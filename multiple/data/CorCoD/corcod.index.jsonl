{"src": "import java.util.HashSet;\nimport java.util.Scanner;\n\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        HashSet<Integer> set = new HashSet<>();\n        for(int i = 0; i<n; i++){\n            int a = sc.nextInt();\n            if(a!=0){\n                set.add(a);\n            }\n        }\n        System.out.println(set.size());\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 1, "index": 1}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class C {\n    static class FastWriter {\n        private final BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int q = fr.nextInt();\n        int[] aa = new int[n - 1];\n        int[] ab = new int[n - 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) dq.addLast(fr.nextInt());\n        for (int i = 0; i < n - 1; i++) {\n            int a = dq.removeFirst();\n            int b = dq.removeFirst();\n            aa[i] = a;\n            ab[i] = b;\n            int mi = Math.min(a, b);\n            int ma = Math.max(a, b);\n            dq.addFirst(ma);\n            dq.addLast(mi);\n        }\n        int fm = dq.removeFirst();\n        int[] arr = new int[n - 1];\n        for (int i = 0; i < arr.length; i++) arr[i] = dq.removeFirst();\n        while (q-- > 0) {\n            long m = fr.nextLong() - 1;\n            if (m < n - 1) {\n                System.out.println(aa[(int) m] + \" \" + ab[(int) m]);\n            } else {\n                m = m % (n - 1);\n                System.out.println(fm + \" \" + arr[(int) m]);\n            }\n        }\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 2, "index": 2}
{"src": "\n// Java program to print boundary traversal of binary tree \n\n/* A binary tree node has data, pointer to left child \n\nand a pointer to right child */\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n// A simple function to print leaf nodes of a binary tree \n\nvoid\nprintLeaves(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nprintLeaves(node.left); \n\n\n// Print it if it is a leaf node \n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintLeaves(node.right); \n\n} \n\n} \n\n\n// A function to print all left boundary nodes, except a leaf node. \n\n// Print the nodes in TOP DOWN manner \n\nvoid\nprintBoundaryLeft(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nif\n(node.left != \nnull\n) { \n\n\n// to ensure top down order, print the node \n\n// before calling itself for left subtree \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintBoundaryLeft(node.left); \n\n} \n\nelse\nif\n(node.right != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintBoundaryLeft(node.right); \n\n} \n\n\n// do nothing if it is a leaf node, this way we avoid \n\n// duplicates in output \n\n} \n\n} \n\n\n// A function to print all right boundary nodes, except a leaf node \n\n// Print the nodes in BOTTOM UP manner \n\nvoid\nprintBoundaryRight(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nif\n(node.right != \nnull\n) { \n\n// to ensure bottom up order, first call for right \n\n// subtree, then print this node \n\nprintBoundaryRight(node.right); \n\nSystem.out.print(node.data + \n\" \"\n); \n\n} \n\nelse\nif\n(node.left != \nnull\n) { \n\nprintBoundaryRight(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\n} \n\n// do nothing if it is a leaf node, this way we avoid \n\n// duplicates in output \n\n} \n\n} \n\n\n// A function to do boundary traversal of a given binary tree \n\nvoid\nprintBoundary(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n// Print the left boundary in top-down manner. \n\nprintBoundaryLeft(node.left); \n\n\n// Print all leaf nodes \n\nprintLeaves(node.left); \n\nprintLeaves(node.right); \n\n\n// Print the right boundary in bottom-up manner \n\nprintBoundaryRight(node.right); \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n20\n); \n\ntree.root.left = \nnew\nNode(\n8\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n12\n); \n\ntree.root.left.right.left = \nnew\nNode(\n10\n); \n\ntree.root.left.right.right = \nnew\nNode(\n14\n); \n\ntree.root.right = \nnew\nNode(\n22\n); \n\ntree.root.right.right = \nnew\nNode(\n25\n); \n\ntree.printBoundary(tree.root); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 3, "index": 3}
{"src": "\t\t\n\t\t\t\t\t\t\timport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\n\t\t\t\t\t\t\t\t\t\t\tpublic class Solution1 implements Runnable\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstatic final long MAX = 1000000007L;\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class InputReader\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate InputStream stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate byte[] buf = new byte[1024];\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int curChar;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int numChars;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate SpaceCharFilter filter;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic InputReader(InputStream stream)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.stream = stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int read()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (numChars==-1) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (curChar >= numChars)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String nextLine()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString str = \"\";\n\t\t\t\t\t\t\t\t\t\t\t            try\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                str = br.readLine();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            catch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                e.printStackTrace();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            return str;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int nextInt()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic long nextLong() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlong res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic double nextDouble() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble m = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm /= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String readString() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res.toString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String next() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn readString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic interface SpaceCharFilter \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t \t\n\t\t\t\t\t\t\t\t\t\t\t\tpublic static void main(String args[]) throws Exception\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Thread(null, new Solution1(),\"Solution1\",1<<26).start();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tlong gcd(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t        if (a == 0)\n\t\t\t\t\t\t\t\t\t\t\t            return b;\n\t\t\t\t\t\t\t\t\t\t\t         \n\t\t\t\t\t\t\t\t\t\t\t        return gcd(b%a, a);\n\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t    // method to return LCM of two numbers\n\t\t\t\t\t\t\t\t\t\t\t\t long lcm(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t\t        return (a*b)/gcd(a, b);\n\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t int root(int a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t while(arr[a] != a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[a] = arr[arr[a]];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t a = arr[a];\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t\t return a;\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t void union(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int xroot = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int yroot = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(arr[xroot] < arr[yroot]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[xroot] = yroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[yroot] = xroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t boolean find(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int roota = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int rootb = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(roota == rootb){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t int[] arr;\n\t\t\t\t\t\t\t\t\t\t\t\t final int level = 20;\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\tpublic void run()\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tInputReader sc= new InputReader(System.in);\n\t\t\t\t\t\t\t\t\t\t\t\t\tPrintWriter w= new PrintWriter(System.out);\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n = sc.nextInt();\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch2 = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tch = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tch2 = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tHashSet<Integer> hset[] = new HashSet[26];\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < 26;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[i]  =new HashSet();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[ch[i]-97].add(ch2[i]-97);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tboolean flag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap1 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap2 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint rem = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].size() != 0){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswap1 = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].contains(ch[i]-97)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trem = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount-=2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(flag){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != swap1 && ch[i] == ch2[swap1] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((swap1+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(rem == -1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(\"-1 -1\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != rem && ch[i] == ch2[rem] && ch[rem] == ch2[i] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((rem+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tboolean fun(long[] prefix,long mid,long temp,long[] arr){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(temp >= prefix[(int)mid]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class Pair implements Comparable<Pair>{\n\t\t\t\t\t\t\t\t\t\t\t\t\tint x;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(){}\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(int x,int y){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int compareTo(Pair p){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn Long.compare(this.x,p.x);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}", "complexity": "linear", "from": "CorCod", "problem": 4, "index": 4}
{"src": "import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class CodeForces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint d = in.nextInt(), sum = in.nextInt();\n\t\tList<Data> data = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < d; ++i) {\n\t\t\tint min = in.nextInt(), max = in.nextInt();\n\t\t\tint centre = (min + max) / 2;\n\t\t\tdata.add(new Data(centre - min, max - centre, centre));\n\t\t\tsum -= centre;\n\t\t}\n\t\t\n\t\tIterator<Data> it = data.iterator();\n\t\t\n\t\twhile (sum != 0) {\n\t\t\tif (!it.hasNext()) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tData da = it.next();\n\n\t\t\tif (sum > 0) {\n\t\t\t\tda.centre += da.above;\n\t\t\t\tsum -= da.above;\n\t\t\t} else {\n\t\t\t\tda.centre -= da.below;\n\t\t\t\tsum += da.below;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n\t\t\n\t\tfor (Data da : data) {\n\t\t\tSystem.out.print(da.centre + \" \");\n\t\t}\n\t}\n}\n\nclass Data {\n\tint below, above, centre;\n\t\n\tData(int below, int above, int centre) {\n\t\tthis.below = below;\n\t\tthis.above = above;\n\t\tthis.centre = centre;\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 5, "index": 5}
{"src": "\n// Java program to find a pair with a given \n// sum in a sorted and rotated array \nclass\nPairInSortedRotated \n{ \n\n// This function returns true if arr[0..n-1] \n\n// has a pair with sum equals to x. \n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n// Find the pivot element \n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n// l is now index of \n\n// smallest element \n\n\nint\nr = i; \n// r is now index of largest \n\n//element \n\n\n// Keep moving either l or r till they meet \n\nwhile\n(l != r) \n\n{ \n\n// If we find a pair with sum x, we \n\n// return true \n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n// If current pair sum is less, move \n\n// to the higher sum \n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n// Move to the lower sum side \n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n} \n/*This code is contributed by Prakriti Gupta*/", "complexity": "linear", "from": "CorCod", "problem": 6, "index": 6}
{"src": "    import java.util.*;\n    import java.io.*;\n    import java.lang.*;\n    import java.math.*;\n    public class B {\n        public static void main(String[] args) throws Exception {\n            BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n            PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n            int n = Integer.parseInt(bf.readLine());\n            StringTokenizer st = new StringTokenizer(bf.readLine());\n            Integer[] a = new Integer[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n            Arrays.sort(a);\n            int[] b = new int[n];\n            for(int i=0; i<n; i++) b[i] = a[i].intValue();\n            boolean diff = false;\n            boolean diff2 = false;\n            Set<Integer> vals = new HashSet<Integer>();\n            vals.add(b[0]);\n            int valval = 0;\n            for(int i=1; i<n; i++) {\n                vals.add(b[i]);\n                if(b[i] == b[i-1]) {\n                    if(!diff) {\n                        diff = true;\n                        valval = b[i];\n                    }\n                    else diff2 = true;\n                }\n            } \n            long sum = 0;\n            for(int i : b) sum += i;\n            sum -= 1L*n*(n-1)/2;\n\n            if(diff && !diff2) {\n                if(!vals.contains((valval-1)) && (valval > 0)) {\n                    if(sum%2 == 0) out.println(\"cslnb\"); else out.println(\"sjfnb\");\n                }\n                else out.println(\"cslnb\");\n            }\n            else if(diff2) out.println(\"cslnb\");\n            else if(sum%2 == 0) out.println(\"cslnb\"); else out.println(\"sjfnb\");\n            // int n = Integer.parseInt(st.nextToken());\n     \n            \n            out.close(); System.exit(0);\n        }\n    }", "complexity": "linear", "from": "CorCod", "problem": 7, "index": 7}
{"src": "import java.util.*;\n\npublic class ehab3 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint n = in.nextInt();\n\tint[] a = new int[n];\n\tfor ( int i = 0; i < n; i++ )\n\t    a[i] = in.nextInt();\n\tSystem.out.println( ( n + 1 ) );\n\tint c = 0;\n\tfor ( int i = n - 1; i >= 0; i-- ) {\n\t    int cd = n + i - ( ( a[i] + c ) % n );\n\t    System.out.println( \"1 \" + ( i + 1 ) + \" \" + cd );\n\t    c += cd;\n\t}\n\tSystem.out.println( \"2 \" + n + \" \" + n );\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 8, "index": 8}
{"src": "\n// Java implementation to find the uncommon \n// characters of the two strings \nclass\nGFG \n{ \n\n\n// size of the hash table \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n// function to find the uncommon \n\n// characters of the two strings \n\nstatic\nvoid\nfindAndPrintUncommonChars(String str1, \n\nString str2) \n\n{ \n\n// mark presence of each character as 0 \n\n// in the hash table 'present[]' \n\nint\npresent[] = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\npresent[i] = \n0\n; \n\n} \n\n\nint\nl1 = str1.length(); \n\nint\nl2 = str2.length(); \n\n\n// for each character of str1, mark its \n\n// presence as 1 in 'present[]' \n\nfor\n(\nint\ni = \n0\n; i < l1; i++) \n\n{ \n\npresent[str1.charAt(i) - \n'a'\n] = \n1\n; \n\n} \n\n\n// for each character of str2 \n\nfor\n(\nint\ni = \n0\n; i < l2; i++) \n\n{ \n\n\n// if a character of str2 is also present \n\n// in str1, then mark its presence as -1 \n\nif\n(present[str2.charAt(i) - \n'a'\n] == \n1\n\n|| present[str2.charAt(i) - \n'a'\n] == -\n1\n) \n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = -\n1\n; \n\n} \n\n\n// else mark its presence as 2 \n\nelse\n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = \n2\n; \n\n} \n\n} \n\n\n// print all the uncommon characters \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\nif\n(present[i] == \n1\n|| present[i] == \n2\n) \n\n{ \n\nSystem.out.print((\nchar\n) (i + \n'a'\n) + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str1 = \n\"characters\"\n; \n\nString str2 = \n\"alphabets\"\n; \n\nfindAndPrintUncommonChars(str1, str2); \n\n} \n} \n\n// This code is contributed by Rajput-JI ", "complexity": "linear", "from": "CorCod", "problem": 9, "index": 9}
{"src": "\n// Java program to find pairs with given sum such \n// that one element of pair exists in one BST and \n// other in other BST. \nimport\njava.util.*; \nclass\nsolution \n{ \n\n// A binary Tree node \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n// A utility function to create a new BST node \n// with key as given num \nstatic\nNode newNode(\nint\nnum) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = num; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n// A utility function to insert a given key to BST \nstatic\nNode insert(Node root, \nint\nkey) \n{ \n\nif\n(root == \nnull\n) \n\nreturn\nnewNode(key); \n\nif\n(root.data > key) \n\nroot.left = insert(root.left, key); \n\nelse\n\nroot.right = insert(root.right, key); \n\nreturn\nroot; \n} \n\n// store storeInorder traversal in auxiliary array \nstatic\nvoid\nstoreInorder(Node ptr, Vector<Integer> vect) \n{ \n\nif\n(ptr==\nnull\n) \n\nreturn\n; \n\nstoreInorder(ptr.left, vect); \n\nvect.add(ptr.data); \n\nstoreInorder(ptr.right, vect); \n} \n\n// Function to find pair for given sum in different bst \n// vect1.get() -. stores storeInorder traversal of first bst \n// vect2.get() -. stores storeInorder traversal of second bst \nstatic\nvoid\npairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, \n\nint\nsum) \n{ \n\n// Initialize two indexes to two different corners \n\n// of two Vectors. \n\nint\nleft = \n0\n; \n\nint\nright = vect2.size() - \n1\n; \n\n\n// find pair by moving two corners. \n\nwhile\n(left < vect1.size() && right >= \n0\n) \n\n{ \n\n// If we found a pair \n\nif\n(vect1.get(left) + vect2.get(right) == sum) \n\n{ \n\nSystem.out.print( \n\"(\"\n+vect1.get(left) + \n\", \"\n+ vect2.get(right) + \n\"), \"\n); \n\nleft++; \n\nright--; \n\n} \n\n\n// If sum is more, move to higher value in \n\n// first Vector. \n\nelse\nif\n(vect1.get(left) + vect2.get(right) < sum) \n\nleft++; \n\n\n// If sum is less, move to lower value in \n\n// second Vector. \n\nelse\n\nright--; \n\n} \n} \n\n// Prints all pairs with given \"sum\" such that one \n// element of pair is in tree with root1 and other \n// node is in tree with root2. \nstatic\nvoid\npairSum(Node root1, Node root2, \nint\nsum) \n{ \n\n// Store inorder traversals of two BSTs in two \n\n// Vectors. \n\nVector<Integer> vect1= \nnew\nVector<Integer>(), vect2= \nnew\nVector<Integer>(); \n\nstoreInorder(root1, vect1); \n\nstoreInorder(root2, vect2); \n\n\n// Now the problem reduces to finding a pair \n\n// with given sum such that one element is in \n\n// vect1 and other is in vect2. \n\npairSumUtil(vect1, vect2, sum); \n} \n\n// Driver program to run the case \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n// first BST \n\nNode root1 = \nnull\n; \n\nroot1 = insert(root1, \n8\n); \n\nroot1 = insert(root1, \n10\n); \n\nroot1 = insert(root1, \n3\n); \n\nroot1 = insert(root1, \n6\n); \n\nroot1 = insert(root1, \n1\n); \n\nroot1 = insert(root1, \n5\n); \n\nroot1 = insert(root1, \n7\n); \n\nroot1 = insert(root1, \n14\n); \n\nroot1 = insert(root1, \n13\n); \n\n\n// second BST \n\nNode root2 = \nnull\n; \n\nroot2 = insert(root2, \n5\n); \n\nroot2 = insert(root2, \n18\n); \n\nroot2 = insert(root2, \n2\n); \n\nroot2 = insert(root2, \n1\n); \n\nroot2 = insert(root2, \n3\n); \n\nroot2 = insert(root2, \n4\n); \n\n\nint\nsum = \n10\n; \n\npairSum(root1, root2, sum); \n} \n} \n//contributed by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 10, "index": 10}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF1082D {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint[] aa = new int[n];\n\t\tint[] i1 = new int[n];\n\t\tint[] i2 = new int[n];\n\t\tint n1 = 0, n2 = 0, m2 = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = Integer.parseInt(st.nextToken());\n\t\t\taa[i] = a;\n\t\t\tif (a == 1)\n\t\t\t\ti1[n1++] = i;\n\t\t\telse {\n\t\t\t\ti2[n2++] = i;\n\t\t\t\tm2 += a;\n\t\t\t}\n\t\t}\n\t\tif (m2 < (n2 - 1) * 2 + n1) {\n\t\t\tSystem.out.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tint m = n2 - 1 + n1;\n\t\tint d = n2 - 1 + Math.min(n1, 2);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tpw.println(\"YES \" + d);\n\t\tpw.println(m);\n\t\tfor (int i = 0; i + 1 < n2; i++) {\n\t\t\tpw.println((i2[i] + 1) + \" \" + (i2[i + 1] + 1));\n\t\t\taa[i2[i]]--; aa[i2[i + 1]]--;\n\t\t}\n\t\tif (n1 > 0) {\n\t\t\twhile (n2 > 0 && aa[i2[n2 - 1]] == 0)\n\t\t\t\tn2--;\n\t\t\tpw.println((i2[n2 - 1] + 1) + \" \" + (i1[n1 - 1] + 1));\n\t\t\taa[i2[n2 - 1]]--;\n\t\t\tn1--;\n\t\t}\n\t\tfor (int i = 0, j = 0; j < n1; j++) {\n\t\t\twhile (aa[i2[i]] == 0)\n\t\t\t\ti++;\n\t\t\tpw.println((i2[i] + 1) + \" \" + (i1[j] + 1));\n\t\t\taa[i2[i]]--;\n\t\t}\n\t\tpw.close();\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 11, "index": 11}
{"src": "\n// Java implementation to check if the given array \n// can represent Level Order Traversal of Binary \n// Search Tree \nimport\njava.util.*; \n\nclass\nSolution \n{ \n\n// to store details of a node like \n// node's data, 'min' and 'max' to obtain the \n// range of values where node's left and \n// right child's should lie \nstatic\nclass\nNodeDetails \n{ \n\nint\ndata; \n\nint\nmin, max; \n}; \n\n// function to check if the given array \n// can represent Level Order Traversal \n// of Binary Search Tree \nstatic\nboolean\nlevelOrderIsOfBST(\nint\narr[], \nint\nn) \n{ \n\n// if tree is empty \n\nif\n(n == \n0\n) \n\nreturn\ntrue\n; \n\n\n// queue to store NodeDetails \n\nQueue<NodeDetails> q = \nnew\nLinkedList<NodeDetails>(); \n\n\n// index variable to access array elements \n\nint\ni = \n0\n; \n\n\n// node details for the \n\n// root of the BST \n\nNodeDetails newNode=\nnew\nNodeDetails(); \n\nnewNode.data = arr[i++]; \n\nnewNode.min = Integer.MIN_VALUE; \n\nnewNode.max = Integer.MAX_VALUE; \n\nq.add(newNode); \n\n\n// until there are no more elements \n\n// in arr[] or queue is not empty \n\nwhile\n(i != n && q.size() > \n0\n) \n\n{ \n\n// extracting NodeDetails of a \n\n// node from the queue \n\nNodeDetails temp = q.peek(); \n\nq.remove(); \n\nnewNode = \nnew\nNodeDetails(); \n\n\n// check whether there are more elements \n\n// in the arr[] and arr[i] can be left child \n\n// of 'temp.data' or not \n\nif\n(i < n && (arr[i] < (\nint\n)temp.data && \n\narr[i] > (\nint\n)temp.min)) \n\n{ \n\n// Create NodeDetails for newNode \n\n/// and add it to the queue \n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.min; \n\nnewNode.max = temp.data; \n\nq.add(newNode); \n\n} \n\n\nnewNode=\nnew\nNodeDetails(); \n\n\n// check whether there are more elements \n\n// in the arr[] and arr[i] can be right child \n\n// of 'temp.data' or not \n\nif\n(i < n && (arr[i] > (\nint\n)temp.data && \n\narr[i] < (\nint\n)temp.max)) \n\n{ \n\n// Create NodeDetails for newNode \n\n/// and add it to the queue \n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.data; \n\nnewNode.max = temp.max; \n\nq.add(newNode); \n\n} \n\n} \n\n\n// given array represents level \n\n// order traversal of BST \n\nif\n(i == n) \n\nreturn\ntrue\n; \n\n\n// given array do not represent \n\n// level order traversal of BST \n\nreturn\nfalse\n; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n7\n, \n4\n, \n12\n, \n3\n, \n6\n, \n8\n, \n1\n, \n5\n, \n10\n}; \n\nint\nn = arr.length; \n\nif\n(levelOrderIsOfBST(arr, n)) \n\nSystem.out.print( \n\"Yes\"\n); \n\nelse\n\nSystem.out.print( \n\"No\"\n); \n\n} \n} \n\n// This code is contributed by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 12, "index": 12}
{"src": "import java.util.Scanner;\n \npublic class pillar {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint a[]=new int[200005];\n\t\tfor (int i=1;i<=n;i++) \n\t\ta[i]=sc.nextInt();\n\t\tfor (int i=2;i<n;i++) \n\t\tif (a[i-1]>a[i]&&a[i]<a[i+1]) {\n\t\t\tSystem.out.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 13, "index": 13}
{"src": "\n// Java program to find smallest \n// number to find smallest number \n// with N as sum of digits and \n// divisible by 10^N. \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nvoid\ndigitsNum(\nint\nN) \n{ \n\n// If N = 0 the string will be 0 \n\nif\n(N == \n0\n) \n\nSystem.out.println(\n\"0\"\n); \n\n\n\n// If n is not perfectly divisible \n\n// by 9 output the remainder \n\nif\n(N % \n9\n!= \n0\n) \n\nSystem.out.print((N % \n9\n)); \n\n\n\n// Print 9 N/9 times \n\nfor\n(\nint\ni = \n1\n; i <= (N / \n9\n); ++i) \n\nSystem.out.print(\n\"9\"\n); \n\n\n\n// Append N zero's to the number so \n\n// as to make it divisible by 10^N \n\nfor\n(\nint\ni = \n1\n; i <= N; ++i) \n\nSystem.out.print(\n\"0\"\n); \n\nSystem.out.print(\n\"\"\n); \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nN = \n5\n; \n\nSystem.out.print(\n\"The number is : \"\n); \n\ndigitsNum(N); \n\n} \n} \n\n// This code is contributed by vt_m ", "complexity": "linear", "from": "CorCod", "problem": 14, "index": 14}
{"src": "\n// Java program for nth nodes of inorder traversals \n\nimport\njava.util. *; \n\nclass\nSolution \n{ \nstatic\nint\ncount =\n0\n; \n/* A binary tree node has data, pointer to left child \nand a pointer to right child */\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n} \n\n/* Helper function that allocates a new node with the \ngiven data and null left and right pointers. */\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\n\nreturn\n(node); \n} \n\n\n/* Given a binary tree, print its nth nodes of inorder*/\nstatic\nvoid\nNthInorder( Node node, \nint\nn) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\nif\n(count <= n) { \n\n/* first recur on left child */\n\nNthInorder(node.left, n); \n\ncount++; \n\n\n// when count = n then print element \n\nif\n(count == n) \n\nSystem.out.printf(\n\"%d \"\n, node.data); \n\n\n/* now recur on right child */\n\nNthInorder(node.right, n); \n\n} \n} \n\n/* Driver program to test above functions*/\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n10\n); \n\nroot.left = newNode(\n20\n); \n\nroot.right = newNode(\n30\n); \n\nroot.left.left = newNode(\n40\n); \n\nroot.left.right = newNode(\n50\n); \n\n\nint\nn = \n4\n; \n\n\nNthInorder(root, n); \n} \n} \n\n// This code is contributed \n// by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 15, "index": 15}
{"src": "\n// Java program to find smallest and second smallest elements \nimport\njava.io.*; \n\nclass\nSecondSmallest \n{ \n\n/* Function to print first smallest and second smallest \n\nelements */\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n/* There should be atleast two elements */\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n/* If current element is smaller than first \n\nthen update both first and second */\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n/* If arr[i] is in between first and second \n\nthen update second */\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "complexity": "linear", "from": "CorCod", "problem": 16, "index": 16}
{"src": "import java.util.*;\n \npublic class Main{\n    private static final int MAX_SIZE = 100005;\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        if(((m + 1) / 60 < a) || ((m + 1) / 60 == a && (m + 1) % 60 <= b)) {\n            out(0, 0);\n            System.exit(0);\n        }\n        for(int i = 2; i <= n; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n\n            int bb = b + 2 * m + 2;\n            int aa = a + bb / 60;\n            bb %= 60;\n\n            if((aa < x) || (aa == x && bb <= y)) {\n                b = b + m + 1;\n                a = a + b / 60;\n                b %= 60;\n                out(a, b);\n                System.exit(0);\n            }\n            a = x;\n            b = y;\n        }\n        b = b + m + 1;\n        a = a + b / 60;\n        b = b % 60;        \n        out(a, b);\n    }\n\n    private static void out(int a, int b) {\n        cout(a);\n        cout(\" \");\n        cout(b);\n    }\n\n    private static void cout(Object a) {\n        System.out.print(a);\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 17, "index": 17}
{"src": "\nclass\nMain \n{ \n\n/* Function to get index of ceiling \n\nof x in arr[low..high] */\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\ni; \n\n\n/* If x is smaller than or equal to first \n\nelement,then return the first element */\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n/* Otherwise, linearly search for ceil value */\n\nfor\n(i = low; i < high; i++) \n\n{ \n\nif\n(arr[i] == x) \n\nreturn\ni; \n\n\n/* if x lies between arr[i] and arr[i+1] \n\nincluding arr[i+1], then return arr[i+1] */\n\nif\n(arr[i] < x && arr[i+\n1\n] >= x) \n\nreturn\ni+\n1\n; \n\n} \n\n\n/* If we reach here then x is greater than the \n\nlast element of the array, return -1 in this case */\n\nreturn\n-\n1\n; \n\n} \n\n\n\n/* Driver program to check above functions */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 18, "index": 18}
{"src": "import java.util.*;\n\npublic class MyClass {\n    public static void main(String args[]) {\n        Scanner sc= new Scanner(System.in);\n        int n=sc.nextInt();\n        int [] a= new int[n];\n        int k=0;\n        int m=0;\n        for (int i=0;i<n;i++){\n            a[i]=sc.nextInt();\n            if (a[i]>=0){\n                a[i]=-a[i]-1;\n            }\n            if (a[i]<m){\n                m=a[i];\n                k=i;\n            }\n        }\n        if (n%2==1){\n            a[k]=-a[k]-1;\n        }\n        for (int i=0;i<n;i++){\n            System.out.print(a[i]+\" \");\n        }\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 19, "index": 19}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SFly {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader lector = new BufferedReader(new InputStreamReader(System.in));\n\t\tint planet = Integer.parseInt(lector.readLine());\n\t\tint ini = Integer.parseInt(lector.readLine());\n\t\tdouble peso = ini;\n\t\tint[] desp = new int[planet];\n\t\tint[] ater = new int[planet];\n\t\tString[] temp = lector.readLine().split(\" \");\t\t\n\t\tfor(int i=0; i<planet; i++) {\n\t\t\tdesp[i] = Integer.parseInt(temp[i]);\n\t\t\tif(desp[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = lector.readLine().split(\" \");\t\t\n\t\tfor(int i=0; i<planet; i++) {\n\t\t\tater[i] = Integer.parseInt(temp[i]);\n\t\t\tif(ater[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = null;\n\t\tint i=planet-1;\n\t\tpeso = (peso*ater[0])/(ater[0]-1);\n\t\twhile(i>0) {\n\t\t\tpeso = (peso*desp[i])/(desp[i]-1);\n\t\t\tpeso = (peso*ater[i])/(ater[i]-1);\n\t\t\ti--;\n\t\t}\n\t\tpeso = (peso*desp[0])/(desp[0]-1);\n\t\tpeso = peso - ini;\n\t\tSystem.out.println(peso);\n\t\tlector.close();\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 20, "index": 20}
{"src": "\n// Java program to find maximum average subarray \n// of given length. \n\nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Returns beginning index of maximum average \n\n// subarray of length 'k' \n\nstatic\nint\nfindMaxAverage(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n// Check if 'k' is valid \n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n// Compute sum of first 'k' elements \n\nint\nsum = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < k; i++) \n\nsum += arr[i]; \n\n\nint\nmax_sum = sum, max_end = k-\n1\n; \n\n\n// Compute sum of remaining subarrays \n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nsum = sum + arr[i] - arr[i-k]; \n\nif\n(sum > max_sum) \n\n{ \n\nmax_sum = sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n// Return starting index \n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.println( \n\"The maximum average\"\n\n+ \n\" subarray of length \"\n+ k \n\n+ \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "complexity": "linear", "from": "CorCod", "problem": 21, "index": 21}
{"src": "\n// Java implementation to print the path from root \n// to a given node in a binary tree \nimport\njava.util.ArrayList; \npublic\nclass\nPrintPath { \n\n\n// Returns true if there is a path from root \n\n// to the given node. It also populates \n\n// 'arr' with the given path \n\npublic\nstatic\nboolean\nhasPath(Node root, ArrayList<Integer> arr, \nint\nx) \n\n{ \n\n// if root is NULL \n\n// there is no path \n\nif\n(root==\nnull\n) \n\nreturn\nfalse\n; \n\n\n// push the node's value in 'arr' \n\narr.add(root.data); \n\n\n// if it is the required node \n\n// return true \n\nif\n(root.data == x) \n\nreturn\ntrue\n; \n\n\n// else check whether the required node lies \n\n// in the left subtree or right subtree of \n\n// the current node \n\nif\n(hasPath(root.left, arr, x) || \n\nhasPath(root.right, arr, x)) \n\nreturn\ntrue\n; \n\n\n// required node does not lie either in the \n\n// left or right subtree of the current node \n\n// Thus, remove current node's value from \n\n// 'arr'and then return false \n\narr.remove(arr.size()-\n1\n); \n\nreturn\nfalse\n; \n\n} \n\n\n// function to print the path from root to the \n\n// given node if the node lies in the binary tree \n\npublic\nstatic\nvoid\nprintPath(Node root, \nint\nx) \n\n{ \n\n// ArrayList to store the path \n\nArrayList<Integer> arr=\nnew\nArrayList<>(); \n\n\n// if required node 'x' is present \n\n// then print the path \n\nif\n(hasPath(root, arr, x)) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i<arr.size()-\n1\n; i++) \n\nSystem.out.print(arr.get(i)+\n\"->\"\n); \n\nSystem.out.print(arr.get(arr.size() - \n1\n)); \n\n} \n\n\n// 'x' is not present in the binary tree \n\nelse\n\nSystem.out.print(\n\"No Path\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.left = \nnew\nNode(\n6\n); \n\nroot.right.right = \nnew\nNode(\n7\n); \n\nint\nx=\n5\n; \n\nprintPath(root, x); \n\n} \n} \n\n// A node of binary tree \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\nleft=right=\nnull\n; \n\n} \n}; \n//This code is contributed by Gaurav Tiwari ", "complexity": "linear", "from": "CorCod", "problem": 22, "index": 22}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class SonyaExhibition {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt();\n\t\tint[] arr = {0,1};\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tSystem.out.print(arr[i % 2]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 23, "index": 23}
{"src": "\n// Java code to find maximum triplet sum \nimport\njava.io.*; \nimport\njava.util.*; \n\n\nclass\nGFG { \n\n\n// This function assumes that there \n\n// are at least three elements in arr[]. \n\nstatic\nint\nmaxTripletSum(\nint\narr[], \nint\nn) \n\n{ \n\n// Initialize Maximum, second maximum and third \n\n// maximum element \n\nint\nmaxA = -\n100000000\n, maxB = -\n100000000\n; \n\nint\nmaxC = -\n100000000\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// Update Maximum, second maximum \n\n// and third maximum element \n\nif\n(arr[i] > maxA) \n\n{ \n\nmaxC = maxB; \n\nmaxB = maxA; \n\nmaxA = arr[i]; \n\n} \n\n\n// Update second maximum and third maximum \n\n// element \n\nelse\nif\n(arr[i] > maxB) \n\n{ \n\nmaxC = maxB; \n\nmaxB = arr[i]; \n\n} \n\n\n// Update third maximum element \n\nelse\nif\n(arr[i] > maxC) \n\nmaxC = arr[i]; \n\n} \n\n\nreturn\n(maxA + maxB + maxC); \n\n} \n\n\n// Driven code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n0\n, \n8\n, \n6\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxTripletSum(arr, n)); \n\n} \n} \n\n\n// This code is contributed by Nikita Tiwari. ", "complexity": "linear", "from": "CorCod", "problem": 24, "index": 24}
{"src": "\n// Java program to check if there exist an edge whose \n// removal creates two trees of same size \n\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nRes \n{ \n\nboolean\nres = \nfalse\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n// To calculate size of tree with given root \n\nint\ncount(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\nreturn\ncount(node.left) + count(node.right) + \n1\n; \n\n} \n\n\n// This function returns size of tree rooted with given \n\n// root. It also set \"res\" as true if there is an edge \n\n// whose removal divides tree in two halves. \n\n// n is size of tree \n\nint\ncheckRec(Node root, \nint\nn, Res res) \n\n{ \n\n// Base case \n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\n\n// Compute sizes of left and right children \n\nint\nc = checkRec(root.left, n, res) + \n1\n\n+ checkRec(root.right, n, res); \n\n\n// If required property is true for current node \n\n// set \"res\" as true \n\nif\n(c == n - c) \n\nres.res = \ntrue\n; \n\n\n// Return size \n\nreturn\nc; \n\n} \n\n\n// This function mainly uses checkRec() \n\nboolean\ncheck(Node root) \n\n{ \n\n// Count total nodes in given tree \n\nint\nn = count(root); \n\n\n// Initialize result and recursively check all nodes \n\nRes res = \nnew\nRes(); \n\ncheckRec(root, n, res); \n\n\nreturn\nres.res; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n1\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nif\n(tree.check(tree.root) == \ntrue\n) \n\nSystem.out.println(\n\"YES\"\n); \n\nelse\n\nSystem.out.println(\n\"NO\"\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "linear", "from": "CorCod", "problem": 25, "index": 25}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 26, "index": 26}
{"src": "\n// Java program to find number of operations \n// to make an array palindrome \n\nclass\nGFG \n{ \n\n// Returns minimum number of count operations \n\n// required to make arr[] palindrome \n\nstatic\nint\nfindMinOps(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\nans = \n0\n; \n// Initialize result \n\n\n// Start from two corners \n\nfor\n(\nint\ni=\n0\n,j=n-\n1\n; i<=j;) \n\n{ \n\n// If corner elements are same, \n\n// problem reduces arr[i+1..j-1] \n\nif\n(arr[i] == arr[j]) \n\n{ \n\ni++; \n\nj--; \n\n} \n\n\n// If left element is greater, then \n\n// we merge right two elements \n\nelse\nif\n(arr[i] > arr[j]) \n\n{ \n\n// need to merge from tail. \n\nj--; \n\narr[j] += arr[j+\n1\n] ; \n\nans++; \n\n} \n\n\n// Else we merge left two elements \n\nelse\n\n{ \n\ni++; \n\narr[i] += arr[i-\n1\n]; \n\nans++; \n\n} \n\n} \n\n\nreturn\nans; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n4\n, \n5\n, \n9\n, \n1\n} ; \n\nSystem.out.println(\n\"Count of minimum operations is \"\n+ \n\nfindMinOps(arr, arr.length)); \n\n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 27, "index": 27}
{"src": "import java.util.*;\n \npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\t int[][] x = new int [200010][10];\n     String a = sc.nextLine(); \n     String b = sc.nextLine(); \n \t  int n = a.length();\n\t  int m = b.length();\n       for (int i = 1; i <= m; i++) {\n         for (int j = 0; j < 2; j++) {\n           x[i][j] = x[i - 1][j];\n         }\n         ++x[i][b.charAt(i - 1) - '0'];\n       }\n       long res = 0;\n        for (int i = 0, c; i < n; i++) {\n          c = a.charAt(i) - '0';\n           for (int j = 0; j < 2; j++) {\n             res += Math.abs(c - j) * (x[m - n + i + 1][j] - x[i][j]);\n           }\n        }\n         System.out.println(res);\n  }\n}", "complexity": "linear", "from": "CorCod", "problem": 28, "index": 28}
{"src": "\n// Java program to find a pair with a given \n// sum in a sorted and rotated array \nclass\nPairInSortedRotated \n{ \n\n// This function returns true if arr[0..n-1] \n\n// has a pair with sum equals to x. \n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n// Find the pivot element \n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n// l is now index of \n\n// smallest element \n\n\nint\nr = i; \n// r is now index of largest \n\n//element \n\n\n// Keep moving either l or r till they meet \n\nwhile\n(l != r) \n\n{ \n\n// If we find a pair with sum x, we \n\n// return true \n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n// If current pair sum is less, move \n\n// to the higher sum \n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n// Move to the lower sum side \n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n} \n/*This code is contributed by Prakriti Gupta*/", "complexity": "linear", "from": "CorCod", "problem": 29, "index": 29}
{"src": "\n/* Java program to check if linked list is palindrome recursively */\n\nclass\nLinkedList { \n\nNode head; \n// head of list \n\nNode left; \n\n\n/* Linked list Node*/\n\nclass\nNode { \n\nchar\ndata; \n\nNode next; \n\n\nNode(\nchar\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n// Initial parameters to this function are &head and head \n\nboolean\nisPalindromeUtil(Node right) \n\n{ \n\nleft = head; \n\n\n/* stop recursion when right becomes NULL */\n\nif\n(right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n/* If sub-list is not palindrome then no need to \n\ncheck for current left and right, return false */\n\nboolean\nisp = isPalindromeUtil(right.next); \n\nif\n(isp == \nfalse\n) \n\nreturn\nfalse\n; \n\n\n/* Check values at current left and right */\n\nboolean\nisp1 = (right.data == (left).data); \n\n\n/* Move left to next node */\n\nleft = left.next; \n\n\nreturn\nisp1; \n\n} \n\n\n// A wrapper over isPalindromeUtil() \n\nboolean\nisPalindrome(Node head) \n\n{ \n\nboolean\nresult = isPalindromeUtil(head); \n\nreturn\nresult; \n\n} \n\n\n/* Push a node to linked list. Note that this function \n\nchanges the head */\n\npublic\nvoid\npush(\nchar\nnew_data) \n\n{ \n\n/* Allocate the Node & \n\nPut in the data */\n\nNode new_node = \nnew\nNode(new_data); \n\n\n/* link the old list off the new one */\n\nnew_node.next = head; \n\n\n/* Move the head to point to new Node */\n\nhead = new_node; \n\n} \n\n\n// A utility function to print a given linked list \n\nvoid\nprintList(Node ptr) \n\n{ \n\nwhile\n(ptr != \nnull\n) { \n\nSystem.out.print(ptr.data + \n\"->\"\n); \n\nptr = ptr.next; \n\n} \n\nSystem.out.println(\n\"NULL\"\n); \n\n} \n\n\n/* Driver program to test the above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n/* Start with the empty list */\n\nLinkedList llist = \nnew\nLinkedList(); \n\n\nchar\nstr[] = { \n'a'\n, \n'b'\n, \n'a'\n, \n'c'\n, \n'a'\n, \n'b'\n, \n'a'\n}; \n\nString string = \nnew\nString(str); \n\nfor\n(\nint\ni = \n0\n; i < \n7\n; i++) { \n\nllist.push(str[i]); \n\nllist.printList(llist.head); \n\nif\n(llist.isPalindrome(llist.head) != \nfalse\n) { \n\nSystem.out.println(\n\"Is Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"Not Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n} \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "linear", "from": "CorCod", "problem": 30, "index": 30}
{"src": "\n// Java code to rearrange an array such \n// that even index elements are smaller \n// and odd index elements are greater \n// than their next. \n\nclass\nGFG { \n\n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\nint\ntemp; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) { \n\nif\n(i % \n2\n== \n0\n&& arr[i] > arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\nif\n(i % \n2\n!= \n0\n&& arr[i] < arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\n} \n\n} \n\n\n/* Utility that prints out an array in \n\na line */\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n6\n, \n4\n, \n2\n, \n1\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.print(\n\"Before rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"After rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "linear", "from": "CorCod", "problem": 31, "index": 31}
{"src": "\n// Java program to find the maximum \n// sum such that no three are \n// consecutive using recursion. \nimport\njava.util.Arrays; \n\nclass\nGFG \n{ \n\nstatic\nint\narr[] = {\n100\n, \n1000\n, \n100\n, \n1000\n, \n1\n}; \nstatic\nint\nsum[] = \nnew\nint\n[\n10000\n]; \n\n// Returns maximum subsequence \n// sum such that no three \n// elements are consecutive \nstatic\nint\nmaxSumWO3Consec(\nint\nn) \n{ \n\nif\n(sum[n] != -\n1\n) \n\nreturn\nsum[n]; \n\n\n//Base cases (process first three elements) \n\n\nif\n(n == \n0\n) \n\nreturn\nsum[n] = \n0\n; \n\n\nif\n(n == \n1\n) \n\nreturn\nsum[n] = arr[\n0\n]; \n\n\nif\n(n == \n2\n) \n\nreturn\nsum[n] = arr[\n1\n] + arr[\n0\n]; \n\n\n// Process rest of the elements \n\n// We have three cases \n\nreturn\nsum[n] = Math.max(Math.max(maxSumWO3Consec(n - \n1\n), \n\nmaxSumWO3Consec(n - \n2\n) + arr[n - \n1\n]), \n\narr[n - \n2\n] + arr[n - \n1\n] + maxSumWO3Consec(n - \n3\n)); \n\n\n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = arr.length; \n\nArrays.fill(sum, -\n1\n); \n\nSystem.out.println(maxSumWO3Consec(n)); \n} \n} \n\n// This code is contributed by Rajput-Ji ", "complexity": "linear", "from": "CorCod", "problem": 32, "index": 32}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class Main\n{\n    static final long mod=(int)1e9+7;\n    public static void main(String[] args) throws Exception\n    {\n    \tFastReader in=new FastReader();\n    \tPrintWriter pw=new PrintWriter(System.out);\n    \tint n=in.nextInt();\n    \tlong ans=0;\n    \tfor(int i=2;2*i<=n;i++)\n    \t{\n    \t\tans+=i*(n/i-1);\n    \t}\n    \tans*=4;\n    \tpw.print(ans);\n    \tpw.flush();\n    }\n}\n\nclass pair\n{\n\tint f,s;\n}\n\nclass FastReader\n{\n    BufferedReader br;\n    StringTokenizer st;\n \n    public FastReader()\n    {\n        br=new BufferedReader(new InputStreamReader(System.in));\n    }\n \n    public String next() throws IOException\n    {\n        if(st==null || !st.hasMoreElements())\n        {\n            st=new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n \n    public int nextInt() throws IOException\n    {\n        return Integer.parseInt(next());\n    }\n \n    public long nextLong() throws IOException\n    {\n        return Long.parseLong(next());\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 33, "index": 33}
{"src": "\n// Java program to construct binary tree from \n// given array in level order fashion \n\npublic\nclass\nTree { \n\nNode root; \n\n\n// Tree Node \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.left = \nnull\n; \n\nthis\n.right = \nnull\n; \n\n} \n\n} \n\n\n// Function to insert nodes in level order \n\npublic\nNode insertLevelOrder(\nint\n[] arr, Node root, \n\nint\ni) \n\n{ \n\n// Base case for recursion \n\nif\n(i < arr.length) { \n\nNode temp = \nnew\nNode(arr[i]); \n\nroot = temp; \n\n\n// insert left child \n\nroot.left = insertLevelOrder(arr, root.left, \n\n2\n* i + \n1\n); \n\n\n// insert right child \n\nroot.right = insertLevelOrder(arr, root.right, \n\n2\n* i + \n2\n); \n\n} \n\nreturn\nroot; \n\n} \n\n\n// Function to print tree nodes in InOrder fashion \n\npublic\nvoid\ninOrder(Node root) \n\n{ \n\nif\n(root != \nnull\n) { \n\ninOrder(root.left); \n\nSystem.out.print(root.data + \n\" \"\n); \n\ninOrder(root.right); \n\n} \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nTree t2 = \nnew\nTree(); \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n6\n, \n6\n, \n6\n}; \n\nt2.root = t2.insertLevelOrder(arr, t2.root, \n0\n); \n\nt2.inOrder(t2.root); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 34, "index": 34}
{"src": "\n// Java implementation of worst \n// case linear time algorithm \n// to find k'th smallest element \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// int partition(int arr[], int l, int r, int k); \n\n// A simple function to find median of arr[]. This is called \n// only for an array of size 5 in this program. \nstatic\nint\nfindMedian(\nint\narr[], \nint\ni,\nint\nn) \n{ \n\nif\n(i <= n) \n\nArrays.sort(arr, i, n); \n// Sort the array \n\nelse\n\nArrays.sort(arr, n, i); \n\nreturn\narr[n/\n2\n]; \n// Return middle element \n} \n\n// Returns k'th smallest element \n// in arr[l..r] in worst case \n// linear time. ASSUMPTION: ALL \n// ELEMENTS IN ARR[] ARE DISTINCT \nstatic\nint\nkthSmallest(\nint\narr[], \nint\nl, \nint\nr, \nint\nk) \n{ \n\n// If k is smaller than \n\n// number of elements in array \n\nif\n(k > \n0\n&& k <= r - l + \n1\n) \n\n{ \n\nint\nn = r - l + \n1\n; \n// Number of elements in arr[l..r] \n\n\n// Divide arr[] in groups of size 5, \n\n// calculate median of every group \n\n// and store it in median[] array. \n\nint\ni; \n\n\n// There will be floor((n+4)/5) groups; \n\nint\n[]median = \nnew\nint\n[(n + \n4\n) / \n5\n]; \n\nfor\n(i = \n0\n; i < n/\n5\n; i++) \n\nmedian[i] = findMedian(arr,l + i * \n5\n, \n5\n); \n\n\n// For last group with less than 5 elements \n\nif\n(i*\n5\n< n) \n\n{ \n\nmedian[i] = findMedian(arr,l + i * \n5\n, n % \n5\n); \n\ni++; \n\n} \n\n\n// Find median of all medians using recursive call. \n\n// If median[] has only one element, then no need \n\n// of recursive call \n\nint\nmedOfMed = (i == \n1\n)? median[i - \n1\n]: \n\nkthSmallest(median, \n0\n, i - \n1\n, i / \n2\n); \n\n\n// Partition the array around a random element and \n\n// get position of pivot element in sorted array \n\nint\npos = partition(arr, l, r, medOfMed); \n\n\n// If position is same as k \n\nif\n(pos-l == k - \n1\n) \n\nreturn\narr[pos]; \n\nif\n(pos-l > k - \n1\n) \n// If position is more, recur for left \n\nreturn\nkthSmallest(arr, l, pos - \n1\n, k); \n\n\n// Else recur for right subarray \n\nreturn\nkthSmallest(arr, pos + \n1\n, r, k - pos + l - \n1\n); \n\n} \n\n\n// If k is more than number of elements in array \n\nreturn\nInteger.MAX_VALUE; \n} \n\nstatic\nint\n[] swap(\nint\n[]arr, \nint\ni, \nint\nj) \n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n} \n\n// It searches for x in arr[l..r], and \n// partitions the array around x. \nstatic\nint\npartition(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n{ \n\n// Search for x in arr[l..r] and move it to end \n\nint\ni; \n\nfor\n(i = l; i < r; i++) \n\nif\n(arr[i] == x) \n\nbreak\n; \n\nswap(arr, i, r); \n\n\n// Standard partition algorithm \n\ni = l; \n\nfor\n(\nint\nj = l; j <= r - \n1\n; j++) \n\n{ \n\nif\n(arr[j] <= x) \n\n{ \n\nswap(arr, i, j); \n\ni++; \n\n} \n\n} \n\nswap(arr, i, r); \n\nreturn\ni; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n12\n, \n3\n, \n5\n, \n7\n, \n4\n, \n19\n, \n26\n}; \n\nint\nn = arr.length, k = \n3\n; \n\nSystem.out.println(\n\"K'th smallest element is \"\n\n+ kthSmallest(arr, \n0\n, n - \n1\n, k)); \n} \n} \n\n// This code has been contributed by 29AjayKumar ", "complexity": "linear", "from": "CorCod", "problem": 35, "index": 35}
{"src": "\n// Java program to create complete Binary Tree from its Linked List \n// representation \n\n// importing necessary classes \nimport\njava.util.*; \n\n// A linked list node \nclass\nListNode \n{ \n\nint\ndata; \n\nListNode next; \n\nListNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n} \n\n// A binary tree node \nclass\nBinaryTreeNode \n{ \n\nint\ndata; \n\nBinaryTreeNode left, right = \nnull\n; \n\nBinaryTreeNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nListNode head; \n\nBinaryTreeNode root; \n\n\n// Function to insert a node at the beginning of \n\n// the Linked List \n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n// allocate node and assign data \n\nListNode new_node = \nnew\nListNode(new_data); \n\n\n// link the old list off the new node \n\nnew_node.next = head; \n\n\n// move the head to point to the new node \n\nhead = new_node; \n\n} \n\n\n// converts a given linked list representing a \n\n// complete binary tree into the linked \n\n// representation of binary tree. \n\nBinaryTreeNode convertList2Binary(BinaryTreeNode node) \n\n{ \n\n// queue to store the parent nodes \n\nQueue<BinaryTreeNode> q = \n\nnew\nLinkedList<BinaryTreeNode>(); \n\n\n// Base Case \n\nif\n(head == \nnull\n) \n\n{ \n\nnode = \nnull\n; \n\nreturn\nnull\n; \n\n} \n\n\n// 1.) The first node is always the root node, and \n\n// add it to the queue \n\nnode = \nnew\nBinaryTreeNode(head.data); \n\nq.add(node); \n\n\n// advance the pointer to the next node \n\nhead = head.next; \n\n\n// until the end of linked list is reached, do the \n\n// following steps \n\nwhile\n(head != \nnull\n) \n\n{ \n\n// 2.a) take the parent node from the q and \n\n// remove it from q \n\nBinaryTreeNode parent = q.peek(); \n\nBinaryTreeNode pp = q.poll(); \n\n\n// 2.c) take next two nodes from the linked list. \n\n// We will add them as children of the current \n\n// parent node in step 2.b. Push them into the \n\n// queue so that they will be parents to the \n\n// future nodes \n\nBinaryTreeNode leftChild = \nnull\n, rightChild = \nnull\n; \n\nleftChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(leftChild); \n\nhead = head.next; \n\nif\n(head != \nnull\n) \n\n{ \n\nrightChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(rightChild); \n\nhead = head.next; \n\n} \n\n\n// 2.b) assign the left and right children of \n\n// parent \n\nparent.left = leftChild; \n\nparent.right = rightChild; \n\n} \n\n\nreturn\nnode; \n\n} \n\n\n// Utility function to traverse the binary tree \n\n// after conversion \n\nvoid\ninorderTraversal(BinaryTreeNode node) \n\n{ \n\nif\n(node != \nnull\n) \n\n{ \n\ninorderTraversal(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderTraversal(node.right); \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.push(\n36\n); \n/* Last node of Linked List */\n\ntree.push(\n30\n); \n\ntree.push(\n25\n); \n\ntree.push(\n15\n); \n\ntree.push(\n12\n); \n\ntree.push(\n10\n); \n/* First node of Linked List */\n\nBinaryTreeNode node = tree.convertList2Binary(tree.root); \n\n\nSystem.out.println(\n\"Inorder Traversal of the\"\n+ \n\n\" constructed Binary Tree is:\"\n); \n\ntree.inorderTraversal(node); \n\n} \n} \n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 36, "index": 36}
{"src": "import java.util.*;\n\n//201920181\n\npublic class Polycarp{\n\n\tpublic static void main(String args[]){\n\t\tScanner s = new Scanner(System.in);\n        int rem[] = new int[3];\n\t\t\n\t\tArrays.fill(rem,-1);\n\t\trem[0] = 0;\n        char ch[] = s.next().toCharArray();\n\t\tint n = ch.length;\n \t\tlong dp[] = new long[n];\n\n        int sum = 0;\n\t\t\n        for(int i=0;i<ch.length;i++){\n\t\t   sum = sum + (ch[i]-48);\n\t\t   if(rem[sum%3] != -1)\n\t\t\t    if(i>0){\n\t\t\t\t\tdp[i] = Math.max(dp[i-1],dp[rem[sum%3]]+1);}\n\t\t\t\telse\n\t\t\t\t\tdp[i] = 1;\n\t       else\n\t\t\t   if(i>0)\n\t\t\t\t   dp[i] = dp[i-1];\n\t\t\t   \n\t\t   \n\t\t   rem[sum%3] = i;\n\t\t   sum = sum%3;\n\t\t   \n\t\t}\t\t\n\t\t \n\n            System.out.println(dp[n-1]);\t\t\t\n\t\t\n\t\t\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 37, "index": 37}
{"src": "\n// Java program for finding postorder \n// traversal of BST from preorder traversal \n\nimport\njava.util.* ; \n\nclass\nSolution \n{ \nstatic\nclass\nINT \n{ \n\nint\ndata; \n\nINT(\nint\nd) \n\n{ \n\ndata=d; \n\n} \n} \n\n// Function to find postorder traversal from \n// preorder traversal. \nstatic\nvoid\nfindPostOrderUtil(\nint\npre[], \nint\nn, \nint\nminval, \n\nint\nmaxval, INT preIndex) \n{ \n\n\n// If entire preorder array is traversed then \n\n// return as no more element is left to be \n\n// added to post order array. \n\nif\n(preIndex.data == n) \n\nreturn\n; \n\n\n// If array element does not lie in range specified, \n\n// then it is not part of current subtree. \n\nif\n(pre[preIndex.data] < minval || pre[preIndex.data] > maxval) { \n\nreturn\n; \n\n} \n\n\n// Store current value, to be printed later, after \n\n// printing left and right subtrees. Increment \n\n// preIndex to find left and right subtrees, \n\n// and pass this updated value to recursive calls. \n\nint\nval = pre[preIndex.data]; \n\npreIndex.data++; \n\n\n// All elements with value between minval and val \n\n// lie in left subtree. \n\nfindPostOrderUtil(pre, n, minval, val, preIndex); \n\n\n// All elements with value between val and maxval \n\n// lie in right subtree. \n\nfindPostOrderUtil(pre, n, val, maxval, preIndex); \n\n\nSystem.out.print( val + \n\" \"\n); \n} \n\n// Function to find postorder traversal. \nstatic\nvoid\nfindPostOrder(\nint\npre[], \nint\nn) \n{ \n\n\n// To store index of element to be \n\n// traversed next in preorder array. \n\n// This is passed by reference to \n\n// utility function. \n\nINT preIndex = \nnew\nINT(\n0\n); \n\n\nfindPostOrderUtil(pre, n, Integer.MIN_VALUE, \n\nInteger.MAX_VALUE, preIndex); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\npre[] = { \n40\n, \n30\n, \n35\n, \n80\n, \n100\n}; \n\n\nint\nn = pre.length; \n\n\n// Calling function \n\nfindPostOrder(pre, n); \n} \n} \n\n// This code is contributed \n// by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 38, "index": 38}
{"src": "\n// java program to find the maximum sum \n// such that no three are consecutive \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Returns maximum subsequence sum such that no three \n\n// elements are consecutive \n\nstatic\nint\nmaxSumWO3Consec(\nint\narr[], \nint\nn) \n\n{ \n\n// Stores result for subarray arr[0..i], i.e., \n\n// maximum possible sum in subarray arr[0..i] \n\n// such that no three elements are consecutive. \n\nint\nsum[] = \nnew\nint\n[n]; \n\n\n// Base cases (process first three elements) \n\nif\n(n >= \n1\n) \n\nsum[\n0\n] = arr[\n0\n]; \n\n\nif\n(n >= \n2\n) \n\nsum[\n1\n] = arr[\n0\n] + arr[\n1\n]; \n\n\nif\n(n > \n2\n) \n\nsum[\n2\n] = Math.max(sum[\n1\n], Math.max(arr[\n1\n] + arr[\n2\n], arr[\n0\n] + arr[\n2\n])); \n\n\n// Process rest of the elements \n\n// We have three cases \n\n// 1) Exclude arr[i], i.e., sum[i] = sum[i-1] \n\n// 2) Exclude arr[i-1], i.e., sum[i] = sum[i-2] + arr[i] \n\n// 3) Exclude arr[i-2], i.e., sum[i-3] + arr[i] + arr[i-1] \n\nfor\n(\nint\ni = \n3\n; i < n; i++) \n\nsum[i] = Math.max(Math.max(sum[i - \n1\n], sum[i - \n2\n] + arr[i]), \n\narr[i] + arr[i - \n1\n] + sum[i - \n3\n]); \n\n\nreturn\nsum[n - \n1\n]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n100\n, \n1000\n, \n100\n, \n1000\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSumWO3Consec(arr, n)); \n\n} \n} \n\n// This code is contributed by vt_m ", "complexity": "linear", "from": "CorCod", "problem": 39, "index": 39}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author MaxHeap\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    CBanhMi solver = new CBanhMi();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class CBanhMi {\n\n    long mod = (long) (1e9 + 7);\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n      int n = in.nextInt();\n      int q = in.nextInt();\n      long[] two = new long[n + 1];\n      two[0] = 1;\n      for (int i = 1; i <= n; ++i) {\n        two[i] = (two[i - 1] * 2L);\n        two[i] %= mod;\n      }\n\n      char[] s = in.nextCharArray();\n      int[] acc = new int[n + 1];\n      for (int i = 1; i <= n; ++i) {\n        acc[i] = s[i - 1] == '0' ? 0 : 1;\n        acc[i] += acc[i - 1];\n      }\n      // 0 0 1 1 | 1: 1 1 2| 2: 2 3| 4: 5| 9\n      // 0 1 1 1| 1: 1 2 2| 2: 3 3| 5: 6| 11\n      // 0 1 1 wwqwq| 1: 1 2 2| 3: 5 3| 8: 8| 16\n      // 0 0 1 1| 1: 1 1 2| 3: 3 3| 6: 6| 12\n      // 0 0 0 1| 1: 1 1 1| 2: 2 2| 4: 4| 8\n      while (q-- > 0) {\n        int f = in.nextInt();\n        int t = in.nextInt();\n        int ones = acc[t] - acc[f - 1];\n        int zeros = (t - f + 1) - ones;\n        if (ones == 0) {\n          out.println(0);\n        } else {\n          long ans = two[t - f + 1] - (zeros > 0 ? two[zeros] : 0);\n          if (zeros == 0) {\n            --ans;\n          }\n          ans = (ans + mod) % mod;\n          out.println(ans);\n        }\n      }\n    }\n\n  }\n\n  static class InputReader implements FastIO {\n\n    private InputStream stream;\n    private static final int DEFAULT_BUFFER_SIZE = 1 << 16;\n    private static final int EOF = -1;\n    private byte[] buf = new byte[DEFAULT_BUFFER_SIZE];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (this.numChars == EOF) {\n        throw new UnknownError();\n      } else {\n        if (this.curChar >= this.numChars) {\n          this.curChar = 0;\n\n          try {\n            this.numChars = this.stream.read(this.buf);\n          } catch (IOException ex) {\n            throw new InputMismatchException();\n          }\n\n          if (this.numChars <= 0) {\n            return EOF;\n          }\n        }\n\n        return this.buf[this.curChar++];\n      }\n    }\n\n    public int nextInt() {\n      int c;\n      for (c = this.read(); isSpaceChar(c); c = this.read()) {\n      }\n\n      byte sgn = 1;\n      if (c == 45) {\n        sgn = -1;\n        c = this.read();\n      }\n\n      int res = 0;\n\n      while (c >= 48 && c <= 57) {\n        res *= 10;\n        res += c - 48;\n        c = this.read();\n        if (isSpaceChar(c)) {\n          return res * sgn;\n        }\n      }\n\n      throw new InputMismatchException();\n    }\n\n    public String next() {\n      int c;\n      while (isSpaceChar(c = this.read())) {\n      }\n\n      StringBuilder result = new StringBuilder();\n      result.appendCodePoint(c);\n\n      while (!isSpaceChar(c = this.read())) {\n        result.appendCodePoint(c);\n      }\n\n      return result.toString();\n    }\n\n    public static boolean isSpaceChar(int c) {\n      return c == 32 || c == 10 || c == 13 || c == 9 || c == EOF;\n    }\n\n    public char[] nextCharArray() {\n      return next().toCharArray();\n    }\n\n  }\n\n  static interface FastIO {\n\n  }\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 40, "index": 40}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class MinimumDiameterTree{\n    public static void main(String[] args) {\n\tInputReader in = new InputReader (System.in);\n\tPrintWriter out = new PrintWriter (System.out);\n\n\tint n = in.nextInt();\n\tint s = in.nextInt();\n\tint deg[] = new int [n];\n\t\n\tfor (int i = 1; i < n; ++i) {\n\t    deg[in.nextInt() - 1] ++;\n\t    deg[in.nextInt() - 1] ++;\n\t}\n\n\tint l = 0;\n\tfor (int i = 0; i < n; ++i)\n\t    if (deg[i] == 1) l ++;\n\n\tout.println((double) 2 * s / l);\n\tout.close();\n    }\n\n    public static class InputReader {\n\tpublic BufferedReader reader;\n\tpublic StringTokenizer tokenizer;\n\n\tpublic InputReader(InputStream stream) {\n\t    reader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t    tokenizer = null;\n\t}\n\n\tpublic String next() {\n\t    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\ttry {\n\t\t    tokenizer = new StringTokenizer(reader.readLine());\n\t\t} catch(IOException e) {\n\t\t    throw new RuntimeException(e);\n\t\t}\n\t    }\n\t    return tokenizer.nextToken();\n\t}\n\n\tpublic int nextInt() {\n\t    return Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 41, "index": 41}
{"src": "\n// Java program to get same frequency character \n// string by removal of at most one char \npublic\nclass\nGFG { \n\n\nstatic\nfinal\nint\nM = \n26\n; \n\n\n// Utility method to get index of character ch \n\n// in lower alphabet characters \n\nstatic\nint\ngetIdx(\nchar\nch) \n\n{ \n\nreturn\n(ch - \n'a'\n); \n\n} \n\n\n// Returns true if all non-zero elements \n\n// values are same \n\nstatic\nboolean\nallSame(\nint\nfreq[], \nint\nN) \n\n{ \n\nint\nsame = \n0\n; \n\n\n// get first non-zero element \n\nint\ni; \n\nfor\n(i = \n0\n; i < N; i++) { \n\nif\n(freq[i] > \n0\n) { \n\nsame = freq[i]; \n\nbreak\n; \n\n} \n\n} \n\n\n// check equality of each element with \n\n// variable same \n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\nif\n(freq[j] > \n0\n&& freq[j] != same) \n\nreturn\nfalse\n; \n\n\nreturn\ntrue\n; \n\n} \n\n\n// Returns true if we can make all character \n\n// frequencies same \n\nstatic\nboolean\npossibleSameCharFreqByOneRemoval(String str) \n\n{ \n\nint\nl = str.length(); \n\n\n// fill frequency array \n\nint\n[] freq = \nnew\nint\n[M]; \n\n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\nfreq[getIdx(str.charAt(i))]++; \n\n\n// if all frequencies are same, then return true \n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\n\n/* Try decreasing frequency of all character \n\nby one and then check all equality of all \n\nnon-zero frequencies */\n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\ni = getIdx(c); \n\n\n// Check character only if it occurs in str \n\nif\n(freq[i] > \n0\n) { \n\nfreq[i]--; \n\n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\nfreq[i]++; \n\n} \n\n} \n\n\nreturn\nfalse\n; \n\n} \n\n\n// Driver code to test above methods \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"xyyzz\"\n; \n\nif\n(possibleSameCharFreqByOneRemoval(str)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "linear", "from": "CorCod", "problem": 42, "index": 42}
{"src": "\n// Java program to check if two binary tree are cousins \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n// Recursive function to check if two Nodes are \n\n// siblings \n\nboolean\nisSibling(Node node, Node a, Node b) \n\n{ \n\n// Base case \n\nif\n(node == \nnull\n) \n\nreturn\nfalse\n; \n\n\nreturn\n((node.left == a && node.right == b) || \n\n(node.left == b && node.right == a) || \n\nisSibling(node.left, a, b) || \n\nisSibling(node.right, a, b)); \n\n} \n\n\n// Recursive function to find level of Node 'ptr' in \n\n// a binary tree \n\nint\nlevel(Node node, Node ptr, \nint\nlev) \n\n{ \n\n// base cases \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\nif\n(node == ptr) \n\nreturn\nlev; \n\n\n// Return level if Node is present in left subtree \n\nint\nl = level(node.left, ptr, lev + \n1\n); \n\nif\n(l != \n0\n) \n\nreturn\nl; \n\n\n// Else search in right subtree \n\nreturn\nlevel(node.right, ptr, lev + \n1\n); \n\n} \n\n\n// Returns 1 if a and b are cousins, otherwise 0 \n\nboolean\nisCousin(Node node, Node a, Node b) \n\n{ \n\n// 1. The two Nodes should be on the same level \n\n// in the binary tree. \n\n// 2. The two Nodes should not be siblings (means \n\n// that they should not have the same parent \n\n// Node). \n\nreturn\n((level(node, a, \n1\n) == level(node, b, \n1\n)) && \n\n(!isSibling(node, a, b))); \n\n} \n\n\n//Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.left.right.right = \nnew\nNode(\n15\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\ntree.root.right.left.right = \nnew\nNode(\n8\n); \n\n\nNode Node1, Node2; \n\nNode1 = tree.root.left.left; \n\nNode2 = tree.root.right.right; \n\nif\n(tree.isCousin(tree.root, Node1, Node2)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 43, "index": 43}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 44, "index": 44}
{"src": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport static java.lang.Integer.*;\nimport static java.lang.Long.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main {\n\n    Main() throws IOException {\n        String a = nextLine();\n        String b = nextLine();\n        long ans = 0;\n        int s = 0;\n        for (int i = 0; i < b.length() - a.length(); ++i) {\n            s += b.charAt(i) == '1' ? 1 : 0;\n        }\n\n        for (int i = 0; i < a.length(); ++i) {\n            s += b.charAt(i + b.length() - a.length()) == '1' ? 1 : 0;\n            ans += a.charAt(i) == '1' ? b.length() - a.length() + 1 - s : s;\n            s -= b.charAt(i) == '1' ? 1 : 0;\n        }\n        out.println(ans);\n    }\n\n\n    //////////////////////////////\n    PrintWriter out = new PrintWriter(System.out, false);\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer stok = null;\n    String nextLine() throws IOException {\n        while (stok == null || !stok.hasMoreTokens()) {\n            stok = new StringTokenizer(in.readLine());\n        }\n        return stok.nextToken();\n    }\n\n\n    public static void main(String args[]) throws IOException {\n        if (args.length > 0) {\n            setIn(new FileInputStream(args[0] + \".inp\"));\n            setOut(new PrintStream(args[0] + \".out\"));\n        }\n        Main solver = new Main();\n        solver.out.flush();  //  could be replace with a method, but nah, this is just competitive programming :p\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 45, "index": 45}
{"src": "\n// Java program to find the smallest positive value that cannot be \n// represented as sum of subsets of a given sorted array \nclass\nFindSmallestInteger \n{ \n\n// Returns the smallest number that cannot be represented as sum \n\n// of subset of elements from set represented by sorted array arr[0..n-1] \n\nint\nfindSmallest(\nint\narr[], \nint\nn) \n\n{ \n\nint\nres = \n1\n; \n// Initialize result \n\n\n// Traverse the array and increment 'res' if arr[i] is \n\n// smaller than or equal to 'res'. \n\nfor\n(\nint\ni = \n0\n; i < n && arr[i] <= res; i++) \n\nres = res + arr[i]; \n\n\nreturn\nres; \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindSmallestInteger small = \nnew\nFindSmallestInteger(); \n\nint\narr1[] = {\n1\n, \n3\n, \n4\n, \n5\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(small.findSmallest(arr1, n1)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n6\n, \n10\n, \n11\n, \n15\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(small.findSmallest(arr2, n2)); \n\n\nint\narr3[] = {\n1\n, \n1\n, \n1\n, \n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(small.findSmallest(arr3, n3)); \n\n\nint\narr4[] = {\n1\n, \n1\n, \n3\n, \n4\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(small.findSmallest(arr4, n4)); \n\n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "linear", "from": "CorCod", "problem": 46, "index": 46}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Cf1005A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int numberOfStairs = 0;\n        StringBuilder result = new StringBuilder(\"\");\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int previousNum = 0;\n        int tmp = 0;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken());\n            if (tmp == 1){\n                ++numberOfStairs;\n                if (previousNum != 0)\n                    result.append(previousNum + \" \");\n            }\n            previousNum = tmp;\n        }\n        result.append(previousNum);\n        System.out.println(numberOfStairs);\n        System.out.println(result);\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 47, "index": 47}
{"src": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n            while(s.length()<n){\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            }\n            System.out.println(s);\n        }\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 48, "index": 48}
{"src": "\n// Java program to find maximum average \n// subarray of given length. \nimport\njava .io.*; \n\nclass\nGFG { \n\n\n// Returns beginning index \n\n// of maximum average \n\n// subarray of length 'k' \n\nstatic\nint\nfindMaxAverage(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\n\n// Check if 'k' is valid \n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n// Create and fill array \n\n// to store cumulative \n\n// sum. csum[i] stores \n\n// sum of arr[0] to arr[i] \n\nint\n[]csum = \nnew\nint\n[n]; \n\n\ncsum[\n0\n] = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ncsum[i] = csum[i - \n1\n] + arr[i]; \n\n\n// Initialize max_sm as \n\n// sum of first subarray \n\nint\nmax_sum = csum[k - \n1\n], \n\nmax_end = k - \n1\n; \n\n\n// Find sum of other \n\n// subarrays and update \n\n// max_sum if required. \n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nint\ncurr_sum = csum[i] - \n\ncsum[i - k]; \n\nif\n(curr_sum > max_sum) \n\n{ \n\nmax_sum = curr_sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n// To avoid memory leak \n\n//delete [] csum; \n\n\n// Return starting index \n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n// Driver Code \n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"The maximum \"\n\n+ \n\"average subarray of length \"\n\n+ k + \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "complexity": "linear", "from": "CorCod", "problem": 49, "index": 49}
{"src": "\n// Java program to find union of \n// two sorted arrays \n\nclass\nFindUnion \n{ \n\n/* Function prints union of arr1[] and arr2[] \n\nm is the number of elements in arr1[] \n\nn is the number of elements in arr2[] */\n\nstatic\nint\nprintUnion(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n\n/* Print remaining elements of \n\nthe larger array */\n\nwhile\n(i < m) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nwhile\n(j < n) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintUnion(arr1, arr2, m, n); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 50, "index": 50}
{"src": "\n// Recursive Java program to print odd level nodes \nclass\nGfG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\nstatic\nvoid\nprintOddNodes(Node root, \nboolean\nisOdd) \n{ \n\n// If empty tree \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n// If current node is of odd level \n\nif\n(isOdd == \ntrue\n) \n\nSystem.out.print(root.data + \n\" \"\n); \n\n\n// Recur for children with isOdd \n\n// switched. \n\nprintOddNodes(root.left, !isOdd); \n\nprintOddNodes(root.right, !isOdd); \n} \n\n// Utility method to create a node \nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nprintOddNodes(root, \ntrue\n); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 51, "index": 51}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.math.*;\n\npublic class C {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t/**/\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t/*/\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(\"src/c.in\"))));\n\t\t/**/\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] counts = new int[60];\n\t\tArrayList<ArrayDeque<Long>> nums = new ArrayList<>();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tnums.add(new ArrayDeque<>());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong num = sc.nextLong();\n\t\t\tfor (int j = 1; j <= 60; ++j) {\n\t\t\t\tif (num < (1L<<j)) {\n\t\t\t\t\tnums.get(j-1).add(num);\n\t\t\t\t\t++counts[j-1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong curr = 0;\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= 60; ++j) {\n\t\t\t\tif (j==60) {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (counts[j]==0||(curr&(1L<<j))!=0)\n\t\t\t\t\tcontinue;\n\t\t\t\tlong num = nums.get(j).removeFirst();\n\t\t\t\t--counts[j];\n\t\t\t\tcurr ^= num;\n\t\t\t\tif (i>0)\n\t\t\t\t\tans.append(\" \");\n\t\t\t\tans.append(num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\tSystem.out.println(ans);\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 52, "index": 52}
{"src": "\n// Java program to find maximum number of \n// thieves caught \nimport\njava.util.*; \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Returns maximum number of thieves \n\n// that can be caught. \n\nstatic\nint\npoliceThief(\nchar\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nArrayList<Integer> thi = \nnew\nArrayList<Integer>(); \n\nArrayList<Integer> pol = \nnew\nArrayList<Integer>(); \n\n\n// store indices in the ArrayList \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(arr[i] == \n'P'\n) \n\npol.add(i); \n\nelse\nif\n(arr[i] == \n'T'\n) \n\nthi.add(i); \n\n} \n\n\n// track lowest current indices of \n\n// thief: thi[l], police: pol[r] \n\nint\nl = \n0\n, r = \n0\n; \n\nwhile\n(l < thi.size() && r < pol.size()) { \n\n\n// can be caught \n\nif\n(Math.abs(thi.get(l) - pol.get(r)) <= k) { \n\nres++; \n\nl++; \n\nr++; \n\n} \n\n\n// increment the minimum index \n\nelse\nif\n(thi.get(l) < pol.get(r)) \n\nl++; \n\nelse\n\nr++; \n\n} \n\nreturn\nres; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nk, n; \n\nchar\narr1[] =\nnew\nchar\n[] { \n'P'\n, \n'T'\n, \n'T'\n, \n\n'P'\n, \n'T'\n}; \n\nk = \n2\n; \n\nn = arr1.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr1, n, k)); \n\n\nchar\narr2[] =\nnew\nchar\n[] { \n'T'\n, \n'T'\n, \n'P'\n, \n'P'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n2\n; \n\nn = arr2.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr2, n, k)); \n\n\nchar\narr3[] = \nnew\nchar\n[]{ \n'P'\n, \n'T'\n, \n'P'\n, \n'T'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n3\n; \n\nn = arr3.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr3, n, k)); \n\n} \n} \n\n/* This code is contributed by Danish kaleem */", "complexity": "linear", "from": "CorCod", "problem": 53, "index": 53}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class round569d2c {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tArrayDeque<Integer> deq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdeq.addLast(in.nextInt());\n\t\t}\n\t\tlong[] queries = new long[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tqueries[i] = in.nextLong();\n\t\t}\n\t\tint[] origAs = new int[n-1];\n\t\tint[] origBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\torigAs[i] = a;\n\t\t\torigBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tint[] repeatAs = new int[n-1];\n\t\tint[] repeatBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\trepeatAs[i] = a;\n\t\t\trepeatBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tlong query = queries[i] - 1;\n\t\t\tif (query < n-1) {\n\t\t\t\tsb.append(origAs[(int)query] + \" \" + origBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquery %= (n-1);\n\t\t\t\tsb.append(repeatAs[(int)query] + \" \" + repeatBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t// ======================================================================================\n\t// =============================== Reference Code =======================================\n\t// ======================================================================================\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t// Method to return all primes smaller than or equal to \n\t// n using Sieve of Eratosthenes \n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t// Create a boolean array \"prime[0..n]\" and initialize \n\t\t// all entries it as true. A value in prime[i] will \n\t\t// finally be false if i is Not a prime, else true. \n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t// If prime[p] is not changed, then it is a prime \n\t\t\tif (prime[p] == true) {\n\t\t\t\t// Update all multiples of p \n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t// Binary search for number greater than or equal to target\n\t// returns -1 if number not found\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t// Base Case \n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; // To store results of recursive call \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t// Update x and y using results of recursive \n\t\t// call \n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t// Returns modulo inverse of a  \n\t// with respect to m using extended \n\t// Euclid Algorithm. Refer below post for details: \n\t// https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/ \n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t// Apply extended Euclid Algorithm \n\t\twhile (a > 1) {\n\t\t\t// q is quotient \n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t// m is remainder now, process \n\t\t\t// same as euclid's algo \n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t// Make x1 positive \n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t// k is size of num[] and rem[]. \n\t// Returns the smallest number \n\t// x such that: \n\t// x % num[0] = rem[0], \n\t// x % num[1] = rem[1], \n\t// .................. \n\t// x % num[k-2] = rem[k-1] \n\t// Assumption: Numbers in num[] are pairwise  \n\t// coprime (gcd for every pair is 1) \n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t// Compute product of all numbers \n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t// Initialize result \n\t\tint result = 0;\n\n\t\t// Apply above formula \n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t/**\n\t * Source: Matt Fontaine\n\t */\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "complexity": "linear", "from": "CorCod", "problem": 54, "index": 54}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF1009E {\n\tstatic final int MD = 998244353;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint[] aa = new int[1 + n];\n\t\tfor (int i = 1, a = 0; i <= n; i++)\n\t\t\taa[i] = a = (a + Integer.parseInt(st.nextToken())) % MD;\n\t\tint[] pp = new int[n];\n\t\tpp[0] = 1;\n\t\tfor (int i = 1, p = 1; i < n; i++) {\n\t\t\tpp[i] = p;\n\t\t\tp = p * 2 % MD;\n\t\t}\n\t\tint d = 0;\n\t\tlong ans = 0;\n\t\tfor (int i = n - 1; i >= 0; i--) {\t// rest at i\n\t\t\td = (d * 2 % MD + aa[n - 1 - i]) % MD;\t// rest again before n\n\t\t\tans = (ans + (long) (d + aa[n - i]) * pp[i]) % MD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 55, "index": 55}
{"src": "\n// Java program for calculating LISS \n// using dynamic programming \n\npublic\nclass\nLisTree \n{ \n\n/* A binary tree node has data, pointer \n\nto left child and a pointer to right \n\nchild */\n\nstatic\nclass\nnode \n\n{ \n\nint\ndata, liss; \n\nnode left, right; \n\n\npublic\nnode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.liss = \n0\n; \n\n} \n\n} \n\n\n// A memoization function returns size \n\n// of the largest independent set in \n\n// a given binary tree \n\nstatic\nint\nliss(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root.liss != \n0\n) \n\nreturn\nroot.liss; \n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\nroot.liss = \n1\n; \n\n\n// Calculate size excluding the \n\n// current node \n\nint\nliss_excl = liss(root.left) + liss(root.right); \n\n\n// Calculate size including the \n\n// current node \n\nint\nliss_incl = \n1\n; \n\nif\n(root.left != \nnull\n) \n\n{ \n\nliss_incl += (liss(root.left.left) + liss(root.left.right)); \n\n} \n\nif\n(root.right != \nnull\n) \n\n{ \n\nliss_incl += (liss(root.right.left) + liss(root.right.right)); \n\n} \n\n\n// Maximum of two sizes is LISS, \n\n// store it for future uses. \n\nreturn\nroot.liss = Math.max(liss_excl, liss_incl); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Let us construct the tree given \n\n// in the above diagram \n\n\nnode root = \nnew\nnode(\n20\n); \n\nroot.left = \nnew\nnode(\n8\n); \n\nroot.left.left = \nnew\nnode(\n4\n); \n\nroot.left.right = \nnew\nnode(\n12\n); \n\nroot.left.right.left = \nnew\nnode(\n10\n); \n\nroot.left.right.right = \nnew\nnode(\n14\n); \n\nroot.right = \nnew\nnode(\n22\n); \n\nroot.right.right = \nnew\nnode(\n25\n); \n\nSystem.out.println(\n\"Size of the Largest Independent Set is \"\n+ liss(root)); \n\n} \n} \n\n// This code is contributed by Rishabh Mahrsee ", "complexity": "linear", "from": "CorCod", "problem": 56, "index": 56}
{"src": "\n// Java program to check if all leaves are at same level \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nLeaf \n{ \n\nint\nleaflevel=\n0\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nLeaf mylevel = \nnew\nLeaf(); \n\n\n/* Recursive function which checks whether all leaves are at same \n\nlevel */\n\nboolean\ncheckUtil(Node node, \nint\nlevel, Leaf leafLevel) \n\n{ \n\n// Base case \n\nif\n(node == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// If a leaf node is encountered \n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\n{ \n\n// When a leaf node is found first time \n\nif\n(leafLevel.leaflevel == \n0\n) \n\n{ \n\n// Set first found leaf's level \n\nleafLevel.leaflevel = level; \n\nreturn\ntrue\n; \n\n} \n\n\n// If this is not first leaf node, compare its level with \n\n// first leaf's level \n\nreturn\n(level == leafLevel.leaflevel); \n\n} \n\n\n// If this node is not leaf, recursively check left and right \n\n// subtrees \n\nreturn\ncheckUtil(node.left, level + \n1\n, leafLevel) \n\n&& checkUtil(node.right, level + \n1\n, leafLevel); \n\n} \n\n\n/* The main function to check if all leafs are at same level. \n\nIt mainly uses checkUtil() */\n\nboolean\ncheck(Node node) \n\n{ \n\nint\nlevel = \n0\n; \n\nreturn\ncheckUtil(node, level, mylevel); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n// Let us create the tree as shown in the example \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n12\n); \n\ntree.root.left = \nnew\nNode(\n5\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n9\n); \n\ntree.root.left.left.left = \nnew\nNode(\n1\n); \n\ntree.root.left.right.left = \nnew\nNode(\n1\n); \n\nif\n(tree.check(tree.root)) \n\nSystem.out.println(\n\"Leaves are at same level\"\n); \n\nelse\n\nSystem.out.println(\n\"Leaves are not at same level\"\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 57, "index": 57}
{"src": "\n// JAVA Code for Find Second largest \n// element in an array \nclass\nGFG { \n\n\n/* Function to print the second largest \n\nelements */\n\npublic\nstatic\nvoid\nprint2largest(\nint\narr[], \n\nint\narr_size) \n\n{ \n\nint\ni, first, second; \n\n\n/* There should be atleast two elements */\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i++) \n\n{ \n\n/* If current element is smaller than \n\nfirst then update both first and second */\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n/* If arr[i] is in between first and \n\nsecond then update second */\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\n\nif\n(second == Integer.MIN_VALUE) \n\nSystem.out.print(\n\"There is no second largest\"\n+ \n\n\" element\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"The second largest element\"\n+ \n\n\" is \"\n+ second); \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n35\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint2largest(arr, n); \n\n} \n} \n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "linear", "from": "CorCod", "problem": 58, "index": 58}
{"src": "\n\nimport java.util.Scanner;\n\npublic class TaxiDriversAndLyft2 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tlong n = scanner.nextLong();\n\t\tlong m = scanner.nextLong();\n\t\tlong[] people = new long[(int) (n+m)];\n\t\tint[] taxiDrivers = new int[(int) (n+m)];\n\t\t\n\t\tfor(int i = 0;i< (n+m); i++) {\n\t\t\tpeople[i] = scanner.nextLong();\n\t\t}\n\t\t\n\t\tfor(int i = 0;i< (n+m); i++) {\n\t\t\ttaxiDrivers[i] = scanner.nextInt();\n\t\t}\n\t\t\n\t\tint lastTaxiDriverIndex = -1;\n\t\tlong[] riderCountArray = new long[(int) (m)];\n\t\tlong[] a1 = new long[(int)n];\n\t\tlong[] b1 = new long[(int)m];\n\t\t\n\t\tint j=0, k=0;\n\t\tfor(int i = 0;i< (n+m); i++) {\t\n\t\t\tif(taxiDrivers[i] == 0) {\n\t\t\t\ta1[j] = people[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse  {\n\t\t\t\tb1[k] = people[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint l = 0, q=0;\n\t\tfor(int i=0;i<j;i++) {\n\t\t\twhile ((l<m-1 && m>1) && Math.abs(a1[i] - b1[l]) > Math.abs(a1[i] - b1[l+1])) {\n\t\t\t\tl++; \n\t\t\t}\n\t\t\t\n\t\t\triderCountArray[l]++;\t\n\t\t}\n\t\t\n\t\tfor(int i = 0;i< (m); i++) {\n\t\t\tSystem.out.print(riderCountArray[i]+\" \");\n\t\t}\n\t} \n}\n", "complexity": "linear", "from": "CorCod", "problem": 59, "index": 59}
{"src": "\n// A O(n) C++ program to count number of substrings \n//starting and ending with 1 \n\nclass\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[], \nint\nn) \n\n{ \n\nint\nm = \n0\n; \n// Count of 1's in input string \n\n\n// Traverse input string and count of 1's in it \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\nm++; \n\n} \n\n\n// Return count of possible pairs among m 1's \n\nreturn\nm * (m - \n1\n) / \n2\n; \n\n} \n\n\n// Driver program to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str, n)); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 60, "index": 60}
{"src": "import java.math.BigInteger;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\npublic class Practice {\n\t\n\t   \n\n\t\tpublic static void main(String []args)\n\t\t{\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tString s=sc.nextLine();\n\t\t\t//System.out.println(s);\n\t\t\tchar c[]=s.toCharArray();\n\t\t\tArrayList a =new ArrayList();\n\t\t\t\n\t\t\tfor(int i=0;i<c.length;i++)\n\t\t\t{\n\t\t\t\t//System.out.println(c[i]);\n\t\t\t\ta.add(c[i]);\n\t\t\t}\n\t\t\n\t\t\tint x=Collections.frequency(a,'0' );\n\t\t\tint y=Collections.frequency(a,'1');\n\t\t\t\n\t\t\t//System.out.println(x+ \"  \"+y );\n\t\t\tif(y==0 || y==1)\n\t\t\t{\n\t\t\t\tSystem.out.println(s);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(y>=2)\n\t\t\t\t{\n\t\t\t\t\tString s1=\"1\";\n\t\t\t\t\tfor(int i=0;i<x;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\ts1=s1+\"0\";\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(s1);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t}\n\n}", "complexity": "linear", "from": "CorCod", "problem": 61, "index": 61}
{"src": "\nclass\nGFG { \n\n// Returns count of ways n people \n\n// can remain single or paired up. \n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\na = \n1\n, b = \n2\n, c = \n0\n; \n\nif\n(n <= \n2\n) { \n\nreturn\nn; \n\n} \n\nfor\n(\nint\ni = \n3\n; i <= n; i++) { \n\nc = b + (i - \n1\n) * a; \n\na = b; \n\nb = c; \n\n} \n\nreturn\nc; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n} \n\n// This code is contributed by Ravi Kasha. ", "complexity": "linear", "from": "CorCod", "problem": 62, "index": 62}
{"src": "import java.util.Scanner;\npublic class Codeforces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, f[], c=0;\n\t\tn = in.nextInt();\n\t\tf = new int[n];\n\t\twhile (--n>0){\n\t\t\tf[in.nextInt()-1] ++;\n\t\t\tf[in.nextInt()-1]++;\n\t\t\tin.nextLine();\n\t\t}\n\t\tfor(int i=0; i<f.length; i++) if (f[i] == 1) c++;\n\t\tSystem.out.println(c);\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 63, "index": 63}
{"src": "\n// Java program to find the smallest number that can be \n// formed from given sum of digits and number of digits \n\nclass\nGFG \n{ \n\n// Function to print the smallest possible number with digit sum 's' \n\n// and 'm' number of digits \n\nstatic\nvoid\nfindSmallest(\nint\nm, \nint\ns) \n\n{ \n\n// If sum of digits is 0, then a number is possible \n\n// only if number of digits is 1 \n\nif\n(s == \n0\n) \n\n{ \n\nSystem.out.print(m == \n1\n? \n\"Smallest number is 0\"\n: \n\"Not possible\"\n); \n\n\nreturn\n; \n\n} \n\n\n// Sum greater than the maximum possible sum \n\nif\n(s > \n9\n*m) \n\n{ \n\nSystem.out.println(\n\"Not possible\"\n); \n\nreturn\n; \n\n} \n\n\n// Create an array to store digits of result \n\nint\n[] res = \nnew\nint\n[m]; \n\n\n// deduct sum by one to account for cases later \n\n// (There must be 1 left for the most significant \n\n// digit) \n\ns -= \n1\n; \n\n\n// Fill last m-1 digits (from right to left) \n\nfor\n(\nint\ni=m-\n1\n; i>\n0\n; i--) \n\n{ \n\n// If sum is still greater than 9, \n\n// digit must be 9 \n\nif\n(s > \n9\n) \n\n{ \n\nres[i] = \n9\n; \n\ns -= \n9\n; \n\n} \n\nelse\n\n{ \n\nres[i] = s; \n\ns = \n0\n; \n\n} \n\n} \n\n\n// Whatever is left should be the most significant \n\n// digit \n\nres[\n0\n] = s + \n1\n; \n// The initially subtracted 1 is \n\n// incorporated here \n\n\nSystem.out.print(\n\"Smallest number is \"\n); \n\nfor\n(\nint\ni=\n0\n; i<m; i++) \n\nSystem.out.print(res[i]); \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\ns = \n9\n, m = \n2\n; \n\nfindSmallest(m, s); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "complexity": "linear", "from": "CorCod", "problem": 64, "index": 64}
{"src": "\n// Java program for nth Catalan Number \n\nclass\nGFG { \n\n// Returns value of Binomial Coefficient C(n, k) \n\nstatic\nlong\nbinomialCoeff(\nint\nn, \nint\nk) { \n\nlong\nres = \n1\n; \n\n\n// Since C(n, k) = C(n, n-k) \n\nif\n(k > n - k) { \n\nk = n - k; \n\n} \n\n\n// Calculate value of [n*(n-1)*---*(n-k+1)] / [k*(k-1)*---*1] \n\nfor\n(\nint\ni = \n0\n; i < k; ++i) { \n\nres *= (n - i); \n\nres /= (i + \n1\n); \n\n} \n\n\nreturn\nres; \n\n} \n\n// A Binomial coefficient based function to find nth catalan \n// number in O(n) time \n\nstatic\nlong\ncatalan(\nint\nn) { \n\n// Calculate value of 2nCn \n\nlong\nc = binomialCoeff(\n2\n* n, n); \n\n\n// return 2nCn/(n+1) \n\nreturn\nc / (n + \n1\n); \n\n} \n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalan(i) + \n\" \"\n); \n\n} \n\n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 65, "index": 65}
{"src": "\n// Java program to find maximum element in the path \n// between two Nodes of Binary Search Tree. \nclass\nSolution \n{ \n\nstatic\nclass\nNode \n{ \n\nNode left, right; \n\nint\ndata; \n} \n\n// Create and return a pointer of new Node. \nstatic\nNode createNode(\nint\nx) \n{ \n\nNode p = \nnew\nNode(); \n\np . data = x; \n\np . left = p . right = \nnull\n; \n\nreturn\np; \n} \n\n// Insert a new Node in Binary Search Tree. \nstatic\nvoid\ninsertNode( Node root, \nint\nx) \n{ \n\nNode p = root, q = \nnull\n; \n\n\nwhile\n(p != \nnull\n) \n\n{ \n\nq = p; \n\nif\n(p . data < x) \n\np = p . right; \n\nelse\n\np = p . left; \n\n} \n\n\nif\n(q == \nnull\n) \n\np = createNode(x); \n\nelse\n\n{ \n\nif\n(q . data < x) \n\nq . right = createNode(x); \n\nelse\n\nq . left = createNode(x); \n\n} \n} \n\n// Return the maximum element between a Node \n// and its given ancestor. \nstatic\nint\nmaxelpath(Node q, \nint\nx) \n{ \n\nNode p = q; \n\n\nint\nmx = -\n1\n; \n\n\n// Traversing the path between ansector and \n\n// Node and finding maximum element. \n\nwhile\n(p . data != x) \n\n{ \n\nif\n(p . data > x) \n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . left; \n\n} \n\nelse\n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . right; \n\n} \n\n} \n\n\nreturn\nMath.max(mx, x); \n} \n\n// Return maximum element in the path between \n// two given Node of BST. \nstatic\nint\nmaximumElement( Node root, \nint\nx, \nint\ny) \n{ \n\nNode p = root; \n\n\n// Finding the LCA of Node x and Node y \n\nwhile\n((x < p . data && y < p . data) || \n\n(x > p . data && y > p . data)) \n\n{ \n\n// Checking if both the Node lie on the \n\n// left side of the parent p. \n\nif\n(x < p . data && y < p . data) \n\np = p . left; \n\n\n// Checking if both the Node lie on the \n\n// right side of the parent p. \n\nelse\nif\n(x > p . data && y > p . data) \n\np = p . right; \n\n} \n\n\n// Return the maximum of maximum elements occur \n\n// in path from ancestor to both Node. \n\nreturn\nMath.max(maxelpath(p, x), maxelpath(p, y)); \n} \n\n\n// Driver Code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n18\n, \n36\n, \n9\n, \n6\n, \n12\n, \n10\n, \n1\n, \n8\n}; \n\nint\na = \n1\n, b = \n10\n; \n\nint\nn =arr.length; \n\n\n// Creating the root of Binary Search Tree \n\nNode root = createNode(arr[\n0\n]); \n\n\n// Inserting Nodes in Binary Search Tree \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ninsertNode(root, arr[i]); \n\n\nSystem.out.println( maximumElement(root, a, b) ); \n\n} \n} \n//contributed by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 66, "index": 66}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n744444444747477777774\n44444447474747777777\n */\n\n/**\n *\n * @author Andy Phan\n */\npublic class b {\n    public static void main(String[] args) {\n        FS in = new FS(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = in.nextInt();\n        Integer[] arr = new Integer[n];\n        int numZ = 0;\n        for(int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n            if(arr[i] == 0) numZ++;\n        }\n        \n        Arrays.sort(arr);\n        \n        \n        if(numZ > 1) {\n            System.out.println(\"cslnb\");\n            return;\n        }\n        int numDup = 0;\n        int[] arr2 = new int[n];\n        for(int i = 0; i < n; i++) {\n            arr2[i] = arr[i];\n            if(i != 0) {\n                if(arr2[i] == arr2[i-1]) {\n                    arr2[i-1]--;\n                    numDup++;\n                }\n            }\n        }\n        \n        if(numDup > 1) {\n            System.out.println(\"cslnb\");\n            return;\n        }\n        \n        \n        for(int i = 0; i < n; i++) {\n            if(i != 0) {\n                if(arr2[i] == arr2[i-1]) {\n                    System.out.println(\"cslnb\");\n                    return;\n                }\n            }\n        }\n        long num = 0;\n        if(numDup == 1) num++;\n        for(int i = 0; i < n; i++) {\n            num += arr2[i]-i;\n        }\n        \n        if(num%2 == 0) {\n            System.out.println(\"cslnb\");\n        } else {\n            System.out.println(\"sjfnb\");\n        }\n        \n\n        out.close();\n    }\n    \n    static class FS {\n\n        BufferedReader in;\n        StringTokenizer token;\n        \n        public FS(InputStream str) {\n            in = new BufferedReader(new InputStreamReader(str));\n        }\n        \n        public String next() {\n            if (token == null || !token.hasMoreElements()) {\n                try {\n                    token = new StringTokenizer(in.readLine());\n                } catch (IOException ex) {\n                }\n                return next();\n            }\n            return token.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 67, "index": 67}
{"src": "\n// Java Program to find all the common characters \n// in n strings \nimport\njava.util.*; \nimport\njava.lang.*; \n\nclass\nGFG { \n\n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\npublic\nstatic\nvoid\ncommonCharacters(String str[], \n\nint\nn) \n\n{ \n\n\n// primary array for common characters \n\n// we assume all characters are seen before. \n\nBoolean[] prim = \nnew\nBoolean[MAX_CHAR]; \n\nArrays.fill(prim, \nnew\nBoolean(\ntrue\n)); \n\n\n// for each string \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// secondary array for common characters \n\n// Initially marked false \n\nBoolean[] sec = \nnew\nBoolean[MAX_CHAR]; \n\nArrays.fill(sec, \nnew\nBoolean(\nfalse\n)); \n\n\n// for every character of ith string \n\nfor\n(\nint\nj = \n0\n; j < str[i].length(); j++) \n\n{ \n\n\n// if character is present in all \n\n// strings before, mark it. \n\nif\n(prim[str[i].charAt(j) - \n'a'\n]) \n\nsec[str[i].charAt(j) - \n'a'\n] = \ntrue\n; \n\n} \n\n\n// copy whole secondary array into primary \n\nSystem.arraycopy(sec, \n0\n, prim, \n0\n, MAX_CHAR); \n\n} \n\n\n// displaying common characters \n\nfor\n(\nint\ni = \n0\n; i < \n26\n; i++) \n\nif\n(prim[i]){ \n\nSystem.out.print(Character.toChars(i \n\n+ \n97\n)); \n\nSystem.out.print(\n\" \"\n); \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str[] = { \n\"geeksforgeeks\"\n, \n\n\"gemkstones\"\n, \n\n\"acknowledges\"\n, \n\n\"aguelikes\"\n}; \n\n\nint\nn = str.length; \n\ncommonCharacters(str, n); \n\n} \n} \n\n// This code is contributed by Prasad Kshirsagar ", "complexity": "linear", "from": "CorCod", "problem": 68, "index": 68}
{"src": "\n// Java program to find nth ugly number \nimport\njava.lang.Math; \n\nclass\nUglyNumber \n{ \n\n/* Function to get the nth ugly number*/\n\nint\ngetNthUglyNo(\nint\nn) \n\n{ \n\nint\nugly[] = \nnew\nint\n[n]; \n// To store ugly numbers \n\nint\ni2 = \n0\n, i3 = \n0\n, i5 = \n0\n; \n\nint\nnext_multiple_of_2 = \n2\n; \n\nint\nnext_multiple_of_3 = \n3\n; \n\nint\nnext_multiple_of_5 = \n5\n; \n\nint\nnext_ugly_no = \n1\n; \n\n\nugly[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nnext_ugly_no = Math.min(next_multiple_of_2, \n\nMath.min(next_multiple_of_3, \n\nnext_multiple_of_5)); \n\n\nugly[i] = next_ugly_no; \n\nif\n(next_ugly_no == next_multiple_of_2) \n\n{ \n\ni2 = i2+\n1\n; \n\nnext_multiple_of_2 = ugly[i2]*\n2\n; \n\n} \n\nif\n(next_ugly_no == next_multiple_of_3) \n\n{ \n\ni3 = i3+\n1\n; \n\nnext_multiple_of_3 = ugly[i3]*\n3\n; \n\n} \n\nif\n(next_ugly_no == next_multiple_of_5) \n\n{ \n\ni5 = i5+\n1\n; \n\nnext_multiple_of_5 = ugly[i5]*\n5\n; \n\n} \n\n} \n/*End of for loop (i=1; i<n; i++) */\n\nreturn\nnext_ugly_no; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n150\n; \n\nUglyNumber obj = \nnew\nUglyNumber(); \n\nSystem.out.println(obj.getNthUglyNo(n)); \n\n} \n} \n\n// This code has been contributed by Amit Khandelwal (Amit Khandelwal 1) ", "complexity": "linear", "from": "CorCod", "problem": 69, "index": 69}
{"src": "import java.util.*;\npublic class kingrace {public static void main(String[] args) \n{ \n    Scanner input=new Scanner(System.in);\n    long a = input.nextLong();\n   input.nextLine();\n    String [] coo = input.nextLine().split(\" \");\n    long xcoin = Long.parseLong(coo[0]);\n    long ycoin = Long.parseLong(coo[1]);\n    coordinates first = new coordinates(1,1,a);\n    coordinates second = new coordinates(a,a,a);\n    double x = (double)Math.sqrt(Math.abs((xcoin-1)*(xcoin-1)+(ycoin-1)*(ycoin-1)));\n    double y = (double)Math.sqrt(Math.abs((xcoin-a)*(xcoin-a)+(ycoin-a)*(ycoin-a)));\n   long c = 0;\n   long d = 0;\n    if (x>y)\n    {\n    \tSystem.out.println(\"Black\");\n    }\n    else if(x<y)\n    {\n    \tSystem.out.println(\"White\");\n    }\n    else {\n    c = first.Distance(new coordinates(xcoin,ycoin,a));\n    d = second.Distance(new coordinates(xcoin,ycoin,a));\n    }\n    if(d!=0&&c!=0)\n    if (d<c)\n    {\n    \tSystem.out.println(\"Black\");\n    \t\n    }\n    else \n    {\n    \tSystem.out.println(\"White\");\n    }\n  //System.out.prlongln(c +\" \"+d);\n  input.close();\n} \n\n}\nclass coordinates{\n\tprivate long xcoord;\n\tprivate long ycoord;\n\tprivate long dim; \n\tpublic coordinates(long x, long y, long dimensions)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\tdim = dimensions;\n\t\t\n\t}\n\tpublic void setCoordinates(long x, long y)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\t\n\t}\n\tpublic long Distance(coordinates num)\n\t{\n\t\tlong distance = 0; \n\t\t\n\t\t\n\t\twhile ((this.xcoord!=num.xcoord||this.ycoord!=num.ycoord))\n\t\t{\n\t\t\n\t\t\tif (num.xcoord-this.xcoord==1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\n\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==-1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==1)\n\t\t\t{distance ++; this.setCoordinates(this.xcoord, this.ycoord+1);}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==-1) {\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord, this.ycoord-1);\n\t\t\t}\n\t\t\t\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord-1); \n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord+1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord-1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t\t\t{distance ++; this.setCoordinates(this.xcoord-1, this.ycoord+1);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\treturn distance;\n\t}\n\t\n\t\n}\n", "complexity": "linear", "from": "CorCod", "problem": 70, "index": 70}
{"src": "\n// Java program to Find the repeating \n// and missing elements \n\nimport\njava.io.*; \n\nclass\nGFG { \n\n\nstatic\nvoid\nprintTwoElements(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nSystem.out.print(\n\"The repeating element is \"\n); \n\n\nfor\n(i = \n0\n; i < size; i++) { \n\nint\nabs_val = Math.abs(arr[i]); \n\nif\n(arr[abs_val - \n1\n] > \n0\n) \n\narr[abs_val - \n1\n] = -arr[abs_val - \n1\n]; \n\nelse\n\nSystem.out.println(abs_val); \n\n} \n\n\nSystem.out.print(\n\"And the missing element is \"\n); \n\nfor\n(i = \n0\n; i < size; i++) { \n\nif\n(arr[i] > \n0\n) \n\nSystem.out.println(i + \n1\n); \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n7\n, \n3\n, \n4\n, \n5\n, \n5\n, \n6\n, \n2\n}; \n\nint\nn = arr.length; \n\nprintTwoElements(arr, n); \n\n} \n} \n\n// This code is contributed by Gitanjali ", "complexity": "linear", "from": "CorCod", "problem": 71, "index": 71}
{"src": "\n// Java program to update every array element with \n// multiplication of previous and next numbers in array \nimport\njava.io.*; \nimport\njava.util.*; \nimport\njava.lang.Math; \n\nclass\nMultipy \n{ \n\nstatic\nvoid\nmodify(\nint\narr[], \nint\nn) \n\n{ \n\n// Nothing to do when array size is 1 \n\nif\n(n <= \n1\n) \n\nreturn\n; \n\n\n// store current value of arr[0] and update it \n\nint\nprev = arr[\n0\n]; \n\narr[\n0\n] = arr[\n0\n] * arr[\n1\n]; \n\n\n// Update rest of the array elements \n\nfor\n(\nint\ni=\n1\n; i<n-\n1\n; i++) \n\n{ \n\n// Store current value of next interation \n\nint\ncurr = arr[i]; \n\n\n// Update current value using previos value \n\narr[i] = prev * arr[i+\n1\n]; \n\n\n// Update previous value \n\nprev = curr; \n\n} \n\n\n// Update last array element \n\narr[n-\n1\n] = prev * arr[n-\n1\n]; \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nmodify(arr, n); \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n} \n/* This code is contributed by Devesh Agrawal */", "complexity": "linear", "from": "CorCod", "problem": 72, "index": 72}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main\n\t{\t\n\t\tclass node{\n\t\tint data;\n\t\tnode next;\n\t\tpublic node(int val){\n\t\t\tdata=val;\n\t\t\tnext=null;\n\t\t}\n\t}\n\tclass linkedlist{\n\t\tnode start;\n\t\tnode end;\n\t\tint size;\n\t\tint turn;\n\t\tpublic linkedlist(){\n\t\t\tstart=null;\n\t\t\tend=null;\n\t\t\tsize=0;\n\t\t}\n\t\tvoid add(int val){\n\t\t\tif(size==0){\n\t\t\t\tnode t=new node(val);\n\t\t\t\tstart=t;\n\t\t\t\tend=t;\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnode t=new node(val);\n\t\t\t\tend.next=t;\n\t\t\t\tend=end.next;\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tvoid myfunc(){\n\t\t\tif(start.data>start.next.data){\n\t\t\t\t// System.out.println(\"me ni hu\");\n\t\t\t\tnode t=new node(start.next.data);\n\t\t\t\tstart.next=start.next.next;\n\t\t\t\tend.next=t;\n\t\t\t\tend=end.next;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// System.out.println(\"me hu\");\n\t\t\t\tint t=start.data;\n\t\t\t\tstart=start.next;\n\t\t\t\tadd(t);\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tint findmax(){\n\t\t\tint m=0;\n\t\t\tnode temp=start;\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tif(temp.data>m){\n\t\t\t\t\tm=temp.data;\n\t\t\t\t}\n\t\t\t\ttemp=temp.next;\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\tvoid display(){\n\t\t\tnode temp=start;\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tSystem.out.print(temp.data+\" \");\n\t\t\t\ttemp=temp.next;\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t}\n\tlinkedlist l;\n\tpublic Main(){\n\t\tl=new linkedlist();\n\t}\n\tpublic static void main(String [] argv) throws IOException\n\t{\n\t\tBufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n\t\tMain ma=new Main();\n\t\tString[] l1=in.readLine().split(\" \");\n\t\tint n=Integer.parseInt(l1[0]);\n\t\tint q=Integer.parseInt(l1[1]);\n\t\tString[] ar=in.readLine().split(\" \");\n\t\tint a1=Integer.parseInt(ar[0]);\n\t\tint b1=Integer.parseInt(ar[1]);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tma.l.add(Integer.parseInt(ar[i]));\n\t\t}\n\t\tint m=ma.l.findmax();\n\t\tint[][] pair=new int[n][2];\n\t\tint t=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(ma.l.start.data==m)\n\t\t\t\tbreak;\n\t\t\tma.l.myfunc();\n\t\t\tpair[t][0]=ma.l.start.data;\n\t\t\tpair[t][1]=ma.l.start.next.data;\n\t\t\tt++;\n\t\t}\n\t\tint rl[]=new int[n];\n\t\tnode temp=ma.l.start;\n\t\tfor(int i=0;i<n;i++){\n\t\t\trl[i]=temp.data;\n\t\t\ttemp=temp.next;\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tlong a=Long.parseLong(in.readLine());\n\t\t\tif(a==1){\n\t\t\t\tSystem.out.println(a1 + \" \" + b1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(a<=t+1){\n\t\t\t\t\tSystem.out.println(pair[(int)(a-2)][0]+\" \"+pair[(int)(a-2)][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif((a-t)%(n-1)==0){\n\t\t\t\t\t\tSystem.out.println(rl[0]+\" \"+rl[n-1]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tSystem.out.println(rl[0]+\" \"+rl[(int)((a-t)%(n-1))]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 73, "index": 73}
{"src": "\n// Java program to count the number of \n// indexes in range L R such that \n// Ai = Ai+1 \nclass\nGFG { \n\n\n// function that answers every query \n\n// in O(r-l) \n\nstatic\nint\nanswer_query(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n\n{ \n\n\n// traverse from l to r and count \n\n// the required indexes \n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = l; i < r; i++) \n\nif\n(a[i] == a[i + \n1\n]) \n\ncount += \n1\n; \n\n\nreturn\ncount; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = a.length; \n\n\n// 1-st query \n\nint\nL, R; \n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n\n// 2nd query \n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n} \n} \n\n// This code is contribute by \n// Smitha Dinesh Semwal ", "complexity": "linear", "from": "CorCod", "problem": 74, "index": 74}
{"src": "\n// Java program to Split the array and \n// add the first part to the end \nclass\nGeeks \n{ \n\n/* Function to reverse arr[] from index start to end*/\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n{ \n\nwhile\n(start < end) { \n\nint\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nstart++; \n\nend--; \n\n} \n} \n\n// Function to print an array \nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n} \n\n/* Function to left rotate arr[] of size n by k */\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nk, \nint\nn) \n{ \n\nrvereseArray(arr, \n0\n, n - \n1\n); \n\nrvereseArray(arr, \n0\n, n - k - \n1\n); \n\nrvereseArray(arr, n - k, n - \n1\n); \n} \n\n/* Driver program to test above functions */\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\n\n// Function calling \n\nsplitArr(arr, k, n); \n\nprintArray(arr, n); \n\n} \n\n} \n\n// This code is contributed by ankita_saini. ", "complexity": "linear", "from": "CorCod", "problem": 75, "index": 75}
{"src": "\n// Java program for counting n digit numbers with \n// non decreasing digits \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Function that returns count of non- decreasing numbers \n\n// with n digits \n\nstatic\nint\nnonDecNums(\nint\nn) \n\n{ \n\n// a[i][j] = count of all possible number \n\n// with i digits having leading digit as j \n\nint\n[][] a = \nnew\nint\n[n + \n1\n][\n10\n]; \n\n\n// Initialization of all 0-digit number \n\nfor\n(\nint\ni = \n0\n; i <= \n9\n; i++) \n\na[\n0\n][i] = \n1\n; \n\n\n// Initialization of all i-digit \n\n// non-decreasing number leading with 9 \n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\na[i][\n9\n] = \n1\n; \n\n\n// for all digits we should calculate \n\n// number of ways depending upon leading \n\n// digits \n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfor\n(\nint\nj = \n8\n; j >= \n0\n; j--) \n\na[i][j] = a[i - \n1\n][j] + a[i][j + \n1\n]; \n\n\nreturn\na[n][\n0\n]; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Non-decreasing digits = \"\n+ nonDecNums(n)); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "complexity": "linear", "from": "CorCod", "problem": 76, "index": 76}
{"src": "\nclass\nLinkedList { \n\n\n/* head node of link list */\n\nstatic\nLNode head; \n\n\n/* Link list Node */\n\nclass\nLNode \n\n{ \n\nint\ndata; \n\nLNode next, prev; \n\n\nLNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\n/* A Binary Tree Node */\n\nclass\nTNode \n\n{ \n\nint\ndata; \n\nTNode left, right; \n\n\nTNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n\n} \n\n\n/* This function counts the number of nodes in Linked List \n\nand then calls sortedListToBSTRecur() to construct BST */\n\nTNode sortedListToBST() \n\n{ \n\n/*Count the number of nodes in Linked List */\n\nint\nn = countNodes(head); \n\n\n/* Construct BST */\n\nreturn\nsortedListToBSTRecur(n); \n\n} \n\n\n/* The main function that constructs balanced BST and \n\nreturns root of it. \n\nn --> No. of nodes in the Doubly Linked List */\n\nTNode sortedListToBSTRecur(\nint\nn) \n\n{ \n\n/* Base Case */\n\nif\n(n <= \n0\n) \n\nreturn\nnull\n; \n\n\n/* Recursively construct the left subtree */\n\nTNode left = sortedListToBSTRecur(n / \n2\n); \n\n\n/* head_ref now refers to middle node, \n\nmake middle node as root of BST*/\n\nTNode root = \nnew\nTNode(head.data); \n\n\n// Set pointer to left subtree \n\nroot.left = left; \n\n\n/* Change head pointer of Linked List for parent \n\nrecursive calls */\n\nhead = head.next; \n\n\n/* Recursively construct the right subtree and link it \n\nwith root. The number of nodes in right subtree is \n\ntotal nodes - nodes in left subtree - 1 (for root) */\n\nroot.right = sortedListToBSTRecur(n - n / \n2\n- \n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n/* UTILITY FUNCTIONS */\n\n/* A utility function that returns count of nodes in a \n\ngiven Linked List */\n\nint\ncountNodes(LNode head) \n\n{ \n\nint\ncount = \n0\n; \n\nLNode temp = head; \n\nwhile\n(temp != \nnull\n) \n\n{ \n\ntemp = temp.next; \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n/* Function to insert a node at the beginging of \n\nthe Doubly Linked List */\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n/* allocate node */\n\nLNode new_node = \nnew\nLNode(new_data); \n\n\n/* since we are adding at the begining, \n\nprev is always NULL */\n\nnew_node.prev = \nnull\n; \n\n\n/* link the old list off the new node */\n\nnew_node.next = head; \n\n\n/* change prev of head node to new node */\n\nif\n(head != \nnull\n) \n\nhead.prev = new_node; \n\n\n/* move the head to point to the new node */\n\nhead = new_node; \n\n} \n\n\n/* Function to print nodes in a given linked list */\n\nvoid\nprintList(LNode node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\n/* A utility function to print preorder traversal of BST */\n\nvoid\npreOrder(TNode node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList llist = \nnew\nLinkedList(); \n\n\n/* Let us create a sorted linked list to test the functions \n\nCreated linked list will be 7->6->5->4->3->2->1 */\n\nllist.push(\n7\n); \n\nllist.push(\n6\n); \n\nllist.push(\n5\n); \n\nllist.push(\n4\n); \n\nllist.push(\n3\n); \n\nllist.push(\n2\n); \n\nllist.push(\n1\n); \n\n\nSystem.out.println(\n\"Given Linked List \"\n); \n\nllist.printList(head); \n\n\n/* Convert List to BST */\n\nTNode root = llist.sortedListToBST(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Pre-Order Traversal of constructed BST \"\n); \n\nllist.preOrder(root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "linear", "from": "CorCod", "problem": 77, "index": 77}
{"src": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     //if(!set2.contains(b)){\n                            //set2.add(b);\n                     //}else{\n                       //     System.out.println(2);\n                         //   return;\n                     //}\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "complexity": "linear", "from": "CorCod", "problem": 78, "index": 78}
{"src": "\n// Java program to make GCD \n// of array a mutiple of k. \nimport\njava.io.*; \n\nclass\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nn, \nint\nk) \n{ \n\n\nint\nresult = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n\n// If array value is not 1 \n\n// and it is greater than k \n\n// then we can increase the \n\n// or decrease the remainder \n\n// obtained by dividing k \n\n// from the ith value of array \n\n// so that we get the number \n\n// which is either closer to k \n\n// or its multiple \n\nif\n(a[i] != \n1\n&& a[i] > k) \n\n{ \n\nresult = result + \n\nMath.min(a[i] % k, \n\nk - a[i] % k); \n\n} \n\nelse\n\n{ \n\n\n// Else we only have one \n\n// choice which is to \n\n// increment the value \n\n// to make equal to k \n\nresult = result + k - a[i]; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr[] = {\n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n5\n; \n\nSystem.out.println(MinOperation(arr, n, k)); \n} \n} \n\n// This code is contributed \n// by akt_mit ", "complexity": "linear", "from": "CorCod", "problem": 79, "index": 79}
{"src": "import java.util.*;\nimport java.io.*;\npublic class vasyaarray{\npublic static void main(String[] args)throws IOException {\n    FastReader in=new FastReader(System.in);\n        int n=in.nextInt();\n        long arr1[]=new long[n];\n        long pre1[]=new long[n];\n        int i,j;\n        arr1[0]=in.nextLong();\n        pre1[0]=arr1[0];\n        for(i=1;i<n;i++)\n        {\n            arr1[i]=in.nextLong();\n            pre1[i]=pre1[i-1]+arr1[i];\n        }\n        int m=in.nextInt();\n        long arr2[]=new long[m];\n        long pre2[]=new long[m];\n        arr2[0]=in.nextInt();\n        pre2[0]=arr2[0];\n        for(i=1;i<m;i++)\n        {\n            arr2[i]=in.nextInt();\n            pre2[i]=pre2[i-1]+arr2[i];\n        }\n        //System.out.println(Arrays.toString(pre1));\n         //System.out.println(Arrays.toString(pre2));\n        if(pre1[n-1]!=pre2[m-1])\n        System.out.println(\"-1\");\n        else\n        {\n            long s1=0,s2=0;\n            i=j=0;\n            int k=0;\n            while(true)\n            {\n                if(s1==s2)\n                {\n                    if(s1==0)\n                    {\n                        s1=arr1[i++];\n                        s2=arr2[j++];\n                        // System.out.println(s1+\" \"+s2+\" \"+i+\" \"+j);\n                    }\n                    else\n                    {\n                        k++;\n                        s1=s2=0;\n                        //System.out.println(k+\" \"+i+\" \"+j);\n                        if(i==n && j==m)\n                        break;\n                    }\n                }\n                else if(s1>s2)\n                {\n                    s2+=arr2[j++];\n                    //System.out.println(\"1\"+\" \"+s1+\" \"+s2+\" \"+i+\" \"+j);\n                }\n                else\n                {\n                    s1+=arr1[i++];\n                    //System.out.println(\"2 \"+s1+\" \"+s2+\" \"+i+\" \"+j);\n                }\n            }\n            System.out.println(k);\n        }\n    }\n}\nclass FastReader {\n \n    byte[] buf = new byte[2048];\n    int index, total;\n    InputStream in;\n \n    FastReader(InputStream is) {\n        in = is;\n    }\n \n    int scan() throws IOException {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) {\n                return -1;\n            }\n        }\n        return buf[index++];\n    }\n \n    String next() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    String nextLine() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c !=10; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    char nextChar() throws IOException{\n        int c;\n         for (c = scan(); c <= 32; c = scan());\n         return (char)c;\n        }\n \n    int nextInt() throws IOException {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n \n    long nextLong() throws IOException {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 80, "index": 80}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class pr902A {\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        out.println(solve(n, m));\n        out.flush();\n        out.close();\n    }\n\n    private static String solve(int n, int m) {\n        int[] grid = new int[m+1];\n        for (int i = 0; i < n; i++) {\n            int start = in.nextInt();\n            int end = in.nextInt();\n\n            grid[start]++;\n            grid[end]--;\n\n        }\n        int sum = 0;\n        for(int i = 0; i < m; i++){\n            sum += grid[i];\n            if(sum == 0) return \"NO\";\n        }\n\n        return \"YES\";\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 81, "index": 81}
{"src": "\n// Java program to check children sum property \n\n/* A binary tree node has data, pointer to left child \n\nand a pointer to right child */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* returns 1 if children sum property holds for the given \n\nnode and both of its children*/\n\nint\nisSumProperty(Node node) \n\n{ \n\n\n/* left_data is left child data and right_data is for right \n\nchild data*/\n\nint\nleft_data = \n0\n, right_data = \n0\n; \n\n\n/* If node is NULL or it's a leaf node then \n\nreturn true */\n\nif\n(node == \nnull\n\n|| (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n1\n; \n\nelse\n\n{ \n\n\n/* If left child is not present then 0 is used \n\nas data of left child */\n\nif\n(node.left != \nnull\n) \n\nleft_data = node.left.data; \n\n\n/* If right child is not present then 0 is used \n\nas data of right child */\n\nif\n(node.right != \nnull\n) \n\nright_data = node.right.data; \n\n\n/* if the node and both of its children satisfy the \n\nproperty return 1 else 0*/\n\nif\n((node.data == left_data + right_data) \n\n&& (isSumProperty(node.left)!=\n0\n) \n\n&& isSumProperty(node.right)!=\n0\n) \n\nreturn\n1\n; \n\nelse\n\nreturn\n0\n; \n\n} \n\n} \n\n\n/* driver program to test the above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n8\n); \n\ntree.root.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n2\n); \n\nif\n(tree.isSumProperty(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree satisfies children\"\n\n+ \n\" sum property\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree does not satisfy children\"\n\n+ \n\" sum property\"\n); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 82, "index": 82}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main{\npublic static void main(String[] args){\n Scanner s= new Scanner(System.in);\n int n=s.nextInt();StringBuilder sb=new StringBuilder();\n long[] a=new long[n/2];\n for(int i=0;i<n/2;i++){\n                  a[i]=s.nextLong();\n }int j=0;long[] a2=new long[n/2];long[] a1=new long[n/2];\n a1[j]=a[a.length-1]/2;\n a2[j]=a[a.length-1]-a[a.length-1]/2;\n for(int i=(n-1)/2-1;i>=0;i--){\n //    a1[j]=a[i]/2;a2[j++]=a[i]-a[i]/2;\n    long n1=a1[j];\n    if((a[i]-n1)<a2[j]){\n      a2[j+1]=a2[j++];a1[j]=a[i]-a2[j];                      \n     }else{a1[++j]=n1;a2[j]=a[i]-n1;}\n }int k=0;//int[] ans=new int[2*n];\n for(int i=(n-1)/2;i>=0;i--)\n   sb.append(a1[i]+\" \");\n  for(int i=0;i<n/2;i++)\n    sb.append(a2[i]+\" \");\n            System.out.println(sb.toString());     \n}\n}", "complexity": "linear", "from": "CorCod", "problem": 83, "index": 83}
{"src": "\n// Java program to find n-th node of \n// Postorder Traversal of Binary Tree \npublic\nclass\nNthNodePostOrder { \n\n\nstatic\nint\nflag = \n0\n; \n\n\n// function to find the N-th node in the postorder \n\n// traversal of a given binary tree \n\npublic\nstatic\nvoid\nNthPostordernode(Node root, \nint\nN) \n\n{ \n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nif\n(flag <= N) \n\n{ \n\n// left recursion \n\nNthPostordernode(root.left, N); \n\n// right recursion \n\nNthPostordernode(root.right, N); \n\nflag++; \n\n// prints the n-th node of preorder traversal \n\nif\n(flag == N) \n\nSystem.out.print(root.data); \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root = \nnew\nNode(\n25\n); \n\nroot.left = \nnew\nNode(\n20\n); \n\nroot.right = \nnew\nNode(\n30\n); \n\nroot.left.left = \nnew\nNode(\n18\n); \n\nroot.left.right = \nnew\nNode(\n22\n); \n\nroot.right.left = \nnew\nNode(\n24\n); \n\nroot.right.right = \nnew\nNode(\n32\n); \n\n\nint\nN = \n6\n; \n\n\n// prints n-th node found \n\nNthPostordernode(root, N); \n\n} \n} \n\n/* A binary tree node structure */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\n} \n}; \n// This code is contributed by Gaurav Tiwari ", "complexity": "linear", "from": "CorCod", "problem": 84, "index": 84}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\n/* spar5h */\n\npublic class cf1 implements Runnable{    \n\t\n\tpublic void run() {\n\n\t\tInputReader s = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\t\n\t\tint t = 1;\n\t\t\n\t\twhile(t-- > 0) {\n\t\t\t\n\t\t\tint n = s.nextInt(), m = s.nextInt();\n\t\t\t\n\t\t\tint[] a = new int[n + 1];\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\ta[i] = s.nextInt();\n\t\t\t\n\t\t\tint[] b = new int[n + 1];\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\tb[i] = s.nextInt();\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\t\n\t\t\tlist.add(a[1]);\n\t\t\t\n\t\t\tfor(int i = 2; i <= n; i++) {\n\t\t\t\tlist.add(b[i]); list.add(a[i]);\n\t\t\t}\n\t\t\t\n\t\t\tlist.add(b[1]);\n\t\t\t\n\t\t\tdouble wt = m;\n\t\t\tboolean check = true;\n\t\t\t\n\t\t\tfor(int i = list.size() - 1; i >= 0; i--) {\n\t\t\t\t\n\t\t\t\tif(list.get(i) <= 1) {\n\t\t\t\t\tcheck = false; break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdouble x = wt / (list.get(i) - 1);\n\t\t\t\t\t\t\n\t\t\t\twt += x;\n\t\t\t}\n\t\t\t\n\t\t\tif(check)\n\t\t\t\tw.println(wt - m);\n\t\t\telse\n\t\t\t\tw.println(-1);\n\t\t}\n\t\t\n\t\tw.close();\n\t}\n\t\n\tstatic class InputReader {\n\t\t\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars==-1) \n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t \n\t\tpublic String nextLine()\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n\t\t}\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile(isSpaceChar(c)) \n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') \n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\n\t\t\treturn res.toString();\n\t\t}\n\t \n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t \n\t\tpublic String next() \n\t\t{\n\t\t\treturn readString();\n\t\t}\n\t\t\n\t\tpublic interface SpaceCharFilter \n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n    \n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\tnew Thread(null, new cf1(),\"cf1\",1<<26).start();\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 85, "index": 85}
{"src": "import java.util.Scanner;\n\npublic class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 86, "index": 86}
{"src": "\n// Java program to find minimum value node in Binary Search Tree \n\n// A binary tree node \nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode head; \n\n\n/* Given a binary search tree and a number, \n\ninserts a new node with the given number in \n\nthe correct place in the tree. Returns the new \n\nroot pointer which the caller should then use \n\n(the standard trick to avoid using reference \n\nparameters). */\n\nNode insert(Node node, \nint\ndata) { \n\n\n/* 1. If the tree is empty, return a new, \n\nsingle node */\n\nif\n(node == \nnull\n) { \n\nreturn\n(\nnew\nNode(data)); \n\n} \nelse\n{ \n\n\n/* 2. Otherwise, recur down the tree */\n\nif\n(data <= node.data) { \n\nnode.left = insert(node.left, data); \n\n} \nelse\n{ \n\nnode.right = insert(node.right, data); \n\n} \n\n\n/* return the (unchanged) node pointer */\n\nreturn\nnode; \n\n} \n\n} \n\n\n/* Given a non-empty binary search tree, \n\nreturn the minimum data value found in that \n\ntree. Note that the entire tree does not need \n\nto be searched. */\n\nint\nminvalue(Node node) { \n\nNode current = node; \n\n\n/* loop down to find the leftmost leaf */\n\nwhile\n(current.left != \nnull\n) { \n\ncurrent = current.left; \n\n} \n\nreturn\n(current.data); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode root = \nnull\n; \n\nroot = tree.insert(root, \n4\n); \n\ntree.insert(root, \n2\n); \n\ntree.insert(root, \n1\n); \n\ntree.insert(root, \n3\n); \n\ntree.insert(root, \n6\n); \n\ntree.insert(root, \n5\n); \n\n\nSystem.out.println(\n\"Minimum value of BST is \"\n+ tree.minvalue(root)); \n\n} \n} \n\n// This code is contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 87, "index": 87}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int[] a = new int[n];\n        for(int i=0;i<n;i++) a[i] = Integer.parseInt(st.nextToken());\n        int ind = 0;\n        for(int i=0;i<n;i++){\n            if(a[i]==n){\n                ind = i;\n                break;\n            }\n        }\n        boolean ok = true;\n        for(int i=ind+1;i<n;i++) if(a[i]>a[i-1]) ok = false;\n        for(int i=ind-1;i>=0;i--) if(a[i]>a[i+1]) ok = false;\n        if(ok) System.out.println(\"YES\");\n        else System.out.println(\"NO\");\n        \n    }\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 88, "index": 88}
{"src": "import java.util.*;\n\npublic class ErrorCorrectSystem\n{\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\t\n\t\tint[][] mismatch = new int[26][26];\n\t\tfor(int i = 0; i < 26; i++) Arrays.fill(mismatch[i], -1);\n\t\tint[][] pair = new int[2][26];\n\t\tfor(int i = 0; i < 2; i++) Arrays.fill(pair[i], -1);\n\t\tint hd = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\thd++;\n\t\t\t\tmismatch[a.charAt(i)-'a'][b.charAt(i)-'a'] = i;\n\t\t\t\tpair[0][a.charAt(i)-'a'] = i;\n\t\t\t\tpair[1][b.charAt(i)-'a'] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tfor(int j = i+1; j < 26; j++) {\n\t\t\t\tif(mismatch[i][j] > -1 && mismatch[j][i] > -1) {\n\t\t\t\t\tSystem.out.println(hd-2);\n\t\t\t\t\tSystem.out.println((mismatch[i][j]+1)+\" \"+(mismatch[j][i]+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\t//try a gets b's letter\n\t\t\t\tif(pair[0][b.charAt(i)-'a'] > -1) {\n\t\t\t\t\tSystem.out.println(hd-1);\n\t\t\t\t\tSystem.out.println((i+1)+\" \"+(pair[0][b.charAt(i)-'a']+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(hd);\n\t\tSystem.out.println(\"-1 -1\");\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 89, "index": 89}
{"src": "\n// Java program to flip a binary tree \nimport\njava.util.*; \nclass\nGFG \n{ \n\n// A binary tree node \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n// Utility function to create \n// a new Binary Tree Node \n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n// method to flip the binary tree \nstatic\nNode flipBinaryTree(Node root) \n{ \n\n// Initialization of pointers \n\nNode curr = root; \n\nNode next = \nnull\n; \n\nNode temp = \nnull\n; \n\nNode prev = \nnull\n; \n\n\n// Iterate through all left nodes \n\nwhile\n(curr != \nnull\n) \n\n{ \n\nnext = curr.left; \n\n\n// Swapping nodes now, need \n\n// temp to keep the previous \n\n// right child \n\n\n// Making prev's right \n\n// as curr's left child \n\ncurr.left = temp; \n\n\n// Storing curr's right child \n\ntemp = curr.right; \n\n\n// Making prev as curr's \n\n// right child \n\ncurr.right = prev; \n\n\nprev = curr; \n\ncurr = next; \n\n} \n\nreturn\nprev; \n} \n\n// Iterative method to do \n// level order traversal \n// line by line \nstatic\nvoid\nprintLevelOrder(Node root) \n{ \n\n// Base Case \n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n// Create an empty queue for \n\n// level order traversal \n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\n\n// Enqueue Root and \n\n// initialize height \n\nq.add(root); \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n// nodeCount (queue size) \n\n// indicates number of nodes \n\n// at current lelvel. \n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n// Dequeue all nodes of current \n\n// level and Enqueue all nodes \n\n// of next level \n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\n\nSystem.out.print(\n\"Level order traversal \"\n+ \n\n\"of given tree\\n\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\n\nSystem.out.print(\n\"\\nLevel order traversal \"\n+ \n\n\"of the flipped tree\\n\"\n); \n\nprintLevelOrder(root); \n} \n} \n\n// This code is contributed \n// by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 90, "index": 90}
{"src": "\n// Java program to find the Minimum length Unsorted Subarray, \n// sorting which makes the complete array sorted \nclass\nMain \n{ \n\nstatic\nvoid\nprintUnsorted(\nint\narr[], \nint\nn) \n\n{ \n\nint\ns = \n0\n, e = n-\n1\n, i, max, min; \n\n\n// step 1(a) of above algo \n\nfor\n(s = \n0\n; s < n-\n1\n; s++) \n\n{ \n\nif\n(arr[s] > arr[s+\n1\n]) \n\nbreak\n; \n\n} \n\nif\n(s == n-\n1\n) \n\n{ \n\nSystem.out.println(\n\"The complete array is sorted\"\n); \n\nreturn\n; \n\n} \n\n\n// step 1(b) of above algo \n\nfor\n(e = n - \n1\n; e > \n0\n; e--) \n\n{ \n\nif\n(arr[e] < arr[e-\n1\n]) \n\nbreak\n; \n\n} \n\n\n// step 2(a) of above algo \n\nmax = arr[s]; min = arr[s]; \n\nfor\n(i = s + \n1\n; i <= e; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\nif\n(arr[i] < min) \n\nmin = arr[i]; \n\n} \n\n\n// step 2(b) of above algo \n\nfor\n( i = \n0\n; i < s; i++) \n\n{ \n\nif\n(arr[i] > min) \n\n{ \n\ns = i; \n\nbreak\n; \n\n} \n\n} \n\n\n// step 2(c) of above algo \n\nfor\n( i = n -\n1\n; i >= e+\n1\n; i--) \n\n{ \n\nif\n(arr[i] < max) \n\n{ \n\ne = i; \n\nbreak\n; \n\n} \n\n} \n\n\n// step 3 of above algo \n\nSystem.out.println(\n\" The unsorted subarray which\"\n+ \n\n\" makes the given array sorted lies\"\n+ \n\n\" between the indices \"\n+s+\n\" and \"\n+e); \n\nreturn\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n10\n, \n12\n, \n20\n, \n30\n, \n25\n, \n40\n, \n32\n, \n31\n, \n35\n, \n50\n, \n60\n}; \n\nint\narr_size = arr.length; \n\nprintUnsorted(arr, arr_size); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 91, "index": 91}
{"src": "    import jdk.nashorn.internal.objects.NativeArray;\n\n    import javax.swing.JOptionPane ;\n    import javax.swing.plaf.basic.BasicInternalFrameTitlePane;\n    import java.sql.SQLSyntaxErrorException;\n    import java.util.Arrays;\n    import java.util.Scanner;\n    import java.util.Vector;\n\n\n    import static jdk.nashorn.internal.objects.NativeArray.sort;\n    import static jdk.nashorn.internal.runtime.ScriptObject.toPropertyDescriptor;\n\n    public class Dialog1 {\n        private static int n ;\n        private static String s ;\n        private static char[] a;\n        public static void main(String[] args) {\n            Scanner input = new Scanner(System.in);\n            n = input.nextInt() ;\n            s = input.next() ;\n            a = s.toCharArray();\n            for(int i = 0 ; i < 200 ; ++i) {\n                int cur = i ;\n                boolean fl = true ;\n                for(int j = 0 ; j < n ; ++j) {\n                    if(a[j] == '+')\n                        ++cur ;\n                    else\n                        --cur ;\n                    if(cur < 0)\n                        fl = false ;\n                }\n                if(fl) {\n                    System.out.print(cur);\n                    return ;\n                }\n            }\n        }\n    }", "complexity": "linear", "from": "CorCod", "problem": 92, "index": 92}
{"src": "\n// JAVA Code to find total count of an element \n// in a range \n\nclass\nGFG { \n\n\n// Returns count of element in arr[left-1..right-1] \n\npublic\nstatic\nint\nfindFrequency(\nint\narr[], \nint\nn, \n\nint\nleft, \nint\nright, \n\nint\nelement) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = left - \n1\n; i < right; ++i) \n\nif\n(arr[i] == element) \n\n++count; \n\nreturn\ncount; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n8\n, \n6\n, \n9\n, \n8\n, \n6\n, \n8\n, \n2\n, \n11\n}; \n\nint\nn = arr.length; \n\n\n// Print frequency of 2 from position 1 to 6 \n\nSystem.out.println(\n\"Frequency of 2 from 1 to 6 = \"\n+ \n\nfindFrequency(arr, n, \n1\n, \n6\n, \n2\n)); \n\n\n// Print frequency of 8 from position 4 to 9 \n\nSystem.out.println(\n\"Frequency of 8 from 4 to 9 = \"\n+ \n\nfindFrequency(arr, n, \n4\n, \n9\n, \n8\n)); \n\n\n} \n\n} \n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "linear", "from": "CorCod", "problem": 93, "index": 93}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class _1036_B_DiagonalWalkingV2 {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tint Q = readInt();\n\t\twhile(Q-- > 0) {\n\t\t\tlong n = readLong(), m = readLong(), k = readLong();\n\t\t\tif(Math.max(n, m) > k) println(-1);\n\t\t\telse {\n\t\t\t\tlong ans = k;\n\t\t\t\tif(n%2 != k%2) ans--;\n\t\t\t\tif(m%2 != k%2) ans--;\n\t\t\t\tprintln(ans);\n\t\t\t}\n\t\t}\n\t\texit();\n\t}\n\n\tfinal private static int BUFFER_SIZE = 1 << 16;\n\tprivate static DataInputStream din = new DataInputStream(System.in);\n\tprivate static byte[] buffer = new byte[BUFFER_SIZE];\n\tprivate static int bufferPointer = 0, bytesRead = 0;\n\tstatic PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\tpublic static String readLine() throws IOException {\n\t\tbyte[] buf = new byte[64]; // line length\n\t\tint cnt = 0, c;\n\t\twhile ((c = Read()) != -1) {\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t\tbuf[cnt++] = (byte) c;\n\t\t}\n\t\treturn new String(buf, 0, cnt);\n\t}\n\n\tpublic static String read() throws IOException {\n\t\tbyte[] ret = new byte[1024];\n\t\tint idx = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ') {\n\t\t\tc = Read();\n\t\t}\n\t\tdo {\n\t\t\tret[idx++] = c;\n\t\t\tc = Read();\n\t\t} while (c != -1 && c != ' ' && c != '\\n' && c != '\\r');\n\t\treturn new String(ret, 0, idx);\n\t}\n\n\tpublic static int readInt() throws IOException {\n\t\tint ret = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tpublic static long readLong() throws IOException {\n\t\tlong ret = 0;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tpublic static double readDouble() throws IOException {\n\t\tdouble ret = 0, div = 1;\n\t\tbyte c = Read();\n\t\twhile (c <= ' ')\n\t\t\tc = Read();\n\t\tboolean neg = (c == '-');\n\t\tif (neg)\n\t\t\tc = Read();\n\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while ((c = Read()) >= '0' && c <= '9');\n\n\t\tif (c == '.') {\n\t\t\twhile ((c = Read()) >= '0' && c <= '9') {\n\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t}\n\t\t}\n\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\n\tprivate static void fillBuffer() throws IOException {\n\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\tif (bytesRead == -1)\n\t\t\tbuffer[0] = -1;\n\t}\n\n\tprivate static byte Read() throws IOException {\n\t\tif (bufferPointer == bytesRead)\n\t\t\tfillBuffer();\n\t\treturn buffer[bufferPointer++];\n\t}\n\n\tstatic void print(Object o) {\n\t\tpr.print(o);\n\t}\n\n\tstatic void println(Object o) {\n\t\tpr.println(o);\n\t}\n\n\tstatic void flush() {\n\t\tpr.flush();\n\t}\n\n\tstatic void println() {\n\t\tpr.println();\n\t}\n\n\tstatic void exit() throws IOException {\n\t\tdin.close();\n\t\tpr.close();\n\t\tSystem.exit(0);\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 94, "index": 94}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TaskA {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tlong i = sc.nextInt();\n\t\tlong goal = sc.nextLong();\n//\tlong goal=sum;\nif(i>goal) {\n\ti=goal;\n}\n\t\tint count = 0;\n\t\twhile (goal >= 0) {\n\t\t\tif (goal - i >= 0) {\n\t\t\t\tgoal = goal - i;\n\t\t\t\tcount++;\n\t\t\t} else\n\t\t\t\ti--;\n\t\t\tif (goal == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tout.print(count);\n\n\t\tout.flush();\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 95, "index": 95}
{"src": "import java.util.*;\npublic class A\n{\n    public static int palin(String str)\n    {\n        int flag=0;\n        int l=str.length();\n        for(int i=0;i<l/2;i++)\n        {\n            if(str.charAt(i)!=str.charAt(l-i-1))\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==1)\n        return 0;\n        else\n        return 1;\n    }\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        String str=sc.next();\n        HashSet<Character> hs=new HashSet<>();\n        for(int i=0;i<str.length();i++)\n        {\n            hs.add(str.charAt(i));\n        }\n        if(hs.size()==1)\n        System.out.println(0);\n        else if(palin(str)==0)\n        System.out.println(str.length());\n        else\n        System.out.println(str.length()-1);\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 96, "index": 96}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Priya\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        contest1 solver = new contest1();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class contest1 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int x = in.nextInt();\n            String s = \"\";\n            int count = 0;\n\n            int copya = a;\n            int copyb = b;\n            int change = 0;\n\n            if (x == 1) {\n                if (copya > copyb) {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n\n                }\n\n            } else {\n                // out.println(\"got in\");\n                if (copya > copyb) {\n                    while (change <= x - 1) {\n                        if (change % 2 == 0) {\n                            s += '0';\n                            change++;\n                            a--;\n                        } else {\n                            s += '1';\n                            change++;\n                            b--;\n                        }\n                    }\n\n                } else if (copyb >= copya) {\n                    //out.println(\"got in in \");\n                    while (change <= x - 1) {\n                        //out.println(change+\" hmm\");\n                        if (change % 2 == 0) {\n                            s += '1';\n                            change++;\n                            b--;\n                        } else {\n                            s += '0';\n                            change++;\n                            a--;\n                        }\n                    }\n                }\n\n                char z = s.charAt(s.length() - 1);\n                //out.println(z+\" hm\");\n                if (z == '0') {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                }\n            }\n            out.println(s);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 97, "index": 97}
{"src": "\n// Java implementation to find \n// the sum of all the parent \n// nodes having child node x \nclass\nGFG \n{ \n// sum \nstatic\nint\nsum = \n0\n; \n\n\n// Node of a binary tree \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n// function to get a new node \nstatic\nNode getNode(\nint\ndata) \n{ \n\n// allocate memory for the node \n\nNode newNode = \nnew\nNode(); \n\n\n// put in the data \n\nnewNode.data = data; \n\nnewNode.left = newNode.right = \nnull\n; \n\nreturn\nnewNode; \n} \n\n// function to find the sum of all the \n// parent nodes having child node x \nstatic\nvoid\nsumOfParentOfX(Node root, \nint\nx) \n{ \n\n// if root == NULL \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n// if left or right child \n\n// of root is 'x', then \n\n// add the root's data to 'sum' \n\nif\n((root.left != \nnull\n&& root.left.data == x) || \n\n(root.right != \nnull\n&& root.right.data == x)) \n\nsum += root.data; \n\n\n// recursively find the required \n\n// parent nodes in the left and \n\n// right subtree \n\nsumOfParentOfX(root.left, x); \n\nsumOfParentOfX(root.right, x); \n\n} \n\n// utility function to find the \n// sum of all the parent nodes \n// having child node x \nstatic\nint\nsumOfParentOfXUtil(Node root, \n\nint\nx) \n{ \n\nsum = \n0\n; \n\nsumOfParentOfX(root, x); \n\n\n// required sum of parent nodes \n\nreturn\nsum; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n// binary tree formation \n\nNode root = getNode(\n4\n); \n// 4 \n\nroot.left = getNode(\n2\n); \n// / \\ \n\nroot.right = getNode(\n5\n); \n// 2 5 \n\nroot.left.left = getNode(\n7\n); \n// / \\ / \\ \n\nroot.left.right = getNode(\n2\n); \n// 7 2 2 3 \n\nroot.right.left = getNode(\n2\n); \n\nroot.right.right = getNode(\n3\n); \n\n\nint\nx = \n2\n; \n\n\nSystem.out.println( \n\"Sum = \"\n+ \n\nsumOfParentOfXUtil(root, x)); \n} \n} \n\n// This code is contributed by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 98, "index": 98}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.util.SortedSet;\nimport java.util.Set;\nimport java.util.NavigableSet;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, FastScanner in, FastPrinter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            char[] c = in.next().toCharArray();\n            NavigableSet<Integer> ones = new TreeSet<>();\n            NavigableSet<Integer> zeros = new TreeSet<>();\n            for (int i = 0; i < n; i++) {\n                if (c[i] == '0') zeros.add(i);\n                else ones.add(i);\n            }\n            if (ones.isEmpty() || zeros.isEmpty() || ones.last() - ones.first() + 1 <= k || zeros.last() - zeros.first() + 1 <= k) {\n                out.println(\"tokitsukaze\");\n                return;\n            }\n            if (check(ones, n, k) && check(zeros, n, k)) {\n                out.println(\"quailty\");\n                return;\n            }\n            out.println(\"once again\");\n        }\n\n        private boolean check(NavigableSet<Integer> ones, int n, int k) {\n            for (int i = 0; i + k <= n; i++) {\n                int left = ones.first();\n                int right = ones.last();\n                if (left >= i) {\n                    left = ones.higher(i + k - 1);\n                }\n                if (right < i + k) {\n                    right = ones.lower(i);\n                }\n                if (right - left + 1 > k) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class FastPrinter extends PrintWriter {\n        public FastPrinter(OutputStream out) {\n            super(out);\n        }\n\n        public FastPrinter(Writer out) {\n            super(out);\n        }\n\n    }\n\n    static class FastScanner extends BufferedReader {\n        public FastScanner(InputStream is) {\n            super(new InputStreamReader(is));\n        }\n\n        public int read() {\n            try {\n                int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n                return ret;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n\n        public String next() {\n            StringBuilder sb = new StringBuilder();\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            if (c < 0) {\n                return null;\n            }\n            while (c >= 0 && !isWhiteSpace(c)) {\n                sb.appendCodePoint(c);\n                c = read();\n            }\n            return sb.toString();\n        }\n\n        static boolean isWhiteSpace(int c) {\n            return c >= 0 && c <= 32;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int ret = 0;\n            while (c >= 0 && !isWhiteSpace(c)) {\n                if (c < '0' || c > '9') {\n                    throw new NumberFormatException(\"digit expected \" + (char) c\n                            + \" found\");\n                }\n                ret = ret * 10 + c - '0';\n                c = read();\n            }\n            return ret * sgn;\n        }\n\n        public String readLine() {\n            try {\n                return super.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n    }\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 99, "index": 99}
{"src": "\n// JAVA implementation of left rotation \n// of an array K number of times \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\narr_rot \n{ \n\n// Function to leftRotate array multiple \n\n// times \n\nstatic\nvoid\nleftRotate(\nint\narr[], \nint\nn, \n\nint\nk) \n\n{ \n\n/* To get the starting point of \n\nrotated array */\n\nint\nmod = k % n; \n\n\n// Prints the rotated array from \n\n// start position \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[(i + mod) % n] \n\n+ \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n5\n, \n7\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nint\nk = \n2\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n3\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n4\n; \n\nleftRotate(arr, n, k); \n\n} \n} \n\n// This code is contributed by Sanjal ", "complexity": "linear", "from": "CorCod", "problem": 100, "index": 100}
{"src": "\n// Java program for solution of friends \n// pairing problem Using Recursion \n\nclass\nGFG { \n\nstatic\nint\n[] dp = \nnew\nint\n[\n1000\n]; \n\n\n// Returns count of ways n people \n\n// can remain single or paired up. \n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nif\n(dp[n] != -\n1\n) \n\nreturn\ndp[n]; \n\n\nif\n(n > \n2\n) \n\nreturn\ndp[n] = countFriendsPairings(n - \n1\n) + (n - \n1\n) * countFriendsPairings(n - \n2\n); \n\nelse\n\nreturn\ndp[n] = n; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < \n1000\n; i++) \n\ndp[i] = -\n1\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n} \n\n// This code is contributed by Ita_c. ", "complexity": "linear", "from": "CorCod", "problem": 101, "index": 101}
{"src": "import java.util.*;\nimport java.io.*;\npublic class X\n{\n\tpublic static void main(String args[])throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tString s1 = br.readLine();\n\t\tString s2 = br.readLine();\n\t\tint i=0;\n\t\tchar c1,c2;\n\t\tint cost = 0;\n\t\twhile(i<n)\n\t\t{\n\t\t\tc1 = s1.charAt(i);\n\t\t\tc2 = s2.charAt(i);\n\t\t\tif(c1 != c2)\n\t\t\t{\n\t\t\t\tif((i+1)<n && s1.charAt(i+1) != s2.charAt(i+1) && s1.charAt(i) != s1.charAt(i+1))\n\t\t\t\t{\n\t\t\t\t\tcost +=1;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcost +=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 102, "index": 102}
{"src": "\n// A simple JAVA program to rearrange \n// contents of arr[] such that arr[j] \n// becomes j if arr[i] is j \n\nclass\nGFG { \n\n\n// A simple method to rearrange \n\n// 'arr[0..n-1]' so that 'arr[j]' \n\n// becomes 'i' if 'arr[i]' is 'j' \n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// retrieving old value and \n\n// storing with the new one \n\narr[arr[i] % n] += i * n; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// retrieving new value \n\narr[i] /= n; \n\n} \n\n} \n\n\n// A utility function to print \n\n// contents of arr[0..n-1] \n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n// Drive code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is : \"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is :\"\n); \n\nprintArray(arr, n); \n\n} \n} \n\n// This code has been contributed by 29AjayKumar ", "complexity": "linear", "from": "CorCod", "problem": 103, "index": 103}
{"src": "\n// Java program to divide n integers \n// in two groups such that absolute \n// difference of their sum is minimum \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// To print vector along size \n\nstatic\nvoid\nprintVector(Vector<Integer> v) \n\n{ \n\n// Print vector size \n\nSystem.out.println(v.size()); \n\n\n// Print vector elements \n\nfor\n(\nint\ni = \n0\n; i < v.size(); i++) \n\nSystem.out.print(v.get(i) + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n// To divide n in two groups such that \n\n// absolute difference of their sum is \n\n// minimum \n\nstatic\nvoid\nfindTwoGroup(\nint\nn) \n\n{ \n\n// Find sum of all elements upto n \n\nint\nsum = n * (n + \n1\n) / \n2\n; \n\n\n// Sum of elements of group1 \n\nint\ngroup1Sum = sum / \n2\n; \n\n\nVector<Integer> group1 = \nnew\nVector<Integer>(); \n\nVector<Integer> group2 = \nnew\nVector<Integer>(); \n\n\nfor\n(\nint\ni = n; i > \n0\n; i--) { \n\n\n// If sum is greater then or equal \n\n// to 0 include i in group1 \n\n// otherwise include in group2 \n\nif\n(group1Sum - i >= \n0\n) { \n\n\ngroup1.add(i); \n\n\n// Decrease sum of group1 \n\ngroup1Sum -= i; \n\n} \n\nelse\n{ \n\ngroup2.add(i); \n\n} \n\n} \n\n\n// Print both the groups \n\nprintVector(group1); \n\nprintVector(group2); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nfindTwoGroup(n); \n\n} \n} \n\n// This code is contributed by Gitanjali. ", "complexity": "linear", "from": "CorCod", "problem": 104, "index": 104}
{"src": "\n// Java program to minimize the \n// cost of array minimization \nimport\njava.util.Arrays; \n\npublic\nclass\nGFG { \n\n// Returns minimum possible \n// sum in array B[] \n\nstatic\nint\nminSum(\nint\n[] A, \nint\nn) { \n\nint\nmin_val = Arrays.stream(A).min().getAsInt(); \n\nreturn\n(min_val * (n - \n1\n)); \n\n} \n\n\n// Driver Code \n\nstatic\npublic\nvoid\nmain(String[] args) { \n\nint\n[] A = {\n3\n, \n6\n, \n2\n, \n8\n, \n7\n, \n5\n}; \n\nint\nn = A.length; \n\nSystem.out.println((minSum(A, n))); \n\n\n} \n} \n// This code is contributed by Rajput-Ji ", "complexity": "linear", "from": "CorCod", "problem": 105, "index": 105}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public void solve() {\n        int n = ni();\n        int a = ni();\n        int b = ni();\n\n        long ans = 0;\n        HashMap<Long, Long> m = new HashMap<>();\n        HashMap<String, Long> s = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            ni();\n            long vx = ni();\n            long vy = ni();\n            long v = (long) a * vx - vy;\n            String k = vx + \"|\" + vy;\n            long cs = s.getOrDefault(k, 0L);\n            long c = m.getOrDefault(v, 0L);\n            ans += c - cs;\n            m.put(v, c + 1);\n            s.put(k, cs + 1);\n        }\n        write (ans * 2 + \"\\n\");\n    }\n\n\n\n    public static void main(String[] args) {\n        Main m = new Main();\n        m.solve();\n        try {\n            m.out.close();\n        } catch (IOException e) {}\n    }\n\n    BufferedReader in;\n    BufferedWriter out;\n    StringTokenizer tokenizer;\n    public Main() {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new BufferedWriter(new OutputStreamWriter(System.out));\n    }\n    public String n() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(in.readLine());\n            } catch (IOException e) {}\n        }\n        return tokenizer.nextToken();\n    }\n    public int ni() {\n        return Integer.parseInt(n());\n    }\n    public long nl() {\n        return Long.parseLong(n());\n    }\n    public void write(String s) {\n        try {\n            out.write(s);\n        } catch (IOException e) {}\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 106, "index": 106}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class LectureSleep {\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n    }\n\n    static InputReader r = new InputReader(System.in);\n    static PrintWriter pw = new PrintWriter(System.out);\n\n\n    public static void main(String[] args) {\n        int n = r.nextInt(); // duration of lecture\n        int k = r.nextInt(); // number of minutes keep mishka awake\n        int[] theorems = new int[n+1];\n        for(int i = 1; i <= n; i++){\n            theorems[i] = r.nextInt();\n        }\n        int[] mishka = new int[n+1];\n        for(int i = 1; i <= n; i++){\n            mishka[i] = r.nextInt();\n        }\n        int[] sums = new int[n+1];\n        for(int i = 1; i <= n; i++){\n            if(mishka[i] == 0){\n                sums[i] = sums[i-1] + theorems[i];\n            } else{\n                sums[i] = sums[i-1];\n            }\n        }\n        int max = 0;\n        for(int i = 1; i <= n-k+1; i++){\n            int sum = sums[i+k-1] - sums[i-1];\n            max = Math.max(max, sum);\n        }\n        int totalSum = 0;\n        for(int i = 1; i <= n; i++){\n            if(mishka[i] == 1){\n                totalSum += theorems[i];\n            }\n        }\n\n        pw.println(totalSum + max);\n\n        pw.close();\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 107, "index": 107}
{"src": "\n// Java program to find a pair with the given difference \nimport\njava.io.*; \n\nclass\nPairDifference \n{ \n\n// The function assumes that the array is sorted \n\nstatic\nboolean\nfindPair(\nint\narr[],\nint\nn) \n\n{ \n\nint\nsize = arr.length; \n\n\n// Initialize positions of two elements \n\nint\ni = \n0\n, j = \n1\n; \n\n\n// Search for a pair \n\nwhile\n(i < size && j < size) \n\n{ \n\nif\n(i != j && arr[j]-arr[i] == n) \n\n{ \n\nSystem.out.print(\n\"Pair Found: \"\n+ \n\n\"( \"\n+arr[i]+\n\", \"\n+ arr[j]+\n\" )\"\n); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(arr[j] - arr[i] < n) \n\nj++; \n\nelse\n\ni++; \n\n} \n\n\nSystem.out.print(\n\"No such pair\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n8\n, \n30\n, \n40\n, \n100\n}; \n\nint\nn = \n60\n; \n\nfindPair(arr,n); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "complexity": "linear", "from": "CorCod", "problem": 108, "index": 108}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n\n    private void solve() {\n        int n = scanner.nextInt();\n\n        Map<Integer, Integer> cnt = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            String s = scanner.nextLine();\n\n            LinkedList<Character> st = new LinkedList<>();\n\n            for (char c : s.toCharArray()) {\n                if (c == ')' && !st.isEmpty() && st.getLast() == '(') {\n                    st.pollLast();\n                    continue;\n                }\n                st.addLast(c);\n            }\n\n            int t = st.size();\n            Set<Character> set = new HashSet<>(st);\n            if (set.size() > 1) {\n                continue;\n            }\n            if (set.isEmpty()) {\n                cnt.put(0, cnt.getOrDefault(0, 0) + 1);\n                continue;\n            }\n\n            if (st.getLast() == '(') {\n                cnt.put(t, cnt.getOrDefault(t, 0) + 1);\n            } else {\n                cnt.put(-t, cnt.getOrDefault(-t, 0) + 1);\n            }\n        }\n\n        long ans = 0;\n\n        for (int next : cnt.keySet()) {\n            if (next == 0) {\n                ans += (long) cnt.get(next) * (cnt.get(next) - 1) + cnt.get(next);\n            } else if (next > 0) {\n                int t = next * -1;\n                if (cnt.containsKey(t)) {\n                    ans += (long) cnt.get(next) * cnt.get(t);\n                }\n            }\n        }\n\n        System.out.print(ans);\n\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 109, "index": 109}
{"src": "\nimport\njava.util.HashMap; \n\n/* Program for finding out majority element in an array */\n\nclass\nMajorityElement \n{ \n\nprivate\nstatic\nvoid\nfindMajority(\nint\n[] arr) \n\n{ \n\nHashMap<Integer,Integer> map = \nnew\nHashMap<Integer, Integer>(); \n\n\nfor\n(\nint\ni = \n0\n; i < arr.length; i++) { \n\nif\n(map.containsKey(arr[i])) { \n\nint\ncount = map.get(arr[i]) +\n1\n; \n\nif\n(count > arr.length /\n2\n) { \n\nSystem.out.println(\n\"Majority found :- \"\n+ arr[i]); \n\nreturn\n; \n\n} \nelse\n\nmap.put(arr[i], count); \n\n\n} \n\nelse\n\nmap.put(arr[i],\n1\n); \n\n} \n\nSystem.out.println(\n\" No Majority element\"\n); \n\n} \n\n\n\n/* Driver program to test the above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = \nnew\nint\n[]{\n2\n,\n2\n,\n2\n,\n2\n,\n5\n,\n5\n,\n2\n,\n3\n,\n3\n}; \n\n\nfindMajority(a); \n\n} \n} \n// This code is contributed by karan malhotra ", "complexity": "linear", "from": "CorCod", "problem": 110, "index": 110}
{"src": "import java.util.Scanner;\n\npublic class Test{\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint num=1;\n\t\tint add;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tadd=4*i;\n\t\t\tnum+=add;\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 111, "index": 111}
{"src": "\nimport\njava.util.Arrays; \n\npublic\nclass\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n1\n, \n2\n, \n3\n, \n4\n, \n5\n}; \n\n\n// Method for rotation \n\nstatic\nvoid\nrotate() \n\n{ \n\nint\nx = arr[arr.length-\n1\n], i; \n\nfor\n(i = arr.length-\n1\n; i > \n0\n; i--) \n\narr[i] = arr[i-\n1\n]; \n\narr[\n0\n] = x; \n\n} \n\n\n/* Driver program */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Given Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n\nrotate(); \n\n\nSystem.out.println(\n\"Rotated Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 112, "index": 112}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class BOOL {\n    static char [][]ch;\n    static int n,m;\nprivate static FastReader in =new FastReader();\n    public static void main(String[] args) {\n    int n=in.nextInt();\n    int a[]=new int[1000002];\n    int dp[]=new int[1000002],ans=0;\n    for(int i=0;i<n;i++){a[in.nextInt()]=in.nextInt();}\n    dp[0]=a[0]==0?0:1;\n    for(int i=1;i<1000002;i++){\n    if(a[i]==0){dp[i]=dp[i-1];}\n    else{\n    if(a[i]>=i){dp[i]=1;}\n    else{\n    dp[i]=dp[i-a[i]-1]+1;\n    }}\n    if(dp[i]>=ans)ans=dp[i];\n    }\n        System.out.println(n-ans);\n    }}\nclass FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 113, "index": 113}
{"src": "\n// Java program to check if binay tree is full or not \n\n/* Tree node structure */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* this function checks if a binary tree is full or not */\n\nboolean\nisFullTree(Node node) \n\n{ \n\n// if empty tree \n\nif\n(node == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// if leaf node \n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// if both left and right subtrees are not null \n\n// the are full \n\nif\n((node.left!=\nnull\n) && (node.right!=\nnull\n)) \n\nreturn\n(isFullTree(node.left) && isFullTree(node.right)); \n\n\n// if none work \n\nreturn\nfalse\n; \n\n} \n\n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n20\n); \n\ntree.root.right = \nnew\nNode(\n30\n); \n\ntree.root.left.right = \nnew\nNode(\n40\n); \n\ntree.root.left.left = \nnew\nNode(\n50\n); \n\ntree.root.right.left = \nnew\nNode(\n60\n); \n\ntree.root.left.left.left = \nnew\nNode(\n80\n); \n\ntree.root.right.right = \nnew\nNode(\n70\n); \n\ntree.root.left.left.right = \nnew\nNode(\n90\n); \n\ntree.root.left.right.left = \nnew\nNode(\n80\n); \n\ntree.root.left.right.right = \nnew\nNode(\n90\n); \n\ntree.root.right.left.left = \nnew\nNode(\n80\n); \n\ntree.root.right.left.right = \nnew\nNode(\n90\n); \n\ntree.root.right.right.left = \nnew\nNode(\n80\n); \n\ntree.root.right.right.right = \nnew\nNode(\n90\n); \n\n\nif\n(tree.isFullTree(tree.root)) \n\nSystem.out.print(\n\"The binary tree is full\"\n); \n\nelse\n\nSystem.out.print(\n\"The binary tree is not full\"\n); \n\n} \n} \n\n// This code is contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 114, "index": 114}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A{\n       \n       public static void main(String args[]){\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int ans = 0;\n              for(int i = 1; i <= n; i++){\n                     ans += ((i*2) <= n) ? i : n-i+1;\n              }\n              System.out.println(ans);\n       }\n}", "complexity": "linear", "from": "CorCod", "problem": 115, "index": 115}
{"src": "/**\n * Created by Baelish on 7/30/2018.\n */\n\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            //g[a]++;\n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       /* public char nextChar() {\n            return (char)skip();\n        }*/\n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        /*private char buff[] = new char[1005];\n        public char[] nextCharArray(){\n            int b = skip(), p = 0;\n            while(!(isSpaceChar(b))){\n                buff[p++] = (char)b;\n                b = readByte();\n            }\n            return Arrays.copyOf(buff, p);\n        }*/\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 116, "index": 116}
{"src": "\n// Java program to print cousins of a node \nclass\nGfG { \n\n// A Binary Tree Node \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n// A utility function to create a new Binary \n// Tree Node \nstatic\nNode newNode(\nint\nitem) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = item; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n/* It returns level of the node if it is present \nin tree, otherwise returns 0.*/\nstatic\nint\ngetLevel(Node root, Node node, \nint\nlevel) \n{ \n\n// base cases \n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root == node) \n\nreturn\nlevel; \n\n\n// If node is present in left subtree \n\nint\ndownlevel = getLevel(root.left, node, level+\n1\n); \n\nif\n(downlevel != \n0\n) \n\nreturn\ndownlevel; \n\n\n// If node is not present in left subtree \n\nreturn\ngetLevel(root.right, node, level+\n1\n); \n} \n\n/* Print nodes at a given level such that sibling of \nnode is not printed if it exists */\nstatic\nvoid\nprintGivenLevel(Node root, Node node, \nint\nlevel) \n{ \n\n// Base cases \n\nif\n(root == \nnull\n|| level < \n2\n) \n\nreturn\n; \n\n\n// If current node is parent of a node with \n\n// given level \n\nif\n(level == \n2\n) \n\n{ \n\nif\n(root.left == node || root.right == node) \n\nreturn\n; \n\nif\n(root.left != \nnull\n) \n\nSystem.out.print(root.left.data + \n\" \"\n); \n\nif\n(root.right != \nnull\n) \n\nSystem.out.print(root.right.data + \n\" \"\n); \n\n} \n\n\n// Recur for left and right subtrees \n\nelse\nif\n(level > \n2\n) \n\n{ \n\nprintGivenLevel(root.left, node, level-\n1\n); \n\nprintGivenLevel(root.right, node, level-\n1\n); \n\n} \n} \n\n// This function prints cousins of a given node \nstatic\nvoid\nprintCousins(Node root, Node node) \n{ \n\n// Get level of given node \n\nint\nlevel = getLevel(root, node, \n1\n); \n\n\n// Print nodes of given level. \n\nprintGivenLevel(root, node, level); \n} \n\n// Driver Program to test above functions \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.left.right.right = newNode(\n15\n); \n\nroot.right.left = newNode(\n6\n); \n\nroot.right.right = newNode(\n7\n); \n\nroot.right.left.right = newNode(\n8\n); \n\n\nprintCousins(root, root.left.right); \n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 117, "index": 117}
{"src": "\nimport\njava.util.Arrays; \n\n// Java program to test whether an array \n// can be sorted by swapping adjacent \n// elements using boolean array \n\nclass\nGFG { \n\n\n// Return true if array can be \n\n// sorted otherwise false \n\nstatic\nboolean\nsortedAfterSwap(\nint\nA[], \n\nboolean\nB[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\n// Check bool array B and sorts \n\n// elements for continuos sequence of 1 \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) { \n\nif\n(B[i]) { \n\nj = i; \n\nwhile\n(B[j]) { \n\nj++; \n\n} \n\n// Sort array A from i to j \n\nArrays.sort(A, i, \n1\n+ j); \n\ni = j; \n\n} \n\n} \n\n\n// Check if array is sorted or not \n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n(A[i] != i + \n1\n) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n// Driver program to test sortedAfterSwap() \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n1\n, \n2\n, \n5\n, \n3\n, \n4\n, \n6\n}; \n\nboolean\nB[] = { \nfalse\n, \ntrue\n, \ntrue\n, \ntrue\n, \nfalse\n}; \n\nint\nn = A.length; \n\n\nif\n(sortedAfterSwap(A, B, n)) { \n\nSystem.out.println(\n\"A can be sorted\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"A can not be sorted\"\n); \n\n} \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 118, "index": 118}
{"src": "\n// Java program for special level order traversal \n\nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \n\n/* Class containing left and right child of current \n\nnode and key value*/\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* Given a perfect binary tree, print its nodes in specific \n\nlevel order */\n\nvoid\nprintSpecificLevelOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n// Let us print root and next level first \n\nSystem.out.print(node.data); \n\n\n// Since it is perfect Binary Tree, right is not checked \n\nif\n(node.left != \nnull\n) \n\nSystem.out.print(\n\" \"\n+ node.left.data + \n\" \"\n+ node.right.data); \n\n\n// Do anything more if there are nodes at next level in \n\n// given perfect Binary Tree \n\nif\n(node.left.left == \nnull\n) \n\nreturn\n; \n\n\n// Create a queue and enqueue left and right children of root \n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\nq.add(node.left); \n\nq.add(node.right); \n\n\n// We process two nodes at a time, so we need two variables \n\n// to store two front items of queue \n\nNode first = \nnull\n, second = \nnull\n; \n\n\n// traversal loop \n\nwhile\n(!q.isEmpty()) \n\n{ \n\n// Pop two items from queue \n\nfirst = q.peek(); \n\nq.remove(); \n\nsecond = q.peek(); \n\nq.remove(); \n\n\n// Print children of first and second in reverse order \n\nSystem.out.print(\n\" \"\n+ first.left.data + \n\" \"\n+second.right.data); \n\nSystem.out.print(\n\" \"\n+ first.right.data + \n\" \"\n+second.left.data); \n\n\n// If first and second have grandchildren, enqueue them \n\n// in reverse order \n\nif\n(first.left.left != \nnull\n) \n\n{ \n\nq.add(first.left); \n\nq.add(second.right); \n\nq.add(first.right); \n\nq.add(second.left); \n\n} \n\n} \n\n} \n\n\n// Driver program to test for above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\ntree.root.left.left.left = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n9\n); \n\ntree.root.left.right.left = \nnew\nNode(\n10\n); \n\ntree.root.left.right.right = \nnew\nNode(\n11\n); \n\ntree.root.right.left.left = \nnew\nNode(\n12\n); \n\ntree.root.right.left.right = \nnew\nNode(\n13\n); \n\ntree.root.right.right.left = \nnew\nNode(\n14\n); \n\ntree.root.right.right.right = \nnew\nNode(\n15\n); \n\n\ntree.root.left.left.left.left = \nnew\nNode(\n16\n); \n\ntree.root.left.left.left.right = \nnew\nNode(\n17\n); \n\ntree.root.left.left.right.left = \nnew\nNode(\n18\n); \n\ntree.root.left.left.right.right = \nnew\nNode(\n19\n); \n\ntree.root.left.right.left.left = \nnew\nNode(\n20\n); \n\ntree.root.left.right.left.right = \nnew\nNode(\n21\n); \n\ntree.root.left.right.right.left = \nnew\nNode(\n22\n); \n\ntree.root.left.right.right.right = \nnew\nNode(\n23\n); \n\ntree.root.right.left.left.left = \nnew\nNode(\n24\n); \n\ntree.root.right.left.left.right = \nnew\nNode(\n25\n); \n\ntree.root.right.left.right.left = \nnew\nNode(\n26\n); \n\ntree.root.right.left.right.right = \nnew\nNode(\n27\n); \n\ntree.root.right.right.left.left = \nnew\nNode(\n28\n); \n\ntree.root.right.right.left.right = \nnew\nNode(\n29\n); \n\ntree.root.right.right.right.left = \nnew\nNode(\n30\n); \n\ntree.root.right.right.right.right = \nnew\nNode(\n31\n); \n\n\nSystem.out.println(\n\"Specific Level Order traversal of binary\"\n\n+\n\"tree is \"\n); \n\ntree.printSpecificLevelOrder(tree.root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 119, "index": 119}
{"src": "import java.io.DataInputStream; \nimport java.io.FileInputStream; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.Scanner; \nimport java.util.StringTokenizer;\nimport java.io.BufferedReader; \n\n import java.util.*;\npublic class Main \n{ \nstatic Graph graph[];\n\tpublic static void add_edge(int u,int v)\n\t{\n\t\tgraph[u].adj.add(graph[v]);\n\t\tgraph[v].adj.add(graph[u]);\n\t}\n\tpublic static void dfs(int index)\n\t{\n\t\tGraph z=graph[index];\n\t\tz.vis=1;Graph v;\n\t\tfor( int i=0;i<z.adj.size();i++)\n\t\t{\n\t\t\tv=z.adj.get(i);\n\t\t\tif(v.vis==0)\n\t\t\t{\n\t\t\t\tv.dist=z.dist+1;\n\t\t\t\tv.parent=z.val;\n\t\t\t\tdfs(v.val);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n  \n    public static void main(String[] args) \n    { \n        FastReader sc=new FastReader();\n\t\tint n=sc.nextInt();\n\t\tPair arr[]=new Pair[n];\n\t\tPair pref[]=new Pair[n];\n\t\tPair suff[]=new Pair[n];\n\t\tfor( int i=0;i<n;i++)\n\t\t{\n\t\t\tlong u=sc.nextLong();\n\t\t\tlong v=sc.nextLong();\n\t\t\tarr[i]=new Pair(u,v);\n\t\t\tpref[i]=new Pair(0,0);\n\t\t\tsuff[i]=new Pair(0,0);\n\t\t}\n\t\tpref[0].x=arr[0].x;\n\t\tpref[0].y=arr[0].y;\n\t\tfor( int i=1;i<n;i++)\n\t\t{\n\t\t\tpref[i].x=(long)Math.max(pref[i-1].x,arr[i].x);\n\t\t\tpref[i].y=(long)Math.min(pref[i-1].y,arr[i].y);\n\t\t}\n\t\tsuff[n-1].x=arr[n-1].x;\n\t\tsuff[n-1].y=arr[n-1].y;\n\t\tfor( int i=n-2;i>=0;i--)\n\t\t{\n\t\t\tsuff[i].x=(long)Math.max(suff[i+1].x,arr[i].x);\n\t\t\tsuff[i].y=(long)Math.min(suff[i+1].y,arr[i].y);\n\t\t}\n\t\tlong max=Long.MIN_VALUE;\n\t\tlong ans=0;\n\t\t\n\t\tfor( int i=0;i<n;i++)\n\t\t{\n\t\t\tlong val=Long.MAX_VALUE;\n\t\t\tlong val1=Long.MAX_VALUE;\n\t\t\t\n\t\t\tif(i!=0&&i!=n-1)\n\t\t\t{\n\t\t\t\t val=(long)Math.min(pref[i-1].y,suff[i+1].y)-(long)Math.max(pref[i-1].x,suff[i+1].x);\n\t\t\t\t \n\t\t\t}\n\t\t\telse if(i!=n-1)\n\t\t\t{\n\t\t\t\tval=suff[i+1].y-suff[i+1].x;\n\t\t\t}\n\t\t\telse\n\t\t\t\tval=pref[i-1].y-pref[i-1].x;\n\t\t\t\n\t\t\tans=val;\n\t\t\tif(ans<0)\n\t\t\t\tans=0;\n\t\t\tmax=(long)Math.max(ans,max);\n\t\t}\n\t\tSystem.out.println(max);\n     \n       \n\t\t\n\t\t\n\t\t\n    } \n}\nclass mycomparator implements Comparator<Graph>\n{\n\tpublic int compare(Graph a, Graph b)\n\t{\n\t\treturn b.dist-a.dist;\n\t}\n}\nclass Graph\n{\n\tint vis,col,val;int parent;int deg;int dist;\n\tArrayList<Graph> adj;\n\tGraph(int val)\n\t{\n\t\tvis=0;\n\t\tcol=-1;\n\t\tadj=new ArrayList<>();\n\t\tparent=-1;\n\t\tthis.val=val;\n\t\tdeg=0;\n\t\tdist=-1;\n\t}\n}\nclass Pair\n{\n\tlong x,y;\n\tPair( long x, long y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 120, "index": 120}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class B {\n\tstatic ArrayList<Integer> [] adj;\n\tstatic int [] num;\n\tstatic int dfs(int u, int p){\n\t\tint cnt = 0;\n\t\tfor(int v:adj[u]){\n\t\t\tif(v != p)\n\t\t\t\tcnt += dfs(v, u);\n\t\t}\n\t\tif(adj[u].size() == 1 && u != 0 || u == 0 && adj[0].size() == 0)\n\t\t\tcnt++;\n\t\tnum[cnt]++;\n\t\treturn cnt;\n\t}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tadj = new ArrayList[n];\n\t\tfor (int i = 0; i < adj.length; ++i) {\n\t\t\tadj[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tint p = sc.nextInt()-1;\n\t\t\tadj[p].add(i);\n\t\t\tadj[i].add(p);\n\t\t}\n\t\tnum = new int[n+1];\n\t\tdfs(0, -1);\n\t\tfor (int i = 1; i < num.length; ++i) {\n\t\t\tnum[i] += num[i-1];\n\t\t}\n\t\tint cur = 1;\n\t\tfor (int i = 0; i < num.length; ++i) {\n\t\t\twhile(cur <= num[i]){\n\t\t\t\tout.print(i + \" \");\n\t\t\t\t++cur;\n\t\t\t}\t\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 121, "index": 121}
{"src": "\n// A simple recursive JAVA program to find \n// maximum sum by recursively breaking a \n// number in 3 parts. \nimport\njava.io.*; \n\nclass\nGFG { \n\n\nfinal\nint\nMAX = \n1000000\n; \n\n\n// Function to find the maximum sum \n\nstatic\nint\nbreakSum(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n+\n1\n]; \n\n\n// base conditions \n\ndp[\n0\n] = \n0\n; dp[\n1\n] = \n1\n; \n\n\n// Fill in bottom-up manner using recursive \n\n// formula. \n\nfor\n(\nint\ni=\n2\n; i<=n; i++) \n\ndp[i] = Math.max(dp[i/\n2\n] + dp[i/\n3\n] + dp[i/\n4\n], i); \n\n\nreturn\ndp[n]; \n\n} \n\n\n// Driver program to test the above function \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\nn = \n24\n; \n\nSystem.out.println(breakSum(n)); \n\n} \n} \n// This code is contributed by Amit Kumar ", "complexity": "linear", "from": "CorCod", "problem": 122, "index": 122}
{"src": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class F {\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tlong l[] = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = scanLong();\n\t\t}\n\t\tlong e1 = 0, e2 = 0, ans = 0;\n\t\tboolean water = false;\n\t\tString types = scanString();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong li = l[i], cur;\n\t\t\tswitch (types.charAt(i)) {\n\t\t\tcase 'G':\n\t\t\t\tcur = min(e1, li);\n\t\t\t\te1 -= cur;\n\t\t\t\tli -= cur;\n\t\t\t\te2 += 2 * cur;\n\t\t\t\tans += 2 * cur;\n\t\t\t\te2 += li;\n\t\t\t\tans += 3 * li;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\twater = true;\n\t\t\t\te1 += li;\n\t\t\t\tans += 2 * li;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tcur = min(e1, li);\n\t\t\t\te1 -= cur;\n\t\t\t\tli -= cur;\n\t\t\t\tans += 2 * cur;\n\t\t\t\tcur = min(e2, li);\n\t\t\t\te2 -= cur;\n\t\t\t\tli -= cur;\n\t\t\t\tans += 3 * cur;\n\t\t\t\tans += (water ? 4 : 6) * li;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 123, "index": 123}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Solution{\n    \n    public static long page(long p,long k){\n        \n        return (p-1)/k;\n        \n    }\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        \n        long n = sc.nextLong();\n        int m = sc.nextInt();\n        long k = sc.nextLong();\n        long[] p = new long[m];\n        long del = 0;\n        long nb = 1;\n        int op = 0;\n        for(int i=0;i<m;i++) p[i] = sc.nextLong();\n        for(int i=1;i<m;i++){\n            if(page(p[i]-del,k)!=page(p[i-1]-del,k)){\n                \n                del += nb;\n                nb = 1;\n                op++;\n                \n            }else{\n                nb++;\n                \n            }\n        }\n        if(nb!=0) op++;\n        \n        System.out.println(op);\n        \n    }\n    \n}", "complexity": "linear", "from": "CorCod", "problem": 124, "index": 124}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class pr1073B {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = Integer.parseInt(br.readLine());\n\n        int[] a = new int[n];\n        int[] b = new int[n];\n\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            b[i] = Integer.parseInt(st.nextToken());\n        }\n\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, int[] a, int[] b, PrintWriter out) {\n        boolean[] book = new boolean[n+1];\n        boolean f;\n        int j1 = 0, j2 = 0;\n        for (int i = 0; i < n; i++) {\n            f = false;\n            int num = b[i];\n            if(!book[num]) {\n                f = true;\n                j1 = j2;\n                for (;j2 < n; j2++) {\n                    book[a[j2]] = true;\n                    if (a[j2] == num) {\n                        j2++;\n                        break;\n                    }\n                }\n            }\n            out.print(f ? j2-j1 + \" \": 0 + \" \");\n        }\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 125, "index": 125}
{"src": "import java.util.*;\npublic class java{\n          public static void main(String[]arg) {\n        \t Scanner sc=new Scanner(System.in); \n        \t int x=sc.nextInt();\n        \t String s=sc.next();\n        \t boolean f=true;\n        \t boolean f2=true;\n        \t boolean f3=true;\n        \t boolean f4=true;\n        \t int v=0;\n        \t for(int i=0;i<s.length()-1;i++) {\n        \t\t if(s.charAt(i)==s.charAt(i+1)&&(s.charAt(i)!='?'||s.charAt(i+1)!='?')) {\n        \t\t\t f=false;\n        \t\t\t break;\n        \t\t }else {\n        \t\t\t f=true;\n        \t\t }\n        \t }\n        \t\n        \t \n        \t for(int i=0;i<s.length();i++) {\n        \t\t if(s.charAt(i)=='?') {\n        \t\t\t \n        \t\t\t if(i==0||i==s.length()-1) {\n        \t\t\t\t f2=true; \n        \t\t\t\t v++;\n        \t\t\t }else if(s.charAt(i)==s.charAt(i+1)) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t          }\n        \t\t\t else if(s.charAt(i-1)==s.charAt(i+1)&&i!=0&&i!=s.length()-1) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t         }\n        \t\t\t }else {\n        \t\t\t\t if(v>0) f2=true;\n        \t\t\t\t else f2=false;\n        \t\t\t }\n        \t\t }\n        \t \n        \tif(f&&f2) {\n        \t\tSystem.out.println(\"YES\");\n        \t}else {\n        \t\tSystem.out.println(\"NO\");\n        \t}\n          }\n          \n}\n", "complexity": "linear", "from": "CorCod", "problem": 126, "index": 126}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.util.Map.Entry;\n\npublic class Codeforces {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < n; i++){\n            arr[i] = Integer.parseInt(st.nextToken());\n        }\n        for(int i = 0; i < n; i++){\n            if(arr[i] % 2 == 0){\n                arr[i]--;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            pw.print(arr[i] + \" \");\n        }\n        pw.flush();\n        pw.close();\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 127, "index": 127}
{"src": "\n// Java program to convert a tree into its sum tree \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n// Convert a given tree to a tree where every node contains sum of \n\n// values of nodes in left and right subtrees in the original tree \n\nint\ntoSumTree(Node node) \n\n{ \n\n// Base case \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\n// Store the old value \n\nint\nold_val = node.data; \n\n\n// Recursively call for left and right subtrees and store the sum \n\n// as new value of this node \n\nnode.data = toSumTree(node.left) + toSumTree(node.right); \n\n\n// Return the sum of values of nodes in left and right subtrees \n\n// and old_value of this node \n\nreturn\nnode.data + old_val; \n\n} \n\n\n// A utility function to print inorder traversal of a Binary Tree \n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n/* Driver function to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n/* Constructing tree given in the above figure */\n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(-\n2\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n8\n); \n\ntree.root.left.right = \nnew\nNode(-\n4\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n5\n); \n\n\ntree.toSumTree(tree.root); \n\n\n// Print inorder traversal of the converted tree to test result \n\n// of toSumTree() \n\nSystem.out.println(\n\"Inorder Traversal of the resultant tree is:\"\n); \n\ntree.printInorder(tree.root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 128, "index": 128}
{"src": "\n// Java Program to find maximum in arr[] \nclass\nTest \n{ \n\nstatic\nint\narr[] = {\n10\n, \n324\n, \n45\n, \n90\n, \n9808\n}; \n\n\n// Method to find maximum in arr[] \n\nstatic\nint\nlargest() \n\n{ \n\nint\ni; \n\n\n// Initialize maximum element \n\nint\nmax = arr[\n0\n]; \n\n\n// Traverse array elements from second and \n\n// compare every element with current max \n\nfor\n(i = \n1\n; i < arr.length; i++) \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n\nreturn\nmax; \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Largest in given array is \"\n+ largest()); \n\n} \n\n} ", "complexity": "linear", "from": "CorCod", "problem": 129, "index": 129}
{"src": "\n// A space efficient Java program to rearrange contents of \n// arr[] such that arr[j] becomes j if arr[i] is j \n\nclass\nRearrangeArray { \n\n// A utility function to rearrange elements in the cycle \n\n// starting at arr[i]. This function assumes values in \n\n// arr[] be from 1 to n. It changes arr[j-1] to i+1 \n\n// if arr[i-1] is j+1 \n\nvoid\nrearrangeUtil(\nint\narr[], \nint\nn, \nint\ni) \n\n{ \n\n// 'val' is the value to be stored at 'arr[i]' \n\n\n// The next value is determined using current index \n\nint\nval = -(i + \n1\n); \n\n\n// The next index is determined \n\n// using current value \n\ni = arr[i] - \n1\n; \n\n\n// While all elements in cycle are not processed \n\nwhile\n(arr[i] > \n0\n) { \n\n// Store value at index as it is going to be \n\n// used as next index \n\nint\nnew_i = arr[i] - \n1\n; \n\n\n// Update arr[] \n\narr[i] = val; \n\n\n// Update value and index for next iteration \n\nval = -(i + \n1\n); \n\ni = new_i; \n\n} \n\n} \n\n\n// A space efficient method to rearrange 'arr[0..n-1]' \n\n// so that 'arr[j]' becomes 'i' if 'arr[i]' is 'j' \n\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n// Increment all values by 1, so that all elements \n\n// can be made negative to mark them as visited \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i]++; \n\n\n// Process all cycles \n\nfor\n(i = \n0\n; i < n; i++) { \n\n// Process cycle starting at arr[i] if this cycle is \n\n// not already processed \n\nif\n(arr[i] > \n0\n) \n\nrearrangeUtil(arr, n, i); \n\n} \n\n\n// Change sign and values of arr[] to get the original \n\n// values back, i.e., values in range from 0 to n-1 \n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = (-arr[i]) - \n1\n; \n\n} \n\n\n// A utility function to print contents of arr[0..n-1] \n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 130, "index": 130}
{"src": "\nimport java.io.*;\nimport java.util.Scanner;\npublic class abc{\n    public static int check(StringBuilder s)\n    {\n    \tint countRemove=0;\n    \tif(!s.toString().contains(\"xxx\")) return countRemove;\n    \telse{\n    \t\t\n    \t\tfor(int i=1;i<s.length()-1;i++)\n    \t\t{\n    \t\t\tif(s.charAt(i-1)=='x' && s.charAt(i)=='x' && s.charAt(i+1)=='x')\n    \t\t\t{\n    \t\t\t\n    \t\t\t\tcountRemove++;\n    \t\t\t}\n    \t\t}\n    \t\treturn countRemove;\n    \t}\n    }\n   \n\tpublic static void main (String[] args) {\n\t\n\tScanner sc = new Scanner(System.in);\n\tint n = sc.nextInt();\n\t//sc= new Scanner(System.in);\n\tString s = sc.next();\n\tStringBuilder sb = new StringBuilder(\"\");\n\tsb.append(s);\n\t\n    System.out.println(check(sb));\n\t\n\t\n\t\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 131, "index": 131}
{"src": "\n// Java implementation of brute \n// force solution. \nimport\njava.util.LinkedHashSet; \n\nclass\nGFG \n{ \n// Function to check if the given \n// number has repeated digit or not \nstatic\nint\nrepeated_digit(\nint\nn) \n{ \n\nLinkedHashSet<Integer> s = \nnew\nLinkedHashSet<>(); \n\n\n// Traversing through each digit \n\nwhile\n(n != \n0\n) \n\n{ \n\nint\nd = n % \n10\n; \n\n\n// if the digit is present \n\n// more than once in the \n\n// number \n\nif\n(s.contains(d)) \n\n{ \n\n// return 0 if the number \n\n// has repeated digit \n\nreturn\n0\n; \n\n} \n\ns.add(d); \n\nn = n / \n10\n; \n\n} \n\n\n// return 1 if the number has \n\n// no repeated digit \n\nreturn\n1\n; \n} \n\n// Function to find total number \n// in the given range which has \n// no repeated digit \nstatic\nint\ncalculate(\nint\nL, \nint\nR) \n{ \n\nint\nanswer = \n0\n; \n\n\n// Traversing through the range \n\nfor\n(\nint\ni = L; i < R + \n1\n; ++i) \n\n{ \n\n\n// Add 1 to the answer if i has \n\n// no repeated digit else 0 \n\nanswer = answer + repeated_digit(i); \n\n} \n\n\nreturn\nanswer; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nL = \n1\n, R = \n100\n; \n\n\n// Calling the calculate \n\nSystem.out.println(calculate(L, R)); \n} \n} \n\n// This code is contributed by RAJPUT-JI ", "complexity": "linear", "from": "CorCod", "problem": 132, "index": 132}
{"src": "\n// Java program to see if two trees \n// are mirror of each other \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode a, b; \n\n\n/* Given two trees, return true if they are \n\nmirror of each other */\n\nboolean\nareMirror(Node a, Node b) \n\n{ \n\n/* Base case : Both empty */\n\nif\n(a == \nnull\n&& b == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// If only one is empty \n\nif\n(a == \nnull\n|| b == \nnull\n) \n\nreturn\nfalse\n; \n\n\n/* Both non-empty, compare them recursively \n\nNote that in recursive calls, we pass left \n\nof one tree and right of other tree */\n\nreturn\na.data == b.data \n\n&& areMirror(a.left, b.right) \n\n&& areMirror(a.right, b.left); \n\n} \n\n\n// Driver code to test above methods \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode a = \nnew\nNode(\n1\n); \n\nNode b = \nnew\nNode(\n1\n); \n\na.left = \nnew\nNode(\n2\n); \n\na.right = \nnew\nNode(\n3\n); \n\na.left.left = \nnew\nNode(\n4\n); \n\na.left.right = \nnew\nNode(\n5\n); \n\n\nb.left = \nnew\nNode(\n3\n); \n\nb.right = \nnew\nNode(\n2\n); \n\nb.right.left = \nnew\nNode(\n5\n); \n\nb.right.right = \nnew\nNode(\n4\n); \n\n\nif\n(tree.areMirror(a, b) == \ntrue\n) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "linear", "from": "CorCod", "problem": 133, "index": 133}
{"src": "\n// Java program to find the maximum stolen value \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Function to calculate the maximum stolen value \n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\nif\n(n == \n1\n) \n\nreturn\nhval[\n0\n]; \n\nif\n(n == \n2\n) \n\nreturn\nMath.max(hval[\n0\n], hval[\n1\n]); \n\n\n// dp[i] represent the maximum value stolen \n\n// so far after reaching house i. \n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n// Initialize the dp[0] and dp[1] \n\ndp[\n0\n] = hval[\n0\n]; \n\ndp[\n1\n] = Math.max(hval[\n0\n], hval[\n1\n]); \n\n\n// Fill remaining positions \n\nfor\n(\nint\ni = \n2\n; i<n; i++) \n\ndp[i] = Math.max(hval[i]+dp[i-\n2\n], dp[i-\n1\n]); \n\n\nreturn\ndp[n-\n1\n]; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "complexity": "linear", "from": "CorCod", "problem": 134, "index": 134}
{"src": "\n import java.io.*;\n\nimport java.util.*;\nimport java.util.Collections;\nimport java.util.Arrays;\n\n\npublic class Codechef {\n     \n\n  public static void main(String[] args) throws IOException {\n\tScanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a=sc.nextInt();\n    int b=sc.nextInt();\n      int res=0;\n     for(int i=1;i<n;i++)\n     res=Math.max(res, Math.min(a/i, b/(n-i) ) );\n     System.out.println(res);\n  }\n\n   }\n  \n\n\n\n\n\n\n\n\n", "complexity": "linear", "from": "CorCod", "problem": 135, "index": 135}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Cf1003A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int[] arr = new int[100];\n        int max = 0;\n        int tmp;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken()) - 1;\n           max = max < ++arr[tmp] ? arr[tmp] : max;\n        }\n        System.out.println(max);\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 136, "index": 136}
{"src": "import java.util.*;\n\npublic class CoinsTask {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint S = in.nextInt();\n\t\tint mCoins = 0;\n\t\twhile(S/n != 0) {\n\t\t\tmCoins+=1;\n\t\t\tS-=n;\n\t\t}\n\t\tmCoins = S == 0? mCoins : mCoins+1;\n\t\tSystem.out.print(mCoins);\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 137, "index": 137}
{"src": "\n/* Java program to flip a binary tree */\nimport\njava.util.Queue; \nimport\njava.util.LinkedList; \npublic\nclass\nFlipTree { \n\n\n// method to flip the binary tree \n\npublic\nstatic\nNode flipBinaryTree(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\nroot; \n\nif\n(root.left == \nnull\n&& root.right ==\nnull\n) \n\nreturn\nroot; \n\n\n// recursively call the same method \n\nNode flippedRoot=flipBinaryTree(root.left); \n\n\n// rearranging main root Node after returning \n\n// from recursive call \n\nroot.left.left=root.right; \n\nroot.left.right=root; \n\nroot.left=root.right=\nnull\n; \n\nreturn\nflippedRoot; \n\n} \n\n\n// Iterative method to do level order traversal \n\n// line by line \n\npublic\nstatic\nvoid\nprintLevelOrder(Node root) \n\n{ \n\n// Base Case \n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n// Create an empty queue for level order traversal \n\nQueue<Node> q=\nnew\nLinkedList<>(); \n\n// Enqueue Root and initialize height \n\nq.add(root); \n\nwhile\n(\ntrue\n) \n\n{ \n\n// nodeCount (queue size) indicates number \n\n// of nodes at current lelvel. \n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n// Dequeue all nodes of current level and \n\n// Enqueue all nodes of next level \n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.remove(); \n\nSystem.out.print(node.data+\n\" \"\n); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left=\nnew\nNode(\n2\n); \n\nroot.right=\nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n4\n); \n\nroot.right.right = \nnew\nNode(\n5\n); \n\nSystem.out.println(\n\"Level order traversal of given tree\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\nSystem.out.println(\n\"Level order traversal of flipped tree\"\n); \n\nprintLevelOrder(root); \n\n} \n} \n\n/* A binary tree node structure */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\n} \n}; \n//This code is contributed by Gaurav Tiwari ", "complexity": "linear", "from": "CorCod", "problem": 138, "index": 138}
{"src": "import java.util.*;\npublic class Solution{\n\tpublic static void main(String sp[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString st = sc.next();\n\t\t\n\t\tchar arr[] = st.toCharArray();\n\t\t\n\t\tboolean b=false;\n\t\tfor(char j='a';j<='z';j++){\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]==j){\n\t\t\t\tarr[i]='*';\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tif(k==0){\n\t\t\t\tb=true;\n\t\t\t\tprin(arr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}}\n\n\t}\n\t\n\tpublic static void prin(char arr[]){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]!='*')\n\t\t\t\tsb.append(arr[i]);\n\t\t}\n\t\tif(sb.length()!=0)\n\t\t\tSystem.out.println(sb.toString());\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 139, "index": 139}
{"src": "\nimport\njava.io.*; \n\nclass\nPairSum { \n\n\n// Fills element in arr[] from its pair sum array pair[]. \n\n// n is size of arr[] \n\nstatic\nvoid\nconstructArr(\nint\narr[], \nint\npair[], \nint\nn) \n\n{ \n\narr[\n0\n] = (pair[\n0\n]+pair[\n1\n]-pair[n-\n1\n]) / \n2\n; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\narr[i] = pair[i-\n1\n]-arr[\n0\n]; \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\npair[] = {\n15\n, \n13\n, \n11\n, \n10\n, \n12\n, \n10\n, \n9\n, \n8\n, \n7\n, \n5\n}; \n\nint\nn = \n5\n; \n\nint\n[] arr = \nnew\nint\n[n]; \n\nconstructArr(arr, pair, n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n} \n/* This code is contributed by Devesh Agrawal */", "complexity": "linear", "from": "CorCod", "problem": 140, "index": 140}
{"src": "\n// Java implementation of an O(n) approach of level order \n// traversal in spiral form \n\nimport\njava.util.*; \n\n// A Binary Tree node \nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n// NULL check \n\n\n// Create two stacks to store alternate levels \n\n// For levels to be printed from right to left \n\nStack<Node> s1 = \nnew\nStack<Node>(); \n\n// For levels to be printed from left to right \n\nStack<Node> s2 = \nnew\nStack<Node>(); \n\n\n// Push first level to first stack 's1' \n\ns1.push(node); \n\n\n// Keep printing while any of the stacks has some nodes \n\nwhile\n(!s1.empty() || !s2.empty()) { \n\n// Print nodes of current level from s1 and push nodes of \n\n// next level to s2 \n\nwhile\n(!s1.empty()) { \n\nNode temp = s1.peek(); \n\ns1.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n// Note that is right is pushed before left \n\nif\n(temp.right != \nnull\n) \n\ns2.push(temp.right); \n\n\nif\n(temp.left != \nnull\n) \n\ns2.push(temp.left); \n\n} \n\n\n// Print nodes of current level from s2 and push nodes of \n\n// next level to s1 \n\nwhile\n(!s2.empty()) { \n\nNode temp = s2.peek(); \n\ns2.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n// Note that is left is pushed before right \n\nif\n(temp.left != \nnull\n) \n\ns1.push(temp.left); \n\nif\n(temp.right != \nnull\n) \n\ns1.push(temp.right); \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral Order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "linear", "from": "CorCod", "problem": 141, "index": 141}
{"src": "import javax.print.DocFlavor;\nimport javax.swing.plaf.basic.BasicInternalFrameTitlePane;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.net.CookieHandler;\nimport java.nio.Buffer;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.sql.BatchUpdateException;\nimport java.util.*;\nimport java.util.stream.Stream;\nimport java.util.Vector;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport static java.lang.Math.*;\nimport java.util.*;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Iterator;\nimport java.util.PriorityQueue;\n\npublic class icpc\n{\n    public static void main(String[] args)throws IOException\n    {\n//        Reader in = new Reader();\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        String s1[] = in.readLine().split(\" \");\n        int  n = Integer.parseInt(s1[0]);\n        int p = Integer.parseInt(s1[1]);\n        String s = in.readLine();\n        StringBuilder stringBuilder = new StringBuilder(s);\n        boolean flag = false;\n        for(int i=0;i<n;i++)\n        {\n            if(i + p < n)\n            {\n                if(s.charAt(i) != '.' && s.charAt(i + p) != '.' && s.charAt(i) != s.charAt(i + p))\n                {\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) != '.')\n                {\n                    int x = s.charAt(i + p) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) != '.' && s.charAt(i + p) == '.')\n                {\n                    int x = s.charAt(i) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i + p, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) == '.')\n                {\n                    stringBuilder.setCharAt(i, '1');\n                    stringBuilder.setCharAt(i + p, '0');\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        if(flag)\n        {\n            for(int i=0;i<stringBuilder.length();i++)\n            {\n                if(stringBuilder.charAt(i) == '.')\n                {\n                    stringBuilder.setCharAt(i, '0');\n                }\n            }\n            System.out.println(stringBuilder);\n        }\n        else\n            System.out.println(\"No\");\n\n\n    }\n}\nclass StringAlgorithms\n{\n    public int[] calculateZ(char input[]) {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        for(int k = 1; k < input.length; k++) {\n            if(k > right) {\n                left = right = k;\n                while(right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n                //we are operating inside box\n                int k1 = k - left;\n                //if value does not stretches till right bound then just copy it.\n                if(Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else { //otherwise try to see if there are more matches.\n                    left = k;\n                    while(right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n        }\n        return Z;\n    }\n    public ArrayList<Integer> matchPattern(char text[], char pattern[]) {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for(char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for(char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n\n        for(i = 0; i < Z.length ; i++) {\n            if(Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\nclass BasicFunctions\n{\n    public long min(long[] A)\n    {\n        long min = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            min = Math.min(min, A[i]);\n        }\n        return min;\n    }\n    public long max(long[] A)\n    {\n        long max = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            max = Math.max(max, A[i]);\n        }\n        return max;\n    }\n}\nclass Name implements Comparable<Name>\n{\n    int x;\n    int y;\n\n    public Name(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int compareTo(Name ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        return 0;\n    }\n}\nclass Matrix\n{\n    long a;\n    long b;\n    long c;\n    long d;\n\n    public Matrix(long a, long b, long c, long d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n}\nclass Game implements Comparable<Game>\n{\n    long x;\n    long y;\n\n    public Game(long x, long y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public int compareTo(Game ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        else\n        {\n            if(this.y < ob.y)\n                return -1;\n            else if(this.y > ob.y)\n                return 1;\n            else\n                return 0;\n        }\n    }\n}\nclass MergeSortInt\n{\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    void merge(int arr[], int l, int m, int r) {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        /* Create temp arrays */\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        /* Merge the temp arrays */\n\n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            // Find the middle point\n            int m = (l + r) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\n}\nclass MergeSortLong\n{\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    void merge(long arr[], int l, int m, int r) {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        /* Create temp arrays */\n        long L[] = new long[n1];\n        long R[] = new long[n2];\n\n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        /* Merge the temp arrays */\n\n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(long arr[], int l, int r) {\n        if (l < r) {\n            // Find the middle point\n            int m = (l + r) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n}\nclass Node\n{\n    String a;\n    String b;\n    Node(String s1,String s2)\n    {\n        this.a = s1;\n        this.b = s2;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {\n        if(ob == null)\n            return false;\n        if(!(ob instanceof Node))\n            return false;\n        if(ob == this)\n            return true;\n        Node obj = (Node)ob;\n        if(this.a.equals(obj.a) && this.b.equals(obj.b))\n            return true;\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int)this.a.length();\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; // line length\n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\nclass FenwickTree\n{\n    public void update(long[] fenwickTree,long delta,int index)\n    {\n        index += 1;\n        while(index < fenwickTree.length)\n        {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n    public long prefixSum(long[] fenwickTree,int index)\n    {\n        long sum = 0L;\n        index += 1;\n        while(index > 0)\n        {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\nclass SegmentTree\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n    public int[] createSegmentTree(int[] input)\n    {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n\n        for(int i=0;i<segmentTree.length;i++)\n            segmentTree[i] = Integer.MIN_VALUE;\n\n        constructSegmentTree(segmentTree,input,0,input.length-1,0);\n        return segmentTree;\n\n    }\n    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/ 2;\n        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);\n        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);\n    }\n    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)\n    {\n        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);\n    }\n    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)\n    {\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n        if(qlow > high || qhigh < low){\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low+high)/2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 142, "index": 142}
{"src": " import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.awt.*;\nimport java.awt.geom.*;\nimport java.math.*;\nimport java.text.*;\nimport java.math.BigInteger.*;\nimport java.util.Arrays; \n\npublic class   CF111111\n{\n  BufferedReader in;\n  StringTokenizer as;\n  int nums[],nums2[];\n  int[] nums1[];\n  boolean con = true;\n \n  ArrayList < Integer >  ar = new ArrayList < Integer >();\n  ArrayList < Integer >  fi = new ArrayList < Integer >();\n  Map<Integer,Integer > map = new HashMap<Integer, Integer>();\n  public static void main (String[] args)\n  {\n    new CF111111  ();\n  }\n  \n  public int GCD(int a, int b) {\n    if (b==0) return a;\n    return GCD(b,a%b);\n  }\n  \n  public int LIS(int arr[])\n  {\n    int n = arr.length;\n    int sun[] = new int [n];\n    int cur = 0;\n    for(int x = 0;x<n;x++)\n    {\n      int temp = Arrays.binarySearch(sun,0,cur,arr[x]);\n      if(temp < 0)\n        temp = -temp -1;\n      sun[temp] = arr[x];\n      if(temp == cur)\n        cur++;\n    }\n    return cur;\n    \n  }\n  \n  \n  \n  \n  public CF111111  ()\n  {\n    try\n    {\n      \n      in = new BufferedReader (new InputStreamReader (System.in));\n      int a = nextInt();\n      for(int xx1 = 0;xx1<a;xx1++)\n      {\n        int b = nextInt();\n        nums = new int [b];\n        for(int x = 0;x<b;x++)\n        {\n          nums[x] = nextInt();\n        }\n         int max = 0;\n         int max2 = -1;\n         for(int x = 0;x<b;x++)\n         {\n           if(nums[x] >= max)\n           {\n             max2 = max;\n             max = nums[x];\n           }\n           else if(nums[x] >= max2)\n             max2 = nums[x];\n         }\n        System.out.println(Math.min(max2, b-1)-1);\n      }\n    }\n    catch(IOException e)\n    {\n\n    }\n  }\n  \n  \n  \n  \n  \n  \n  \n  String next () throws IOException\n  {\n    while (as == null || !as.hasMoreTokens ())\n    {\n      as = new StringTokenizer (in.readLine ().trim ());\n    }\n    \n    \n    return as.nextToken ();\n  }\n  \n  \n  \n  long nextLong () throws IOException\n  {\n    return Long.parseLong (next ());\n  }\n  \n  \n  int nextInt () throws IOException\n  {\n    return Integer.parseInt (next ());\n  }\n  \n  \n  double nextDouble () throws IOException\n  {\n    return Double.parseDouble (next ());\n  }\n  \n  \n  String nextLine () throws IOException\n  {\n    return in.readLine ().trim ();\n  }\n}", "complexity": "linear", "from": "CorCod", "problem": 143, "index": 143}
{"src": "\n// A O(n) time and O(1) extra \n// space solution to calculate \n// the Permutation Coefficient \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nint\nPermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nFn = \n1\n, Fk = \n1\n; \n\n\n// Compute n! and (n-k)! \n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\nFn *= i; \n\nif\n(i == n - k) \n\nFk = Fn; \n\n} \n\nint\ncoeff = Fn / Fk; \n\nreturn\ncoeff; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ \n\nk +\n\") is \"\n+ \n\nPermutationCoeff(n, k) ); \n\n} \n} \n\n// This code is contributed by Nikita Tiwari. ", "complexity": "linear", "from": "CorCod", "problem": 144, "index": 144}
{"src": "\n// A Java program to remove BST \n// keys outside the given range \nimport\njava.math.BigDecimal; \nimport\njava.util.ArrayList; \nimport\njava.util.Arrays; \nimport\njava.util.List; \nimport\njava.util.Scanner; \n\nclass\nNode \n{ \n\nint\nkey; \n\nNode left; \n\nNode right; \n} \n\nclass\nGFG \n{ \n\n// Removes all nodes having value \n\n// outside the given range and \n\n// returns the root of modified tree \n\nprivate\nstatic\nNode removeOutsideRange(Node root, \n\nint\nmin, \nint\nmax) \n\n{ \n\n// BASE CASE \n\nif\n(root == \nnull\n) \n\n{ \n\nreturn\nnull\n; \n\n} \n\n\n// FIRST FIX THE LEFT AND \n\n// RIGHT SUBTREE OF ROOT \n\nroot.left = removeOutsideRange(root.left, \n\nmin, max); \n\nroot.right = removeOutsideRange(root.right, \n\nmin, max); \n\n\n// NOW FIX THE ROOT. THERE ARE \n\n// TWO POSSIBLE CASES FOR THE ROOT \n\n// 1. a) Root's key is smaller than \n\n// min value(root is not in range) \n\nif\n(root.key < min) \n\n{ \n\nNode rchild = root.right; \n\nroot = \nnull\n; \n\nreturn\nrchild; \n\n} \n\n\n// 1. b) Root's key is greater than \n\n// max value (Root is not in range) \n\nif\n(root.key > max) \n\n{ \n\nNode lchild = root.left; \n\nroot = \nnull\n; \n\nreturn\nlchild; \n\n} \n\n\n// 2. Root in range \n\nreturn\nroot; \n\n} \n\n\npublic\nstatic\nNode newNode(\nint\nnum) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.key = num; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n\n} \n\n\npublic\nstatic\nNode insert(Node root, \n\nint\nkey) \n\n{ \n\nif\n(root == \nnull\n) \n\n{ \n\nreturn\nnewNode(key); \n\n} \n\nif\n(root.key > key) \n\n{ \n\nroot.left = insert(root.left, key); \n\n} \n\nelse\n\n{ \n\nroot.right = insert(root.right, key); \n\n} \n\nreturn\nroot; \n\n} \n\n\nprivate\nstatic\nvoid\ninorderTraversal(Node root) \n\n{ \n\nif\n(root != \nnull\n) \n\n{ \n\ninorderTraversal(root.left); \n\nSystem.out.print(root.key + \n\" \"\n); \n\ninorderTraversal(root.right); \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nNode root = \nnull\n; \n\nroot = insert(root, \n6\n); \n\nroot = insert(root, -\n13\n); \n\nroot = insert(root, \n14\n); \n\nroot = insert(root, -\n8\n); \n\nroot = insert(root, \n15\n); \n\nroot = insert(root, \n13\n); \n\nroot = insert(root, \n7\n); \n\n\nSystem.out.print(\n\"Inorder Traversal of \"\n+ \n\n\"the given tree is: \"\n); \n\ninorderTraversal(root); \n\n\nroot = removeOutsideRange(root, -\n10\n, \n13\n); \n\n\nSystem.out.print(\n\"\\nInorder traversal of \"\n+ \n\n\"the modified tree: \"\n); \n\ninorderTraversal(root); \n\n} \n} \n\n// This code is contributed \n// by Divya ", "complexity": "linear", "from": "CorCod", "problem": 145, "index": 145}
{"src": "\n// Java program to find missing Number \n\nclass\nMain { \n\n// Function to ind missing number \n\nstatic\nint\ngetMissingNo(\nint\na[], \nint\nn) \n\n{ \n\nint\ni, total; \n\ntotal = (n + \n1\n) * (n + \n2\n) / \n2\n; \n\nfor\n(i = \n0\n; i < n; i++) \n\ntotal -= a[i]; \n\nreturn\ntotal; \n\n} \n\n\n/* program to test above function */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\na[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\nmiss = getMissingNo(a, \n5\n); \n\nSystem.out.println(miss); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 146, "index": 146}
{"src": "\n// Java program to count subsequences of the \n// form a^i b^j c^k \npublic\nclass\nNo_of_subsequence { \n\n\n// Returns count of subsequences of the form \n\n// a^i b^j c^k \n\nstatic\nint\ncountSubsequences(String s) \n\n{ \n\n// Initialize counts of different subsequences \n\n// caused by different combination of 'a' \n\nint\naCount = \n0\n; \n\n\n// Initialize counts of different subsequences \n\n// caused by different combination of 'a' and \n\n// different combination of 'b' \n\nint\nbCount = \n0\n; \n\n\n// Initialize counts of different subsequences \n\n// caused by different combination of 'a', 'b' \n\n// and 'c'. \n\nint\ncCount = \n0\n; \n\n\n// Traverse all characters of given string \n\nfor\n(\nint\ni=\n0\n; i< s.length(); i++) \n\n{ \n\n/* If current character is 'a', then \n\nthere are following possibilities : \n\na) Current character begins a new \n\nsubsequence. \n\nb) Current character is part of aCount \n\nsubsequences. \n\nc) Current character is not part of \n\naCount subsequences. */\n\nif\n(s.charAt(i) == \n'a'\n) \n\naCount = (\n1\n+ \n2\n* aCount); \n\n\n/* If current character is 'b', then \n\nthere are following possibilities : \n\na) Current character begins a new \n\nsubsequence of b's with aCount \n\nsubsequences. \n\nb) Current character is part of bCount \n\nsubsequences. \n\nc) Current character is not part of \n\nbCount subsequences. */\n\nelse\nif\n(s.charAt(i) == \n'b'\n) \n\nbCount = (aCount + \n2\n* bCount); \n\n\n/* If current character is 'c', then \n\nthere are following possibilities : \n\na) Current character begins a new \n\nsubsequence of c's with bCount \n\nsubsequences. \n\nb) Current character is part of cCount \n\nsubsequences. \n\nc) Current character is not part of \n\ncCount subsequences. */\n\nelse\nif\n(s.charAt(i) == \n'c'\n) \n\ncCount = (bCount + \n2\n* cCount); \n\n} \n\n\nreturn\ncCount; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abbc\"\n; \n\nSystem.out.println(countSubsequences(s)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "linear", "from": "CorCod", "problem": 147, "index": 147}
{"src": "\n// A Java program for in-place conversion of Binary Tree to DLL \n\n// A binary tree node has data, left pointers and right pointers \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n// head --> Pointer to head node of created doubly linked list \n\nNode head; \n\n\n// Initialize previously visited node as NULL. This is \n\n// static so that the same value is accessible in all recursive \n\n// calls \n\nstatic\nNode prev = \nnull\n; \n\n\n// A simple recursive function to convert a given Binary tree \n\n// to Doubly Linked List \n\n// root --> Root of Binary Tree \n\nvoid\nBinaryTree2DoubleLinkedList(Node root) \n\n{ \n\n// Base case \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n// Recursively convert left subtree \n\nBinaryTree2DoubleLinkedList(root.left); \n\n\n// Now convert this node \n\nif\n(prev == \nnull\n) \n\nhead = root; \n\nelse\n\n{ \n\nroot.left = prev; \n\nprev.right = root; \n\n} \n\nprev = root; \n\n\n// Finally convert right subtree \n\nBinaryTree2DoubleLinkedList(root.right); \n\n} \n\n\n/* Function to print nodes in a given doubly linked list */\n\nvoid\nprintList(Node node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.right; \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Let us create the tree as shown in above diagram \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n12\n); \n\ntree.root.right = \nnew\nNode(\n15\n); \n\ntree.root.left.left = \nnew\nNode(\n25\n); \n\ntree.root.left.right = \nnew\nNode(\n30\n); \n\ntree.root.right.left = \nnew\nNode(\n36\n); \n\n\n// convert to DLL \n\ntree.BinaryTree2DoubleLinkedList(tree.root); \n\n\n// Print the converted List \n\ntree.printList(tree.head); \n\n\n} \n} \n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "linear", "from": "CorCod", "problem": 148, "index": 148}
{"src": "\n// A java program for iterative postorder traversal using stack \n\nimport\njava.util.ArrayList; \nimport\njava.util.Stack; \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nArrayList<Integer> list = \nnew\nArrayList<Integer>(); \n\n\n// An iterative function to do postorder traversal \n\n// of a given binary tree \n\nArrayList<Integer> postOrderIterative(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack<Node>(); \n\n\n// Check for empty tree \n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\nS.push(node); \n\nNode prev = \nnull\n; \n\nwhile\n(!S.isEmpty()) \n\n{ \n\nNode current = S.peek(); \n\n\n/* go down the tree in search of a leaf an if so process it \n\nand pop stack otherwise move down */\n\nif\n(prev == \nnull\n|| prev.left == current || \n\nprev.right == current) \n\n{ \n\nif\n(current.left != \nnull\n) \n\nS.push(current.left); \n\nelse\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n/* go up the tree from left node, if the child is right \n\npush it onto stack otherwise process parent and pop \n\nstack */\n\n} \n\nelse\nif\n(current.left == prev) \n\n{ \n\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n/* go up the tree from right node and after coming back \n\nfrom right node process parent and pop stack */\n\n} \n\nelse\nif\n(current.right == prev) \n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\nprev = current; \n\n} \n\n\nreturn\nlist; \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n// Let us create trees shown in above diagram \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nArrayList<Integer> mylist = tree.postOrderIterative(tree.root); \n\n\nSystem.out.println(\n\"Post order traversal of binary tree is :\"\n); \n\nSystem.out.println(mylist); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 149, "index": 149}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author caoash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EMilitaryProblem solver = new EMilitaryProblem();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMilitaryProblem {\n        ArrayList<Integer>[] adj;\n        int[] sz;\n        int[] preorder;\n        int curPos;\n        int[] pos;\n\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            int q = br.nextInt();\n            preorder = new int[n];\n            sz = new int[n];\n            pos = new int[n];\n            curPos = 0;\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) adj[i] = new ArrayList<Integer>();\n            for (int i = 1; i < n; i++) {\n                int u = br.nextInt();\n                u--;\n                adj[u].add(i);\n            }\n            dfs(0);\n            for (int i = 0; i < n; i++) {\n                pos[preorder[i]] = i;\n            }\n            for (int i = 0; i < q; i++) {\n                int u = br.nextInt();\n                int k = br.nextInt();\n                u--;\n                if (sz[u] < k) {\n                    pw.println(\"-1\");\n                } else {\n                    pw.println(preorder[pos[u] + k - 1] + 1);\n                }\n            }\n            pw.close();\n        }\n\n        public int dfs(int u) {\n            preorder[curPos] = u;\n            curPos++;\n            sz[u]++;\n            for (int e : adj[u]) {\n                sz[u] += dfs(e);\n            }\n            return sz[u];\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 150, "index": 150}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,ans=0;\n\t\tString sa,sb;\n\t\tchar[] a,b;\n\t\tn=sc.nextInt();\n\t\tsa=sc.next();\n\t\tsb=sc.next();\n\t\ta=sa.toCharArray();\n\t\tb=sb.toCharArray();\n\t\tans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i==n/2)\n\t\t\t{\n\t\t\t\tif(a[i]!=b[i])\n\t\t\t\t\tans++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] vis=new int[28];\n\t\t\tvis[a[i]-'a']++;\n\t\t\tvis[b[i]-'a']++;\n\t\t\tvis[a[n-1-i]-'a']++;\n\t\t\tvis[b[n-1-i]-'a']++;\n\t\t\tint num=0,ans1=0,ans2=0;\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tif(vis[j]!=0)\n\t\t\t\t{\n\t\t\t\t\tnum++;\n\t\t\t\t\tif(num==1)\n\t\t\t\t\t\tans1=vis[j];\n\t\t\t\t\telse\n\t\t\t\t\t\tans2=vis[j];\n\t\t\t\t}\n\t\t\tif(num==2)\n\t\t\t{\n\t\t\t\tif(ans1==1||ans2==1)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==3)\n\t\t\t{\n\t\t\t\tif(a[i]==a[n-i-1])\n\t\t\t\t\tans+=2;\n\t\t\t\telse\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==4)\n\t\t\t\tans+=2;\n\t\t\ta[i]=b[i];\n\t\t\ta[n-1-i]=b[n-1-i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 151, "index": 151}
{"src": "import java.util.*;\n\nimport java.io.*;\npublic class Solution\n{\n    public static void main(String [] args) throws IOException\n    {\n        PrintWriter pw=new PrintWriter(System.out);//use pw.println() not pw.write();\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(br.readLine());\n        /*\n        inputCopy\n5 3\nxyabd\noutputCopy\n29\ninputCopy\n7 4\nproblem\noutputCopy\n34\ninputCopy\n2 2\nab\noutputCopy\n-1\ninputCopy\n12 1\nabaabbaaabbb\noutputCopy\n1\n        */\n        int n=Integer.parseInt(st.nextToken());\n        int k=Integer.parseInt(st.nextToken());\n        st=new StringTokenizer(br.readLine());\n        String str=st.nextToken();\n        char [] arr=str.toCharArray();\n        Arrays.sort(arr);\n        int weight=arr[0]-96;\n        char a=arr[0];\n        int included=1;\n        for(int i=1;i<arr.length;++i)\n        {\n            if(included==k)\n                break;\n            char c=arr[i];\n            if(c-a<2)\n                continue;\n           \n            weight+=arr[i]-96;\n            ++included;\n            a=arr[i];\n            \n        }\n        if(included==k)\n            pw.println(weight);\n        else\n            pw.println(-1);\n        pw.close();//Do not forget to write it after every program return statement !!\n    }\n}\n/*\n\u2192Judgement Protocol\nTest: #1, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n5 3\nxyabd\nOutput\n29\nAnswer\n29\nChecker Log\nok 1 number(s): \"29\"\nTest: #2, time: 78 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n7 4\nproblem\nOutput\n34\nAnswer\n34\nChecker Log\nok 1 number(s): \"34\"\nTest: #3, time: 139 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nab\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #4, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n12 1\nabaabbaaabbb\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #5, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 13\nqwertyuiopasdfghjklzxcvbnmaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n169\nAnswer\n169\nChecker Log\nok 1 number(s): \"169\"\nTest: #6, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 14\nqwertyuiopasdfghjklzxcvbnmaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #7, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\na\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #8, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 1\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #9, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 2\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #10, time: 92 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n13 13\nuwgmkyqeiaocs\nOutput\n169\nAnswer\n169\nChecker Log\nok 1 number(s): \"169\"\nTest: #11, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n13 13\nhzdxpbfvrltnj\nOutput\n182\nAnswer\n182\nChecker Log\nok 1 number(s): \"182\"\nTest: #12, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\nn\nOutput\n14\nAnswer\n14\nChecker Log\nok 1 number(s): \"14\"\nTest: #13, time: 92 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n10 8\nsmzeblyjqw\nOutput\n113\nAnswer\n113\nChecker Log\nok 1 number(s): \"113\"\nTest: #14, time: 78 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n20 20\ntzmvhskkyugkuuxpvtbh\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #15, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n30 15\nwjzolzzkfulwgioksfxmcxmnnjtoav\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #16, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n40 30\nxumfrflllrrgswehqtsskefixhcxjrxbjmrpsshv\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #17, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 31\nahbyyoxltryqdmvenemaqnbakglgqolxnaifnqtoclnnqiabpz\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #18, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n10 7\niuiukrxcml\nOutput\n99\nAnswer\n99\nChecker Log\nok 1 number(s): \"99\"\nTest: #19, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n38 2\nvjzarfykmrsrvwbwfwldsulhxtykmjbnwmdufa\nOutput\n5\nAnswer\n5\nChecker Log\nok 1 number(s): \"5\"\nTest: #20, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n12 6\nfwseyrarkwcd\nOutput\n61\nAnswer\n61\nChecker Log\nok 1 number(s): \"61\"\nTest: #21, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nac\nOutput\n4\nAnswer\n4\nChecker Log\nok 1 number(s): \"4\"\nTest: #22, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\nc\nOutput\n3\nAnswer\n3\nChecker Log\nok 1 number(s): \"3\"\nTest: #23, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nad\nOutput\n5\nAnswer\n5\nChecker Log\nok 1 number(s): \"5\"\nTest: #24, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n2 1\nac\nOutput\n-1\nAnswer\n1\nChecker Log\nwrong answer 1st number\n*/", "complexity": "linear", "from": "CorCod", "problem": 152, "index": 152}
{"src": "\n// Java program to convert BTT to DLL using \n// simple inorder traversal \n\npublic\nclass\nBinaryTreeToDLL \n{ \n\nstatic\nclass\nnode \n\n{ \n\nint\ndata; \n\nnode left, right; \n\n\npublic\nnode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\nstatic\nnode prev; \n\n\n// Changes left pointers to work as previous \n\n// pointers in converted DLL The function \n\n// simply does inorder traversal of Binary \n\n// Tree and updates left pointer using \n\n// previously visited node \n\nstatic\nvoid\nfixPrevptr(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nfixPrevptr(root.left); \n\nroot.left = prev; \n\nprev = root; \n\nfixPrevptr(root.right); \n\n\n} \n\n\n// Changes right pointers to work \n\n// as next pointers in converted DLL \n\nstatic\nnode fixNextptr(node root) \n\n{ \n\n// Find the right most node in \n\n// BT or last node in DLL \n\nwhile\n(root.right != \nnull\n) \n\nroot = root.right; \n\n\n// Start from the rightmost node, traverse \n\n// back using left pointers. While traversing, \n\n// change right pointer of nodes \n\nwhile\n(root != \nnull\n&& root.left != \nnull\n) \n\n{ \n\nnode left = root.left; \n\nleft.right = root; \n\nroot = root.left; \n\n} \n\n\n// The leftmost node is head of linked list, return it \n\nreturn\nroot; \n\n} \n\n\nstatic\nnode BTTtoDLL(node root) \n\n{ \n\nprev = \nnull\n; \n\n\n// Set the previous pointer \n\nfixPrevptr(root); \n\n\n// Set the next pointer and return head of DLL \n\nreturn\nfixNextptr(root); \n\n} \n\n\n// Traverses the DLL from left tor right \n\nstatic\nvoid\nprintlist(node root) \n\n{ \n\nwhile\n(root != \nnull\n) \n\n{ \n\nSystem.out.print(root.data + \n\" \"\n); \n\nroot = root.right; \n\n} \n\n} \n\n\n// Standard Inorder traversal of tree \n\nstatic\nvoid\ninorder(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\ninorder(root.left); \n\nSystem.out.print(root.data + \n\" \"\n); \n\ninorder(root.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Let us create the tree shown in above diagram \n\nnode root = \nnew\nnode(\n10\n); \n\nroot.left = \nnew\nnode(\n12\n); \n\nroot.right = \nnew\nnode(\n15\n); \n\nroot.left.left = \nnew\nnode(\n25\n); \n\nroot.left.right = \nnew\nnode(\n30\n); \n\nroot.right.left = \nnew\nnode(\n36\n); \n\n\nSystem.out.println(\n\"Inorder Tree Traversal\"\n); \n\ninorder(root); \n\n\nnode head = BTTtoDLL(root); \n\n\nSystem.out.println(\n\"\\nDLL Traversal\"\n); \n\nprintlist(head); \n\n} \n} \n\n// This code is contributed by Rishabh Mahrsee ", "complexity": "linear", "from": "CorCod", "problem": 153, "index": 153}
{"src": "\n/* Java program to find first repeating element in arr[] */\nimport\njava.util.*; \n\nclass\nMain \n{ \n\n// This function prints the first repeating element in arr[] \n\nstatic\nvoid\nprintFirstRepeating(\nint\narr[]) \n\n{ \n\n// Initialize index of first repeating element \n\nint\nmin = -\n1\n; \n\n\n// Creates an empty hashset \n\nHashSet<Integer> set = \nnew\nHashSet<>(); \n\n\n// Traverse the input array from right to left \n\nfor\n(\nint\ni=arr.length-\n1\n; i>=\n0\n; i--) \n\n{ \n\n// If element is already in hash set, update min \n\nif\n(set.contains(arr[i])) \n\nmin = i; \n\n\nelse\n// Else add element to hash set \n\nset.add(arr[i]); \n\n} \n\n\n// Print the result \n\nif\n(min != -\n1\n) \n\nSystem.out.println(\n\"The first repeating element is \"\n+ arr[min]); \n\nelse\n\nSystem.out.println(\n\"There are no repeating elements\"\n); \n\n} \n\n\n// Driver method to test above method \n\npublic\nstatic\nvoid\nmain (String[] args) \nthrows\njava.lang.Exception \n\n{ \n\nint\narr[] = {\n10\n, \n5\n, \n3\n, \n4\n, \n3\n, \n5\n, \n6\n}; \n\nprintFirstRepeating(arr); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 154, "index": 154}
{"src": "\n// Java program to find all elements \n// in array which have atleast \n// two greater elements itself. \nimport\njava.util.*; \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nint\nfirst = Integer.MIN_VALUE; \n\nint\nsecond = Integer.MAX_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n// If current element is smaller \n\n// than first then update both \n\n// first and second \n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n/* If arr[i] is in between \n\nfirst and second \n\nthen update second */\n\nelse\nif\n(arr[i] > second) \n\nsecond = arr[i]; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < second) \n\nSystem.out.print(arr[i] + \n\" \"\n) ; \n} \n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n} \n} \n\n// This code is contributed by Sahil_Bansall ", "complexity": "linear", "from": "CorCod", "problem": 155, "index": 155}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class EhabAndAComponentChoosingProblem {\n    \n    long INF = (long) 1e18;\n    \n    int n;\n    int[] a;\n    \n    int[][] G;\n    \n    void solve() {\n        n = in.nextInt();\n        a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = in.nextInt();\n        int[] fr = new int[n - 1], to = new int[n - 1];\n        for (int i = 0; i < n - 1; i++) {\n            fr[i] = in.nextInt() - 1;\n            to[i] = in.nextInt() - 1;\n        }\n        G = build_graph(n, fr, to);\n        \n        int[][] ret = bfs(G, 0);\n        int[] par = ret[0], ord = ret[2];\n        \n        long best = -INF;\n        long[] dp = new long[n];\n        for (int i = n - 1; i >= 0; i--) {\n            int u = ord[i];\n            dp[u] = a[u];\n            for (int v : G[u]) {\n                if (v != par[u]) {\n                    if (dp[v] > 0) dp[u] += dp[v];\n                }\n            }\n            best = Math.max(best, dp[u]);\n        }\n        \n        int k = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            int u = ord[i];\n            dp[u] = a[u];\n            for (int v : G[u]) {\n                if (v != par[u]) {\n                    if (dp[v] > 0) dp[u] += dp[v];\n                }\n            }\n            if (dp[u] == best) {\n                dp[u] = -INF;\n                k++;\n            }\n        }\n        \n        out.printf(\"%d %d%n\", best * k, k);\n    }\n    \n    int[][] bfs(int[][] G, int root) {\n        int n = G.length;\n        \n        int[] par = new int[n];\n        Arrays.fill(par, -1);\n        \n        int[] dep = new int[n];\n        dep[root] = 0;\n        \n        int[] qu = new int[n];\n        qu[0] = root;\n        for (int l = 0, r = 1; l < r; l++) {\n            int u = qu[l];\n            for (int v : G[u]) {\n                if (v != par[u]) {\n                    qu[r++] = v;\n                    par[v] = u;\n                    dep[v] = dep[u] + 1;\n                }\n            }\n        }\n        \n        return new int[][]{par, dep, qu};\n    }\n    \n    int[][] build_graph(int n, int[] from, int[] to) {\n        int[][] G = new int[n][];\n        int[] cnt = new int[n];\n        for (int i = 0; i < from.length; i++) {\n            cnt[from[i]]++;\n            cnt[to[i]]++;\n        }\n        for (int i = 0; i < n; i++) G[i] = new int[cnt[i]];\n        for (int i = 0; i < from.length; i++) {\n            G[from[i]][--cnt[from[i]]] = to[i];\n            G[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return G;\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new EhabAndAComponentChoosingProblem().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 156, "index": 156}
{"src": "\n// Java program to Find longest subsequence where \n// every character appears at-least k times \n\nclass\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHARS = \n26\n; \n\n\nstatic\nvoid\nlongestSubseqWithK(String str, \nint\nk) { \n\nint\nn = str.length(); \n\n\n// Count frequencies of all characters \n\nint\nfreq[] = \nnew\nint\n[MAX_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nfreq[str.charAt(i) - \n'a'\n]++; \n\n} \n\n\n// Traverse given string again and print \n\n// all those characters whose frequency \n\n// is more than or equal to k. \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(freq[str.charAt(i) - \n'a'\n] >= k) { \n\nSystem.out.print(str.charAt(i)); \n\n} \n\n} \n\n} \n\n// Driver code \n\nstatic\npublic\nvoid\nmain(String[] args) { \n\nString str = \n\"geeksforgeeks\"\n; \n\nint\nk = \n2\n; \n\nlongestSubseqWithK(str, k); \n\n\n} \n} \n\n// This code is contributed by Rajput-Ji ", "complexity": "linear", "from": "CorCod", "problem": 157, "index": 157}
{"src": "\n// Java code to find a pair with given sum \n// in a Balanced BST \nimport\njava.util.ArrayList; \n\n// A binary tree node \nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n// Root of BST \n\nNode root; \n\n\n// Constructor \n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n// Inorder traversal of the tree \n\nvoid\ninorder() \n\n{ \n\ninorderUtil(\nthis\n.root); \n\n} \n\n\n// Utility function for inorder traversal of the tree \n\nvoid\ninorderUtil(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\ninorderUtil(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderUtil(node.right); \n\n} \n\n\n// This method mainly calls insertRec() \n\nvoid\ninsert(\nint\nkey) \n\n{ \n\nroot = insertRec(root, key); \n\n} \n\n\n/* A recursive function to insert a new key in BST */\n\nNode insertRec(Node root, \nint\ndata) \n\n{ \n\n\n/* If the tree is empty, return a new node */\n\nif\n(root == \nnull\n) { \n\nroot = \nnew\nNode(data); \n\nreturn\nroot; \n\n} \n\n\n/* Otherwise, recur down the tree */\n\nif\n(data < root.data) \n\nroot.left = insertRec(root.left, data); \n\nelse\nif\n(data > root.data) \n\nroot.right = insertRec(root.right, data); \n\n\nreturn\nroot; \n\n} \n\n\n// Method that adds values of given BST into ArrayList \n\n// and hence returns the ArrayList \n\nArrayList<Integer> treeToList(Node node, ArrayList<Integer> \n\nlist) \n\n{ \n\n// Base Case \n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\n\ntreeToList(node.left, list); \n\nlist.add(node.data); \n\ntreeToList(node.right, list); \n\n\nreturn\nlist; \n\n} \n\n\n// method that checks if there is a pair present \n\nboolean\nisPairPresent(Node node, \nint\ntarget) \n\n{ \n\n// This list a1 is passed as an argument \n\n// in treeToList method \n\n// which is later on filled by the values of BST \n\nArrayList<Integer> a1 = \nnew\nArrayList<>(); \n\n\n// a2 list contains all the values of BST \n\n// returned by treeToList method \n\nArrayList<Integer> a2 = treeToList(node, a1); \n\n\nint\nstart = \n0\n; \n// Starting index of a2 \n\n\nint\nend = a2.size() - \n1\n; \n// Ending index of a2 \n\n\nwhile\n(start < end) { \n\n\nif\n(a2.get(start) + a2.get(end) == target) \n// Target Found! \n\n{ \n\nSystem.out.println(\n\"Pair Found: \"\n+ a2.get(start) + \n\" + \"\n+ a2.get(end) + \n\" \"\n\n+ \n\"= \"\n+ target); \n\nreturn\ntrue\n; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) > target) \n// decrements end \n\n{ \n\nend--; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) < target) \n// increments start \n\n{ \n\nstart++; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No such values are found!\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n/* \n\n15 \n\n/ \\ \n\n10 20 \n\n/ \\ / \\ \n\n8 12 16 25 */\n\ntree.insert(\n15\n); \n\ntree.insert(\n10\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n8\n); \n\ntree.insert(\n12\n); \n\ntree.insert(\n16\n); \n\ntree.insert(\n25\n); \n\n\ntree.isPairPresent(tree.root, \n33\n); \n\n} \n} \n\n// This code is contributed by Kamal Rawal ", "complexity": "linear", "from": "CorCod", "problem": 158, "index": 158}
{"src": "import java.util.*;\n\t\tpublic class mohamedy23\n\t\t{\n\t      public static void main (String args[])\n\t\t    {\n\t\t    \tScanner sc=new Scanner(System.in);\n\t\t    \tint n=sc.nextInt();String s=sc.next();int i=s.length()-1;\n\t\t    \t\n\t\t    \tif(n==1) {\n\t\t    \t\tif(s.charAt(0)=='1') {\n\t\t    \t\t\tSystem.out.print(\"YES\");return;\n\t\t    \t\t}else {\n\t\t    \t\t\tSystem.out.print(\"NO\");return;\n\t\t    \t\t}\n\t\t    \t}else if(n==2) {\n\t\t    \t\tif(s.contains(\"00\")||s.contains(\"11\")) {\n\t\t    \t\t\tSystem.out.print(\"NO\");return;\n\t\t    \t\t}else {\n\t\t    \t\t\tSystem.out.print(\"Yes\");return;\n\t\t    \t\t}\n\t\t    \t}\n\t\t    \telse if(s.contains(\"000\")||s.contains(\"11\")) {\n\t\t    \t\tSystem.out.print(\"NO\");return;\n\t\t    \t}\n\t\t    \telse\tif(s.charAt(0)=='0'&&s.charAt(1)=='0'&&s.charAt(2)=='1') {\n\t\t    \t\tSystem.out.print(\"NO\");return;\n\t\t    \t}\n\t\t    \telse\tif(s.charAt(i)=='0'&&s.charAt(i-1)=='0') {\n\t\t    \t\tSystem.out.print(\"NO\");\n\t\t    \t\treturn;\n\t\t    \t\t}\n\t\t    \t System.out.print(\"YES\");\n\t\t    }\n\t\t}\n\t\t ", "complexity": "linear", "from": "CorCod", "problem": 159, "index": 159}
{"src": "\n// An otpimized Java program to find pairs with distance \n// equal to English alphabet distance \n\nclass\nTest { \n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n// Method to count pairs with distance \n\n// equal to English alphabet distance \n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n// This loop runs at most 26 times \n\nfor\n(\nint\nj = \n1\n; (i + j) < n && j <= MAX_CHAR; j++) \n\nif\n((Math.abs(str.charAt(i + j) - str.charAt(i)) == j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 160, "index": 160}
{"src": "\n// A O(n) solution that uses \n// table fact[] to calculate \n// the Permutation Coefficient \nimport\njava .io.*; \n\npublic\nclass\nGFG { \n\n\n// Returns value of Permutation \n\n// Coefficient P(n, k) \n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\n[]fact = \nnew\nint\n[n+\n1\n]; \n\n\n// base case \n\nfact[\n0\n] = \n1\n; \n\n\n// Caculate value \n\n// factorials up to n \n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfact[i] = i * fact[i - \n1\n]; \n\n\n// P(n,k) = n! / (n - k)! \n\nreturn\nfact[n] / fact[n - k]; \n\n} \n\n\n// Driver Code \n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of\"\n\n+ \n\" P( \"\n+ n + \n\", \"\n+ k + \n\") is \"\n\n+ permutationCoeff(n, k) ); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "complexity": "linear", "from": "CorCod", "problem": 161, "index": 161}
{"src": "import java.io.*;\nimport java.util.Arrays;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        IO io = new IO();\n        String s=io.nextLine();\n        if (s.length()<3)io.println(\"No\");\n        else {\n            int[]b=new int[200];\n            for (int i=2;i<s.length();i++){\n                b['.']=b['A']=b['B']=b['C']=0;\n                b[s.charAt(i-2)]=1;\n                b[s.charAt(i-1)]=1;\n                b[s.charAt(i)]=1;\n                if (b['A']+b['B']+b['C']==3){io.println(\"Yes\");return;}\n            }\n            io.println(\"No\");\n        }\n    }\n\n\n    static class IO {\n\n        BufferedInputStream din;\n        final int BUFFER_SIZE = 1 << 16;\n        byte[] buffer;\n        int byteRead, bufferPoint;\n\n        StringBuilder builder;\n        PrintWriter pw;\n\n        public IO() {\n            din = new BufferedInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPoint = byteRead = 0;\n\n            builder = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    System.out\n            )), true);\n        }\n\n        int read() {\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (byteRead == -1) buffer[0] = -1;\n            }\n            return buffer[bufferPoint++];\n        }\n\n        int peek() {\n            if (byteRead == -1) return -1;\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (byteRead <= 0) return -1;\n            }\n            return buffer[bufferPoint];\n        }\n\n        boolean hasNext() {\n            int c = peek();\n            while (c != -1 && c <= ' ') {\n                read();\n                c = peek();\n            }\n            return c != -1;\n        }\n\n        char nextChar() {\n            int c = read();\n            while (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        double nextDouble() {\n            double ret = 0, div = 1;\n            int c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        String nextLine() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n\n        String next() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (Character.isWhitespace(c)) {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        int nextInt() {\n            int ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        long nextLong() {\n            long ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        void println(Object o) {\n            pw.println(o);\n        }\n\n        void print(Object o) {\n            pw.print(o);\n        }\n\n        void printf(String format, Object... objects) {\n            pw.printf(format, objects);\n        }\n\n        void close() {\n            pw.close();\n        }\n\n        void done(Object o) {\n            print(o);\n            close();\n        }\n\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 162, "index": 162}
{"src": "\n// Java Program for finding K-th largest Node using O(1) \n// extra memory and reverse Morris traversal. \nclass\nGfG \n{ \n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n// helper function to create a new Node \nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.right = \nnull\n; \n\ntemp.left = \nnull\n; \n\nreturn\ntemp; \n} \n\nstatic\nNode KthLargestUsingMorrisTraversal(Node root, \nint\nk) \n{ \n\nNode curr = root; \n\nNode Klargest = \nnull\n; \n\n\n// count variable to keep count of visited Nodes \n\nint\ncount = \n0\n; \n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n// if right child is NULL \n\nif\n(curr.right == \nnull\n) \n\n{ \n\n\n// first increment count and check if count = k \n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n// otherwise move to the left child \n\ncurr = curr.left; \n\n} \n\n\nelse\n\n{ \n\n\n// find inorder successor of current Node \n\nNode succ = curr.right; \n\n\nwhile\n(succ.left != \nnull\n&& succ.left != curr) \n\nsucc = succ.left; \n\n\nif\n(succ.left == \nnull\n) \n\n{ \n\n\n// set left child of successor to the \n\n// current Node \n\nsucc.left = curr; \n\n\n// move current to its right \n\ncurr = curr.right; \n\n} \n\n\n// restoring the tree back to original binary \n\n// search tree removing threaded links \n\nelse\n\n{ \n\n\nsucc.left = \nnull\n; \n\n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n// move current to its left child \n\ncurr = curr.left; \n\n} \n\n} \n\n} \n\nreturn\nKlargest; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n// Your Java Code \n\n/* Constructed binary tree is \n\n4 \n\n/ \\ \n\n2 7 \n\n/ \\ / \\ \n\n1 3 6 10 */\n\n\nNode root = newNode(\n4\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n7\n); \n\nroot.left.left = newNode(\n1\n); \n\nroot.left.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n6\n); \n\nroot.right.right = newNode(\n10\n); \n\n\nSystem.out.println(\n\"Finding K-th largest Node in BST : \"\n+ \n\nKthLargestUsingMorrisTraversal(root, \n2\n).data); \n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 163, "index": 163}
{"src": "\n// Java program to find minimum cost \n// to reduce array size to 1, \nimport\njava.lang.*; \n\npublic\nclass\nGFG { \n\n\n// function to calculate the \n\n// minimum cost \n\nstatic\nint\ncost(\nint\n[]a, \nint\nn) \n\n{ \n\nint\nmin = a[\n0\n]; \n\n\n// find the minimum using \n\n// for loop \n\nfor\n(\nint\ni = \n1\n; i< a.length; i++) \n\n{ \n\nif\n(a[i] < min) \n\nmin = a[i]; \n\n} \n\n\n// Minimum cost is n-1 multiplied \n\n// with minimum element. \n\nreturn\n(n - \n1\n) * min; \n\n} \n\n\n// driver program to test the \n\n// above function. \n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\n[]a = { \n4\n, \n3\n, \n2\n}; \n\nint\nn = a.length; \n\n\nSystem.out.println(cost(a, n)); \n\n} \n} \n\n// This code is contributed by parashar. ", "complexity": "linear", "from": "CorCod", "problem": 164, "index": 164}
{"src": "\n// Java program to covert a ternary \n// expreesion to a tree. \nimport\njava.util.Queue; \nimport\njava.util.LinkedList; \n\n// Class to represent Tree node \nclass\nNode \n{ \n\nchar\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n} \n\n// Class to covert a ternary expression to a Tree \nclass\nBinaryTree \n{ \n\n// Function to convert Ternary Expression to a Binary \n\n// Tree. It return the root of tree \n\nNode convertExpression(\nchar\n[] expression, \nint\ni) \n\n{ \n\n// Base case \n\nif\n(i >= expression.length) \n\nreturn\nnull\n; \n\n\n// store current character of expression_string \n\n// [ 'a' to 'z'] \n\nNode root = \nnew\nNode(expression[i]); \n\n\n// Move ahead in str \n\n++i; \n\n\n// if current character of ternary expression is '?' \n\n// then we add next character as a left child of \n\n// current node \n\nif\n(i < expression.length && expression[i]==\n'?'\n) \n\nroot.left = convertExpression(expression, i+\n1\n); \n\n\n// else we have to add it as a right child of \n\n// current node expression.at(0) == ':' \n\nelse\nif\n(i < expression.length) \n\nroot.right = convertExpression(expression, i+\n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n// function print tree \n\npublic\nvoid\nprintTree( Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nSystem.out.print(root.data +\n\" \"\n); \n\nprintTree(root.left); \n\nprintTree(root.right); \n\n} \n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString exp = \n\"a?b?c:d:e\"\n; \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nchar\n[] expression=exp.toCharArray(); \n\nNode root = tree.convertExpression(expression, \n0\n); \n\ntree.printTree(root) ; \n\n} \n} \n\n/* This code is contributed by Mr. Somesh Awasthi */", "complexity": "linear", "from": "CorCod", "problem": 165, "index": 165}
{"src": "\nimport java.io.*;\nimport java.util.*;\npublic class D999 {\n    public static void main(String args[])throws IOException\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        int req=n/m;\n        int arr[]=new int[n+1];\n        int size[]=new int[m];\n        List<Integer> list[]=new ArrayList[m];\n        for(int i=0;i<m;i++)\n        {\n            list[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=n;i++)\n        {\n            arr[i]=sc.nextInt();\n            size[arr[i]%m]++;\n            list[arr[i]%m].add(i);\n        }\n        long tot=0;int x=0,y=0;\n        List<Integer> idx=new ArrayList<>();\n        for(int i=0;i < 2*m;i++)\n        {\n            //System.out.println(i+\" \"+size[i%m]);\n            if(size[i%m]>req)\n            {\n                for(int j=0;j<size[i%m]-req;j++)\n                {\n                    idx.add(list[i%m].get(j));\n                    y++;\n                    \n                }\n                size[i%m]=req;\n                //System.out.println(i+\" \"+x+\" \"+y);\n            }\n            else if(size[i%m]<req)\n            {\n                //System.out.println(idx+\" \"+i);\n                while(x!=y && size[i%m]<req)\n                {\n                    int num=arr[idx.get(x)];\n                    int gg=i-num%m;\n                    tot+=gg;\n                    arr[idx.get(x)]+=gg;\n                    x++;\n                    size[i%m]++;\n                }\n            }\n        }\n        System.out.println(tot);\n        for(int i=1;i<=n;i++)\n        {\n            System.out.print(arr[i]+\" \");\n        }\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 166, "index": 166}
{"src": "//package com.krakn.CF.B1159;\n\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n;\n        n = sc.nextInt();\n        int[] arr = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n        }\n\n        int min = 1000000000, temp;\n\n        for (int i = 0; i < n; i++) {\n            temp = arr[i] / Math.max(i, n - 1 - i);\n            if (temp < min)\n                min = temp;\n//            System.out.println(i + \" \" + temp);\n        }\n\n        System.out.println(min);\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 167, "index": 167}
{"src": "\n// Java program to find maximum product of \n// a subset. \nclass\nGFG { \n\n\nstatic\nint\nminProductSubset(\nint\na[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\na[\n0\n]; \n\n\n// Find count of negative numbers, \n\n// count of zeros, maximum valued \n\n// negative number, minimum valued \n\n// positive number and product of \n\n// non-zero numbers \n\nint\nnegmax = Integer.MIN_VALUE; \n\nint\nposmin = Integer.MAX_VALUE; \n\nint\ncount_neg = \n0\n, count_zero = \n0\n; \n\nint\nproduct = \n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n// if number is zero,count it \n\n// but dont multiply \n\nif\n(a[i] == \n0\n){ \n\ncount_zero++; \n\ncontinue\n; \n\n} \n\n\n// count the negetive numbers \n\n// and find the max negetive number \n\nif\n(a[i] < \n0\n) \n\n{ \n\ncount_neg++; \n\nnegmax = Math.max(negmax, a[i]); \n\n} \n\n\n// find the minimum positive number \n\nif\n(a[i] > \n0\n&& a[i] < posmin) \n\nposmin = a[i]; \n\n\nproduct *= a[i]; \n\n} \n\n\n// if there are all zeroes \n\n// or zero is present but no \n\n// negetive number is present \n\nif\n(count_zero == n || \n\n(count_neg == \n0\n&& count_zero > \n0\n)) \n\nreturn\n0\n; \n\n\n// If there are all positive \n\nif\n(count_neg == \n0\n) \n\nreturn\nposmin; \n\n\n// If there are even number except \n\n// zero of negative numbers \n\nif\n(count_neg % \n2\n== \n0\n&& count_neg != \n0\n) \n\n{ \n\n\n// Otherwise result is product of \n\n// all non-zeros divided by maximum \n\n// valued negative. \n\nproduct = product / negmax; \n\n} \n\n\nreturn\nproduct; \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\na[] = { -\n1\n, -\n1\n, -\n2\n, \n4\n, \n3\n}; \n\nint\nn = \n5\n; \n\n\nSystem.out.println(minProductSubset(a, n)); \n\n} \n} \n\n// This code is contributed by Arnab Kundu. ", "complexity": "linear", "from": "CorCod", "problem": 168, "index": 168}
{"src": "import java.util.Scanner;\n\npublic class TreasureHunt {\n\t\n\tpublic static String Solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tString kuro = sc.nextLine(), shiro = sc.nextLine(), katie = sc.nextLine();\n\t\tsc.close();\n\t\tString[] output = {\"Kuro\", \"Shiro\", \"Katie\", \"Draw\"};\n\t\tif(n >= kuro.length())\n\t\t\treturn output[3];\n\t\tint[] maxArr = new int[3];\t\t\n\t\tint[][] freq = new int[3][58];\n\t\tfor(int i = 0; i < kuro.length(); i++) {\n\t\t\tmaxArr[0] = ++freq[0][kuro.charAt(i) - 65] > maxArr[0]? freq[0][kuro.charAt(i) - 65] : maxArr[0];\n\t\t\tmaxArr[1] = ++freq[1][shiro.charAt(i) - 65] > maxArr[1]? freq[1][shiro.charAt(i) - 65] : maxArr[1];\n\t\t\tmaxArr[2] = ++freq[2][katie.charAt(i) - 65] > maxArr[2]? freq[2][katie.charAt(i) - 65] : maxArr[2];\n\t\t}\n\t\tint winner = 0, max = 0;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tif(kuro.length() - maxArr[i] >= n)\n\t\t\t\tmaxArr[i] += n;\n\t\t\telse \n\t\t\t\tmaxArr[i] = n == 1? kuro.length() - 1: kuro.length();\n\t\t\tif(max < maxArr[i]) {\n\t\t\t\twinner = i;\n\t\t\t\tmax = maxArr[i];\n\t\t\t} else if(max == maxArr[i])\n\t\t\t\twinner = 3;\n\t\t}\n\t\t\n\t\treturn output[winner];\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(Solve());\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 169, "index": 169}
{"src": "import java.util.Scanner;\n\n//import java.util.Scanner;\n\n\n\n\npublic class SingleWildcard {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner input =new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tchar[] s1 =new char[a];\n\t\ts1 = input.next().toCharArray();\n\t\t\n\t\tchar[] s2 = new char[b];\n\t\ts2 = input.next().toCharArray();\n\t    boolean condition = false;\n\t    for(int i=0; i<a;i++){\n\t    \tif(s1[i]=='*'){\n\t    \t\tcondition= true;\n\t    \t\tbreak;\n\t    \t}\n\t    }\n\t   \n\t    if(!condition){\n\t    \tif(match(s1,s2)){\n\t    \t\tSystem.out.println(\"YES\");\n\t    \t\t\n\t    \t}\n\t    \telse\n\t    \t\tSystem.out.println(\"NO\");\n\t       return;\n\t    }\n\t    else{\n\t    \tint i=0;\n\t    \tif(s1.length-1>s2.length){\n\t    \t\tSystem.out.println(\"NO\");\n\t    \t\treturn;\n\t    \t}\n\t    \twhile(i<s1.length && i<s2.length && s1[i]==s2[i]){\n\t    \t\ti++;\n\t    \t}\n\t    \tint j=s2.length-1;\n\t    \tint k = s1.length-1;\n\t    \twhile(j>=0 && k>=0 &&  s1[k]==s2[j] && i<=j){\n\t    \t\tj--;\n\t    \t\tk--;\n\t    \t}\n\t    \t//System.out.println(i);\n\t    \tif(i==k && i>=0 && i<s1.length && s1[i]=='*' ){\n\t    \t\tSystem.out.println(\"YES\");\n\t    \t\treturn;\n\t    \t}\n\t    \tSystem.out.println(\"NO\");\n\t    }\n\t\t\n\t\t\n\t}\n\t\n\tstatic boolean match(char[] s1,char[] s2){\n\t\tif(s1.length!=s2.length)return false;\n\t\tfor(int i=0; i<s1.length;i++){\n\t\t\tif(s1[i]!=s2[i])return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 170, "index": 170}
{"src": "import java.io.BufferedReader;\n\nimport java.io.PrintWriter;\n\nimport java.io.InputStreamReader;\n\nimport java.io.IOException;\n\nimport java.util.StringTokenizer;\n\npublic class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int n = in.nextInt(), l[] = new int[n],\n            p = -1000000, d_min = 1000000, min = 1000000000;\n        for(int i = 0; i < n; i++) {\n            l[i] = in.nextInt();\n            min = Math.min(min, l[i]);\n        }\n        for(int i = 0; i < n; i++)\n            if(l[i] == min) {\n                d_min = Math.min(d_min, i - p);\n                p = i;\n            }\n        out.print(d_min);\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public String nextLine() throws IOException {\n            while(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            String r = st.nextToken(\"\\n\");\n            st = new StringTokenizer(br.readLine(), \" \");\n            return r;\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 171, "index": 171}
{"src": "//package contese_476;\nimport java.util.*;\npublic class q1 \n{\n\tint m=(int)1e9+7;\npublic class Node\n{\n\tint a;\n\tint b;\n\tpublic void Node(int a,int b)\n\t{\n\t\tthis.a=a;\n\t\tthis.b=b;\n\t}\n}\npublic int mul(int a ,int b)\n{\na=a%m;\nb=b%m;\nreturn((a*b)%m);\n}\npublic int pow(int a,int b)\n{\n\tint x=1;\n\twhile(b>0)\n\t{\n\t\tif(b%2!=0)\n\t\t\tx=mul(x,a);\n\t\ta=mul(a,a);\n\t\tb=b/2;\n\t}\n\treturn x;\n}\npublic static long gcd(long a,long b)\n{\n\tif(b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\npublic static void main(String[] args)\n{\n\tScanner sc=new Scanner(System.in);\n\tint n=sc.nextInt();\n\tHashMap<Integer,Integer> h=new HashMap();\n\t//HashMap<Integer,Integer> h1=new HashMap();\n\tint[] a=new int[n];\n\tint x=sc.nextInt();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta[i]=sc.nextInt();\n\t\tif(h.get(a[i])==null)\n\t\t{\n\t\t\th.put(a[i], 1);\n\t\t\t//h1.put(a[i],i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(0);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint num=a[i]&x;\n\t\tif(num==a[i])\n\t\t\tcontinue;\n\t\tif(h.get(num)==null)\n\t\t\tcontinue;\n\t\t\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tSystem.out.print(1);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint num=a[i]&x;\n\t\tif(num==a[i])\n\t\t\tcontinue;\n\t\tif(h.get(num)==null)\n\t\t\th.put(num, 1);\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(2);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tSystem.out.print(-1);\n\t\n     \n}\n\n}", "complexity": "linear", "from": "CorCod", "problem": 172, "index": 172}
{"src": "\n// Java program to find the maximum stolen value \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Function to calculate the maximum stolen value \n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\n\nint\nvalue1 = hval[\n0\n]; \n\nif\n(n == \n1\n) \n\nreturn\nvalue1; \n\n\nint\nvalue2 = Math.max(hval[\n0\n], hval[\n1\n]); \n\nif\n(n == \n2\n) \n\nreturn\nvalue2; \n\n\n// contains maximum stolen value at the end \n\nint\nmax_val = \n0\n; \n\n\n// Fill remaining positions \n\nfor\n(\nint\ni=\n2\n; i<n; i++) \n\n{ \n\nmax_val = Math.max(hval[i]+value1, value2); \n\nvalue1 = value2; \n\nvalue2 = max_val; \n\n} \n\n\nreturn\nmax_val; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n} \n\n// Contributed by Pramod kumar ", "complexity": "linear", "from": "CorCod", "problem": 173, "index": 173}
{"src": "\n// Java code to demonstrate Difference Array \nclass\nGFG { \n\n\n// Creates a diff array D[] for A[] and returns \n\n// it after filling initial values. \n\nstatic\nvoid\ninitializeDiffArray(\nint\nA[], \nint\nD[]) \n\n{ \n\n\nint\nn = A.length; \n\n\nD[\n0\n] = A[\n0\n]; \n\nD[n] = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nD[i] = A[i] - A[i - \n1\n]; \n\n} \n\n\n// Does range update \n\nstatic\nvoid\nupdate(\nint\nD[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nD[l] += x; \n\nD[r + \n1\n] -= x; \n\n} \n\n\n// Prints updated Array \n\nstatic\nint\nprintArray(\nint\nA[], \nint\nD[]) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < A.length; i++) { \n\n\nif\n(i == \n0\n) \n\nA[i] = D[i]; \n\n\n// Note that A[0] or D[0] decides \n\n// values of rest of the elements. \n\nelse\n\nA[i] = D[i] + A[i - \n1\n]; \n\n\nSystem.out.print(A[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n\nreturn\n0\n; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Array to be updated \n\nint\nA[] = { \n10\n, \n5\n, \n20\n, \n40\n}; \n\nint\nn = A.length; \n\n// Create and fill difference Array \n\n// We use one extra space because \n\n// update(l, r, x) updates D[r+1] \n\nint\nD[] = \nnew\nint\n[n + \n1\n]; \n\ninitializeDiffArray(A, D); \n\n\n// After below update(l, r, x), the \n\n// elements should become 20, 15, 20, 40 \n\nupdate(D, \n0\n, \n1\n, \n10\n); \n\nprintArray(A, D); \n\n\n// After below updates, the \n\n// array should become 30, 35, 70, 60 \n\nupdate(D, \n1\n, \n3\n, \n20\n); \n\nupdate(D, \n2\n, \n2\n, \n30\n); \n\n\nprintArray(A, D); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "linear", "from": "CorCod", "problem": 174, "index": 174}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class round569d2a {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint sum = 1;\n\t\tint tracker = 4;\n\t\twhile (n > 1) {\n\t\t\tsum += tracker;\n\t\t\ttracker += 4;\n\t\t\tn--;\n\t\t}\n\t\tSystem.out.println(sum);\n\n\t}\n\n\t// ======================================================================================\n\t// =============================== Reference Code =======================================\n\t// ======================================================================================\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t// Method to return all primes smaller than or equal to \n\t// n using Sieve of Eratosthenes \n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t// Create a boolean array \"prime[0..n]\" and initialize \n\t\t// all entries it as true. A value in prime[i] will \n\t\t// finally be false if i is Not a prime, else true. \n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t// If prime[p] is not changed, then it is a prime \n\t\t\tif (prime[p] == true) {\n\t\t\t\t// Update all multiples of p \n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t// Binary search for number greater than or equal to target\n\t// returns -1 if number not found\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t// Base Case \n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; // To store results of recursive call \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t// Update x and y using results of recursive \n\t\t// call \n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t// Returns modulo inverse of a  \n\t// with respect to m using extended \n\t// Euclid Algorithm. Refer below post for details: \n\t// https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/ \n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t// Apply extended Euclid Algorithm \n\t\twhile (a > 1) {\n\t\t\t// q is quotient \n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t// m is remainder now, process \n\t\t\t// same as euclid's algo \n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t// Make x1 positive \n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t// k is size of num[] and rem[]. \n\t// Returns the smallest number \n\t// x such that: \n\t// x % num[0] = rem[0], \n\t// x % num[1] = rem[1], \n\t// .................. \n\t// x % num[k-2] = rem[k-1] \n\t// Assumption: Numbers in num[] are pairwise  \n\t// coprime (gcd for every pair is 1) \n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t// Compute product of all numbers \n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t// Initialize result \n\t\tint result = 0;\n\n\t\t// Apply above formula \n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t/**\n\t * Source: Matt Fontaine\n\t */\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "complexity": "linear", "from": "CorCod", "problem": 175, "index": 175}
{"src": "import java.util.*;\n\nimport java.io.*;\npublic class Solution\n{\n    public static void main(String [] args) throws IOException\n    {\n        PrintWriter pw=new PrintWriter(System.out);//use pw.println() not pw.write();\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(br.readLine());\n        /*\n        inputCopy\n5 3\nxyabd\noutputCopy\n29\ninputCopy\n7 4\nproblem\noutputCopy\n34\ninputCopy\n2 2\nab\noutputCopy\n-1\ninputCopy\n12 1\nabaabbaaabbb\noutputCopy\n1\n        */\n        int n=Integer.parseInt(st.nextToken());\n        int k=Integer.parseInt(st.nextToken());\n        st=new StringTokenizer(br.readLine());\n        String str=st.nextToken();\n        char [] arr=str.toCharArray();\n        Arrays.sort(arr);\n        int weight=arr[0]-96;\n        char a=arr[0];\n        int included=1;\n        for(int i=1;i<arr.length;++i)\n        {\n            if(included==k)\n                break;\n            char c=arr[i];\n            if(c-a<2)\n                continue;\n           \n            weight+=arr[i]-96;\n            ++included;\n            a=arr[i];\n            \n        }\n        if(included==k)\n            pw.println(weight);\n        else\n            pw.println(-1);\n        pw.close();//Do not forget to write it after every program return statement !!\n    }\n}\n/*\n\u2192Judgement Protocol\nTest: #1, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n5 3\nxyabd\nOutput\n29\nAnswer\n29\nChecker Log\nok 1 number(s): \"29\"\nTest: #2, time: 78 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n7 4\nproblem\nOutput\n34\nAnswer\n34\nChecker Log\nok 1 number(s): \"34\"\nTest: #3, time: 139 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nab\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #4, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n12 1\nabaabbaaabbb\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #5, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 13\nqwertyuiopasdfghjklzxcvbnmaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n169\nAnswer\n169\nChecker Log\nok 1 number(s): \"169\"\nTest: #6, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 14\nqwertyuiopasdfghjklzxcvbnmaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #7, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\na\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #8, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 1\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #9, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 2\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #10, time: 92 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n13 13\nuwgmkyqeiaocs\nOutput\n169\nAnswer\n169\nChecker Log\nok 1 number(s): \"169\"\nTest: #11, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n13 13\nhzdxpbfvrltnj\nOutput\n182\nAnswer\n182\nChecker Log\nok 1 number(s): \"182\"\nTest: #12, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\nn\nOutput\n14\nAnswer\n14\nChecker Log\nok 1 number(s): \"14\"\nTest: #13, time: 92 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n10 8\nsmzeblyjqw\nOutput\n113\nAnswer\n113\nChecker Log\nok 1 number(s): \"113\"\nTest: #14, time: 78 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n20 20\ntzmvhskkyugkuuxpvtbh\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #15, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n30 15\nwjzolzzkfulwgioksfxmcxmnnjtoav\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #16, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n40 30\nxumfrflllrrgswehqtsskefixhcxjrxbjmrpsshv\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #17, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 31\nahbyyoxltryqdmvenemaqnbakglgqolxnaifnqtoclnnqiabpz\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #18, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n10 7\niuiukrxcml\nOutput\n99\nAnswer\n99\nChecker Log\nok 1 number(s): \"99\"\nTest: #19, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n38 2\nvjzarfykmrsrvwbwfwldsulhxtykmjbnwmdufa\nOutput\n5\nAnswer\n5\nChecker Log\nok 1 number(s): \"5\"\nTest: #20, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n12 6\nfwseyrarkwcd\nOutput\n61\nAnswer\n61\nChecker Log\nok 1 number(s): \"61\"\nTest: #21, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nac\nOutput\n4\nAnswer\n4\nChecker Log\nok 1 number(s): \"4\"\nTest: #22, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\nc\nOutput\n3\nAnswer\n3\nChecker Log\nok 1 number(s): \"3\"\nTest: #23, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nad\nOutput\n5\nAnswer\n5\nChecker Log\nok 1 number(s): \"5\"\nTest: #24, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n2 1\nac\nOutput\n-1\nAnswer\n1\nChecker Log\nwrong answer 1st number\n*/", "complexity": "linear", "from": "CorCod", "problem": 176, "index": 176}
{"src": "\n// Java program to check if binary tree \n// is subtree of another binary tree \nclass\nNode { \n\n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nPassing { \n\n\nint\ni; \n\nint\nm = \n0\n; \n\nint\nn = \n0\n; \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\nPassing p = \nnew\nPassing(); \n\n\nString strstr(String haystack, String needle) \n\n{ \n\nif\n(haystack == \nnull\n|| needle == \nnull\n) { \n\nreturn\nnull\n; \n\n} \n\nint\nhLength = haystack.length(); \n\nint\nnLength = needle.length(); \n\nif\n(hLength < nLength) { \n\nreturn\nnull\n; \n\n} \n\nif\n(nLength == \n0\n) { \n\nreturn\nhaystack; \n\n} \n\nfor\n(\nint\ni = \n0\n; i <= hLength - nLength; i++) { \n\nif\n(haystack.charAt(i) == needle.charAt(\n0\n)) { \n\nint\nj = \n0\n; \n\nfor\n(; j < nLength; j++) { \n\nif\n(haystack.charAt(i + j) != needle.charAt(j)) { \n\nbreak\n; \n\n} \n\n} \n\nif\n(j == nLength) { \n\nreturn\nhaystack.substring(i); \n\n} \n\n} \n\n} \n\nreturn\nnull\n; \n\n} \n\n\n// A utility function to store inorder traversal of tree rooted \n\n// with root in an array arr[]. Note that i is passed as reference \n\nvoid\nstoreInorder(Node node, \nchar\narr[], Passing i) \n\n{ \n\nif\n(node == \nnull\n) { \n\narr[i.i++] = \n'$'\n; \n\nreturn\n; \n\n} \n\nstoreInorder(node.left, arr, i); \n\narr[i.i++] = node.data; \n\nstoreInorder(node.right, arr, i); \n\n} \n\n\n// A utility function to store preorder traversal of tree rooted \n\n// with root in an array arr[]. Note that i is passed as reference \n\nvoid\nstorePreOrder(Node node, \nchar\narr[], Passing i) \n\n{ \n\nif\n(node == \nnull\n) { \n\narr[i.i++] = \n'$'\n; \n\nreturn\n; \n\n} \n\narr[i.i++] = node.data; \n\nstorePreOrder(node.left, arr, i); \n\nstorePreOrder(node.right, arr, i); \n\n} \n\n\n/* This function returns true if S is a subtree of T, otherwise false */\n\nboolean\nisSubtree(Node T, Node S) \n\n{ \n\n/* base cases */\n\nif\n(S == \nnull\n) { \n\nreturn\ntrue\n; \n\n} \n\nif\n(T == \nnull\n) { \n\nreturn\nfalse\n; \n\n} \n\n\n// Store Inorder traversals of T and S in inT[0..m-1] \n\n// and inS[0..n-1] respectively \n\nchar\ninT[] = \nnew\nchar\n[\n100\n]; \n\nString op1 = String.valueOf(inT); \n\nchar\ninS[] = \nnew\nchar\n[\n100\n]; \n\nString op2 = String.valueOf(inS); \n\nstoreInorder(T, inT, p); \n\nstoreInorder(S, inS, p); \n\ninT[p.m] = \n'\\0'\n; \n\ninS[p.m] = \n'\\0'\n; \n\n\n// If inS[] is not a substring of preS[], return false \n\nif\n(strstr(op1, op2) != \nnull\n) { \n\nreturn\nfalse\n; \n\n} \n\n\n// Store Preorder traversals of T and S in inT[0..m-1] \n\n// and inS[0..n-1] respectively \n\np.m = \n0\n; \n\np.n = \n0\n; \n\nchar\npreT[] = \nnew\nchar\n[\n100\n]; \n\nchar\npreS[] = \nnew\nchar\n[\n100\n]; \n\nString op3 = String.valueOf(preT); \n\nString op4 = String.valueOf(preS); \n\nstorePreOrder(T, preT, p); \n\nstorePreOrder(S, preS, p); \n\npreT[p.m] = \n'\\0'\n; \n\npreS[p.n] = \n'\\0'\n; \n\n\n// If inS[] is not a substring of preS[], return false \n\n// Else return true \n\nreturn\n(strstr(op3, op4) != \nnull\n); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode T = \nnew\nNode(\n'a'\n); \n\nT.left = \nnew\nNode(\n'b'\n); \n\nT.right = \nnew\nNode(\n'd'\n); \n\nT.left.left = \nnew\nNode(\n'c'\n); \n\nT.right.right = \nnew\nNode(\n'e'\n); \n\n\nNode S = \nnew\nNode(\n'a'\n); \n\nS.left = \nnew\nNode(\n'b'\n); \n\nS.right = \nnew\nNode(\n'd'\n); \n\nS.left.left = \nnew\nNode(\n'c'\n); \n\n\nif\n(tree.isSubtree(T, S)) { \n\nSystem.out.println(\n\"Yes, S is a subtree of T\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"No, S is not a subtree of T\"\n); \n\n} \n\n} \n} \n\n// This code is contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 177, "index": 177}
{"src": "\n// LM10: The next Ballon d'or\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport javafx.util.Pair;\npublic class Main\n{\n    static class FastReader\n    {\n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public FastReader() { this(System.in); }public FastReader(InputStream is) { mIs = is;}\n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];}\n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;}\n        public String next(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();}\n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;}\n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;}\n        public double d() throws IOException {return Double.parseDouble(next()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; }\n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; }\n        public void scanIntArr(int [] arr){ for(int li=0;li<arr.length;++li){ arr[li]=i();}}\n        public void scanLongArr(long [] arr){for (int i=0;i<arr.length;++i){arr[i]=l();}}\n        public void shuffle(int [] arr){ for(int i=arr.length;i>0;--i) { int r=(int)(Math.random()*i); int temp=arr[i-1]; arr[i-1]=arr[r]; arr[r]=temp; } }\n    }\n    public static void main(String[] args)throws IOException {\n        /*\ninputCopy\n4\n2 1 2 1\noutputCopy\n4\ninputCopy\n5\n0 -1 -1 -1 -1\noutputCopy\n4\n*/\n        PrintWriter pw = new PrintWriter(System.out);\n        FastReader fr = new FastReader();\n        int n=fr.i();\n        int [] arr=new int[n];\n        fr.scanIntArr(arr);\n        int min=Integer.MAX_VALUE;\n        int max=Integer.MIN_VALUE;\n        long sum=0;\n        if(n==1)\n        {\n            pw.println(arr[0]);\n            pw.flush();\n            pw.close();\n            return;\n        }\n        for(int i=0;i<n;++i)\n        {\n            if(arr[i]<min)\n                min=arr[i];\n            if(arr[i]>max)\n                max=arr[i];\n            sum+=Math.abs(arr[i]);\n        }\n        if(min>0)\n        {\n            sum-=2*min;\n        }\n        if(max<0)\n        {\n            sum+=2*max;\n        }\n        pw.println(sum);\n        pw.flush();\n        pw.close();\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 178, "index": 178}
{"src": "\n// A simple Java program to rearrange contents of arr[] \n// such that arr[j] becomes j if arr[i] is j \nclass\nRearrangeArray { \n\n// A simple method to rearrange 'arr[0..n-1]' so that 'arr[j]' \n\n// becomes 'i' if 'arr[i]' is 'j' \n\nvoid\nrearrangeNaive(\nint\narr[], \nint\nn) \n\n{ \n\n// Create an auxiliary array of same size \n\nint\ntemp[] = \nnew\nint\n[n]; \n\nint\ni; \n\n\n// Store result in temp[] \n\nfor\n(i = \n0\n; i < n; i++) \n\ntemp[arr[i]] = i; \n\n\n// Copy temp back to arr[] \n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n// A utility function to print contents of arr[0..n-1] \n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n1\n, \n3\n, \n0\n, \n2\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrangeNaive(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 179, "index": 179}
{"src": "import java.io.*;\nimport java.util.*;\npublic class GFG {\n\tpublic static void main (String[] args) {\n\t    Scanner sc = new Scanner (System.in);\n\t    int n = sc.nextInt();\n\t    int a = sc.nextInt();\n\t    int b = sc.nextInt();\n\t    int c = sc.nextInt();\n\t    int ans = 0;\n\t    int t= sc.nextInt();\n\t    int arr[] = new int[n];\n\t    for(int i=0;i<n;i++){\n\t        int nn = sc.nextInt();\n\t        ans+=a;\n\t        if(b<c){\n\t            ans += (t-nn) * (c - b);\n\t        }\n\t    }\n\t    System.out.println(ans);\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 180, "index": 180}
{"src": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(bf.readLine());\n        int[]f=new int[1001];\n        int[]a=new int[n];\n        StringTokenizer tk=new StringTokenizer(bf.readLine());\n        for (int i = 0; i < n; i++) {\n            int element=Integer.parseInt(tk.nextToken());\n            a[i]=element;\n            f[element]++;\n        }\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        ArrayList<Integer> h=new ArrayList<>();\n        int counter=0;\n        for (int i = 0; i < n; i++) {\n            if(f[a[i]]==1){counter++; h.add(a[i]);}\n            else{f[a[i]]-=1;}\n        }\n        pw.write(counter+\"\\n\");\n        for (int i = 0; i < h.size(); i++) {\n            pw.write(h.get(i)+\" \");\n        }\n        pw.flush();\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 181, "index": 181}
{"src": "\n/* Java program to convert left-right to \ndown-right representation of binary tree */\nclass\nGFG \n{ \n\n// A Binary Tree Node \nstatic\nclass\nnode \n{ \n\nint\nkey; \n\nnode left, right; \n\nnode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nthis\n.left = \nnull\n; \n\nthis\n.right = \nnull\n; \n\n} \n} \n\n// An Iterative level order traversal \n// based function to convert left-right \n// to down-right representation. \nstatic\nvoid\nconvert(node root) \n{ \n\n// Base Case \n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n// Recursively convert left \n\n// an right subtrees \n\nconvert(root.left); \n\nconvert(root.right); \n\n\n// If left child is NULL, make right \n\n// child as left as it is the first child. \n\nif\n(root.left == \nnull\n) \n\nroot.left = root.right; \n\n\n// If left child is NOT NULL, then make \n\n// right child as right of left child \n\nelse\n\nroot.left.right = root.right; \n\n\n// Set root's right as NULL \n\nroot.right = \nnull\n; \n} \n\n// A utility function to traverse a \n// tree stored in down-right form. \nstatic\nvoid\ndownRightTraversal(node root) \n{ \n\nif\n(root != \nnull\n) \n\n{ \n\nSystem.out.print(root.key + \n\" \"\n); \n\ndownRightTraversal(root.right); \n\ndownRightTraversal(root.left); \n\n} \n} \n\n// Utility function to create \n// a new tree node \nstatic\nnode newNode(\nint\nkey) \n{ \n\nnode temp = \nnew\nnode(\n0\n); \n\ntemp.key = key; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n// Let us create binary tree \n\n// shown in above diagram \n\n/* \n\n1 \n\n/ \\ \n\n2 3 \n\n/ \\ \n\n4 5 \n\n/ / \\ \n\n6 7 8 \n\n*/\n\nnode root = \nnew\nnode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\nroot.right.left.left = newNode(\n6\n); \n\nroot.right.right.left = newNode(\n7\n); \n\nroot.right.right.right = newNode(\n8\n); \n\n\nconvert(root); \n\n\nSystem.out.println(\n\"Traversal of the tree \"\n+ \n\n\"converted to down-right form\"\n); \n\ndownRightTraversal(root); \n} \n} \n\n// This code is contributed \n// by Prerna Saini ", "complexity": "linear", "from": "CorCod", "problem": 182, "index": 182}
{"src": "\n// Java code to find largest three elements \n// in an array \n\nclass\nPrintLargest \n{ \n\n/* Function to print three largest elements */\n\nstatic\nvoid\nprint3largest(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ni, first, second, third; \n\n\n/* There should be atleast three elements */\n\nif\n(arr_size < \n3\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nthird = first = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i ++) \n\n{ \n\n/* If current element is greater than \n\nfirst*/\n\nif\n(arr[i] > first) \n\n{ \n\nthird = second; \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n/* If arr[i] is in between first and \n\nsecond then update second */\n\nelse\nif\n(arr[i] > second) \n\n{ \n\nthird = second; \n\nsecond = arr[i]; \n\n} \n\n\nelse\nif\n(arr[i] > third) \n\nthird = arr[i]; \n\n} \n\n\nSystem.out.println(\n\"Three largest elements are \"\n+ \n\nfirst + \n\" \"\n+ second + \n\" \"\n+ third); \n\n} \n\n\n/* Driver program to test above function*/\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint3largest(arr, n); \n\n} \n} \n/*This code is contributed by Prakriti Gupta \nand edited by Ayush Singla(@ayusin51)*/", "complexity": "linear", "from": "CorCod", "problem": 183, "index": 183}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        int ans = -1;\n        int time = 1;\n        int n = S.length();\n        for (int i = 1; i < n*2; i++) {\n            if( S.charAt((i-1)%n) != S.charAt(i%n) ) {\n                time++;\n            } else {\n                ans = Math.max(time, ans);\n                time = 1;\n            }\n        }\n        ans = Math.max(time, ans);\n\n        if( ans == n*2 ) {\n            return n;\n        } else {\n            return ans;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 184, "index": 184}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class UniformString {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = nextInt();\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint n = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tString s = \"\";\n\t\t\tfor (int j = 0; j < n; j++) \n\t\t\t\ts += (char)('a' + (j%k)); \n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 185, "index": 185}
{"src": "\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.util.Scanner;\n\npublic class A1 {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n\n        long size = scan.nextLong();\n        int numberOfSpecial = scan.nextInt();\n        long pageSize = scan.nextLong();\n\n        long[] specialItemsArray = new long[numberOfSpecial];\n        for (int i = 0; i < numberOfSpecial; i++) {\n            specialItemsArray[i] = scan.nextLong();\n        }\n\n        int totalRemoved = 0;\n        int step = 0;\n\n        long currentPageIndex = BigDecimal.valueOf(specialItemsArray[0]).divide(BigDecimal.valueOf(pageSize),2, RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();\n        int specialItemArrayIndex = 1;\n\n        while (specialItemArrayIndex < numberOfSpecial) {\n            long pageIndex = BigDecimal.valueOf(specialItemsArray[specialItemArrayIndex] - totalRemoved).divide(BigDecimal.valueOf(pageSize),2,RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();\n            if (currentPageIndex != pageIndex) {\n                step++;\n                totalRemoved = specialItemArrayIndex;\n                currentPageIndex =  BigDecimal.valueOf(specialItemsArray[specialItemArrayIndex] - totalRemoved).divide(BigDecimal.valueOf(pageSize),2,RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();\n            }\n            specialItemArrayIndex++;\n        }\n\n\n        System.out.println(step + 1);\n\n    }\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 186, "index": 186}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tint n = input.nextInt();\n\t\tString s = input.next();\n\t\tboolean done = false;\n\t\tfor (int i = 0; i < s.length() - 1; i++)\n\t\t{\n\t\t\tif (s.charAt(i) != s.charAt(i + 1))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tSystem.out.println(s.charAt(i) + \"\" + s.charAt(i + 1));\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!done)\n\t\t{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 187, "index": 187}
{"src": "\n// Java program to check if a given array is sorted \n// or not. \n\nclass\nGFG { \n\n// Function that returns true if array is Inorder \n// traversal of any Binary Search Tree or not. \n\nstatic\nboolean\nisInorder(\nint\n[] arr, \nint\nn) { \n\n// Array has one or no element \n\nif\n(n == \n0\n|| n == \n1\n) { \n\nreturn\ntrue\n; \n\n} \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n// Unsorted pair found \n\n{ \n\nif\n(arr[i - \n1\n] > arr[i]) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n// No unsorted pair found \n\nreturn\ntrue\n; \n\n} \n// Drivers code \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n19\n, \n23\n, \n25\n, \n30\n, \n45\n}; \n\nint\nn = arr.length; \n\nif\n(isInorder(arr, n)) { \n\nSystem.out.println(\n\"Yes\"\n); \n\n} \nelse\n{ \n\nSystem.out.println(\n\"Non\"\n); \n\n} \n\n} \n} \n//This code is contributed by 29AjayKumar ", "complexity": "linear", "from": "CorCod", "problem": 188, "index": 188}
{"src": "\n// Java implementation to find the character in \n// first string that is present at minimum index \n// in second string \n\nimport\njava.util.HashMap; \n\npublic\nclass\nGFG \n{ \n\n// method to find the minimum index character \n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n// map to store the first index of each character of 'str' \n\nHashMap<Character, Integer> hm = \nnew\nHashMap<>(); \n\n\n// to store the index of character having \n\n// minimum index \n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n// lengths of the two strings \n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n// store the first index of each character of 'str' \n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(!hm.containsKey(str.charAt(i))) \n\nhm.put(str.charAt(i),i); \n\n\n// traverse the string 'patt' \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n// if patt[i] is found in 'um', check if \n\n// it has the minimum index or not accordingly \n\n// update 'minIndex' \n\nif\n(hm.containsKey(patt.charAt(i)) && \n\nhm.get(patt.charAt(i)) < minIndex) \n\nminIndex = hm.get(patt.charAt(i)); \n\n\n// print the minimum index character \n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n// if no character of 'patt' is present in 'str' \n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n// Driver Method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 189, "index": 189}
{"src": "\n// A recursive java program to print reverse level order traversal \n// using stack and queue \n\nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \nimport\njava.util.Stack; \n\n/* A binary tree node has data, pointer to left and right children */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* Given a binary tree, print its nodes in reverse level order */\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack(); \n\nQueue<Node> Q = \nnew\nLinkedList(); \n\nQ.add(node); \n\n\n// Do something like normal level order traversal order.Following \n\n// are the differences with normal level order traversal \n\n// 1) Instead of printing a node, we push the node to stack \n\n// 2) Right subtree is visited before left subtree \n\nwhile\n(Q.isEmpty() == \nfalse\n) \n\n{ \n\n/* Dequeue node and make it root */\n\nnode = Q.peek(); \n\nQ.remove(); \n\nS.push(node); \n\n\n/* Enqueue right child */\n\nif\n(node.right != \nnull\n) \n\n// NOTE: RIGHT CHILD IS ENQUEUED BEFORE LEFT \n\nQ.add(node.right); \n\n\n/* Enqueue left child */\n\nif\n(node.left != \nnull\n) \n\nQ.add(node.left); \n\n} \n\n\n// Now pop all items from stack one by one and print them \n\nwhile\n(S.empty() == \nfalse\n) \n\n{ \n\nnode = S.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nS.pop(); \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n// Let us create trees shown in above diagram \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is :\"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 190, "index": 190}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class AnnoyingPresent {\n\n\t\n\t//UPSOLVED\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n        long n = Long.parseLong(st.nextToken()) , m = Long.parseLong(st.nextToken());\n        \n        long sum = 0;\n        \n        for(int i=0;i<m;i++){\n        \tStringTokenizer st1 = new StringTokenizer(br.readLine());\n            sum+= n* Long.parseLong(st1.nextToken());\n            Long a= Long.parseLong(st1.nextToken());\n            if(a < 0){\n                if(n % 2 == 0)\n                    sum += n*n / 4*a;\n                else{\n                    sum += (n/2) * (n/2+1) * a;\n                }\n            }\n            else\n                sum += (a*(n) * (n-1) / 2);\n            \n        }\n        System.out.println((double)sum/n);\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 191, "index": 191}
{"src": "\n// Recursive Java Program to reverse an array \nimport\njava.io.*; \n\nclass\nReverseArray { \n\n\n/* Function to reverse arr[] from start to end*/\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n\n{ \n\nint\ntemp; \n\nif\n(start >= end) \n\nreturn\n; \n\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nrvereseArray(arr, start+\n1\n, end-\n1\n); \n\n} \n\n\n/* Utility that prints out an array on a line */\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n/*Driver function to check for above functions*/\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nprintArray(arr, \n6\n); \n\nrvereseArray(arr, \n0\n, \n5\n); \n\nSystem.out.println(\n\"Reversed array is \"\n); \n\nprintArray(arr, \n6\n); \n\n} \n} \n/*This article is contributed by Devesh Agrawal*/", "complexity": "linear", "from": "CorCod", "problem": 192, "index": 192}
{"src": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class A1180 {\n\n    public static void main(String[] args) throws FileNotFoundException \n    { \n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint layers = n-1;\n\t\tint counter =0;\n\t\tfor(int i =1 ;i < layers + 1 ; i ++) {\n\t\t\tcounter += i ;\n\t\t}\n\t\t//System.out.println(counter);\n\t\tSystem.out.println(1 + counter*4);\n    } \n}\n", "complexity": "linear", "from": "CorCod", "problem": 193, "index": 193}
{"src": "\n// Most efficient Java program to count all \n// substrings with same first and last characters. \npublic\nclass\nGFG { \n\n\n// assuming lower case only \n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n// Calculating frequency of each character \n\n// in the string. \n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[s.charAt(i)-\n'a'\n]++; \n\n\n// Computing result using counts \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nresult += (count[i] * (count[i] + \n1\n) / \n2\n); \n\n\nreturn\nresult; \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "linear", "from": "CorCod", "problem": 194, "index": 194}
{"src": "import java.util.Scanner;\n\npublic class GenerateLogin {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\tchar last = b.charAt(0);\n\t\tString ans = \"\"+a.charAt(0);\n\t\tfor(int i = 1;i<a.length();i++){\n\t\t\tif(a.charAt(i)>=last)break;\n\t\t\tans+=a.charAt(i);\n\t\t}\n\t\tans+=last;\n\t\tSystem.out.println(ans);\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 195, "index": 195}
{"src": "\n// Java program to see if there is a root to leaf path \n// with given sequence. \npublic\nclass\nCheckForPath { \n\n\n// function to check given sequence of root to leaf path exist \n\n// in tree or not. \n\n// index represents current element in sequence of rooth to \n\n// leaf path \n\npublic\nstatic\nboolean\nexistPath(Node root, \nint\narr[], \nint\nindex) \n\n{ \n\n// If root is NULL, then there must not be any element \n\n// in array. \n\nif\n(root==\nnull\n) \n\n{ \n\nreturn\narr.length==\n0\n; \n\n} \n\n\n// If this node is a leaf and matches with last entry \n\n// of array. \n\nif\n((root.left==\nnull\n&& root.right==\nnull\n) && (root.data==arr[index] \n\n&& root.data==arr[arr.length-\n1\n])) \n\n{ \n\nreturn\ntrue\n; \n\n} \n\n\n// If current node is equal to arr[index] this means \n\n// that till this level path has been matched and \n\n// remaining path can be either in left subtree or \n\n// right subtree. \n\nreturn\n(index<arr.length && (root.data==arr[index] && \n\n(existPath(root.left,arr,index+\n1\n) || \n\nexistPath(root.right, arr, index+\n1\n)))); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\n// arr[] is sequence of root to leaf path \n\nint\narr[] = {\n5\n, \n8\n, \n6\n, \n7\n}; \n\nNode root=\nnew\nNode(\n5\n); \n\nroot.left=\nnew\nNode(\n3\n); \n\nroot.right=\nnew\nNode(\n8\n); \n\nroot.left.left = \nnew\nNode(\n2\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.left.left.left = \nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n6\n); \n\nroot.right.left.right = \nnew\nNode(\n7\n); \n\n\nif\n(existPath(root, arr, \n0\n)) \n\n{ \n\nSystem.out.print(\n\"Path Exists\"\n); \n\n} \n\nelse\n\n{ \n\nSystem.out.print(\n\"Path does not Exist\"\n); \n\n} \n\n} \n} \n\n/* A binary tree node has data, pointer to left child \nand a pointer to right child */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\nleft=right=\nnull\n; \n\n} \n}; \n\n// This code is contributed by Gaurav Tiwari ", "complexity": "linear", "from": "CorCod", "problem": 196, "index": 196}
{"src": "\n// Efficient Java program to sort an \n// array of numbers in range from 1 \n// to n. \nimport\njava.io.*; \nimport\njava.util.*; \n\npublic\nclass\nGFG { \n\n\n\n// function for sort array \n\nstatic\nvoid\nsortit(\nint\n[]arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i]=i+\n1\n; \n\n\n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n7\n, \n9\n, \n2\n, \n8\n, \n\n3\n, \n5\n, \n4\n, \n6\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n// for sort an array \n\nsortit(arr, n); \n\n\n// for print all the \n\n// element in sorted way \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} \n\n// This code is contributed by Manish Shaw \n// (manishshaw1) ", "complexity": "linear", "from": "CorCod", "problem": 197, "index": 197}
{"src": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\npublic class alex\n{\n    public static void main(String[] args)throws IOException\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();int sum=1;\n        for(int i=1;i<=n;i++)\n        {\n            sum=sum+(4*(i-1));\n        }\n        System.out.println(sum);\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 198, "index": 198}
{"src": "\nclass\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni = \n0\n; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nint\nprev=\n0\n; \n\n\n// Find the first occurence of any of the two numbers (x or y) \n\n// and store the index of this occurence in prev \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\nprev = i; \n\nbreak\n; \n\n} \n\n} \n\n\n// Traverse after the first occurence \n\nfor\n(; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\n// If the current element matches with any of the two then \n\n// check if current element and prev element are different \n\n// Also check if this value is smaller than minimum distance \n\n// so far \n\nif\n(arr[prev] != arr[i] && (i - prev) < min_dist) \n\n{ \n\nmin_dist = i - prev; \n\nprev = i; \n\n} \n\nelse\n\nprev = i; \n\n} \n\n} \n\n\nreturn\nmin_dist; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n3\n, \n0\n, \n0\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 199, "index": 199}
{"src": "import java.util.Scanner;\n\npublic class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tbeacon[sc.nextInt()] = sc.nextInt();\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 1;\n\t\tif (beacon[0] > 0) {\n\t\t\tdp[0] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint b = beacon[i];\n\t\t\t\tif (i <= b) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[i-b-1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t\tsc.close();\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 200, "index": 200}
{"src": "\n// Java program to check whether a given \n// Binary Tree is Perfect or not \nclass\nGfG { \n\n/* Tree node structure */\nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n// Returns depth of leftmost leaf. \nstatic\nint\nfindADepth(Node node) \n{ \nint\nd = \n0\n; \nwhile\n(node != \nnull\n) \n{ \n\nd++; \n\nnode = node.left; \n} \nreturn\nd; \n} \n\n/* This function tests if a binary tree is perfect \nor not. It basically checks for two things : \n1) All leaves are at same level \n2) All internal nodes have two children */\nstatic\nboolean\nisPerfectRec(Node root, \nint\nd, \nint\nlevel) \n{ \n\n// An empty tree is perfect \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// If leaf node, then its depth must be same as \n\n// depth of all other leaves. \n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\n(d == level+\n1\n); \n\n\n// If internal node and one child is empty \n\nif\n(root.left == \nnull\n|| root.right == \nnull\n) \n\nreturn\nfalse\n; \n\n\n// Left and right subtrees must be perfect. \n\nreturn\nisPerfectRec(root.left, d, level+\n1\n) && isPerfectRec(root.right, d, level+\n1\n); \n} \n\n// Wrapper over isPerfectRec() \nstatic\nboolean\nisPerfect(Node root) \n{ \nint\nd = findADepth(root); \nreturn\nisPerfectRec(root, d, \n0\n); \n} \n\n/* Helper function that allocates a new node with the \ngiven key and NULL left and right pointer. */\nstatic\nNode newNode(\nint\nk) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.key = k; \n\nnode.right = \nnull\n; \n\nnode.left = \nnull\n; \n\nreturn\nnode; \n} \n\n// Driver Program \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = \nnull\n; \n\nroot = newNode(\n10\n); \n\nroot.left = newNode(\n20\n); \n\nroot.right = newNode(\n30\n); \n\n\nroot.left.left = newNode(\n40\n); \n\nroot.left.right = newNode(\n50\n); \n\nroot.right.left = newNode(\n60\n); \n\nroot.right.right = newNode(\n70\n); \n\n\nif\n(isPerfect(root) == \ntrue\n) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 201, "index": 201}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author zodiacLeo\n */\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskC\n    {\n        public void solve(int testNumber, FastScanner in, FastPrinter out)\n        {\n            int n = in.nextInt();\n            long[] a = new long[n];\n            long[] b = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                b[i] = a[i] = in.nextInt();\n                if (i > 0)\n                {\n                    a[i] += a[i - 1];\n                }\n            }\n            for (int i = n - 2; i >= 0; i--)\n            {\n                b[i] += b[i + 1];\n            }\n            \n            long sum1 = 0;\n            long sum3 = 0;\n            long result = 0;\n            for (int i = 0, j = n - 1; i < j; )\n            {\n                sum1 = a[i];\n                sum3 = b[j];\n                if (sum1 == sum3)\n                {\n                    result = Math.max(result, sum1);\n                    i++;\n                    j--;\n                }\n                else if (sum1 < sum3)\n                {\n                    i++;\n                }\n                else\n                {\n                    j--;\n                }\n            }\n            out.println(result);\n            \n            \n        }\n        \n    }\n    \n    static class FastScanner\n    {\n        public BufferedReader br;\n        public StringTokenizer st;\n        \n        public FastScanner(InputStream is)\n        {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n        \n        public FastScanner(File f)\n        {\n            try\n            {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        \n        public String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                String s = null;\n                try\n                {\n                    s = br.readLine();\n                } catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                {\n                    return null;\n                }\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        \n    }\n    \n    static class FastPrinter extends PrintWriter\n    {\n        public FastPrinter(OutputStream out)\n        {\n            super(out);\n        }\n        \n        public FastPrinter(Writer out)\n        {\n            super(out);\n        }\n        \n    }\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 202, "index": 202}
{"src": "\n// Java program for solution of \n// friends pairing problem \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Returns count of ways n people \n\n// can remain single or paired up. \n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n + \n1\n]; \n\n\n// Filling dp[] in bottom-up manner using \n\n// recursive formula explained above. \n\nfor\n(\nint\ni = \n0\n; i <= n; i++) { \n\nif\n(i <= \n2\n) \n\ndp[i] = i; \n\nelse\n\ndp[i] = dp[i - \n1\n] + (i - \n1\n) * dp[i - \n2\n]; \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n} \n\n// This code is contributed by vt_m ", "complexity": "linear", "from": "CorCod", "problem": 203, "index": 203}
{"src": "/*\nRoses are red\nMemes are neat\nAll my test cases time out\nLmao yeet\n*/\nimport java.util.*;\nimport java.io.*;\n\n   public class A\n   {\n      public static void main(String args[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in)); \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int L = Integer.parseInt(st.nextToken());\n         int A = Integer.parseInt(st.nextToken());\n         int[] arr1 = new int[N];\n         int[] arr2 = new int[N];\n         for(int i=0; i < N; i++)\n         {\n            st = new StringTokenizer(infile.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken())+x;\n            arr1[i] = x;\n            arr2[i] = y;\n         }\n         int res = 0;\n         for(int i=1; i < N; i++)\n            res += (arr1[i]-arr2[i-1])/A;\n         if(N > 0)\n            res += (L-arr2[N-1])/A+arr1[0]/A;\n         else\n            res += L/A;\n         System.out.println(res);\n      }\n   }", "complexity": "linear", "from": "CorCod", "problem": 204, "index": 204}
{"src": "\n// Java Code for Maximum sum in a 2 x n grid \n// such that no two elements are adjacent \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Function to find max sum without adjacent \n\npublic\nstatic\nint\nmaxSum(\nint\ngrid[][], \nint\nn) \n\n{ \n\n// Sum including maximum element of first \n\n// column \n\nint\nincl = Math.max(grid[\n0\n][\n0\n], grid[\n1\n][\n0\n]); \n\n\n// Not including first column's element \n\nint\nexcl = \n0\n, excl_new; \n\n\n// Traverse for further elements \n\nfor\n(\nint\ni = \n1\n; i < n; i++ ) \n\n{ \n\n// Update max_sum on including or \n\n// excluding of previous column \n\nexcl_new = Math.max(excl, incl); \n\n\n// Include current column. Add maximum element \n\n// from both row of current column \n\nincl = excl + Math.max(grid[\n0\n][i], grid[\n1\n][i]); \n\n\n// If current column doesn't to be included \n\nexcl = excl_new; \n\n} \n\n\n// Return maximum of excl and incl \n\n// As that will be the maximum sum \n\nreturn\nMath.max(excl, incl); \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ngrid[][] = {{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n}, \n\n{ \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}}; \n\n\nint\nn = \n5\n; \n\nSystem.out.println(maxSum(grid, n)); \n\n} \n\n} \n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "linear", "from": "CorCod", "problem": 205, "index": 205}
{"src": "\n// Java program to remove duplicates, the order of \n// characters is not maintained in this program \n\npublic\nclass\nGFG \n{ \n\nstatic\nfinal\nint\nNO_OF_CHARS = \n256\n; \n\n\n/* Returns an array of size 256 containg count \n\nof characters in the passed char array */\n\nstatic\nint\n[] getCharCountArray(String str) \n\n{ \n\nint\ncount[] = \nnew\nint\n[NO_OF_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i<str.length(); i++) \n\ncount[str.charAt(i)]++; \n\n\nreturn\ncount; \n\n} \n\n\n/* removeDirtyChars takes two string as arguments: First \n\nstring (str) is the one from where function removes dirty \n\ncharacters. Second string is the string which contain all \n\ndirty characters which need to be removed from first string */\n\nstatic\nString removeDirtyChars(String str, String mask_str) \n\n{ \n\nint\ncount[] = getCharCountArray(mask_str); \n\nint\nip_ind = \n0\n, res_ind = \n0\n; \n\n\nchar\narr[] = str.toCharArray(); \n\n\nwhile\n(ip_ind != arr.length) \n\n{ \n\nchar\ntemp = arr[ip_ind]; \n\nif\n(count[temp] == \n0\n) \n\n{ \n\narr[res_ind] = arr[ip_ind]; \n\nres_ind ++; \n\n} \n\nip_ind++; \n\n\n} \n\n\nstr = \nnew\nString(arr); \n\n\n/* After above step string is ngring. \n\nRemoving extra \"iittg\" after string*/\n\n\nreturn\nstr.substring(\n0\n, res_ind); \n\n\n} \n\n\n// Driver Method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString mask_str = \n\"mask\"\n; \n\nSystem.out.println(removeDirtyChars(str, mask_str)); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 206, "index": 206}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint tmp;\n\t\tint min=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttmp=sc.nextInt();\n\t\t\tif(i>n-1-i) {\n\t\t\t\ttmp=tmp/i;\n\t\t\t}else {\n\t\t\t\ttmp=tmp/(n-1-i);\n\t\t\t}\n\t\t\tif(tmp<min) {\n\t\t\t\tmin=tmp;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 207, "index": 207}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner in=new Scanner(System.in);\n\t\tString str=in.next();\n\t\tint cnt=0;\n\t\tfor(int i=0;i<str.length();++i) {\n\t\t\tif(str.charAt(i)=='1') {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tint i=0;\n\t\tfor(;i<str.length();++i) {\n\t\t\tif(str.charAt(i)=='0') {\n\t\t\t\tSystem.out.print(\"0\");\n\t\t\t}\n\t\t\telse if(str.charAt(i)=='2') {\n\t\t\t\twhile(cnt-->0) {//\n\t\t\t\t\tSystem.out.print(\"1\");\n\t\t\t\t}\n\t\t\t\tSystem.out.print(\"2\");\n\t\t\t}\n\t\t}\n\t\twhile(cnt-->0) {\n\t\t\tSystem.out.print(\"1\");\n\t\t}\n\t\tin.close();\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 208, "index": 208}
{"src": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint n = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tif(n % 2 == 0) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint maxi = -1, max = -1;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tint x = a[i] >= 0 ? -a[i] - 1 : a[i];\n\t\t\t\tx = -x;\n\t\t\t\tif(x > max) {\n\t\t\t\t\tmax = x; maxi = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max == 1) {\n\t\t\t\ta[0] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\t\tif(i == maxi) {\n\t\t\t\t\t\tif(a[i] < 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int x : a)\n\t\t\tSystem.out.print(x + \" \");\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "complexity": "linear", "from": "CorCod", "problem": 209, "index": 209}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int best = 1;\n        int bestTime = Integer.MAX_VALUE;\n        for(int i=0;i<n;i++) {\n            int time;\n            int a = sc.nextInt();\n            time = (a%n==0 || a%n<=i) ? a/n : (a+n)/n;\n            if(time < bestTime) {\n                best = i + 1;\n                bestTime = time;\n            }\n        }\n\n        pw.println(best);\n        pw.close();\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 210, "index": 210}
{"src": "\n// Java program to see if two trees are identical \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root1, root2; \n\n\n/* Given two trees, return true if they are \n\nstructurally identical */\n\nboolean\nidenticalTrees(Node a, Node b) \n\n{ \n\n/*1. both empty */\n\nif\n(a == \nnull\n&& b == \nnull\n) \n\nreturn\ntrue\n; \n\n\n/* 2. both non-empty -> compare them */\n\nif\n(a != \nnull\n&& b != \nnull\n) \n\nreturn\n(a.data == b.data \n\n&& identicalTrees(a.left, b.left) \n\n&& identicalTrees(a.right, b.right)); \n\n\n/* 3. one empty, one not -> false */\n\nreturn\nfalse\n; \n\n} \n\n\n/* Driver program to test identicalTrees() function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\ntree.root1 = \nnew\nNode(\n1\n); \n\ntree.root1.left = \nnew\nNode(\n2\n); \n\ntree.root1.right = \nnew\nNode(\n3\n); \n\ntree.root1.left.left = \nnew\nNode(\n4\n); \n\ntree.root1.left.right = \nnew\nNode(\n5\n); \n\n\ntree.root2 = \nnew\nNode(\n1\n); \n\ntree.root2.left = \nnew\nNode(\n2\n); \n\ntree.root2.right = \nnew\nNode(\n3\n); \n\ntree.root2.left.left = \nnew\nNode(\n4\n); \n\ntree.root2.left.right = \nnew\nNode(\n5\n); \n\n\nif\n(tree.identicalTrees(tree.root1, tree.root2)) \n\nSystem.out.println(\n\"Both trees are identical\"\n); \n\nelse\n\nSystem.out.println(\n\"Trees are not identical\"\n); \n\n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 211, "index": 211}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\n/* spar5h */\n\npublic class cf1 implements Runnable{    \n\t\n\tpublic void run() {\n\n\t\tInputReader s = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\t\n\t\tint t = 1;\n\t\t\n\t\twhile(t-- > 0) {\n\t\t\t\n\t\t\tint n = s.nextInt(), m = s.nextInt();\n\t\t\t\n\t\t\tint[] a = new int[n + 1];\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\ta[i] = s.nextInt();\n\t\t\t\n\t\t\tint[] b = new int[n + 1];\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\tb[i] = s.nextInt();\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\t\n\t\t\tlist.add(a[1]);\n\t\t\t\n\t\t\tfor(int i = 2; i <= n; i++) {\n\t\t\t\tlist.add(b[i]); list.add(a[i]);\n\t\t\t}\n\t\t\t\n\t\t\tlist.add(b[1]);\n\t\t\t\n\t\t\tdouble wt = m;\n\t\t\tboolean check = true;\n\t\t\t\n\t\t\tfor(int i = list.size() - 1; i >= 0; i--) {\n\t\t\t\t\n\t\t\t\tif(list.get(i) <= 1) {\n\t\t\t\t\tcheck = false; break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdouble x = wt / (list.get(i) - 1);\n\t\t\t\t\t\t\n\t\t\t\twt += x;\n\t\t\t}\n\t\t\t\n\t\t\tif(check)\n\t\t\t\tw.println(wt - m);\n\t\t\telse\n\t\t\t\tw.println(-1);\n\t\t}\n\t\t\n\t\tw.close();\n\t}\n\t\n\tstatic class InputReader {\n\t\t\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars==-1) \n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t \n\t\tpublic String nextLine()\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n\t\t}\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile(isSpaceChar(c)) \n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') \n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\n\t\t\treturn res.toString();\n\t\t}\n\t \n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t \n\t\tpublic String next() \n\t\t{\n\t\t\treturn readString();\n\t\t}\n\t\t\n\t\tpublic interface SpaceCharFilter \n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n    \n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\tnew Thread(null, new cf1(),\"cf1\",1<<26).start();\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 212, "index": 212}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class D909 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        char[] line = br.readLine().toCharArray();\n        int n = line.length;\n\n        int l = 0;\n        ArrayList<Node> groups = new ArrayList<>();\n        Node node = new Node(line[0], 1);\n        groups.add(node);\n        for (int i = 1; i < n; i++) {\n            if (line[i] == groups.get(l).letter) {\n                groups.get(l).count++;\n            } else {\n                node = new Node(line[i], 1);\n                groups.add(node);\n                l++;\n            }\n        }\n\n        int moves = 0;\n        ArrayList<Node> temp = new ArrayList<>();\n        while (groups.size() > 1) {\n            moves++;\n\n            l = groups.size();\n            groups.get(0).count--;\n            groups.get(l - 1).count--;\n            for (int i = 1; i < l - 1; i++) {\n                groups.get(i).count -= 2;\n            }\n\n            int p;\n            for (p = 0; p < l; p++) {\n                if (groups.get(p).count > 0) {\n                    temp.add(groups.get(p));\n                    break;\n                }\n            }\n            int lTemp = temp.size();\n            for (p++; p < l; p++) {\n                if (groups.get(p).count <= 0) {\n                    continue;\n                }\n                if (groups.get(p).letter == temp.get(lTemp - 1).letter) {\n                    temp.get(lTemp - 1).count += groups.get(p).count;\n                } else {\n                    temp.add(groups.get(p));\n                    lTemp++;\n                }\n            }\n\n            groups.clear();\n            groups.addAll(temp);\n            temp.clear();\n        }\n\n        System.out.println(moves);\n    }\n\n    private static class Node {\n        char letter;\n        int count;\n\n        Node(char letter, int count) {\n            this.letter = letter;\n            this.count = count;\n        }\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 213, "index": 213}
{"src": "\n// A O(n) and O(n) extra space Java program to find \n// longest common subarray of two binary arrays with \n// same sum \n\nclass\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n// Returns length of the longest common sum in arr1[] \n\n// and arr2[]. Both are of same size n. \n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n// Initialize result \n\nint\nmaxLen = \n0\n; \n\n\n// Initialize prefix sums of two arrays \n\nint\npreSum1 = \n0\n, preSum2 = \n0\n; \n\n\n// Create an array to store staring and ending \n\n// indexes of all possible diff values. diff[i] \n\n// would store starting and ending points for \n\n// difference \"i-n\" \n\nint\ndiff[] = \nnew\nint\n[\n2\n*n+\n1\n]; \n\n\n// Initialize all starting and ending values as -1. \n\nfor\n(\nint\ni = \n0\n; i < diff.length; i++) { \n\ndiff[i] = -\n1\n; \n\n} \n\n\n// Traverse both arrays \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n// Update prefix sums \n\npreSum1 += arr1[i]; \n\npreSum2 += arr2[i]; \n\n\n// Comput current diff and index to be used \n\n// in diff array. Note that diff can be negative \n\n// and can have minimum value as -1. \n\nint\ncurr_diff = preSum1 - preSum2; \n\nint\ndiffIndex = n + curr_diff; \n\n\n// If current diff is 0, then there are same number \n\n// of 1's so far in both arrays, i.e., (i+1) is \n\n// maximum length. \n\nif\n(curr_diff == \n0\n) \n\nmaxLen = i+\n1\n; \n\n\n// If current diff is seen first time, then update \n\n// starting index of diff. \n\nelse\nif\n( diff[diffIndex] == -\n1\n) \n\ndiff[diffIndex] = i; \n\n\n// Current diff is already seen \n\nelse\n\n{ \n\n// Find length of this same sum common span \n\nint\nlen = i - diff[diffIndex]; \n\n\n// Update max len if needed \n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 214, "index": 214}
{"src": "\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\n\npublic class TaskB implements Runnable {\n    boolean prime[] = new boolean[(int)1e6+10];\n    InputReader c;\n    PrintWriter w;\n\n    public void run() {\n        c = new InputReader(System.in);\n        w = new PrintWriter(System.out);\n\n        char a[] = c.next().toCharArray(), b[] = c.next().toCharArray();\n        int n = a.length, m = b.length;\n\n        int[][] prefix = new int[m][2];\n        for(int i=0;i<m;i++){\n            if(i!=0) {\n                prefix[i][0] = prefix[i-1][0];\n                prefix[i][1] = prefix[i-1][1];\n            }\n            prefix[i][b[i] - '0']++;\n            //w.println(prefix[i][0]+\" \"+prefix[i][1]);\n        }\n\n        long res = 0;\n        for(int i=0;i<n;i++){\n            int temp = a[i] - '0';\n\n            res += prefix[m - n + i][temp^1];\n            if(i!=0) res -= prefix[i-1][temp^1];\n        }\n\n        w.println(res);\n\n        w.close();\n    }\n\n    void sieveOfEratosthenes(int n) {\n        for(int i=0;i<n;i++)\n            prime[i] = true;\n\n        for(int p = 2; p*p <=n; p++)\n        {\n            if(prime[p] == true)\n            {\n                for(int i = p*p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n    }\n    class pair implements Comparable<pair>{\n        char ch;\n        int ind;\n\n        @Override\n        public String toString() {\n            return \"pair{\" +\n                    \"ch=\" + ch +\n                    \", ind=\" + ind +\n                    '}';\n        }\n\n        public pair(char ch, int ind) {\n            this.ch = ch;\n            this.ind = ind;\n        }\n        public int compareTo(pair car) {\n            if(this.ch==car.ch)\n                return this.ind - car.ind;\n            return this.ch - car.ch;\n        }\n    }\n    public static void sortbyColumn(int arr[][], int col){\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    static long gcd(long a, long b){\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static class DJSet {\n        public int[] upper;\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f) {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    public void printArray(int[] a){\n        for(int i=0;i<a.length;i++)\n            w.print(a[i]+\" \");\n        w.println();\n    }\n    public int[] scanArrayI(int n){\n        int a[] = new int[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextInt();\n        return a;\n    }\n    public long[] scanArrayL(int n){\n        long a[] = new long[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextLong();\n        return a;\n    }\n    public void printArray(long[] a){\n        for(int i=0;i<a.length;i++)\n            w.print(a[i]+\" \");\n        w.println();\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new TaskB(),\"TaskB\",1<<26).start();\n    }\n}\n\n\n\n", "complexity": "linear", "from": "CorCod", "problem": 215, "index": 215}
{"src": "\n// Java program to find maximum product of \n// a subset. \n\nclass\nGFG { \n\n\nstatic\nint\nmaxProductSubset(\nint\na[], \nint\nn) { \n\nif\n(n == \n1\n) { \n\nreturn\na[\n0\n]; \n\n} \n\n\n// Find count of negative numbers, count \n\n// of zeros, maximum valued negative number \n\n// and product of non-zero numbers \n\nint\nmax_neg = Integer.MIN_VALUE; \n\nint\ncount_neg = \n0\n, count_zero = \n0\n; \n\nint\nprod = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// If number is 0, we don't \n\n// multiply it with product. \n\nif\n(a[i] == \n0\n) { \n\ncount_zero++; \n\ncontinue\n; \n\n} \n\n\n// Count negatives and keep \n\n// track of maximum valued negative. \n\nif\n(a[i] < \n0\n) { \n\ncount_neg++; \n\nmax_neg = Math.max(max_neg, a[i]); \n\n} \n\n\nprod = prod * a[i]; \n\n} \n\n\n// If there are all zeros \n\nif\n(count_zero == n) { \n\nreturn\n0\n; \n\n} \n\n\n// If there are odd number of \n\n// negative numbers \n\nif\n(count_neg % \n2\n== \n1\n) { \n\n\n// Exceptional case: There is only \n\n// negative and all other are zeros \n\nif\n(count_neg == \n1\n\n&& count_zero > \n0\n\n&& count_zero + count_neg == n) { \n\nreturn\n0\n; \n\n} \n\n\n// Otherwise result is product of \n\n// all non-zeros divided by maximum \n\n// valued negative. \n\nprod = prod / max_neg; \n\n} \n\n\nreturn\nprod; \n\n} \n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\na[] = {-\n1\n, -\n1\n, -\n2\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(maxProductSubset(a, n)); \n\n\n} \n} \n/* This JAVA code is contributed by Rajput-Ji*/", "complexity": "linear", "from": "CorCod", "problem": 216, "index": 216}
{"src": "\n// java program to find maximum \n// element \n\nclass\nMain \n{ \n\n// function to find the \n\n// maximum element \n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\nmax = arr[low]; \n\nint\ni; \n\nfor\n(i = low; i <= high; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n} \n\nreturn\nmax; \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n30\n, \n40\n, \n50\n, \n60\n, \n70\n, \n23\n, \n20\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"The maximum element is \"\n+ \n\nfindMaximum(arr, \n0\n, n-\n1\n)); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 217, "index": 217}
{"src": "\n// JAVA Code for Newman-Conway Sequence \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Function to find the n-th element \n\nstatic\nint\nsequence(\nint\nn) \n\n{ \n\n// Declare array to store sequence \n\nint\nf[] = \nnew\nint\n[n + \n1\n]; \n\nf[\n0\n] = \n0\n; \n\nf[\n1\n] = \n1\n; \n\nf[\n2\n] = \n1\n; \n\n\nint\ni; \n\n\nfor\n(i = \n3\n; i <= n; i++) \n\nf[i] = f[f[i - \n1\n]] + \n\nf[i - f[i - \n1\n]]; \n\n\nreturn\nf[n]; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(sequence(n)); \n\n\n} \n} \n\n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "linear", "from": "CorCod", "problem": 218, "index": 218}
{"src": "\n// Java program to reverse alternate levels of a tree \nclass\nSol \n{ \n\nstatic\nclass\nNode \n{ \n\nchar\nkey; \n\nNode left, right; \n}; \n\nstatic\nvoid\npreorder( Node root1, Node root2, \nint\nlvl) \n{ \n\n// Base cases \n\nif\n(root1 == \nnull\n|| root2==\nnull\n) \n\nreturn\n; \n\n\n// Swap subtrees if level is even \n\nif\n(lvl % \n2\n== \n0\n) \n\n{ \n\nchar\nt = root1.key; \n\nroot1.key = root2.key; \n\nroot2.key = t; \n\n} \n\n\n// Recur for left and right subtrees (Note : left of root1 \n\n// is passed and right of root2 in first call and opposite \n\n// in second call. \n\npreorder(root1.left, root2.right, lvl+\n1\n); \n\npreorder(root1.right, root2.left, lvl+\n1\n); \n} \n\n// This function calls preorder() for left and right children \n// of root \nstatic\nvoid\nreverseAlternate( Node root) \n{ \n\npreorder(root.left, root.right, \n0\n); \n} \n\n// Inorder traversal (used to print initial and \n// modified trees) \nstatic\nvoid\nprintInorder( Node root) \n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\nprintInorder(root.left); \n\nSystem.out.print( root.key + \n\" \"\n); \n\nprintInorder(root.right); \n} \n\n// A utility function to create a new node \nstatic\nNode newNode(\nint\nkey) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.left = temp.right = \nnull\n; \n\ntemp.key = (\nchar\n)key; \n\nreturn\ntemp; \n} \n\n// Driver program to test above functions \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n'a'\n); \n\nroot.left = newNode(\n'b'\n); \n\nroot.right = newNode(\n'c'\n); \n\nroot.left.left = newNode(\n'd'\n); \n\nroot.left.right = newNode(\n'e'\n); \n\nroot.right.left = newNode(\n'f'\n); \n\nroot.right.right = newNode(\n'g'\n); \n\nroot.left.left.left = newNode(\n'h'\n); \n\nroot.left.left.right = newNode(\n'i'\n); \n\nroot.left.right.left = newNode(\n'j'\n); \n\nroot.left.right.right = newNode(\n'k'\n); \n\nroot.right.left.left = newNode(\n'l'\n); \n\nroot.right.left.right = newNode(\n'm'\n); \n\nroot.right.right.left = newNode(\n'n'\n); \n\nroot.right.right.right = newNode(\n'o'\n); \n\n\nSystem.out.print(\n\"Inorder Traversal of given tree\\n\"\n); \n\nprintInorder(root); \n\n\nreverseAlternate(root); \n\n\nSystem.out.print(\n\"\\n\\nInorder Traversal of modified tree\\n\"\n); \n\nprintInorder(root); \n\n} \n} \n\n// This code is contributed by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 219, "index": 219}
{"src": "\n// Java program to find common elements in three arrays \nclass\nFindCommon \n{ \n\n// This function prints common elements in ar1 \n\nvoid\nfindCommon(\nint\nar1[], \nint\nar2[], \nint\nar3[]) \n\n{ \n\n// Initialize starting indexes for ar1[], ar2[] and ar3[] \n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n// Iterate through three arrays while all arrays have elements \n\nwhile\n(i < ar1.length && j < ar2.length && k < ar3.length) \n\n{ \n\n// If x = y and y = z, print any of them and move ahead \n\n// in all arrays \n\nif\n(ar1[i] == ar2[j] && ar2[j] == ar3[k]) \n\n{ System.out.print(ar1[i]+\n\" \"\n); i++; j++; k++; } \n\n\n// x < y \n\nelse\nif\n(ar1[i] < ar2[j]) \n\ni++; \n\n\n// y < z \n\nelse\nif\n(ar2[j] < ar3[k]) \n\nj++; \n\n\n// We reach here when x > y and z < y, i.e., z is smallest \n\nelse\n\nk++; \n\n} \n\n} \n\n\n// Driver code to test above \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nFindCommon ob = \nnew\nFindCommon(); \n\n\nint\nar1[] = {\n1\n, \n5\n, \n10\n, \n20\n, \n40\n, \n80\n}; \n\nint\nar2[] = {\n6\n, \n7\n, \n20\n, \n80\n, \n100\n}; \n\nint\nar3[] = {\n3\n, \n4\n, \n15\n, \n20\n, \n30\n, \n70\n, \n80\n, \n120\n}; \n\n\nSystem.out.print(\n\"Common elements are \"\n); \n\nob.findCommon(ar1, ar2, ar3); \n\n} \n} \n\n/*This code is contributed by Rajat Mishra */", "complexity": "linear", "from": "CorCod", "problem": 220, "index": 220}
{"src": "\n// Java Program to find the \"GFG\" subsequence \n// in the given string \n\npublic\nclass\nGFG { \n\n\nstatic\nint\nmax = \n100\n; \n\n\n// Print the count of \"GFG\" subsequence \n\n// in the string \n\nstatic\nvoid\ncountSubsequence(String s, \nint\nn) \n\n{ \n\nint\ncntG = \n0\n, cntF = \n0\n, result = \n0\n, C=\n0\n; \n\n\n// Traversing the given string \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nswitch\n(s.charAt(i)) { \n\n\n// If the character is 'G', \n\n// increment the count of 'G', \n\n// increase the result and \n\n// update the array. \n\ncase\n'G'\n: \n\ncntG++; \n\nresult+=C; \n\nbreak\n; \n\n\n// If the character is 'F', \n\n// increment the count of 'F' \n\n// and update the array. \n\ncase\n'F'\n: \n\ncntF++; \n\nC+=cntG; \n\nbreak\n; \n\n\n// Ignore other character. \n\ndefault\n: \n\ncontinue\n; \n\n} \n\n} \n\n\nSystem.out.println(result); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nString s= \n\"GFGFG\"\n; \n\nint\nn = s.length(); \n\ncountSubsequence(s, n); \n\n} \n} \n\n// This code is contributed by Sam007 ", "complexity": "linear", "from": "CorCod", "problem": 221, "index": 221}
{"src": "\n// Java implementation to divide N into \n// maximum number of segments \n// of length a, b and c \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n\n// function to find the maximum \n\n// number of segments \n\nstatic\nint\nmaximumSegments(\nint\nn, \nint\na, \n\nint\nb, \nint\nc) \n\n{ \n\n// stores the maximum number of \n\n// segments each index can have \n\nint\ndp[] = \nnew\nint\n[n + \n10\n]; \n\n\n// initialize with -1 \n\nArrays.fill(dp, -\n1\n); \n\n\n// 0th index will have 0 segments \n\n// base case \n\ndp[\n0\n] = \n0\n; \n\n\n// traverse for all possible \n\n// segments till n \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(dp[i] != -\n1\n) \n\n{ \n\n\n// conditions \n\nif\n(i + a <= n ) \n//avoid buffer overflow \n\ndp[i + a] = Math.max(dp[i] + \n1\n, \n\ndp[i + a]); \n\n\nif\n(i + b <= n ) \n//avoid buffer overflow \n\ndp[i + b] = Math.max(dp[i] + \n1\n, \n\ndp[i + b]); \n\n\nif\n(i + c <= n ) \n//avoid buffer overflow \n\ndp[i + c] = Math.max(dp[i] + \n1\n, \n\ndp[i + c]); \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nn = \n7\n, a = \n5\n, b = \n2\n, c = \n5\n; \n\nSystem.out.print(maximumSegments(n, a, b, c)); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "linear", "from": "CorCod", "problem": 222, "index": 222}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint num=sc.nextInt();\n\t\tlong sum1=0,sum2=0;\n\t\tfor(int i=0;i<num*2;i++){\n\t\t\tsum1+=sc.nextInt();\n\t\t\tsum2+=sc.nextInt();\n\t\t}\n\t\tSystem.out.println(sum1/num+\" \"+sum2/num);\n\t}\n}\n\t\t\t\t  \t\t\t \t\t  \t \t\t\t \t\t\t\t \t", "complexity": "linear", "from": "CorCod", "problem": 223, "index": 223}
{"src": "\n// Recursive Java program to search x in array \nclass\nTest \n{ \n\nstatic\nint\narr[] = {\n12\n, \n34\n, \n54\n, \n2\n, \n3\n}; \n\n\n/* Recursive Method to search x in arr[l..r] */\n\nstatic\nint\nrecSearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r < l) \n\nreturn\n-\n1\n; \n\nif\n(arr[l] == x) \n\nreturn\nl; \n\nif\n(arr[r] == x) \n\nreturn\nr; \n\nreturn\nrecSearch(arr, l+\n1\n, r-\n1\n, x); \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nx = \n3\n; \n\n\n//Method call to find x \n\nint\nindex = recSearch(arr, \n0\n, arr.length-\n1\n, x); \n\nif\n(index != -\n1\n) \n\nSystem.out.println(\n\"Element \"\n+ x + \n\" is present at index \"\n+ \n\nindex); \n\nelse\n\nSystem.out.println(\n\"Element \"\n+ x + \n\" is not present\"\n); \n\n} \n\n} ", "complexity": "linear", "from": "CorCod", "problem": 224, "index": 224}
{"src": "import java.util.*;\n\npublic class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        char c[]=new char[n];\n        Arrays.fill(c,'o');\n        int x=1,y=1,z;\n        while(y<=n)\n        {\n            c[y-1]='O';\n            z=x+y;\n            x=y;\n            y=z;\n        }\n        String ans=new String(c);\n        System.out.println(ans);\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 225, "index": 225}
{"src": "\n// Java code to find second largest element in BST \n\n// A binary tree node \nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n// Root of BST \n\nNode root; \n\n\n// Constructor \n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n// function to insert new nodes \n\npublic\nvoid\ninsert(\nint\ndata) \n\n{ \n\nthis\n.root = \nthis\n.insertRec(\nthis\n.root, data); \n\n} \n\n\n/* A utility function to insert a new node with given \n\nkey in BST */\n\nNode insertRec(Node node, \nint\ndata) \n\n{ \n\n/* If the tree is empty, return a new node */\n\nif\n(node == \nnull\n) { \n\nthis\n.root = \nnew\nNode(data); \n\nreturn\nthis\n.root; \n\n} \n\n\n/* Otherwise, recur down the tree */\n\nif\n(data < node.data) { \n\nnode.left = \nthis\n.insertRec(node.left, data); \n\n} \nelse\n{ \n\nnode.right = \nthis\n.insertRec(node.right, data); \n\n} \n\nreturn\nnode; \n\n} \n\n\n// class that stores the value of count \n\npublic\nclass\ncount { \n\nint\nc = \n0\n; \n\n} \n\n\n// Function to find 2nd largest element \n\nvoid\nsecondLargestUtil(Node node, count C) \n\n{ \n\n// Base cases, the second condition is important to \n\n// avoid unnecessary recursive calls \n\nif\n(node == \nnull\n|| C.c >= \n2\n) \n\nreturn\n; \n\n\n// Follow reverse inorder traversal so that the \n\n// largest element is visited first \n\nthis\n.secondLargestUtil(node.right, C); \n\n\n// Increment count of visited nodes \n\nC.c++; \n\n\n// If c becomes k now, then this is the 2nd largest \n\nif\n(C.c == \n2\n) { \n\nSystem.out.print(\n\"2nd largest element is \"\n+ \n\nnode.data); \n\nreturn\n; \n\n} \n\n\n// Recur for left subtree \n\nthis\n.secondLargestUtil(node.left, C); \n\n} \n\n\n// Function to find 2nd largest element \n\nvoid\nsecondLargest(Node node) \n\n{ \n\n// object of class count \n\ncount C = \nnew\ncount(); \n\nthis\n.secondLargestUtil(\nthis\n.root, C); \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n/* Let us create following BST \n\n50 \n\n/ \\ \n\n30 70 \n\n/ \\ / \\ \n\n20 40 60 80 */\n\n\ntree.insert(\n50\n); \n\ntree.insert(\n30\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n40\n); \n\ntree.insert(\n70\n); \n\ntree.insert(\n60\n); \n\ntree.insert(\n80\n); \n\n\ntree.secondLargest(tree.root); \n\n} \n} \n\n// This code is contributed by Kamal Rawal ", "complexity": "linear", "from": "CorCod", "problem": 226, "index": 226}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine());\n        StringTokenizer st;\n        for(int z=0;z<t;z++){\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            st = new StringTokenizer(br.readLine());\n            int min=1;\n            int max=1;\n            for(int i=0;i<n;i++){\n                int k = Integer.parseInt(st.nextToken());\n                if(max<k){\n                    min = max;\n                    max = k;\n                }else if(min<k){\n                    min = k;\n                }\n            }\n            int res = Math.min(n-2,min-1);\n            System.out.println(res);\n        }\n    }\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 227, "index": 227}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CF_1029E_Tree_with_Small_Distances {\n\tstatic ArrayList<Integer> adj[];\n\tstatic int dist[];\n\tstatic boolean visitParent[];\n\tstatic int ans=0;\n public static void main(String[] args) throws IOException {\n\tScanner sc = new Scanner(System.in);\n\tint n  =sc.nextInt();\n\tadj=new ArrayList[n+1];\n\tdist = new int[n+1];\n\tvisitParent = new boolean[n+1];\n\tfor(int i=0;i<=n;i++) adj[i]=new ArrayList<Integer>();\n\tint max=0;\n\t//first contribution\n\tfor(int i=1;i<n;i++){\n\t\tint u = sc.nextInt(),v=sc.nextInt();\n\t\tadj[u].add(v);\n\t\tadj[v].add(u);\n\t}\n\tdist[1]=0;\n\tdfs(1,1);\n System.out.println(ans);\n \n \n }\nprivate static void dfs(int i , int j) {\n\t// TODO Auto-generated method stub\n\tboolean f = false;\n\tfor(int k=0;k<adj[i].size();k++){\n\t\tint x = adj[i].get(k);\n\t\tif(x!=j){\n\t\t\tdist[x]=dist[i]+1;\n\t\t\tdfs(x,i);\n\t\t\tif(visitParent[x])\n\t\t\t\tf=true;\n\t\t}\n\t}\n\t//System.out.println(Arrays.toString(dist));\n\tif(dist[i]>2&&!visitParent[j]&&!f&&!visitParent[i]){\n\t\tvisitParent[j]=true;\n\t\tans++;\n\t\tfor(int v=0;v<adj[i].size();v++){\n\t\t\t\n\t\t}\n\t}\n\t\n}\nstatic class Scanner \n{\n    StringTokenizer st;\n    BufferedReader br;\n\n    public Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}\n\n    public String next() throws IOException \n    {\n        while (st == null || !st.hasMoreTokens()) \n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n    \n    public double nextDouble() throws IOException\n    {\n        String x = next();\n        StringBuilder sb = new StringBuilder(\"0\");\n        double res = 0, f = 1;\n        boolean dec = false, neg = false;\n        int start = 0;\n        if(x.charAt(0) == '-')\n        {\n            neg = true;\n            start++;\n        }\n        for(int i = start; i < x.length(); i++)\n            if(x.charAt(i) == '.')\n            {\n                res = Long.parseLong(sb.toString());\n                sb = new StringBuilder(\"0\");\n                dec = true;\n            }\n            else\n            {\n                sb.append(x.charAt(i));\n                if(dec)\n                    f *= 10;\n            }\n        res += Long.parseLong(sb.toString()) / f;\n        return res * (neg?-1:1);\n    }\n\n\n    public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n    public long nextLong() throws IOException {return Long.parseLong(next());}\n\n    public String nextLine() throws IOException {return br.readLine();}\n\n    public boolean ready() throws IOException {return br.ready(); }\n\n\n}\n\t\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 228, "index": 228}
{"src": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n=sc.nextInt();\n\t\t\tString s=sc.next();\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<s.length();i++) {\n\t\t\t\tif(s.charAt(i)=='+') {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t\tif(s.charAt(i)=='-'&&sum!=0) {\n\t\t\t\t\tsum--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 229, "index": 229}
{"src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }\n    static boolean valid(int i,int j,int r,int c)\n    {\n    if(i<r && i>=0 && j<c && j>=0)\n    return true;\n    else\n    return false;\n    }*/\n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 230, "index": 230}
{"src": "\n// Java program to find maximum number to be removed \n// to convert a tree into forest containg trees of \n// even number of nodes \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\nstatic\nint\nN = \n12\n,ans; \n\n\nstatic\nVector<Vector<Integer>> tree=\nnew\nVector<Vector<Integer>>(); \n\n\n// Return the number of nodes of subtree having \n\n// node as a root. \n\nstatic\nint\ndfs( \nint\nvisit[], \nint\nnode) \n\n{ \n\nint\nnum = \n0\n, temp = \n0\n; \n\n\n// Mark node as visited. \n\nvisit[node] = \n1\n; \n\n\n// Traverse the adjacency list to find non- \n\n// visited node. \n\nfor\n(\nint\ni = \n0\n; i < tree.get(node).size(); i++) \n\n{ \n\nif\n(visit[tree.get(node).get(i)] == \n0\n) \n\n{ \n\n// Finding number of nodes of the subtree \n\n// of a subtree. \n\ntemp = dfs( visit, tree.get(node).get(i)); \n\n\n// If nodes are even, increment number of \n\n// edges to removed. \n\n// Else leave the node as child of subtree. \n\nif\n(temp%\n2\n!=\n0\n) \n\nnum += temp; \n\nelse\n\nans++; \n\n} \n\n} \n\n\nreturn\nnum+\n1\n; \n\n} \n\n\n// Return the maxium number of edge to remove \n\n// to make forest. \n\nstatic\nint\nminEdge( \nint\nn) \n\n{ \n\nint\nvisit[] = \nnew\nint\n[n+\n2\n]; \n\nans = \n0\n; \n\n\ndfs( visit, \n1\n); \n\n\nreturn\nans; \n\n} \n\n\n// Driven Program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n; \n\n\n//set the size of vector \n\nfor\n(\nint\ni = \n0\n; i < n + \n2\n;i++) \n\ntree.add(\nnew\nVector<Integer>()); \n\n\ntree.get(\n1\n).add(\n3\n); \n\ntree.get(\n3\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n6\n); \n\ntree.get(\n6\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n2\n); \n\ntree.get(\n2\n).add(\n1\n); \n\n\ntree.get(\n3\n).add(\n4\n); \n\ntree.get(\n4\n).add(\n3\n); \n\n\ntree.get(\n6\n).add(\n8\n); \n\ntree.get(\n8\n).add(\n6\n); \n\n\ntree.get(\n2\n).add(\n7\n); \n\ntree.get(\n7\n).add(\n2\n); \n\n\ntree.get(\n2\n).add(\n5\n); \n\ntree.get(\n5\n).add(\n2\n); \n\n\ntree.get(\n4\n).add(\n9\n); \n\ntree.get(\n9\n).add(\n4\n); \n\n\ntree.get(\n4\n).add(\n10\n); \n\ntree.get(\n10\n).add(\n4\n); \n\n\nSystem.out.println( minEdge( n)); \n\n} \n} \n\n// This code is contributed by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 231, "index": 231}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        int h=0,t=n-1,answ=0;\n        while (h<n&&t>=0){\n            if(a[h]<=m){\n                answ++;\n                h++;\n            }else if(a[t]<=m){\n                t--;\n                answ++;\n            }else{\n                break;\n            }\n        }\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "complexity": "linear", "from": "CorCod", "problem": 232, "index": 232}
{"src": "\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner (System.in);\n    public static void main(String[] args) {\n    \tint n = sc.nextInt();\n    \tint k = sc.nextInt();\n    \tchar str[][] = new char[5][n];\n        for(int i = 0;i < 4;i ++){\n        \tfor(int j = 0;j < n;j ++)\n                str[i][j] = '.';\n        }\n        if(k % 2 == 0){\n            k /= 2;\n            for(int i = 1;i <= 2;i++){\n                for(int j = 1;j <= k;j++)\n                     str[i][j] = '#'; \n            }\n        }\n        else{\n            str[1][n / 2] = '#';\n            if(k != 1){\n                int tmp = n / 2;\n                if(k <= n - 2){\n                    for(int i = 1;i<= (k - 1) / 2;i++){\n                        str[1][i] = '#';\n                        str[1][n - 1 - i] = '#';\n                    }\n                }\n                else{\n                    for(int i = 1;i <= n - 2;i++) str[1][i] = '#';\n                    k -= n - 2;\n                    for(int i = 1;i <= k/2;i++){\n                        str[2][i] = '#';\n                        str[2][n - 1 - i]='#';\n                    }\n                }\n     \n            }\n        }\n        System.out.println(\"YES\");\n        for(int i = 0;i < 4;i ++){\n        \tSystem.out.println(str[i]);\n        }\n    }\n }", "complexity": "linear", "from": "CorCod", "problem": 233, "index": 233}
{"src": "import java.util.*;\npublic class Test { public static void main(String[] args)\n{\nScanner sc = new Scanner(System.in);\nint n= sc.nextInt();\nint x= (int)Math.sqrt(n) ;\nint a[] = new int[n+5];\nfor(int i=1,o=n,j;i<=n;i+=x)\nfor(j=(int)Math.min(i+x-1,n);j>=i;a[j--]=o--);\nfor(int i=1;i<=n;i++)System.out.print(a[i]+\" \");\nSystem.out.println();\n\n\n} \n}", "complexity": "linear", "from": "CorCod", "problem": 234, "index": 234}
{"src": "import java.util.Scanner;\n\npublic class ChainReaction {\n\t\n\tpublic static void main(String [] args) {\n\t\tScanner kb = new Scanner(System.in);\n\t\tint num = kb.nextInt();\n\t\t\n\t\tint[] beacons = new int[1000002];\n\t\tfor (int i=0; i<num; i++) {\n\t\t\tbeacons[kb.nextInt()] = kb.nextInt();\n\t\t}\n\t\t\n\t\tint [] dp = new int[1000002];\n\t\tint max = 0;\n\t\tif (beacons[0] != 0)\n\t\t\tdp[0] = 1;\n\t\t\n\t\tfor (int i=1; i<dp.length; i++) {\n\t\t\tif (beacons[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} else {\n\t\t\t\tint index = i-1-beacons[i];\n\t\t\t\tif (index<0)\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\telse\n\t\t\t\t\tdp[i] = 1 + dp[index];\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t\t//if (i<11)\n\t\t\t\t//System.out.println(i +\" is \"+dp[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(num-max);\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 235, "index": 235}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\t\n\n\n\n", "complexity": "linear", "from": "CorCod", "problem": 236, "index": 236}
{"src": "\n// Java program to illustrate \n// the number of ways to represent \n// N as sum of 1, 3 and 4. \n\nclass\nGFG { \n\n\n// Function to count the \n\n// number of ways to represent \n\n// n as sum of 1, 3 and 4 \n\nstatic\nint\ncountWays(\nint\nn) \n\n{ \n\nint\nDP[] = \nnew\nint\n[n + \n1\n]; \n\n\n// base cases \n\nDP[\n0\n] = DP[\n1\n] = DP[\n2\n] = \n1\n; \n\nDP[\n3\n] = \n2\n; \n\n\n// iterate for all values from 4 to n \n\nfor\n(\nint\ni = \n4\n; i <= n; i++) \n\nDP[i] = DP[i - \n1\n] + DP[i - \n3\n] \n\n+ DP[i - \n4\n]; \n\n\nreturn\nDP[n]; \n\n} \n\n\n// driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(countWays(n)); \n\n} \n} \n\n// This code is contributed \n// by prerna saini. ", "complexity": "linear", "from": "CorCod", "problem": 237, "index": 237}
{"src": "import java.util.Scanner;\n\npublic class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tint pos[] = new int[num];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tint position = sc.nextInt();\n\t\t\tbeacon[position] = sc.nextInt();\n\t\t\tpos[i] = position;\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 1;\n\t\tif (beacon[0] != 0)\n\t\t\tdp[0] = 1;\n\t\t\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint j = i - beacon[i] - 1;\n\t\t\t\tif (j < 0) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 238, "index": 238}
{"src": "\nclass\nMergeArrays \n{ \n\n/* Function to move m elements at the end of array mPlusN[] */\n\nvoid\nmoveToEnd(\nint\nmPlusN[], \nint\nsize) \n\n{ \n\nint\ni, j = size - \n1\n; \n\nfor\n(i = size - \n1\n; i >= \n0\n; i--) \n\n{ \n\nif\n(mPlusN[i] != -\n1\n) \n\n{ \n\nmPlusN[j] = mPlusN[i]; \n\nj--; \n\n} \n\n} \n\n} \n\n\n/* Merges array N[] of size n into array mPlusN[] \n\nof size m+n*/\n\nvoid\nmerge(\nint\nmPlusN[], \nint\nN[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = n; \n\n\n/* Current index of i/p part of mPlusN[]*/\n\nint\nj = \n0\n; \n\n\n/* Current index of N[]*/\n\nint\nk = \n0\n; \n\n\n/* Current index of output mPlusN[]*/\n\nwhile\n(k < (m + n)) \n\n{ \n\n/* Take an element from mPlusN[] if \n\na) value of the picked element is smaller and we have \n\nnot reached end of it \n\nb) We have reached end of N[] */\n\nif\n((i < (m + n) && mPlusN[i] <= N[j]) || (j == n)) \n\n{ \n\nmPlusN[k] = mPlusN[i]; \n\nk++; \n\ni++; \n\n} \n\nelse\n// Otherwise take element from N[] \n\n{ \n\nmPlusN[k] = N[j]; \n\nk++; \n\nj++; \n\n} \n\n} \n\n} \n\n\n/* Utility that prints out an array on a line */\n\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMergeArrays mergearray = \nnew\nMergeArrays(); \n\n\n/* Initialize arrays */\n\nint\nmPlusN[] = {\n2\n, \n8\n, -\n1\n, -\n1\n, -\n1\n, \n13\n, -\n1\n, \n15\n, \n20\n}; \n\nint\nN[] = {\n5\n, \n7\n, \n9\n, \n25\n}; \n\nint\nn = N.length; \n\nint\nm = mPlusN.length - n; \n\n\n/*Move the m elements at the end of mPlusN*/\n\nmergearray.moveToEnd(mPlusN, m + n); \n\n\n/*Merge N[] into mPlusN[] */\n\nmergearray.merge(mPlusN, N, m, n); \n\n\n/* Print the resultant mPlusN */\n\nmergearray.printArray(mPlusN, m + n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 239, "index": 239}
{"src": "\nclass\nProfit \n{ \n\n// Returns maximum profit with two transactions on a given \n\n// list of stock prices, price[0..n-1] \n\nstatic\nint\nmaxProfit(\nint\nprice[], \nint\nn) \n\n{ \n\n// Create profit array and initialize it as 0 \n\nint\nprofit[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nprofit[i] = \n0\n; \n\n\n/* Get the maximum profit with only one transaction \n\nallowed. After this loop, profit[i] contains maximum \n\nprofit from price[i..n-1] using at most one trans. */\n\nint\nmax_price = price[n-\n1\n]; \n\nfor\n(\nint\ni=n-\n2\n;i>=\n0\n;i--) \n\n{ \n\n// max_price has maximum of price[i..n-1] \n\nif\n(price[i] > max_price) \n\nmax_price = price[i]; \n\n\n// we can get profit[i] by taking maximum of: \n\n// a) previous maximum, i.e., profit[i+1] \n\n// b) profit by buying at price[i] and selling at \n\n// max_price \n\nprofit[i] = Math.max(profit[i+\n1\n], max_price-price[i]); \n\n} \n\n\n/* Get the maximum profit with two transactions allowed \n\nAfter this loop, profit[n-1] contains the result */\n\nint\nmin_price = price[\n0\n]; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\n// min_price is minimum price in price[0..i] \n\nif\n(price[i] < min_price) \n\nmin_price = price[i]; \n\n\n// Maximum profit is maximum of: \n\n// a) previous maximum, i.e., profit[i-1] \n\n// b) (Buy, Sell) at (min_price, price[i]) and add \n\n// profit of other trans. stored in profit[i] \n\nprofit[i] = Math.max(profit[i-\n1\n], profit[i] + \n\n(price[i]-min_price) ); \n\n} \n\nint\nresult = profit[n-\n1\n]; \n\nreturn\nresult; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nprice[] = {\n2\n, \n30\n, \n15\n, \n10\n, \n8\n, \n25\n, \n80\n}; \n\nint\nn = price.length; \n\nSystem.out.println(\n\"Maximum Profit = \"\n+ maxProfit(price, n)); \n\n} \n\n}\n/* This code is contributed by Rajat Mishra */", "complexity": "linear", "from": "CorCod", "problem": 240, "index": 240}
{"src": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint[] cnt = new int[101];\n\t\tcnt[1] = 1;\n\t\tfor(int i = 2; i <= 100; ++i) {\n\t\t\tcnt[i] = cnt[i-1] + 4 * (i - 1);\n\t\t}\n\t\tint n = in.nextInt();\n\t\tSystem.out.println( cnt[n] );\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic int maxHit(ArrayList<Integer> a, int p, int i) {\n\t\tif(i == a.size())\n\t\t\treturn 0;\n\t\tif(memo[p][i] != -1)\n\t\t\treturn memo[p][i];\n\t\tint ret = maxHit(a, p, i + 1);\n\t\tif(p == -1 || a.get(p) < a.get(i)) {\n\t\t\tret = Math.max(ret, maxHit(a, i, i + 1) );\n\t\t}\n\t\treturn memo[p][i] = ret;\n\t}\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "complexity": "linear", "from": "CorCod", "problem": 241, "index": 241}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tstatic ArrayList<Integer> ar;\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tif(n <= 2)\n\t\t\tans.append(\"No\");\n\t\telse if(n == 4) {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tans.append(\"1 2\\n\");\n\t\t\tans.append(\"3 1 3 4\\n\");\n\t\t}\n\t\telse  {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tif(n % 2 == 1) {\n\t\t\t\tint a = (n+1)/2;\n\t\t\t\tans.append(\"1 \");\n\t\t\t\tans.append(a);\n\t\t\t\tans.append(\"\\n\");\n\t\t\t\tans.append(n-1);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+1; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a = n/2;\n\t\t\t\tans.append(\"2 \");\n\t\t\t\tans.append(a + \" \");\n\t\t\t\tans.append(a+1 + \" \\n\");\n\t\t\t\tans.append(n-2);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+2; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 242, "index": 242}
{"src": "import java.util.Scanner;\n\npublic class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tint pos[] = new int[num];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tint position = sc.nextInt();\n\t\t\tbeacon[position] = sc.nextInt();\n\t\t\tpos[i] = position;\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 0;\n\t\tif (beacon[0] != 0)\n\t\t\tdp[0] = 1;\n\t\t\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint j = i - beacon[i] - 1;\n\t\t\t\tif (j < 0) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 243, "index": 243}
{"src": "import java.io.*;\n\n\npublic class First {\n    StreamTokenizer in;\n    PrintWriter out;\n\n    int nextInt() throws IOException {\n        in.nextToken();\n        return (int)in.nval;\n    }\n\n    long nextLong() throws IOException {\n        in.nextToken();\n        return (long) in.nval;\n    }\n\n    String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n\n\n    void run() throws IOException {\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    void solve() throws IOException {\n        int n = nextInt(), k = nextInt(), sum = 0, count = 0;\n        String str = nextString();\n        char[] arr = str.toCharArray();\n        boolean[] bool = new boolean[26];\n        for(char ch: arr){\n            bool[((int)ch)-97] = true;\n        }\n        for(int i = 0; i < 26; i++){\n            if(bool[i]){\n                sum += i+1;\n                count++;\n                i += 1;\n            }\n            if(count == k) break;\n        }\n        if(count == k) out.println(sum);\n        else out.println(-1);\n    }\n\n    public static void main(String[] args) throws IOException {\n        new First().run();\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 244, "index": 244}
{"src": "\n// A Simple Java program to find \n// minimum average subarray \n\nclass\nTest { \n\n\nstatic\nint\narr[] = \nnew\nint\n[] { \n3\n, \n7\n, \n90\n, \n20\n, \n10\n, \n50\n, \n40\n}; \n\n\n// Prints beginning and ending indexes of subarray \n\n// of size k with minimum average \n\nstatic\nvoid\nfindMinAvgSubarray(\nint\nn, \nint\nk) \n\n{ \n\n// k must be smaller than or equal to n \n\nif\n(n < k) \n\nreturn\n; \n\n\n// Initialize beginning index of result \n\nint\nres_index = \n0\n; \n\n\n// Compute sum of first subarray of size k \n\nint\ncurr_sum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\ncurr_sum += arr[i]; \n\n\n// Initialize minimum sum as current sum \n\nint\nmin_sum = curr_sum; \n\n\n// Traverse from (k+1)'th element to n'th element \n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\n// Add current item and remove first \n\n// item of previous subarray \n\ncurr_sum += arr[i] - arr[i - k]; \n\n\n// Update result if needed \n\nif\n(curr_sum < min_sum) { \n\nmin_sum = curr_sum; \n\nres_index = (i - k + \n1\n); \n\n} \n\n} \n\n\nSystem.out.println(\n\"Subarray between [\"\n+ \n\nres_index + \n\", \"\n+ (res_index + k - \n1\n) + \n\n\"] has minimum average\"\n); \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nk = \n3\n; \n// Subarray size \n\nfindMinAvgSubarray(arr.length, k); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 245, "index": 245}
{"src": "\n// Java program to count ways to build street \n// under given constraints \npublic\nclass\nGFG { \n\n// function to count ways of building \n// a street of n rows \n\nstatic\nlong\ncountWays(\nint\nn) { \n\nlong\ndp[][] = \nnew\nlong\n[\n2\n][n + \n1\n]; \n\n\n// base case \n\ndp[\n0\n][\n1\n] = \n1\n; \n\ndp[\n1\n][\n1\n] = \n2\n; \n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\n\n// ways of building houses in both \n\n// the spots of ith row \n\ndp[\n0\n][i] = dp[\n0\n][i - \n1\n] + dp[\n1\n][i - \n1\n]; \n\n\n// ways of building an office in one of \n\n// the two spots of ith row \n\ndp[\n1\n][i] = dp[\n0\n][i - \n1\n] * \n2\n+ dp[\n1\n][i - \n1\n]; \n\n} \n\n\n// total ways for n rows \n\nreturn\ndp[\n0\n][n] + dp[\n1\n][n]; \n\n} \n\n// driver program for checking above function \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nint\nn = \n5\n; \n\nSystem.out.print(\n\"Total no of ways with n = \"\n+ n \n\n+ \n\" are: \"\n+ countWays(n)); \n\n} \n\n} \n\n/*This code is contributed by PrinciRaj1992*/", "complexity": "linear", "from": "CorCod", "problem": 246, "index": 246}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class LightItUp {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t StringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint m = Integer.parseInt(st.nextToken());\n\t\tint previous = 0;\n\t\tint array[] = new int[n+1];\n\t\tint answer = 0;\n\t\t\n\t\tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarray[i] = Integer.parseInt(st1.nextToken());\n\t\t\tif(i % 2 == 0){\n\t\t\t\tanswer += (array[i] - previous);\n\t\t\t}\n\t\t\tprevious = array[i];\n\t\t}\n\t\t\n\t\tif(n % 2 == 0){\n\t\t\tanswer += (m - previous);\n\t\t}\n\t\tprevious = m;\n\t\tint max = Integer.MAX_VALUE;\n\t\t\n\t\twhile(n-- != 0){\n\t\t\tint temp = array[n];\n\t\t\tif(n%2 == 0){\n\t\t\t\tarray[n] = array[n+1] - (previous - array[n]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarray[n] = array[n+1] + (previous - array[n]);\n\t\t\t}\n\t\t\tprevious = temp;\n\t\t\tmax = Math.min(max, array[n]);\n\t\t}\n\t\tif(max>=-1){\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(answer - (max+1));\n\t\t}\n\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 247, "index": 247}
{"src": "\n// Java program to write characters in \n// minimum time by inserting, removing \n// and copying operation \n\npublic\nclass\nGFG{ \n\n\n// method returns minimum time to write \n\n// 'N' characters \n\nstatic\nint\nminTimeForWritingChars(\nint\nN, \nint\ninsert, \n\nint\nremove, \nint\ncopy) \n\n{ \n\nif\n(N == \n0\n) \n\nreturn\n0\n; \n\nif\n(N == \n1\n) \n\nreturn\ninsert; \n\n\n// declare dp array and initialize with zero \n\nint\ndp[] = \nnew\nint\n[N + \n1\n]; \n\n\n\n// loop for 'N' number of times \n\nfor\n(\nint\ni = \n1\n; i <= N; i++) \n\n{ \n\n/* if current char count is even then \n\nchoose minimum from result for (i-1) \n\nchars and time for insertion and \n\nresult for half of chars and time \n\nfor copy */\n\nif\n(i % \n2\n== \n0\n) \n\ndp[i] = Math.min(dp[i-\n1\n] + insert, dp[i/\n2\n] + copy); \n\n\n/* if current char count is odd then \n\nchoose minimum from \n\nresult for (i-1) chars and time for \n\ninsertion and \n\nresult for half of chars and time for \n\ncopy and one extra character deletion*/\n\nelse\n\ndp[i] = Math.min(dp[i-\n1\n] + insert, \n\ndp[(i+\n1\n)/\n2\n] + copy + remove); \n\n} \n\nreturn\ndp[N]; \n\n} \n\n\n// Driver code to test above methods \n\npublic\nstatic\nvoid\nmain(String []args) \n\n{ \n\nint\nN = \n9\n; \n\nint\ninsert = \n1\n, remove = \n2\n, copy = \n1\n; \n\nSystem.out.println(minTimeForWritingChars(N, insert,remove, copy)); \n\n} \n\n// This code is contributed by Ryuga \n} ", "complexity": "linear", "from": "CorCod", "problem": 248, "index": 248}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(a));\n\n\t\tsc.close();\n\t}\n\n\tstatic String solve(int[] a) {\n\t\tif (a.length == 1 || (a.length == 2 && a[0] == a[1])) {\n\t\t\treturn \"-1\";\n\t\t}\n\n\t\tint sum = Arrays.stream(a).sum();\n\t\tfor (int i = 0;; i++) {\n\t\t\tif (a[i] * 2 != sum) {\n\t\t\t\treturn String.format(\"1\\n%d\", i + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 249, "index": 249}
{"src": "import java.math.BigInteger;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\npublic class Practice {\n\t\n\t   \n\n\t\tpublic static void main(String []args)\n\t\t{\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\t\n\t\t\t\n\t\t\tString s=sc.nextLine();\n\t\t\tint n=0;\n\t\t\tint m=0;\n\t\t\t//System.out.println(5%0);\n\t\t\t\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)=='-')\n\t\t\t\t{\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif(n%m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t}\n\n}", "complexity": "linear", "from": "CorCod", "problem": 250, "index": 250}
{"src": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class PlayingPiano {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\t int n = scanner.nextInt();\n\t\t \n\t\t List<Integer> as = new LinkedList<>();\n\t\t int[] as2 = new int[n];\n\t\t \n\t\t for (int i = 0; i < n; i++) {\n\t\t\t int a = scanner.nextInt();\n\t\t\t as.add(a);\n\t\t\t as2[i] = a;\n\t\t }\n\t\t \n\t\t //System.out.println(solve(as));\n\t\t System.out.println(solve2(as2));\n\t\t\n\t\tscanner.close();\n\t}\n\n\tpublic static String solve(List<Integer> as) {\n\t\tList<Integer> fingers = new LinkedList<>();\n\t\t fingers.add(1);\n\t\t fingers.add(2);\n\t\t fingers.add(3);\n\t\t fingers.add(4);\n\t\t fingers.add(5);\n\t\t \n\t\t List<Integer> solution = assign(as, fingers, fingers);\n\t\t if (solution == null) {\n\t\t\t return \"-1\";\n\t\t } else {\n\t\t\t StringBuilder sb = new StringBuilder();\n\t\t\t for (int b : solution) {\n\t\t\t\t sb.append(b);\n\t\t\t\t sb.append(\" \");\n\t\t\t }\n\t\t\t sb.deleteCharAt(sb.length() - 1);\n\t\t\t return sb.toString();\n\t\t }\n\t}\n\n\tprivate static List<Integer> assign(List<Integer> as, List<Integer> fingers, List<Integer> allFingers) {\n\t\t// if fingers is empty return null\n\t\tif (fingers.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// if as size is one then return first element in fingers\n\t\tif (as.size() == 1) {\n\t\t\tList<Integer> ret = new LinkedList<>();\n\t\t\tret.add(fingers.get(0));\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\t// get sublist\n\t\tList<Integer> subList = as.subList(1, as.size());\n\t\t\n\t\tfor (int i = 0; i < fingers.size(); i++) {\n\t\t\t// recursively call with sublist and limited list of fingers\n\t\t\tList<Integer> subFingers = new LinkedList<>();\n\t\t\tfinal int j = i;\n\t\t\tif (as.get(0) < as.get(1)) {\n\t\t\t\t subFingers = allFingers.stream()\n\t\t\t\t\t    .filter(p -> p > fingers.get(j)).collect(Collectors.toList());\n\t\t\t} else if (as.get(0) > as.get(1)) {\n\t\t\t\tsubFingers = allFingers.stream()\n\t\t\t\t\t    .filter(p -> p < fingers.get(j)).collect(Collectors.toList());\n\t\t\t} else {\n\t\t\t\tsubFingers = allFingers.stream()\n\t\t\t\t\t    .filter(p -> p != fingers.get(j)).collect(Collectors.toList());\n\t\t\t}\n\t\t\t\n\t\t\tList<Integer> ret = assign(subList, subFingers, allFingers);\n\t\t\tif (ret != null) {\n\t\t\t\tList<Integer> solution = new LinkedList<>();\n\t\t\t\tsolution.add(fingers.get(i));\n\t\t\t\tsolution.addAll(ret);\n\t\t\t\treturn solution;\n\t\t\t}\n\t\t\t\n\t\t\t// if return is null, then return null, else return an array\n\t\t}\n\t\treturn null;\n\t\t\n\t}\n\t\n\tpublic static String solve2(int[] as) {\n\t\tint[] ret = new int[as.length];\n\t\t\n\t\tif (as.length == 1) return \"1\";\n\t\t\n\t\tif (as[0] < as[1]) ret[0] = 1;\n\t\telse if (as[0] == as[1])\tret[0] = 3;\n\t\telse ret[0] = 5;\n\t\t\n\t\tfor (int i = 1; i < as.length - 1; i++) {\n\t\t\tif (as[i-1] < as[i] && ret[i-1] == 5) return \"-1\";\n\t\t\tif (as[i-1] > as[i] && ret[i-1] == 1) return \"-1\";\n\t\t\t\n\t\t\tif (as[i-1] < as[i] && as[i] < as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] + 1;\n\t\t\t} else if (as[i-1] == as[i] && as[i] < as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] == 1 ? 2 : 1;\n\t\t\t} else if (as[i-1] > as[i] && as[i] < as[i+1]) {\n\t\t\t\tret[i] = 1;\n\t\t\t} else if (as[i-1] < as[i] && as[i] == as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] + 1;\n\t\t\t} else if (as[i-1] == as[i] && as[i] == as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] == 4 ? 2 : 4;\n\t\t\t} else if (as[i-1] > as[i] && as[i] == as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] == 2 ? 1 : 2;\n\t\t\t} else if (as[i-1] < as[i] && as[i] > as[i+1]) {\n\t\t\t\tret[i] = 5;\n\t\t\t} else if (as[i-1] == as[i] && as[i] > as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] == 5 ? 4 : 5;\n\t\t\t} else if (as[i-1] > as[i] && as[i] > as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (as.length > 1) {\n\t\t\tif (as[as.length - 1] > as[as.length - 2]) {\n\t\t\t\tif (ret[as.length - 2] == 5)\n\t\t\t\t\treturn \"-1\";\n\t\t\t\tret[as.length - 1] = 5;\n\t\t\t} else if (as[as.length - 1] == as[as.length - 2]) {\n\t\t\t\tret[as.length - 1] = ret[as.length - 2] == 5 ? 4 : 5;\n\t\t\t} else {\n\t\t\t\tif (ret[as.length - 2] == 1)\n\t\t\t\t\treturn \"-1\";\n\t\t\t\tret[as.length - 1] = 1;\n\t\t\t} \n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\t for (int b : ret) {\n\t\t\t sb.append(b);\n\t\t\t sb.append(\" \");\n\t\t }\n\t\t sb.deleteCharAt(sb.length() - 1);\n\t\t return sb.toString();\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 251, "index": 251}
{"src": "\n// Java program to find remaining \n// chocolates after k iterations \nclass\nGFG \n{ \n// A O(n) C++ program to count \n// even length binary sequences \n// such that the sum of first \n// and second half bits is same \n\n// Returns the count of \n// even length sequences \nstatic\nint\ncountSeq(\nint\nn) \n{ \n\nint\nnCr = \n1\n, res = \n1\n; \n\n\n// Calculate SUM ((nCr)^2) \n\nfor\n(\nint\nr = \n1\n; r <= n ; r++) \n\n{ \n\n// Compute nCr using nC(r-1) \n\n// nCr/nC(r-1) = (n+1-r)/r; \n\nnCr = (nCr * (n + \n1\n- r)) / r; \n\n\nres += nCr * nCr; \n\n} \n\n\nreturn\nres; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.print(\n\"Count of sequences is \"\n); \n\nSystem.out.println(countSeq(n)); \n} \n} \n\n// This code is contributed \n// by Shivi_Aggarwal ", "complexity": "linear", "from": "CorCod", "problem": 252, "index": 252}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint arr[] = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tans = Math.min(ans, Math.min(arr[i],arr[0])/i);\n\t\t}\n\t\tfor (int i=n-2;i>=0;i--){\n\t\t\tans = Math.min(ans, Math.min(arr[n-1],arr[i])/(n-i-1));\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 253, "index": 253}
{"src": "import java.io.*;\n\npublic class GennadyAndACardGame {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tString line =null;\n\t\tString[] n={};\n\t\tString s=\"NO\";\n\t\twhile((line=bufr.readLine())!=null)    {\n\t\t\tif(\"over\".equals(line))\n\t\t\t\tbreak;\n\t\t\tn=bufr.readLine().split(\" \");\n\t\t\tfor(int i=0;i<n.length;i++){\n\t\t\t\tif(n[i].contains(line.substring(0,1)) || n[i].contains(line.substring(1))){\n\t\t\t\t\ts=\"YES\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(s);\n\t\t\ts=\"NO\";\n\t\t\tbufw.flush();\n\t\t}\n\t\tbufw.close();                          //\u5173\u95ed\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 254, "index": 254}
{"src": "\n// Java program to store sum of nodes in left subtree in every \n// node \nclass\nGfG { \n\n// A tree node \nstatic\nclass\nnode \n{ \n\nint\ndata; \n\nnode left, right; \n} \n\n// Function to modify a Binary Tree so that every node \n// stores sum of values in its left child including its \n// own value \nstatic\nint\nupdatetree(node root) \n{ \n\n// Base cases \n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\nroot.data; \n\n\n// Update left and right subtrees \n\nint\nleftsum = updatetree(root.left); \n\nint\nrightsum = updatetree(root.right); \n\n\n// Add leftsum to current node \n\nroot.data += leftsum; \n\n\n// Return sum of values under root \n\nreturn\nroot.data + rightsum; \n} \n\n// Utility function to do inorder traversal \nstatic\nvoid\ninorder(node node) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\ninorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorder(node.right); \n} \n\n// Utility function to create a new node \nstatic\nnode newNode(\nint\ndata) \n{ \n\nnode node = \nnew\nnode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n// Driver program \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n/* Let us construct below tree \n\n1 \n\n/ \\ \n\n2 3 \n\n/ \\ \\ \n\n4 5 6 */\n\nnode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\nupdatetree(root); \n\n\n\nSystem.out.println(\n\"Inorder traversal of the modified tree is\"\n); \n\ninorder(root); \n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 255, "index": 255}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 256, "index": 256}
{"src": "\n// Java program to do level order \n// traversal line by line \nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \n\npublic\nclass\nGFG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n// Prints level order traversal line \n\n// by line using two queues. \n\nstatic\nvoid\nlevelOrder(Node root) { \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\n\n// Pushing root node into the queue. \n\nq.add(root); \n\n\n// Pushing delimiter into the queue. \n\nq.add(\nnull\n); \n\n\n// Executing loop till queue becomes \n\n// empty \n\nwhile\n(!q.isEmpty()) { \n\n\nNode curr = q.poll(); \n\n\n// condition to check the \n\n// occurence of next level \n\nif\n(curr == \nnull\n) { \n\nif\n(!q.isEmpty()) { \n\nq.add(\nnull\n); \n\nSystem.out.println(); \n\n} \n\n} \nelse\n{ \n\n// Pushing left child current node \n\nif\n(curr.left != \nnull\n) \n\nq.add(curr.left); \n\n\n// Pushing right child current node \n\nif\n(curr.right != \nnull\n) \n\nq.add(curr.right); \n\n\nSystem.out.print(curr.data + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nlevelOrder(root); \n\n} \n} \n\n// This code is Contributed by Rishabh Jindal ", "complexity": "linear", "from": "CorCod", "problem": 257, "index": 257}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Waw{\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) a[i] = sc.nextLong();\n        long[] p = new long[n];\n        p[n-1] = a[n-1];\n        for(int i=n-2;i>=0;i--){\n            if(a[i]<p[i+1]) p[i] = p[i+1]-1;\n            else p[i] = a[i];\n        }\n        long max = p[0];\n        long res = p[0] - a[0];\n        for(int i=1;i<n;i++){\n            if(max < p[i]) max = p[i];\n            res += max - a[i];\n        }\n        System.out.println(res);\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 258, "index": 258}
{"src": "\n// Java program to find k'th largest element in BST \nimport\njava.util.*; \nclass\nGfG { \n\n// A BST node \nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n// A function to find \nstatic\nint\nKSmallestUsingMorris(Node root, \nint\nk) \n{ \n\n// Count to iterate over elements till we \n\n// get the kth smallest number \n\nint\ncount = \n0\n; \n\n\nint\nksmall = Integer.MIN_VALUE; \n// store the Kth smallest \n\nNode curr = root; \n// to store the current node \n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n// Like Morris traversal if current does \n\n// not have left child rather than printing \n\n// as we did in inorder, we will just \n\n// increment the count as the number will \n\n// be in an increasing order \n\nif\n(curr.left == \nnull\n) \n\n{ \n\ncount++; \n\n\n// if count is equal to K then we found the \n\n// kth smallest, so store it in ksmall \n\nif\n(count==k) \n\nksmall = curr.key; \n\n\n// go to current's right child \n\ncurr = curr.right; \n\n} \n\nelse\n\n{ \n\n// we create links to Inorder Successor and \n\n// count using these links \n\nNode pre = curr.left; \n\nwhile\n(pre.right != \nnull\n&& pre.right != curr) \n\npre = pre.right; \n\n\n// building links \n\nif\n(pre.right== \nnull\n) \n\n{ \n\n//link made to Inorder Successor \n\npre.right = curr; \n\ncurr = curr.left; \n\n} \n\n\n// While breaking the links in so made temporary \n\n// threaded tree we will check for the K smallest \n\n// condition \n\nelse\n\n{ \n\n// Revert the changes made in if part (break link \n\n// from the Inorder Successor) \n\npre.right = \nnull\n; \n\n\ncount++; \n\n\n// If count is equal to K then we found \n\n// the kth smallest and so store it in ksmall \n\nif\n(count==k) \n\nksmall = curr.key; \n\n\ncurr = curr.right; \n\n} \n\n} \n\n} \n\nreturn\nksmall; \n//return the found value \n} \n\n// A utility function to create a new BST node \nstatic\nNode newNode(\nint\nitem) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.key = item; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n/* A utility function to insert a new node with given key in BST */\nstatic\nNode insert(Node node, \nint\nkey) \n{ \n\n/* If the tree is empty, return a new node */\n\nif\n(node == \nnull\n) \nreturn\nnewNode(key); \n\n\n/* Otherwise, recur down the tree */\n\nif\n(key < node.key) \n\nnode.left = insert(node.left, key); \n\nelse\nif\n(key > node.key) \n\nnode.right = insert(node.right, key); \n\n\n/* return the (unchanged) node pointer */\n\nreturn\nnode; \n} \n\n// Driver Program to test above functions \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n/* Let us create following BST \n\n50 \n\n/ \\ \n\n30 70 \n\n/ \\ / \\ \n\n20 40 60 80 */\n\nNode root = \nnull\n; \n\nroot = insert(root, \n50\n); \n\ninsert(root, \n30\n); \n\ninsert(root, \n20\n); \n\ninsert(root, \n40\n); \n\ninsert(root, \n70\n); \n\ninsert(root, \n60\n); \n\ninsert(root, \n80\n); \n\n\nfor\n(\nint\nk=\n1\n; k<=\n7\n; k++) \n\nSystem.out.print(KSmallestUsingMorris(root, k) + \n\" \"\n); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 259, "index": 259}
{"src": "import java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n\t// write your code here\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        for(; T > 0; T--) {\n            int n = scan.nextInt();\n            int[] arr = new int[n];\n            for(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n            int m1 = 1, m2 = 1;\n            for(int i = 0; i < n; i++) {\n                if(arr[i] >= m1) {\n                    m2 = m1;\n                    m1 = arr[i];\n                } else if (arr[i] >= m2) {\n                    m2 = arr[i];\n                }\n            }\n            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));\n        }\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 260, "index": 260}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author El-Bishoy\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C982_cut_them_all solver = new D2C982_cut_them_all();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C982_cut_them_all {\n        int n;\n        ArrayList<Integer>[] adj;\n        int[] sizes = new int[n];\n        boolean[] visited = new boolean[n];\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            n = in.nextInt();\n            if ((n & 1) == 1) {\n                out.println(-1);\n                return;\n            }\n            sizes = new int[n];\n            visited = new boolean[n];\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            for (int i = 1; i < n; i++) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            int root = 0;\n            for (int i = 1; i < n; i++) {\n                if (adj[i].size() > adj[root].size()) {\n                    root = i;\n                }\n            }\n\n            dfs(root);\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if ((sizes[i] & 1) == 0) cnt++;\n            }\n            out.println(cnt - 1);\n\n        }\n\n        int dfs(int u) {\n\n            visited[u] = true;\n            int cnt = 1;\n\n            for (int w : adj[u])\n                if (!visited[w])\n                    cnt += dfs(w);\n\n            sizes[u] = cnt;\n            return cnt;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 261, "index": 261}
{"src": "\n// Java implementation to count pairs from two \n// BSTs whose sum is equal to a given value x \nimport\njava.util.Stack; \npublic\nclass\nGFG { \n\n\n// structure of a node of BST \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n// constructor \n\npublic\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\nstatic\nNode root1; \n\nstatic\nNode root2; \n\n// function to count pairs from two BSTs \n\n// whose sum is equal to a given value x \n\nstatic\nint\ncountPairs(Node root1, Node root2, \n\nint\nx) \n\n{ \n\n// if either of the tree is empty \n\nif\n(root1 == \nnull\n|| root2 == \nnull\n) \n\nreturn\n0\n; \n\n\n// stack 'st1' used for the inorder \n\n// traversal of BST 1 \n\n// stack 'st2' used for the reverse \n\n// inorder traversal of BST 2 \n\n//stack<Node*> st1, st2; \n\nStack<Node> st1 = \nnew\nStack<>(); \n\nStack<Node> st2 = \nnew\nStack<>(); \n\nNode top1, top2; \n\n\nint\ncount = \n0\n; \n\n\n// the loop will break when either of two \n\n// traversals gets completed \n\nwhile\n(\ntrue\n) { \n\n\n// to find next node in inorder \n\n// traversal of BST 1 \n\nwhile\n(root1 != \nnull\n) { \n\nst1.push(root1); \n\nroot1 = root1.left; \n\n} \n\n\n// to find next node in reverse \n\n// inorder traversal of BST 2 \n\nwhile\n(root2 != \nnull\n) { \n\nst2.push(root2); \n\nroot2 = root2.right; \n\n} \n\n\n// if either gets empty then corresponding \n\n// tree traversal is completed \n\nif\n(st1.empty() || st2.empty()) \n\nbreak\n; \n\n\ntop1 = st1.peek(); \n\ntop2 = st2.peek(); \n\n\n// if the sum of the node's is equal to 'x' \n\nif\n((top1.data + top2.data) == x) { \n\n// increment count \n\ncount++; \n\n\n// pop nodes from the respective stacks \n\nst1.pop(); \n\nst2.pop(); \n\n\n// insert next possible node in the \n\n// respective stacks \n\nroot1 = top1.right; \n\nroot2 = top2.left; \n\n} \n\n\n// move to next possible node in the \n\n// inoder traversal of BST 1 \n\nelse\nif\n((top1.data + top2.data) < x) { \n\nst1.pop(); \n\nroot1 = top1.right; \n\n} \n\n\n// move to next possible node in the \n\n// reverse inoder traversal of BST 2 \n\nelse\n{ \n\nst2.pop(); \n\nroot2 = top2.left; \n\n} \n\n} \n\n\n// required count of pairs \n\nreturn\ncount; \n\n} \n\n\n// Driver program to test above \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n// formation of BST 1 \n\nroot1 = \nnew\nNode(\n5\n); \n/* 5 */\n\nroot1.left = \nnew\nNode(\n3\n); \n/* / \\ */\n\nroot1.right = \nnew\nNode(\n7\n); \n/* 3 7 */\n\nroot1.left.left = \nnew\nNode(\n2\n); \n/* / \\ / \\ */\n\nroot1.left.right = \nnew\nNode(\n4\n); \n/* 2 4 6 8 */\n\nroot1.right.left = \nnew\nNode(\n6\n); \n\nroot1.right.right = \nnew\nNode(\n8\n); \n\n\n// formation of BST 2 \n\nroot2 = \nnew\nNode(\n10\n); \n/* 10 */\n\nroot2.left = \nnew\nNode(\n6\n); \n/* / \\ */\n\nroot2.right = \nnew\nNode(\n15\n); \n/* 6 15 */\n\nroot2.left.left = \nnew\nNode(\n3\n); \n/* / \\ / \\ */\n\nroot2.left.right = \nnew\nNode(\n8\n); \n/* 3 8 11 18 */\n\nroot2.right.left = \nnew\nNode(\n11\n); \n\nroot2.right.right = \nnew\nNode(\n18\n); \n\n\nint\nx = \n16\n; \n\nSystem.out.println(\n\"Pairs = \"\n\n+ countPairs(root1, root2, x)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "linear", "from": "CorCod", "problem": 262, "index": 262}
{"src": "\n// Java code to find number of subsequences of \n// \"ab\" in the string S which is repeated K times. \n\nimport\njava.io.*; \n\nclass\nGFG { \n\n\nstatic\nint\ncountOccurrences(String s, \nint\nK) \n\n{ \n\nint\nn = s.length(); \n\nint\nC = \n0\n, c1 = \n0\n, c2 = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(s.charAt(i) == \n'a'\n) \n\nc1++; \n// Count of 'a's \n\nif\n(s.charAt(i) == \n'b'\n) { \n\nc2++; \n// Count of 'b's \n\n\n// occurrence of \"ab\"s \n\n// in string S \n\nC += c1; \n\n} \n\n} \n\n\n// Add following two : \n\n// 1) K * (Occurrences of \"ab\" in single string) \n\n// 2) a is from one string and b is from other. \n\nreturn\nC * K + (K * (K - \n1\n) / \n2\n) * c1 * c2; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString S = \n\"abcb\"\n; \n\nint\nk = \n2\n; \n\n\nSystem.out.println(countOccurrences(S, k)); \n\n} \n} \n\n// This code is contributed by vt_m. ", "complexity": "linear", "from": "CorCod", "problem": 263, "index": 263}
{"src": "\n// Java program to convert a given Binary Tree to \n// Doubly Linked List \n\n/* Structure for tree and Linked List */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\n// 'root' - root of binary tree \n\nNode root; \n\n\n// 'head' - reference to head node of created \n\n//double linked list \n\nNode head; \n\n\n// A simple recursive function to convert a given \n\n// Binary tree to Doubly Linked List \n\nvoid\nBToDLL(Node root) \n\n{ \n\n// Base cases \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n// Recursively convert right subtree \n\nBToDLL(root.right); \n\n\n// insert root into DLL \n\nroot.right = head; \n\n\n// Change left pointer of previous head \n\nif\n(head != \nnull\n) \n\n(head).left = root; \n\n\n// Change head of Doubly linked list \n\nhead = root; \n\n\n// Recursively convert left subtree \n\nBToDLL(root.left); \n\n} \n\n\n// Utility function for printing double linked list. \n\nvoid\nprintList(Node head) \n\n{ \n\nSystem.out.println(\n\"Extracted Double Linked List is : \"\n); \n\nwhile\n(head != \nnull\n) \n\n{ \n\nSystem.out.print(head.data + \n\" \"\n); \n\nhead = head.right; \n\n} \n\n} \n\n\n// Driver program to test the above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n/* Constructing below tree \n\n5 \n\n/ \\ \n\n3 6 \n\n/ \\ \\ \n\n1 4 8 \n\n/ \\ / \\ \n\n0 2 7 9 */\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n3\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.right = \nnew\nNode(\n4\n); \n\ntree.root.left.left = \nnew\nNode(\n1\n); \n\ntree.root.right.right = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left.left = \nnew\nNode(\n0\n); \n\ntree.root.right.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right.right = \nnew\nNode(\n9\n); \n\n\ntree.BToDLL(tree.root); \n\ntree.printList(tree.head); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "linear", "from": "CorCod", "problem": 264, "index": 264}
{"src": "import java.io.*;\n\n\npublic class First {\n    StreamTokenizer in;\n    PrintWriter out;\n\n    int nextInt() throws IOException {\n        in.nextToken();\n        return (int)in.nval;\n    }\n\n    long nextLong() throws IOException {\n        in.nextToken();\n        return (long) in.nval;\n    }\n\n    String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n\n\n    void run() throws IOException {\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    void solve() throws IOException {\n        int n = nextInt(), k = nextInt(), sum = 0, count = 0;\n        String str = nextString();\n        char[] arr = str.toCharArray();\n        boolean[] bool = new boolean[26];\n        for(char ch: arr){\n            bool[((int)ch)-97] = true;\n        }\n        for(int i = 0; i < 26; i++){\n            if(bool[i]){\n                sum += i+1;\n                count++;\n                i += 1;\n            }\n            if(count == k) break;\n        }\n        if(count == k) out.println(sum);\n        else out.println(-1);\n    }\n\n    public static void main(String[] args) throws IOException {\n        new First().run();\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 265, "index": 265}
{"src": "\n// Java program to reverse alternate levels of perfect binary tree \n// A binary tree node \nclass\nNode { \n\n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) { \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\n// class to access index value by reference \nclass\nIndex { \n\n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n\nNode root; \n\nIndex index_obj = \nnew\nIndex(); \n\n\n// function to store alternate levels in a tree \n\nvoid\nstoreAlternate(Node node, \nchar\narr[], Index index, \nint\nl) { \n\n// base case \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n// store elements of left subtree \n\nstoreAlternate(node.left, arr, index, l + \n1\n); \n\n\n// store this node only if level is odd \n\nif\n(l % \n2\n!= \n0\n) { \n\narr[index.index] = node.data; \n\nindex.index++; \n\n} \n\n\nstoreAlternate(node.right, arr, index, l + \n1\n); \n\n} \n\n\n// Function to modify Binary Tree (All odd level nodes are \n\n// updated by taking elements from array in inorder fashion) \n\nvoid\nmodifyTree(Node node, \nchar\narr[], Index index, \nint\nl) { \n\n\n// Base case \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n// Update nodes in left subtree \n\nmodifyTree(node.left, arr, index, l + \n1\n); \n\n\n// Update this node only if this is an odd level node \n\nif\n(l % \n2\n!= \n0\n) { \n\nnode.data = arr[index.index]; \n\n(index.index)++; \n\n} \n\n\n// Update nodes in right subtree \n\nmodifyTree(node.right, arr, index, l + \n1\n); \n\n} \n\n\n// A utility function to reverse an array from index \n\n// 0 to n-1 \n\nvoid\nreverse(\nchar\narr[], \nint\nn) { \n\nint\nl = \n0\n, r = n - \n1\n; \n\nwhile\n(l < r) { \n\nchar\ntemp = arr[l]; \n\narr[l] = arr[r]; \n\narr[r] = temp; \n\nl++; \n\nr--; \n\n} \n\n} \n\n\nvoid\nreverseAlternate() { \n\nreverseAlternate(root); \n\n} \n\n\n// The main function to reverse alternate nodes of a binary tree \n\nvoid\nreverseAlternate(Node node) { \n\n\n// Create an auxiliary array to store nodes of alternate levels \n\nchar\n[] arr = \nnew\nchar\n[\n100\n]; \n\n\n// First store nodes of alternate levels \n\nstoreAlternate(node, arr, index_obj, \n0\n); \n\n\n//index_obj.index = 0; \n\n\n// Reverse the array \n\nreverse(arr, index_obj.index); \n\n\n// Update tree by taking elements from array \n\nindex_obj.index = \n0\n; \n\nmodifyTree(node, arr, index_obj, \n0\n); \n\n} \n\n\nvoid\nprintInorder() { \n\nprintInorder(root); \n\n} \n\n\n// A utility function to print indorder traversal of a \n\n// binary tree \n\nvoid\nprintInorder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n// Driver program to test the above functions \n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n'a'\n); \n\ntree.root.left = \nnew\nNode(\n'b'\n); \n\ntree.root.right = \nnew\nNode(\n'c'\n); \n\ntree.root.left.left = \nnew\nNode(\n'd'\n); \n\ntree.root.left.right = \nnew\nNode(\n'e'\n); \n\ntree.root.right.left = \nnew\nNode(\n'f'\n); \n\ntree.root.right.right = \nnew\nNode(\n'g'\n); \n\ntree.root.left.left.left = \nnew\nNode(\n'h'\n); \n\ntree.root.left.left.right = \nnew\nNode(\n'i'\n); \n\ntree.root.left.right.left = \nnew\nNode(\n'j'\n); \n\ntree.root.left.right.right = \nnew\nNode(\n'k'\n); \n\ntree.root.right.left.left = \nnew\nNode(\n'l'\n); \n\ntree.root.right.left.right = \nnew\nNode(\n'm'\n); \n\ntree.root.right.right.left = \nnew\nNode(\n'n'\n); \n\ntree.root.right.right.right = \nnew\nNode(\n'o'\n); \n\nSystem.out.println(\n\"Inorder Traversal of given tree\"\n); \n\ntree.printInorder(); \n\n\ntree.reverseAlternate(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Inorder Traversal of modified tree\"\n); \n\ntree.printInorder(); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 266, "index": 266}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class FirstClass {\n\t\n\tpublic static void main(String[] args)throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tint arr[] = new int [n];\n\t\t\n\t\tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t{\n\t\t\tarr[i] = Integer.parseInt(st1.nextToken());\n\t\t}\n\t\t\n\t\tint max = -1;\n\t\tboolean flag = true;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t{\n\t\t\tif(arr[i] > max+1)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tout.println(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax = Math.max(max, arr[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(flag)\n\t\t\tout.println(-1);\n\t\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 267, "index": 267}
{"src": "\n// Java program to find nth \n// element of Newman-Conway Sequence \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Recursion to find \n\n// n-th element \n\nstatic\nint\nsequence(\nint\nn) \n\n{ \n\nif\n(n == \n1\n|| n == \n2\n) \n\nreturn\n1\n; \n\nelse\n\nreturn\nsequence(sequence(n - \n1\n)) \n\n+ sequence(n - sequence(n - \n1\n)); \n\n} \n\n\n// Driver Program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(sequence(n)); \n\n} \n} \n\n/*This code is contributed by Nikita Tiwari.*/", "complexity": "linear", "from": "CorCod", "problem": 268, "index": 268}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Equator {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint[] a = intArray(n);\n\t\t\n\t\tlong s = 0;\n\t\tfor (int x : a)\n\t\t\ts += x;\n\t\t\n\t\tlong m = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tm += a[i];\n\t\t\tif (m*2 >= s) {\n\t\t\t\tSystem.out.println(i+1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 269, "index": 269}
{"src": "\n//A Java program to check if a given binary tree is complete or not \n\nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \n\npublic\nclass\nCompleteBTree \n{ \n\n/* A binary tree node has data, a pointer to left child \n\nand a pointer to right child */\n\nstatic\nclass\nNode \n\n{ \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\n// Constructor \n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n/* Given a binary tree, return true if the tree is complete \n\nelse false */\n\nstatic\nboolean\nisCompleteBT(Node root) \n\n{ \n\n// Base Case: An empty tree is complete Binary Tree \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// Create an empty queue \n\nQueue<Node> queue =\nnew\nLinkedList<>(); \n\n\n// Create a flag variable which will be set true \n\n// when a non full node is seen \n\nboolean\nflag = \nfalse\n; \n\n\n// Do level order traversal using queue. \n\nqueue.add(root); \n\nwhile\n(!queue.isEmpty()) \n\n{ \n\nNode temp_node = queue.remove(); \n\n\n/* Check if left child is present*/\n\nif\n(temp_node.left != \nnull\n) \n\n{ \n\n// If we have seen a non full node, and we see a node \n\n// with non-empty left child, then the given tree is not \n\n// a complete Binary Tree \n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n// Enqueue Left Child \n\nqueue.add(temp_node.left); \n\n} \n\n// If this a non-full node, set the flag as true \n\nelse\n\nflag = \ntrue\n; \n\n\n/* Check if right child is present*/\n\nif\n(temp_node.right != \nnull\n) \n\n{ \n\n// If we have seen a non full node, and we see a node \n\n// with non-empty right child, then the given tree is not \n\n// a complete Binary Tree \n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n// Enqueue Right Child \n\nqueue.add(temp_node.right); \n\n\n} \n\n// If this a non-full node, set the flag as true \n\nelse\n\nflag = \ntrue\n; \n\n} \n\n// If we reach here, then the tree is complete Binary Tree \n\nreturn\ntrue\n; \n\n} \n\n\n/* Driver program to test above functions*/\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n/* Let us construct the following Binary Tree which \n\nis not a complete Binary Tree \n\n1 \n\n/ \\ \n\n2 3 \n\n/ \\ \\ \n\n4 5 6 \n\n*/\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nif\n(isCompleteBT(root) == \ntrue\n) \n\nSystem.out.println(\n\"Complete Binary Tree\"\n); \n\nelse\n\nSystem.out.println(\n\"NOT Complete Binary Tree\"\n); \n\n} \n\n} \n//This code is contributed by Sumit Ghosh ", "complexity": "linear", "from": "CorCod", "problem": 270, "index": 270}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  static Scanner in = new Scanner(System.in);\n  static PrintWriter out = new PrintWriter(System.out);\n  \n  public static void main(String[] args) {\n    int n = in.nextInt();\n    int m = in.nextInt();\n    long boyMax = 0;\n    int NBoyMax = 0;\n\n    long sweets = 0;\n    TreeSet<Long> boyMember = new TreeSet<>();\n    for (int i = 0; i < n; i++) {\n      long input = in.nextLong();\n      boyMember.add(input);\n      if (boyMax < input) {\n        boyMax = input;\n        NBoyMax = 1;\n      } else if (boyMax == input) NBoyMax++;\n      sweets += (input * m);\n    }\n\n    long smallestGirl = (long) 1e8 + 1;\n    long sum = 0;\n    for (int i = 0; i < m; i++) {\n      long input = in.nextLong();\n      sum += input;\n      if (smallestGirl > input) smallestGirl = input;\n    }\n\n    if (smallestGirl < boyMember.last()) {\n      out.println(-1);\n    } else if (smallestGirl == boyMember.last()) {\n      sweets += sum - boyMember.last() * m;\n      out.println(sweets);\n    } else {\n\n      if (NBoyMax > 1) {\n        sweets += sum - boyMember.last() * m;\n        out.println(sweets);\n      } else {\n        Object[] boyList = boyMember.toArray();\n        if (boyList.length > 1) {\n          long boy = 0;\n          boy = (long)boyList[boyList.length - 2];\n          sweets += (sum - smallestGirl - boyMember.last() * (m - 1));\n          sweets += (smallestGirl - boy);\n          out.println(sweets);\n        } else {\n          out.println(-1);\n        }\n      }\n    }\n\n    in.close();\n    out.close();\n  }\n}", "complexity": "linear", "from": "CorCod", "problem": 271, "index": 271}
{"src": "import java.util.Scanner;\n\npublic class Solution {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString s = sc.next();\n\n\t\tStringBuilder ans = new StringBuilder();\n\t\tint count = 0;\n\t\tint open = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tans.append(\"(\");\n\t\t\t\tcount++;\n\t\t\t\topen++;\n\t\t\t} else {\n\t\t\t\tans.append(\")\");\n\t\t\t\topen--;\n\t\t\t}\n\t\t\tif (count == k / 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile (open > 0) {\n\t\t\tans.append(\")\");\n\t\t\topen--;\n\t\t}\n\t\tSystem.out.println(ans.toString());\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 272, "index": 272}
{"src": "\n// Java program to print sum of all substring of \n// a number represented as a string \nimport\njava.util.Arrays; \n\nclass\nGFG{ \n\n\n// Returns sum of all substring of num \n\npublic\nstatic\nint\nsumOfSubstrings(String num) \n\n{ \n\nint\nn = num.length(); \n\n\n// allocate memory equal to length of string \n\nint\nsumofdigit[] = \nnew\nint\n[n]; \n\n\n// initialize first value with first digit \n\nsumofdigit[\n0\n] = num.charAt(\n0\n)-\n'0'\n; \n\nint\nres = sumofdigit[\n0\n]; \n\n\n// loop over all digits of string \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nint\nnumi = num.charAt(i)-\n'0'\n; \n\n\n// update each sumofdigit from previous value \n\nsumofdigit[i] = (i+\n1\n) * numi + \n\n10\n* sumofdigit[i-\n1\n]; \n\n\n// add current value to the result \n\nres += sumofdigit[i]; \n\n} \n\n\nreturn\nres; \n\n} \n\n\n// Driver code to test above methods \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString num = \n\"1234\"\n; \n\n\nSystem.out.println(sumOfSubstrings(num)); \n\n\n} \n} \n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "linear", "from": "CorCod", "problem": 273, "index": 273}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n/**\n *\n * @author Ahmed\n */\n\n\n\n\npublic class Watermelon {\n\n   static class Passengers {\n  \n     public int floor ;\n     public int time;\n     \n     \n     public Passengers( int floor  , int time){\n         this.floor =floor;\n         this.time =time;\n     }\n     \n}\n\n    \n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        \n        Scanner in = new Scanner(System.in);\n        \n        int x = in.nextInt() , y = in.nextInt();\n        \n        ArrayList<Passengers> list = new ArrayList<>();\n        \n        for(int i = 1 ; i <= x ; ++i){\n            list.add(new Passengers(in.nextInt(), in.nextInt()));\n        }\n        \n        int sum = 0 ;\n       for(int i = list.size() - 1 ; i >= 0 ; --i)\n       {\n          int s = y -  list.get(i).floor;\n          sum = sum + s ; \n          \n          if(sum < list.get(i).time)\n          {\n              sum = sum + ( list.get(i).time - sum);\n          }\n          \n          y = list.get(i).floor;\n       } \n        \n        \n       if( list.get(list.size() - 1).floor != 0){\n           sum = sum  + (list.get(0).floor);\n       }\n        System.out.println(sum);\n    }\n    \n}\n", "complexity": "linear", "from": "CorCod", "problem": 274, "index": 274}
{"src": "\n// Java implementation to check whether the two \n// binary tress are mirrors of each other or not \nimport\njava.util.*; \nclass\nGfG { \n\n// structure of a node in binary tree \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n// Utility function to create and return \n// a new node for a binary tree \nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n// function to check whether the two binary trees \n// are mirrors of each other or not \nstatic\nString areMirrors(Node root1, Node root2) \n{ \n\nStack<Node> st1 = \nnew\nStack<Node> (); \n\nStack<Node> st2 = \nnew\nStack<Node> (); \n\nwhile\n(\ntrue\n) \n\n{ \n\n// iterative inorder traversal of 1st tree and \n\n// reverse inoder traversal of 2nd tree \n\nwhile\n(root1 != \nnull\n&& root2 != \nnull\n) \n\n{ \n\n// if the corresponding nodes in the two traversal \n\n// have different data values, then they are not \n\n// mirrors of each other. \n\nif\n(root1.data != root2.data) \n\nreturn\n\"No\"\n; \n\n\nst1.push(root1); \n\nst2.push(root2); \n\nroot1 = root1.left; \n\nroot2 = root2.right; \n\n} \n\n\n// if at any point one root becomes null and \n\n// the other root is not null, then they are \n\n// not mirrors. This condition verifies that \n\n// structures of tree are mirrors of each other. \n\nif\n(!(root1 == \nnull\n&& root2 == \nnull\n)) \n\nreturn\n\"No\"\n; \n\n\nif\n(!st1.isEmpty() && !st2.isEmpty()) \n\n{ \n\nroot1 = st1.peek(); \n\nroot2 = st2.peek(); \n\nst1.pop(); \n\nst2.pop(); \n\n\n/* we have visited the node and its left subtree. \n\nNow, it's right subtree's turn */\n\nroot1 = root1.right; \n\n\n/* we have visited the node and its right subtree. \n\nNow, it's left subtree's turn */\n\nroot2 = root2.left; \n\n} \n\n\n// both the trees have been completely traversed \n\nelse\n\nbreak\n; \n\n} \n\n\n// tress are mirrors of each other \n\nreturn\n\"Yes\"\n; \n} \n\n// Driver program to test above \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n// 1st binary tree formation \n\nNode root1 = newNode(\n1\n); \n/* 1 */\n\nroot1.left = newNode(\n3\n); \n/* / \\ */\n\nroot1.right = newNode(\n2\n); \n/* 3 2 */\n\nroot1.right.left = newNode(\n5\n); \n/* / \\ */\n\nroot1.right.right = newNode(\n4\n); \n/* 5 4 */\n\n\n// 2nd binary tree formation \n\nNode root2 = newNode(\n1\n); \n/* 1 */\n\nroot2.left = newNode(\n2\n); \n/* / \\ */\n\nroot2.right = newNode(\n3\n); \n/* 2 3 */\n\nroot2.left.left = newNode(\n4\n); \n/* / \\ */\n\nroot2.left.right = newNode(\n5\n); \n/* 4 5 */\n\n\nSystem.out.println(areMirrors(root1, root2)); \n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 275, "index": 275}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class round569d2b {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint max = Integer.MIN_VALUE;\n\t\t\tint maxIndex = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint elem = arr[i];\n\t\t\t\tif (elem < 0) {\n\t\t\t\t\telem = -1*elem-1;\n\t\t\t\t}\n\t\t\t\tif (elem > max) {\n\t\t\t\t\tmax = elem;\n\t\t\t\t\tmaxIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i == maxIndex) {\n\t\t\t\t\tif (arr[i] < 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < n ;i++) {\n\t\t\tsb.append(arr[i] + \" \");\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t// ======================================================================================\n\t// =============================== Reference Code =======================================\n\t// ======================================================================================\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t// Method to return all primes smaller than or equal to \n\t// n using Sieve of Eratosthenes \n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t// Create a boolean array \"prime[0..n]\" and initialize \n\t\t// all entries it as true. A value in prime[i] will \n\t\t// finally be false if i is Not a prime, else true. \n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t// If prime[p] is not changed, then it is a prime \n\t\t\tif (prime[p] == true) {\n\t\t\t\t// Update all multiples of p \n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t// Binary search for number greater than or equal to target\n\t// returns -1 if number not found\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t// Base Case \n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; // To store results of recursive call \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t// Update x and y using results of recursive \n\t\t// call \n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t// Returns modulo inverse of a  \n\t// with respect to m using extended \n\t// Euclid Algorithm. Refer below post for details: \n\t// https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/ \n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t// Apply extended Euclid Algorithm \n\t\twhile (a > 1) {\n\t\t\t// q is quotient \n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t// m is remainder now, process \n\t\t\t// same as euclid's algo \n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t// Make x1 positive \n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t// k is size of num[] and rem[]. \n\t// Returns the smallest number \n\t// x such that: \n\t// x % num[0] = rem[0], \n\t// x % num[1] = rem[1], \n\t// .................. \n\t// x % num[k-2] = rem[k-1] \n\t// Assumption: Numbers in num[] are pairwise  \n\t// coprime (gcd for every pair is 1) \n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t// Compute product of all numbers \n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t// Initialize result \n\t\tint result = 0;\n\n\t\t// Apply above formula \n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t/**\n\t * Source: Matt Fontaine\n\t */\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "complexity": "linear", "from": "CorCod", "problem": 276, "index": 276}
{"src": "\n// A DP based Java program to find maximum tasks. \nclass\nGFG \n{ \n\n// Returns the maximum among the 2 numbers \nstatic\nint\nmax(\nint\nx, \nint\ny) \n{ \n\nreturn\n(x > y ? x : y); \n} \n\n// Returns maximum amount of task that can be \n// done till day n \nstatic\nint\nmaxTasks(\nint\n[]high, \nint\n[]low, \nint\nn) \n{ \n\n// An array task_dp that stores the maximum \n\n// task done \n\nint\n[] task_dp = \nnew\nint\n[n + \n1\n]; \n\n\n// If n = 0, no solution exists \n\ntask_dp[\n0\n] = \n0\n; \n\n\n// If n = 1, high effort task on that day will \n\n// be the solution \n\ntask_dp[\n1\n] = high[\n0\n]; \n\n\n// Fill the entire array determining which \n\n// task to choose on day i \n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\ntask_dp[i] = Math.max(high[i - \n1\n] + task_dp[i - \n2\n], \n\nlow[i - \n1\n] + task_dp[i - \n1\n]); \n\nreturn\ntask_dp[n]; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n5\n; \n\nint\n[]high = {\n3\n, \n6\n, \n8\n, \n7\n, \n6\n}; \n\nint\n[]low = {\n1\n, \n5\n, \n4\n, \n5\n, \n3\n}; \n\nSystem.out.println(maxTasks(high, low, n)); \n} \n} \n\n// This code is contributed by Code_Mech. ", "complexity": "linear", "from": "CorCod", "problem": 277, "index": 277}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Cheast {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] l = new int[n];\n        l[0] = sc.nextInt();\n        int x=1;\n        int c=1;\n        for (int i=1;i<n;i++) {\n            l[i] = sc.nextInt();\n            if (l[i] <= l[i-1]*2) {\n                c++;\n                x = Math.max(x,c);\n            }\n            else\n                c = 1;\n        }\n        System.out.println(x);\n\n\n\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 278, "index": 278}
{"src": "import java.util.*;\npublic class Main {\n\n    public static void main(String args[]) {\n        Scanner scan = new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int[] game=new int[n];\n        int[] bill=new int[m];\n        for (int i = 0; i <n ; i++) {\n            game[i]=scan.nextInt();\n        }\n        for (int i = 0; i <m ; i++) {\n            bill[i]=scan.nextInt();\n        }\n        int i=0;\n        int j=0;\n        int ans=0;\n        while (i<m){\n            boolean f=true;\n            for (int k = j; k <n ; k++) {\n                if (bill[i]>=game[k]){\n                    ans++;\n                    i++;\n                    j=k+1;\n                    f=false;\n                    break;\n                }\n            }\n            if (f){\n                break;\n            }\n        }\n        System.out.println(ans);\n    }\n}\n\n\n", "complexity": "linear", "from": "CorCod", "problem": 279, "index": 279}
{"src": "import java.util.Arrays;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args)\n    {\n        Scanner stdin = new Scanner(System.in);\n        /*int n = stdin.nextInt();\n        for(int i = 0; i < n; i++)\n        {\n        \ttest(stdin);\n        }*/\n        test(stdin);\n        stdin.close();\n    }\n    public static void test(Scanner stdin)\n    {\n    \tint n = stdin.nextInt();\n    \tint min = Integer.MAX_VALUE;\n    \tfor(int i = 0; i < n; i++)\n    \t{\n    \t\tint a = stdin.nextInt();\n    \t\tif((int)((1.0)*a/(Math.max(i, n - i - 1))) < min)\n    \t\t{ min = (int)((1.0)*a/(Math.max(i, n - i - 1))); }\n    \t}\n    \tSystem.out.println(min);\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 280, "index": 280}
{"src": "\n// Java program to calculate the \n// product of max element of first \n// array and min element of second array \nimport\njava.util.*; \nimport\njava.lang.*; \n\nclass\nGfG \n{ \n\n\n// Function to calculate the product \n\npublic\nstatic\nint\nminMaxProduct(\nint\narr1[], \n\nint\narr2[], \n\nint\nn1, \n\nint\nn2) \n\n{ \n\n\n// Initialize max of \n\n// first array \n\nint\nmax = arr1[\n0\n]; \n\n\n// initialize min of \n\n// second array \n\nint\nmin = arr2[\n0\n]; \n\n\nint\ni; \n\nfor\n(i = \n1\n; i < n1 && i < n2; ++i) \n\n{ \n\n\n// To find the maximum \n\n// element in first array \n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\n\n// To find the minimum element \n\n// in second array \n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\n} \n\n\n// Process remaining elements \n\nwhile\n(i < n1) \n\n{ \n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\ni++; \n\n} \n\nwhile\n(i < n2) \n\n{ \n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\ni++; \n\n} \n\n\nreturn\nmax * min; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String argc[]) \n\n{ \n\nint\n[] arr1= \nnew\nint\n[]{ \n10\n, \n2\n, \n3\n, \n\n6\n, \n4\n, \n1\n}; \n\nint\n[] arr2 = \nnew\nint\n[]{ \n5\n, \n1\n, \n4\n, \n\n2\n, \n6\n, \n9\n}; \n\nint\nn1 = \n6\n; \n\nint\nn2 = \n6\n; \n\nSystem.out.println(minMaxProduct(arr1, arr2, \n\nn1, n2)); \n\n} \n} \n\n// This code is contributed by Sagar Shukla ", "complexity": "linear", "from": "CorCod", "problem": 281, "index": 281}
{"src": "\n// Java implementation of program to find \n// the maximum length that can be removed \nimport\njava.util.ArrayList; \n\npublic\nclass\nGFG \n{ \n\n// User defined class Pair \n\nstatic\nclass\nPair{ \n\nchar\nfirst; \n\nint\nsecond; \n\nPair(\nchar\nfirst, \nint\nsecond){ \n\nthis\n.first = first; \n\nthis\n.second = second; \n\n} \n\n} \n\n\n/* Function to find the length of longest \n\nsub-string that can me make removed \n\narr --> pair type of array whose first \n\nfield store character in string \n\nand second field stores \n\ncorresponding index of that character*/\n\nstatic\nint\nlongestNull(String str) \n\n{ \n\nArrayList<Pair> arr = \nnew\nArrayList<>(); \n\n\n// store {'@',-1} in arr , here this value \n\n// will work as base index \n\narr.add(\nnew\nPair(\n'@'\n, -\n1\n)); \n\n\nint\nmaxlen = \n0\n; \n// Initialize result \n\n\n// one by one iterate characters of string \n\nfor\n(\nint\ni = \n0\n; i < str.length(); ++i) \n\n{ \n\n// make pair of char and index , then \n\n// store them into arr \n\narr.add(\nnew\nPair(str.charAt(i), i)); \n\n\n// now if last three elements of arr[] \n\n// are making sub-string \"100\" or not \n\nwhile\n(arr.size() >= \n3\n&& \n\narr.get(arr.size()-\n3\n).first==\n'1'\n&& \n\narr.get(arr.size()-\n2\n).first==\n'0'\n&& \n\narr.get(arr.size()-\n1\n).first==\n'0'\n) \n\n{ \n\n// if above condition is true then \n\n// delete sub-string \"100\" from arr[] \n\narr.remove(arr.size() - \n3\n); \n\narr.remove(arr.size() - \n2\n); \n\narr.remove(arr.size() - \n1\n); \n\n} \n\n\n// index of current last element in arr[] \n\nint\ntmp = arr.get(arr.size() - \n1\n).second; \n\n\n// This is important, here 'i' is the index \n\n// of current character inserted into arr[] \n\n// and 'tmp' is the index of last element \n\n// in arr[] after continuous deletion of \n\n// sub-string \"100\" from arr[] till we make \n\n// it null, difference of these to 'i-tmp' \n\n// gives the length of current sub-string \n\n// that can be make null by continuous \n\n// deletion of sub-string \"100\" \n\nmaxlen = Math.max(maxlen, i - tmp); \n\n} \n\n\nreturn\nmaxlen; \n\n} \n\n\n// Driver program to run the case \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(longestNull(\n\"1011100000100\"\n)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "linear", "from": "CorCod", "problem": 282, "index": 282}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n *\n * @author Haya\n */\npublic class CommentaryBoxes {\n\n    public static void main(String[] args) {\n        \n        FastReader in = new FastReader();\n        \n        long n = in.nextLong();\n        long m = in.nextLong();\n        long a = in.nextLong();\n        long b = in.nextLong();\n        long total = 0;\n        \n        long val =(n%m);\n        if (n%m != 0){\n            \n            long x = (val)*b;\n            long y = (m-val)*a;\n            \n            total = Math.min(x, y);\n        }\n        System.out.println(Math.abs(total));\n        \n    }\n\n    public static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String string = \"\";\n            try {\n                string = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return string;\n        }\n\n    }\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 283, "index": 283}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lewin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ERandomForestRank solver = new ERandomForestRank();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ERandomForestRank {\n        int n;\n        List<Integer>[] tree;\n        int mod = 998244353;\n        long[][] dp;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            tree = LUtils.genArrayList(n);\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                tree[a].add(b);\n                tree[b].add(a);\n            }\n            dp = new long[n][];\n            out.println((dfs(0, -1)[2] * 2) % mod);\n        }\n\n        long[] dfs(int node, int par) {\n            long tot = 1;\n            long alltaken = 1;\n            for (int next : tree[node]) {\n                if (next == par) continue;\n                long[] r = dfs(next, node);\n                tot = tot * (r[0] + r[1] + r[0] + r[1]) % mod;\n                alltaken = alltaken * (r[1] + r[1] + r[0]) % mod;\n            }\n            long free = alltaken;\n            long notfree = (tot - alltaken + mod) % mod;\n            long sum = notfree;\n            for (int next : tree[node]) {\n                if (next == par) continue;\n                long mult = tot * Utils.inv((dp[next][0] + dp[next][1] + dp[next][0] + dp[next][1]) % mod, mod) % mod;\n                sum = (sum + 2 * mult * dp[next][2]) % mod;\n            }\n            return dp[node] = new long[]{free, notfree, sum};\n        }\n\n    }\n\n    static class Utils {\n        public static long inv(long N, long M) {\n            long x = 0, lastx = 1, y = 1, lasty = 0, q, t, a = N, b = M;\n            while (b != 0) {\n                q = a / b;\n                t = a % b;\n                a = b;\n                b = t;\n                t = x;\n                x = lastx - q * x;\n                lastx = t;\n                t = y;\n                y = lasty - q * y;\n                lasty = t;\n            }\n            return (lastx + M) % M;\n        }\n\n    }\n\n    static class LUtils {\n        public static <E> List<E>[] genArrayList(int size) {\n            return Stream.generate(ArrayList::new).limit(size).toArray(List[]::new);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 20];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 284, "index": 284}
{"src": "\n// Java implementation to replace each node \n// in binary tree with the sum of its inorder \n// predecessor and successor \nimport\njava.util.*; \nclass\nSolution \n{ \n\n// node of a binary tree \nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\n//INT class \nstatic\nclass\nINT \n{ \n\nint\ndata; \n} \n\n// function to get a new node of a binary tree \nstatic\nNode getNode(\nint\ndata) \n{ \n\n// allocate node \n\nNode new_node =\nnew\nNode(); \n\n\n// put in the data; \n\nnew_node.data = data; \n\nnew_node.left = new_node.right = \nnull\n; \n\n\nreturn\nnew_node; \n} \n\n// function to store the inorder traversal \n// of the binary tree in 'arr' \nstatic\nvoid\nstoreInorderTraversal( Node root, \n\nVector<Integer> arr) \n{ \n\n// if root is null \n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n// first recur on left child \n\nstoreInorderTraversal(root.left, arr); \n\n\n// then store the root's data in 'arr' \n\narr.add(root.data); \n\n\n// now recur on right child \n\nstoreInorderTraversal(root.right, arr); \n} \n\n// function to replace each node with the sum of its \n// inorder predecessor and successor \nstatic\nvoid\nreplaceNodeWithSum( Node root, \n\nVector<Integer> arr, INT i) \n{ \n\n// if root is null \n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n// first recur on left child \n\nreplaceNodeWithSum(root.left, arr, i); \n\n\n// replace node's data with the sum of its \n\n// inorder predecessor and successor \n\nroot.data = arr.get(i.data - \n1\n) + arr.get(i.data + \n1\n); \n\n\n// move 'i' to point to the next 'arr' element \n\ni.data++; \n\n\n// now recur on right child \n\nreplaceNodeWithSum(root.right, arr, i); \n} \n\n// Utility function to replace each node in binary \n// tree with the sum of its inorder predecessor \n// and successor \nstatic\nvoid\nreplaceNodeWithSumUtil( Node root) \n{ \n\n// if tree is empty \n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\nVector<Integer> arr= \nnew\nVector<Integer>(); \n\n\n// store the value of inorder predecessor \n\n// for the leftmost leaf \n\narr.add(\n0\n); \n\n\n// store the inoder traversal of the tree in 'arr' \n\nstoreInorderTraversal(root, arr); \n\n\n// store the value of inorder successor \n\n// for the rightmost leaf \n\narr.add(\n0\n); \n\n\n// replace each node with the required sum \n\nINT i = \nnew\nINT(); \n\n\ni.data=\n1\n; \n\n\nreplaceNodeWithSum(root, arr, i); \n} \n\n// function to print the preorder traversal \n// of a binary tree \nstatic\nvoid\npreorderTraversal( Node root) \n{ \n\n// if root is null \n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n// first print the data of node \n\nSystem.out.print( root.data + \n\" \"\n); \n\n\n// then recur on left subtree \n\npreorderTraversal(root.left); \n\n\n// now recur on right subtree \n\npreorderTraversal(root.right); \n} \n\n// Driver program to test above \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n// binary tree formation \n\nNode root = getNode(\n1\n); \n// 1 \n\nroot.left = getNode(\n2\n); \n// / \\ \n\nroot.right = getNode(\n3\n); \n// 2 3 \n\nroot.left.left = getNode(\n4\n); \n// / \\ / \\ \n\nroot.left.right = getNode(\n5\n); \n// 4 5 6 7 \n\nroot.right.left = getNode(\n6\n); \n\nroot.right.right = getNode(\n7\n); \n\n\nSystem.out.println( \n\"Preorder Traversal before tree modification:\"\n); \n\npreorderTraversal(root); \n\n\nreplaceNodeWithSumUtil(root); \n\n\nSystem.out.println(\n\"\\nPreorder Traversal after tree modification:\"\n); \n\npreorderTraversal(root); \n\n} \n} \n//contributed by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 285, "index": 285}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF1027D {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint[] cc = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcc[i] = Integer.parseInt(st.nextToken());\n\t\tst = new StringTokenizer(br.readLine());\n\t\tint[] aa = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = Integer.parseInt(st.nextToken()) - 1;\n\t\tint[] used = new int[n];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] == 2)\n\t\t\t\tcontinue;\n\t\t\tint j = i;\n\t\t\twhile (used[j] == 0) {\n\t\t\t\tused[j] = 1;\n\t\t\t\tj = aa[j];\n\t\t\t}\n\t\t\tif (used[j] == 1) {\n\t\t\t\tint c = cc[j];\n\t\t\t\twhile (used[j] == 1) {\n\t\t\t\t\tused[j] = 2;\n\t\t\t\t\tc = Math.min(c, cc[j]);\n\t\t\t\t\tj = aa[j];\n\t\t\t\t}\n\t\t\t\tans += c;\n\t\t\t}\n\t\t\tj = i;\n\t\t\twhile (used[j] == 1) {\n\t\t\t\tused[j] = 2;\n\t\t\t\tj = aa[j];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 286, "index": 286}
{"src": "\n// Java program to find pair with sum closest to x \nimport\njava.io.*; \nimport\njava.util.*; \nimport\njava.lang.Math; \n\nclass\nCloseSum { \n\n\n// Prints the pair with sum cloest to x \n\nstatic\nvoid\nprintClosest(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres_l=\n0\n, res_r=\n0\n; \n// To store indexes of result pair \n\n\n// Initialize left and right indexes and difference between \n\n// pair sum and x \n\nint\nl = \n0\n, r = n-\n1\n, diff = Integer.MAX_VALUE; \n\n\n// While there are elements between l and r \n\nwhile\n(r > l) \n\n{ \n\n// Check if this pair is closer than the closest pair so far \n\nif\n(Math.abs(arr[l] + arr[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(arr[l] + arr[r] - x); \n\n} \n\n\n// If this pair has more sum, move to smaller values. \n\nif\n(arr[l] + arr[r] > x) \n\nr--; \n\nelse\n// Move to larger values \n\nl++; \n\n} \n\n\nSystem.out.println(\n\" The closest pair is \"\n+arr[res_l]+\n\" and \"\n+ arr[res_r]); \n} \n\n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n22\n, \n28\n, \n29\n, \n30\n, \n40\n}, x = \n54\n; \n\nint\nn = arr.length; \n\nprintClosest(arr, n, x); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "complexity": "linear", "from": "CorCod", "problem": 287, "index": 287}
{"src": "\n// Java program to find the only repeating \n// element in an array where elements are \n// from 1 to n-1. \nclass\nGFG \n{ \n\n\nstatic\nint\nfindRepeating(\nint\narr[], \nint\nn) \n\n{ \n\n\n// res is going to store value of \n\n// 1 ^ 2 ^ 3 .. ^ (n-1) ^ arr[0] ^ \n\n// arr[1] ^ .... arr[n-1] \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nres = res ^ (i + \n1\n) ^ arr[i]; \n\nres = res ^ arr[n - \n1\n]; \n\n\nreturn\nres; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n9\n, \n8\n, \n2\n, \n6\n, \n1\n, \n8\n, \n5\n, \n3\n, \n4\n, \n7\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findRepeating(arr, n)); \n\n} \n} \n\n// This code is contributed by \n// Smitha Dinesh Semwal. ", "complexity": "linear", "from": "CorCod", "problem": 288, "index": 288}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.HashMap;\n\npublic class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n    } \n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    public static void main(String args[])\n    {\n        Reader sc=new Reader();\n        PrintWriter out=new PrintWriter(System.out);\n        int n=sc.i();\n        String s1=sc.s();\n        String s2=sc.s();\n        int pos1=-1;\n        int pos2=-1;\n        int arr[][][]=new int[100][100][2];\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                if(arr[s2.charAt(i)-97][s1.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr[s2.charAt(i)-97][s1.charAt(i)-97][1];\n                    break;\n                }\n                arr[s1.charAt(i)-97][s2.charAt(i)-97][0]=1;\n                arr[s1.charAt(i)-97][s2.charAt(i)-97][1]=i;\n            }\n        }\n        int ham=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            ham++;\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-2);\n            System.out.println(pos1+1+\" \"+(pos2+1));\n            System.exit(0);\n        }\n        \n        int arr1[][]=new int[100][2];\n        int arr2[][]=new int[100][2];\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                if(arr1[s1.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr1[s1.charAt(i)-97][1];\n                    break;\n                }\n                if(arr2[s2.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr2[s2.charAt(i)-97][1];\n                    break;\n                }\n                arr1[s2.charAt(i)-97][0]=1;\n                arr1[s2.charAt(i)-97][1]=i;\n                arr2[s1.charAt(i)-97][0]=1;\n                arr2[s1.charAt(i)-97][1]=i;\n            }\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-1);\n            System.out.println(pos1+1+\" \"+(pos2+1));\n            System.exit(0);\n        }\n        System.out.println(ham);\n        System.out.println(pos1+\" \"+pos2);\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 289, "index": 289}
{"src": "\n// Java code to add all greater values to \n// every node in a given BST \n\n// A binary tree node \nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n// Root of BST \n\nNode root; \n\n\n// Constructor \n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n// Inorder traversal of the tree \n\nvoid\ninorder() \n\n{ \n\ninorderUtil(\nthis\n.root); \n\n} \n\n\n// Utility function for inorder traversal of \n\n// the tree \n\nvoid\ninorderUtil(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\ninorderUtil(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderUtil(node.right); \n\n} \n\n\n// adding new node \n\npublic\nvoid\ninsert(\nint\ndata) \n\n{ \n\nthis\n.root = \nthis\n.insertRec(\nthis\n.root, data); \n\n} \n\n\n/* A utility function to insert a new node with \n\ngiven data in BST */\n\nNode insertRec(Node node, \nint\ndata) \n\n{ \n\n/* If the tree is empty, return a new node */\n\nif\n(node == \nnull\n) { \n\nthis\n.root = \nnew\nNode(data); \n\nreturn\nthis\n.root; \n\n} \n\n\n/* Otherwise, recur down the tree */\n\nif\n(data <= node.data) { \n\nnode.left = \nthis\n.insertRec(node.left, data); \n\n} \nelse\n{ \n\nnode.right = \nthis\n.insertRec(node.right, data); \n\n} \n\nreturn\nnode; \n\n} \n\n\n// This class initialises the value of sum to 0 \n\npublic\nclass\nSum { \n\nint\nsum = \n0\n; \n\n} \n\n\n// Recursive function to add all greater values in \n\n// every node \n\nvoid\nmodifyBSTUtil(Node node, Sum S) \n\n{ \n\n// Base Case \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n// Recur for right subtree \n\nthis\n.modifyBSTUtil(node.right, S); \n\n\n// Now *sum has sum of nodes in right subtree, add \n\n// root->data to sum and update root->data \n\nS.sum = S.sum + node.data; \n\nnode.data = S.sum; \n\n\n// Recur for left subtree \n\nthis\n.modifyBSTUtil(node.left, S); \n\n} \n\n\n// A wrapper over modifyBSTUtil() \n\nvoid\nmodifyBST(Node node) \n\n{ \n\nSum S = \nnew\nSum(); \n\nthis\n.modifyBSTUtil(node, S); \n\n} \n\n\n// Driver Function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n/* Let us create following BST \n\n50 \n\n/ \\ \n\n30 70 \n\n/ \\ / \\ \n\n20 40 60 80 */\n\n\ntree.insert(\n50\n); \n\ntree.insert(\n30\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n40\n); \n\ntree.insert(\n70\n); \n\ntree.insert(\n60\n); \n\ntree.insert(\n80\n); \n\n\ntree.modifyBST(tree.root); \n\n\n// print inoder tarversal of the modified BST \n\ntree.inorder(); \n\n} \n} \n\n// This code is contributed by Kamal Rawal ", "complexity": "linear", "from": "CorCod", "problem": 290, "index": 290}
{"src": "/**\n * Created by Aminul on 3/14/2019.\n */\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\nimport static java.lang.Math.max;\n\npublic class E_2 {\n    public static void main(String[] args) throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = in.nextInt(), k = in.nextInt(), N = (int) 5e6 + 1;\n        int left = 0, right = 0;\n        int a[] = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            a[i] = in.nextInt();\n            if (a[i] == k) left++;\n        }\n        int f[] = new int[N + 1];\n        int ans = 0;\n        for (int i = n; i >= 1; i--) {\n            if (a[i] == k) left--;\n            f[a[i]]++;\n            f[a[i]] = max(f[a[i]], 1 + right);\n            ans = max(ans, f[a[i]] + left);\n            if (a[i] == k) right++;\n        }\n        pw.println(ans);\n        pw.close();\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n\n        public FastReader(InputStream is) {\n            this.is = is;\n        }\n\n        public int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = is.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public int nextInt() {\n            int num = 0, b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 291, "index": 291}
{"src": "/*\n * Created on 17.05.2019\n */\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * @author Wolfgang Weck\n */\npublic class C01Easy {\n\tpublic static void main(String[] args) {\n\t\ttry (BufferedReader r = new BufferedReader(new InputStreamReader(System.in))) {\n\t\t\tfinal String[] line = r.readLine().split(\" \");\n\t\t\tfinal int N = Integer.parseInt(line[0]), P = Integer.parseInt(line[1]);\n\t\t\tfinal String[] numS = r.readLine().split(\" \");\n\t\t\tif (numS.length != N) throw new IllegalArgumentException();\n\t\t\tfinal int[] n = new int[N];\n\t\t\tint sum1 = 0, sum2 = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tn[i] = Integer.parseInt(numS[i]) % P;\n\t\t\t\tsum2 += n[i];\n\t\t\t\tif (sum2 >= P) sum2 -= P;\n\t\t\t}\n\t\t\tint max = sum2;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tsum1 += n[i];\n\t\t\t\tif (sum1 >= P) sum1 -= P;\n\t\t\t\tsum2 -= n[i];\n\t\t\t\tif (sum2 < 0) sum2 += P;\n\t\t\t\tfinal int s = sum1 + sum2;\n\t\t\t\tif (s > max) max = s;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 292, "index": 292}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt(), t;\n        int[] a = new int[101];\n        int answ = 0;\n        for (long i = 0; i < n; i++) {\n            t = in.nextInt();\n            a[t]++;\n            if (a[t] < 2) {\n                if (answ < k) {\n                    data.append(i + 1).append(\" \");\n                    answ++;\n                }\n            }\n\n        }\n        if (answ == k) {\n            System.out.println(\"YES\");\n            System.out.println(data);\n        } else {\n            System.out.println(\"NO\");\n        }\n\n\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "complexity": "linear", "from": "CorCod", "problem": 293, "index": 293}
{"src": "\n// Java program to print BST in given range \n\n// A binary tree node \nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\n\n/* A function that constructs Balanced Binary Search Tree \n\nfrom a sorted array */\n\nNode sortedArrayToBST(\nint\narr[], \nint\nstart, \nint\nend) { \n\n\n/* Base Case */\n\nif\n(start > end) { \n\nreturn\nnull\n; \n\n} \n\n\n/* Get the middle element and make it root */\n\nint\nmid = (start + end) / \n2\n; \n\nNode node = \nnew\nNode(arr[mid]); \n\n\n/* Recursively construct the left subtree and make it \n\nleft child of root */\n\nnode.left = sortedArrayToBST(arr, start, mid - \n1\n); \n\n\n/* Recursively construct the right subtree and make it \n\nright child of root */\n\nnode.right = sortedArrayToBST(arr, mid + \n1\n, end); \n\n\nreturn\nnode; \n\n} \n\n\n/* A utility function to print preorder traversal of BST */\n\nvoid\npreOrder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn = arr.length; \n\nroot = tree.sortedArrayToBST(arr, \n0\n, n - \n1\n); \n\nSystem.out.println(\n\"Preorder traversal of constructed BST\"\n); \n\ntree.preOrder(root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 294, "index": 294}
{"src": " import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.awt.*;\nimport java.awt.geom.*;\nimport java.math.*;\nimport java.text.*;\nimport java.math.BigInteger.*;\nimport java.util.Arrays; \n\npublic class   CF111111\n{\n  BufferedReader in;\n  StringTokenizer as;\n  int nums[],nums2[];\n  int[] nums1[];\n  boolean con = true;\n \n  ArrayList < Integer >  ar = new ArrayList < Integer >();\n  ArrayList < Integer >  fi = new ArrayList < Integer >();\n  Map<Integer,Integer > map = new HashMap<Integer, Integer>();\n  public static void main (String[] args)\n  {\n    new CF111111  ();\n  }\n  \n  public int GCD(int a, int b) {\n    if (b==0) return a;\n    return GCD(b,a%b);\n  }\n  \n  public int LIS(int arr[])\n  {\n    int n = arr.length;\n    int sun[] = new int [n];\n    int cur = 0;\n    for(int x = 0;x<n;x++)\n    {\n      int temp = Arrays.binarySearch(sun,0,cur,arr[x]);\n      if(temp < 0)\n        temp = -temp -1;\n      sun[temp] = arr[x];\n      if(temp == cur)\n        cur++;\n    }\n    return cur;\n    \n  }\n  \n  \n  public void no()\n  {\n    System.out.println(\"NO\");\n    System.exit(0);\n  }\n  \n  public CF111111  ()\n  {\n    try\n    {\n      \n      in = new BufferedReader (new InputStreamReader (System.in));\n      int a = nextInt();\n      nums = new int [a];\n      int max = -1;\n      int index = -1;\n     for(int x = 0;x<a;x++)\n     {\n       nums[x] = nextInt();\n       if(nums[x] > max)\n       {\n         max = nums[x];\n         index = x;\n       }\n     }\n      int lindex = index-1;\n      int rindex = index+1;\n      int done = 1;\n      int top = max;\n      for(;;)\n      {\n        done++;\n      //  System.out.println(done + \" \" + lindex + \" \" + rindex);\n        if(lindex < 0)\n        {\n           if(nums[rindex] > top)\n           {\n             no();\n           }\n           else\n             top = nums[rindex];\n           rindex++;\n        }\n        else if(rindex >= a)\n        {\n          if(nums[lindex] > top)\n            no();\n          else\n            top = nums[lindex];\n          lindex--;\n        }\n        else\n        {\n          if(nums[lindex] > top || nums[rindex] > top)\n            no();\n          else\n          {\n            if(nums[lindex] > nums[rindex])\n            {\n              top = nums[lindex];\n              lindex--;\n            }\n            else\n            {\n              top = nums[rindex];\n              rindex++;\n            }\n          }\n        }\n        if(done == a)\n        {\n          System.out.println(\"YES\");\n          System.exit(0);\n        }\n      }\n    }\n    catch(IOException e)\n    {\n\n    }\n  }\n  \n  \n  \n  \n  \n  \n  \n  String next () throws IOException\n  {\n    while (as == null || !as.hasMoreTokens ())\n    {\n      as = new StringTokenizer (in.readLine ().trim ());\n    }\n    \n    \n    return as.nextToken ();\n  }\n  \n  \n  \n  long nextLong () throws IOException\n  {\n    return Long.parseLong (next ());\n  }\n  \n  \n  int nextInt () throws IOException\n  {\n    return Integer.parseInt (next ());\n  }\n  \n  \n  double nextDouble () throws IOException\n  {\n    return Double.parseDouble (next ());\n  }\n  \n  \n  String nextLine () throws IOException\n  {\n    return in.readLine ().trim ();\n  }\n}", "complexity": "linear", "from": "CorCod", "problem": 295, "index": 295}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 296, "index": 296}
{"src": "\n// Java program to find inorder successor of a node \nclass\nSolution \n{ \n// A Binary Tree Node \n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n// Temporary node for case 2 \nstatic\nNode temp = \nnew\nNode(); \n\n// Utility function to create a new tree node \nstatic\nNode newNode(\nint\ndata) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n// function to find left most node in a tree \nstatic\nNode leftMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.left != \nnull\n) \n\nnode = node.left; \n\nreturn\nnode; \n} \n\n// function to find right most node in a tree \nstatic\nNode rightMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.right != \nnull\n) \n\nnode = node.right; \n\nreturn\nnode; \n} \n\n// recursive function to find the Inorder Scuccessor \n// when the right child of node x is null \nstatic\nNode findInorderRecursive(Node root, Node x ) \n\n{ \n\nif\n(root==\nnull\n) \n\nreturn\nnull\n; \n\n\nif\n(root==x || (temp = findInorderRecursive(root.left,x))!=\nnull\n|| \n\n(temp = findInorderRecursive(root.right,x))!=\nnull\n) \n\n{ \n\nif\n(temp!=\nnull\n) \n\n{ \n\nif\n(root.left == temp) \n\n{ \n\nSystem.out.print( \n\"Inorder Successor of \"\n+x.data); \n\nSystem.out.print( \n\" is \"\n+ root.data + \n\"\\n\"\n); \n\nreturn\nnull\n; \n\n} \n\n} \n\n\nreturn\nroot; \n\n} \n\n\nreturn\nnull\n; \n} \n\n// function to find inorder successor of \n// a node \nstatic\nvoid\ninorderSuccesor(Node root, Node x) \n\n{ \n\n// Case1: If right child is not null \n\nif\n(x.right != \nnull\n) \n\n{ \n\nNode inorderSucc = leftMostNode(x.right); \n\nSystem.out.print(\n\"Inorder Successor of \"\n+x.data+\n\" is \"\n); \n\nSystem.out.print(inorderSucc.data+\n\"\\n\"\n); \n\n} \n\n\n// Case2: If right child is null \n\nif\n(x.right == \nnull\n) \n\n{ \n\nint\nf = \n0\n; \n\n\nNode rightMost = rightMostNode(root); \n\n\n// case3: If x is the right most node \n\nif\n(rightMost == x) \n\nSystem.out.print(\n\"No inorder successor! Right most node.\\n\"\n); \n\nelse\n\nfindInorderRecursive(root, x); \n\n} \n} \n\n// Driver program to test above functions \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n// Let's con the binary tree \n\n// as shown in above diagram \n\n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\n// Case 1 \n\ninorderSuccesor(root, root.right); \n\n\n// case 2 \n\ninorderSuccesor(root, root.left.left); \n\n\n// case 3 \n\ninorderSuccesor(root, root.right.right); \n\n} \n} \n//contributed by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 297, "index": 297}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class tr {\n\tstatic int[][] ad;\n    static boolean []vis;\n    static int []goods;\n    static int[][]sol;\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n=sc.nextInt();\n\t\tint []a=new int [n];\n\t\tint max=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=sc.nextInt();\n\t\tStack<Integer> s=new Stack<>();\n\t\tboolean f=true;\n\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\tmax=Math.max(max,a[i]);\n\t\t\t\t\tif(!s.isEmpty() && a[i]>s.peek())\n\t\t\t\t\t\tf=false;\n\t\t\t\t\ts.push(a[i]);\n\t\t\t\t\twhile(!s.isEmpty()) {\n\t\t\t\t\t\tint high=s.pop();\n\t\t\t\t\t\tif(s.isEmpty() || s.peek()!=high) {\n\t\t\t\t\t\t\ts.push(high);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\t}\n\t\t\t\t//\tSystem.out.println(s+\" \"+max);\n\t\t\t\t}\n\t\t\t\t//System.out.println(f+\" \"+max);\n\t\t\t\tif(f && s.size()==0)\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\telse if(f && s.size()==1 && s.peek()==max)\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\telse\n\t\t\t\t\tout.println(\"NO\");\n\t\t out.flush();\n\t}\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tint a;\n\t\tint b;\n\n\t\tpair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\treturn  o.a-a ;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 298, "index": 298}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = 0;\n\t\tString inp = s.nextLine();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchar k = inp.charAt(i);\n\t\t\tif (k == '+')\n\t\t\t\tans++;\n\t\t\tif (k == '-') {\n\t\t\t\tif (ans>0)\n\t\t\t\t\tans--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 299, "index": 299}
{"src": "\n// Java program to check if Binary tree is sum tree or not \n\n\n/* A binary tree node has data, left child and right child */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right, nextRight; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = nextRight = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* Utility function to check if the given node is leaf or not */\n\nint\nisLeaf(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nreturn\n1\n; \n\nreturn\n0\n; \n\n} \n\n\n/* returns 1 if SumTree property holds for the given \n\ntree */\n\nint\nisSumTree(Node node) \n\n{ \n\nint\nls; \n// for sum of nodes in left subtree \n\nint\nrs; \n// for sum of nodes in right subtree \n\n\n/* If node is NULL or it's a leaf node then \n\nreturn true */\n\nif\n(node == \nnull\n|| isLeaf(node) == \n1\n) \n\nreturn\n1\n; \n\n\nif\n(isSumTree(node.left) != \n0\n&& isSumTree(node.right) != \n0\n) \n\n{ \n\n// Get the sum of nodes in left subtree \n\nif\n(node.left == \nnull\n) \n\nls = \n0\n; \n\nelse\nif\n(isLeaf(node.left) != \n0\n) \n\nls = node.left.data; \n\nelse\n\nls = \n2\n* (node.left.data); \n\n\n// Get the sum of nodes in right subtree \n\nif\n(node.right == \nnull\n) \n\nrs = \n0\n; \n\nelse\nif\n(isLeaf(node.right) != \n0\n) \n\nrs = node.right.data; \n\nelse\n\nrs = \n2\n* (node.right.data); \n\n\n/* If root's data is equal to sum of nodes in left \n\nand right subtrees then return 1 else return 0*/\n\nif\n((node.data == rs + ls)) \n\nreturn\n1\n; \n\nelse\n\nreturn\n0\n; \n\n} \n\n\nreturn\n0\n; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n26\n); \n\ntree.root.left = \nnew\nNode(\n10\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n3\n); \n\n\nif\n(tree.isSumTree(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree is a sum tree\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree is not a sum tree\"\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 300, "index": 300}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            String s2[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int m=Integer.parseInt(s1[1]);\n            int a[]=new int[n];\n            int b[]=new int[n];\n            int c[]=new int[n];\n            int d[]=new int[n];\n            HashSet<Integer> hs=new HashSet<Integer>();\n            hs.add(0);\n            hs.add(m);\n            int max=0;\n            for(int i=0;i<n;i++)\n            {\n                  a[i]=Integer.parseInt(s2[i]);\n                  if(i%2==0)\n                   b[i]=1;\n                  hs.add(a[i]);\n            }\n            \n            c[0]=a[0];\n            for(int i=1;i<n;i++)\n            {\n                  if(b[i]==0)\n                   c[i]=c[i-1];\n                  else\n                   c[i]=c[i-1]+a[i]-a[i-1];\n            }\n            \n            if(b[n-1]==0)\n             d[n-1]=m-a[n-1];\n            for(int i=n-2;i>=0;i--)\n            {\n                  if(b[i]==1)\n                   d[i]=d[i+1];\n                  else\n                   d[i]=d[i+1]+a[i+1]-a[i];\n            }\n            \n            max=c[n-1];\n            if(b[n-1]==0)\n             max+=m-a[n-1];\n            //System.out.println(max);\n            for(int i=n-1;i>=0;i--)\n            {\n                  int u=a[i]-1;\n                  int v=a[i]+1;\n                  if(!hs.contains(u))\n                  {\n                        if(b[i]==0)\n                        {\n                             int r=1+m-a[i]-d[i]+c[i-1];\n                             max=Math.max(max,r);\n                        }\n                        else\n                        {\n                              int l=0;\n                              if(i>0)\n                               l=a[i-1];\n                              int r=c[i]-1+m-a[i]-d[i];\n                              max=Math.max(max,r);\n                        }\n                  }\n                  \n                  if(!hs.contains(v))\n                  {\n                        if(b[i]==0)\n                        {\n                           if(i==n-1)\n                           {\n                              int r=c[i]+1;\n                              max=Math.max(max,r);\n                           }\n                           else\n                           {\n                               int r=c[i]+1+m-a[i+1]-d[i+1];\n                               max=Math.max(max,r);\n                           }\n                        }\n                        else\n                        {\n                                if(i==n-1)\n                                {\n                                   int r=c[i]+m-a[i]-1;\n                                   max=Math.max(max,r);\n                                }\n                                else\n                                {\n                                    int r=c[i]+m-a[i+1]-d[i+1]+a[i+1]-1-a[i];  \n                                    max=Math.max(max,r);\n                                }\n                        }\n                  }\n            }\n            \n            System.out.println(max);\n      }\n}", "complexity": "linear", "from": "CorCod", "problem": 301, "index": 301}
{"src": "import java.util.*;\npublic class Kello\n{\n    public static void  main(String args[])\n    {\n        Scanner sc =new Scanner(System.in);\n        int n,q,m,max,inp,k,i;\n        long in_q;\n        n=sc.nextInt();\n        q=sc.nextInt();\n        int a[]=new int[n-1];\n        int b[]=new int[n-1];\n        int c[]=new int[n-1];\n        max=sc.nextInt();\n        for(i=0;i<n-1;i++)\n        {\n            inp=sc.nextInt();\n            a[i]=max;\n            b[i]=inp;\n            if(inp>max)\n            {\n                c[i]=max;\n             max=inp;\n        }\n        else\n        c[i]=inp;\n    }\n   // display(a,b);\n        for(i=0;i<q;i++)\n        {\n            in_q=sc.nextLong();\n            if(in_q<n)\n            System.out.println(a[(int)in_q-1]+\" \"+b[(int)in_q-1]);\n          else   {\n          k=(int)(in_q %(n-1))-1;\n          if(k==-1)\n          k=n-2;\n          System.out.println(max+\" \"+c[k]);\n            }\n        }\n    }\n    public static void display(int a[],int b[])\n    {\n        int i;\n        for(i=0;i<a.length;i++)\n        System.out.println(a[i]+\" \"+b[i]);\n}\n}\n\n              ", "complexity": "linear", "from": "CorCod", "problem": 302, "index": 302}
{"src": "import java.util.*;\nimport java.io.*;\npublic class programA {\n   \tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint d = Integer.parseInt(st.nextToken());\n\t\tint arr[] = new int[n];\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tarr[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tint s= 2;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tlong dis = (long)2*d;\n\t\t\tlong dis2 = Math.abs(arr[i]-arr[i+1]);\n\t\t\tif(dis2 == dis)s++;\n\t\t\telse if (dis2 > dis)s+=2;\n\t\t}\n\t\tSystem.out.println(s);\n   \t\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 303, "index": 303}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class DeathNote {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\tint x = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx += a[i];\n\t\t\tsb.append(\" \" + (x/m));\n\t\t\tx %= m;\n\t\t}\n\t\t\n\t\tSystem.out.println(sb.toString().substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 304, "index": 304}
{"src": "\n// Java program to find intersection of \n// two sorted arrays \n\nclass\nFindIntersection \n{ \n\n/* Function prints Intersection of arr1[] and arr2[] \n\nm is the number of elements in arr1[] \n\nn is the number of elements in arr2[] */\n\nstatic\nvoid\nprintIntersection(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\ni++; \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nj++; \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintIntersection(arr1, arr2, m, n); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 305, "index": 305}
{"src": "import java.util.Scanner;\n\n/**\n *\n * @author User\n */\npublic class Code {\n\n   static int [] reverse(int a[]) \n    { \n        int[] b = new int[a.length]; \n       int j = 0  ;\n        for (int i = a.length-1; i >= 0; i--) {\n            b[i] = a[j] ; \n            j++;\n        }\n        return b ;\n    }\n    public static void main(String[] args) {\n        int pas ; \n        int top ; \n        Scanner in = new Scanner(System.in) ; \n        pas= in.nextInt(); \n        top=in.nextInt() ; \n        int a [] = new int[pas] ; \n        int b [] = new int[pas] ; \n        \n        for (int i = 0; i < pas; i++) {\n            a[i] = in.nextInt() ; \n            b[i] = in.nextInt() ; \n           \n         }\n       a =  reverse(a) ;\n        b = reverse(b) ;\n        int ftime =0 ; \n        int t;\n        int po = top ; \n        for (int i = 0; i < pas; i++) {\n             ftime+=(po-a[i]) ; \n            t = Math.max(b[i]-ftime, 0) ; \n            ftime+=t ; \n            po = a[i] ; \n           \n        }\n        if(po!=0) ftime+=po ;\n        System.out.println(ftime);\n        \n    }\n    \n}\n", "complexity": "linear", "from": "CorCod", "problem": 306, "index": 306}
{"src": "import java.util.Scanner;\n\npublic class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 307, "index": 307}
{"src": "\n// O(n) solution for finding smallest subarray with sum \n// greater than x \n\nclass\nSmallestSubArraySum \n{ \n\n// Returns length of smallest subarray with sum greater than x. \n\n// If there is no subarray with given sum, then returns n+1 \n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n// Initialize current sum and minimum length \n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n// Initialize starting and ending indexes \n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n// Keep adding array elements while current sum \n\n// is smaller than x \n\nwhile\n(curr_sum <= x && end < n) \n\ncurr_sum += arr[end++]; \n\n\n// If current sum becomes greater than x. \n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n// Update minimum length if needed \n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n// remove starting elements \n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 308, "index": 308}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n\tstatic boolean canWinFromOneMove(char []s,int k) {\n\t\tint prefix=0;\n\t\tint n=s.length;\n\t\tfor(int i=0;i<n && s[i]==s[0];i++)\n\t\t\tprefix++;\n\t\tint suffix=0;\n\t\tfor(int i=n-1;i>=0 && s[i]==s[n-1];i--)\n\t\t\tsuffix++;\n\t\t\n\t\treturn s[0]==s[n-1] && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;\n\t\t\t\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n=sc.nextInt(),k=sc.nextInt();\n\t\tchar []s=sc.next().toCharArray();\n\t\tif(canWinFromOneMove(s, k)) {\n\t\t\tSystem.out.println(\"tokitsukaze\");\n\t\t\treturn;\n\t\t}\n\t\tint []suff=new int [n+1];\n\t\tsuff[n-1]=1;\n\t\tfor(int i=n-2;i>=0;i--) {\n\t\t\tsuff[i]=1+(s[i+1]==s[i]?suff[i+1]:0);\n\t\t}\n\t\tfor(int i=n-2;i>=0;i--)\n\t\t\tsuff[i]=Math.max(suff[i], suff[i+1]);\n\t\tint max=0,curr=0;\n\t\tboolean draw=false;\n\t\tint ones=0;\n\t\tfor(int i=0;i+k<=n;i++) {\n\t\t\t\n\t\t\t// one\n\t\t\tint prefix=ones==i?k+ones:max;\n\t\t\tint suffix=i+k==n?k:s[i+k]=='1' && suff[i+k]==n-(i+k)?k+suff[i+k]:suff[i+k];\n\t\t\tchar first=i==0?'1':s[0],last=i+k==n?'1':s[n-1];\n\t\t\tboolean zero=first==last && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;\n\t\t\t// zero\n\t\t\t prefix=ones==0?k+ones:max;\n\t\t\t suffix=i+k==n?k:s[i+k]=='0' && suff[i+k]==n-(i+k)?k+suff[i+k]:suff[i+k];\n\t\t\t first=i==0?'0':s[0];\n\t\t\t last=i+k==n?'0':s[n-1];\n\t\t\tboolean one=first==last && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;\n\t\t\tif(!zero || !one) {\n//\t\t\t\tSystem.err.println(i+1);\n\t\t\t\tdraw=true;\n\t\t\t}\n\t\t\tif(s[i]=='1')\n\t\t\t\tones++;\n\t\t\tif(i>0 && s[i]==s[i-1] )\n\t\t\t\tcurr++;\n\t\t\telse\n\t\t\t\tcurr=1;\n\t\t\tmax=Math.max(max, curr);\n\t\t}\n\t\tout.println(draw?\"once again\":\"quailty\");\n\t\tout.close();\n\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tboolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "complexity": "linear", "from": "CorCod", "problem": 309, "index": 309}
{"src": "/**\n * Created by Baelish on 7/30/2018.\n */\n\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            //g[a]++;\n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       /* public char nextChar() {\n            return (char)skip();\n        }*/\n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        /*private char buff[] = new char[1005];\n        public char[] nextCharArray(){\n            int b = skip(), p = 0;\n            while(!(isSpaceChar(b))){\n                buff[p++] = (char)b;\n                b = readByte();\n            }\n            return Arrays.copyOf(buff, p);\n        }*/\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 310, "index": 310}
{"src": "\n// Java implementation to count number \n// of ways to tile a floor of size \n// n x m using 1 x m tiles \nimport\njava.io.*; \n\nclass\nGFG { \n\n// function to count the total number of ways \n\nstatic\nint\ncountWays(\nint\nn, \nint\nm) \n\n{ \n\n// table to store values \n\n// of subproblems \n\nint\ncount[] = \nnew\nint\n[n + \n1\n]; \n\ncount[\n0\n] = \n0\n; \n\n\n// Fill the table upto value n \n\nint\ni; \n\nfor\n(i = \n1\n; i <= n; i++) { \n\n// recurrence relation \n\nif\n(i > m) \n\ncount[i] = count[i - \n1\n] + count[i - m]; \n\n\n// base cases \n\nelse\nif\n(i < m) \n\ncount[i] = \n1\n; \n\n\n// i = = m \n\nelse\n\ncount[i] = \n2\n; \n\n} \n\n\n// required number of ways \n\nreturn\ncount[n]; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n7\n; \n\nint\nm = \n4\n; \n\nSystem.out.println(\n\"Number of ways = \"\n\n+ countWays(n, m)); \n\n} \n} \n\n// This code is contributed by vt_m. ", "complexity": "linear", "from": "CorCod", "problem": 311, "index": 311}
{"src": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            while(s.length()<n){\n                s=s+s;\n            }\n            String s1=new String();\n            for(int i=0;i<n;i++){\n                s1=s1+Character.toString(s.charAt(i));\n            }\n            System.out.println(s1);\n        }\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 312, "index": 312}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[] ar = new int[200];\n\t\t\n\t\tString str = in.next();\n\t\tfor(int i = 0; i < str.length(); i++)\n\t\t\tar[ str.charAt(i) ]++;\n\t\t\t\n\t\tint ans = 100000;\n\t\t\n\t\tfor(int i = 'A'; i < 'A' + m; i++)\n\t\t\tans = Math.min(ans, ar[i]);\n\t\tans *= m;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 313, "index": 313}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class TwoGram {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        String s = sc.next();\n\n        HashMap <String, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n - 1; i++) {\n            String curr = s.substring(i, i + 2);\n\n            if (hm.containsKey(curr)) {\n                hm.put(curr, hm.get(curr) + 1);\n            } else {\n                hm.put(curr, 1);\n            }\n        }\n\n        String ans = \"\";\n        int currMax = 0;\n        for (String twoGram : hm.keySet()) {\n            if (hm.get(twoGram) > currMax) {\n                ans = twoGram;\n                currMax = hm.get(twoGram);\n            }\n        }\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 314, "index": 314}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Fingerprints {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tset.add(nextInt());\n\t\t\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (set.contains(a[i]))\n\t\t\t\ts += \" \" + a[i];\n\t\t\n\t\tSystem.out.println(s.length() == 0 ? s : s.substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 315, "index": 315}
{"src": "\n// Java program to Move All -ve Element At End \n// Without changing order Of Array Element \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n\n// Moves all -ve element to end of array in \n\n// same order. \n\nstatic\nvoid\nsegregateElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n// Create an empty array to store result \n\nint\ntemp[] = \nnew\nint\n[n]; \n\n\n// Traversal array and store +ve element in \n\n// temp array \n\nint\nj = \n0\n; \n// index of temp \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] >= \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n// If array contains all positive or all \n\n// negative. \n\nif\n(j == n || j == \n0\n) \n\nreturn\n; \n\n\n// Store -ve element in temp array \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n// Copy contents of temp[] to arr[] \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = { \n1\n, -\n1\n, -\n3\n, -\n2\n, \n7\n, \n5\n, \n11\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nsegregateElements(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "linear", "from": "CorCod", "problem": 316, "index": 316}
{"src": "\n// Java program for different tree traversals \n\n/* Class containing left and right child of current \n\nnode and key value*/\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\nkey = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\n// Root of Binary Tree \n\nNode root; \n\n\nBinaryTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n/* Given a binary tree, print its nodes according to the \n\n\"bottom-up\" postorder traversal. */\n\nvoid\nprintPostorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n// first recur on left subtree \n\nprintPostorder(node.left); \n\n\n// then recur on right subtree \n\nprintPostorder(node.right); \n\n\n// now deal with the node \n\nSystem.out.print(node.key + \n\" \"\n); \n\n} \n\n\n/* Given a binary tree, print its nodes in inorder*/\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first recur on left child */\n\nprintInorder(node.left); \n\n\n/* then print the data of node */\n\nSystem.out.print(node.key + \n\" \"\n); \n\n\n/* now recur on right child */\n\nprintInorder(node.right); \n\n} \n\n\n/* Given a binary tree, print its nodes in preorder*/\n\nvoid\nprintPreorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first print data of node */\n\nSystem.out.print(node.key + \n\" \"\n); \n\n\n/* then recur on left sutree */\n\nprintPreorder(node.left); \n\n\n/* now recur on right subtree */\n\nprintPreorder(node.right); \n\n} \n\n\n// Wrappers over above recursive functions \n\nvoid\nprintPostorder() { printPostorder(root); } \n\nvoid\nprintInorder() { printInorder(root); } \n\nvoid\nprintPreorder() { printPreorder(root); } \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\n\nSystem.out.println(\n\"Preorder traversal of binary tree is \"\n); \n\ntree.printPreorder(); \n\n\nSystem.out.println(\n\"\\nInorder traversal of binary tree is \"\n); \n\ntree.printInorder(); \n\n\nSystem.out.println(\n\"\\nPostorder traversal of binary tree is \"\n); \n\ntree.printPostorder(); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 317, "index": 317}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class C {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        // Scanner scan = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(bf.readLine());\n        int counter = 0;\n        for(int i=0; i<2*n/3; i++) System.out.println(\"0 \" + i);\n        for(int i=0; i<n-2*n/3; i++) System.out.println(\"3 \" + (2*i+1));\n\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 318, "index": 318}
{"src": "import java.util.*;\nimport java.io.*;\npublic class C{\n    static PrintWriter out;\n    static InputReader in;\n    public static void main(String args[]){\n        out = new PrintWriter(System.out);\n        in = new InputReader();\n        new C();\n        out.flush(); out.close();\n    }   \n    C(){\n       int w = solve();\n       out.print(w == 0 ? \"sjfnb\" : \"cslnb\");\n    }\n    int n;\n    long a[];\n    int solve(){\n        n = in.nextInt(); a = new long[n];\n        long sum = 0;\n        for(int i = 0; i < n; i++)sum += a[i] = in.nextLong();\n        if(sum == 0){\n            return 1;\n        }\n        Arrays.sort(a);\n        int c = 0, c0 = 0; long p = -1, max = 0;\n        int f = 0;\n        long t = -1; int pp = -1;\n        for(int i = 0; i < n; i++){\n            if(a[i] == p){\n                c++;\n            }else{\n                if(p == 0)c0 = c;\n                if(c >= 2){f++; t = p; pp = i - 2;}\n                max = Math.max(max, c);\n                p = a[i];\n                c = 1;\n            }\n        }\n        max = Math.max(max, c);\n        sum = 0;\n        if(c >= 2){f++; t = p; pp = n - 2;}\n        if(max > 2 || c0 > 1 || f > 1)return 1;\n        if(f == 1){\n            long v = Arrays.binarySearch(a, t - 1);\n            if(v >= 0)return 1;\n            a[pp]--; sum = 1;\n        }\n\n        p = -1;\n        for(int i = 0; i < n; i++){\n            sum += a[i] - (p + 1);\n            a[i] = p + 1;\n            p = a[i];\n        }\n\n        return 1 - (int)(sum % 2);\n    }\n    public static class InputReader{\n        BufferedReader br;\n        StringTokenizer st;\n        InputReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        public String next(){\n            while(st == null || !st.hasMoreTokens()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch(IOException e){}\n            }\n            return st.nextToken();\n        }\n    }\n}\n        ", "complexity": "linear", "from": "CorCod", "problem": 319, "index": 319}
{"src": "\n// Java program to print a string with \n// no adjacent duplicates by doing \n// minimum changes to original string \nimport\njava.util.*; \nimport\njava.lang.*; \n\npublic\nclass\nGfG{ \n\n\n// Function to print simple string \n\npublic\nstatic\nString noAdjacentDup(String s1) \n\n{ \n\nint\nn = s1.length(); \n\nchar\n[] s = s1.toCharArray(); \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n// If any two adjacent \n\n// characters are equal \n\nif\n(s[i] == s[i - \n1\n]) \n\n{ \n\n// Initialize it to 'a' \n\ns[i] = \n'a'\n; \n\n\n// Traverse the loop until it \n\n// is different from the left \n\n// and right letter. \n\nwhile\n(s[i] == s[i - \n1\n] || \n\n(i + \n1\n< n && s[i] == s[i + \n1\n])) \n\ns[i]++; \n\n\ni++; \n\n} \n\n} \n\nreturn\n(\nnew\nString(s)); \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\n\nString s = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(noAdjacentDup(s)); \n\n\n} \n\n} \n\n/* This code is contributed by Sagar Shukla */", "complexity": "linear", "from": "CorCod", "problem": 320, "index": 320}
{"src": "import java.io.*;\nimport java.util.*;\npublic class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        String st[]=br.readLine().split(\" \");\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=Integer.parseInt(st[i]);\n\n        int max=0;\n        for(int i=0;i<n;i++)\n        {\n            if(i!=0 && a[i]>a[max])\n                max=i;\n        }\n       // System.out.println(a[max]);\n        int maxi=max;\n        int i=max-1;\n        while(i>=0)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i--;\n        }\n        max=maxi;\n        i=max+1;\n        while(i<n)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i++;\n        }\n        System.out.println(\"YES\");\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 321, "index": 321}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class SequenceTransformation {\n    void solve() {\n        int p = 1, n = in.nextInt();\n        while (n > 0) {\n            if (n == 1) {\n                out.print(p + \" \");\n                break;\n            }\n            if (n == 2) {\n                out.print(p + \" \");\n                out.print(2 * p + \" \");\n                break;\n            }\n            if (n == 3) {\n                out.print(p + \" \");\n                out.print(p + \" \");\n                out.print(3 * p + \" \");\n                break;\n            }\n            for (int i = 0; i < (n + 1) / 2; i++) {\n                out.print(p + \" \");\n            }\n            p *= 2;\n            n /= 2;\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new SequenceTransformation().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 322, "index": 322}
{"src": "\n// Java implementation of alternate vowel and \n// consonant string \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// 'ch' is vowel or not \nstatic\nboolean\nisVowel(\nchar\nch) \n{ \n\nif\n(ch == \n'a'\n|| ch == \n'e'\n|| ch == \n'i'\n|| \n\nch == \n'o'\n|| ch ==\n'u'\n) \n\nreturn\ntrue\n; \n\nreturn\nfalse\n; \n} \n\n// create alternate vowel and consonant string \n// str1[0...l1-1] and str2[start...l2-1] \nstatic\nString createAltStr(String str1, String str2, \n\nint\nstart, \nint\nl) \n{ \n\nString finalStr = \n\"\"\n; \n\n\n// first adding character of vowel/consonant \n\n// then adding character of consonant/vowel \n\nfor\n(\nint\ni = \n0\n, j = start; j < l; i++, j++) \n\nfinalStr = (finalStr + str1.charAt(i)) + \n\nstr2.charAt(j); \n\nreturn\nfinalStr; \n} \n\n// function to find the required \n// alternate vowel and consonant string \nstatic\nString findAltStr(String str) \n{ \n\nint\nnv = \n0\n, nc = \n0\n; \n\nString vstr = \n\"\"\n, cstr = \n\"\"\n; \n\nint\nl = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\n{ \n\nchar\nch = str.charAt(i); \n\n\n// count vowels and updaye vowel string \n\nif\n(isVowel(ch)) \n\n{ \n\nnv++; \n\nvstr = vstr + ch; \n\n} \n\n\n// count consonants and update consonant \n\n// string \n\nelse\n\n{ \n\nnc++; \n\ncstr = cstr + ch; \n\n} \n\n} \n\n\n// no such string can be formed \n\nif\n(Math.abs(nv - nc) >= \n2\n) \n\nreturn\n\"no such string\"\n; \n\n\n// remove first character of vowel string \n\n// then create alternate string with \n\n// cstr[0...nc-1] and vstr[1...nv-1] \n\nif\n(nv > nc) \n\nreturn\n(vstr.charAt(\n0\n) + createAltStr(cstr, vstr, \n1\n, nv)); \n\n\n// remove first character of consonant string \n\n// then create alternate string with \n\n// vstr[0...nv-1] and cstr[1...nc-1] \n\nif\n(nc > nv) \n\nreturn\n(cstr.charAt(\n0\n) + createAltStr(vstr, cstr, \n1\n, nc)); \n\n\n// if both vowel and consonant \n\n// strings are of equal length \n\n// start creating string with consonant \n\nif\n(cstr.charAt(\n0\n) < vstr.charAt(\n0\n)) \n\nreturn\ncreateAltStr(cstr, vstr, \n0\n, nv); \n\n\n// start creating string with vowel \n\nreturn\ncreateAltStr(vstr, cstr, \n0\n, nc); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nString str = \n\"geeks\"\n; \n\nSystem.out.println(findAltStr(str)); \n} \n} \n\n// This code is contributed by \n// Shashank_Sharma ", "complexity": "linear", "from": "CorCod", "problem": 323, "index": 323}
{"src": "\nimport java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\n\n// _ h _ r _ t r _\n// _ t _ t _ s t _\n\n\n\n\npublic class TaskA implements Runnable {\n    long m = (int)1e9+7;\n    PrintWriter w;\n    InputReader c;\n    final int MAXN = (int)1e6 + 100;\n    public void run() {\n        c = new InputReader(System.in);\n        w = new PrintWriter(System.out);\n\n        int n = c.nextInt(), hamming_distance = 0;\n        char[] s = c.next().toCharArray(), t = c.next().toCharArray();\n        HashMap<Character, HashSet<Character>> replace = new HashMap<>();\n        HashMap<Character, Integer> map = new HashMap<>();\n\n        for(int i=0;i<n;++i) if(s[i] != t[i]) {\n            HashSet<Character> temp;\n            if(replace.containsKey(s[i])){\n                temp = replace.get(s[i]);\n                temp.add(t[i]);\n            } else {\n                temp = new HashSet<>();\n                temp.add(t[i]);\n            }\n            map.put(s[i],i);\n            replace.put(s[i], temp);\n            hamming_distance++;\n        }\n\n        int l = -1, r = -1;\n        boolean global_check = false;\n        for(int i=0;i<n;i++) if(s[i] != t[i]) {\n            if(replace.containsKey(t[i])) {\n                HashSet<Character> indices = replace.get(t[i]);\n                int ind = map.get(t[i]);\n                l = i + 1;\n                r = ind + 1;\n                if (indices.contains(s[i])) {\n                    hamming_distance -= 2;\n                    global_check = true;\n                    break;\n                }\n            }\n            if(global_check) break;\n        }\n\n        if(!global_check && l!=-1) hamming_distance--;\n        else if(global_check){\n            for(int i=0;i<n;i++) {\n                if(t[i] == s[l-1] && s[i] == t[l-1]){\n                    r = i + 1;\n                    break;\n                }\n            }\n        }\n        w.println(hamming_distance);\n        w.println(l+\" \"+r);\n\n        w.close();\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static void sortbyColumn(int arr[][], int col){\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f)    {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    public void printArray(int[] a){\n        for(int i=0;i<a.length;i++)\n            w.print(a[i]+\" \");\n        w.println();\n    }\n    public int[] scanArrayI(int n){\n        int a[] = new int[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextInt();\n        return a;\n    }\n    public long[] scanArrayL(int n){\n        long a[] = new long[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextLong();\n        return a;\n    }\n    public void printArray(long[] a){\n        for(int i=0;i<a.length;i++)\n            w.print(a[i]+\" \");\n        w.println();\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new TaskA(),\"TaskA\",1<<26).start();\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 324, "index": 324}
{"src": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     //if(!set2.contains(b)){\n                            //set2.add(b);\n                     //}else{\n                       //     System.out.println(2);\n                         //   return;\n                     //}\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "complexity": "linear", "from": "CorCod", "problem": 325, "index": 325}
{"src": "\n// A dynamic programming based Java program for partition problem \nimport\njava.io.*; \n\nclass\nPartition { \n\n\n// Returns true if arr[] can be partitioned in two subsets of \n\n// equal sum, otherwise false \n\nstatic\nboolean\nfindPartition (\nint\narr[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n; \n\nint\ni, j; \n\n\n// Caculcate sun of all elements \n\nfor\n(i = \n0\n; i < n; i++) \n\nsum += arr[i]; \n\n\nif\n(sum%\n2\n!= \n0\n) \n\nreturn\nfalse\n; \n\n\nboolean\npart[][]=\nnew\nboolean\n[sum/\n2\n+\n1\n][n+\n1\n]; \n\n\n// initialize top row as true \n\nfor\n(i = \n0\n; i <= n; i++) \n\npart[\n0\n][i] = \ntrue\n; \n\n\n// initialize leftmost column, except part[0][0], as 0 \n\nfor\n(i = \n1\n; i <= sum/\n2\n; i++) \n\npart[i][\n0\n] = \nfalse\n; \n\n\n// Fill the partition table in botton up manner \n\nfor\n(i = \n1\n; i <= sum/\n2\n; i++) \n\n{ \n\nfor\n(j = \n1\n; j <= n; j++) \n\n{ \n\npart[i][j] = part[i][j-\n1\n]; \n\nif\n(i >= arr[j-\n1\n]) \n\npart[i][j] = part[i][j] || \n\npart[i - arr[j-\n1\n]][j-\n1\n]; \n\n} \n\n} \n\n\n/* // uncomment this part to print table \n\nfor (i = 0; i <= sum/2; i++) \n\n{ \n\nfor (j = 0; j <= n; j++) \n\nprintf (\"%4d\", part[i][j]); \n\nprintf(\"\\n\"); \n\n} */\n\n\nreturn\npart[sum/\n2\n][n]; \n\n} \n\n\n/*Driver function to check for above function*/\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n3\n, \n1\n, \n1\n, \n2\n, \n2\n,\n1\n}; \n\nint\nn = arr.length; \n\nif\n(findPartition(arr, n) == \ntrue\n) \n\nSystem.out.println(\n\"Can be divided into two \"\n\n\"subsets of equal sum\"\n); \n\nelse\n\nSystem.out.println(\n\"Can not be divided into\"\n\n\" two subsets of equal sum\"\n); \n\n\n} \n} \n/* This code is contributed by Devesh Agrawal */", "complexity": "linear", "from": "CorCod", "problem": 326, "index": 326}
{"src": "import java.util.*;\n\n\npublic class Main {\n    static int n=5;\n    static int[] arr=new int[5];\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n        int arr[]=new int[n];\n        for (int i=0;i<n;i++)\n        {\n            arr[i]=sc.nextInt();\n        }\n        for (int i=0;i<n;i++)\n        {\n            if (arr[i]>=0)\n            {\n                arr[i]=-arr[i]-1;\n            }\n        }\n        if (n%2!=0)\n        {\n            int min=0;\n            for (int i=1;i<n;i++)\n            {\n                if (arr[i]<arr[min])\n                    min=i;\n            }\n            arr[min]=-arr[min]-1;\n        }\n        for (int x:arr)\n        {\n            System.out.print(x + \" \");\n        }\n\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 327, "index": 327}
{"src": "\n// Java program to find the all full nodes in \n// a given binary tree \npublic\nclass\nFullNodes { \n\n\n// Traverses given tree in Inorder fashion and \n\n// prints all nodes that have both children as \n\n// non-empty. \n\npublic\nstatic\nvoid\nfindFullNode(Node root) \n\n{ \n\nif\n(root != \nnull\n) \n\n{ \n\nfindFullNode(root.left); \n\nif\n(root.left != \nnull\n&& root.right != \nnull\n) \n\nSystem.out.print(root.data+\n\" \"\n); \n\nfindFullNode(root.right); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\nroot.right.left.right = \nnew\nNode(\n7\n); \n\nroot.right.right.right = \nnew\nNode(\n8\n); \n\nroot.right.left.right.left = \nnew\nNode(\n9\n); \n\nfindFullNode(root); \n\n} \n} \n\n/* A binary tree node */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nleft=right=\nnull\n; \n\nthis\n.data=data; \n\n} \n}; \n//This code is contributed by Gaurav Tiwari ", "complexity": "linear", "from": "CorCod", "problem": 328, "index": 328}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        String a = scanner.nextLine(), b = scanner.nextLine();\n\n        int n = b.length(), m = a.length();\n\n        int p[] = new int[n];\n\n        p[0] = b.charAt(0) - '0';\n\n        for (int i = 1; i < n; i++) {\n            p[i] = p[i - 1] + (b.charAt(i) - '0');\n        }\n\n        long ans = 0;\n        for (int i = 0; i < m; i++) {\n            int cur = a.charAt(i) - '0';\n\n            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);\n\n            if (cur == 0) {\n                ans += cnt;\n            } else {\n                ans += n - m + 1  - cnt;\n            }\n        }\n\n        System.out.println(ans);\n\n    }\n\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 329, "index": 329}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\nimport static java.lang.Math.ceil;\n\npublic class practise {\n    static final int N = 31;\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out,true);\n    static long c[] = new long[N];\n    static int w[] = new int[N];\n    public static void main(String[] args) {\n        w[0] = 1;\n        for(int i=1;i<N;i++) w[i] = w[i-1]*2;\n        int n = sc.nextInt(); int l = sc.nextInt();\n        for(int i=0;i<N;i++) c[i] = Long.MAX_VALUE;\n        for(int i=0;i<n;i++) c[i] = sc.nextInt();\n        for(int i=1;i<N;i++) {\n            c[i] = min(c[i-1]*2,c[i]);\n        }\n        long ans = 0;\n        for(int i=0;i<N;i++) {\n            if( (l&w[i])!=0) {\n                ans += c[i];\n            }\n        }\n        long m = 0;\n        for(int i=N - 1;i>=0;i--) {\n            if((l&w[i])!=0) {\n                m += c[i];\n            } else {\n                ans = min(ans,m+c[i]);\n            }\n        }\n        out.println(ans);\n    }\n\n    static long min(long a,long b) {\n        return a<b?a:b;\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 330, "index": 330}
{"src": "\n// Java program to find maximum revenue \n// by placing billboard on the highway \n// with given constarints. \n\nclass\nGFG \n{ \n\nstatic\nint\nmaxRevenue(\nint\nm, \nint\n[] x, \n\nint\n[] revenue, \n\nint\nn, \nint\nt) \n{ \n\n\n// Array to store maximum revenue \n\n// at each miles. \n\nint\n[] maxRev = \nnew\nint\n[m + \n1\n]; \n\nfor\n(\nint\ni = \n0\n; i < m + \n1\n; i++) \n\nmaxRev[i] = \n0\n; \n\n\n// actual minimum distance between \n\n// 2 billboards. \n\nint\nnxtbb = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\n{ \n\n// check if all billboards are \n\n// already placed. \n\nif\n(nxtbb < n) \n\n{ \n\n// check if we have billboard for \n\n// that particular mile. If not, \n\n// copy the previous maximum revenue. \n\nif\n(x[nxtbb] != i) \n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n\n// we do have billboard for this mile. \n\nelse\n\n{ \n\n// We have 2 options, we either take \n\n// current or we ignore current billboard. \n\n\n// If current position is less than or \n\n// equal to t, then we can have only \n\n// one billboard. \n\nif\n(i <= t) \n\nmaxRev[i] = Math.max(maxRev[i - \n1\n], \n\nrevenue[nxtbb]); \n\n\n// Else we may have to remove \n\n// previously placed billboard \n\nelse\n\nmaxRev[i] = Math.max(maxRev[i - t - \n1\n] + \n\nrevenue[nxtbb], \n\nmaxRev[i - \n1\n]); \n\n\nnxtbb++; \n\n} \n\n} \n\nelse\n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n} \n\n\nreturn\nmaxRev[m]; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String []args) \n{ \n\nint\nm = \n20\n; \n\nint\n[] x = \nnew\nint\n[]{\n6\n, \n7\n, \n12\n, \n13\n, \n14\n}; \n\nint\n[] revenue = \nnew\nint\n[]{\n5\n, \n6\n, \n5\n, \n3\n, \n1\n}; \n\nint\nn = x.length; \n\nint\nt = \n5\n; \n\nSystem.out.println(maxRevenue(m, x, revenue, n, t)); \n} \n} \n\n// This code is contributed by Ita_c. ", "complexity": "linear", "from": "CorCod", "problem": 331, "index": 331}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader in = new FastReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong n = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tif (k > s || k * (n - 1) < s) {\n\t\t\tout.println(\"NO\");\n\t\t} else {\n\t\t\tout.println(\"YES\");\n\t\t\tlong cur = 1;\n\t\t\twhile (k > 0) {\n\t\t\t\tlong x = Math.min(n - 1, s - k + 1);\n\t\t\t\tcur = ( cur - x > 0 ? cur  - x : cur + x);\n\t\t\t\tout.print(cur + \" \");\n\t\t\t\ts -= x;\n\t\t\t\tk--;\n\t\t\t}\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class FastReader {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic FastReader(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic FastReader(FileReader fileReader) {\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}", "complexity": "linear", "from": "CorCod", "problem": 332, "index": 332}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static void solve(InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n\n        if (n < 6) {\n            out.println(-1);\n        } else {\n            int m = (n - 2);\n            for (int i = 2; i <= m; i++) {\n                out.println(\"1 \" + i);\n            }\n            out.println(m + \" \" + (m + 1));\n            out.println(m + \" \" + (m + 2));\n        }\n\n        for (int i = 2; i <= n; i++) {\n            out.println(\"1 \" + i);\n        }\n    }\n\n    private static void shuffleArray(int[] array) {\n        int index;\n        Random random = new Random();\n        for (int i = array.length - 1; i > 0; i--) {\n            index = random.nextInt(i + 1);\n            if (index != i) {\n                array[index] ^= array[i];\n                array[i] ^= array[index];\n                array[index] ^= array[i];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        solve(in, out);\n        in.close();\n        out.close();\n    }\n\n    private static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        InputReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n            st = null;\n        }\n\n        String nextLine() {\n            String line = null;\n            try {\n                line = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return line;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = nextLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        byte nextByte() {\n            return Byte.parseByte(next());\n        }\n\n        short nextShort() {\n            return Short.parseShort(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class OutputWriter {\n        BufferedWriter bw;\n\n        OutputWriter(OutputStream os) {\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n        }\n\n        void print(int i) {\n            print(Integer.toString(i));\n        }\n\n        void println(int i) {\n            println(Integer.toString(i));\n        }\n\n        void print(long l) {\n            print(Long.toString(l));\n        }\n\n        void println(long l) {\n            println(Long.toString(l));\n        }\n\n        void print(double d) {\n            print(Double.toString(d));\n        }\n\n        void println(double d) {\n            println(Double.toString(d));\n        }\n\n        void print(boolean b) {\n            print(Boolean.toString(b));\n        }\n\n        void println(boolean b) {\n            println(Boolean.toString(b));\n        }\n\n        void print(char c) {\n            try {\n                bw.write(c);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(char c) {\n            println(Character.toString(c));\n        }\n\n        void print(String s) {\n            try {\n                bw.write(s);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(String s) {\n            print(s);\n            print('\\n');\n        }\n\n        void close() {\n            try {\n                bw.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 333, "index": 333}
{"src": "\n// Java program to check fixed point \n// in an array using linear search \n\nclass\nMain \n{ \n\nstatic\nint\nlinearSearch(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == i) \n\nreturn\ni; \n\n} \n\n\n/* If no fixed point present \n\nthen return -1 */\n\nreturn\n-\n1\n; \n\n} \n\n//main function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {-\n10\n, -\n1\n, \n0\n, \n3\n, \n10\n, \n11\n, \n30\n, \n50\n, \n100\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Fixed Point is \"\n\n+ linearSearch(arr, n)); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 334, "index": 334}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class C {\n\n    void solve(){\n       int n = readInt();\n       int q = readInt();\n       int max = 0;\n       int[] a = new int[n];\n       Deque<Integer> deque = new ArrayDeque<>();\n       for(int i = 0;i<n;i++){\n           a[i] = readInt();\n           deque.addLast(a[i]);\n           max = Math.max(max, a[i]);\n       }\n        List<String> ans = new ArrayList<>();\n        while(deque.peekFirst() != max){\n           int one = deque.pollFirst();\n           int two = deque.pollFirst();\n           ans.add(one + \" \" + two);\n           deque.addFirst(one > two ? one : two);\n           deque.addLast(one > two ? two : one);\n           if(one == max) break;\n       }\n\n       for(int i = 0;i<n;i++){\n           a[i] = deque.pollFirst();\n       }\n\n       for(int i = 0;i<q;i++){\n          long x = readLong();\n           if(x <= ans.size()){\n               out.println(ans.get((int)x - 1));\n               continue;\n           }\n           x -= ans.size();\n           int y =(int) (x%(n - 1) - 1%(n - 1) + (n - 1)) % (n - 1) + 1;\n           out.println(max + \" \" + a[y]);\n       }\n    }\n\n    public static void main(String[] args) {\n        new C().run();\n    }\n\n    void run(){\n        init();\n        solve();\n        out.close();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init(){\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out  = new PrintWriter(System.out);\n    }\n\n    String readLine(){\n        try{\n            return in.readLine();\n        }catch(Exception ex){\n            throw new RuntimeException(ex);\n        }\n    }\n    String readString(){\n        while(!tok.hasMoreTokens()){\n            String nextLine = readLine();\n            if(nextLine == null) return null;\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt(){\n        return Integer.parseInt(readString());\n    }\n\n    long readLong(){\n        return Long.parseLong(readString());\n    }\n\n    double readDouble(){\n        return Double.parseDouble(readString());\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 335, "index": 335}
{"src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        long a;\n        int i;\n        public card(long a,int i)\n        {\n            this.a=a;\n            this.i=i;\n        }\n    }\n    static class sort implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.a!=o2.a)\n                return (int)(o1.a-o2.a);\n            else\n                return (int)(o1.b-o2.b);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }*/\n    /*static boolean valid(int i,int j)\n    {\n    if(i<4 && i>=0 && j<4 && j>=0)\n    return true;\n    else\n    return false;\n    }*/\n    static class pair{\n        int a,b;\n        public pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        char c[]=sc.next().toCharArray();\n        int l=c.length;\n        int a[]=new int[3];\n        for(int i=0;i<l;i++)\n        {\n            a[c[i]-'a']++;\n           if(i>0 && c[i]<c[i-1])\n           {\n               System.out.println(\"NO\");\n               System.exit(0);\n           }\n        }\n        if(a[0]>0 && a[1]>0 && (a[2]==a[1] || a[2]==a[0]))\n        System.out.println(\"YES\");\n        else\n        System.out.println(\"NO\");\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 336, "index": 336}
{"src": "\n// Java program to Find the repeating \n// and missing elements \n\nimport\njava.io.*; \n\nclass\nGFG { \n\nstatic\nint\nx, y; \n\n\nstatic\nvoid\ngetTwoElements(\nint\narr[], \nint\nn) \n\n{ \n\n/* Will hold xor of all elements \n\nand numbers from 1 to n */\n\nint\nxor1; \n\n\n/* Will have only single set bit of xor1 */\n\nint\nset_bit_no; \n\n\nint\ni; \n\nx = \n0\n; \n\ny = \n0\n; \n\n\nxor1 = arr[\n0\n]; \n\n\n/* Get the xor of all array elements */\n\nfor\n(i = \n1\n; i < n; i++) \n\nxor1 = xor1 ^ arr[i]; \n\n\n/* XOR the previous result with numbers from \n\n1 to n*/\n\nfor\n(i = \n1\n; i <= n; i++) \n\nxor1 = xor1 ^ i; \n\n\n/* Get the rightmost set bit in set_bit_no */\n\nset_bit_no = xor1 & ~(xor1 - \n1\n); \n\n\n/* Now divide elements into two sets by comparing \n\nrightmost set bit of xor1 with the bit at the same \n\nposition in each element. Also, get XORs of two \n\nsets. The two XORs are the output elements. The \n\nfollowing two for loops serve the purpose */\n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n((arr[i] & set_bit_no) != \n0\n) \n\n/* arr[i] belongs to first set */\n\nx = x ^ arr[i]; \n\n\nelse\n\n/* arr[i] belongs to second set*/\n\ny = y ^ arr[i]; \n\n} \n\nfor\n(i = \n1\n; i <= n; i++) { \n\nif\n((i & set_bit_no) != \n0\n) \n\n/* i belongs to first set */\n\nx = x ^ i; \n\n\nelse\n\n/* i belongs to second set*/\n\ny = y ^ i; \n\n} \n\n\n/* *x and *y hold the desired output elements */\n\n} \n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n4\n, \n5\n, \n1\n, \n6\n, \n2\n}; \n\n\nint\nn = arr.length; \n\ngetTwoElements(arr, n); \n\nSystem.out.println(\n\" The missing element is \"\n\n+ x + \n\"and the \"\n\n+ \n\"repeating number is \"\n\n+ y); \n\n} \n} \n\n// This code is contributed by Gitanjali. ", "complexity": "linear", "from": "CorCod", "problem": 337, "index": 337}
{"src": "\n// Java program to find max value of i*arr[i] \n\nimport\njava.util.Arrays; \n\nclass\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n10\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\n\n// Returns max possible value of i*arr[i] \n\nstatic\nint\nmaxSum() \n\n{ \n\n// Find array sum and i*arr[i] with no rotation \n\nint\narrSum = \n0\n; \n// Stores sum of arr[i] \n\nint\ncurrVal = \n0\n; \n// Stores sum of i*arr[i] \n\nfor\n(\nint\ni=\n0\n; i<arr.length; i++) \n\n{ \n\narrSum = arrSum + arr[i]; \n\ncurrVal = currVal+(i*arr[i]); \n\n} \n\n\n// Initialize result as 0 rotation sum \n\nint\nmaxVal = currVal; \n\n\n// Try all rotations one by one and find \n\n// the maximum rotation sum. \n\nfor\n(\nint\nj=\n1\n; j<arr.length; j++) \n\n{ \n\ncurrVal = currVal + arrSum-arr.length*arr[arr.length-j]; \n\nif\n(currVal > maxVal) \n\nmaxVal = currVal; \n\n} \n\n\n// Return result \n\nreturn\nmaxVal; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Max sum is \"\n+ maxSum()); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 338, "index": 338}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tstatic int check(int temp)\n\t{\n\t\tint count1 = 0; \n    while (temp>0) \n    { \n        if(temp % 2 != 0) \n        count1++; \n        temp/= 2; \n    } \n    return count1;\n\t}\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner sc=new Scanner(System.in);\n\t\tString a=sc.next();\n\t\tString b=sc.next();\n\t\tint m=a.length();\n\t\tint n=b.length();\n\t\tint[] zero=new int[n];\n\t\tint[] one=new int[n];\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i==0)\n\t\t\t{\n\t\t\t\tif(b.charAt(i)=='0')\n\t\t\t\tzero[i]++;\n\t\t\t\telse\n\t\t\t\tone[i]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tzero[i]=zero[i-1];\n\t\t\t\tone[i]=one[i-1];\n\t\t\t\tif(b.charAt(i)=='0')\n\t\t\t\tzero[i]++;\n\t\t\t\telse\n\t\t\t\tone[i]++;\n\t\t    }\n\t\t}\n\t\t\n\n\t\tlong res=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\tint x=n-m+i;\n\t\tif(a.charAt(i)=='0')\n\t\tres+=one[x];\n\t\telse\n\t\tres+=zero[x];\n\t\tif(i>0)\n\t\t{\n\t\t\tif(a.charAt(i)=='0')\n\t\t\tres-=one[i-1];\n\t\t\telse\n\t\t\tres-=zero[i-1];\n\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(res);\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 339, "index": 339}
{"src": "\n// Java program to check if all leaf nodes are at \n// same level of binary tree \nimport\njava.util.*; \n\n// User defined node class \nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n// Constructor to create a new tree node \n\nNode(\nint\nkey) { \n\nint\ndata = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nGFG { \n\n\n// return true if all leaf nodes are \n\n// at same level, else false \n\nstatic\nboolean\ncheckLevelLeafNode(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// create a queue for level order traversal \n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\nq.add(root); \n\n\nint\nresult = Integer.MAX_VALUE; \n\nint\nlevel = \n0\n; \n\n\n// traverse until the queue is empty \n\nwhile\n(q.size() != \n0\n) { \n\nint\nsize = q.size(); \n\nlevel++; \n\n\n// traverse for complete level \n\nwhile\n(size > \n0\n) { \n\nNode temp = q.remove(); \n\n\n// check for left child \n\nif\n(temp.left != \nnull\n) { \n\nq.add(temp.left); \n\n\n// if its leaf node \n\nif\n(temp.left.left == \nnull\n&& temp.left.right == \nnull\n) { \n\n\n// if it's first leaf node, then update result \n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n// if it's not first leaf node, then compare \n\n// the level with level of previous leaf node. \n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n// check for right child \n\nif\n(temp.right != \nnull\n) { \n\nq.add(temp.right); \n\n\n// if its leaf node \n\nif\n(temp.right.left == \nnull\n&& temp.right.right == \nnull\n) { \n\n\n// if it's first leaf node, then update result \n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n// if it's not first leaf node, then compare \n\n// the level with level of previous leaf node. \n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\nsize--; \n\n} \n\n\n} \n\nreturn\ntrue\n; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n// construct a tree \n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nboolean\nresult = checkLevelLeafNode(root); \n\nif\n(result == \ntrue\n) \n\nSystem.out.println(\n\"All leaf nodes are at same level\"\n); \n\nelse\n\nSystem.out.println(\n\"Leaf nodes not at same level\"\n); \n\n} \n} \n// This code is contributed by rachana soma ", "complexity": "linear", "from": "CorCod", "problem": 340, "index": 340}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] P = new int[n];\n        int[] check=new int[n];\n        for (int i = 1; i < n; i++) {\n\n            P[i] = scanner.nextInt();\n            P[i]--;\n            check[P[i]]++;\n        }\n        int[] leaves = new int[n];\n\n\n        for (int i=0;i<n;i++) {\n            if(check[i]==0){\n                leaves[P[i]]++;\n            }\n        }\n\n\n        for (int i = 0; i < n; i++) {\n\n            if (check[i]>0&&leaves[i]<3) {\n                System.out.println(\"No\");\n                return;\n            }\n        }\n        System.out.println(\"Yes\");\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 341, "index": 341}
{"src": "\n// Iterative Java program to print odd level nodes \nimport\njava.util.*; \nclass\nGfG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\n// Iterative method to do level order traversal line by line \nstatic\nvoid\nprintOddNodes(Node root) \n{ \n\n// Base Case \n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n// Create an empty queue for level \n\n// order tarversal \n\nQueue<Node> q = \nnew\nLinkedList<Node> (); \n\n\n// Enqueue root and initialize level as odd \n\nq.add(root); \n\nboolean\nisOdd = \ntrue\n; \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n// nodeCount (queue size) indicates \n\n// number of nodes at current level. \n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n// Dequeue all nodes of current level \n\n// and Enqueue all nodes of next level \n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nif\n(isOdd == \ntrue\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\n\nisOdd = !isOdd; \n\n} \n} \n\n// Utility method to create a node \nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nprintOddNodes(root); \n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 342, "index": 342}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint[] f = new int[n];\n\t\tint[] t = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = sc.nextInt();\n\t\t\tt[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(f, t, s));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] f, int[] t, int s) {\n\t\tint[] maxTimes = new int[s + 1];\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tmaxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);\n\t\t}\n\n\t\tint time = 0;\n\t\tfor (int i = s; i > 0; i--) {\n\t\t\ttime = Math.max(time, maxTimes[i]);\n\n\t\t\ttime++;\n\t\t}\n\t\treturn time;\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 343, "index": 343}
{"src": "// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF903F {\n\tstatic final int INF = 0x3f3f3f3f;\n\tstatic void fill(int[][][][] aa, int a) {\n\t\tfor (int h0 = 0; h0 <= 4; h0++)\n\t\t\tfor (int h1 = 0; h1 <= 4; h1++)\n\t\t\t\tfor (int h2 = 0; h2 <= 4; h2++)\n\t\t\t\t\tfor (int h3 = 0; h3 <= 4; h3++)\n\t\t\t\t\t\taa[h0][h1][h2][h3] = a;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint a1 = Integer.parseInt(st.nextToken());\n\t\tint a2 = Integer.parseInt(st.nextToken());\n\t\tint a3 = Integer.parseInt(st.nextToken());\n\t\tint a4 = Integer.parseInt(st.nextToken());\n\t\tint[] aa = new int[10];\n\t\taa[0] = aa[1] = aa[2] = aa[3] = a1;\n\t\taa[4] = aa[5] = aa[6] = a2;\n\t\taa[7] = aa[8] = a3;\n\t\taa[9] = a4;\n\t\tint[][] ww = new int[10][4];\n\t\tww[0][0] = 1;\n\t\tww[1][1] = 1;\n\t\tww[2][2] = 1;\n\t\tww[3][3] = 1;\n\t\tww[4][0] = ww[4][1] = 2;\n\t\tww[5][1] = ww[5][2] = 2;\n\t\tww[6][2] = ww[6][3] = 2;\n\t\tww[7][0] = ww[7][1] = ww[7][2] = 3;\n\t\tww[8][1] = ww[8][2] = ww[8][3] = 3;\n\t\tww[9][0] = ww[9][1] = ww[9][2] = ww[9][3] = 4;\n\t\tchar[][] cc = new char[4][n + 8];\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tchar[] c_ = cc[k];\n\t\t\tbr.readLine().getChars(0, n, c_, 4);\n\t\t\tc_[0] = c_[1] = c_[2] = c_[3]\n\t\t\t\t= c_[n + 4] = c_[n + 5] = c_[n + 6] = c_[n + 7] = '.';\n\t\t}\n\t\tint[][][][] dp = new int[5][5][5][5];\n\t\tint[][][][] dq = new int[5][5][5][5];\n\t\tfill(dp, INF);\n\t\tdp[4][4][4][4] = 0;\n\t\tint[] hh = new int[4];\n\t\tfor (int i = 0; i < n + 4; i++) {\n\t\t\tfor (int h0 = 0; h0 <= 4; h0++)\n\t\t\t\tfor (int h1 = 0; h1 <= 4; h1++)\n\t\t\t\t\tfor (int h2 = 0; h2 <= 4; h2++)\n\t\t\t\t\t\tfor (int h3 = 0; h3 <= 4; h3++)\n\t\t\t\t\t\t\tfor (int s = 0; s < 10; s++) {\n\t\t\t\t\t\t\t\thh[0] = h0;\n\t\t\t\t\t\t\t\thh[1] = h1;\n\t\t\t\t\t\t\t\thh[2] = h2;\n\t\t\t\t\t\t\t\thh[3] = h3;\n\t\t\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\t\t\tint h = ww[s][k];\n\t\t\t\t\t\t\t\t\tif (hh[k] < h) {\n\t\t\t\t\t\t\t\t\t\twhile (h < 4 && cc[k][i + h] == '.')\n\t\t\t\t\t\t\t\t\t\t\th++;\n\t\t\t\t\t\t\t\t\t\thh[k] = h;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint x = dp[h0][h1][h2][h3] + aa[s];\n\t\t\t\t\t\t\t\tif (dp[hh[0]][hh[1]][hh[2]][hh[3]] > x)\n\t\t\t\t\t\t\t\t\tdp[hh[0]][hh[1]][hh[2]][hh[3]] = x;\n\t\t\t\t\t\t\t}\n\t\t\tfill(dq, INF);\n\t\t\tfor (int h0 = 1; h0 <= 4; h0++) {\n\t\t\t\thh[0] = h0 < 4 || cc[0][i + 4] == '*' ? h0 - 1 : 4;\n\t\t\t\tfor (int h1 = 1; h1 <= 4; h1++) {\n\t\t\t\t\thh[1] = h1 < 4 || cc[1][i + 4] == '*' ? h1 - 1 : 4;\n\t\t\t\t\tfor (int h2 = 1; h2 <= 4; h2++) {\n\t\t\t\t\t\thh[2] = h2 < 4 || cc[2][i + 4] == '*' ? h2 - 1 : 4;\n\t\t\t\t\t\tfor (int h3 = 1; h3 <= 4; h3++) {\n\t\t\t\t\t\t\thh[3] = h3 < 4 || cc[3][i + 4] == '*' ? h3 - 1 : 4;\n\t\t\t\t\t\t\tint x = dp[h0][h1][h2][h3];\n\t\t\t\t\t\t\tif (dq[hh[0]][hh[1]][hh[2]][hh[3]] > x)\n\t\t\t\t\t\t\t\tdq[hh[0]][hh[1]][hh[2]][hh[3]] = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][][][] tmp = dp; dp = dq; dq = tmp;\n\t\t}\n\t\tSystem.out.println(dp[4][4][4][4]);\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 344, "index": 344}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static void solve(InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n\n        List<List<Integer>> g = new ArrayList<>(n + 1);\n        for (int i = 0; i < n + 1; i++) {\n            g.add(new LinkedList<>());\n        }\n\n        int degree1 = 0, degree2 = 0, root = 0;\n        for (int i = 0; i < n - 1; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n\n            g.get(a).add(b);\n            g.get(b).add(a);\n\n            if (g.get(a).size() > degree1) {\n\n                if (a == root) {\n                    degree1 = g.get(a).size();\n                } else {\n                    degree2 = degree1;\n                    degree1 = g.get(a).size();\n                    root = a;\n                }\n\n            } else if (g.get(a).size() > degree2) {\n                degree2 = g.get(a).size();\n            }\n\n            if (g.get(b).size() > degree1) {\n\n                if (b == root) {\n                    degree1 = g.get(b).size();\n                } else {\n                    degree2 = degree1;\n                    degree1 = g.get(b).size();\n                    root = b;\n                }\n\n            } else if (g.get(b).size() > degree2) {\n                degree2 = g.get(b).size();\n            }\n        }\n\n        if (degree2 > 2) {\n            out.print(\"No\");\n        } else {\n            out.println(\"Yes\");\n\n            List<Integer> leaves = new LinkedList<>();\n            for (int i = 1; i <= n; i++) {\n                if (i != root) {\n                    if (g.get(i).size() == 1) {\n                        leaves.add(i);\n                    }\n                }\n            }\n\n            out.println(leaves.size());\n            for (int i : leaves) {\n                out.println(root + \" \" + i);\n            }\n        }\n    }\n\n    private static void shuffleArray(int[] array) {\n        int index;\n        Random random = new Random();\n        for (int i = array.length - 1; i > 0; i--) {\n            index = random.nextInt(i + 1);\n            if (index != i) {\n                array[index] ^= array[i];\n                array[i] ^= array[index];\n                array[index] ^= array[i];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        solve(in, out);\n        in.close();\n        out.close();\n    }\n\n    private static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        InputReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n            st = null;\n        }\n\n        String nextLine() {\n            String line = null;\n            try {\n                line = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return line;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = nextLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        byte nextByte() {\n            return Byte.parseByte(next());\n        }\n\n        short nextShort() {\n            return Short.parseShort(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class OutputWriter {\n        BufferedWriter bw;\n\n        OutputWriter(OutputStream os) {\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n        }\n\n        void print(int i) {\n            print(Integer.toString(i));\n        }\n\n        void println(int i) {\n            println(Integer.toString(i));\n        }\n\n        void print(long l) {\n            print(Long.toString(l));\n        }\n\n        void println(long l) {\n            println(Long.toString(l));\n        }\n\n        void print(double d) {\n            print(Double.toString(d));\n        }\n\n        void println(double d) {\n            println(Double.toString(d));\n        }\n\n        void print(boolean b) {\n            print(Boolean.toString(b));\n        }\n\n        void println(boolean b) {\n            println(Boolean.toString(b));\n        }\n\n        void print(char c) {\n            try {\n                bw.write(c);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(char c) {\n            println(Character.toString(c));\n        }\n\n        void print(String s) {\n            try {\n                bw.write(s);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(String s) {\n            print(s);\n            print('\\n');\n        }\n\n        void close() {\n            try {\n                bw.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 345, "index": 345}
{"src": "\n// Java program to find efficient \n// solution for the network \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// number of houses and number \n\n// of pipes \n\nstatic\nint\nn, p; \n\n\n// Array rd stores the \n\n// ending vertex of pipe \n\nstatic\nint\nrd[] = \nnew\nint\n[\n1100\n]; \n\n\n// Array wd stores the value \n\n// of diameters between two pipes \n\nstatic\nint\nwt[] = \nnew\nint\n[\n1100\n]; \n\n\n// Array cd stores the \n\n// starting end of pipe \n\nstatic\nint\ncd[] = \nnew\nint\n[\n1100\n]; \n\n\n// arraylist a, b, c are used \n\n// to store the final output \n\nstatic\nList <Integer> a = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nList <Integer> b = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nList <Integer> c = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nint\nans; \n\n\nstatic\nint\ndfs(\nint\nw) \n\n{ \n\nif\n(cd[w] == \n0\n) \n\nreturn\nw; \n\nif\n(wt[w] < ans) \n\nans = wt[w]; \n\n\nreturn\ndfs(cd[w]); \n\n} \n\n\n// Function to perform calculations. \n\nstatic\nvoid\nsolve(\nint\narr[][]) \n\n{ \n\nint\ni = \n0\n; \n\n\nwhile\n(i < p) \n\n{ \n\n\nint\nq = arr[i][\n0\n]; \n\nint\nh = arr[i][\n1\n]; \n\nint\nt = arr[i][\n2\n]; \n\n\ncd[q] = h; \n\nwt[q] = t; \n\nrd[h] = q; \n\ni++; \n\n} \n\n\na=\nnew\nArrayList<Integer>(); \n\nb=\nnew\nArrayList<Integer>(); \n\nc=\nnew\nArrayList<Integer>(); \n\n\nfor\n(\nint\nj = \n1\n; j <= n; ++j) \n\n\n/*If a pipe has no ending vertex \n\nbut has starting vertex i.e is \n\nan outgoing pipe then we need \n\nto start DFS with this vertex.*/\n\nif\n(rd[j] == \n0\n&& cd[j]>\n0\n) { \n\nans = \n1000000000\n; \n\nint\nw = dfs(j); \n\n\n// We put the details of \n\n// component in final output \n\n// array \n\na.add(j); \n\nb.add(w); \n\nc.add(ans); \n\n} \n\n\nSystem.out.println(a.size()); \n\n\nfor\n(\nint\nj = \n0\n; j < a.size(); ++j) \n\nSystem.out.println(a.get(j) + \n\" \"\n\n+ b.get(j) + \n\" \"\n+ c.get(j)); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nn = \n9\n; \n\np = \n6\n; \n\n\n// set the value of the araray \n\n// to zero \n\nfor\n(\nint\ni = \n0\n; i < \n1100\n; i++) \n\nrd[i] = cd[i] = wt[i] = \n0\n; \n\n\nint\narr[][] = { { \n7\n, \n4\n, \n98\n}, \n\n{ \n5\n, \n9\n, \n72\n}, \n\n{ \n4\n, \n6\n, \n10\n}, \n\n{ \n2\n, \n8\n, \n22\n}, \n\n{ \n9\n, \n7\n, \n17\n}, \n\n{ \n3\n, \n1\n, \n66\n} }; \n\nsolve(arr); \n\n} \n} \n\n// This code is contributed by Arnab Kundu ", "complexity": "linear", "from": "CorCod", "problem": 346, "index": 346}
{"src": "import java.util.Scanner;\n\npublic class NickAndArray {\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\t int array[]=new int[n];\n\t\t int max=Integer.MAX_VALUE;\n\t\t int index=0;\n\t\t for(int i=0;i<n;i++)\n\t\t {\n\t\t\t int k=sc.nextInt();\n\t\t\t array[i]=k;\n\t\t\t if(array[i]>=0)\n\t\t\t {\n\t\t\t\t array[i]=-array[i]-1;\n\t\t\t }\n\t\t\t if(array[i]<max)\n\t\t\t {\n\t\t\t\t max=array[i];\n\t\t\t\t index=i;\n\t\t\t\t \n\t\t\t }\n\t\t }\n\t\t if(n%2!=0)\n\t\t {\n\t\t\t array[index]=-array[index]-1;\n\t\t }\n\t\t for(int i=0;i<n;i++)\n\t\t {\n\t\t\t System.out.print(array[i]+\" \" );\n\t\t }\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 347, "index": 347}
{"src": "\n// Java program to find smallest and second smallest elements \nimport\njava.io.*; \n\nclass\nSecondSmallest \n{ \n\n/* Function to print first smallest and second smallest \n\nelements */\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n/* There should be atleast two elements */\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n/* If current element is smaller than first \n\nthen update both first and second */\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n/* If arr[i] is in between first and second \n\nthen update second */\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "complexity": "linear", "from": "CorCod", "problem": 348, "index": 348}
{"src": "//package contese_476;\nimport java.util.*;\npublic class q1 \n{\n\tint m=(int)1e9+7;\npublic class Node\n{\n\tint a;\n\tint b;\n\tpublic void Node(int a,int b)\n\t{\n\t\tthis.a=a;\n\t\tthis.b=b;\n\t}\n}\npublic int mul(int a ,int b)\n{\na=a%m;\nb=b%m;\nreturn((a*b)%m);\n}\npublic int pow(int a,int b)\n{\n\tint x=1;\n\twhile(b>0)\n\t{\n\t\tif(b%2!=0)\n\t\t\tx=mul(x,a);\n\t\ta=mul(a,a);\n\t\tb=b/2;\n\t}\n\treturn x;\n}\npublic static long gcd(long a,long b)\n{\n\tif(b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\npublic static void main(String[] args)\n{\n\tScanner sc=new Scanner(System.in);\n\tint n=sc.nextInt();\n\tHashMap<Integer,Integer> h=new HashMap();\n\t//HashMap<Integer,Integer> h1=new HashMap();\n\tint[] a=new int[n];\n\tint x=sc.nextInt();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta[i]=sc.nextInt();\n\t\tif(h.get(a[i])==null)\n\t\t{\n\t\t\th.put(a[i], 1);\n\t\t\t//h1.put(a[i],i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(0);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint num=a[i]&x;\n\t\tif(num==a[i])\n\t\t\tcontinue;\n\t\tif(h.get(num)==null)\n\t\t\tcontinue;\n\t\t\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tSystem.out.print(1);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint num=a[i]&x;\n\t\tif(num==a[i])\n\t\t\tcontinue;\n\t\tif(h.get(num)==null)\n\t\t\th.put(num, 1);\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(2);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tSystem.out.print(-1);\n\t\n     \n}\n\n}", "complexity": "linear", "from": "CorCod", "problem": 349, "index": 349}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SFly {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader lector = new BufferedReader(new InputStreamReader(System.in));\n\t\tint planet = Integer.parseInt(lector.readLine());\n\t\tint ini = Integer.parseInt(lector.readLine());\n\t\tdouble peso = ini;\n\t\tint[] desp = new int[planet];\n\t\tint[] ater = new int[planet];\n\t\tString[] temp = lector.readLine().split(\" \");\t\t\n\t\tfor(int i=0; i<planet; i++) {\n\t\t\tdesp[i] = Integer.parseInt(temp[i]);\n\t\t\tif(desp[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = lector.readLine().split(\" \");\t\t\n\t\tfor(int i=0; i<planet; i++) {\n\t\t\tater[i] = Integer.parseInt(temp[i]);\n\t\t\tif(ater[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = null;\n\t\tint i=planet-1;\n\t\tpeso = (peso*ater[0])/(ater[0]-1);\n\t\twhile(i>0) {\n\t\t\tpeso = (peso*desp[i])/(desp[i]-1);\n\t\t\tpeso = (peso*ater[i])/(ater[i]-1);\n\t\t\ti--;\n\t\t}\n\t\tpeso = (peso*desp[0])/(desp[0]-1);\n\t\tpeso = peso - ini;\n\t\tSystem.out.println(peso);\n\t\tlector.close();\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 350, "index": 350}
{"src": "\nclass\nMaximumSum \n{ \n\n/*Function to return max sum such that no two elements \n\nare adjacent */\n\nint\nFindMaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nincl = arr[\n0\n]; \n\nint\nexcl = \n0\n; \n\nint\nexcl_new; \n\nint\ni; \n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\n/* current max excluding i */\n\nexcl_new = (incl > excl) ? incl : excl; \n\n\n/* current max including i */\n\nincl = excl + arr[i]; \n\nexcl = excl_new; \n\n} \n\n\n/* return max of incl and excl */\n\nreturn\n((incl > excl) ? incl : excl); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMaximumSum sum = \nnew\nMaximumSum(); \n\nint\narr[] = \nnew\nint\n[]{\n5\n, \n5\n, \n10\n, \n100\n, \n10\n, \n5\n}; \n\nSystem.out.println(sum.FindMaxSum(arr, arr.length)); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 351, "index": 351}
{"src": "\n// Java Program to find the length of \n// substring with maximum difference of \n// zeroes and ones in binary string. \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Find the length of substring with maximum \n\n// difference of zeros and ones in binary \n\n// string \n\npublic\nstatic\nint\nfindLength(String str, \nint\nn) \n\n{ \n\n\nint\ncurrent_sum = \n0\n; \n\nint\nmax_sum = \n0\n; \n\n\n// traverse a binary string from left to right \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// add current value to the current_sum \n\n// according to the Character \n\n// if it's '0' add 1 else -1 \n\ncurrent_sum += (str.charAt(i) == \n'0'\n? \n1\n: -\n1\n); \n\n\nif\n(current_sum < \n0\n) \n\ncurrent_sum = \n0\n; \n\n\n// update maxium sum \n\nmax_sum = Math.max(current_sum, max_sum); \n\n} \n\n// return -1 if string does not contain any zero \n\n// that means string contains all ones otherwise max_sum \n\nreturn\nmax_sum == \n0\n? -\n1\n: max_sum; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"11000010001\"\n; \n\nint\nn = str.length(); \n\n\nSystem.out.println(findLength(str, n)); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 352, "index": 352}
{"src": "import java.util.*;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc= new Scanner(System.in);\n\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\tint loca[]=new int[n+m];\n\t\tint res[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++)\n\t\t\tloca[i]=sc.nextInt();\n\t\t\n\t\tint y=0;\n\t\tint driver[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++){\n\t\t\tint x=sc.nextInt();\n\t\t\tif(x==1)\n\t\t\t\tdriver[y++]=i;\n\t\t}\n\t\t\n\t\tint i=0,j=0,p=0,q=0;\n\t\tfor(i=0;i<m+n;i++) {\n\t\t\tif(i==driver[0])\n\t\t\t\t{i++;break;}\n\t\t\tif(loca[i]<loca[driver[0]])\n\t\t\t\tres[0]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//j=1;\n\t\t\n\t\tfor(;i<n+m;i++){\n\t\t\t\n\t\t\tint coor=loca[i];\n\t\t\t\n\t\t\t/*if(coor>q&&j!=0)\n\t\t\t\tj++;*/\n\t\t\t\n\t\t\tif(j==m-1)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tp=driver[j];q=driver[j+1];\t\t\n\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint d1=coor-loca[p],d2=loca[q]-coor;\n\t\t\t\n\t\t\tif(d2==0)\n\t\t\t\t{j++;continue;}\n\t\t\tif(d1<=d2)\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tres[j+1]++;\n\t\t\t\n\t\t\t//add check for j+1<m\n\t\t\t//handle cases for j==0 && j==m-1\n\t\t}\n\t\t\n\t\tfor(;i<m+n;i++) {\n\t\t\t\n\t\t\tif(i==driver[j])\n\t\t\t{i++;break;}\n\t\t\t\n\t\t\tif(loca[i]>loca[driver[j]])\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(i=0;i<m;i++)\n\t\t\tSystem.out.print(res[i]+\" \");\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 353, "index": 353}
{"src": "\n// Java program to rearrange characters in a string \n// so that no two adjacent characters are same. \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nKeyComparator \nimplements\nComparator<Key> { \n\n\n// Overriding compare()method of Comparator \n\npublic\nint\ncompare(Key k1, Key k2) \n\n{ \n\nif\n(k1.freq < k2.freq) \n\nreturn\n1\n; \n\nelse\nif\n(k1.freq > k2.freq) \n\nreturn\n-\n1\n; \n\nreturn\n0\n; \n\n} \n} \n\nclass\nKey { \n\nint\nfreq; \n// store frequency of character \n\nchar\nch; \n\nKey(\nint\nval, \nchar\nc) \n\n{ \n\nfreq = val; \n\nch = c; \n\n} \n} \n\nclass\nGFG { \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n// Function to rearrange character of a string \n\n// so that no char repeat twice \n\nstatic\nvoid\nrearrangeString(String str) \n\n{ \n\nint\nn = str.length(); \n\n\n// Store frequencies of all characters in string \n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[str.charAt(i) - \n'a'\n]++; \n\n\n// Insert all characters with their frequencies \n\n// into a priority_queue \n\nPriorityQueue<Key> pq = \nnew\nPriorityQueue<>(\nnew\n\nKeyComparator()); \n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\nval = c - \n'a'\n; \n\nif\n(count[val] > \n0\n) \n\npq.add(\nnew\nKey(count[val], c)); \n\n} \n\n\n// 'str' that will store resultant value \n\nstr = \n\"\"\n; \n\n\n// work as the previous visited element \n\n// initial previous element be. ( '#' and \n\n// it's frequency '-1' ) \n\nKey prev = \nnew\nKey(-\n1\n, \n'#'\n); \n\n\n// traverse queue \n\nwhile\n(pq.size() != \n0\n) { \n\n\n// pop top element from queue and add it \n\n// to string. \n\nKey k = pq.peek(); \n\npq.poll(); \n\nstr = str + k.ch; \n\n\n// If frequency of previous character is less \n\n// than zero that means it is useless, we \n\n// need not to push it \n\nif\n(prev.freq > \n0\n) \n\npq.add(prev); \n\n\n// make current character as the previous 'char' \n\n// decrease frequency by 'one' \n\n(k.freq)--; \n\nprev = k; \n\n} \n\n\n// If length of the resultant string and original \n\n// string is not same then string is not valid \n\nif\n(n != str.length()) \n\nSystem.out.println(\n\" Not valid String \"\n); \n\nelse\n\nSystem.out.println(str); \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"bbbaa\"\n; \n\nrearrangeString(str); \n\n} \n} \n\n// This code is contributed by rachana soma ", "complexity": "linear", "from": "CorCod", "problem": 354, "index": 354}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class CF1197B {\n    public static void main(String[] args) {\n        FastReader input = new FastReader();\n        int n = input.nextInt();\n        int[] arr = new int[n];\n        int max = 0;\n        int maxIndex = 0;\n        for(int i = 0;i < n;i++){\n            arr[i] = input.nextInt();\n            if(arr[i] > max){\n                max = arr[i];\n                maxIndex = i;\n            }\n        }\n        int j = maxIndex - 1;\n        int k = maxIndex + 1;\n        while (j >= 0 && k < n){\n            if(arr[j] > arr[k]){\n                if(arr[j] < max){\n                    max = arr[j];\n                    j--;\n                }\n                else {\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n            else{\n                if(arr[k] < max){\n                    max = arr[k];\n                    k++;\n                }\n                else{\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        if(j >= 0){\n            while (j >= 0){\n                if(arr[j] < max){\n                    max = arr[j];\n                    j--;\n                }\n                else{\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        if(k < n){\n            while (k < n){\n                if(arr[k] < max){\n                    max = arr[k];\n                    k++;\n                }\n                else{\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        if(j == -1 && k == n){\n            System.out.println(\"YES\");\n        }\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 355, "index": 355}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            Debug debug = new Debug();\n            int n = in.nextInt();\n            int K = in.nextInt();\n\n            List<Integer>[] g = GraphUtils.nextU(in, n, n - 1, true);\n            int[] center = GraphUtils.getCenter(g);\n            if (center.length == 2) {\n                out.println(\"No\");\n                return;\n            }\n\n            int[][] pars = GraphUtils.parents3(g, center[0]);\n            int[] par = pars[0], ord = pars[1], depth = pars[2];\n            int[] deg = new int[n];\n            for (int i = 0; i < n; ++i) deg[i] = g[i].size();\n\n            if (deg[center[0]] < 3) {\n                out.println(\"No\");\n                return;\n            }\n\n            // all leaves depth = K\n            for (int i = 0; i < n; ++i) {\n                if (deg[i] == 1) {\n                    if (depth[i] != K) {\n                        out.println(\"No\");\n                        return;\n                    }\n                } else if (i != center[0]) {\n                    if (deg[i] < 4) {\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            }\n            out.println(\"Yes\");\n        }\n\n    }\n\n    static class GraphUtils {\n        public static List<Integer>[] nextU(FastReader in, int n, int m, boolean oneIndexed) {\n            int diff = oneIndexed ? 1 : 0;\n            List<Integer>[] g = new List[n];\n            for (int i = 0; i < n; ++i) g[i] = new ArrayList<>();\n            for (int i = 0; i < m; ++i) {\n                int u = in.nextInt() - diff;\n                int v = in.nextInt() - diff;\n                g[u].add(v);\n                g[v].add(u);\n            }\n            return g;\n        }\n\n        public static int[][] parents3(List<Integer>[] g, int root) {\n            int n = g.length;\n            int[] par = new int[n];\n            ArrayUtils.fill(par, -1);\n\n            int[] depth = new int[n];\n            depth[0] = 0;\n\n            int[] q = new int[n];\n            q[0] = root;\n            for (int p = 0, r = 1; p < r; p++) {\n                int cur = q[p];\n                for (int nex : g[cur]) {\n                    if (par[cur] != nex) {\n                        q[r++] = nex;\n                        par[nex] = cur;\n                        depth[nex] = depth[cur] + 1;\n                    }\n                }\n            }\n            return new int[][]{par, q, depth};\n        }\n\n        public static int[] getCenter(List<Integer>[] g) {\n            int n = g.length;\n            int[] q = new int[n];\n            int[] deg = new int[n];\n            int p = 0;\n            for (int i = 0; i < n; i++) {\n                deg[i] = g[i].size();\n                if (g[i].size() <= 1) { // < for n=1\n                    q[p++] = i;\n                }\n            }\n            int bound = p == n ? 0 : p;\n            for (int z = 0; z < p; z++) {\n                if (bound == z && p < n) bound = p;\n                int cur = q[z];\n                deg[cur]--;\n                for (int e : g[cur]) {\n                    if (--deg[e] == 1) q[p++] = e;\n                }\n            }\n            assert p == n;\n            assert bound >= n - 2 && bound < n;\n            if (bound == n - 2) {\n                return new int[]{q[n - 2], q[n - 1]};\n            } else {\n                return new int[]{q[n - 1]};\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void fill(int[] array, int value) {\n            Arrays.fill(array, value);\n        }\n\n    }\n\n    static class Debug {\n        PrintWriter out;\n        boolean oj;\n        boolean system;\n        long timeBegin;\n        Runtime runtime;\n\n        public Debug(PrintWriter out) {\n            oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n            this.out = out;\n            this.timeBegin = System.currentTimeMillis();\n            this.runtime = Runtime.getRuntime();\n        }\n\n        public Debug() {\n            system = true;\n            oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n            OutputStream outputStream = System.out;\n            this.out = new PrintWriter(outputStream);\n            this.timeBegin = System.currentTimeMillis();\n            this.runtime = Runtime.getRuntime();\n        }\n\n    }\n}\n\n", "complexity": "linear", "from": "CorCod", "problem": 356, "index": 356}
{"src": "import java.util.*;\npublic class Main{\n    public static void main(String args[]){\n     Scanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a[]=new int[n];\n    for(int i=0;i<n;i++)\n    a[i]=sc.nextInt();\n    Arrays.sort(a);\n    //boolean \n    int t=1,c=0;\n    for(int i=1;i<n;i++){\n        if(a[i]==a[i-1])\n        {\n            if(i-2>=0&&a[i-2]==a[i-1]-1){\n                System.out.println(\"cslnb\");\n                return;\n            }\n            c++;\n        }\n        if(a[i]==a[i-1]&&a[i]==0){\n        System.out.println(\"cslnb\");\n        return;\n        }\n    }\n    if(c>1)\n    {\n        System.out.println(\"cslnb\");\n        return;\n    }\n    for(int i=0;i<n;i++){\n        if((a[i]-i)%2!=0)\n        t=t^1;\n    }\n    if(t==1)\n    System.out.println(\"cslnb\");\n    else\n    System.out.println(\"sjfnb\");\n    \n    \n    \n    }\n    \n}", "complexity": "linear", "from": "CorCod", "problem": 357, "index": 357}
{"src": "\n\nimport java.util.*;\nimport java.lang.*;\npublic class CodeForce {\n    \n    \n        public static void main(String[] args) {\n            Scanner sc=new Scanner(System.in);\n            String s=sc.next();\n            String t=sc.next();\n            int count=s.length()+t.length();\n            for(int i=0;i<Math.min(s.length(), t.length());i++){\n                if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;\n                else break;\n            }\n            System.out.println(count);\n            \n            \n            \n            \n           \n            \n                \n        }    \n    }\n\n\n", "complexity": "linear", "from": "CorCod", "problem": 358, "index": 358}
{"src": "\n// Java program to find largest pair sum in a given array \n\nclass\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n12\n, \n34\n, \n10\n, \n6\n, \n40\n}; \n\n\n/* Method to return largest pair sum. Assumes that \n\nthere are at-least two elements in arr[] */\n\nstatic\nint\nfindLargestSumPair() \n\n{ \n\n// Initialize first and second largest element \n\nint\nfirst, second; \n\nif\n(arr[\n0\n] > arr[\n1\n]) \n\n{ \n\nfirst = arr[\n0\n]; \n\nsecond = arr[\n1\n]; \n\n} \n\nelse\n\n{ \n\nfirst = arr[\n1\n]; \n\nsecond = arr[\n0\n]; \n\n} \n\n\n// Traverse remaining array and find first and second largest \n\n// elements in overall array \n\nfor\n(\nint\ni = \n2\n; i<arr.length; i ++) \n\n{ \n\n/* If current element is greater than first then update both \n\nfirst and second */\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n/* If arr[i] is in between first and second then update second */\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nreturn\n(first + second); \n\n} \n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nSystem.out.println(\n\"Max Pair Sum is \"\n+ findLargestSumPair()); \n\n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 359, "index": 359}
{"src": "\n// JAVA Code for Find maximum sum possible \n// equal sum of three stacks \nclass\nGFG { \n\n\n// Returns maximum possible equal sum of three \n\n// stacks with removal of top elements allowed \n\npublic\nstatic\nint\nmaxSum(\nint\nstack1[], \nint\nstack2[], \n\nint\nstack3[], \nint\nn1, \nint\nn2, \n\nint\nn3) \n\n{ \n\nint\nsum1 = \n0\n, sum2 = \n0\n, sum3 = \n0\n; \n\n\n// Finding the initial sum of stack1. \n\nfor\n(\nint\ni=\n0\n; i < n1; i++) \n\nsum1 += stack1[i]; \n\n\n// Finding the initial sum of stack2. \n\nfor\n(\nint\ni=\n0\n; i < n2; i++) \n\nsum2 += stack2[i]; \n\n\n// Finding the initial sum of stack3. \n\nfor\n(\nint\ni=\n0\n; i < n3; i++) \n\nsum3 += stack3[i]; \n\n\n// As given in question, first element is top \n\n// of stack.. \n\nint\ntop1 =\n0\n, top2 = \n0\n, top3 = \n0\n; \n\nint\nans = \n0\n; \n\nwhile\n(\ntrue\n) \n\n{ \n\n// If any stack is empty \n\nif\n(top1 == n1 || top2 == n2 || top3 == n3) \n\nreturn\n0\n; \n\n\n// If sum of all three stack are equal. \n\nif\n(sum1 == sum2 && sum2 == sum3) \n\nreturn\nsum1; \n\n\n// Finding the stack with maximum sum and \n\n// removing its top element. \n\nif\n(sum1 >= sum2 && sum1 >= sum3) \n\nsum1 -= stack1[top1++]; \n\nelse\nif\n(sum2 >= sum3 && sum2 >= sum3) \n\nsum2 -= stack2[top2++]; \n\nelse\nif\n(sum3 >= sum2 && sum3 >= sum1) \n\nsum3 -= stack3[top3++]; \n\n} \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nstack1[] = { \n3\n, \n2\n, \n1\n, \n1\n, \n1\n}; \n\nint\nstack2[] = { \n4\n, \n3\n, \n2\n}; \n\nint\nstack3[] = { \n1\n, \n1\n, \n4\n, \n1\n}; \n\n\nint\nn1 = stack1.length; \n\nint\nn2 = stack2.length; \n\nint\nn3 = stack3.length; \n\n\nSystem.out.println(maxSum(stack1, stack2, \n\nstack3, n1, n2, n3)); \n\n} \n\n} \n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "linear", "from": "CorCod", "problem": 360, "index": 360}
{"src": "\n// Java program to rearrange an \n// array in minimum maximum form \n\npublic\nclass\nMain { \n\n\n// Prints max at first position, min at second \n\n// position second max at third position, second \n\n// min at fourth position and so on. \n\npublic\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n// initialize index of first minimum and first \n\n// maximum element \n\nint\nmax_ele = arr[n - \n1\n]; \n\nint\nmin_ele = arr[\n0\n]; \n\n// traverse array elements \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n// at even index : we have to put maximum element \n\nif\n(i % \n2\n== \n0\n) { \n\narr[i] = max_ele; \n\nmax_ele -= \n1\n; \n\n} \n\n\n// at odd index : we have to put minimum element \n\nelse\n{ \n\narr[i] = min_ele; \n\nmin_ele += \n1\n; \n\n} \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Original Array\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"\\nModified Array\\n\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 361, "index": 361}
{"src": "import java.util.Scanner;\npublic class P1075A\n{\n\tpublic static void main(String[] args)\n\t{\n\t Scanner scan=new Scanner(System.in);\n\t long n,x,y;\n\t n=scan.nextLong();\n\t x=scan.nextLong();\n\t y=scan.nextLong();\n\t boolean flag=true,flag1=false,flag2=false;\n\t long w1,w2,b1,b2;\n\t long W=0l,B=0l;\n\t w1=w2=1;\t\tb1=b2=n;\n\t while(w1<n)\n\t\t{\n\t\t if(w1==x)\n\t\t\t{flag1=true;\tbreak;}\n\t\t if(w2==y)\n\t\t\tbreak;\n\t\t ++w1;\t++w2;\t++W;\n\t\t}\n\t if(flag1)\n\t\tW+=(y-w2);\n\t else\n\t\tW+=(x-w1);\n\t while(b1>1)\n\t\t{\n\t\t if(b1==x)\n\t\t\t{flag2=true;\tbreak;}\n\t\t if(b2==y)\n\t\t\tbreak;\n\t\t --b1;\t--b2;\t++B;\n\t\t}\n\t if(flag2)\n\t\tB+=(b2-y);\n\t else\n\t\tB+=(b1-x);\n\t if(B<W)\n\t\tSystem.out.println(\"Black\");\n\t else\n\t\tSystem.out.println(\"White\");\n\t}\n}", "complexity": "linear", "from": "CorCod", "problem": 362, "index": 362}
{"src": "/**\n * BaZ :D\n */\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\npublic class Main\n{\n    static Reader scan;\n    static PrintWriter pw;\n    static int n,k,left[],right[],arr[];\n    static long MOD = 1000000007,count[],dp[];\n    public static void main(String[] args) {\n        new Thread(null,null,\"BaZ\",1<<25)\n        {\n            public void run()\n            {\n                try\n                {\n                    solve();\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n    static void solve() throws IOException\n    {\n        scan = new Reader();\n        pw = new PrintWriter(System.out,true);\n        StringBuilder sb = new StringBuilder();\n        n = ni();\n        k = ni();\n        int stack[] = new int[1000001];\n        int top = -1;\n        arr = new int[n];\n        left = new int[n];\n        right = new int[n];\n        for(int i=0;i<n;++i) {\n            arr[i] = ni();\n            while(top>=0 && arr[stack[top]]<=arr[i])\n                top--;\n            if(top==-1)\n                left[i] = 0;\n            else left[i] = stack[top]+1;\n            stack[++top] = i;\n        }\n        top = -1;\n        for(int i=n-1;i>=0;--i) {\n            while(top>=0 && arr[stack[top]]<arr[i])\n                top--;\n            if(top==-1)\n                right[i] = n-1;\n            else right[i] = stack[top]-1;\n            stack[++top] = i;\n        }\n        //pa(\"left\", left);\n        //pa(\"right\", right);\n        dp = new long[n+1];\n        for(int i=0;i<=n;++i) {\n            if(i<k)\n              continue;\n            dp[i] = dp[i-k+1] + (i-k+1);\n        }\n        count = new long[n];\n        long ans = 0;\n        for(int i=0;i<n;++i) {\n            int len = right[i]-left[i]+1;\n            int lef = i-left[i];\n            int rig = right[i]-i;\n            long count = dp[len] - dp[lef] - dp[rig];\n            if(count>=MOD)\n              count%=MOD;\n            ans += count*arr[i];\n            if(ans>=MOD)\n                ans%=MOD;\n        }\n        pl(ans);\n        pw.flush();\n        pw.close();\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 363, "index": 363}
{"src": "//package com.krakn.CF.D1159;\n\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n, k;\n        n = sc.nextInt();\n        k = sc.nextInt();\n\n        int a = (n - k) / 2;\n\n        StringBuilder s = new StringBuilder();\n\n        int i;\n        while (s.length() < n) {\n            i = 0;\n            while (i < a && s.length() < n) {\n                s.append(\"0\");\n                i++;\n            }\n            if (s.length() < n) s.append(\"1\");\n        }\n\n        System.out.println(s);\n    }\n}\n", "complexity": "linear", "from": "CorCod", "problem": 364, "index": 364}
{"src": "import java.util.*;\nimport java.io.*;\npublic class C{\n    static PrintWriter out;\n    static InputReader in;\n    public static void main(String args[]){\n        out = new PrintWriter(System.out);\n        in = new InputReader();\n        new C();\n        out.flush(); out.close();\n    }   \n    C(){\n       int a = solve();\n       out.print(a == 0 ? \"tokitsukaze\" : a == 1 ? \"quailty\" : \"once again\");\n    }\n    int n, k;\n    char ch[]; int a[], c0 = 0, c1 = 0;\n    TreeSet<Integer> ts[] = new TreeSet[2];\n    boolean check(){\n        int min = 0, max = n;\n        if(!ts[0].isEmpty()){\n            min = ts[0].first(); max = ts[0].last();\n            if(max - min + 1 > k)return true;\n        }\n        if(!ts[1].isEmpty()){\n            min = ts[1].first(); max = ts[1].last();\n            if(max - min + 1 > k)return true;   \n        }\n        return false;\n    }\n    int solve(){\n        n  = in.nextInt(); k = in.nextInt();\n        ch = in.next().trim().toCharArray(); a = new int[n];\n        for(int i = 0; i < n; i++)c1 += a[i] = ch[i] - '0';\n        c0 = n - c1;\n        for(int i = 0; i < k; i++){\n            if(a[i] == 0)c0--; else c1--;\n        }\n        if(c0 == 0 || c1 == 0)return 0;\n        for(int i = k; i < n; i++){\n            if(a[i] == 0)c0--; else c1--;\n            if(a[i - k] == 0)c0++; else c1++;\n            if(c0 == 0 || c1 == 0)return 0;\n        }\n\n        for(int i = 0; i < 2; i++)ts[i] = new TreeSet<>();\n        for(int i = 0; i < n; i++){\n            ts[a[i]].add(i);\n        }\n        for(int i = 0; i < k; i++){\n            ts[a[i]].remove(i);\n        }\n        if(check())return 2;\n        for(int i = k; i < n; i++){\n            ts[a[i]].remove(i); ts[a[i - k]].add(i - k);\n            if(check())return 2;\n        }\n        return 1;\n    }\n    public static class InputReader{\n        BufferedReader br;\n        StringTokenizer st;\n        InputReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        public String next(){\n            while(st == null || !st.hasMoreTokens()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch(IOException e){}\n            }\n            return st.nextToken();\n        }\n    }\n}\n        ", "complexity": "linear", "from": "CorCod", "problem": 365, "index": 365}
{"src": "\n// Java program to count of ways to place 1 x 4 tiles \n// on n x 4 grid \nimport\njava.io.*; \n\nclass\nGrid \n{ \n\n// Function that count the number of ways to place 1 x 4 tiles \n\n// on n x 4 grid. \n\nstatic\nint\ncount(\nint\nn) \n\n{ \n\n// Create a table to store results of sub-problems \n\n// dp[i] stores count of ways for i x 4 grid. \n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\ndp[\n0\n] = \n0\n; \n\n// Fill the table from d[1] to dp[n] \n\nfor\n(\nint\ni=\n1\n;i<=n;i++) \n\n{ \n\n// Base cases \n\nif\n(i >= \n1\n&& i <= \n3\n) \n\ndp[i] = \n1\n; \n\nelse\nif\n(i==\n4\n) \n\ndp[i] = \n2\n; \n\n\nelse\n\n{ \n\n// dp(i-1) : Place first tile horizontally \n\n// dp(i-4) : Place first tile vertically \n\n// which means 3 more tiles have \n\n// to be placed vertically. \n\ndp[i] = dp[i-\n1\n] + dp[i-\n4\n]; \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nSystem.out.println(\n\"Count of ways is: \"\n+ count(n)); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "complexity": "linear", "from": "CorCod", "problem": 366, "index": 366}
{"src": "import java.util.Scanner;\n\npublic class HammingDistancesSum {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString  a = sc.nextLine(), b = sc.nextLine();\n\t\tlong sum = 0;\n\t\tint frequency[][] = new int[200010][2];\n\t\tfor (int i = 1; i <= b.length(); i++) {\n\t        for (int j = 0; j < 2; j++)\n\t            frequency[i][j] = frequency[i - 1][j];\n\t        frequency[i][Character.getNumericValue((b.charAt(i - 1)))]++;\n\t    }\n\t   \n\t    for (int i = 0; i < a.length(); i++) {\n\t        int c = Character.getNumericValue(a.charAt(i));\n\t        for (int j = 0; j < 2; j++) {\n\t        \tint flippingTerm = Math.abs(c - j);\n\t        \tint endOfWindowValue = frequency[b.length() - a.length() + i + 1][j];\n\t        \tint startOfWindowOffset = frequency[i][j];\n\t            sum += flippingTerm * (endOfWindowValue - startOfWindowOffset);\n\t        }\n\t    }\n\t\tSystem.out.println(sum);\n\t\tsc.close();\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 367, "index": 367}
{"src": "\n// Java program to find union of two \n// sorted arrays (Handling Duplicates) \nclass\nFindUnion \n{ \n\n\nstatic\nvoid\nUnionArray(\nint\narr1[], \n\nint\narr2[]) \n\n{ \n\n// Taking max element present in either array \n\nint\nm = arr1[arr1.length - \n1\n]; \n\nint\nn = arr2[arr2.length - \n1\n]; \n\n\nint\nans = \n0\n; \n\n\nif\n(m > n) \n\n{ \n\nans = m; \n\n} \n\nelse\n\nans = n; \n\n\n// Finding elements from 1st array \n\n// (non duplicates only). Using \n\n// another array for storing union \n\n// elements of both arrays \n\n// Assuming max element present \n\n// in array is not more than 10^7 \n\nint\nnewtable[] = \nnew\nint\n[ans + \n1\n]; \n\n\n// First element is always \n\n// present in final answer \n\nSystem.out.print(arr1[\n0\n] + \n\" \"\n); \n\n\n// Incrementing the First element's count \n\n// in it's corresponding index in newtable \n\n++newtable[arr1[\n0\n]]; \n\n\n// Starting traversing the first \n\n// array from 1st index till last \n\nfor\n(\nint\ni = \n1\n; i < arr1.length; i++) \n\n{ \n\n// Checking whether current element \n\n// is not equal to it's previous element \n\nif\n(arr1[i] != arr1[i - \n1\n]) \n\n{ \n\nSystem.out.print(arr1[i] + \n\" \"\n); \n\n++newtable[arr1[i]]; \n\n} \n\n} \n\n\n// Finding only non common \n\n// elements from 2nd array \n\nfor\n(\nint\nj = \n0\n; j < arr2.length; j++) \n\n{ \n\n// By checking whether it's already \n\n// present in newtable or not \n\nif\n(newtable[arr2[j]] == \n0\n) \n\n{ \n\nSystem.out.print(arr2[j] + \n\" \"\n); \n\n++newtable[arr2[j]]; \n\n} \n\n} \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n4\n, \n5\n}; \n\n\nUnionArray(arr1, arr2); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 368, "index": 368}
{"src": "\n\nimport java.util.Scanner;\npublic class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 369, "index": 369}
{"src": "\n// Java O(n) solution for \n// finding smallest subarray \n// with sum greater than x \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Returns length of smallest \n// subarray with sum greater \n// than x. If there is no \n// subarray with given sum, \n// then returns n+1 \nstatic\nint\nsmallestSubWithSum(\nint\narr[], \n\nint\nn, \nint\nx) \n{ \n\n// Initialize current \n\n// sum and minimum length \n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n// Initialize starting \n\n// and ending indexes \n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n// Keep adding array \n\n// elements while current \n\n// sum is smaller than x \n\nwhile\n(curr_sum <= x && end < n) \n\n{ \n\n// Ignore subarrays with \n\n// negative sum if x is \n\n// positive. \n\nif\n(curr_sum <= \n0\n&& x > \n0\n) \n\n{ \n\nstart = end; \n\ncurr_sum = \n0\n; \n\n} \n\n\ncurr_sum += arr[end++]; \n\n} \n\n\n// If current sum becomes \n\n// greater than x. \n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n// Update minimum \n\n// length if needed \n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n// remove starting elements \n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n} \n\n\n// Driver Code \npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr1[] = {- \n8\n, \n1\n, \n4\n, \n2\n, -\n6\n}; \n\nint\nx = \n6\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, \n\nn1, x); \n\nif\n(res1 == n1 + \n1\n) \n\nSystem.out.println(\n\"Not possible\"\n); \n\nelse\n\nSystem.out.println (res1); \n} \n} \n\n// This code is contributed by ajit ", "complexity": "linear", "from": "CorCod", "problem": 370, "index": 370}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Cf1017A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int result = 1;\n        int thomasSum = 0;\n        StringTokenizer stk;\n        stk = new StringTokenizer(br.readLine());\n        int first = Integer.parseInt(stk.nextToken());\n        int second = Integer.parseInt(stk.nextToken());\n        int third = Integer.parseInt(stk.nextToken());\n        int fourth = Integer.parseInt(stk.nextToken());\n        thomasSum = first + second + third + fourth;\n        int tmp;\n        for (int i = 1; i < n; i++) {\n            stk = new StringTokenizer(br.readLine());\n            first = Integer.parseInt(stk.nextToken());\n            second = Integer.parseInt(stk.nextToken());\n            third = Integer.parseInt(stk.nextToken());\n            fourth = Integer.parseInt(stk.nextToken());\n            tmp = first + second + third + fourth;\n            if (tmp > thomasSum)\n                result++;\n        }\n        System.out.println(result);\n    }\n}", "complexity": "linear", "from": "CorCod", "problem": 371, "index": 371}
{"src": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\t\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tint max = -1;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x = in.nextInt();\n\t\t\tdq.add(x);\n\t\t\tmax = Math.max(max, x);\n\t\t}\n\t\tArrayList<Pair> ans = new ArrayList<>();\n\t\twhile(dq.peekFirst() != max) {\n\t\t\tint a = dq.pollFirst();\n\t\t\tint b = dq.pollFirst();\n\t\t\tans.add(new Pair(a, b));\n\t\t\tif(a > b) {\n\t\t\t\tdq.addFirst(a);\n\t\t\t\tdq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdq.addFirst(b);\n\t\t\t\tdq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> a = new ArrayList<>();\n\t\tdq.pollFirst();\n\t\tfor(int x : dq)\n\t\t\ta.add(x);\n\t\twhile(q --> 0) {\n\t\t\tlong m = in.nextLong() - 1;\n\t\t\tif(m < ans.size()) {\n\t\t\t\tSystem.out.println(ans.get((int)m).first + \" \" + ans.get((int)m).second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint idx = (int)((m - ans.size()) % a.size());\n\t\t\t\tSystem.out.println(max + \" \" + a.get(idx));\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "complexity": "linear", "from": "CorCod", "problem": 372, "index": 372}
{"src": "\n// Java program to find maximum sum \n// of all rotation of i*arr[i] using pivot. \n\nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// function definition \nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nsum = \n0\n; \n\nint\ni; \n\nint\npivot = findPivot(arr, n); \n\n\n// difference in pivot and index of \n\n// last element of array \n\nint\ndiff = n - \n1\n- pivot; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nsum= sum + ((i + diff) % n) * arr[i]; \n\n} \n\nreturn\nsum; \n} \n\n// function to find pivot \nstatic\nint\nfindPivot(\nint\narr[], \nint\nn) \n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] > arr[(i + \n1\n) % n]) \n\nreturn\ni; \n\n} \n\nreturn\n0\n; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n// rotated input array \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nmax = maxSum(arr,n); \n\nSystem.out.println(max); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 373, "index": 373}
{"src": "\n// Java program to count occurrences \n// of an element \n\nclass\nMain \n{ \n\n// Returns number of times x occurs in arr[0..n-1] \n\nstatic\nint\ncountOccurrences(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nif\n(x == arr[i]) \n\nres++; \n\nreturn\nres; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n3\n, \n4\n, \n7\n,\n8\n,\n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.println(countOccurrences(arr, n, x)); \n\n} \n} ", "complexity": "linear", "from": "CorCod", "problem": 374, "index": 374}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.InputMismatchException;\nimport java.util.Stack;\npublic class D527A2 {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint N = in.nextInt();\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint num = in.nextInt() % 2;\n\t\t\tif(stack.size() >= 1 && stack.lastElement() == num)\n\t\t\t\tstack.pop();\n\t\t\telse\n\t\t\t\tstack.add(num);\n\t\t}\n\t\t\n\t\tSystem.out.println(stack.size() <= 1 ? \"YES\" : \"NO\");\n\t}\n\t\n\t/**\n\t * Source: Matt Fontaine\n\t */\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}\n/*\n5\n2 1 1 2 5\noutputCopy\nYES\ninputCopy\n3\n4 5 3\noutputCopy\nYES\ninputCopy\n2\n10 10\noutputCopy\nYES\ninputCopy\n3\n1 2 3\noutputCopy\nNO\n\n5\n2 3 2 2 3\n\nYES\n*/", "complexity": "linear", "from": "CorCod", "problem": 375, "index": 375}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package newpackage;\nimport java.util.*;\n/**\n *\n * @author parpaorsa\n */\npublic class NewClass {\n    static Scanner in=new Scanner(System.in);\n    public static void main(String[] args) {\n        int n = in.nextInt(),ans=Integer.MAX_VALUE,t=0;\n        String x = in.next();\n        for (int i = 0; i < n; i++) {\n            if(x.charAt(i)=='-')t--;\n            else t++;\n            ans=Math.min(ans,t);\n        }\n           if(ans <= 0) \n               System.out.println(Math.abs(ans)+t);\n           else \n               System.out.println(t);\n    }\n \n}\n", "complexity": "linear", "from": "CorCod", "problem": 376, "index": 376}
{"src": "\n\nimport java.util.Scanner;\npublic class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}\n", "complexity": "linear", "from": "CorCod", "problem": 377, "index": 377}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class Code {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t int n = Integer.parseInt(br.readLine());\n\t\t HashMap<Double,Integer>h = new HashMap<>();\n\t\t double [] temp = new double[n];\n\t\t int m = 0;\n\t\t for(int i=0;i<n;i++) {\n\t\t\t String l = br.readLine();\n\t\t\t int[] x = new int[4];\n\t\t\t int k=0;\n\t\t\t boolean t = false;\n\t\t\t for(int j=0;j<l.length();j++) {\n\t\t\t\t if(l.charAt(j)=='(' || l.charAt(j)=='+' || l.charAt(j)==')' || l.charAt(j)=='/')\n\t\t\t\t\t x[k++] = j;\n\t\t\t }\n\t\t\t double a = Integer.parseInt(l.substring(x[0]+1,x[1]));\n\t\t\t double b = Integer.parseInt(l.substring(x[1]+1, x[2]));\n\t\t\t double c = Integer.parseInt(l.substring(x[3]+1));\n\t\t\t temp[m++] = (a+b)/c;\n\t\t\t //System.out.print((a+b)/c + \" \");\n\t\t\tif(h.containsKey((a+b)/c))\n\t\t\t\t\th.put((a+b)/c, h.get((a+b)/c)+1);\n\t\t\telse\n\t\t\t\th.put((a+b)/c, 1);\n\t\t }\n\t\t //System.out.println(h);\n\t\t for(int i=0;i<n;i++) {\n\t\t\t System.out.print(h.get(temp[i]) + \" \");\n\t\t }\n\t}\n\t}\n", "complexity": "linear", "from": "CorCod", "problem": 378, "index": 378}
{"src": "\n// Java program to convert BST to binary tree such that sum of \n// all greater keys is added to every key \n\nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nSum { \n\n\nint\nsum = \n0\n; \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\nSum summ = \nnew\nSum(); \n\n\n// A recursive function that traverses the given BST in reverse inorder and \n\n// for every key, adds all greater keys to it \n\nvoid\naddGreaterUtil(Node node, Sum sum_ptr) { \n\n\n// Base Case \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n// Recur for right subtree first so that sum of all greater \n\n// nodes is stored at sum_ptr \n\naddGreaterUtil(node.right, sum_ptr); \n\n\n// Update the value at sum_ptr \n\nsum_ptr.sum = sum_ptr.sum + node.data; \n\n\n// Update key of this node \n\nnode.data = sum_ptr.sum; \n\n\n// Recur for left subtree so that the updated sum is added \n\n// to smaller nodes \n\naddGreaterUtil(node.left, sum_ptr); \n\n} \n\n\n// A wrapper over addGreaterUtil(). It initializes sum and calls \n\n// addGreaterUtil() to recursivel upodate and use value of sum \n\nNode addGreater(Node node) { \n\naddGreaterUtil(node, summ); \n\nreturn\nnode; \n\n} \n\n\n// A utility function to print inorder traversal of Binary Tree \n\nvoid\nprintInorder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n// Driver program to test the above functions \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n13\n); \n\n\nSystem.out.println(\n\"Inorder traversal of given tree \"\n); \n\ntree.printInorder(root); \n\nNode node = tree.addGreater(root); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Inorder traversal of modified tree \"\n); \n\ntree.printInorder(node); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "linear", "from": "CorCod", "problem": 379, "index": 379}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class C {\n\n\tpublic static int mod = 1000000000 + 7;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString n = br.readLine();\n\t\tint k = Integer.parseInt(br.readLine());\n\t\tint l = n.length();\n\t\t\n\t\tif(k == 0) {\n\t\t\tSystem.out.println(1);\n\t\t}else {\n\t\t\tint max = 1000;\n\t\t\tif (l <= 10) {\n\t\t\t\tmax = Integer.min(1000, Integer.parseInt(n, 2));\n\t\t\t}\n\n\t\t\tint[] steps = new int[max + 1];\n\t\t\t\t\t\n\t\t\tfor (int i = 2; i <= max; i++) {\n\t\t\t\tint ones = numberOfOnes(i);\n\t\t\t\tsteps[i] = 1 + steps[ones];\n\t\t\t}\n\n\t\t\tif (l <= 10) {\n\t\t\t\tint ans = 0;\n\t\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\t\tif (steps[i] == k) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t} else {\n\t\t\t\tint[][] C = binomial(max);\n\n\t\t\t\tint ans = 0;\n\t\t\t\tint count = 0;\n\n\t\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\t\tif (n.charAt(i) == '1') {\n\t\t\t\t\t\tfor (int j = count; j < max; j++) {\n\t\t\t\t\t\t\tif (steps[j] == k - 1) {\n\t\t\t\t\t\t\t\tans = (ans + C[l - i - 1][j - count]) % mod;\n\t\t\t\t\t\t\t\tif (i == 0 && k == 1) {\n\t\t\t\t\t\t\t\t\tans = (ans + mod - 1) % mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint ones = 0;\n\t\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\t\tif (n.charAt(i) == '1') {\n\t\t\t\t\t\tones++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (steps[ones] == k-1) {\n\t\t\t\t\tans = (ans + 1) % mod;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int numberOfOnes(int x) {\n\t\tchar[] s = Integer.toBinaryString(x).toCharArray();\n\t\tint count = 0;\n\t\tfor (char c : s) {\n\t\t\tif (c == '1') {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static int[][] binomial(int n) {\n\t\tint[][] C = new int[n + 1][n + 1];\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tC[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tC[i][j] = ((C[i - 1][j - 1] % mod) + (C[i - 1][j] % mod)) % mod;\n\t\t\t}\n\t\t}\n\n\t\treturn C;\n\t}\n\n}\n", "complexity": "linear", "from": "CorCod", "problem": 380, "index": 380}
{"src": "\n// Java program to count number of distinct \n// subsequences of a given string. \nimport\njava.util.ArrayList; \nimport\njava.util.Arrays; \npublic\nclass\nCount_Subsequences { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n256\n; \n\n\n// Returns count of distinct sunsequences of str. \n\nstatic\nint\ncountSub(String str) \n\n{ \n\n// Create an array to store index \n\n// of last \n\nint\n[] last = \nnew\nint\n[MAX_CHAR]; \n\nArrays.fill(last, -\n1\n); \n\n\n// Length of input string \n\nint\nn = str.length(); \n\n\n// dp[i] is going to store count of distinct \n\n// subsequences of length i. \n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\n\n// Empty substring has only one subsequence \n\ndp[\n0\n] = \n1\n; \n\n\n// Traverse through all lengths from 1 to n. \n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n// Number of subsequences with substring \n\n// str[0..i-1] \n\ndp[i] = \n2\n*dp[i-\n1\n]; \n\n\n// If current character has appeared \n\n// before, then remove all subsequences \n\n// ending with previous occurrence. \n\nif\n(last[(\nint\n)str.charAt(i-\n1\n)] != -\n1\n) \n\ndp[i] = dp[i] - dp[last[(\nint\n)str.charAt(i-\n1\n)]]; \n\n\n// Mark occurrence of current character \n\nlast[(\nint\n)str.charAt(i-\n1\n)] = (i-\n1\n); \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(countSub(\n\"gfg\"\n)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "linear", "from": "CorCod", "problem": 381, "index": 381}
{"src": "\n// Java program to find closest pair in an array \nclass\nClosestPair \n{ \n\n// ar1[0..m-1] and ar2[0..n-1] are two given sorted \n\n// arrays/ and x is given number. This function prints \n\n// the pair from both arrays such that the sum of the \n\n// pair is closest to x. \n\nvoid\nprintClosest(\nint\nar1[], \nint\nar2[], \nint\nm, \nint\nn, \nint\nx) \n\n{ \n\n// Initialize the diff between pair sum and x. \n\nint\ndiff = Integer.MAX_VALUE; \n\n\n// res_l and res_r are result indexes from ar1[] and ar2[] \n\n// respectively \n\nint\nres_l = \n0\n, res_r = \n0\n; \n\n\n// Start from left side of ar1[] and right side of ar2[] \n\nint\nl = \n0\n, r = n-\n1\n; \n\nwhile\n(l<m && r>=\n0\n) \n\n{ \n\n// If this pair is closer to x than the previously \n\n// found closest, then update res_l, res_r and diff \n\nif\n(Math.abs(ar1[l] + ar2[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(ar1[l] + ar2[r] - x); \n\n} \n\n\n// If sum of this pair is more than x, move to smaller \n\n// side \n\nif\n(ar1[l] + ar2[r] > x) \n\nr--; \n\nelse\n// move to the greater side \n\nl++; \n\n} \n\n\n// Print the result \n\nSystem.out.print(\n\"The closest pair is [\"\n+ ar1[res_l] + \n\n\", \"\n+ ar2[res_r] + \n\"]\"\n); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nClosestPair ob = \nnew\nClosestPair(); \n\nint\nar1[] = {\n1\n, \n4\n, \n5\n, \n7\n}; \n\nint\nar2[] = {\n10\n, \n20\n, \n30\n, \n40\n}; \n\nint\nm = ar1.length; \n\nint\nn = ar2.length; \n\nint\nx = \n38\n; \n\nob.printClosest(ar1, ar2, m, n, x); \n\n} \n} \n/*This code is contributed by Rajat Mishra */", "complexity": "linear", "from": "CorCod", "problem": 382, "index": 382}
{"src": "\n// Java program to construct a binary tree from preorder traversal \n\n// A Binary Tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nIndex \n{ \n\nint\nindex = \n0\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nIndex myindex = \nnew\nIndex(); \n\n\n/* A recursive function to create a Binary Tree from given pre[] \n\npreLN[] arrays. The function returns root of tree. index_ptr is used \n\nto update index values in recursive calls. index must be initially \n\npassed as 0 */\n\nNode constructTreeUtil(\nint\npre[], \nchar\npreLN[], Index index_ptr, \n\nint\nn, Node temp) \n\n{ \n\n// store the current value of index in pre[] \n\nint\nindex = index_ptr.index; \n\n\n// Base Case: All nodes are constructed \n\nif\n(index == n) \n\nreturn\nnull\n; \n\n\n// Allocate memory for this node and increment index for \n\n// subsequent recursive calls \n\ntemp = \nnew\nNode(pre[index]); \n\n(index_ptr.index)++; \n\n\n// If this is an internal node, construct left and right subtrees \n\n// and link the subtrees \n\nif\n(preLN[index] == \n'N'\n) \n\n{ \n\ntemp.left = constructTreeUtil(pre, preLN, index_ptr, n, \n\ntemp.left); \n\ntemp.right = constructTreeUtil(pre, preLN, index_ptr, n, \n\ntemp.right); \n\n} \n\n\nreturn\ntemp; \n\n} \n\n\n// A wrapper over constructTreeUtil() \n\nNode constructTree(\nint\npre[], \nchar\npreLN[], \nint\nn, Node node) \n\n{ \n\n// Initialize index as 0. Value of index is used in recursion to \n\n// maintain the current index in pre[] and preLN[] arrays. \n\nint\nindex = \n0\n; \n\n\nreturn\nconstructTreeUtil(pre, preLN, myindex, n, node); \n\n} \n\n\n/* This function is used only for testing */\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first recur on left child */\n\nprintInorder(node.left); \n\n\n/* then print the data of node */\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n/* now recur on right child */\n\nprintInorder(node.right); \n\n} \n\n\n// driver function to test the above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\npre[] = \nnew\nint\n[]{\n10\n, \n30\n, \n20\n, \n5\n, \n15\n}; \n\nchar\npreLN[] = \nnew\nchar\n[]{\n'N'\n, \n'N'\n, \n'L'\n, \n'L'\n, \n'L'\n}; \n\nint\nn = pre.length; \n\n\n// construct the above tree \n\nNode mynode = tree.constructTree(pre, preLN, n, tree.root); \n\n\n// Test the constructed tree \n\nSystem.out.println(\n\"Following is Inorder Traversal of the\"\n\n+ \n\"Constructed Binary Tree: \"\n); \n\ntree.printInorder(mynode); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal \n", "complexity": "linear", "from": "CorCod", "problem": 383, "index": 383}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\t\n\n\n\n", "complexity": "linear", "from": "CorCod", "problem": 384, "index": 384}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class RGBSubstring {\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int Q = scanner.nextInt();\n        while(Q-->0) {\n            int N = scanner.nextInt();\n            int K = scanner.nextInt();\n            String s1 = \"RGB\";\n            String s2 = \"GBR\";\n            String s3 = \"BRG\";\n            char[] arr = scanner.next().toCharArray();\n            int[] cnts = new int[3];\n            for(int i = 0; i < K; i++) {\n                int ind = i % 3;\n                if (arr[i] != s1.charAt(ind)) cnts[0]++;\n                if (arr[i] != s2.charAt(ind)) cnts[1]++;\n                if (arr[i] != s3.charAt(ind)) cnts[2]++;\n            }\n            int ans = Math.min(Math.min(cnts[0], cnts[1]), cnts[2]);\n            for(int i = K; i < N; i++) {\n                int ind = (K-1)%3;\n                int[] nextCnts = new int[3];\n                nextCnts[1] = cnts[0];\n                nextCnts[2] = cnts[1];\n                nextCnts[0] = cnts[2];\n                if ('R' != arr[i-K]) nextCnts[1]--;\n                if ('G' != arr[i-K]) nextCnts[2]--;\n                if ('B' != arr[i-K]) nextCnts[0]--;\n                if (arr[i] != s1.charAt(ind)) nextCnts[0]++;\n                if (arr[i] != s2.charAt(ind)) nextCnts[1]++;\n                if (arr[i] != s3.charAt(ind)) nextCnts[2]++;\n                cnts = nextCnts;\n                for(int j = 0; j < 3; j++) ans = Math.min(ans, cnts[j]);\n            }\n            out.println(ans);\n        }\n        out.flush();\n    }\n    \n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 385, "index": 385}
{"src": "\n// A simple Java program to find max subarray XOR \nclass\nGFG { \n\nstatic\nint\nmaxSubarrayXOR(\nint\narr[], \nint\nn) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n// Initialize result \n\n\n// Pick starting points of subarrays \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n// to store xor of current subarray \n\nint\ncurr_xor = \n0\n; \n\n\n// Pick ending points of subarrays starting with i \n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\ncurr_xor = curr_xor ^ arr[j]; \n\nans = Math.max(ans, curr_xor); \n\n} \n\n} \n\nreturn\nans; \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n8\n, \n1\n, \n2\n, \n12\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Max subarray XOR is \"\n+ \n\nmaxSubarrayXOR(arr, n)); \n\n} \n} \n//This code is contributed by Sumit Ghosh ", "complexity": "quadratic", "from": "CorCod", "problem": 386, "index": 386}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.System.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t// out.println(\"---- \"+arr[i]);\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// out.println(list.toString());\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// out.println(list.toString());\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "complexity": "quadratic", "from": "CorCod", "problem": 387, "index": 387}
{"src": "\n// Java program to construct tree from inorder traversal \n\n/* A binary tree node has data, pointer to left child \n\nand a pointer to right child */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* Recursive function to construct binary of size len from \n\nInorder traversal inorder[]. Initial values of start and end \n\nshould be 0 and len -1. */\n\nNode buildTree(\nint\ninorder[], \nint\nstart, \nint\nend, Node node) \n\n{ \n\nif\n(start > end) \n\nreturn\nnull\n; \n\n\n/* Find index of the maximum element from Binary Tree */\n\nint\ni = max(inorder, start, end); \n\n\n/* Pick the maximum value and make it root */\n\nnode = \nnew\nNode(inorder[i]); \n\n\n/* If this is the only element in inorder[start..end], \n\nthen return it */\n\nif\n(start == end) \n\nreturn\nnode; \n\n\n/* Using index in Inorder traversal, construct left and \n\nright subtress */\n\nnode.left = buildTree(inorder, start, i - \n1\n, node.left); \n\nnode.right = buildTree(inorder, i + \n1\n, end, node.right); \n\n\nreturn\nnode; \n\n} \n\n\n/* UTILITY FUNCTIONS */\n\n\n/* Function to find index of the maximum value in arr[start...end] */\n\nint\nmax(\nint\narr[], \nint\nstrt, \nint\nend) \n\n{ \n\nint\ni, max = arr[strt], maxind = strt; \n\nfor\n(i = strt + \n1\n; i <= end; i++) \n\n{ \n\nif\n(arr[i] > max) \n\n{ \n\nmax = arr[i]; \n\nmaxind = i; \n\n} \n\n} \n\nreturn\nmaxind; \n\n} \n\n\n/* This funtcion is here just to test buildTree() */\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first recur on left child */\n\nprintInorder(node.left); \n\n\n/* then print the data of node */\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n/* now recur on right child */\n\nprintInorder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n/* Assume that inorder traversal of following tree is given \n\n40 \n\n/ \\ \n\n10 30 \n\n/ \\ \n\n5 28 */\n\nint\ninorder[] = \nnew\nint\n[]{\n5\n, \n10\n, \n40\n, \n30\n, \n28\n}; \n\nint\nlen = inorder.length; \n\nNode mynode = tree.buildTree(inorder, \n0\n, len - \n1\n, tree.root); \n\n\n/* Let us test the built tree by printing Inorder traversal */\n\nSystem.out.println(\n\"Inorder traversal of the constructed tree is \"\n); \n\ntree.printInorder(mynode); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "quadratic", "from": "CorCod", "problem": 388, "index": 388}
{"src": "\n// java program to find maximum \n// equilibrium sum. \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Function to find maximum \n\n// equilibrium sum. \n\nstatic\nint\nfindMaxSum(\nint\n[]arr, \nint\nn) \n\n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\nprefix_sum = arr[i]; \n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nprefix_sum += arr[j]; \n\n\nint\nsuffix_sum = arr[i]; \n\n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nsuffix_sum += arr[j]; \n\n\nif\n(prefix_sum == suffix_sum) \n\nres = Math.max(res, prefix_sum); \n\n} \n\n\nreturn\nres; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {-\n2\n, \n5\n, \n3\n, \n1\n, \n2\n, \n6\n, -\n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findMaxSum(arr, n)); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "complexity": "quadratic", "from": "CorCod", "problem": 389, "index": 389}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author pandusonu\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            // out.print(\"Case #\" + testNumber + \": \");\n            int n = in.readInt();\n            int[] a = in.readIntArray(n);\n            int[][] sol = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                sol[0][i] = a[i];\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < n - i; j++) {\n                    sol[i][j] = sol[i - 1][j] ^ sol[i - 1][j + 1];\n                }\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < n - i; j++) {\n                    sol[i][j] = Math.max(sol[i][j], Math.max(sol[i - 1][j], sol[i - 1][j + 1]));\n                }\n            }\n            int q = in.readInt();\n            for (int i = 0; i < q; i++) {\n                int l = in.readInt() - 1;\n                int r = in.readInt() - 1;\n                out.println(sol[r - l][l]);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() {\n            try {\n                if (curChar >= numChars) {\n                    curChar = 0;\n                    numChars = stream.read(buf);\n                    if (numChars <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            return (int) readLong();\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n                if (c == -1) throw new RuntimeException();\n            }\n            boolean negative = false;\n            if (c == '-') {\n                negative = true;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res *= 10;\n                res += (c - '0');\n                c = read();\n            } while (!isSpaceChar(c));\n            return negative ? (-res) : (res);\n        }\n\n        public int[] readIntArray(int size) {\n            int[] arr = new int[size];\n            for (int i = 0; i < size; i++) arr[i] = readInt();\n            return arr;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "from": "CorCod", "problem": 390, "index": 390}
{"src": "\n// Java program to find a triplet \nclass\nFindTriplet { \n\n\n// returns true if there is triplet with sum equal \n\n// to 'sum' present in A[]. Also, prints the triplet \n\nboolean\nfind3Numbers(\nint\nA[], \nint\narr_size, \nint\nsum) \n\n{ \n\nint\nl, r; \n\n\n/* Sort the elements */\n\nquickSort(A, \n0\n, arr_size - \n1\n); \n\n\n/* Now fix the first element one by one and find the \n\nother two elements */\n\nfor\n(\nint\ni = \n0\n; i < arr_size - \n2\n; i++) { \n\n\n// To find the other two elements, start two index variables \n\n// from two corners of the array and move them toward each \n\n// other \n\nl = i + \n1\n; \n// index of the first element in the remaining elements \n\nr = arr_size - \n1\n; \n// index of the last element \n\nwhile\n(l < r) { \n\nif\n(A[i] + A[l] + A[r] == sum) { \n\nSystem.out.print(\n\"Triplet is \"\n+ A[i] + \n\", \"\n+ A[l] + \n\", \"\n+ A[r]); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(A[i] + A[l] + A[r] < sum) \n\nl++; \n\n\nelse\n// A[i] + A[l] + A[r] > sum \n\nr--; \n\n} \n\n} \n\n\n// If we reach here, then no triplet was found \n\nreturn\nfalse\n; \n\n} \n\n\nint\npartition(\nint\nA[], \nint\nsi, \nint\nei) \n\n{ \n\nint\nx = A[ei]; \n\nint\ni = (si - \n1\n); \n\nint\nj; \n\n\nfor\n(j = si; j <= ei - \n1\n; j++) { \n\nif\n(A[j] <= x) { \n\ni++; \n\nint\ntemp = A[i]; \n\nA[i] = A[j]; \n\nA[j] = temp; \n\n} \n\n} \n\nint\ntemp = A[i + \n1\n]; \n\nA[i + \n1\n] = A[ei]; \n\nA[ei] = temp; \n\nreturn\n(i + \n1\n); \n\n} \n\n\n/* Implementation of Quick Sort \n\nA[] --> Array to be sorted \n\nsi --> Starting index \n\nei --> Ending index \n\n*/\n\nvoid\nquickSort(\nint\nA[], \nint\nsi, \nint\nei) \n\n{ \n\nint\npi; \n\n\n/* Partitioning index */\n\nif\n(si < ei) { \n\npi = partition(A, si, ei); \n\nquickSort(A, si, pi - \n1\n); \n\nquickSort(A, pi + \n1\n, ei); \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindTriplet triplet = \nnew\nFindTriplet(); \n\nint\nA[] = { \n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n8\n}; \n\nint\nsum = \n22\n; \n\nint\narr_size = A.length; \n\n\ntriplet.find3Numbers(A, arr_size, sum); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 391, "index": 391}
{"src": "// discussed with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF915D {\n\tstatic ArrayList[] aa;\n\tstatic boolean[] visited, instack;\n\tstatic int[] stack;\n\tstatic int cnt, h_, i_, j_;\n\tstatic boolean dfs1(int i) {\n\t\tif (visited[i]) {\n\t\t\tif (instack[i]) {\n\t\t\t\th_ = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvisited[i] = instack[i] = true;\n\t\tstack[cnt++] = i;\n\t\tArrayList<Integer> adj = aa[i];\n\t\tfor (int j : adj)\n\t\t\tif (dfs1(j))\n\t\t\t\treturn true;\n\t\tinstack[i] = false;\n\t\tcnt--;\n\t\treturn false;\n\t}\n\tstatic boolean dfs2(int i) {\n\t\tif (visited[i])\n\t\t\treturn instack[i];\n\t\tvisited[i] = instack[i] = true;\n\t\tArrayList<Integer> adj = aa[i];\n\t\tfor (int j : adj)\n\t\t\tif (!(i == i_ && j == j_) && dfs2(j))\n\t\t\t\treturn true;\n\t\tinstack[i] = false;\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint m = Integer.parseInt(st.nextToken());\n\t\taa = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = new ArrayList<Integer>();\n\t\twhile (m-- > 0) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint i = Integer.parseInt(st.nextToken()) - 1;\n\t\t\tint j = Integer.parseInt(st.nextToken()) - 1;\n\t\t\taa[i].add(j);\n\t\t}\n\t\tvisited = new boolean[n];\n\t\tinstack = new boolean[n];\n\t\tstack = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (dfs1(i))\n\t\t\t\tbreak;\n\t\tif (cnt == 0) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t\treturn;\n\t\t}\n\t\tfor (j_ = h_, i_ = stack[--cnt]; ; j_ = i_, i_ = stack[--cnt]) {\n\t\t\tArrays.fill(visited, false);\n\t\t\tArrays.fill(instack, false);\n\t\t\tboolean cycle = false;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (dfs2(i)) {\n\t\t\t\t\tcycle = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!cycle) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (i_ == h_)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t}\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 392, "index": 392}
{"src": "\n// A Naive Java program to find \n// maximum sum rotation \nimport\njava.util.*; \nimport\njava.io.*; \n\nclass\nGFG { \n\n// Returns maximum value of i*arr[i] \nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n// Initialize result \nint\nres = Integer.MIN_VALUE; \n\n// Consider rotation beginning with i \n// for all possible values of i. \nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n// Initialize sum of current rotation \n\nint\ncurr_sum = \n0\n; \n\n\n// Compute sum of all values. We don't \n\n// actually rotation the array, but compute \n\n// sum by finding ndexes when arr[i] is \n\n// first element \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n// Update result if required \n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n} \n\n// This code is contributed by Sahil_Bansall ", "complexity": "quadratic", "from": "CorCod", "problem": 393, "index": 393}
{"src": "\nclass\nGFG{ \n\n// A dynamic programming based function to find nth \n// Catalan number \n\nstatic\nint\ncatalanDP(\nint\nn) { \n\n// Table to store results of subproblems \n\nint\ncatalan[] = \nnew\nint\n[n + \n2\n]; \n\n\n// Initialize first two values in table \n\ncatalan[\n0\n] = \n1\n; \n\ncatalan[\n1\n] = \n1\n; \n\n\n// Fill entries in catalan[] using recursive formula \n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\ncatalan[i] = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) { \n\ncatalan[i] += catalan[j] * catalan[i - j - \n1\n]; \n\n} \n\n} \n\n\n// Return last entry \n\nreturn\ncatalan[n]; \n\n} \n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalanDP(i) + \n\" \"\n); \n\n} \n\n} \n} \n// This code contributed by Rajput-Ji ", "complexity": "quadratic", "from": "CorCod", "problem": 394, "index": 394}
{"src": "/**\n * Created by Baelish on 8/28/2018.\n */\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class F_DSU {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        n = in.nextInt();\n        \n        int brr[] = new int[2*n];\n        for (int i = 0; i < 2*n; i+= 2) {\n            brr[i] = in.nextInt();\n            brr[i+1] = in.nextInt();\n        }\n\n        arr = shrink(brr);\n        int imap[] = new int[2*n];\n        for (int i = 0; i < 2*n; i++) {\n            imap[arr[i]] = brr[i];\n        }\n\n        int idx = binarySearch(arr.length);\n        if(idx >= arr.length) pw.println(-1);\n        else pw.println(imap[idx]);\n\n        pw.close();\n    }\n    static int n, arr[];\n\n    static int binarySearch(int H) {\n        int lo = 0, hi = H, mid;\n        while (lo < hi) {\n            mid = (lo + hi) / 2;\n            if (check(mid)) hi = mid;\n            else lo = mid + 1;\n        }\n        if(lo > 0 && check(lo-1)) return lo-1;\n        return lo;\n    }\n\n    static boolean check(int m){\n        DSU dsu = new DSU(2*n);\n        for (int i = 0; i < n; i++) {\n            int u = arr[2*i], v = arr[2*i+1];\n            if(u > m) return false;\n            if(v > m){\n                if(++dsu.cycle[dsu.find(u)] >= 2) return false;\n            }\n            else{\n                if(!dsu.union(u, v)){\n                    if(++dsu.cycle[dsu.find(u)] >= 2) return false;\n                }\n                else{\n                    if(dsu.cycle[dsu.find(u)] >= 2) return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    static class DSU{\n        int parent[], cycle[], n;\n        DSU(int N){\n            n = N;\n            parent = new int[N];\n            cycle = new int[N];\n            for(int i = 0; i < N; i++){\n                parent[i] = i;\n            }\n        }\n\n        DSU(int [] p){\n            parent = p; n = p.length;\n        }\n\n        int find(int i) {\n            int p = parent[i];\n            if (i == p) return i;\n            return parent[i] = find(p);\n        }\n\n        boolean equiv(int u, int v){\n            return find(u) == find(v);\n        }\n\n        boolean union(int u, int v){\n            u = find(u); v = find(v);\n            if(u != v) {\n                parent[u] = parent[v];\n                cycle[v] += cycle[u];\n            }\n            return u != v;\n        }\n\n        int count(){\n            int cnt = 0;\n            for(int i = 0; i < n; i++){\n                if(i == find(i)) cnt++;\n            }\n            return cnt;\n        }\n    }\n\n    public static int[] shrink(int[] a) {\n        int n = a.length;\n        long[] b = new long[n];\n        for(int i = 0;i < n;i++)b[i] = (long)a[i]<<32|i;\n        Arrays.sort(b);\n        int[] ret = new int[n];\n        int p = 0;\n        for(int i = 0;i < n;i++) {\n            if(i>0 && (b[i]^b[i-1])>>32!=0)p++;\n            ret[(int)b[i]] = p;\n        }\n        return ret;\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       /* public char nextChar() {\n            return (char)skip();\n        }*/\n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        /*private char buff[] = new char[1005];\n        public char[] nextCharArray(){\n            int b = skip(), p = 0;\n            while(!(isSpaceChar(b))){\n                buff[p++] = (char)b;\n                b = readByte();\n            }\n            return Arrays.copyOf(buff, p);\n        }*/\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 395, "index": 395}
{"src": "\n// Java program to sort an \n// array using stack \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// This function return \n\n// the sorted stack \n\nstatic\nStack<Integer> sortStack(Stack<Integer> input) \n\n{ \n\nStack<Integer> tmpStack = \n\nnew\nStack<Integer>(); \n\n\nwhile\n(!input.empty()) \n\n{ \n\n// pop out the \n\n// first element \n\nint\ntmp = input.peek(); \n\ninput.pop(); \n\n\n// while temporary stack is \n\n// not empty and top of stack \n\n// is smaller than temp \n\nwhile\n(!tmpStack.empty() && \n\ntmpStack.peek() < tmp) \n\n{ \n\n// pop from temporary \n\n// stack and push it \n\n// to the input stack \n\ninput.push(tmpStack.peek()); \n\ntmpStack.pop(); \n\n} \n\n\n// push temp in \n\n// tempory of stack \n\ntmpStack.push(tmp); \n\n} \n\n\nreturn\ntmpStack; \n\n} \n\n\nstatic\nvoid\nsortArrayUsingStacks(\nint\n[]arr, \n\nint\nn) \n\n{ \n\n// push array elements \n\n// to stack \n\nStack<Integer> input = \n\nnew\nStack<Integer>(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ninput.push(arr[i]); \n\n\n// Sort the temporary stack \n\nStack<Integer> tmpStack = \n\nsortStack(input); \n\n\n// Put stack elements \n\n// in arrp[] \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i] = tmpStack.peek(); \n\ntmpStack.pop(); \n\n} \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n5\n, \n15\n, \n45\n}; \n\nint\nn = arr.length; \n\n\nsortArrayUsingStacks(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} \n\n// This code is contributed by \n// Manish Shaw(manishshaw1) ", "complexity": "quadratic", "from": "CorCod", "problem": 396, "index": 396}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int MAXN= 1005;\n\tstatic final long MOD =1_000_000_007;\n\tstatic final boolean DEBUG= false;\n\tstatic int  n, m;\n\tstatic long stlr[][]= new long[MAXN][MAXN],bell[]= new long[MAXN],occ[];\n\tstatic PrintStream cerr=System.err;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tReadin();\n\t\tstlr[0][0]= bell[0] =1;\n\t\tfor (int i=1; i<=m; i++)\n\t\t\tfor (int j=1;j<=i;j++) {\n\t\t\t\tstlr[i][j]= (stlr[i-1][j-1]+stlr[i-1][j]*(long)j)%MOD;\n\t\t\t\tbell[i]= (bell[i]+stlr[i][j])%MOD;\n\t\t\t}\n\t\tif (DEBUG)\n\t\t\tfor (int i=1; i<=m; i++) cerr.println(\"Bell[\"+i+\"] =\"+bell[i]);\n\t\tArrays.sort(occ);\n\t\tif (DEBUG) {\n\t\t\tcerr.println(\"After Sorting\");\n\t\t\tfor (int i=0;i<m; i++) cerr.println(occ[i]+\" \");}\n\t\tlong ans=1;\n\t\tfor (int i=0,j=0; i<m; i=j) {\n\t\t\tfor (j=i+1; j<m && occ[i]==occ[j];j++);\n\t\t\tans= (ans*bell[j-i])%MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tstatic void Readin() {\n\t\tScanner  cin;\n\t\tif ( !DEBUG)cin= new Scanner(System.in);\n\t\telse {\n\t\t\ttry {\n\t\t\t\tcin = new Scanner(new File(\"input.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\tif ( DEBUG)cerr.println(\"Not Fount input.txt\");\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t\tm = cin.nextInt(); n=cin.nextInt();\n\t\tocc= new long[m];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tString s= cin.next();\n\t\t\tfor (int j=0;j <m; j++)\n\t\t\t\tocc[j]|=((long)(s.charAt(j)-'0'))<<i;\n\t\t}\n\t\tcin.close();\n\t}\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 397, "index": 397}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class CodeForces\n{\n\tpublic static void main(String[] args)throws IOException\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\t//Scanner sc=new Scanner(new File(\"ip.txt\"));\n\t\t\n\t\tint t,i,j,n,k,x,y,z,min1,min2,min3,arr1[],arr2[],arr3[];\n\t\tString s;\n\t\tchar[] s1,s2,s3;\n\n\t\tt=sc.nextInt();\n\t\t\n\t\twhile(t-->0)\n\t\t{\n\t\t\tn=sc.nextInt();\n\t\t\tk=sc.nextInt();\n\t\t\ts=sc.next();\n\t\t\ts1=new char[n];\n\t\t\ts2=new char[n];\n\t\t\ts3=new char[n];\n\t\t\t\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(i%3==0)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='R';\n\t\t\t\t\ts2[i]='G';\n\t\t\t\t\ts3[i]='B';\n\t\t\t\t}\n\t\t\t\tif(i%3==1)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='G';\n\t\t\t\t\ts2[i]='B';\n\t\t\t\t\ts3[i]='R';\n\t\t\t\t}\n\t\t\t\tif(i%3==2)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='B';\n\t\t\t\t\ts2[i]='R';\n\t\t\t\t\ts3[i]='G';\n\t\t\t\t}\n\t\t\t}\n\t\t\tarr1=new int[n];\n\t\t\tarr2=new int[n];\n\t\t\tarr3=new int[n];\n\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)!=s1[i])\n\t\t\t\t\tarr1[i]=1;\n\t\t\t\tif(s.charAt(i)!=s2[i])\n\t\t\t\t\tarr2[i]=1;\n\t\t\t\tif(s.charAt(i)!=s3[i])\n\t\t\t\t\tarr3[i]=1;\n\t\t\t}\n\t\t\tfor(i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tarr1[i]=arr1[i]+arr1[i-1];\n\t\t\t\tarr2[i]=arr2[i]+arr2[i-1];\n\t\t\t\tarr3[i]=arr3[i]+arr3[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tmin1=arr1[k-1];\n\t\t\tmin2=arr2[k-1];\n\t\t\tmin3=arr3[k-1];\n\n\t\t\tfor(i=k;i<n;i++)\n\t\t\t{\n\t\t\t\tif(min1>(arr1[i]-arr1[i-k]))\n\t\t\t\t\tmin1=(arr1[i]-arr1[i-k]);\n\t\t\t\tif(min2>(arr2[i]-arr2[i-k]))\n\t\t\t\t\tmin2=(arr2[i]-arr2[i-k]);\n\t\t\t\tif(min3>(arr3[i]-arr3[i-k]))\n\t\t\t\t\tmin3=(arr3[i]-arr3[i-k]);\n\t\t\t}\n\t\t\tSystem.out.println(Math.min(min1,Math.min(min2,min3)));\n\t\t}\n\t}\n}", "complexity": "quadratic", "from": "CorCod", "problem": 398, "index": 398}
{"src": "import java.util.Scanner;\n\npublic class A961_Tetris {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner input = new Scanner(System.in);\n\t\tint platforms = input.nextInt();\n\t\tint in = input.nextInt();\n\t\tint[] cols = new int[platforms];\n\t\tint[] squares = new int[in];\n\t\t\n\t\tfor (int i = 0; i < in; i ++) {\n\t\t\tsquares[i] = input.nextInt();\n\t\t}\n\t\t\n\t\tboolean hi = false;\n\t\tint score = 0;\n\t\t\n\t\tfor (int i = 0; i < in; i ++) {\n\t\t\tcols[squares[i] - 1] ++;\n\t\t\thi = checkscore(cols);\n\t\t\tif (hi == true) {\n\t\t\t\thi = false;\n\t\t\t\tscore ++;\n\t\t\t\tfor (int j = 0; j < cols.length; j ++) {\n\t\t\t\t\tcols[j] --;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(score);\n\t\t\n\t}\n\t\n\tpublic static boolean checkscore(int[] cols) {\n\t\tfor (int i = 0; i < cols.length; i ++) {\n\t\t\tif (cols[i] == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}\n\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 399, "index": 399}
{"src": "\n// Java program to print all words that have \n// the same unique character set \nimport\njava.util.ArrayList; \nimport\njava.util.Arrays; \nimport\njava.util.HashMap; \nimport\njava.util.Map.Entry; \npublic\nclass\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n// Generates a key from given string. The key \n\n// contains all unique characters of given string \n\n// in sorted order consisting of only distinct elements. \n\nstatic\nString getKey(String str) \n\n{ \n\nboolean\n[] visited = \nnew\nboolean\n[MAX_CHAR]; \n\nArrays.fill(visited, \nfalse\n); \n\n\n// store all unique characters of current \n\n// word in key \n\nfor\n(\nint\nj = \n0\n; j < str.length(); j++) \n\nvisited[str.charAt(j) - \n'a'\n] = \ntrue\n; \n\nString key = \n\"\"\n; \n\nfor\n(\nint\nj=\n0\n; j < MAX_CHAR; j++) \n\nif\n(visited[j]) \n\nkey = key + (\nchar\n)(\n'a'\n+j); \n\nreturn\nkey; \n\n} \n\n\n// Print all words together with same character sets. \n\nstatic\nvoid\nwordsWithSameCharSet(String words[], \nint\nn) \n\n{ \n\n// Stores indexes of all words that have same \n\n// set of unique characters. \n\n//unordered_map <string, vector <int> > Hash; \n\nHashMap<String, ArrayList<Integer>> Hash = \nnew\nHashMap<>(); \n\n\n// Traverse all words \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\nString key = getKey(words[i]); \n\n\n// if the key is already in the map \n\n// then get its corresponding value \n\n// and update the list and put it in the map \n\nif\n(Hash.containsKey(key)) \n\n{ \n\nArrayList<Integer> get_al = Hash.get(key); \n\nget_al.add(i); \n\nHash.put(key, get_al); \n\n} \n\n\n// if key is not present in the map \n\n// then create a new list and add \n\n// both key and the list \n\nelse\n\n{ \n\nArrayList<Integer> new_al = \nnew\nArrayList<>(); \n\nnew_al.add(i); \n\nHash.put(key, new_al); \n\n} \n\n} \n\n\n// print all words that have the same unique character set \n\nfor\n(Entry<String, ArrayList<Integer>> it : Hash.entrySet()) \n\n{ \n\nArrayList<Integer> get =it.getValue(); \n\nfor\n(Integer v:get) \n\nSystem.out.print( words[v] + \n\", \"\n); \n\nSystem.out.println(); \n\n} \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString words[] = { \n\"may\"\n, \n\"student\"\n, \n\"students\"\n, \n\"dog\"\n, \n\n\"studentssess\"\n, \n\"god\"\n, \n\"cat\"\n, \n\"act\"\n, \n\"tab\"\n, \n\n\"bat\"\n, \n\"flow\"\n, \n\"wolf\"\n, \n\"lambs\"\n, \n\"amy\"\n, \n\"yam\"\n, \n\n\"balms\"\n, \n\"looped\"\n, \n\"poodle\"\n}; \n\nint\nn = words.length; \n\nwordsWithSameCharSet(words, n); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "quadratic", "from": "CorCod", "problem": 400, "index": 400}
{"src": "import java.util.Scanner;\npublic class Tokitsukaze {\n\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        long k =sc.nextLong();\n        double[]p=new double[m];\n        for(int i = 0;i<m;i++){\n            p[i]=sc.nextDouble();\n        }\n        int c=0;\n        int used=0;\n        for(int i = 0;i<m;){\n            long low=(long)((Math.floor(p[i]/k)*k)-i)+1;\n            long high=low+k;\n            for(int j=i;j<m;j++){\n                if(p[j]>=low&&p[i]<=high){\n                    i++;\n                }\n            }\n            c++;\n        }\n        System.out.println(c);\n\n    }\n    \n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 401, "index": 401}
{"src": "\n// Java program to print Postorder traversal from given Inorder \n// and Preorder traversals. \n\npublic\nclass\nPrintPost { \n\nstatic\nint\npreIndex = \n0\n; \n\nvoid\nprintPost(\nint\n[] in, \nint\n[] pre, \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\n; \n\n\n// Find index of next item in preorder traversal in \n\n// inorder. \n\nint\ninIndex = search(in, inStrt, inEnd, pre[preIndex++]); \n\n\n// traverse left tree \n\nprintPost(in, pre, inStrt, inIndex - \n1\n); \n\n\n// traverse right tree \n\nprintPost(in, pre, inIndex + \n1\n, inEnd); \n\n\n// print root node at the end of traversal \n\nSystem.out.print(in[inIndex] + \n\" \"\n); \n\n} \n\n\nint\nsearch(\nint\n[] in, \nint\nstartIn, \nint\nendIn, \nint\ndata) \n\n{ \n\nint\ni = \n0\n; \n\nfor\n(i = startIn; i < endIn; i++) \n\nif\n(in[i] == data) \n\nreturn\ni; \n\nreturn\ni; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String ars[]) \n\n{ \n\nint\nin[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nlen = in.length; \n\nPrintPost tree = \nnew\nPrintPost(); \n\ntree.printPost(in, pre, \n0\n, len - \n1\n); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 402, "index": 402}
{"src": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map.Entry;\n\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic final class CF_573_D1_A {\n\n\n\tstatic boolean verb=true;\n\tstatic void log(Object X){if (verb) System.err.println(X);}\n\tstatic void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n\tstatic void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\n\tstatic void logWln(Object X){if (verb) System.err.print(X);}\n\tstatic void info(Object o){\tSystem.out.println(o);}\n\tstatic void output(Object o){outputWln(\"\"+o+\"\\n\");\t}\n\tstatic void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n\n\t//static long mod=1000000007;\n\tstatic long mod=998244353 ; \n\tstatic int CX=64;\n\n\n\t// Global vars\n\tstatic BufferedWriter out;\n\tstatic InputReader reader;\n\n\n\t\n\n\tstatic void process() throws Exception {\n\n\t\tLocale.setDefault(Locale.US);\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\treader = new InputReader(System.in);\n\n\t\tlong n=reader.readLong();\n\t\tint m=reader.readInt();\n\t\t\n\t\tlong k=reader.readLong();\n\t\tlong[] p=new long[m];\n\t\tfor (int i=0;i<m;i++)\n\t\t\tp[i]=reader.readLong()-1;\n\t\t\n\t\tint pid=-1;\n\t\tint rem=m;\n\t\tint win=0; // current window\n\t\tlong mx=k-1; // max value of window\n\t\tint res=0;\n\t\tint idx=0;\n\t\t\n\t\twhile (rem>0) {\n\t\t\t//log(\"======\");\n\t\t\twhile (p[idx]>mx) {\n\t\t\t\tmx+=k;\n\t\t\t\tif (mx>=n-1)\n\t\t\t\t\tmx=n-1;\n\t\t\t\t//log(\"mx:\"+mx);\n\t\t\t}\n\t\t\n\t\t\tint nxt=idx;\n\t\t\twhile (nxt+1<m && p[nxt+1]<=mx)\n\t\t\t\tnxt++;\n\t\t\tint nb=nxt-idx+1;\n\t\t\trem-=nb;\n\t\t\tmx+=nb;\n\t\t\tidx=nxt+1;\n\t\t\tres++;\n\t\t}\n\t\toutput(res);\n\n\t\n\t\ttry {\n\t\t\tout.close();\n\t\t} catch (Exception E) {\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tprocess();\n\n\t}\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t// log(\"d:\"+d);\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t// log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t// log(\"d:\"+d);\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t// log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n}", "complexity": "quadratic", "from": "CorCod", "problem": 403, "index": 403}
{"src": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class TaxiDriversAndLyft {\n\t\n\tstatic class Resident{\n\t\tInteger index;\t\t\t// For all residents\n\t\tInteger type;\t\t\t// 1 if driver & 0 for rider\n\t\tInteger requests;\t\t// Only for drivers\n\t\t\n\t\tpublic Resident(int index, int type) {\n\t\t\tthis.index = index;\n\t\t\tthis.type = type;\n\t\t\tthis.requests = 0;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif(type == 0) {\n\t\t\t\treturn \"Rider at index : \" + index;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"Driver at index : \" + index + \", Requests: \" + requests;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Resident> residents;\n\tstatic ArrayList<Integer> drivers_indexes = new ArrayList<>();\n\n\tpublic static void main(String[] args) {\n\t\tScanner reader = new Scanner(System.in);\n\t\tint n = reader.nextInt();\n\t\tint m = reader.nextInt();\n\t\tint length = n + m;\n\t\t\n\t\tint [] coordinates = new int[length];\n\t\tint [] types = new int[length];\n\t\tresidents = new ArrayList<>();\n\t\tdrivers_indexes = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tcoordinates[i] = reader.nextInt();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\ttypes[i] = reader.nextInt();\n\t\t\t\n\t\t\tif(types[i] == 1)\n\t\t\t\tdrivers_indexes.add(i);\n\t\t\t\t\n\t\t\tresidents.add(new Resident(i, types[i]));\n\t\t}\n\t\treader.close();\t\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tResident current = residents.get(i);\n\t\t\tif(current.type == 0) {\n\t\t\t\tint left = i-1, right = i+1;\n\t\t\t\t\t\t\t\t\n\t\t\t\twhile(left >= 0 || right < length) {\n\t\t\t\t\tif(left >= 0 && residents.get(left).type == 1) {\n\t\t\t\t\t\tresidents.get(left).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(right < length && residents.get(right).type == 1) {\n\t\t\t\t\t\tresidents.get(right).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tleft--;\n\t\t\t\t\tright++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int index : drivers_indexes) {\n\t\t\tSystem.out.print(residents.get(index).requests + \" \");\n\t\t}\n\t}\n\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 404, "index": 404}
{"src": "\n// Java program to find equilibrium \n// index of an array \n\nclass\nEquilibriumIndex { \n\nint\nequilibrium(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\nleftsum, rightsum; \n\n\n/* Check for indexes one by one until \n\nan equilibrium index is found */\n\nfor\n(i = \n0\n; i < n; ++i) { \n\n\n/* get left sum */\n\nleftsum = \n0\n; \n\nfor\n(j = \n0\n; j < i; j++) \n\nleftsum += arr[j]; \n\n\n/* get right sum */\n\nrightsum = \n0\n; \n\nfor\n(j = i + \n1\n; j < n; j++) \n\nrightsum += arr[j]; \n\n\n/* if leftsum and rightsum are same, \n\nthen we are done */\n\nif\n(leftsum == rightsum) \n\nreturn\ni; \n\n} \n\n\n/* return -1 if no equilibrium index is found */\n\nreturn\n-\n1\n; \n\n} \n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nEquilibriumIndex equi = \nnew\nEquilibriumIndex(); \n\nint\narr[] = { -\n7\n, \n1\n, \n5\n, \n2\n, -\n4\n, \n3\n, \n0\n}; \n\nint\narr_size = arr.length; \n\nSystem.out.println(equi.equilibrium(arr, arr_size)); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "quadratic", "from": "CorCod", "problem": 405, "index": 405}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class MainG {\n\tstatic StdIn in = new StdIn();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic long M=(long)1e9+7;\n\t\n\tpublic static void main(String[] args) {\n\t\tchar[] cs = in.next().toCharArray();\n\t\tint n=cs.length;\n\t\tint[] x = new int[n];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tx[i]=cs[i]-'0';\n\t\tlong[] dp1 = new long[n+1];\n\t\tfor(int i=0; i<n; ++i) \n\t\t\tdp1[i+1]=(x[i]+dp1[i]*10)%M;\n\t\tlong ans=0;\n\t\tfor(int d1=1; d1<=9; ++d1) {\n\t\t\tlong[][] dp2 = new long[2][n+1];\n\t\t\tfor(int i=0; i<n; ++i) {\n\t\t\t\tdp2[0][i+1]=x[i]>=d1?(10*dp2[0][i]+1)%M:dp2[0][i];\n\t\t\t\tfor(int d2=0; d2<x[i]; ++d2)\n\t\t\t\t\tdp2[1][i+1]=((d2>=d1?10*(dp2[0][i]+dp2[1][i])+dp1[i]+1:dp2[0][i]+dp2[1][i])+dp2[1][i+1])%M;\n\t\t\t\tfor(int d2=x[i]; d2<=9; ++d2)\n\t\t\t\t\tdp2[1][i+1]=((d2>=d1?10*dp2[1][i]+dp1[i]:dp2[1][i])+dp2[1][i+1])%M;\n\t\t\t}\n\t\t\tans+=dp2[0][n]+dp2[1][n];\n\t\t}\n\t\tout.println(ans%M);\n\t\tout.close();\n\t}\n\t\n\tinterface Input {\n\t\tpublic String next();\n\t\tpublic String nextLine();\n\t\tpublic int nextInt();\n\t\tpublic long nextLong();\n\t\tpublic double nextDouble();\n\t}\n\tstatic class StdIn implements Input {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\t\tpublic StdIn() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic StdIn(InputStream in) {\n\t\t\ttry{\n\t\t\t\tdin = new DataInputStream(in);\n\t\t\t} catch(Exception e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic String next() {\n\t\t\tint c;\n\t\t\twhile((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\twhile (c != -1)\n\t\t\t{\n\t\t\t\tif (c == ' ' || c == '\\n'||c=='\\r')\n\t\t\t\t\tbreak;\n\t\t\t\ts.append((char)c);\n\t\t\t\tc=read();\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\tint c;\n\t\t\twhile((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\twhile (c != -1)\n\t\t\t{\n\t\t\t\tif (c == '\\n'||c=='\\r')\n\t\t\t\t\tbreak;\n\t\t\t\ts.append((char)c);\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] readIntArray(int n) {\n\t\t\tint[] ar = new int[n];\n\t\t\tfor(int i=0; i<n; ++i)\n\t\t\t\tar[i]=nextInt();\n\t\t\treturn ar;\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic long[] readLongArray(int n) {\n\t\t\tlong[] ar = new long[n];\n\t\t\tfor(int i=0; i<n; ++i)\n\t\t\t\tar[i]=nextLong();\n\t\t\treturn ar;\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\t\t\tif (c == '.')\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9')\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\t\tprivate byte read() {\n\t\t\ttry{\n\t\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\t\tfillBuffer();\n\t\t\t\treturn buffer[bufferPointer++];\n\t\t\t} catch(IOException e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n}", "complexity": "quadratic", "from": "CorCod", "problem": 406, "index": 406}
{"src": "//q4\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\npublic class q4 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));\n        \n        int query = in.nextInt();\n        \n        while (query -- > 0) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            \n            char[] arr = new char[n];\n            //slot all n into char array\n            String code = in.next();\n            for (int i = 0; i < n; i++) {\n                arr[i] = code.charAt(i);\n                \n            }\n            \n            //R, G, B cycle\n            int r = 0;\n            int g = 0;\n            int b = 0;\n            \n            for (int i = 0; i < k; i++) {\n                if (i % 3 == 0) {\n                    if (arr[i] == 'R') {g++; b++;}\n                    else if (arr[i] == 'G') {r++; b++;}\n                    else {r++; g++;} //if is 'B'\n                } else if (i % 3 == 1) {\n                    if (arr[i] == 'G') {g++; b++;}\n                    else if (arr[i] == 'B') {r++; b++;}\n                    else {r++; g++;} //if is 'R'\n                } else { //if mod 3 is 2\n                    if (arr[i] == 'B') {g++; b++;}\n                    else if (arr[i] == 'R') {r++; b++;}\n                    else {r++; g++;} //if is 'G'     \n                }\n            }\n            \n            //starting from kth position, if different then add 1, and check (j-k)th position\n            int rMin = r;\n            int gMin = g;\n            int bMin = b;\n            for (int j = k; j < n; j++) {\n                //R cycle\n                if ((j % 3 == 0 && arr[j] != 'R') ||  \n                    (j % 3 == 1 && arr[j] != 'G') ||\n                    (j % 3 == 2 && arr[j] != 'B')) {\n                    r++;\n                }\n                //R cycle \n                if (((j - k) % 3 == 0 && arr[j - k] != 'R') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'G') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'B')) {\n                    r--;\n                }\n                rMin = Math.min(r, rMin);\n                //G cycle\n                if ((j % 3 == 0 && arr[j] != 'G') ||  \n                    (j % 3 == 1 && arr[j] != 'B') ||\n                    (j % 3 == 2 && arr[j] != 'R')) {\n                    g++;\n                } \n                if (((j - k) % 3 == 0 && arr[j - k] != 'G') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'B') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'R')) {\n                    g--;\n                }      \n                gMin = Math.min(gMin, g);\n                //B cycle\n                if ((j % 3 == 0 && arr[j] != 'B') ||  \n                    (j % 3 == 1 && arr[j] != 'R') ||\n                    (j % 3 == 2 && arr[j] != 'G')) {\n                    b++;\n                }       \n                if (((j - k) % 3 == 0 && arr[j - k] != 'B') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'R') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'G')) {\n                    b--;\n                } \n                bMin = Math.min(bMin, b);\n                \n            }\n            \n            out.println(Math.min(Math.min(rMin, gMin), bMin));\n            \n        }\n        out.flush();\n        \n    } \n    \n}", "complexity": "quadratic", "from": "CorCod", "problem": 407, "index": 407}
{"src": "\n/* Java program for Dynamic Programming implementation \n\nof Min Cost Path problem */\nimport\njava.util.*; \n\nclass\nMinimumCostPath \n{ \n\n/* A utility function that returns minimum of 3 integers */\n\nprivate\nstatic\nint\nmin(\nint\nx, \nint\ny, \nint\nz) \n\n{ \n\nif\n(x < y) \n\nreturn\n(x < z)? x : z; \n\nelse\n\nreturn\n(y < z)? y : z; \n\n} \n\n\nprivate\nstatic\nint\nminCost(\nint\ncost[][], \nint\nm, \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\ntc[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\ntc[\n0\n][\n0\n] = cost[\n0\n][\n0\n]; \n\n\n/* Initialize first column of total cost(tc) array */\n\nfor\n(i = \n1\n; i <= m; i++) \n\ntc[i][\n0\n] = tc[i-\n1\n][\n0\n] + cost[i][\n0\n]; \n\n\n/* Initialize first row of tc array */\n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[\n0\n][j] = tc[\n0\n][j-\n1\n] + cost[\n0\n][j]; \n\n\n/* Construct rest of the tc array */\n\nfor\n(i = \n1\n; i <= m; i++) \n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[i][j] = min(tc[i-\n1\n][j-\n1\n], \n\ntc[i-\n1\n][j], \n\ntc[i][j-\n1\n]) + cost[i][j]; \n\n\nreturn\ntc[m][n]; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\ncost[][]= {{\n1\n, \n2\n, \n3\n}, \n\n{\n4\n, \n8\n, \n2\n}, \n\n{\n1\n, \n5\n, \n3\n}}; \n\nSystem.out.println(minCost(cost,\n2\n,\n2\n)); \n\n} \n} \n// This code is contributed by Pankaj Kumar ", "complexity": "quadratic", "from": "CorCod", "problem": 408, "index": 408}
{"src": "\n// Java program to fin maximum cash \n// flow among a set of persons \n\nclass\nGFG \n{ \n\n// Number of persons (or vertices in the graph) \n\nstatic\nfinal\nint\nN = \n3\n; \n\n\n// A utility function that returns \n\n// index of minimum value in arr[] \n\nstatic\nint\ngetMin(\nint\narr[]) \n\n{ \n\nint\nminInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] < arr[minInd]) \n\nminInd = i; \n\nreturn\nminInd; \n\n} \n\n\n// A utility function that returns \n\n// index of maximum value in arr[] \n\nstatic\nint\ngetMax(\nint\narr[]) \n\n{ \n\nint\nmaxInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] > arr[maxInd]) \n\nmaxInd = i; \n\nreturn\nmaxInd; \n\n} \n\n\n// A utility function to return minimum of 2 values \n\nstatic\nint\nminOf2(\nint\nx, \nint\ny) \n\n{ \n\nreturn\n(x < y) ? x: y; \n\n} \n\n\n// amount[p] indicates the net amount \n\n// to be credited/debited to/from person 'p' \n\n// If amount[p] is positive, then \n\n// i'th person will amount[i] \n\n// If amount[p] is negative, then \n\n// i'th person will give -amount[i] \n\nstatic\nvoid\nminCashFlowRec(\nint\namount[]) \n\n{ \n\n// Find the indexes of minimum and \n\n// maximum values in amount[] \n\n// amount[mxCredit] indicates the maximum amount \n\n// to be given (or credited) to any person . \n\n// And amount[mxDebit] indicates the maximum amount \n\n// to be taken(or debited) from any person. \n\n// So if there is a positive value in amount[], \n\n// then there must be a negative value \n\nint\nmxCredit = getMax(amount), mxDebit = getMin(amount); \n\n\n// If both amounts are 0, then \n\n// all amounts are settled \n\nif\n(amount[mxCredit] == \n0\n&& amount[mxDebit] == \n0\n) \n\nreturn\n; \n\n\n// Find the minimum of two amounts \n\nint\nmin = minOf2(-amount[mxDebit], amount[mxCredit]); \n\namount[mxCredit] -= min; \n\namount[mxDebit] += min; \n\n\n// If minimum is the maximum amount to be \n\nSystem.out.println(\n\"Person \"\n+ mxDebit + \n\" pays \"\n+ min \n\n+ \n\" to \"\n+ \n\"Person \"\n+ mxCredit); \n\n\n// Recur for the amount array. \n\n// Note that it is guaranteed that \n\n// the recursion would terminate \n\n// as either amount[mxCredit] or \n\n// amount[mxDebit] becomes 0 \n\nminCashFlowRec(amount); \n\n} \n\n\n// Given a set of persons as graph[] \n\n// where graph[i][j] indicates \n\n// the amount that person i needs to \n\n// pay person j, this function \n\n// finds and prints the minimum \n\n// cash flow to settle all debts. \n\nstatic\nvoid\nminCashFlow(\nint\ngraph[][]) \n\n{ \n\n// Create an array amount[], \n\n// initialize all value in it as 0. \n\nint\namount[]=\nnew\nint\n[N]; \n\n\n// Calculate the net amount to \n\n// be paid to person 'p', and \n\n// stores it in amount[p]. The \n\n// value of amount[p] can be \n\n// calculated by subtracting \n\n// debts of 'p' from credits of 'p' \n\nfor\n(\nint\np = \n0\n; p < N; p++) \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\namount[p] += (graph[i][p] - graph[p][i]); \n\n\nminCashFlowRec(amount); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n// graph[i][j] indicates the amount \n\n// that person i needs to pay person j \n\nint\ngraph[][] = { {\n0\n, \n1000\n, \n2000\n}, \n\n{\n0\n, \n0\n, \n5000\n}, \n\n{\n0\n, \n0\n, \n0\n},}; \n\n\n// Print the solution \n\nminCashFlow(graph); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "quadratic", "from": "CorCod", "problem": 409, "index": 409}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class LogicalExpression {\n    \n    int N = 256;\n    \n    void solve() {\n        Expression[] E = new Expression[N];\n        for (int i = 0; i < N; i++) E[i] = new Expression();\n        \n        E[Integer.parseInt(\"00001111\", 2)].update_f(\"x\");\n        E[Integer.parseInt(\"00110011\", 2)].update_f(\"y\");\n        E[Integer.parseInt(\"01010101\", 2)].update_f(\"z\");\n        \n        for (int l = 2; l < 40; l++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (E[i].e != null && E[j].t != null && E[i].e.length() + E[j].t.length() + 1 == l) {\n                        E[i | j].update_e(E[i].e + '|' + E[j].t);\n                    }\n                    if (E[i].t != null && E[j].f != null && E[i].t.length() + E[j].f.length() + 1 == l) {\n                        E[i & j].update_t(E[i].t + '&' + E[j].f);\n                    }\n                }\n                if (E[i].f != null) E[i ^ (N - 1)].update_f('!' + E[i].f);\n            }\n        }\n        \n        String[] res = new String[N];\n        for (int i = 0; i < N; i++) res[i] = E[i].calc_best();\n        \n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int x = Integer.parseInt(in.nextToken(), 2);\n            out.println(res[x]);\n        }\n    }\n    \n    static class Expression {\n        String e, t, f;\n        \n        Expression() {\n        }\n        \n        public Expression(String e, String t, String f) {\n            this.e = e;\n            this.t = t;\n            this.f = f;\n        }\n        \n        String calc_best() {\n            String best = e;\n            if (compare(best, t) > 0) best = t;\n            if (compare(best, f) > 0) best = f;\n            return best;\n        }\n        \n        void update_e(String ne) {\n            if (e == null || compare(e, ne) > 0) {\n                e = ne;\n                update_f('(' + e + ')');\n            }\n        }\n        \n        void update_t(String nt) {\n            if (t == null || compare(t, nt) > 0) {\n                t = nt;\n                update_e(t);\n            }\n        }\n        \n        void update_f(String nf) {\n            if (f == null || compare(f, nf) > 0) {\n                f = nf;\n                update_t(f);\n            }\n        }\n        \n        int compare(String a, String b) {\n            if (a.length() != b.length()) return Integer.compare(a.length(), b.length());\n            return a.compareTo(b);\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new LogicalExpression().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 410, "index": 410}
{"src": "import java.util.*;\n\nimport java.lang.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.*;\n \npublic class Main {\n        \n    public static void main(String[] args) throws Exception{\n        FastReader sc=new FastReader(); \n        OutputStream outputStream = System.out;\n        PrintWriter out = new PrintWriter(outputStream);\n        int n=sc.nextInt();\n        int[] font=new int[n];\n        int[] cost=new int[n];\n        for(int i=0;i<n;i++) {\n            font[i]=sc.nextInt();\n        \n        }\n        for(int i=0;i<n;i++) {\n            cost[i]=sc.nextInt();\n        }\n        int[] dou= new int[n];\n        for(int i=0;i<n;i++) {\n            int min=Integer.MAX_VALUE;\n            for(int j=0;j<i;j++) {\n                if(font[j]<font[i]) {\n                    if(min>cost[i]+cost[j]) {\n                        min=cost[i]+cost[j];\n                    }\n                }\n            }\n            dou[i]=min;\n        }\n        int ans=Integer.MAX_VALUE;\n        for(int i=0;i<n;i++) {\n            int min=Integer.MAX_VALUE;\n            for(int j=0;j<i;j++) {\n                if(dou[j]!=Integer.MAX_VALUE && font[j]<font[i]) {\n                    if(min>dou[j]+cost[i]) {\n                        min=dou[j]+cost[i];\n                    }\n                }\n            }\n            if(min<ans) {\n                ans=min;\n            }\n        }\n        if(ans==Integer.MAX_VALUE) {\n            System.out.println(-1);\n        }\n        else {\n            System.out.println(ans);\n        }\n    }\n}\n\nclass FastReader \n{ \n    BufferedReader br; \n    StringTokenizer st; \n \n    public FastReader() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n \n    String next() \n    { \n        while (st == null || !st.hasMoreElements()) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n \n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n \n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n \n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n \n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 411, "index": 411}
{"src": "\n// Java program to construct a tree using inorder \n// and postorder traversals \n\n/* A binary tree node has data, pointer to left \n\nchild and a pointer to right child */\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\n// Class Index created to implement pass by reference of Index \nclass\nIndex { \n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n/* Recursive function to construct binary of size n \n\nfrom Inorder traversal in[] and Postrder traversal \n\npost[]. Initial values of inStrt and inEnd should \n\nbe 0 and n -1. The function doesn't do any error \n\nchecking for cases where inorder and postorder \n\ndo not form a tree */\n\nNode buildUtil(\nint\nin[], \nint\npost[], \nint\ninStrt, \n\nint\ninEnd, Index pIndex) \n\n{ \n\n// Base case \n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n/* Pick current node from Postrder traversal using \n\npostIndex and decrement postIndex */\n\nNode node = \nnew\nNode(post[pIndex.index]); \n\n(pIndex.index)--; \n\n\n/* If this node has no children then return */\n\nif\n(inStrt == inEnd) \n\nreturn\nnode; \n\n\n/* Else find the index of this node in Inorder \n\ntraversal */\n\nint\niIndex = search(in, inStrt, inEnd, node.data); \n\n\n/* Using index in Inorder traversal, construct left and \n\nright subtress */\n\nnode.right = buildUtil(in, post, iIndex + \n1\n, inEnd, pIndex); \n\nnode.left = buildUtil(in, post, inStrt, iIndex - \n1\n, pIndex); \n\n\nreturn\nnode; \n\n} \n\n\n// This function mainly initializes index of root \n\n// and calls buildUtil() \n\nNode buildTree(\nint\nin[], \nint\npost[], \nint\nn) \n\n{ \n\nIndex pIndex = \nnew\nIndex(); \n\npIndex.index = n - \n1\n; \n\nreturn\nbuildUtil(in, post, \n0\n, n - \n1\n, pIndex); \n\n} \n\n\n/* Function to find index of value in arr[start...end] \n\nThe function assumes that value is postsent in in[] */\n\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nbreak\n; \n\n} \n\nreturn\ni; \n\n} \n\n\n/* This funtcion is here just to test */\n\nvoid\npreOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\nin[] = \nnew\nint\n[] { \n4\n, \n8\n, \n2\n, \n5\n, \n1\n, \n6\n, \n3\n, \n7\n}; \n\nint\npost[] = \nnew\nint\n[] { \n8\n, \n4\n, \n5\n, \n2\n, \n6\n, \n7\n, \n3\n, \n1\n}; \n\nint\nn = in.length; \n\nNode root = tree.buildTree(in, post, n); \n\nSystem.out.println(\n\"Preorder of the constructed tree : \"\n); \n\ntree.preOrder(root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "quadratic", "from": "CorCod", "problem": 412, "index": 412}
{"src": "\nimport java.util.*;\nimport java.math.*;\npublic class Main {\n\tstatic class en implements Comparable<en>{\n\t\tint w,h,dex;\n\t\ten(int a,int b,int c){\n\t\t\tw=a;\n\t\t\th=b;\n\t\t\tdex=c;\n\t\t}\n\t\tpublic int compareTo(en o) {\n\t\t\treturn w-o.w;\n\t\t}\n\t}\n\tpublic static void main(String args[]) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tint n=cin.nextInt(),ww=cin.nextInt(),hh=cin.nextInt(),num=0;\n\t\tQueue<en> que=new PriorityQueue();\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint a=cin.nextInt(),b=cin.nextInt();\n\t\t\tif(a>ww&&b>hh) {\n\t\t\t\tque.add(new en(a,b,i));\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tint dp[][]=new int[num+5][2],ans=0,ad=0,arr[][]=new int[num+5][3];\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tarr[i][0]=que.peek().w;\n\t\t\tarr[i][1]=que.peek().h;\n\t\t\tarr[i][2]=que.remove().dex;\n\t\t}\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tint te=0,td=0;\n\t\t\tfor(int j=1;j<i;j++) {\n\t\t\t\tif(arr[j][0]<arr[i][0]&&arr[j][1]<arr[i][1]&&dp[j][0]>te) {\n\t\t\t\t\tte=dp[j][0];\n\t\t\t\t\ttd=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][0]=te+1;\n\t\t\tdp[i][1]=td;\n\t\t\tif(dp[i][0]>ans) {\n\t\t\t\tans=dp[i][0];\n\t\t\t\tad=i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tArrayList<Integer> an=new ArrayList();\n\t\tint u=ad;\n\t\twhile(u>0) {\n\t\t\tan.add(arr[u][2]);\n\t\t\tu=dp[u][1];\n\t\t\t//System.out.println(u);\n\t\t}\n\t\tfor(int i=an.size()-1;i>=0;i--) System.out.print(an.get(i)+\" \");\n\t}\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 413, "index": 413}
{"src": "\n/* Java program to check if all three given \ntraversals are of the same tree */\nimport\njava.util.*; \nclass\nGfG { \n\nstatic\nint\npreIndex = \n0\n; \n\n// A Binary Tree Node \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n// Utility function to create a new tree node \nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n/* Function to find index of value in arr[start...end] \nThe function assumes that value is present in in[] */\nstatic\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n{ \n\nfor\n(\nint\ni = strt; i <= end; i++) \n\n{ \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\n-\n1\n; \n} \n\n/* Recursive function to construct binary tree \nof size len from Inorder traversal in[] and \nPreorder traversal pre[]. Initial values \nof inStrt and inEnd should be 0 and len -1. \nThe function doesn't do any error checking for \ncases where inorder and preorder do not form a \ntree */\nstatic\nNode buildTree(\nint\nin[], \nint\npre[], \nint\ninStrt, \nint\ninEnd) \n{ \n\n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n/* Pick current node from Preorder traversal \n\nusing preIndex and increment preIndex */\n\nNode tNode = newNode(pre[preIndex++]); \n\n\n/* If this node has no children then return */\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n/* Else find the index of this node in \n\nInorder traversal */\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n/* Using index in Inorder traversal, \n\nconstruct left and right subtress */\n\ntNode.left = buildTree(in, pre, inStrt, inIndex-\n1\n); \n\ntNode.right = buildTree(in, pre, inIndex+\n1\n, inEnd); \n\n\nreturn\ntNode; \n} \n\n/* function to compare Postorder traversal \non constructed tree and given Postorder */\nstatic\nint\ncheckPostorder(Node node, \nint\npostOrder[], \nint\nindex) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\nindex; \n\n\n/* first recur on left child */\n\nindex = checkPostorder(node.left,postOrder,index); \n\n\n/* now recur on right child */\n\nindex = checkPostorder(node.right,postOrder,index); \n\n\n/* Compare if data at current index in \n\nboth Postorder traversals are same */\n\nif\n(node.data == postOrder[index]) \n\nindex++; \n\nelse\n\nreturn\n-\n1\n; \n\n\nreturn\nindex; \n} \n\n// Driver program to test above functions \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\ninOrder[] = {\n4\n, \n2\n, \n5\n, \n1\n, \n3\n}; \n\nint\npreOrder[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n3\n}; \n\nint\npostOrder[] = {\n4\n, \n5\n, \n2\n, \n3\n, \n1\n}; \n\n\nint\nlen = inOrder.length; \n\n\n// build tree from given \n\n// Inorder and Preorder traversals \n\nNode root = buildTree(inOrder, preOrder, \n0\n, len - \n1\n); \n\n\n// compare postorder traversal on constructed \n\n// tree with given Postorder traversal \n\nint\nindex = checkPostorder(root,postOrder,\n0\n); \n\n\n// If both postorder traversals are same \n\nif\n(index == len) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 414, "index": 414}
{"src": "//\n//                                  _oo8oo_\n//                                 o8888888o\n//                                 88\" . \"88\n//                                 (| -_- |)\n//                                 0\\  =  /0\n//                               ___/'==='\\___\n//                             .' \\\\|     |// '.\n//                            / \\\\|||  :  |||// \\\n//                           / _||||| -:- |||||_ \\\n//                          |   | \\\\\\  -  /// |   |\n//                          | \\_|  ''\\---/''  |_/ |\n//                          \\  .-\\__  '-'  __/-.  /\n//                        ___'. .'  /--.--\\  '. .'___\n//                     .\"\" '<  '.___\\_<|>_/___.'  >' \"\".\n//                    | | :  `- \\`.:`\\ _ /`:.`/ -`  : | |\n//                    \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n//                =====`-.____`.___ \\_____/ ___.`____.-`=====\n//                                  `=---=`\n//\n//\n//               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//                          \u4f5b\u7956\u4fdd\u4f51         \u6c38\u4e0d\u5b95\u673a/\u6c38\u65e0bug\n//\n\nimport java.util.*;\n\npublic class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n//        System.out.println(Arrays.toString(list.toArray()));\n//        if (list.size() < n) {\n//            System.out.println(0);\n//        } else {\n//            System.out.println(list.get(n - 1).num);\n//        }\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 415, "index": 415}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author caoash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BObtainingTheString solver = new BObtainingTheString();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BObtainingTheString {\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            String s = br.nextString();\n            String t = br.nextString();\n            char[] sarr = new char[n];\n            char[] tarr = new char[n];\n            int[] sAppear = new int[26];\n            int[] tAppear = new int[26];\n            for (int i = 0; i < s.length(); i++) {\n                sarr[i] = s.charAt(i);\n                tarr[i] = t.charAt(i);\n                sAppear[s.charAt(i) - 'a']++;\n                tAppear[t.charAt(i) - 'a']++;\n            }\n            for (int i = 0; i < 26; i++) {\n                if (sAppear[i] != tAppear[i]) {\n                    pw.println(-1);\n                    pw.close();\n                }\n            }\n            ArrayList<Integer> ans = new ArrayList<Integer>();\n            for (int i = 0; i < n; i++) {\n                char curr = tarr[i];\n                for (int j = i + 1; j < n; j++) {\n                    if (sarr[j] == curr) {\n                        for (int k = j; k > i; k--) {\n                            ans.add(k);\n                            char temp = sarr[k - 1];\n                            sarr[k - 1] = sarr[k];\n                            sarr[k] = temp;\n                        }\n                        break;\n                    }\n                }\n            }\n            pw.println(ans.size());\n            for (int e : ans) {\n                pw.print(e + \" \");\n            }\n            pw.close();\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "from": "CorCod", "problem": 416, "index": 416}
{"src": "\n/* Dynamic Programming Java \n\nimplementation of Maximum Sum \n\nIncreasing Subsequence (MSIS) \n\nproblem */\nclass\nGFG \n{ \n\n/* maxSumIS() returns the \n\nmaximum sum of increasing \n\nsubsequence in arr[] of size n */\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n/* Initialize msis values \n\nfor all indexes */\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n/* Compute maximum sum values \n\nin bottom up manner */\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n/* Pick maximum of all \n\nmsis values */\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n} \n\n// This code is contributed \n// by Rajat Mishra ", "complexity": "quadratic", "from": "CorCod", "problem": 417, "index": 417}
{"src": "\n// Java program to find Minimum \n// number of jumps to reach end \nclass\nGFG \n{ \n// Returns Minimum number \n// of jumps to reach end \nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n// jumps[0] will \n\n// hold the result \n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n// Minimum number of jumps \n\n// needed to reach last \n\n// element from last elements \n\n// itself is always 0 \n\njumps[n - \n1\n] = \n0\n; \n\n\n\n// Start from the second \n\n// element, move from right \n\n// to left and construct the \n\n// jumps[] array where jumps[i] \n\n// represents minimum number of \n\n// jumps needed to reach arr[m-1] \n\n// from arr[i] \n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n// If arr[i] is 0 then arr[n-1] \n\n// can't be reached from here \n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n// If we can direcly reach to \n\n// the end point from here then \n\n// jumps[i] is 1 \n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n// Otherwise, to find out \n\n// the minimum number of \n\n// jumps needed to reach \n\n// arr[n-1], check all the \n\n// points reachable from \n\n// here and jumps[] value \n\n// for those points \n\nelse\n\n{ \n\n// initialize min value \n\nmin = Integer.MAX_VALUE; \n\n\n// following loop checks \n\n// with all reachable points \n\n// and takes the minimum \n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n// Handle overflow \n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n// or Integer.MAX_VALUE \n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n} \n\n// This code is contributed by mits. ", "complexity": "quadratic", "from": "CorCod", "problem": 418, "index": 418}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n\n        new Main().go();\n    }\n\n    PrintWriter out;\n    Reader in;\n    BufferedReader br;\n\n    Main() throws IOException {\n\n        try {\n\n            //br = new BufferedReader( new FileReader(\"input.txt\") );\n            //in = new Reader(\"input.txt\");\n            in = new Reader(\"input.txt\");\n            out = new PrintWriter( new BufferedWriter(new FileWriter(\"output.txt\")) );\n        }\n        catch (Exception e) {\n\n            //br = new BufferedReader( new InputStreamReader( System.in ) );\n            in = new Reader();\n            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );\n        }\n    }\n\n    void go() throws Exception {\n\n        //int t = in.nextInt();\n        int t = 1;\n        while (t > 0) {\n            solve();\n            t--;\n        }\n\n        out.flush();\n        out.close();\n    }\n\n\n    int inf = 2000000000;\n    int mod = 1000000007;\n    double eps = 0.000000001;\n\n    int n;\n    int m;\n\n    ArrayList<Pair>[] g;\n    String s;\n    int[][] a;\n    void solve() throws IOException {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        a = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            String s = in.nextLine();\n            for (int j = 0; j < m; j++) {\n                a[i][j] = s.charAt(j);\n            }\n        }\n\n        int[][] f = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                f[i][j] = inf;\n\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < m; j++) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = m - 1; j >= 0; j--) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        for (int j = 0; j < m; j++) {\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        for (int j = 0; j < m; j++) {\n            int cnt = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        ArrayList<Item> ans = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) {\n                if (a[i][j] == '*' && f[i][j] > 0)\n                    ans.add(new Item(i + 1, j + 1, f[i][j]));\n            }\n        boolean[][] used = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < m; j++) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n            cnt = 0;\n            for (int j = m - 1; j >= 0; j--) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n        }\n\n        for (int j = 0; j < m; j++) {\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n            cnt = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n        }\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (a[i][j] == '*' && !used[i][j]) {\n                    out.println(-1);\n                    return;\n                }\n\n        out.println(ans.size());\n        for (Item i : ans)\n            out.println(i.a + \" \" + i.b + \" \" + i.c);\n    }\n\n\n    class Pair implements Comparable<Pair>{\n\n        int a;\n        int b;\n\n        Pair(int a, int b) {\n\n            this.a = a;\n            this.b = b;\n        }\n\n        public int compareTo(Pair p) {\n            if (a != p.a)\n                return Integer.compare(a, p.a);\n            else\n                return Integer.compare(b, p.b);\n        }\n    }\n\n    class Item {\n\n        int a;\n        int b;\n        int c;\n\n        Item(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n    }\n\n\n    class Reader {\n\n        BufferedReader  br;\n        StringTokenizer tok;\n\n        Reader(String file) throws IOException {\n            br = new BufferedReader( new FileReader(file) );\n        }\n\n        Reader() throws IOException {\n            br = new BufferedReader( new InputStreamReader(System.in) );\n        }\n\n        String next() throws IOException {\n\n            while (tok == null || !tok.hasMoreElements())\n                tok = new StringTokenizer(br.readLine());\n            return tok.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.valueOf(next());\n        }\n\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n\n    static class InputReader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public InputReader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n}", "complexity": "quadratic", "from": "CorCod", "problem": 419, "index": 419}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.util.Map.Entry;\n\npublic class Codeforces {\n\n    static int n;\n    static double max;\n    static int[] pre;\n\n    public static void findIntensity(int l){\n        for(int i = 0, j = i + l; j < n + 1; i++, j++){\n            double res = (pre[j] - pre[i]) / (double) l;\n            max = Math.max(max, res);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int[] heat = new int[n];\n        st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < n; i++){\n            heat[i] = Integer.parseInt(st.nextToken());\n        }\n        max = 0;\n        pre = new int[n + 1];\n        pre[0] = 0;\n        for(int i = 0; i < n; i++){\n            pre[i + 1] = pre[i] + heat[i];\n        }\n        for(int i = k; i <= n; i++){\n            findIntensity(i);\n        }\n        System.out.println(max);\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 420, "index": 420}
{"src": "\n// java program to find maximum \n// sum of bi-tonic sub-sequence \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Function return maximum sum \n\n// of Bi-tonic sub-sequence \n\nstatic\nint\nMaxSumBS(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmax_sum = Integer.MIN_VALUE; \n\n\n// MSIBS[i] ==> Maximum sum Increasing Bi-tonic \n\n// subsequence ending with arr[i] \n\n// MSDBS[i] ==> Maximum sum Decreasing Bi-tonic \n\n// subsequence starting with arr[i] \n\n// Initialize MSDBS and MSIBS values as arr[i] for \n\n// all indexes \n\nint\nMSIBS[] = \nnew\nint\n[n]; \n\nint\nMSDBS[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nMSDBS[i] = arr[i]; \n\nMSIBS[i] = arr[i]; \n\n} \n\n\n// Compute MSIBS values from left to right */ \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) \n\nMSIBS[i] = MSIBS[j] + arr[i]; \n\n\n// Compute MSDBS values from right to left \n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) \n\nMSDBS[i] = MSDBS[j] + arr[i]; \n\n\n// Find the maximum value of MSIBS[i] + \n\n// MSDBS[i] - arr[i] \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmax_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); \n\n\n// return max sum of bi-tonic \n\n// sub-sequence \n\nreturn\nmax_sum; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n15\n, \n51\n, \n45\n, \n33\n, \n100\n, \n12\n, \n18\n, \n9\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum Sum : \"\n+ MaxSumBS(arr, n)); \n\n} \n} \n\n// This code is contributed by vt_m ", "complexity": "quadratic", "from": "CorCod", "problem": 421, "index": 421}
{"src": "\n// Java program to count number of substrings \n// with counts of distinct characters as k. \nclass\nGFG \n{ \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n// Returns true if all values \n// in freq[] are either 0 or k. \nstatic\nboolean\ncheck(\nint\nfreq[], \nint\nk) \n{ \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nif\n(freq[i] !=\n0\n&& freq[i] != k) \n\nreturn\nfalse\n; \n\nreturn\ntrue\n; \n} \n\n// Returns count of substrings where frequency \n// of every present character is k \nstatic\nint\nsubstrings(String s, \nint\nk) \n{ \n\nint\nres = \n0\n; \n// Initialize result \n\n\n// Pick a starting point \n\nfor\n(\nint\ni = \n0\n; i< s.length(); i++) \n\n{ \n\n\n// Initialize all frequencies as 0 \n\n// for this starting point \n\nint\nfreq[] = \nnew\nint\n[MAX_CHAR]; \n\n\n// One by one pick ending points \n\nfor\n(\nint\nj = i; j<s.length(); j++) \n\n{ \n\n\n// Increment frequency of current char \n\nint\nindex = s.charAt(j) - \n'a'\n; \n\nfreq[index]++; \n\n\n// If frequency becomes more than \n\n// k, we can't have more substrings \n\n// starting with i \n\nif\n(freq[index] > k) \n\nbreak\n; \n\n\n// If frequency becomes k, then check \n\n// other frequencies as well. \n\nelse\nif\n(freq[index] == k && \n\ncheck(freq, k) == \ntrue\n) \n\nres++; \n\n} \n\n} \n\nreturn\nres; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nString s = \n\"aabbcc\"\n; \n\nint\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n\n\ns = \n\"aabbc\"\n; \n\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n} \n} \n\n// This code has been contributed by 29AjayKumar ", "complexity": "quadratic", "from": "CorCod", "problem": 422, "index": 422}
{"src": "\n// Java implementation of simple \n// algorithm to find smaller \n// element on left side \nimport\njava.io.*; \nclass\nGFG { \n\n// Prints smaller elements on \n// left side of every element \nstatic\nvoid\nprintPrevSmaller(\nint\n[]arr, \nint\nn) \n{ \n\n\n// Always print empty or '_' \n\n// for first element \n\nSystem.out.print( \n\"_, \"\n); \n\n\n// Start from second element \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n// look for smaller \n\n// element on left of 'i' \n\nint\nj; \n\nfor\n(j = i - \n1\n; j >= \n0\n; j--) \n\n{ \n\nif\n(arr[j] < arr[i]) \n\n{ \n\nSystem.out.print(arr[j] + \n\", \"\n); \n\nbreak\n; \n\n} \n\n} \n\n\n// If there is no smaller \n\n// element on left of 'i' \n\nif\n(j == -\n1\n) \n\nSystem.out.print( \n\"_, \"\n) ; \n\n} \n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n3\n, \n0\n, \n2\n, \n5\n}; \n\nint\nn = arr.length; \n\nprintPrevSmaller(arr, n); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "complexity": "quadratic", "from": "CorCod", "problem": 423, "index": 423}
{"src": "\n// Java Program to find the maximum for each and every contiguous subarray of size k. \n\npublic\nclass\nGFG { \n\n// Method to find the maximum for each and every contiguous subarray of size k. \n\nstatic\nvoid\nprintKMax(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nj, max; \n\n\nfor\n(\nint\ni = \n0\n; i <= n - k; i++) { \n\n\nmax = arr[i]; \n\n\nfor\n(j = \n1\n; j < k; j++) { \n\nif\n(arr[i + j] > max) \n\nmax = arr[i + j]; \n\n} \n\nSystem.out.print(max + \n\" \"\n); \n\n} \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}; \n\nint\nk = \n3\n; \n\nprintKMax(arr, arr.length, k); \n\n} \n} \n\n// This code is contributed by Sumit Ghosh ", "complexity": "quadratic", "from": "CorCod", "problem": 424, "index": 424}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 425, "index": 425}
{"src": "\nclass\nSmallestSubArraySum \n{ \n\n// Returns length of smallest subarray with sum greater than x. \n\n// If there is no subarray with given sum, then returns n+1 \n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n// Initilize length of smallest subarray as n+1 \n\nint\nmin_len = n + \n1\n; \n\n\n// Pick every element as starting point \n\nfor\n(\nint\nstart = \n0\n; start < n; start++) \n\n{ \n\n// Initialize sum starting with current start \n\nint\ncurr_sum = arr[start]; \n\n\n// If first element itself is greater \n\nif\n(curr_sum > x) \n\nreturn\n1\n; \n\n\n// Try different ending points for curremt start \n\nfor\n(\nint\nend = start + \n1\n; end < n; end++) \n\n{ \n\n// add last element to current sum \n\ncurr_sum += arr[end]; \n\n\n// If sum becomes more than x and length of \n\n// this subarray is smaller than current smallest \n\n// length, update the smallest length (or result) \n\nif\n(curr_sum > x && (end - start + \n1\n) < min_len) \n\nmin_len = (end - start + \n1\n); \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "quadratic", "from": "CorCod", "problem": 426, "index": 426}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 427, "index": 427}
{"src": "\n// Program to find minimum \n// total offerings required \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Returns minimum \n// offerings required \nstatic\nint\nofferingNumber(\nint\nn, \n\nint\ntempleHeight[]) \n{ \n\nint\nsum = \n0\n; \n// Initialize result \n\n\n// Go through all \n\n// temples one by one \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n// Go to left while \n\n// height keeps increasing \n\nint\nleft = \n0\n, right = \n0\n; \n\nfor\n(\nint\nj = i - \n1\n; j >= \n0\n; --j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j + \n1\n]) \n\n++left; \n\nelse\n\nbreak\n; \n\n} \n\n\n// Go to right while \n\n// height keeps increasing \n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j - \n1\n]) \n\n++right; \n\nelse\n\nbreak\n; \n\n} \n\n\n// This temple should offer \n\n// maximum of two values \n\n// to follow the rule. \n\nsum += Math.max(right, left) + \n1\n; \n\n} \n\n\nreturn\nsum; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain (String[] args) \n{ \nint\narr1[] = {\n1\n, \n2\n, \n2\n}; \nSystem.out.println(offeringNumber(\n3\n, arr1)); \nint\narr2[] = {\n1\n, \n4\n, \n3\n, \n\n6\n, \n2\n, \n1\n}; \nSystem.out.println(offeringNumber(\n6\n, arr2)); \n} \n} \n\n// This code is contributed by akt_mit ", "complexity": "quadratic", "from": "CorCod", "problem": 428, "index": 428}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class CodeForces {\n\n\tpublic static int difference(String s, String b, int n, int k) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] pre = new int[n];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (i == 1) {\n\t\t\t\tpre[i - 1] = (s.charAt(i-1) == b.charAt(i-1) ? 0 : 1);\n\t\t\t}\n\t\t\tpre[i] = pre[i - 1] + (s.charAt(i) == b.charAt(i) ? 0 : 1);\n\t\t}\n\t\tint v = -1;\n\t\tfor (int i = k - 1; i < n; i++) {\n\t\t\tmin = Math.min(min, pre[i] - (v == -1 ? 0 : pre[v]));\n\t\t\tv++;\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint t = sc.nextInt();\n\t\tO: while (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tString s = sc.nextLine();\n\t\t\tint c = 1;\n\t\t\tStringBuilder R = new StringBuilder();\n\t\t\tStringBuilder G = new StringBuilder();\n\t\t\tStringBuilder B = new StringBuilder();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (c % 3 == 1) {\n\t\t\t\t\tR.append(\"R\") ;\n\t\t\t\t\tG.append(\"G\");\n\t\t\t\t\tB.append(\"B\");\n\t\t\t\t} else if (c % 3 == 2) {\n\t\t\t\t\tR.append(\"G\");\n\t\t\t\t\tG.append(\"B\");\n\t\t\t\t\tB.append(\"R\");\n\t\t\t\t} else {\n\t\t\t\t\tR.append(\"B\");\n\t\t\t\t\tG.append(\"R\");\n\t\t\t\t\tB.append(\"G\");\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tString RR = R.toString(),BB = B.toString() , GG = G.toString();\n\t\t\tString[] arr = new String[] { RR, BB, GG };\n\t\t\tint i = 0;\n\t\t\tint j = k;\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\twhile (i < 3) {\n\t\t\t\tmin = Math.min(min, difference(s, arr[i], n, k));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tpw.println(min);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic class SegmentTree {\n\t\tstatic int[] S, in;\n\t\tstatic int N;\n\n\t\tpublic SegmentTree(int[] arr) {\n\t\t\tin = arr;\n\t\t\tN = in.length - 1;\n\t\t\tS = new int[N << 1];\n\t\t\tbuild(1, 1, N);\n\t\t}\n\n\t\tstatic int stat;\n\n\t\tvoid build(int node, int b, int e) {\n\t\t\tif (b == e) {\n\t\t\t\tS[node] = in[b];\n\t\t\t\tstat = 1;\n\t\t\t} else {\n\t\t\t\tint mid = (b + e) / 2;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[node] = S[node << 1] | S[node << 1 | 1];\n\n\t\t\t\t} else {\n\t\t\t\t\tS[node] = S[node << 1] ^ S[node << 1 | 1];\n\t\t\t\t}\n\t\t\t\tstat = 1 - stat;\n\t\t\t}\n\t\t}\n\n\t\tint update(int idx, int val) {\n\t\t\tidx += (N - 1);\n\n\t\t\tS[idx] = val;\n\t\t\tint stat = 1;\n\t\t\twhile (idx > 1) {\n\t\t\t\tidx >>= 1;\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[idx] = S[idx << 1] | S[idx << 1 | 1];\n\t\t\t\t\tstat = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS[idx] = S[idx << 1] ^ S[idx << 1 | 1];\n\t\t\t\t\tstat = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn S[1];\n\t\t}\n\n\t}\n\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint a, b;\n\n\t\tpublic Pair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic int compareTo(Pair A) {\n\t\t\tif (a != A.a)\n\t\t\t\treturn A.a - a;\n\t\t\treturn A.b - b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "complexity": "quadratic", "from": "CorCod", "problem": 429, "index": 429}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n    private void solve() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n\n        int n = nextInt(), m = nextInt();\n        boolean[][] used = new boolean[n + 1][m + 1];\n\n        for (int j = 1; j <= (m + 1) / 2; j++) {\n            int x1 = 1, x2 = n;\n            for (int i = 1; i <= n; i++) {\n                if (x1 <= n && !used[x1][j]) {\n                    out.println(x1 + \" \" + j);\n                    used[x1++][j] = true;\n                }\n                if (x2 > 0 && !used[x2][m - j + 1]) {\n                    out.println(x2 + \" \" + (m - j + 1));\n                    used[x2--][m - j + 1] = true;\n                }\n            }\n        }\n\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new D().solve();\n    }\n\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter out;\n\n    private String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return st.nextToken();\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    private long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    private double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 430, "index": 430}
{"src": "import java.io.*;\nimport java.util.*;\n\n\n\npublic class hi {\n    public static void main(String[] args) throws IOException{\n        Reader in=new Reader();\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\tint n=in.nextInt();\n\t\tint[] arr=in.nextIntArray(n);\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tint a=(int)Math.floor((Math.min(arr[i],arr[j])/Math.abs(i-j)));\n\t\t\t\tif(a < k)\n\t\t\t\t\tk=a;\n\t\t\t}\n\t\t}\n\t\tw.println(k);\n        w.close();\n        return;\n\t}\n\t\n}\n\n\nclass Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\t\tpublic String nextLine() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n        public String next() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n        } \n        public int[] nextIntArray(int n) throws IOException{\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n            }\n\n\t\t\treturn a;\n\t\t}\n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n        } \n        public boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n    }\n", "complexity": "quadratic", "from": "CorCod", "problem": 431, "index": 431}
{"src": "\n// Java Program to Find the minimum \n// distance between two numbers \nclass\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni, j; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nfor\n(j = i + \n1\n; j < n; j++) \n\n{ \n\nif\n((x == arr[i] && y == arr[j] \n\n|| y == arr[i] && x == arr[j]) \n\n&& min_dist > Math.abs(i - j)) \n\nmin_dist = Math.abs(i - j); \n\n} \n\n} \n\nreturn\nmin_dist; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n5\n, \n6\n, \n6\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 432, "index": 432}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.System.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t// out.println(\"---- \"+arr[i]);\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// out.println(list.toString());\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// out.println(list.toString());\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "complexity": "quadratic", "from": "CorCod", "problem": 433, "index": 433}
{"src": "\n// Space efficient Java program to count all \n// substrings with same first and last characters. \npublic\nclass\nGFG { \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n// Iterating through all substrings in \n\n// way so that we can find first and last \n\n// character easily \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i; j < n; j++) \n\nif\n(s.charAt(i) == s.charAt(j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "quadratic", "from": "CorCod", "problem": 434, "index": 434}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] v = new int[n];\n        int[] ans = new int[n];\n        long s = 0;\n        int t;\n        for(int i=0; i<n;i++) {\n            v[i] = in.nextInt();\n            s+=v[i];\n        }\n\n        for(int i=0; i<n-1;i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (v[j] > v[i]) {\n                    t = v[i];\n                    v[i] = v[j];\n                    v[j] = t;\n                }\n            }\n        }\n\n        for(int i=0; i<n-1; i++){\n            if(v[i] > v[i+1]){\n                    ans[i] = v[i]-v[i+1];\n            }\n\n            if(v[i] == v[i+1] && v[i]!=1){\n                ans[i]=1;\n                v[i+1]--;\n            }\n\n            if(v[i] < v[i+1]){\n                ans[i]=1;\n                v[i+1] = v[i]-1;\n                if(v[i+1] == 0){\n                    v[i+1] = 1;\n                }\n            }\n            if(v[i] == 0 || v[i] == 1){\n                ans[i] = 1;\n                v[i] = 1;\n            }\n        }\n        if (v[n-1] > 1){\n            ans[n-1] = v[n-1];\n        }\n        else{\n            ans[n-1] = 1;\n        }\n\n        for (int i=0; i<n; i++){\n                s-=ans[i];\n\n        }\n        System.out.print(s);\n\n\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 435, "index": 435}
{"src": "\n// Java Code to find the last man Standing \npublic\nclass\nGFG { \n\n\n// Node class to store data \n\nstatic\nclass\nNode \n\n{ \n\npublic\nint\ndata ; \n\npublic\nNode next; \n\npublic\nNode( \nint\ndata ) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\n/* Function to find the only person left \n\nafter one in every m-th node is killed \n\nin a circle of n nodes */\n\nstatic\nvoid\ngetJosephusPosition(\nint\nm, \nint\nn) \n\n{ \n\n// Create a circular linked list of \n\n// size N. \n\nNode head = \nnew\nNode(\n1\n); \n\nNode prev = head; \n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\n{ \n\nprev.next = \nnew\nNode(i); \n\nprev = prev.next; \n\n} \n\n\n// Connect last node to first \n\nprev.next = head; \n\n\n/* while only one node is left in the \n\nlinked list*/\n\nNode ptr1 = head, ptr2 = head; \n\n\nwhile\n(ptr1.next != ptr1) \n\n{ \n\n\n// Find m-th node \n\nint\ncount = \n1\n; \n\nwhile\n(count != m) \n\n{ \n\nptr2 = ptr1; \n\nptr1 = ptr1.next; \n\ncount++; \n\n} \n\n\n/* Remove the m-th node */\n\nptr2.next = ptr1.next; \n\nptr1 = ptr2.next; \n\n} \n\nSystem.out.println (\n\"Last person left standing \"\n+ \n\n\"(Josephus Position) is \"\n+ ptr1.data); \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n14\n, m = \n2\n; \n\ngetJosephusPosition(m, n); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 436, "index": 436}
{"src": "\n/* Dynamic Programming implementation in Java for longest bitonic \n\nsubsequence problem */\nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nLBS \n{ \n\n/* lbs() returns the length of the Longest Bitonic Subsequence in \n\narr[] of size n. The function mainly creates two temporary arrays \n\nlis[] and lds[] and returns the maximum lis[i] + lds[i] - 1. \n\n\nlis[i] ==> Longest Increasing subsequence ending with arr[i] \n\nlds[i] ==> Longest decreasing subsequence starting with arr[i] \n\n*/\n\nstatic\nint\nlbs( \nint\narr[], \nint\nn ) \n\n{ \n\nint\ni, j; \n\n\n/* Allocate memory for LIS[] and initialize LIS values as 1 for \n\nall indexes */\n\nint\n[] lis = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlis[i] = \n1\n; \n\n\n/* Compute LIS values from left to right */\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && lis[i] < lis[j] + \n1\n) \n\nlis[i] = lis[j] + \n1\n; \n\n\n/* Allocate memory for lds and initialize LDS values for \n\nall indexes */\n\nint\n[] lds = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlds[i] = \n1\n; \n\n\n/* Compute LDS values from right to left */\n\nfor\n(i = n-\n2\n; i >= \n0\n; i--) \n\nfor\n(j = n-\n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && lds[i] < lds[j] + \n1\n) \n\nlds[i] = lds[j] + \n1\n; \n\n\n\n/* Return the maximum value of lis[i] + lds[i] - 1*/\n\nint\nmax = lis[\n0\n] + lds[\n0\n] - \n1\n; \n\nfor\n(i = \n1\n; i < n; i++) \n\nif\n(lis[i] + lds[i] - \n1\n> max) \n\nmax = lis[i] + lds[i] - \n1\n; \n\n\nreturn\nmax; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n0\n, \n8\n, \n4\n, \n12\n, \n2\n, \n10\n, \n6\n, \n14\n, \n1\n, \n9\n, \n5\n, \n\n13\n, \n3\n, \n11\n, \n7\n, \n15\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of LBS is \"\n+ lbs( arr, n )); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 437, "index": 437}
{"src": "import java.io.*;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Lyft {\n    private static FastScanner scan = new FastScanner(System.in);\n    private static PrintWriter pr = new PrintWriter(System.out);\n    private static int n, m, taxistNumber, noTaxistNumber = 0;\n    static people peoples[], taxist[], noTaxist[];\n    public static void main(String[] args) throws IOException {\n        n = scan.nextInt();\n        m = scan.nextInt();\n        peoples = new people[n + m];\n        noTaxist = new people[n];\n        taxist = new people[m];\n        for(int i = 0; i < peoples.length; i++){\n            peoples[i] = new people(scan.nextInt());\n        }\n        for (people i : peoples){\n            if(scan.nextInt() == 1){\n                i.taxi = true;\n                i.passangers = 0;\n                taxist[taxistNumber] = i;\n                taxistNumber++;\n            }else{\n                noTaxist[noTaxistNumber] = i;\n                noTaxistNumber++;\n            }\n        }\n        for (people i : noTaxist){\n                for (people ii: taxist){\n                    if(ii.taxi){\n                       if(i.nearestTaxist == null){\n                           i.nearestTaxist = ii;\n                           ii.passangers++;\n                       }else if(i.coord - i.nearestTaxist.coord > ii.coord - i.coord){\n                           i.nearestTaxist.passangers--;\n                           i.nearestTaxist = ii;\n                           i.nearestTaxist.passangers++;\n                       }\n                    }\n                }\n        }\n        for (people i : taxist){\n                pr.print(i.passangers + \" \");\n        }\n        pr.close();\n    }\n}\nclass FastScanner\n{\n    private static final int bufferSize = 64 * 1024;\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    FastScanner(InputStream inputStream)\n    {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream), bufferSize);\n    }\n\n    String nextToken() throws IOException\n    {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n        {\n            String line = reader.readLine();\n            if (line == null)\n            {\n                tokenizer = null;\n                return null;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    int[] readIntArray(int n) throws IOException\n    {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    long[] readLongArray(int n) throws IOException\n    {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nextLong();\n        }\n        return a;\n    }\n\n    int nextInt() throws NumberFormatException, IOException\n    {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws NumberFormatException, IOException\n    {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException\n    {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextLine() throws IOException\n    {\n        tokenizer = null;\n        return reader.readLine();\n    }\n}\nclass people{\n    int coord = 0;\n    boolean taxi = false;\n    people nearestTaxist = null;\n    int passangers = -1;\n    people(int coord){\n        this.coord = coord;\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 438, "index": 438}
{"src": "\n// Java implementation to find the character in \n// first string that is present at minimum index \n// in second string \n\npublic\nclass\nGFG \n{ \n\n// method to find the minimum index character \n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n// to store the index of character having \n\n// minimum index \n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n// lengths of the two strings \n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n// traverse 'patt' \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// for each character of 'patt' traverse 'str' \n\nfor\n(\nint\nj = \n0\n; j < m; j++) { \n\n\n// if patt.charAt(i)is found in 'str', check if \n\n// it has the minimum index or not. If yes, \n\n// then update 'minIndex' and break \n\nif\n(patt.charAt(i)== str.charAt(j) && j < minIndex) { \n\nminIndex = j; \n\nbreak\n; \n\n} \n\n} \n\n} \n\n\n// print the minimum index character \n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n// if no character of 'patt' is present in 'str' \n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n// Driver Method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 439, "index": 439}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class DoggoRecoloring {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tString s = nextString();\n\t\tboolean b = false;\n\t\t\n\t\tif (n == 1 || n > 26)\n\t\t\tb = true;\n\t\telse \n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = i+1; j < n; j++)\n\t\t\t\t\tif (s.charAt(i) == s.charAt(j))\n\t\t\t\t\t\t b = true;\n\t\t\n\t\tSystem.out.println(b ? \"Yes\" : \"No\");\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "quadratic", "from": "CorCod", "problem": 440, "index": 440}
{"src": "\n// Java program to find palindromic substrings of a string \n\npublic\nclass\nGFG \n{ \n\n// Returns total number of palindrome substring of \n\n// length greater then equal to 2 \n\nstatic\nint\nCountPS(\nchar\nstr[], \nint\nn) \n\n{ \n\n// create empty 2-D matrix that counts all palindrome \n\n// substring. dp[i][j] stores counts of palindromic \n\n// substrings in st[i..j] \n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n// P[i][j] = true if substring str[i..j] is palindrome, \n\n// else false \n\nboolean\nP[][] = \nnew\nboolean\n[n][n]; \n\n\n// palindrome of single length \n\nfor\n(\nint\ni= \n0\n; i< n; i++) \n\nP[i][i] = \ntrue\n; \n\n\n// palindrome of length 2 \n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\nif\n(str[i] == str[i+\n1\n]) \n\n{ \n\nP[i][i+\n1\n] = \ntrue\n; \n\ndp[i][i+\n1\n] = \n1\n; \n\n} \n\n} \n\n\n// Palindromes of length more than 2. This loop is similar \n\n// to Matrix Chain Multiplication. We start with a gap of \n\n// length 2 and fill the DP table in a way that gap between \n\n// starting and ending indexes increases one by one by \n\n// outer loop. \n\nfor\n(\nint\ngap=\n2\n; gap<n; gap++) \n\n{ \n\n// Pick starting point for current gap \n\nfor\n(\nint\ni=\n0\n; i<n-gap; i++) \n\n{ \n\n// Set ending point \n\nint\nj = gap + i; \n\n\n// If current string is palindrome \n\nif\n(str[i] == str[j] && P[i+\n1\n][j-\n1\n] ) \n\nP[i][j] = \ntrue\n; \n\n\n// Add current palindrome substring ( + 1) \n\n// and rest palindrome substring (dp[i][j-1] + dp[i+1][j]) \n\n// remove common palindrome substrings (- dp[i+1][j-1]) \n\nif\n(P[i][j] == \ntrue\n) \n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] + \n1\n- dp[i+\n1\n][j-\n1\n]; \n\nelse\n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] - dp[i+\n1\n][j-\n1\n]; \n\n} \n\n} \n\n\n// return total palindromic substrings \n\nreturn\ndp[\n0\n][n-\n1\n]; \n\n} \n\n\n// Driver Method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"abaab\"\n; \n\nSystem.out.println(CountPS(str.toCharArray(), str.length())); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 441, "index": 441}
{"src": "\n// A Dynamic Programming solution for Rod cutting problem \nclass\nRodCutting \n{ \n\n/* Returns the best obtainable price for a rod of \n\nlength n and price[] as prices of different pieces */\n\nstatic\nint\ncutRod(\nint\nprice[],\nint\nn) \n\n{ \n\nint\nval[] = \nnew\nint\n[n+\n1\n]; \n\nval[\n0\n] = \n0\n; \n\n\n// Build the table val[] in bottom up manner and return \n\n// the last entry from the table \n\nfor\n(\nint\ni = \n1\n; i<=n; i++) \n\n{ \n\nint\nmax_val = Integer.MIN_VALUE; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nmax_val = Math.max(max_val, \n\nprice[j] + val[i-j-\n1\n]); \n\nval[i] = max_val; \n\n} \n\n\nreturn\nval[n]; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[] {\n1\n, \n5\n, \n8\n, \n9\n, \n10\n, \n17\n, \n17\n, \n20\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Maximum Obtainable Value is \"\n+ \n\ncutRod(arr, size)); \n\n} \n} \n/* This code is contributed by Rajat Mishra */", "complexity": "quadratic", "from": "CorCod", "problem": 442, "index": 442}
{"src": "//Atcoder\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 443, "index": 443}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class TestClass {\n    // function for finding size of set\n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 444, "index": 444}
{"src": "\n// JAVA Code for Minimum number of jumps to reach end \nclass\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n// jumps[n-1] will hold the \n\n// result \n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n// if first element is 0, \n\n// end cannot be reached \n\n\njumps[\n0\n] = \n0\n; \n\n\n// Find the minimum number of jumps to reach arr[i] \n\n// from arr[0], and assign this value to jumps[i] \n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n// driver program to test above function \npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n} \n\n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "quadratic", "from": "CorCod", "problem": 445, "index": 445}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class TestClass {\n    // function for finding size of set\n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 446, "index": 446}
{"src": "\n// Java implementation of finding length of longest \n// Common substring using Dynamic Programming \npublic\nclass\nLongestCommonSubSequence \n{ \n\n/* \n\nReturns length of longest common substring \n\nof X[0..m-1] and Y[0..n-1] \n\n*/\n\nstatic\nint\nLCSubStr(\nchar\nX[], \nchar\nY[], \nint\nm, \nint\nn) \n\n{ \n\n// Create a table to store lengths of longest common suffixes of \n\n// substrings. Note that LCSuff[i][j] contains length of longest \n\n// common suffix of X[0..i-1] and Y[0..j-1]. The first row and \n\n// first column entries have no logical meaning, they are used only \n\n// for simplicity of program \n\nint\nLCStuff[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\nint\nresult = \n0\n; \n// To store length of the longest common substring \n\n\n// Following steps build LCSuff[m+1][n+1] in bottom up fashion \n\nfor\n(\nint\ni = \n0\n; i <= m; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\n{ \n\nif\n(i == \n0\n|| j == \n0\n) \n\nLCStuff[i][j] = \n0\n; \n\nelse\nif\n(X[i - \n1\n] == Y[j - \n1\n]) \n\n{ \n\nLCStuff[i][j] = LCStuff[i - \n1\n][j - \n1\n] + \n1\n; \n\nresult = Integer.max(result, LCStuff[i][j]); \n\n} \n\nelse\n\nLCStuff[i][j] = \n0\n; \n\n} \n\n} \n\nreturn\nresult; \n\n} \n\n\n// Driver Program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString X = \n\"OldSite:GeeksforGeeks.org\"\n; \n\nString Y = \n\"NewSite:GeeksQuiz.com\"\n; \n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\nSystem.out.println(\n\"Length of Longest Common Substring is \"\n\n+ LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); \n\n} \n} \n\n// This code is contributed by Sumit Ghosh ", "complexity": "quadratic", "from": "CorCod", "problem": 447, "index": 447}
{"src": "\n// Java program to split array and move first \n// part to end. \n\nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nGFG { \n\npublic\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < k; i++) { \n\n\n// Rotate array by 1. \n\nint\nx = arr[\n0\n]; \n\nfor\n(\nint\nj = \n0\n; j < n - \n1\n; ++j) \n\narr[j] = arr[j + \n1\n]; \n\narr[n - \n1\n] = x; \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nsplitArr(arr, \n6\n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} \n\n// Code Contributed by Mohit Gupta_OMG <(0_o)> ", "complexity": "quadratic", "from": "CorCod", "problem": 448, "index": 448}
{"src": "import java.util.*;\n\npublic class vas2 {\n    public static void main( String[] args ) {\n\tScanner in = new Scanner( System.in );\n\tint n = in.nextInt();\n\tString st = in.next();\n\tint[] a = new int[n];\n\tfor ( int i = 0; i < n; i++ )\n\t    a[i] = st.charAt( i ) - 48;\n\tboolean c = false;\n\tfor ( int i = 1; !c && i < n; i++ ) {\n\t    int s = 0;\n\t    for ( int j = 0; j < i; j++ )\n\t\ts += a[j];\n\t    int t = 0;\n\t    for ( int j = i; j < n; j++ ) {\n\t\tt += a[j];\n\t\tif ( t > s )\n\t\t    if ( t - a[j] != s )\n\t\t\tbreak;\n\t\t    else\n\t\t\tt = a[j];\n\t    }\n\t    if ( t == s )\n\t\tc = true;\n\t}\n\tSystem.out.println( c ? \"YES\" : \"NO\" );\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 449, "index": 449}
{"src": "\n// A memoization based Java program to \n// count even length binary sequences \n// such that the sum of first and \n// second half bits is same \nimport\njava.io.*; \n\nclass\nGFG { \n\n// A lookup table to store the results of \n// subproblems \nstatic\nint\nlookup[][] = \nnew\nint\n[\n1000\n][\n1000\n]; \n\n// dif is diference between sums of first \n// n bits and last n bits i.e., \n// dif = (Sum of first n bits) - (Sum of last n bits) \nstatic\nint\ncountSeqUtil(\nint\nn, \nint\ndif) \n{ \n\n// We can't cover diference of \n\n// more than n with 2n bits \n\nif\n(Math.abs(dif) > n) \n\nreturn\n0\n; \n\n\n// n == 1, i.e., 2 bit long sequences \n\nif\n(n == \n1\n&& dif == \n0\n) \n\nreturn\n2\n; \n\nif\n(n == \n1\n&& Math.abs(dif) == \n1\n) \n\nreturn\n1\n; \n\n\n// Check if this subbproblem is already \n\n// solved n is added to dif to make \n\n// sure index becomes positive \n\nif\n(lookup[n][n+dif] != -\n1\n) \n\nreturn\nlookup[n][n+dif]; \n\n\nint\nres = \n// First bit is 0 & last bit is 1 \n\ncountSeqUtil(n-\n1\n, dif+\n1\n) + \n\n\n// First and last bits are same \n\n2\n*countSeqUtil(n-\n1\n, dif) + \n\n\n// First bit is 1 & last bit is 0 \n\ncountSeqUtil(n-\n1\n, dif-\n1\n); \n\n\n// Store result in lookup table \n\n// and return the result \n\nreturn\nlookup[n][n+dif] = res; \n} \n\n// A Wrapper over countSeqUtil(). It mainly \n// initializes lookup table, then calls \n// countSeqUtil() \nstatic\nint\ncountSeq(\nint\nn) \n{ \n\n// Initialize all entries of lookup \n\n// table as not filled \n\n// memset(lookup, -1, sizeof(lookup)); \n\nfor\n(\nint\nk = \n0\n; k < lookup.length; k++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < lookup.length; j++) \n\n{ \n\nlookup[k][j] = -\n1\n; \n\n} \n\n} \n\n\n// call countSeqUtil() \n\nreturn\ncountSeqUtil(n, \n0\n); \n} \n\n// Driver program \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Count of sequences is \"\n\n+ countSeq(\n2\n)); \n} \n} \n\n// This code is contributed by Prerna Saini ", "complexity": "quadratic", "from": "CorCod", "problem": 450, "index": 450}
{"src": "\n// Java program to count number of substrings \n// of a string \nimport\njava.io.*; \n\npublic\nclass\nGFG { \n\n\nstatic\nint\ncountNonEmptySubstr(String str) \n\n{ \n\nint\nn = str.length(); \n\nreturn\nn * (n + \n1\n) / \n2\n; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcde\"\n; \n\nSystem.out.println( \n\ncountNonEmptySubstr(s)); \n\n} \n} \n\n// This code is contributed \n// by Manish Shaw (manishshaw1) ", "complexity": "quadratic", "from": "CorCod", "problem": 451, "index": 451}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint[] arr = new int [n];\n\t\tint maxindex=0;\n\t\tint minindex=0;\n\t\tint max;\n\t\tint min;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tarr[i]=sc.nextInt();\n\t\t}\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tfor(int j=i;j<arr.length;j++) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tint k1=Math.min(arr[i], arr[j])/Math.abs(i-j);\n\t\t\t\t\tif(k1<k) {\n\t\t\t\t\t\tk = k1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(k);\n\t}\n\n}", "complexity": "quadratic", "from": "CorCod", "problem": 452, "index": 452}
{"src": "//\n//                                  _oo8oo_\n//                                 o8888888o\n//                                 88\" . \"88\n//                                 (| -_- |)\n//                                 0\\  =  /0\n//                               ___/'==='\\___\n//                             .' \\\\|     |// '.\n//                            / \\\\|||  :  |||// \\\n//                           / _||||| -:- |||||_ \\\n//                          |   | \\\\\\  -  /// |   |\n//                          | \\_|  ''\\---/''  |_/ |\n//                          \\  .-\\__  '-'  __/-.  /\n//                        ___'. .'  /--.--\\  '. .'___\n//                     .\"\" '<  '.___\\_<|>_/___.'  >' \"\".\n//                    | | :  `- \\`.:`\\ _ /`:.`/ -`  : | |\n//                    \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n//                =====`-.____`.___ \\_____/ ___.`____.-`=====\n//                                  `=---=`\n//\n//\n//               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//                          \u4f5b\u7956\u4fdd\u4f51         \u6c38\u4e0d\u5b95\u673a/\u6c38\u65e0bug\n//\n\nimport java.util.*;\n\npublic class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n//        System.out.println(Arrays.toString(list.toArray()));\n//        if (list.size() < n) {\n//            System.out.println(0);\n//        } else {\n//            System.out.println(list.get(n - 1).num);\n//        }\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 453, "index": 453}
{"src": "/*\n * Created on 17.05.2019\n */\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * @author Wolfgang Weck\n */\npublic class A01Easy {\n\tprivate static interface Matrix {\n\t\tboolean get(int i, int j);\n\n\t\tint size();\n\t}\n\n\tprivate static class MData implements Matrix {\n\t\tprivate final boolean[][] m;\n\n\t\tMData(boolean[][] m) {\n\t\t\tthis.m = m;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn m[i][j];\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn m.length;\n\t\t}\n\t}\n\n\tprivate static abstract class MDecorator implements Matrix {\n\t\tprotected final Matrix inner;\n\n\t\tMDecorator(Matrix inner) {\n\t\t\tthis.inner = inner;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn inner.size();\n\t\t}\n\t}\n\n\tprivate static class MHFlip extends MDecorator {\n\t\tMHFlip(Matrix inner) {\n\t\t\tsuper(inner);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn inner.get(size() - 1 - i, j);\n\t\t}\n\t}\n\n\tprivate static class MVFlip extends MDecorator {\n\t\tMVFlip(Matrix inner) {\n\t\t\tsuper(inner);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn inner.get(i, size() - 1 - j);\n\t\t}\n\t}\n\n\tprivate static class MRot extends MDecorator {\n\t\tMRot(Matrix inner) {\n\t\t\tsuper(inner);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn inner.get(j, size() - 1 - i);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry (BufferedReader r = new BufferedReader(new InputStreamReader(System.in))) {\n\t\t\tfinal int N = Integer.parseInt(r.readLine());\n\t\t\tMatrix m1 = readMatrix(r, N), m2 = readMatrix(r, N);\n\t\t\tboolean matched = matchesFlipped(m1, m2);\n\t\t\tint i = 0;\n\t\t\twhile (i < 3 && !matched) {\n\t\t\t\tm1 = new MRot(m1);\n\t\t\t\tmatched = matchesFlipped(m1, m2);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tSystem.out.println(matched ? \"Yes\" : \"No\");\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate static Matrix readMatrix(BufferedReader r, int n) throws IOException {\n\t\tboolean[][] m = new boolean[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString line = r.readLine();\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tm[i][j] = line.charAt(j) == 'X';\n\t\t\t}\n\t\t}\n\t\treturn new MData(m);\n\t}\n\n\tprivate static boolean matches(Matrix m1, Matrix m2) {\n\t\tint i = 0, j = 0, n = m1.size();\n\t\twhile (i < n && m1.get(i, j) == m2.get(i, j)) {\n\t\t\tj++;\n\t\t\tif (j == n) {\n\t\t\t\tj = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn i == n;\n\t}\n\n\tprivate static boolean matchesFlipped(Matrix m1, Matrix m2) {\n\t\treturn matches(m1, m2) || matches(new MHFlip(m1), m2) || matches(new MVFlip(m1), m2);\n\t}\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 454, "index": 454}
{"src": "\n// A Simple Java program to find pairs with distance \n// equal to English alphabet distance \nclass\nTest { \n\n\n// Method to count pairs \n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n\n// Increment count if characters \n\n// are at same distance \n\nif\n(Math.abs(str.charAt(i) - str.charAt(j)) == \n\nMath.abs(i - j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 455, "index": 455}
{"src": "import java.io.BufferedInputStream;\nimport java.util.Scanner;\n\npublic class RookHome {\n\tstatic long MAX = 1_000_000_000;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(new BufferedInputStream(System.in));\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tlong[] vert = new long[n + 2];\n\t\tvert[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tvert[i] = s.nextLong();\n\t\t}\n\t\tvert[n + 1] = MAX;\n\t\tlong[][] hor = new long[m][2];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\thor[i][0] = s.nextLong();\n\t\t\thor[i][1] = s.nextLong();\n\t\t\ts.nextLong();\n\t\t}\n\t\tlong min = Long.MAX_VALUE;\n\t\tint count;\n\t\tfor(int i = 0; i < vert.length - 1; i++) {\n\t\t\tcount = 0;\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = Math.min(min, i + count);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 456, "index": 456}
{"src": "//package ContestEd69;\n\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class mainD {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n    public static long[] arr;\n    public static void main(String[] args) throws IOException {\n        int n=enter.nextInt();\n        int m=enter.nextInt();\n        long k=enter.nextLong();\n        arr=new long[n+1];\n        for (int i = 1; i <n+1 ; i++) {\n            arr[i]=enter.nextLong();\n        }\n        long[] summ=new long[n+1];\n        for (int i = 1; i <n+1 ; i++) {\n            summ[i]+=arr[i]+summ[i-1];\n        }\n\n        long[] best=new long[n+1];\n\n        for (int i = 1; i <n+1 ; i++) {\n            best[i]=Math.max(0, ((i-m>=0) ? best[i-m]+summ[i]-summ[i-m]-k:0));\n        }\n        long ans=best[1];\n\n        for (int i = 1; i <n+1 ; i++) {\n            ans=Math.max(ans,best[i]);\n            for (int j = 1; j <m ; j++) {\n                ans=Math.max(ans, ((i-j>=0) ? best[i-j] -k +summ[i]-summ[i-j]:0));\n            }\n        }\n        System.out.println(ans);\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 457, "index": 457}
{"src": "\n// Java program to print a given matrix in spiral form \nimport\njava.io.*; \n\nclass\nGFG { \n\n// Function print matrix in spiral form \n\nstatic\nvoid\nspiralPrint(\nint\nm, \nint\nn, \nint\na[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n/* k - starting row index \n\nm - ending row index \n\nl - starting column index \n\nn - ending column index \n\ni - iterator \n\n*/\n\n\nwhile\n(k < m && l < n) { \n\n// Print the first row from the remaining rows \n\nfor\n(i = l; i < n; ++i) { \n\nSystem.out.print(a[k][i] + \n\" \"\n); \n\n} \n\nk++; \n\n\n// Print the last column from the remaining columns \n\nfor\n(i = k; i < m; ++i) { \n\nSystem.out.print(a[i][n - \n1\n] + \n\" \"\n); \n\n} \n\nn--; \n\n\n// Print the last row from the remaining rows */ \n\nif\n(k < m) { \n\nfor\n(i = n - \n1\n; i >= l; --i) { \n\nSystem.out.print(a[m - \n1\n][i] + \n\" \"\n); \n\n} \n\nm--; \n\n} \n\n\n// Print the first column from the remaining columns */ \n\nif\n(l < n) { \n\nfor\n(i = m - \n1\n; i >= k; --i) { \n\nSystem.out.print(a[i][l] + \n\" \"\n); \n\n} \n\nl++; \n\n} \n\n} \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nR = \n3\n; \n\nint\nC = \n6\n; \n\nint\na[][] = { { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}, \n\n{ \n7\n, \n8\n, \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n, \n17\n, \n18\n} }; \n\nspiralPrint(R, C, a); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "complexity": "quadratic", "from": "CorCod", "problem": 458, "index": 458}
{"src": "import java.util.Scanner;\npublic class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "complexity": "quadratic", "from": "CorCod", "problem": 459, "index": 459}
{"src": "import java.util.*;\nimport java.math.*;\npublic class Solution{\n    private long [] sums;\n    private void solve(){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int k = sc.nextInt();\n        int [] arr = new int[n];\n        this.sums = new long[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = sc.nextInt();\n            sums[i] = arr[i] + (i == 0 ? 0 : sums[i - 1]);\n        }\n        long ans = 0;\n        for(int i = 1; i <= n && i <= m; i++){\n            ans = Math.max(ans, sum(0, i - 1) - k);\n        }\n        long [] dp = new long[n];\n        for(int i = 0; i < n; i++){\n            if(i + 1 >= m){\n                long cur = sum(i - m + 1, i) - k;\n                if(i - m >= 0){\n                    cur += dp[i - m];\n                }\n                dp[i] = Math.max(dp[i], cur);\n            }\n            for(int j = 0; j <= m && i + j < n; j++){\n                ans = Math.max(ans, dp[i] + sum(i + 1, i + j) - k * (j > 0 ? 1 : 0));\n            }\n        }\n        System.out.println(ans);\n    }\n    private long sum(int l, int r){\n        if(l <= 0){\n            return sums[r];\n        }else{\n            return sums[r] - sums[l - 1];\n        }\n    }\n    public static void main(String [] args){\n        new Solution().solve();\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 460, "index": 460}
{"src": "\n// Java program for recursive level order traversal in spiral form \n\n/* A binary tree node has data, pointer to left child \n\nand a pointer to right child */\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n// Function to print the spiral traversal of tree \n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n/* ltr -> left to right. If this variable is set then the \n\ngiven label is traversed from left to right */\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n/*Revert ltr to traverse next level in opposite order*/\n\nltr = !ltr; \n\n} \n\n} \n\n\n/* Compute the \"height\" of a tree -- the number of \n\nnodes along the longest path from the root node \n\ndown to the farthest leaf node.*/\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n/* compute the height of each subtree */\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n/* use the larger one */\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n/* Print nodes at a given level */\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n/* Driver program to test the above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "quadratic", "from": "CorCod", "problem": 461, "index": 461}
{"src": "\n// Java program program to merge two \n// sorted arrays with O(1) extra space. \n\nimport\njava.util.Arrays; \n\nclass\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n1\n, \n5\n, \n9\n, \n10\n, \n15\n, \n20\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n2\n, \n3\n, \n8\n, \n13\n}; \n\n\nstatic\nvoid\nmerge(\nint\nm, \nint\nn) \n\n{ \n\n// Iterate through all elements of ar2[] starting from \n\n// the last element \n\nfor\n(\nint\ni=n-\n1\n; i>=\n0\n; i--) \n\n{ \n\n/* Find the smallest element greater than ar2[i]. Move all \n\nelements one position ahead till the smallest greater \n\nelement is not found */\n\nint\nj, last = arr1[m-\n1\n]; \n\nfor\n(j=m-\n2\n; j >= \n0\n&& arr1[j] > arr2[i]; j--) \n\narr1[j+\n1\n] = arr1[j]; \n\n\n// If there was a greater element \n\nif\n(j != m-\n2\n|| last > arr2[i]) \n\n{ \n\narr1[j+\n1\n] = arr2[i]; \n\narr2[i] = last; \n\n} \n\n} \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nmerge(arr1.length,arr2.length); \n\nSystem.out.print(\n\"After Merging nFirst Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr1)); \n\nSystem.out.print(\n\"Second Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr2)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 462, "index": 462}
{"src": "\n// Java program to find Minimum \n// number of jumps to reach end \nclass\nGFG \n{ \n// Returns Minimum number \n// of jumps to reach end \nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n// jumps[0] will \n\n// hold the result \n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n// Minimum number of jumps \n\n// needed to reach last \n\n// element from last elements \n\n// itself is always 0 \n\njumps[n - \n1\n] = \n0\n; \n\n\n\n// Start from the second \n\n// element, move from right \n\n// to left and construct the \n\n// jumps[] array where jumps[i] \n\n// represents minimum number of \n\n// jumps needed to reach arr[m-1] \n\n// from arr[i] \n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n// If arr[i] is 0 then arr[n-1] \n\n// can't be reached from here \n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n// If we can direcly reach to \n\n// the end point from here then \n\n// jumps[i] is 1 \n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n// Otherwise, to find out \n\n// the minimum number of \n\n// jumps needed to reach \n\n// arr[n-1], check all the \n\n// points reachable from \n\n// here and jumps[] value \n\n// for those points \n\nelse\n\n{ \n\n// initialize min value \n\nmin = Integer.MAX_VALUE; \n\n\n// following loop checks \n\n// with all reachable points \n\n// and takes the minimum \n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n// Handle overflow \n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n// or Integer.MAX_VALUE \n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n} \n\n// This code is contributed by mits. ", "complexity": "quadratic", "from": "CorCod", "problem": 463, "index": 463}
{"src": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 464, "index": 464}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class main {\nstatic\tclass Interval{\n\t\tint start;\n\t\tint end;\n\t\tpublic Interval(int start,int end) {\n\t\t\tthis.start=start;\n\t\t\tthis.end=end;\n\t\t}\n\t}\nstatic class FastReader \n{ \n    BufferedReader br; \n    StringTokenizer st; \n\n    public FastReader() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n\n    String next() \n    { \n        while (st == null || !st.hasMoreElements()) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n\n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n\n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n\n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n\n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n} \n\tstatic long mod = 1000000007;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tFastReader in = new FastReader();\n\t\tlong intervals = in.nextInt();\n\t\tlong x = in.nextInt();\n\t\t long y = in.nextInt();\n\t\tInterval []ints = new Interval[(int)(int) intervals];\n\t\tfor(int i = 0;i<intervals;i++) {\n\t\t\tints[i] = new Interval(in.nextInt(),in.nextInt());\n\t\t}\n\t\tArrays.sort(ints, (a,b)->a.start-b.start);\n\t\tlong count = 0;\n\t\tfor(int i = 0;i<ints.length;i++) {\n\t\t\tif(i>=0&&ints[i]!=null) {\n\t\t\tInterval cur1 = ints[i];\n\t\t\tfor(int j = i+1;j<ints.length;j++) {\n\t\t\tif(ints[j]!=null) {\n\t\t\tInterval cur2 = ints[j];\n\t\t\tif(y*(cur2.start-cur1.end)<x) {\n\t\t\tif(cur1.start!=cur2.start&&cur1.end<cur2.start) {\n\t\t\t\tcur1.end=cur2.end;\n\t\t\t\t\n\t\t\t\tints[j]=null;\n\t\t\t//\ti--;\n\t\t\t}}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tcount = (count + x) % mod;\n\t\t\tcount += (y*(cur1.end-cur1.start)%mod);\n\t\t\tcount%=mod;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n//\t\tfor(int i = 0;i<ints.length;i++) {\n//\t\t\tif(ints[i]!=null) {\n//\t\t\tInterval cur = ints[i];\n//\t\t\tcount = (count + x) % mod;\n//\t\t\tcount += (y*(cur.end-cur.start)%mod);\n//\t\t\tcount%=mod;\n//\t\t\t}\n//\t\t}\n\t\tSystem.out.println(count);\n\t}\n\n}", "complexity": "quadratic", "from": "CorCod", "problem": 465, "index": 465}
{"src": "\n// A Java program to implement greedy algorithm for graph coloring \nimport\njava.io.*; \nimport\njava.util.*; \nimport\njava.util.LinkedList; \n\n// This class represents an undirected graph using adjacency list \nclass\nGraph \n{ \n\nprivate\nint\nV; \n// No. of vertices \n\nprivate\nLinkedList<Integer> adj[]; \n//Adjacency List \n\n\n//Constructor \n\nGraph(\nint\nv) \n\n{ \n\nV = v; \n\nadj = \nnew\nLinkedList[v]; \n\nfor\n(\nint\ni=\n0\n; i<v; ++i) \n\nadj[i] = \nnew\nLinkedList(); \n\n} \n\n\n//Function to add an edge into the graph \n\nvoid\naddEdge(\nint\nv,\nint\nw) \n\n{ \n\nadj[v].add(w); \n\nadj[w].add(v); \n//Graph is undirected \n\n} \n\n\n// Assigns colors (starting from 0) to all vertices and \n\n// prints the assignment of colors \n\nvoid\ngreedyColoring() \n\n{ \n\nint\nresult[] = \nnew\nint\n[V]; \n\n\n// Initialize all vertices as unassigned \n\nArrays.fill(result, -\n1\n); \n\n\n// Assign the first color to first vertex \n\nresult[\n0\n] = \n0\n; \n\n\n// A temporary array to store the available colors. False \n\n// value of available[cr] would mean that the color cr is \n\n// assigned to one of its adjacent vertices \n\nboolean\navailable[] = \nnew\nboolean\n[V]; \n\n\n// Initially, all colors are available \n\nArrays.fill(available, \ntrue\n); \n\n\n// Assign colors to remaining V-1 vertices \n\nfor\n(\nint\nu = \n1\n; u < V; u++) \n\n{ \n\n// Process all adjacent vertices and flag their colors \n\n// as unavailable \n\nIterator<Integer> it = adj[u].iterator() ; \n\nwhile\n(it.hasNext()) \n\n{ \n\nint\ni = it.next(); \n\nif\n(result[i] != -\n1\n) \n\navailable[result[i]] = \nfalse\n; \n\n} \n\n\n// Find the first available color \n\nint\ncr; \n\nfor\n(cr = \n0\n; cr < V; cr++){ \n\nif\n(available[cr]) \n\nbreak\n; \n\n} \n\n\nresult[u] = cr; \n// Assign the found color \n\n\n// Reset the values back to true for the next iteration \n\nArrays.fill(available, \ntrue\n); \n\n} \n\n\n// print the result \n\nfor\n(\nint\nu = \n0\n; u < V; u++) \n\nSystem.out.println(\n\"Vertex \"\n+ u + \n\" ---> Color \"\n\n+ result[u]); \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nGraph g1 = \nnew\nGraph(\n5\n); \n\ng1.addEdge(\n0\n, \n1\n); \n\ng1.addEdge(\n0\n, \n2\n); \n\ng1.addEdge(\n1\n, \n2\n); \n\ng1.addEdge(\n1\n, \n3\n); \n\ng1.addEdge(\n2\n, \n3\n); \n\ng1.addEdge(\n3\n, \n4\n); \n\nSystem.out.println(\n\"Coloring of graph 1\"\n); \n\ng1.greedyColoring(); \n\n\nSystem.out.println(); \n\nGraph g2 = \nnew\nGraph(\n5\n); \n\ng2.addEdge(\n0\n, \n1\n); \n\ng2.addEdge(\n0\n, \n2\n); \n\ng2.addEdge(\n1\n, \n2\n); \n\ng2.addEdge(\n1\n, \n4\n); \n\ng2.addEdge(\n2\n, \n4\n); \n\ng2.addEdge(\n4\n, \n3\n); \n\nSystem.out.println(\n\"Coloring of graph 2 \"\n); \n\ng2.greedyColoring(); \n\n} \n} \n// This code is contributed by Aakash Hasija ", "complexity": "quadratic", "from": "CorCod", "problem": 466, "index": 466}
{"src": "\n// Java program to query number of palindromic \n// substrings of a string in a range \nimport\njava.io.*; \n\nclass\nGFG { \n\n// Function to construct the dp array \n\nstatic\nvoid\nconstructDp(\nint\ndp[][], String str) \n\n{ \n\nint\nl = str.length(); \n\n\n// declare 2D array isPalin, isPalin[i][j] will \n\n// be 1 if str(i..j) is palindrome \n\nint\n[][] isPalin = \nnew\nint\n[l + \n1\n][l + \n1\n]; \n\n\n// initialize dp and isPalin array by zeros \n\nfor\n(\nint\ni = \n0\n; i <= l; i++) { \n\nfor\n(\nint\nj = \n0\n; j <= l; j++) { \n\nisPalin[i][j] = dp[i][j] = \n0\n; \n\n} \n\n} \n\n\n// loop for starting index of range \n\nfor\n(\nint\ni = l - \n1\n; i >= \n0\n; i--) { \n\n// initialize value for one character strings as 1 \n\nisPalin[i][i] = \n1\n; \n\ndp[i][i] = \n1\n; \n\n\n// loop for ending index of range \n\nfor\n(\nint\nj = i + \n1\n; j < l; j++) { \n\n/* isPalin[i][j] will be 1 if ith and \n\njth characters are equal and mid \n\nsubstring str(i+1..j-1) is also a \n\npalindrome */\n\nisPalin[i][j] = (str.charAt(i) == str.charAt(j) && (i + \n1\n> j - \n1\n|| (isPalin[i + \n1\n][j - \n1\n]) != \n0\n)) ? \n1\n: \n0\n; \n\n\n/* dp[i][j] will be addition of number \n\nof palindromes from i to j-1 and i+1 \n\nto j subtracting palindromes from i+1 \n\nto j-1 (as counted twice) plus 1 if \n\nstr(i..j) is also a palindrome */\n\ndp[i][j] = dp[i][j - \n1\n] + dp[i + \n1\n][j] - dp[i + \n1\n][j - \n1\n] + isPalin[i][j]; \n\n} \n\n} \n\n} \n\n\n// method returns count of palindromic substring in range (l, r) \n\nstatic\nint\ncountOfPalindromeInRange(\nint\ndp[][], \nint\nl, \nint\nr) \n\n{ \n\nreturn\ndp[l][r]; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nMAX = \n50\n; \n\nString str = \n\"xyaabax\"\n; \n\nint\n[][] dp = \nnew\nint\n[MAX][MAX]; \n\nconstructDp(dp, str); \n\n\nint\nl = \n3\n; \n\nint\nr = \n5\n; \n\nSystem.out.println(countOfPalindromeInRange(dp, l, r)); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "complexity": "quadratic", "from": "CorCod", "problem": 467, "index": 467}
{"src": "\nimport java.util.Scanner;\n\npublic class TaxistsnLyft {\n\tpublic static void main (String[] args){\n\t\tScanner scan = new Scanner (System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint k = n+m;\n\t\tlong[] arr1 = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tarr1[i]=scan.nextLong();\n\t\t}\n\t\tlong[] tax = new long[k];\n\t\tlong[] taxcount = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\ttax[i]=scan.nextInt();\n\t\t}\n\t\tint c;\n\t\tint b;\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tif(tax[i]==0){\n\t\t\t\tc=i;\n\t\t\t\twhile(tax[c]!=1){\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tc=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tc--;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tb=i;\n\t\t\t\twhile(tax[b]!=1){\n\t\t\t\t\tif(b>=k-1){\n\t\t\t\t\t\tb=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t\tb++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t//System.out.println(\">>\"+b+\">>\"+c);\n\t\t\t\tif(c==-1&&b>=0){\n\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t} else if(b==-1&&c>=0) {\n\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t} else if(b>=0&&c>=0) {\n\t\t\t\t\tif(arr1[i]-arr1[c]>arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]<arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]==arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tfor(int j = 0; j<k; j++){\n\t\t\tif(tax[j]==1){\n\t\t\t\tSystem.out.print(taxcount[j]+\" \");\n\t\t\t}\n\t\tscan.close();\n\t\t}\n\t}\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 468, "index": 468}
{"src": "\n// A Space optimized Dynamic Programming \n// based Java program for LPS problem \n\nclass\nGFG { \n\n\n// Returns the length of the longest \n\n// palindromic subsequence in str \n\nstatic\nint\nlps(String s) \n\n{ \n\nint\nn = s.length(); \n\n\n// a[i] is going to store length \n\n// of longest palindromic subsequence \n\n// of substring s[0..i] \n\nint\na[] = \nnew\nint\n[n]; \n\n\n// Pick starting point \n\nfor\n(\nint\ni = n - \n1\n; i >= \n0\n; i--) \n\n{ \n\nint\nback_up = \n0\n; \n\n\n// Pick ending points and see if s[i] \n\n// increases length of longest common \n\n// subsequence ending with s[j]. \n\nfor\n(\nint\nj = i; j < n; j++) { \n\n\n// similar to 2D array L[i][j] == 1 \n\n// i.e., handling substrings of length \n\n// one. \n\nif\n(j == i) \n\na[j] = \n1\n; \n\n\n// Similar to 2D array L[i][j] = L[i+1][j-1]+2 \n\n// i.e., handling case when corner characters \n\n// are same. \n\nelse\nif\n(s.charAt(i) == s.charAt(j)) \n\n{ \n\nint\ntemp = a[j]; \n\na[j] = back_up + \n2\n; \n\nback_up = temp; \n\n} \n\n\n// similar to 2D array L[i][j] = max(L[i][j-1], \n\n// a[i+1][j]) \n\nelse\n\n{ \n\nback_up = a[j]; \n\na[j] = Math.max(a[j - \n1\n], a[j]); \n\n} \n\n} \n\n} \n\nreturn\na[n - \n1\n]; \n\n} \n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"GEEKSFORGEEKS\"\n; \n\nSystem.out.println(lps(str)); \n\n} \n} \n\n//This article is contributed by prerna saini. ", "complexity": "quadratic", "from": "CorCod", "problem": 469, "index": 469}
{"src": "\n// A Java program for Prim's Minimum Spanning Tree (MST) algorithm. \n// The program is for adjacency matrix representation of the graph \n\nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nMST { \n\n// Number of vertices in the graph \n\nprivate\nstatic\nfinal\nint\nV = \n5\n; \n\n\n// A utility function to find the vertex with minimum key \n\n// value, from the set of vertices not yet included in MST \n\nint\nminKey(\nint\nkey[], Boolean mstSet[]) \n\n{ \n\n// Initialize min value \n\nint\nmin = Integer.MAX_VALUE, min_index = -\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(mstSet[v] == \nfalse\n&& key[v] < min) { \n\nmin = key[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n// A utility function to print the constructed MST stored in \n\n// parent[] \n\nvoid\nprintMST(\nint\nparent[], \nint\ngraph[][]) \n\n{ \n\nSystem.out.println(\n\"Edge \\tWeight\"\n); \n\nfor\n(\nint\ni = \n1\n; i < V; i++) \n\nSystem.out.println(parent[i] + \n\" - \"\n+ i + \n\"\\t\"\n+ graph[i][parent[i]]); \n\n} \n\n\n// Function to construct and print MST for a graph represented \n\n// using adjacency matrix representation \n\nvoid\nprimMST(\nint\ngraph[][]) \n\n{ \n\n// Array to store constructed MST \n\nint\nparent[] = \nnew\nint\n[V]; \n\n\n// Key values used to pick minimum weight edge in cut \n\nint\nkey[] = \nnew\nint\n[V]; \n\n\n// To represent set of vertices not yet included in MST \n\nBoolean mstSet[] = \nnew\nBoolean[V]; \n\n\n// Initialize all keys as INFINITE \n\nfor\n(\nint\ni = \n0\n; i < V; i++) { \n\nkey[i] = Integer.MAX_VALUE; \n\nmstSet[i] = \nfalse\n; \n\n} \n\n\n// Always include first 1st vertex in MST. \n\nkey[\n0\n] = \n0\n; \n// Make key 0 so that this vertex is \n\n// picked as first vertex \n\nparent[\n0\n] = -\n1\n; \n// First node is always root of MST \n\n\n// The MST will have V vertices \n\nfor\n(\nint\ncount = \n0\n; count < V - \n1\n; count++) { \n\n// Pick thd minimum key vertex from the set of vertices \n\n// not yet included in MST \n\nint\nu = minKey(key, mstSet); \n\n\n// Add the picked vertex to the MST Set \n\nmstSet[u] = \ntrue\n; \n\n\n// Update key value and parent index of the adjacent \n\n// vertices of the picked vertex. Consider only those \n\n// vertices which are not yet included in MST \n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n// graph[u][v] is non zero only for adjacent vertices of m \n\n// mstSet[v] is false for vertices not yet included in MST \n\n// Update the key only if graph[u][v] is smaller than key[v] \n\nif\n(graph[u][v] != \n0\n&& mstSet[v] == \nfalse\n&& graph[u][v] < key[v]) { \n\nparent[v] = u; \n\nkey[v] = graph[u][v]; \n\n} \n\n} \n\n\n// print the constructed MST \n\nprintMST(parent, graph); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n/* Let us create the following graph \n\n2 3 \n\n(0)--(1)--(2) \n\n| / \\ | \n\n6| 8/ \\5 |7 \n\n| / \\ | \n\n(3)-------(4) \n\n9 */\n\nMST t = \nnew\nMST(); \n\nint\ngraph[][] = \nnew\nint\n[][] { { \n0\n, \n2\n, \n0\n, \n6\n, \n0\n}, \n\n{ \n2\n, \n0\n, \n3\n, \n8\n, \n5\n}, \n\n{ \n0\n, \n3\n, \n0\n, \n0\n, \n7\n}, \n\n{ \n6\n, \n8\n, \n0\n, \n0\n, \n9\n}, \n\n{ \n0\n, \n5\n, \n7\n, \n9\n, \n0\n} }; \n\n\n// Print the solution \n\nt.primMST(graph); \n\n} \n} \n// This code is contributed by Aakash Hasija ", "complexity": "quadratic", "from": "CorCod", "problem": 470, "index": 470}
{"src": "\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n       Scanner s = new Scanner(System.in);\n       int n = s.nextInt();\n       int m = s.nextInt();\n       m = 0;\n       long sum = 0;\n       int[] expon = new int[n];\n        for (int i = 0; i < n; i++) {\n            expon[i] = s.nextInt();\n            m = Math.max(expon[i], m);\n            sum += expon[i];\n        }\n        HashSet<Integer> levels = new HashSet<>();\n\n\n        int amount = 0;\n        for (int i = 0; i < n; i++) {\n            int currentHigh = expon[i];\n            for (int j = currentHigh; j >= 1; j--) {\n                if(!levels.contains(j)) {\n                    levels.add(j);\n                    amount++;\n                    break;\n                }\n                if(j == 1){\n                    amount++;\n                }\n            }\n        }\n        System.out.println((sum - amount) - (m - levels.size()));\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 471, "index": 471}
{"src": "import java.util.*;\n\npublic class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 472, "index": 472}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author sumit\n */\npublic class Main {\n      public static void main(String[] args) {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            InputReader in = new InputReader(inputStream);\n            OutputWriter out = new OutputWriter(outputStream);\n            CChessboard solver = new CChessboard();\n            solver.solve(1, in, out);\n            out.close();\n      }\n\n      static class CChessboard {\n            int[] nextPermutation(int[] array) {\n                  int i = array.length - 1;\n                  while (i > 0 && array[i - 1] >= array[i]) {\n                        i--;\n                  }\n\n                  if (i <= 0) {\n                        return null;\n                  }\n\n                  int j = array.length - 1;\n\n                  while (array[j] <= array[i - 1]) {\n                        j--;\n                  }\n\n                  int temp = array[i - 1];\n                  array[i - 1] = array[j];\n                  array[j] = temp;\n\n                  j = array.length - 1;\n\n                  while (i < j) {\n                        temp = array[i];\n                        array[i] = array[j];\n                        array[j] = temp;\n                        i++;\n                        j--;\n                  }\n\n                  return array;\n            }\n\n            public void solve(int testNumber, InputReader in, OutputWriter out) {\n                  int n = in.nextInt();\n                  int arr[][][] = new int[4][n][n];\n                  int sum[] = new int[4];\n\n                  for (int k = 0; k < 4; k++) {\n                        for (int i = 0; i < n; i++) {\n                              String str = in.next();\n                              for (int j = 0; j < n; j++) {\n                                    arr[k][i][j] = (str.charAt(j) - '0');\n                              }\n                        }\n                  }\n\n                  for (int k = 0; k < 4; k++) {\n                        for (int i = 0; i < n; i++) {\n                              for (int j = 0; j < n; j++) {\n                                    if ((i + j) % 2 == arr[k][i][j])\n                                          sum[k]++;\n                              }\n                        }\n                  }\n\n                  int perm[] = new int[4];\n                  for (int i = 0; i < 4; i++)\n                        perm[i] = i;\n\n\n                  int min = Integer.MAX_VALUE;\n                  while (true) {\n                        perm = nextPermutation(perm);\n\n                        if (perm == null)\n                              break;\n\n                        int sm = 0;\n                        for (int j = 0; j < 4; j++) {\n                              if (j % 2 == 0) {\n                                    sm += (sum[perm[j]]);\n                              } else {\n                                    sm += (n * n - sum[perm[j]]);\n                              }\n                        }\n                        min = Math.min(min, sm);\n\n                        sm = 0;\n                        for (int j = 0; j < 4; j++) {\n                              if (j % 2 == 0) {\n                                    sm += (n * n - sum[perm[j]]);\n                              } else {\n                                    sm += (sum[perm[j]]);\n                              }\n                        }\n                        min = Math.min(sm, min);\n\n\n                  }\n                  out.printLine(min);\n\n\n            }\n\n      }\n\n      static class OutputWriter {\n            private final PrintWriter writer;\n\n            public OutputWriter(OutputStream outputStream) {\n                  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n            }\n\n            public OutputWriter(Writer writer) {\n                  this.writer = new PrintWriter(writer);\n            }\n\n            public void close() {\n                  writer.close();\n            }\n\n            public void printLine(int i) {\n                  writer.println(i);\n            }\n\n      }\n\n      static class InputReader {\n            private InputStream stream;\n            private byte[] buf = new byte[1024];\n            private int curChar;\n            private int numChars;\n\n            public InputReader(InputStream stream) {\n                  this.stream = stream;\n            }\n\n            public int read() {\n                  if (numChars == -1)\n                        throw new InputMismatchException();\n\n                  if (curChar >= numChars) {\n                        curChar = 0;\n                        try {\n                              numChars = stream.read(buf);\n                        } catch (IOException e) {\n                              throw new InputMismatchException();\n                        }\n                        if (numChars <= 0)\n                              return -1;\n                  }\n\n                  return buf[curChar++];\n            }\n\n            public int nextInt() {\n                  int c = read();\n\n                  while (isSpaceChar(c))\n                        c = read();\n\n                  int sgn = 1;\n\n                  if (c == '-') {\n                        sgn = -1;\n                        c = read();\n                  }\n\n                  int res = 0;\n\n                  do {\n                        if (c < '0' || c > '9')\n                              throw new InputMismatchException();\n\n                        res *= 10;\n                        res += c & 15;\n\n                        c = read();\n                  } while (!isSpaceChar(c));\n\n                  return res * sgn;\n            }\n\n            public String next() {\n                  int c = read();\n\n                  while (isSpaceChar(c))\n                        c = read();\n\n                  StringBuilder res = new StringBuilder();\n\n                  do {\n                        res.appendCodePoint(c);\n\n                        c = read();\n                  } while (!isSpaceChar(c));\n\n                  return res.toString();\n            }\n\n            public boolean isSpaceChar(int c) {\n                  return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n            }\n\n      }\n}\n\n", "complexity": "quadratic", "from": "CorCod", "problem": 473, "index": 473}
{"src": "\nimport java.io.BufferedOutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class E1180D {\n\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        // Move from both ends, Time limit exceeded on test 6\n        for (int i= 1; i<= m/2; i++) {\n            // String s = \"\";\n            int i2 = m -i + 1; // the other end of i\n            // i is left row, i2 is right row\n            for (int j = 1; j <= n ; j++) {\n                int j2 = n - j + 1;\n                // start with (i,j), then go thru all the cell with (,i) and (,i2)\n                pw.println(j + \" \" + i);\n                pw.println(j2+ \" \" + i2);\n                // s += j + \" \" + i + \"\\n\" + j2+ \" \" + i2 + \"\\n\";\n            }\n            // out.print(s);\n        }\n        \n        // if n is odd, there is one line in the middle\n        if (m % 2 == 1) {\n            int i2 = m /2 + 1; // this is the middle column\n            for (int j = 1; j <= n/2 ; j++) {\n                int j2 = n - j + 1;\n                // start with (i,j), then go thru all the cell with (,i) and (,i2)\n                pw.println(j + \" \" + i2);\n                pw.println(j2+ \" \" + i2);\n            }\n            if (n %2 == 1) {\n                int j = n /2 + 1;\n                pw.println(j + \" \" + i2);\n            }\n        }\n        pw.flush();\n        pw.close();\n    }    \n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 474, "index": 474}
{"src": "//Atcoder\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 475, "index": 475}
{"src": "\n// Java program to find sum of maximum \n// sum alternating sequence starting with \n// first element. \n\npublic\nclass\nGFG \n{ \n\n// Return sum of maximum sum alternating \n\n// sequence starting with arr[0] and is first \n\n// decreasing. \n\nstatic\nint\nmaxAlternateSum(\nint\narr[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\narr[\n0\n]; \n\n\n// create two empty array that store result of \n\n// maximum sum of alternate sub-sequence \n\n\n// stores sum of decreasing and increasing \n\n// sub-sequence \n\nint\ndec[] = \nnew\nint\n[n]; \n\n\n\n// store sum of increasing and decreasing sun-sequence \n\nint\ninc[] = \nnew\nint\n[n]; \n\n\n// As per question, first element must be part \n\n// of solution. \n\ndec[\n0\n] = inc[\n0\n] = arr[\n0\n]; \n\n\nint\nflag = \n0\n; \n\n\n// Traverse remaining elements of array \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<i; j++) \n\n{ \n\n// IF current sub-sequence is decreasing the \n\n// update dec[j] if needed. dec[i] by current \n\n// inc[j] + arr[i] \n\nif\n(arr[j] > arr[i]) \n\n{ \n\ndec[i] = Math.max(dec[i], inc[j]+arr[i]); \n\n\n// Revert the flag , if first decreasing \n\n// is found \n\nflag = \n1\n; \n\n} \n\n\n// If next element is greater but flag should be 1 \n\n// i.e. this element should be counted after the \n\n// first decreasing element gets counted \n\nelse\nif\n(arr[j] < arr[i] && flag == \n1\n) \n\n\n// If current sub-sequence is increasing \n\n// then update inc[i] \n\ninc[i] = Math.max(inc[i], dec[j]+arr[i]); \n\n} \n\n} \n\n\n// find maximum sum in b/w inc[] and dec[] \n\nint\nresult = Integer.MIN_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(result < inc[i]) \n\nresult = inc[i]; \n\nif\n(result < dec[i]) \n\nresult = dec[i]; \n\n} \n\n\n// return maximum sum alternate sun-sequence \n\nreturn\nresult; \n\n} \n\n\n// Driver Method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[]= {\n8\n, \n2\n, \n3\n, \n5\n, \n7\n, \n9\n, \n10\n}; \n\nSystem.out.println(\n\"Maximum sum = \"\n+ \n\nmaxAlternateSum(arr , arr.length)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 476, "index": 476}
{"src": "\n// Java implementation to find the first negative \n// integer in every window of size k \nimport\njava.util.*; \n\nclass\nsolution \n{ \n\n// function to find the first negative \n// integer in every window of size k \nstatic\nvoid\nprintFirstNegativeInteger(\nint\narr[], \nint\nn, \nint\nk) \n{ \n\n// flag to check whether window contains \n\n// a negative integer or not \n\nboolean\nflag; \n\n\n// Loop for each subarray(window) of size k \n\nfor\n(\nint\ni = \n0\n; i<(n-k+\n1\n); i++) \n\n{ \n\nflag = \nfalse\n; \n\n\n// traverse through the current window \n\nfor\n(\nint\nj = \n0\n; j<k; j++) \n\n{ \n\n// if a negative integer is found, then \n\n// it is the first negative integer for \n\n// current window. Print it, set the flag \n\n// and break \n\nif\n(arr[i+j] < \n0\n) \n\n{ \n\nSystem.out.print((arr[i+j])+\n\" \"\n); \n\nflag = \ntrue\n; \n\nbreak\n; \n\n} \n\n} \n\n\n// if the current window does not \n\n// contain a negative integer \n\nif\n(!flag) \n\nSystem.out.print(\n\"0\"\n+\n\" \"\n); \n\n} \n} \n\n// Driver program to test above functions \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n12\n, -\n1\n, -\n7\n, \n8\n, -\n15\n, \n30\n, \n16\n, \n28\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nprintFirstNegativeInteger(arr, n, k); \n\n} \n} \n// This code is contributed by \n// Shashank_Sharma ", "complexity": "quadratic", "from": "CorCod", "problem": 477, "index": 477}
{"src": "\n// Java prorgam for finding max path in matrix \n\nimport\nstatic\njava.lang.Math.max; \n\nclass\nGFG \n{ \n\npublic\nstatic\nint\nN = \n4\n, M = \n6\n; \n\n\n// Function to calculate max path in matrix \n\nstatic\nint\nfindMaxPath(\nint\nmat[][]) \n\n{ \n\n// To find max val in first row \n\nint\nres = -\n1\n; \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nres = max(res, mat[\n0\n][i]); \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\nres = -\n1\n; \n\nfor\n(\nint\nj = \n0\n; j < M; j++) \n\n{ \n\n// When all paths are possible \n\nif\n(j > \n0\n&& j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmax(mat[i - \n1\n][j - \n1\n], \n\nmat[i - \n1\n][j + \n1\n])); \n\n\n// When diagonal right is not possible \n\nelse\nif\n(j > \n0\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j - \n1\n]); \n\n\n// When diagonal left is not possible \n\nelse\nif\n(j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j + \n1\n]); \n\n\n// Store max path sum \n\nres = max(mat[i][j], res); \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nmat[][] = { { \n10\n, \n10\n, \n2\n, \n0\n, \n20\n, \n4\n}, \n\n{ \n1\n, \n0\n, \n0\n, \n30\n, \n2\n, \n5\n}, \n\n{ \n0\n, \n10\n, \n4\n, \n0\n, \n2\n, \n0\n}, \n\n{ \n1\n, \n0\n, \n2\n, \n20\n, \n0\n, \n4\n} \n\n}; \n\n\nSystem.out.println(findMaxPath(mat)); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "complexity": "quadratic", "from": "CorCod", "problem": 478, "index": 478}
{"src": "\nclass\nPair{ \n\nint\na; \n\nint\nb; \n\n\npublic\nPair(\nint\na, \nint\nb) { \n\nthis\n.a = a; \n\nthis\n.b = b; \n\n} \n\n\n// This function assumes that arr[] is sorted in increasing order \n\n// according the first (or smaller) values in pairs. \n\nstatic\nint\nmaxChainLength(Pair arr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmcl[] = \nnew\nint\n[n]; \n\n\n/* Initialize MCL (max chain length) values for all indexes */\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nmcl[i] = \n1\n; \n\n\n/* Compute optimized chain length values in bottom up manner */\n\nfor\n( i = \n1\n; i < n; i++ ) \n\nfor\n( j = \n0\n; j < i; j++ ) \n\nif\n( arr[i].a > arr[j].b && mcl[i] < mcl[j] + \n1\n) \n\nmcl[i] = mcl[j] + \n1\n; \n\n\n// mcl[i] now stores the maximum chain length ending with pair i \n\n\n/* Pick maximum of all MCL values */\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nif\n( max < mcl[i] ) \n\nmax = mcl[i]; \n\n\nreturn\nmax; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nPair arr[] = \nnew\nPair[] {\nnew\nPair(\n5\n,\n24\n), \nnew\nPair(\n15\n, \n25\n), \n\nnew\nPair (\n27\n, \n40\n), \nnew\nPair(\n50\n, \n60\n)}; \n\nSystem.out.println(\n\"Length of maximum size chain is \"\n+ \n\nmaxChainLength(arr, arr.length)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 479, "index": 479}
{"src": "import java.util.*;\npublic class Main {\n    public static int n, m;\n    public static int[] vert, group;\n    public static int[][] horiz;\n    public static boolean ok(int a, int b, int g) {\n        int start, end;\n        if (g == 0) {\n            start = 1;\n            end = vert.length > 0 ? vert[0] : (int)Math.pow(10, 9);\n        } else if (g == group.length - 1) {\n            start = vert[g - 1];\n            end = (int)Math.pow(10, 9);\n        } else {\n            start = vert[g - 1];\n            end = vert[g];\n        }\n        return a <= start && b >= end;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        vert = new int[n];\n        for (int i = 0; i < n; i++) {\n            vert[i] = in.nextInt();\n        }\n        horiz = new int[m][3];\n        for (int i = 0; i < m; i++) {\n            horiz[i] = new int[]{in.nextInt(), in.nextInt(), in.nextInt()};\n        }\n        group = new int[n + 1];\n        Arrays.fill(group, 0);\n        for (int i = 0; i < m; i++) {\n            int a = horiz[i][0];\n            int b = horiz[i][1];\n            for (int j = 0; j < group.length; j++) {\n                if (ok(a, b, j)) {\n                    group[j]++;\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < group.length; i++) {\n            min = Math.min(min, group[i] + i);\n        }\n        System.out.println(min);\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 480, "index": 480}
{"src": "import java.util.Scanner;\n\n\npublic class FUck {\n\n\t\tpublic static void main(String args[])\n\t\t{\n\t\t\tScanner scan=new Scanner(System.in);\n\t\t\tint n=scan.nextInt();\n\t\t\tint k=scan.nextInt();\n\t\t\tString t=scan.next();\n\t\t\tint mx=0;\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tint gd=1;\n\t\t\t\tfor(int j=0;j<i;j++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif(t.charAt(j)!=t.charAt((n-i)+j))\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tgd=0;\n\t\t\t\t\t\t// i think i can break here\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(gd==1){\n\t\t\t\t\tmx=i;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(t);\n\t\t\tfor(int i=2;i<=k;i++)\n\t\t\t{\n\t\t\t\tfor(int j=mx;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(t.charAt(j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 481, "index": 481}
{"src": "\n// Java program to find \n// lexicographically \n// maximum value after \n// k swaps. \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nvoid\nSwapInts(\nint\narray[], \n\nint\nposition1, \n\nint\nposition2) \n\n{ \n\n// Swaps elements \n\n// in an array. \n\n\n// Copy the first \n\n// position's element \n\nint\ntemp = array[position1]; \n\n\n// Assign to the \n\n// second element \n\narray[position1] = array[position2]; \n\n\n// Assign to the \n\n// first element \n\narray[position2] = temp; \n\n} \n\n\n// Function which \n\n// modifies the array \n\nstatic\nvoid\nKSwapMaximum(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; \n\ni < n - \n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n// Here, indexPositionition \n\n// is set where we want to \n\n// put the current largest \n\n// integer \n\nint\nindexPosition = i; \n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\n\n// If we exceed the \n\n// Max swaps then \n\n// break the loop \n\nif\n(k <= j - i) \n\nbreak\n; \n\n\n// Find the maximum value \n\n// from i+1 to max k or n \n\n// which will replace \n\n// arr[indexPosition] \n\nif\n(arr[j] > arr[indexPosition]) \n\nindexPosition = j; \n\n} \n\n\n// Swap the elements from \n\n// Maximum indexPosition \n\n// we found till now to \n\n// the ith index \n\nfor\n(\nint\nj = indexPosition; j > i; --j) \n\nSwapInts(arr, j, j - \n1\n); \n\n\n// Updates k after swapping \n\n// indexPosition-i elements \n\nk -= indexPosition - i; \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = { \n3\n, \n5\n, \n4\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nKSwapMaximum(arr, n, k); \n\n\n// Print the final Array \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} \n\n// This code is contributed by \n// Manish Shaw(manishshaw1) ", "complexity": "quadratic", "from": "CorCod", "problem": 482, "index": 482}
{"src": "\n// Space optimized CPP implementation of \n// longest common substring. \nimport\njava.io.*; \nimport\njava.util.*; \n\npublic\nclass\nGFG { \n\n\n// Function to find longest \n\n// common substring. \n\nstatic\nint\nLCSubStr(String X, String Y) \n\n{ \n\n\n// Find length of both the strings. \n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\n// Variable to store length of longest \n\n// common substring. \n\nint\nresult = \n0\n; \n\n\n// Matrix to store result of two \n\n// consecutive rows at a time. \n\nint\n[][]len = \nnew\nint\n[\n2\n][n]; \n\n\n// Variable to represent which row of \n\n// matrix is current row. \n\nint\ncurrRow = \n0\n; \n\n\n// For a particular value of \n\n// i and j, len[currRow][j] \n\n// stores length of longest \n\n// common substring in string \n\n// X[0..i] and Y[0..j]. \n\nfor\n(\nint\ni = \n0\n; i < m; i++) { \n\nfor\n(\nint\nj = \n0\n; j < n; j++) { \n\nif\n(i == \n0\n|| j == \n0\n) { \n\nlen[currRow][j] = \n0\n; \n\n} \n\nelse\nif\n(X.charAt(i - \n1\n) == \n\nY.charAt(j - \n1\n)) \n\n{ \n\nlen[currRow][j] = \n\nlen[(\n1\n- currRow)][(j - \n1\n)] \n\n+ \n1\n; \n\nresult = Math.max(result, \n\nlen[currRow][j]); \n\n} \n\nelse\n\n{ \n\nlen[currRow][j] = \n0\n; \n\n} \n\n} \n\n\n// Make current row as previous \n\n// row and previous row as \n\n// new current row. \n\ncurrRow = \n1\n- currRow; \n\n} \n\n\nreturn\nresult; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString X = \n\"GeeksforGeeks\"\n; \n\nString Y = \n\"GeeksQuiz\"\n; \n\n\nSystem.out.print(LCSubStr(X, Y)); \n\n} \n} \n\n// This code is contributed by \n// Manish Shaw (manishshaw1) ", "complexity": "quadratic", "from": "CorCod", "problem": 483, "index": 483}
{"src": "\n// Java program to rotate an array by \n// d elements \n\nclass\nRotateArray { \n\n/*Function to left rotate arr[] of size n by d*/\n\nvoid\nleftRotate(\nint\narr[], \nint\nd, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < d; i++) \n\nleftRotatebyOne(arr, n); \n\n} \n\n\nvoid\nleftRotatebyOne(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, temp; \n\ntemp = arr[\n0\n]; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\narr[i] = arr[i + \n1\n]; \n\narr[i] = temp; \n\n} \n\n\n/* utility function to print an array */\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRotateArray rotate = \nnew\nRotateArray(); \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nrotate.leftRotate(arr, \n2\n, \n7\n); \n\nrotate.printArray(arr, \n7\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "quadratic", "from": "CorCod", "problem": 484, "index": 484}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            int inv = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (a[j] > a[i]) {\n                        inv++;\n                    }\n                }\n            }\n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int l = in.nextInt();\n                int r = in.nextInt();\n                int s = (r - l + 1) * (r - l) / 2;\n                inv = (inv + s) % 2;\n                out.println(inv % 2 == 0 ? \"even\" : \"odd\");\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String next() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "from": "CorCod", "problem": 485, "index": 485}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n    int[][] fast(int n, int m){\n\n        int[][] ans = new int[2][n * m];\n        int c = 0;\n\n        for (int left = 1, right = m; left < right; left++, right--) {\n            for (int l = 1, r = n; l <= n && r >= 1; l++, r--) {\n                ans[0][c] = l;\n                ans[1][c++] = left;\n\n                ans[0][c] = r;\n                ans[1][c++] = right;\n            }\n        }\n\n        if (m % 2 == 1) {\n            int x = m/2 + 1;\n            for(int l = 1, r = n;l < r;l++, r--){\n                ans[0][c] = l;\n                ans[1][c++] = x;\n\n                ans[0][c] = r;\n                ans[1][c++] = x;\n                    if(n % 2 == 1 && l + 2 == r){\n                        ans[0][c] = l+1;\n                        ans[1][c++] = x;\n                    }\n            }\n        }\n\n        if(n == 1 && m % 2 == 1){\n            ans[0][c] = 1;\n            ans[1][c] = m/2 + 1;\n        }\n\n        return ans;\n    }\n\n    void stress(){\n\n        for(int i = 3;i<=5;i++){\n            for(int j = 2;j<=5;j++){\n                int[][] ans = new int[2][];\n                try{\n                    ans = fast(i, j);\n                }catch(Exception e){\n                    out.println(\"\u043e\u0448\u0438\u0431\u043a\u0430\");\n                    out.print(i + \" \" + j);\n                    return;\n                }\n\n                boolean[][] check = new boolean[i][j];\n                for(int c = 0;c<ans[0].length;c++){\n                    int x = ans[0][c] - 1;\n                    int y = ans[1][c] - 1;\n                    check[x][y] = true;\n                }\n\n                for(int c = 0;c<i;c++){\n                    for(int q = 0;q<j;q++){\n                        if(!check[c][q]){\n                            out.println(i + \" \" + j);\n                            out.println(\"\u0442\u043e\u0447\u043a\u0438\");\n                            for(int w = 0;w<ans[0].length;w++){\n                                out.println(ans[0][w] + \" \" + ans[1][w]);\n                            }\n                            return;\n                        }\n                    }\n                }\n\n                HashSet<String> set = new HashSet<>();\n                for(int c = 1;c<ans[0].length;c++){\n                    int x = ans[0][c] - ans[0][c- 1];\n                    int y = ans[1][c] - ans[1][c - 1];\n                    set.add(x + \" \" + y);\n                }\n\n                if(set.size() < i * j - 1){\n                    out.println(i + \" \" + j);\n                    out.println(\"\u0432\u0435\u043a\u0442\u043e\u0440\u0430\");\n                    for(int w = 0;w<ans[0].length;w++){\n                        out.println(ans[0][w] + \" \" + ans[1][w]);\n                    }\n                    return;\n                }\n            }\n        }\n    }\n\n    void normal(){\n        int n =readInt();\n        int m = readInt();\n        int[][] ans = fast(n, m);\n        for(int i = 0;i<ans[0].length;i++){\n            out.println(ans[0][i] + \" \" + ans[1][i]);\n        }\n    }\n\n    boolean stress = false;\n    void solve(){\n        if(stress) stress();\n        else normal();\n    }\n\n    public static void main(String[] args) {\n        new D().run();\n    }\n\n    void run(){\n        init();\n        solve();\n        out.close();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init(){\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out  = new PrintWriter(System.out);\n    }\n\n    String readLine(){\n        try{\n            return in.readLine();\n        }catch(Exception ex){\n            throw new RuntimeException(ex);\n        }\n    }\n    String readString(){\n        while(!tok.hasMoreTokens()){\n            String nextLine = readLine();\n            if(nextLine == null) return null;\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt(){\n        return Integer.parseInt(readString());\n    }\n\n    long readLong(){\n        return Long.parseLong(readString());\n    }\n\n    double readDouble(){\n        return Double.parseDouble(readString());\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 486, "index": 486}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class java2 {\n    public static void main(String[] args) {\n        Scanner r = new Scanner(System.in);\n        int n=r.nextInt();\n        int []l=new int[1005];\n        int []ri=new int[1005];\n        int []candy=new int[1005];\n        for(int i=1;i<=n;++i)\n        {\n            l[i]=r.nextInt();\n        }\n        for(int i=1;i<=n;++i)\n        {\n            ri[i]=r.nextInt();\n        }\n        for(int i=1;i<=n;++i)\n        {\n            if(l[i]>i-1||ri[i]>n-i)\n            {\n                System.out.println(\"NO\");\n                System.exit(0);\n            }\n            candy[i]=n-l[i]-ri[i];\n        }\n        for(int i=1;i<=n;++i)\n        {\n            int left=0,right=0;\n            for(int j=1;j<=i-1;++j)\n            {\n                if(candy[j]>candy[i])\n                {\n                    ++left;\n                }\n            }\n            for(int j=i+1;j<=n;++j)\n            {\n                if(candy[j]>candy[i])\n                {\n                    ++right;\n                }\n            }\n            if(left!=l[i]||right!=ri[i])\n            {\n                System.out.println(\"NO\");\n                System.exit(0);\n            }\n        }\n        System.out.println(\"YES\");\n        for(int i=1;i<=n;++i)\n        {\n            System.out.print(candy[i]+\" \");\n        }\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 487, "index": 487}
{"src": "import java.util.Scanner;\n\npublic class Amain {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[] = new int[100005];\n\t\tint vis[] = new int[100005];\n\t\tint maxx = -1;\n\t\tint n , k ;\n\t\tint e = 0  , s = 0 ;\n\t\tint ans = 0  ;\n\t\t\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\n\t\tfor(int i = 1 ; i<=n ; i++ )\n\t\t{\n\t\t\ta[i]=sc.nextInt() ;\n\t\t\tif(a[i]== 1 )\n\t\t\t{\n\t\t\t\te++ ; //\u8bb0\u5f55\u5e26\u6709test\u6807\u7b7e\u7684\u7f51\u9875\u4e2a\u6570 ; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts++ ;// \u8bb0\u5f55\u5e26\u6709\u793e\u4ea4\u6807\u7b7e\u7684\u7f51\u7ad9\u4e2a\u6570; \n\t\t\t}\n\t\t}\n\t    // \u9898\u76ee\u4e2d\u7684  c=b+i\u22c5k \u5927\u6982\u5c31\u662f\u6bcf\u9694 k \u7684\u5c31\u5173\u4e00\u4e2a\u7f51\u9875 \n\t\tfor(int i = 1 ; i<=k  ;i++ )\n\t\t{\n\t\t\tint e1 = 0 ; // \u8bb0\u5f55\u5e94\u8be5\u5173\u95ed\u7684\u5e26\u6709test\u6807\u7b7e\u7684\u7f51\u9875\u4e2a\u6570 \n\t\t\tint s1 = 0 ;  // \u8bb0\u5f55\u5e94\u8be5\u5173\u95ed\u7684\u5e26\u6709\u793e\u4ea4\u6807\u7b7e\u7684\u7f51\u9875\u4e2a\u6570\n\t\t\tfor(int j = i ; j<=n ;j+=k )\n\t\t\t{\n\t\t\t\tif(a[j]==1 )\n\t\t\t\t{\n\t\t\t\t\te1++ ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1++ ;\n\t\t\t\t}\n\t\t\t}\n\t        // s-s1 \u5c31\u662f\u8fd8\u5269\u7684\u5e26\u6709\u793e\u4ea4\u6807\u7b7e\u7684\u7f51\u9875\u4e2a\u6570;\n\t        // e-e1 \u5c31\u662f\u8fd8\u5269\u7684\u5e26\u6709test\u6807\u7b7e\u7684\u7f51\u9875\u4e2a\u6570; \n\t \n\t\t\tans = Math.abs(  (s-s1)-(e-e1)) ; // | s -e |\n\t\t\tmaxx = Math.max(maxx,ans) ; // \u6c42\u6700\u5927\u7684\n\t\t}\n       System.out.print(maxx);\n\t}\n\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 488, "index": 488}
{"src": "\n\n// Java program to convert an arbitrary binary tree to a tree that holds \n// children sum property \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n/* This function changes a tree to hold children sum \n\nproperty */\n\n\nvoid\nconvertTree(Node node) \n\n{ \n\nint\nleft_data = \n0\n, right_data = \n0\n, diff; \n\n\n/* If tree is empty or it's a leaf node then \n\nreturn true */\n\nif\n(node == \nnull\n\n|| (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n; \n\nelse\n\n{ \n\n/* convert left and right subtrees */\n\nconvertTree(node.left); \n\nconvertTree(node.right); \n\n\n/* If left child is not present then 0 is used \n\nas data of left child */\n\nif\n(node.left != \nnull\n) \n\nleft_data = node.left.data; \n\n\n/* If right child is not present then 0 is used \n\nas data of right child */\n\nif\n(node.right != \nnull\n) \n\nright_data = node.right.data; \n\n\n/* get the diff of node's data and children sum */\n\ndiff = left_data + right_data - node.data; \n\n\n/* If node's children sum is greater than the node's data */\n\nif\n(diff > \n0\n) \n\nnode.data = node.data + diff; \n\n\n/* THIS IS TRICKY --> If node's data is greater than children \n\nsum, then increment subtree by diff */\n\nif\n(diff < \n0\n) \n\n\n// -diff is used to make diff positive \n\nincrement(node, -diff); \n\n} \n\n} \n\n\n/* This function is used to increment subtree by diff */\n\nvoid\nincrement(Node node, \nint\ndiff) \n\n{ \n\n/* IF left child is not NULL then increment it */\n\nif\n(node.left != \nnull\n) \n\n{ \n\nnode.left.data = node.left.data + diff; \n\n\n// Recursively call to fix the descendants of node->left \n\nincrement(node.left, diff); \n\n} \n\nelse\nif\n(node.right != \nnull\n) \n// Else increment right child \n\n{ \n\nnode.right.data = node.right.data + diff; \n\n\n// Recursively call to fix the descendants of node->right \n\nincrement(node.right, diff); \n\n} \n\n} \n\n\n/* Given a binary tree, printInorder() prints out its \n\ninorder traversal*/\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first recur on left child */\n\nprintInorder(node.left); \n\n\n/* then print the data of node */\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n/* now recur on right child */\n\nprintInorder(node.right); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n50\n); \n\ntree.root.left = \nnew\nNode(\n7\n); \n\ntree.root.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n1\n); \n\ntree.root.right.right = \nnew\nNode(\n30\n); \n\n\nSystem.out.println(\n\"Inorder traversal before conversion is :\"\n); \n\ntree.printInorder(tree.root); \n\n\ntree.convertTree(tree.root); \n\nSystem.out.println(\n\"\"\n); \n\n\nSystem.out.println(\n\"Inorder traversal after conversion is :\"\n); \n\ntree.printInorder(tree.root); \n\n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "quadratic", "from": "CorCod", "problem": 489, "index": 489}
{"src": "import java.util.*;\npublic class TestClass\n{\n   public static void main(String args[])\n   {\n   \tScanner in = new Scanner(System.in);\n   \tint n = in.nextInt();\n   \tint m = in.nextInt();\n   \tint k = in.nextInt();\n   \tint arr[] = new int[n+1];\n   \tfor(int i =0;i<n;i++)\n   \t arr[i+1]= in.nextInt();\n   \t\n   \tlong sum[] = new long [n+1];\n   \t\n   \tfor(int i=1;i<=n;i++)\n   \t sum[i]=sum[i-1]+arr[i];\n   \t\n    long dp[] = new long[n+1];\n\n    for(int i =1;i<=n;i++)\n    {\n      for(int j=i;j>i-m&&j>=1;j--)\n      {\n        long val = sum[i]-sum[j-1]+dp[j-1]-k;\n        dp[i]= Math.max(dp[i],val);\n      }\t\n    }\n    long max =0;\n    for(int i =1;i<=n;i++)\n     max=Math.max(max,dp[i]);\n    \n    System.out.println(max);\n     \n   }\t\n}", "complexity": "quadratic", "from": "CorCod", "problem": 490, "index": 490}
{"src": "\n// Java code for Dynamic Programming based \n// solution that uses table P[][] to \n// calculate the Permutation Coefficient \nimport\njava.io.*; \nimport\njava.math.*; \n\nclass\nGFG \n{ \n\n\n// Returns value of Permutation \n\n// Coefficient P(n, k) \n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nP[][] = \nnew\nint\n[n + \n2\n][k + \n2\n]; \n\n\n// Caculate value of Permutation \n\n// Coefficient in bottom up manner \n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; \n\nj <= Math.min(i, k); \n\nj++) \n\n{ \n\n// Base Cases \n\nif\n(j == \n0\n) \n\nP[i][j] = \n1\n; \n\n\n// Calculate value using previosly \n\n// stored values \n\nelse\n\nP[i][j] = P[i - \n1\n][j] + \n\n(j * P[i - \n1\n][j - \n1\n]); \n\n\n// This step is important \n\n// as P(i,j)=0 for j>i \n\nP[i][j + \n1\n] = \n0\n; \n\n} \n\n} \n\nreturn\nP[n][k]; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ k +\n\")\"\n+ \n\n\" is \"\n+ permutationCoeff(n, k) ); \n\n} \n} \n\n// This code is contributed by Nikita Tiwari. ", "complexity": "quadratic", "from": "CorCod", "problem": 491, "index": 491}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n    \n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    public static void main(String args[] ) {\n        \n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] arr = new int[105];\n        \n        for(int i=0;i<m;i++){\n            int a = sc.nextInt();\n            arr[a]++;\n        }\n        \n        for(int i=1;i<=1000;i++){\n            int sum=0;\n            \n            for(int a:arr){\n                if(a!=0){\n                    sum+=(a/i);\n                }\n            }\n            \n            \n            if(sum<n){\n                System.out.println(i-1);\n                return;\n            }\n            \n        }\n    }\n\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 492, "index": 492}
{"src": "\n// Java code to Count Palindromic Subsequence \n// in a given String \npublic\nclass\nGFG \n{ \n\n// Function return the total palindromic \n\n// subsequence \n\nstatic\nint\ncountPS(String str) \n\n{ \n\nint\nN = str.length(); \n\n\n// create a 2D array to store the count \n\n// of palindromic subsequence \n\nint\n[][] cps = \nnew\nint\n[N+\n1\n][N+\n1\n]; \n\n\n// palindromic subsequence of length 1 \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ncps[i][i] = \n1\n; \n\n\n// check subsequence of length L is \n\n// palindrome or not \n\nfor\n(\nint\nL=\n2\n; L<=N; L++) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nint\nk = L + i - \n1\n; \n\nif\n(k < N){ \n\nif\n(str.charAt(i) == str.charAt(k)) \n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] + \n1\n; \n\nelse\n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] - \n\ncps[i+\n1\n][k-\n1\n]; \n\n} \n\n} \n\n} \n\n\n// return total palindromic subsequence \n\nreturn\ncps[\n0\n][N-\n1\n]; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"abcb\"\n; \n\nSystem.out.println(\n\"Total palindromic \"\n+ \n\n\"subsequence are : \"\n\n+ countPS(str)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "quadratic", "from": "CorCod", "problem": 493, "index": 493}
{"src": "\n// A recursive java program to print reverse level order traversal \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* Function to print REVERSE level order traversal a tree*/\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\nfor\n(i = h; i >= \n1\n; i--) \n\n//THE ONLY LINE DIFFERENT FROM NORMAL LEVEL ORDER \n\n{ \n\nprintGivenLevel(node, i); \n\n} \n\n} \n\n\n/* Print nodes at a given level */\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) \n\n{ \n\nprintGivenLevel(node.left, level - \n1\n); \n\nprintGivenLevel(node.right, level - \n1\n); \n\n} \n\n} \n\n\n/* Compute the \"height\" of a tree -- the number of \n\nnodes along the longest path from the root node \n\ndown to the farthest leaf node.*/\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n\n{ \n\n/* compute the height of each subtree */\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n/* use the larger one */\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n// Let us create trees shown in above diagram \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is : \"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "quadratic", "from": "CorCod", "problem": 494, "index": 494}
{"src": "\n// A simple Java program to \n//count pairs with difference k \nimport\njava.util.*; \nimport\njava.io.*; \n\nclass\nGFG { \n\n\nstatic\nint\ncountPairsWithDiffK(\nint\narr[], \n\nint\nn, \nint\nk) \n\n{ \n\nint\ncount = \n0\n; \n\n\n// Pick all elements one by one \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n// See if there is a pair \n\n// of this picked element \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] - arr[j] == k || \n\narr[j] - arr[i] == k) \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n5\n, \n3\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Count of pairs with given diff is \"\n\n+ countPairsWithDiffK(arr, n, k)); \n\n} \n} \n\n// This code is contributed \n// by Sahil_Bansall ", "complexity": "quadratic", "from": "CorCod", "problem": 495, "index": 495}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskG solver = new TaskG();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG {\n        static final long MODULO = (long) 1e9 + 7;\n        static final long BIG = Long.MAX_VALUE - Long.MAX_VALUE % MODULO;\n        static final int[] ONE = new int[]{1};\n        int k;\n        int n;\n        long[] globalRes;\n        int[] p2;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            k = in.nextInt();\n            globalRes = new long[k + 1];\n            p2 = new int[n + 1];\n            p2[0] = 1;\n            for (int i = 1; i <= n; ++i) p2[i] = (int) (2 * p2[i - 1] % MODULO);\n            Vertex[] vs = new Vertex[n];\n            for (int i = 0; i < n; ++i) vs[i] = new Vertex();\n            for (int i = 0; i < n - 1; ++i) {\n                Vertex a = vs[in.nextInt() - 1];\n                Vertex b = vs[in.nextInt() - 1];\n                a.adj.add(b);\n                b.adj.add(a);\n            }\n            vs[0].dfs(null);\n            long[][] ways = new long[k + 1][k + 1];\n            ways[0][0] = 1;\n            for (int i = 1; i <= k; ++i) {\n                for (int j = 1; j <= k; ++j) {\n                    ways[i][j] = j * (ways[i - 1][j] + ways[i - 1][j - 1]) % MODULO;\n                }\n            }\n            long sum = 0;\n            for (int i = 1; i <= k; ++i) {\n                long s = globalRes[i];\n                s %= MODULO;\n                sum = (sum + s * ways[k][i]) % MODULO;\n            }\n            out.println(sum);\n        }\n\n        class Vertex {\n            int[] res;\n            int subtreeSize;\n            List<Vertex> adj = new ArrayList<>();\n\n            public void dfs(Vertex parent) {\n                subtreeSize = 1;\n                int[] prod = ONE;\n                for (Vertex child : adj)\n                    if (child != parent) {\n                        child.dfs(this);\n                        subtreeSize += child.subtreeSize;\n                    }\n                int mult = 2;//p2[n - subtreeSize];\n                for (Vertex child : adj)\n                    if (child != parent) {\n                        int[] c = child.res;\n                        prod = mul(prod, c);\n                        subFrom(globalRes, c, 1);\n                    }\n                addTo(globalRes, prod, mult);\n                res = insertEdge(prod);\n            }\n\n            private int[] insertEdge(int[] a) {\n                int len = a.length + 1;\n                if (len > k) len = k + 1;\n                int[] b = new int[len];\n                b[0] = a[0] * 2;\n                if (b[0] >= MODULO) b[0] -= MODULO;\n                for (int i = 1; i < len; ++i) {\n                    long s = a[i - 1];\n                    if (i < a.length) s += a[i];\n                    if (s >= MODULO) s -= MODULO;\n                    s = s * 2;\n                    if (s >= MODULO) s -= MODULO;\n                    b[i] = (int) s;\n                }\n                b[1] -= 1;\n                if (b[1] < 0) b[1] += MODULO;\n                return b;\n            }\n\n            private void addTo(long[] a, int[] b, int mult) {\n                for (int i = 0; i < b.length; ++i) {\n                    long s = a[i] + b[i] * (long) mult;\n                    if (s < 0) s -= BIG;\n                    a[i] = s;\n                }\n            }\n\n            private void subFrom(long[] a, int[] b, int mult) {\n                for (int i = 0; i < b.length; ++i) {\n                    long s = a[i] + (MODULO - b[i]) * (long) mult;\n                    if (s < 0) s -= BIG;\n                    a[i] = s;\n                }\n            }\n\n            private int[] mul(int[] a, int[] b) {\n                int len = a.length + b.length - 1;\n                if (len > k) len = k + 1;\n                int[] c = new int[len];\n                for (int i = 0; i < len; ++i) {\n                    long s = 0;\n                    int left = Math.max(0, i - (b.length - 1));\n                    int right = Math.min(a.length - 1, i);\n                    for (int ia = left; ia <= right; ++ia) {\n                        int ib = i - ia;\n                        s += a[ia] * (long) b[ib];\n                        if (s < 0) s -= BIG;\n                    }\n                    c[i] = (int) (s % MODULO);\n                }\n                return c;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "from": "CorCod", "problem": 496, "index": 496}
{"src": "\n// A Dynamic Programming based Java program to find minimum \n// number operations to convert str1 to str2 \nclass\nEDIST \n{ \n\nstatic\nint\nmin(\nint\nx,\nint\ny,\nint\nz) \n\n{ \n\nif\n(x <= y && x <= z) \nreturn\nx; \n\nif\n(y <= x && y <= z) \nreturn\ny; \n\nelse\nreturn\nz; \n\n} \n\n\nstatic\nint\neditDistDP(String str1, String str2, \nint\nm, \nint\nn) \n\n{ \n\n// Create a table to store results of subproblems \n\nint\ndp[][] = \nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\n// Fill d[][] in bottom up manner \n\nfor\n(\nint\ni=\n0\n; i<=m; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<=n; j++) \n\n{ \n\n// If first string is empty, only option is to \n\n// insert all characters of second string \n\nif\n(i==\n0\n) \n\ndp[i][j] = j; \n// Min. operations = j \n\n\n// If second string is empty, only option is to \n\n// remove all characters of second string \n\nelse\nif\n(j==\n0\n) \n\ndp[i][j] = i; \n// Min. operations = i \n\n\n// If last characters are same, ignore last char \n\n// and recur for remaining string \n\nelse\nif\n(str1.charAt(i-\n1\n) == str2.charAt(j-\n1\n)) \n\ndp[i][j] = dp[i-\n1\n][j-\n1\n]; \n\n\n// If the last character is different, consider all \n\n// possibilities and find the minimum \n\nelse\n\ndp[i][j] = \n1\n+ min(dp[i][j-\n1\n], \n// Insert \n\ndp[i-\n1\n][j], \n// Remove \n\ndp[i-\n1\n][j-\n1\n]); \n// Replace \n\n} \n\n} \n\n\nreturn\ndp[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str1 = \n\"sunday\"\n; \n\nString str2 = \n\"saturday\"\n; \n\nSystem.out.println( editDistDP( str1 , str2 , str1.length(), str2.length()) ); \n\n} \n}\n/*This code is contributed by Rajat Mishra*/", "complexity": "quadratic", "from": "CorCod", "problem": 497, "index": 497}
{"src": "\n// Java program to find Majority \n// element in an array \n\nimport\njava.io.*; \n\nclass\nGFG { \n\n// Function to find Majority element \n// in an array \nstatic\nvoid\nfindMajority(\nint\narr[], \nint\nn) \n{ \n\nint\nmaxCount = \n0\n; \n\nint\nindex = -\n1\n; \n// sentinels \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(arr[i] == arr[j]) \n\ncount++; \n\n} \n\n\n// update maxCount if count of \n\n// current element is greater \n\nif\n(count > maxCount) \n\n{ \n\nmaxCount = count; \n\nindex = i; \n\n} \n\n} \n\n\n// if maxCount is greater than n/2 \n\n// return the corresponding element \n\nif\n(maxCount > n/\n2\n) \n\nSystem.out.println (arr[index]); \n\n\nelse\n\nSystem.out.println (\n\"No Majority Element\"\n); \n} \n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n1\n, \n1\n, \n2\n, \n1\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n// Function calling \n\nfindMajority(arr, n); \n\n} \n//This code is contributed by ajit. \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 498, "index": 498}
{"src": "import java.util.Scanner;\npublic class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "complexity": "quadratic", "from": "CorCod", "problem": 499, "index": 499}
{"src": "\nimport\njava.util.Arrays; \n\n// Java program to find the largest \n// subset which where each pair \n// is divisible. \nclass\nGFG { \n\n\n// function to find the longest Subsequence \n\nstatic\nint\nlargestSubset(\nint\n[] a, \nint\nn) \n\n{ \n\n// Sort array in increasing order \n\nArrays.sort(a); \n\n\n// dp[i] is going to store size of largest \n\n// divisible subset beginning with a[i]. \n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n// Since last element is largest, d[n-1] is 1 \n\ndp[n - \n1\n] = \n1\n; \n\n\n// Fill values for smaller elements. \n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) { \n\n\n// Find all multiples of a[i] and consider \n\n// the multiple that has largest subset \n\n// beginning with it. \n\nint\nmxm = \n0\n; \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) { \n\nif\n(a[j] % a[i] == \n0\n) { \n\nmxm = Math.max(mxm, dp[j]); \n\n} \n\n} \n\n\ndp[i] = \n1\n+ mxm; \n\n} \n\n\n// Return maximum value from dp[] \n\nreturn\nArrays.stream(dp).max().getAsInt(); \n\n} \n\n\n// driver code to check the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] a = { \n1\n, \n3\n, \n6\n, \n13\n, \n17\n, \n18\n}; \n\nint\nn = a.length; \n\nSystem.out.println(largestSubset(a, n)); \n\n} \n} \n\n/* This JAVA code is contributed by Rajput-Ji*/", "complexity": "quadratic", "from": "CorCod", "problem": 500, "index": 500}
{"src": "\n// Java implementation for brute force method to calculate stock span values \n\nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n// method to calculate stock span values \n\nstatic\nvoid\ncalculateSpan(\nint\nprice[], \nint\nn, \nint\nS[]) \n\n{ \n\n// Span value of first day is always 1 \n\nS[\n0\n] = \n1\n; \n\n\n// Calculate span value of remaining days by linearly checking \n\n// previous days \n\nfor\n(\nint\ni = \n1\n; i < n; i++) { \n\nS[i] = \n1\n; \n// Initialize span value \n\n\n// Traverse left while the next element on left is smaller \n\n// than price[i] \n\nfor\n(\nint\nj = i - \n1\n; (j >= \n0\n) && (price[i] >= price[j]); j--) \n\nS[i]++; \n\n} \n\n} \n\n\n// A utility function to print elements of array \n\nstatic\nvoid\nprintArray(\nint\narr[]) \n\n{ \n\nSystem.out.print(Arrays.toString(arr)); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nprice[] = { \n10\n, \n4\n, \n5\n, \n90\n, \n120\n, \n80\n}; \n\nint\nn = price.length; \n\nint\nS[] = \nnew\nint\n[n]; \n\n\n// Fill the span values in array S[] \n\ncalculateSpan(price, n, S); \n\n\n// print the calculated span values \n\nprintArray(S); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "quadratic", "from": "CorCod", "problem": 501, "index": 501}
{"src": "\n// Java program to Rearrange positive and negative \n// numbers in a array \nclass\nGFG { \n\n\n/* Function to print an array */\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n; \n\n} \n\n\n/* Function to reverse an array. An array can be \nreversed in O(n) time and O(1) space. */\n\nstatic\nvoid\nreverse(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\narr = swap(arr, l, r); \n\nreverse(arr, ++l, --r); \n\n} \n\n} \n\n\n// Merges two subarrays of arr[]. \n\n// First subarray is arr[l..m] \n\n// Second subarray is arr[m+1..r] \n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni = l; \n// Initial index of 1st subarray \n\nint\nj = m + \n1\n; \n// Initial index of IInd \n\n\nwhile\n(i <= m && arr[i] < \n0\n) \n\ni++; \n\n\n// arr[i..m] is positive \n\n\nwhile\n(j <= r && arr[j] < \n0\n) \n\nj++; \n\n\n// arr[j..r] is positive \n\n\n// reverse positive part of \n\n// left sub-array (arr[i..m]) \n\nreverse(arr, i, m); \n\n\n// reverse negative part of \n\n// right sub-array (arr[m+1..j-1]) \n\nreverse(arr, m + \n1\n, j - \n1\n); \n\n\n// reverse arr[i..j-1] \n\nreverse(arr, i, j - \n1\n); \n\n} \n\n\n// Function to Rearrange positive and negative \n\n// numbers in a array \n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n// Same as (l+r)/2, but avoids overflow for \n\n// large l and h \n\nint\nm = l + (r - l) / \n2\n; \n\n\n// Sort first and second halves \n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\nstatic\nint\n[] swap(\nint\n[] arr, \nint\ni, \nint\nj) \n\n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n\n} \n\n\n/* Driver code*/\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\n\nprintArray(arr, arr_size); \n\n} \n} \n\n// This code has been contributed by 29AjayKumar ", "complexity": "quadratic", "from": "CorCod", "problem": 502, "index": 502}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n    private void solve() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n\n        int n = nextInt(), m = nextInt(), u = 1, d = n;\n\n        while (u < d) {\n            for (int i = 1; i <= m; i++) {\n                out.println(u + \" \" + i);\n                out.println(d + \" \" + (m - i + 1));\n            }\n            u++;\n            d--;\n        }\n        if (u == d) {\n            int l = 1, r = m;\n            while (l < r) {\n                out.println(u + \" \" + l++);\n                out.println(d + \" \" + r--);\n            }\n            if (l == r) out.println(u + \" \" + l);\n        }\n\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new D().solve();\n    }\n\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter out;\n\n    private String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return st.nextToken();\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    private long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    private double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 503, "index": 503}
{"src": "\n// Java program to Rearrange positive \n// and negative numbers in a array \nimport\njava.io.*; \n\nclass\nGFG { \n\n/* Function to print an array */\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(); \n\n} \n\n\n// Merges two subarrays of arr[]. \n\n// First subarray is arr[l..m] \n\n// Second subarray is arr[m+1..r] \n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni, j, k; \n\nint\nn1 = m - l + \n1\n; \n\nint\nn2 = r - m; \n\n\n/* create temp arrays */\n\nint\nL[] = \nnew\nint\n[n1]; \n\nint\nR[] = \nnew\nint\n[n2]; \n\n\n/* Copy data to temp arrays L[] and R[] */\n\nfor\n(i = \n0\n; i < n1; i++) \n\nL[i] = arr[l + i]; \n\nfor\n(j = \n0\n; j < n2; j++) \n\nR[j] = arr[m + \n1\n+ j]; \n\n\n/* Merge the temp arrays back into arr[l..r]*/\n\n// Initial index of first subarray \n\ni = \n0\n; \n\n\n// Initial index of second subarray \n\nj = \n0\n; \n\n\n// Initial index of merged subarray \n\nk = l; \n\n\n// Note the order of appearance of elements should \n\n// be maintained - we copy elements of left subarray \n\n// first followed by that of right subarray \n\n\n// copy negative elements of left subarray \n\nwhile\n(i < n1 && L[i] < \n0\n) \n\narr[k++] = L[i++]; \n\n\n// copy negative elements of right subarray \n\nwhile\n(j < n2 && R[j] < \n0\n) \n\narr[k++] = R[j++]; \n\n\n// copy positive elements of left subarray \n\nwhile\n(i < n1) \n\narr[k++] = L[i++]; \n\n\n// copy positive elements of right subarray \n\nwhile\n(j < n2) \n\narr[k++] = R[j++]; \n\n} \n\n\n// Function to Rearrange positive and negative \n\n// numbers in a array \n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n// Same as (l + r)/2, but avoids overflow for \n\n// large l and h \n\nint\nm = l + (r - l) / \n2\n; \n\n\n// Sort first and second halves \n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\nprintArray(arr, arr_size); \n\n} \n} \n\n// This code is contributed by vt_m. ", "complexity": "quadratic", "from": "CorCod", "problem": 504, "index": 504}
{"src": "\n// Java program to check if there is a subset \n// with sum divisible by m. \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n\n// Returns true if there is a subset \n\n// of arr[] with sum divisible by m \n\nstatic\nboolean\nmodularSum(\nint\narr[], \n\nint\nn, \nint\nm) \n\n{ \n\nif\n(n > m) \n\nreturn\ntrue\n; \n\n\n// This array will keep track of all \n\n// the possible sum (after modulo m) \n\n// which can be made using subsets of arr[] \n\n// initialising boolean array with all false \n\nboolean\nDP[]=\nnew\nboolean\n[m]; \n\n\nArrays.fill(DP, \nfalse\n); \n\n\n// we'll loop through all the elements \n\n// of arr[] \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n// anytime we encounter a sum divisible \n\n// by m, we are done \n\nif\n(DP[\n0\n]) \n\nreturn\ntrue\n; \n\n\n// To store all the new encountered sum \n\n// (after modulo). It is used to make \n\n// sure that arr[i] is added only to \n\n// those entries for which DP[j] \n\n// was true before current iteration. \n\nboolean\ntemp[] = \nnew\nboolean\n[m]; \n\nArrays.fill(temp, \nfalse\n); \n\n\n// For each element of arr[], we loop \n\n// through all elements of DP table \n\n// from 1 to m and we add current \n\n// element i. e., arr[i] to all those \n\n// elements which are true in DP table \n\nfor\n(\nint\nj = \n0\n; j < m; j++) \n\n{ \n\n\n// if an element is true in \n\n// DP table \n\nif\n(DP[j] == \ntrue\n) \n\n{ \n\nif\n(DP[(j + arr[i]) % m] == \nfalse\n) \n\n\n// We update it in temp and update \n\n// to DP once loop of j is over \n\ntemp[(j + arr[i]) % m] = \ntrue\n; \n\n} \n\n} \n\n\n// Updating all the elements of temp \n\n// to DP table since iteration over \n\n// j is over \n\nfor\n(\nint\nj = \n0\n; j < m; j++) \n\nif\n(temp[j]) \n\nDP[j] = \ntrue\n; \n\n\n\n// Also since arr[i] is a single \n\n// element subset, arr[i]%m is one \n\n// of the possible sum \n\nDP[arr[i] % m] = \ntrue\n; \n\n} \n\n\nreturn\nDP[\n0\n]; \n\n} \n\n\n//driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = {\n1\n, \n7\n}; \n\nint\nn = arr.length; \n\nint\nm = \n5\n; \n\n\nif\n(modularSum(arr, n, m)) \n\nSystem.out.print(\n\"YES\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"NO\\n\"\n); \n\n} \n} \n\n//This code is contributed by Anant Agarwal. ", "complexity": "quadratic", "from": "CorCod", "problem": 505, "index": 505}
{"src": "import java.util.*;\n\npublic class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 506, "index": 506}
{"src": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 507, "index": 507}
{"src": "\n// Java program to split array and move first \n// part to end. \nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nGFG { \n\n\n// Function to spilt array and \n\n// move first part to end \n\npublic\nstatic\nvoid\nSplitAndAdd(\nint\n[] A,\nint\nlength,\nint\nrotation){ \n\n\n//make a temporary array with double the size \n\nint\n[] tmp = \nnew\nint\n[length*\n2\n]; \n\n\n// copy array element in to new array twice \n\nSystem.arraycopy(A, \n0\n, tmp, \n0\n, length); \n\nSystem.arraycopy(A, \n0\n, tmp, length, length); \n\nfor\n(\nint\ni=rotation;i<rotation+length;i++) \n\nA[i-rotation]=tmp[i]; \n\n} \n\n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nSplitAndAdd(arr, n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 508, "index": 508}
{"src": "\n// Java program to count all substrings with same \n// first and last characters. \npublic\nclass\nGFG { \n\n\n// Returns true if first and last characters \n\n// of s are same. \n\nstatic\nboolean\ncheckEquality(String s) \n\n{ \n\nreturn\n(s.charAt(\n0\n) == s.charAt(s.length() - \n1\n)); \n\n} \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n// Starting point of substring \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n// Length of substring \n\nfor\n(\nint\nlen = \n1\n; len <= n-i; len++) \n\n\n// Check if current substring has same \n\n// starting and ending characters. \n\nif\n(checkEquality(s.substring(i, i + len))) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "quadratic", "from": "CorCod", "problem": 509, "index": 509}
{"src": "import java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Practice {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            String[] arr1 = new String[n];\n            String[] arr2 = new String[n];\n            for (int i = 0; i < n; i++) {\n                arr1[i] = in.next();\n            }\n            for (int i = 0; i < n; i++) {\n                arr2[i] = in.next();\n            }\n            int ans = 0;\n            boolean arr[]=new boolean[n];\n            boolean found=false;\n            for (int i = 0; i < arr1.length; i++) {\n                for(int j=0;j<arr1.length;j++){\n                    found=false;\n                    if(arr1[i].equals(arr2[j]) && !arr[j]){\n                        found=true;\n                        arr[j]=true;\n                        break;\n                    }\n                }\n                if(!found){\n                    ans++;\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    public static boolean checkPrime(int n, int p) {\n        for (int i = 2; i <= Math.sqrt(n) && i <= p; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void mergeArrays(int[] arr1, int[] arr2, int n1,\n            int n2, int[] arr3) {\n        int i = 0, j = 0, k = 0;\n        while (i < n1 && j < n2) {\n            if (arr1[i] < arr2[j]) {\n                arr3[k++] = arr1[i++];\n            } else {\n                arr3[k++] = arr2[j++];\n            }\n        }\n        while (i < n1) {\n            arr3[k++] = arr1[i++];\n        }\n        while (j < n2) {\n            arr3[k++] = arr2[j++];\n        }\n    }\n\n    public long GCD(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return GCD(b, a % b);\n    }\n\n    public static long nCr(int n, int r) {\n        return n * (n - 1) / 2;\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 510, "index": 510}
{"src": "\n// Java Solution \npublic\nclass\nLongestPalinSubstring \n{ \n\n// A utility function to print a substring str[low..high] \n\nstatic\nvoid\nprintSubStr(String str, \nint\nlow, \nint\nhigh) { \n\nSystem.out.println(str.substring(low, high + \n1\n)); \n\n} \n\n\n// This function prints the longest palindrome substring \n\n// of str[]. \n\n// It also returns the length of the longest palindrome \n\nstatic\nint\nlongestPalSubstr(String str) { \n\nint\nn = str.length(); \n// get length of input string \n\n\n// table[i][j] will be false if substring str[i..j] \n\n// is not palindrome. \n\n// Else table[i][j] will be true \n\nboolean\ntable[][] = \nnew\nboolean\n[n][n]; \n\n\n// All substrings of length 1 are palindromes \n\nint\nmaxLength = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\ntable[i][i] = \ntrue\n; \n\n\n// check for sub-string of length 2. \n\nint\nstart = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nif\n(str.charAt(i) == str.charAt(i + \n1\n)) { \n\ntable[i][i + \n1\n] = \ntrue\n; \n\nstart = i; \n\nmaxLength = \n2\n; \n\n} \n\n} \n\n\n// Check for lengths greater than 2. k is length \n\n// of substring \n\nfor\n(\nint\nk = \n3\n; k <= n; ++k) { \n\n\n// Fix the starting index \n\nfor\n(\nint\ni = \n0\n; i < n - k + \n1\n; ++i) \n\n{ \n\n// Get the ending index of substring from \n\n// starting index i and length k \n\nint\nj = i + k - \n1\n; \n\n\n// checking for sub-string from ith index to \n\n// jth index iff str.charAt(i+1) to \n\n// str.charAt(j-1) is a palindrome \n\nif\n(table[i + \n1\n][j - \n1\n] && str.charAt(i) == \n\nstr.charAt(j)) { \n\ntable[i][j] = \ntrue\n; \n\n\nif\n(k > maxLength) { \n\nstart = i; \n\nmaxLength = k; \n\n} \n\n} \n\n} \n\n} \n\nSystem.out.print(\n\"Longest palindrome substring is; \"\n); \n\nprintSubStr(str, start, start + maxLength - \n1\n); \n\n\nreturn\nmaxLength; \n// return length of LPS \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nString str = \n\"forgeeksskeegfor\"\n; \n\nSystem.out.println(\n\"Length is: \"\n+ \n\nlongestPalSubstr(str)); \n\n} \n} \n\n// This code is contributed by Sumit Ghosh ", "complexity": "quadratic", "from": "CorCod", "problem": 511, "index": 511}
{"src": "\n// JAVA Code for Dynamic Programming | \n// Set 9 (Binomial Coefficient) \nimport\njava.util.*; \n\nclass\nGFG { \n\n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[] = \nnew\nint\n[k + \n1\n]; \n\n\n// nC0 is 1 \n\nC[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\n// Compute next row of pascal \n\n// triangle using the previous row \n\nfor\n(\nint\nj = Math.min(i, k); j > \n0\n; j--) \n\nC[j] = C[j] + C[j-\n1\n]; \n\n} \n\nreturn\nC[k]; \n\n} \n\n\n/* Driver program */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.printf(\n\"Value of C(%d, %d) is %d \"\n\n, n, k, binomialCoeff(n, k)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 512, "index": 512}
{"src": "\n// Java program to find triplets in a given \n// array whose sum is zero \nimport\njava.util.Arrays; \nimport\njava.io.*; \n\nclass\nGFG { \n\n// function to print triplets with 0 sum \nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n{ \n\nboolean\nfound = \nfalse\n; \n\n\n// sort array elements \n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\n// initialize left and right \n\nint\nl = i + \n1\n; \n\nint\nr = n - \n1\n; \n\nint\nx = arr[i]; \n\nwhile\n(l < r) \n\n{ \n\nif\n(x + arr[l] + arr[r] == \n0\n) \n\n{ \n\n// print elements if it's sum is zero \n\nSystem.out.print(x + \n\" \"\n); \n\nSystem.out.print(arr[l]+ \n\" \"\n); \n\nSystem.out.println(arr[r]+ \n\" \"\n); \n\n\nl++; \n\nr--; \n\nfound = \ntrue\n; \n\n} \n\n\n// If sum of three elements is less \n\n// than zero then increment in left \n\nelse\nif\n(x + arr[l] + arr[r] < \n0\n) \n\nl++; \n\n\n// if sum is greater than zero than \n\n// decrement in right side \n\nelse\n\nr--; \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\nSystem.out.println(\n\" No Triplet Found\"\n); \n} \n\n// Driven source \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn =arr.length; \n\nfindTriplets(arr, n); \n\n} \n//This code is contributed by Tushil.. \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 513, "index": 513}
{"src": "\n// JAVA Code for Maximum size square \n// sub-matrix with all 1s \npublic\nclass\nGFG \n{ \n\n// method for Maximum size square sub-matrix with all 1s \n\nstatic\nvoid\nprintMaxSubSquare(\nint\nM[][]) \n\n{ \n\nint\ni,j; \n\nint\nR = M.length; \n//no of rows in M[][] \n\nint\nC = M[\n0\n].length; \n//no of columns in M[][] \n\nint\nS[][] = \nnew\nint\n[R][C]; \n\n\nint\nmax_of_s, max_i, max_j; \n\n\n/* Set first column of S[][]*/\n\nfor\n(i = \n0\n; i < R; i++) \n\nS[i][\n0\n] = M[i][\n0\n]; \n\n\n/* Set first row of S[][]*/\n\nfor\n(j = \n0\n; j < C; j++) \n\nS[\n0\n][j] = M[\n0\n][j]; \n\n\n/* Construct other entries of S[][]*/\n\nfor\n(i = \n1\n; i < R; i++) \n\n{ \n\nfor\n(j = \n1\n; j < C; j++) \n\n{ \n\nif\n(M[i][j] == \n1\n) \n\nS[i][j] = Math.min(S[i][j-\n1\n], \n\nMath.min(S[i-\n1\n][j], S[i-\n1\n][j-\n1\n])) + \n1\n; \n\nelse\n\nS[i][j] = \n0\n; \n\n} \n\n} \n\n\n/* Find the maximum entry, and indexes of maximum entry \n\nin S[][] */\n\nmax_of_s = S[\n0\n][\n0\n]; max_i = \n0\n; max_j = \n0\n; \n\nfor\n(i = \n0\n; i < R; i++) \n\n{ \n\nfor\n(j = \n0\n; j < C; j++) \n\n{ \n\nif\n(max_of_s < S[i][j]) \n\n{ \n\nmax_of_s = S[i][j]; \n\nmax_i = i; \n\nmax_j = j; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\"Maximum size sub-matrix is: \"\n); \n\nfor\n(i = max_i; i > max_i - max_of_s; i--) \n\n{ \n\nfor\n(j = max_j; j > max_j - max_of_s; j--) \n\n{ \n\nSystem.out.print(M[i][j] + \n\" \"\n); \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nM[][] = {{\n0\n, \n1\n, \n1\n, \n0\n, \n1\n}, \n\n{\n1\n, \n1\n, \n0\n, \n1\n, \n0\n}, \n\n{\n0\n, \n1\n, \n1\n, \n1\n, \n0\n}, \n\n{\n1\n, \n1\n, \n1\n, \n1\n, \n0\n}, \n\n{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{\n0\n, \n0\n, \n0\n, \n0\n, \n0\n}}; \n\n\nprintMaxSubSquare(M); \n\n} \n\n} ", "complexity": "quadratic", "from": "CorCod", "problem": 514, "index": 514}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.lang.*;\nimport java.math.*;\n \npublic class Main{\n\t\n\tstatic ArrayList a[]=new ArrayList[200001];\n\tstatic int Count(int a[][],int n) {\n\t\tdsu d=new dsu(n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tif(a[i][j]==0) {\n\t\t\t\t\td.union(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tboolean chk[]=new boolean [n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint p=d.root(i);\n\t\t\tif(!chk[p]) {\n\t\t\t\tchk[p]=true;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t    return cnt;\n\t}\n\tpublic void solve () {\n\t\tInputReader in = new InputReader(System.in);\n\t    PrintWriter pw = new PrintWriter(System.out); \n\t    int n=in.nextInt();\n\t    int a=in.nextInt();\n\t    int b=in.nextInt();\n\t    if(a==1 || b==1) {\n\t    \tint ans[][]=new int [n][n];\n\t    \tint temp=(a==1)?b:a;\n\t    \tfor(int i=1;i<=n-temp;i++) {\n\t    \t\tans[i][i-1]=1;\n\t    \t\tans[i-1][i]=1;\n\t    \t}\n\t    \tint freq=Count(ans,n);\n\t    \tif(freq!=1) {\n\t    \t\tpw.println(\"NO\");\n\t    \t}\n\t    \telse {\n\t    \t\tpw.println(\"YES\");\n\t    \t\tfor(int i=0;i<n;i++) {\n\t    \t\t\tfor(int j=0;j<n;j++) {\n\t    \t\t\t\tif(i==j) {\n\t    \t\t\t\t\tpw.print(0);\n\t    \t\t\t\t}\n\t    \t\t\t\telse\n\t    \t\t\t\t\tpw.print((ans[i][j]+((temp==b)?1:0))%2);\n\t    \t\t\t}\n\t    \t\t\tpw.println();\n\t    \t\t}\n\t    \t}\n\t    }\n\t    else {\n\t    \tpw.print(\"NO\");\n\t    }\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\tpublic static void main(String[] args) throws Exception {\n        \n        \n        new Thread(null,new Runnable() {\n        \tpublic void run() {\n        \t\tnew Main().solve();\n        \t}\n        },\"1\",1<<26).start();\n        \n        \n    }\n    static void debug(Object... o) {\n    \tSystem.out.println(Arrays.deepToString(o));\n        }\n        \n        static class InputReader \n        {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) \n        {\n            this.stream = stream;\n        }\n        public int snext() \n        {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) \n            {\n                curChar = 0;\n                try \n                {\n                    snumChars = stream.read(buf);\n                } \n                catch (IOException e) \n                {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int nextInt() \n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public long nextLong()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') \n            {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public int[] nextIntArray(int n) \n        {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) \n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n \n        public String readString()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public String nextLine() \n        {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) \n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        private boolean isEndOfLine(int c) \n        {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n        public static long mod = 1000000007;\n        public static int d;\n        public static int p;\n        public static int q;\n        public void extended(int a,int b) {\n        \tif(b==0) {\n        \t\td=a;\n        \t\tp=1;\n        \t\tq=0;\n        \t}\n        \telse\n        \t{\n        \t\textended(b,a%b);\n        \t\tint temp=p;\n        \t\tp=q;\n        \t\tq=temp-(a/b)*q;\n        \t}\n        }\n        public static long[] shuffle(long[] a,Random gen)\n        {\n            int n = a.length;\n            for(int i=0;i<n;i++)\n            {\n                int ind = gen.nextInt(n-i)+i;\n                long temp = a[ind];\n                a[ind] = a[i];\n                a[i] = temp;\n            }\n            return a;\n        }\n        \n        public static void swap(int a, int b){\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        public static HashSet<Integer> primeFactorization(int n)\n        {\n            HashSet<Integer> a =new HashSet<Integer>();\n            for(int i=2;i*i<=n;i++)\n            {\n                while(n%i==0)\n                {\n                    a.add(i);\n                    n/=i;\n                }\n            }\n            if(n!=1)\n                a.add(n);\n            return a;\n        }\n        \n        public static void sieve(boolean[] isPrime,int n)\n        {\n            for(int i=1;i<n;i++)\n                isPrime[i] = true;\n            \n            isPrime[0] = false;\n            isPrime[1] = false;\n            \n            for(int i=2;i*i<n;i++)\n            {\n                if(isPrime[i] == true)\n                {\n                    for(int j=(2*i);j<n;j+=i)\n                        isPrime[j] = false;\n                }\n            }\n        }\n        \n        public static int GCD(int a,int b)\n        {\n            if(b==0)\n                return a;\n            else\n                return GCD(b,a%b);\n        }\n        \n        static class pair implements Comparable<pair>\n        {\n            Integer x;\n            Long y;\n            pair(int x,long y)\n            {\n                this.x=x;\n                this.y=y;\n                \n            }\n            \n           \n            public int compareTo(pair o) {\n                int result = x.compareTo(o.x);\n                if(result==0)\n                    result = y.compareTo(o.y);\n                \n                return result;\n            }  \n            \n            public String toString()\n            {\n                return x+\" \"+y;\n            }\n            \n            public boolean equals(Object o)\n            {\n                if (o instanceof pair)\n                {\n                    pair p = (pair)o;\n                    return p.x == x && p.y == y ;\n                }\n                return false;\n            }\n            \n            public int hashCode()\n            {\n                return new Long(x).hashCode()*31 + new Long(y).hashCode();\n            }\n        }\n        \n    \n}\nclass pair implements Comparable<pair>\n{\n    Integer x;\n    Long y;\n    pair(int x,long y)\n    {\n        this.x=x;\n        this.y=y;\n        \n    }\n    \n   \n    public int compareTo(pair o) {\n        int result = x.compareTo(o.x);\n        if(result==0)\n            result = y.compareTo(o.y);\n        \n        return result;\n    }  \n    \n    public String toString()\n    {\n        return x+\" \"+y;\n    }\n    \n    public boolean equals(Object o)\n    {\n        if (o instanceof pair)\n        {\n            pair p = (pair)o;\n            return p.x == x && p.y == y ;\n        }\n        return false;\n    }\n    \n    public int hashCode()\n    {\n        return new Long(x).hashCode()*31 + new Long(y).hashCode();\n    }\n}\nclass dsu{\n\tint parent[];\n\tdsu(int n){\n\t\tparent=new int[n+1];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tparent[i]=i;\n\t\t}\n\t}\n\tint root(int n) {\n\t\twhile(parent[n]!=n)\n\t\t{ \n\t\t\tparent[n]=parent[parent[n]];\n\t\t\tn=parent[n];\n\t\t}\n\t\treturn n;\n\t}\n\tvoid union(int _a,int _b) {\n\t\tint p_a=root(_a);\n\t\tint p_b=root(_b);\n\t\t\n\t\t\tparent[p_a]=p_b;\n\t\t\n\t\t\t\n\t}\n\tboolean find(int a,int b) {\n\t\tif(root(a)==root(b))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn  false;\n\t}\n\t\n\t\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 515, "index": 515}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class D {\n    static class FastWriter {\n        private final BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int m = fr.nextInt();\n        for (int r = 0; r < n / 2; r++) {\n            for (int c = 0; c < m; c++) {\n                fw.println((r + 1) + \" \" + (c + 1));\n                fw.println((n - r) + \" \" + (m - c));\n            }\n        }\n        if (n % 2 != 0) {\n            int r = n / 2;\n            for (int c = 0; c < m / 2; c++) {\n                fw.println((r + 1) + \" \" + (c + 1));\n                fw.println((r + 1) + \" \" + (m - c));\n            }\n            if (m % 2 != 0) fw.println((r + 1) + \" \" + (m / 2 + 1));\n        }\n        fw.close();\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 516, "index": 516}
{"src": "\n// Java program to to maximize array \n// sum after k operations. \n\nclass\nGFG \n{ \n\n// This function does k operations \n\n// on array in a way that maximize \n\n// the array sum. index --> stores \n\n// the index of current minimum \n\n// element for j'th operation \n\nstatic\nint\nmaximumSum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n// Modify array K number of times \n\nfor\n(\nint\ni = \n1\n; i <= k; i++) \n\n{ \n\nint\nmin = +\n2147483647\n; \n\nint\nindex = -\n1\n; \n\n\n// Find minimum element in array for \n\n// current operation and modify it \n\n// i.e; arr[j] --> -arr[j] \n\nfor\n(\nint\nj=\n0\n; j<n; j++) \n\n{ \n\nif\n(arr[j] < min) \n\n{ \n\nmin = arr[j]; \n\nindex = j; \n\n} \n\n} \n\n\n// this the condition if we find 0 as \n\n// minimum element, so it will useless to \n\n// replace 0 by -(0) for remaining operations \n\nif\n(min == \n0\n) \n\nbreak\n; \n\n\n// Modify element of array \n\narr[index] = -arr[index]; \n\n} \n\n\n// Calculate sum of array \n\nint\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum += arr[i]; \n\nreturn\nsum; \n\n} \n\n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = {-\n2\n, \n0\n, \n5\n, -\n1\n, \n2\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.print(maximumSum(arr, n, k)); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "quadratic", "from": "CorCod", "problem": 517, "index": 517}
{"src": "\n// A Simple Java program to find longest common \n// subarray of two binary arrays with same sum \n\nclass\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n// Returns length of the longest common sum in arr1[] \n\n// and arr2[]. Both are of same size n. \n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n// Initialize result \n\nint\nmaxLen = \n0\n; \n\n\n// One by one pick all possible starting points \n\n// of subarrays \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n// Initialize sums of current subarrays \n\nint\nsum1 = \n0\n, sum2 = \n0\n; \n\n\n// Conider all points for starting with arr[i] \n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n// Update sums \n\nsum1 += arr1[j]; \n\nsum2 += arr2[j]; \n\n\n// If sums are same and current length is \n\n// more than maxLen, update maxLen \n\nif\n(sum1 == sum2) \n\n{ \n\nint\nlen = j-i+\n1\n; \n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 518, "index": 518}
{"src": "\nclass\nSubarraySum \n{ \n\n/* Returns true if the there is a subarray of arr[] with a sum equal to \n\n'sum' otherwise returns false. Also, prints the result */\n\nint\nsubArraySum(\nint\narr[], \nint\nn, \nint\nsum) \n\n{ \n\nint\ncurr_sum, i, j; \n\n\n// Pick a starting point \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\ncurr_sum = arr[i]; \n\n\n// try all subarrays starting with 'i' \n\nfor\n(j = i + \n1\n; j <= n; j++) \n\n{ \n\nif\n(curr_sum == sum) \n\n{ \n\nint\np = j - \n1\n; \n\nSystem.out.println(\n\"Sum found between indexes \"\n+ i \n\n+ \n\" and \"\n+ p); \n\nreturn\n1\n; \n\n} \n\nif\n(curr_sum > sum || j == n) \n\nbreak\n; \n\ncurr_sum = curr_sum + arr[j]; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No subarray found\"\n); \n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSubarraySum arraysum = \nnew\nSubarraySum(); \n\nint\narr[] = {\n15\n, \n2\n, \n4\n, \n8\n, \n9\n, \n5\n, \n10\n, \n23\n}; \n\nint\nn = arr.length; \n\nint\nsum = \n23\n; \n\narraysum.subArraySum(arr, n, sum); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "quadratic", "from": "CorCod", "problem": 519, "index": 519}
{"src": "\n// Java program to count \n// inversions in an array \nclass\nTest { \n\nstatic\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\n\nstatic\nint\ngetInvCount(\nint\nn) \n\n{ \n\nint\ninv_count = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] > arr[j]) \n\ninv_count++; \n\n\nreturn\ninv_count; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Number of inversions are \"\n\n+ getInvCount(arr.length)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 520, "index": 520}
{"src": "import java.util.*;\n\npublic class HelloWorld{\n\n     public static void main(String []args){\n        final long MOD = 1000000007;\n        Scanner scan = new Scanner(System.in);\n        int now = 1;\n        int maxStatements = scan.nextInt();\n        long[] dp = new long[maxStatements + 1];\n        dp[now] = 1;\n        while(maxStatements > 0)\n        {\n            String add = scan.next();\n            if (add.equals(\"f\"))\n            {\n                now++;\n            }\n            else\n            {\n                for (int k = 1; k <= now; k++)\n                {\n                    dp[k] = ((dp[k] + dp[k-1]) % MOD);\n                }\n            }\n            maxStatements--;\n        }\n        System.out.println(dp[now]);\n     }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 521, "index": 521}
{"src": "\n// A Java program for Dijkstra's single source shortest path algorithm. \n// The program is for adjacency matrix representation of the graph \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nShortestPath \n{ \n\n// A utility function to find the vertex with minimum distance value, \n\n// from the set of vertices not yet included in shortest path tree \n\nstatic\nfinal\nint\nV=\n9\n; \n\nint\nminDistance(\nint\ndist[], Boolean sptSet[]) \n\n{ \n\n// Initialize min value \n\nint\nmin = Integer.MAX_VALUE, min_index=-\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(sptSet[v] == \nfalse\n&& dist[v] <= min) \n\n{ \n\nmin = dist[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n// A utility function to print the constructed distance array \n\nvoid\nprintSolution(\nint\ndist[], \nint\nn) \n\n{ \n\nSystem.out.println(\n\"Vertex Distance from Source\"\n); \n\nfor\n(\nint\ni = \n0\n; i < V; i++) \n\nSystem.out.println(i+\n\" tt \"\n+dist[i]); \n\n} \n\n\n// Funtion that implements Dijkstra's single source shortest path \n\n// algorithm for a graph represented using adjacency matrix \n\n// representation \n\nvoid\ndijkstra(\nint\ngraph[][], \nint\nsrc) \n\n{ \n\nint\ndist[] = \nnew\nint\n[V]; \n// The output array. dist[i] will hold \n\n// the shortest distance from src to i \n\n\n// sptSet[i] will true if vertex i is included in shortest \n\n// path tree or shortest distance from src to i is finalized \n\nBoolean sptSet[] = \nnew\nBoolean[V]; \n\n\n// Initialize all distances as INFINITE and stpSet[] as false \n\nfor\n(\nint\ni = \n0\n; i < V; i++) \n\n{ \n\ndist[i] = Integer.MAX_VALUE; \n\nsptSet[i] = \nfalse\n; \n\n} \n\n\n// Distance of source vertex from itself is always 0 \n\ndist[src] = \n0\n; \n\n\n// Find shortest path for all vertices \n\nfor\n(\nint\ncount = \n0\n; count < V-\n1\n; count++) \n\n{ \n\n// Pick the minimum distance vertex from the set of vertices \n\n// not yet processed. u is always equal to src in first \n\n// iteration. \n\nint\nu = minDistance(dist, sptSet); \n\n\n// Mark the picked vertex as processed \n\nsptSet[u] = \ntrue\n; \n\n\n// Update dist value of the adjacent vertices of the \n\n// picked vertex. \n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n// Update dist[v] only if is not in sptSet, there is an \n\n// edge from u to v, and total weight of path from src to \n\n// v through u is smaller than current value of dist[v] \n\nif\n(!sptSet[v] && graph[u][v]!=\n0\n&& \n\ndist[u] != Integer.MAX_VALUE && \n\ndist[u]+graph[u][v] < dist[v]) \n\ndist[v] = dist[u] + graph[u][v]; \n\n} \n\n\n// print the constructed distance array \n\nprintSolution(dist, V); \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n/* Let us create the example graph discussed above */\n\nint\ngraph[][] = \nnew\nint\n[][]{{\n0\n, \n4\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n8\n, \n0\n}, \n\n{\n4\n, \n0\n, \n8\n, \n0\n, \n0\n, \n0\n, \n0\n, \n11\n, \n0\n}, \n\n{\n0\n, \n8\n, \n0\n, \n7\n, \n0\n, \n4\n, \n0\n, \n0\n, \n2\n}, \n\n{\n0\n, \n0\n, \n7\n, \n0\n, \n9\n, \n14\n, \n0\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n0\n, \n9\n, \n0\n, \n10\n, \n0\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n4\n, \n14\n, \n10\n, \n0\n, \n2\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n2\n, \n0\n, \n1\n, \n6\n}, \n\n{\n8\n, \n11\n, \n0\n, \n0\n, \n0\n, \n0\n, \n1\n, \n0\n, \n7\n}, \n\n{\n0\n, \n0\n, \n2\n, \n0\n, \n0\n, \n0\n, \n6\n, \n7\n, \n0\n} \n\n}; \n\nShortestPath t = \nnew\nShortestPath(); \n\nt.dijkstra(graph, \n0\n); \n\n} \n} \n//This code is contributed by Aakash Hasija ", "complexity": "quadratic", "from": "CorCod", "problem": 522, "index": 522}
{"src": "\nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n/* Array should have at least two elements*/\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n/* Initialization of values */\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n} ", "complexity": "quadratic", "from": "CorCod", "problem": 523, "index": 523}
{"src": "\n// Java program to find lexicographically minimum \n// value after k swaps. \nclass\nGFG { \n\n\n// Modifies arr[0..n-1] to lexicographically \n\n// smallest with k swaps. \n\nstatic\nvoid\nminimizeWithKSwaps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n-\n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n// Set the position where we want \n\n// to put the smallest integer \n\nint\npos = i; \n\nfor\n(\nint\nj = i+\n1\n; j < n ; ++j) \n\n{ \n\n\n// If we exceed the Max swaps \n\n// then terminate the loop \n\nif\n(j - i > k) \n\nbreak\n; \n\n\n// Find the minimum value from i+1 to \n\n// max k or n \n\nif\n(arr[j] < arr[pos]) \n\npos = j; \n\n} \n\n\n// Swap the elements from Minimum position \n\n// we found till now to the i index \n\nint\ntemp; \n\n\nfor\n(\nint\nj = pos; j>i; --j) \n\n{ \n\ntemp=arr[j]; \n\narr[j]=arr[j-\n1\n]; \n\narr[j-\n1\n]=temp; \n\n} \n\n\n// Set the final value after swapping pos-i \n\n// elements \n\nk -= pos-i; \n\n} \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\narr[] = {\n7\n, \n6\n, \n9\n, \n2\n, \n1\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nminimizeWithKSwaps(arr, n, k); \n\n\n//Print the final Array \n\nfor\n(\nint\ni=\n0\n; i<n; ++i) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "quadratic", "from": "CorCod", "problem": 524, "index": 524}
{"src": "\n// Java program to solve Gold Mine problem \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n\nstatic\nfinal\nint\nMAX = \n100\n; \n\n\n// Returns maximum amount of gold that \n\n// can be collected when journey started \n\n// from first column and moves allowed \n\n// are right, right-up and right-down \n\nstatic\nint\ngetMaxGold(\nint\ngold[][], \n\nint\nm, \nint\nn) \n\n{ \n\n\n// Create a table for storing \n\n// intermediate results and initialize \n\n// all cells to 0. The first row of \n\n// goldMineTable gives the maximum \n\n// gold that the miner can collect \n\n// when starts that row \n\nint\ngoldTable[][] = \nnew\nint\n[m][n]; \n\n\nfor\n(\nint\n[] rows:goldTable) \n\nArrays.fill(rows, \n0\n); \n\n\nfor\n(\nint\ncol = n-\n1\n; col >= \n0\n; col--) \n\n{ \n\nfor\n(\nint\nrow = \n0\n; row < m; row++) \n\n{ \n\n\n// Gold collected on going to \n\n// the cell on the right(->) \n\nint\nright = (col == n-\n1\n) ? \n0\n\n: goldTable[row][col+\n1\n]; \n\n\n// Gold collected on going to \n\n// the cell to right up (/) \n\nint\nright_up = (row == \n0\n|| \n\ncol == n-\n1\n) ? \n0\n: \n\ngoldTable[row-\n1\n][col+\n1\n]; \n\n\n// Gold collected on going to \n\n// the cell to right down (\\) \n\nint\nright_down = (row == m-\n1\n\n|| col == n-\n1\n) ? \n0\n: \n\ngoldTable[row+\n1\n][col+\n1\n]; \n\n\n// Max gold collected from taking \n\n// either of the above 3 paths \n\ngoldTable[row][col] = gold[row][col] \n\n+ Math.max(right, Math.max(right_up, \n\nright_down)); \n\n; \n\n} \n\n} \n\n\n// The max amount of gold collected will be \n\n// the max value in first column of all rows \n\nint\nres = goldTable[\n0\n][\n0\n]; \n\n\nfor\n(\nint\ni = \n1\n; i < m; i++) \n\nres = Math.max(res, goldTable[i][\n0\n]); \n\n\nreturn\nres; \n\n} \n\n\n//driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ngold[][]= { {\n1\n, \n3\n, \n1\n, \n5\n}, \n\n{\n2\n, \n2\n, \n4\n, \n1\n}, \n\n{\n5\n, \n0\n, \n2\n, \n3\n}, \n\n{\n0\n, \n6\n, \n1\n, \n2\n} }; \n\n\nint\nm = \n4\n, n = \n4\n; \n\n\nSystem.out.print(getMaxGold(gold, m, n)); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "quadratic", "from": "CorCod", "problem": 525, "index": 525}
{"src": "import java.io.*;\nimport java.util.Scanner;\npublic class DivideCandies {\n\tpublic static void main(String[] args){\n\t\tScanner input = new Scanner(System.in);\n\t\tlong n = input.nextLong();\n\t\tint m = input.nextInt();\n\t\tlong[] a = new long[m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tif(i <= (n%m) && i != 0)\n\t\t\t{\n\t\t\t\ta[i] = n/m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i] = n/m;\n\t\t\t}\n\t\t}\n\t\tlong result = 0L;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif((i * i + j * j) % m == 0)\n\t\t\t\t{\n\t\t\t\t\tresult += a[i] * a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}\n\n\n\n", "complexity": "quadratic", "from": "CorCod", "problem": 526, "index": 526}
{"src": "\n// Java Code for Maximum weight path ending at \n// any element of last row in a matrix \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n/* Function which return the maximum weight \n\npath sum */\n\npublic\nstatic\nint\nmaxCost(\nint\nmat[][], \nint\nN) \n\n{ \n\n// create 2D matrix to store the sum of \n\n// the path \n\nint\ndp[][]=\nnew\nint\n[N][N]; \n\n\ndp[\n0\n][\n0\n] = mat[\n0\n][\n0\n]; \n\n\n// Initialize first column of total \n\n// weight array (dp[i to N][0]) \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\ndp[i][\n0\n] = mat[i][\n0\n] + dp[i-\n1\n][\n0\n]; \n\n\n// Calculate rest path sum of weight matrix \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j < i + \n1\n&& j < N; j++) \n\ndp[i][j] = mat[i][j] + \n\nMath.max(dp[i-\n1\n][j-\n1\n], \n\ndp[i-\n1\n][j]); \n\n\n// find the max weight path sum to reach \n\n// the last row \n\nint\nresult = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nif\n(result < dp[N-\n1\n][i]) \n\nresult = dp[N-\n1\n][i]; \n\n\n// return maximum weight path sum \n\nreturn\nresult; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n4\n, \n1\n,\n5\n,\n6\n, \n1\n}, \n\n{ \n2\n,\n9\n,\n2\n,\n11\n,\n10\n}, \n\n{ \n15\n,\n1\n,\n3\n,\n15\n, \n2\n}, \n\n{ \n16\n, \n92\n, \n41\n,\n4\n,\n3\n}, \n\n{ \n8\n, \n142\n, \n6\n, \n4\n, \n8\n} \n\n}; \n\nint\nN = \n5\n; \n\nSystem.out.println(\n\"Maximum Path Sum : \"\n+ \n\nmaxCost(mat, N)); \n\n} \n} \n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "quadratic", "from": "CorCod", "problem": 527, "index": 527}
{"src": "\n// Java program to find maximum sum increasing \n// subsequence tiint i-th index and including \n// k-th index. \nclass\nGFG { \n\n\nstatic\nint\npre_compute(\nint\na[], \nint\nn, \n\nint\nindex, \nint\nk) \n\n{ \n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n// Initializing the first row of \n\n// the dp[][]. \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(a[i] > a[\n0\n]) \n\ndp[\n0\n][i] = a[i] + a[\n0\n]; \n\nelse\n\ndp[\n0\n][i] = a[i]; \n\n} \n\n\n// Creating the dp[][] matrix. \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(a[j] > a[i] && j > i) \n\n{ \n\nif\n(dp[i - \n1\n][i] + a[j] > \n\ndp[i - \n1\n][j]) \n\ndp[i][j] = dp[i - \n1\n][i] \n\n+ a[j]; \n\nelse\n\ndp[i][j] = dp[i - \n1\n][j]; \n\n} \n\nelse\n\ndp[i][j] = dp[i - \n1\n][j]; \n\n} \n\n} \n\n\n// To calculate for i=4 and k=6. \n\nreturn\ndp[index][k]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = { \n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = a.length; \n\nint\nindex = \n4\n, k = \n6\n; \n\nSystem.out.println( \n\npre_compute(a, n, index, k)); \n\n} \n} \n\n// This code is contributed by Smitha. ", "complexity": "quadratic", "from": "CorCod", "problem": 528, "index": 528}
{"src": "\n// Java implementation to print \n// the counter clock wise \n// spiral traversal of matrix \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nint\nR = \n4\n; \n\nstatic\nint\nC = \n4\n; \n\n\n// function to print the \n\n// required traversal \n\nstatic\nvoid\ncounterClockspiralPrint(\nint\nm, \n\nint\nn, \n\nint\narr[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n\n/* k - starting row index \n\nm - ending row index \n\nl - starting column index \n\nn - ending column index \n\ni - iterator */\n\n\n// initialize the count \n\nint\ncnt = \n0\n; \n\n\n// total number of \n\n// elements in matrix \n\nint\ntotal = m * n; \n\n\nwhile\n(k < m && l < n) \n\n{ \n\nif\n(cnt == total) \n\nbreak\n; \n\n\n// Print the first column \n\n// from the remaining columns \n\nfor\n(i = k; i < m; ++i) \n\n{ \n\nSystem.out.print(arr[i][l] + \n\" \"\n); \n\ncnt++; \n\n} \n\nl++; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n// Print the last row from \n\n// the remaining rows \n\nfor\n(i = l; i < n; ++i) \n\n{ \n\nSystem.out.print(arr[m - \n1\n][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nm--; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n// Print the last column \n\n// from the remaining columns \n\nif\n(k < m) \n\n{ \n\nfor\n(i = m - \n1\n; i >= k; --i) \n\n{ \n\nSystem.out.print(arr[i][n - \n1\n] + \n\" \"\n); \n\ncnt++; \n\n} \n\nn--; \n\n} \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n// Print the first row \n\n// from the remaining rows \n\nif\n(l < n) \n\n{ \n\nfor\n(i = n - \n1\n; i >= l; --i) \n\n{ \n\nSystem.out.print(arr[k][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nk++; \n\n} \n\n} \n\n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[][] = { { \n1\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n5\n, \n6\n, \n7\n, \n8\n}, \n\n{ \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n} }; \n\n\n// Function calling \n\ncounterClockspiralPrint(R, C, arr); \n} \n} \n\n// This code is contributed by vt_m ", "complexity": "quadratic", "from": "CorCod", "problem": 529, "index": 529}
{"src": "import java.util.*;\n \nimport javax.lang.model.util.ElementScanner6;\n \nimport java.io.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n \n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n \n    }\n \n \n \n \n \n    static class Solver {\n\n        class pair implements Comparable<pair>{\n\n            int i;\n            long dist;\n            public pair(int i,long dist)\n            {\n                this.i=i;\n                this.dist=dist;\n            }\n\n            public int compareTo(pair p)\n            {\n                return Long.compare(this.dist,p.dist);\n            }\n\n        }\n \n        class Node implements Comparable < Node > {\n            int i;\n            int cnt;\n \n            Node(int i, int cnt) {\n                this.i = i;\n                this.cnt = cnt;\n            }\n \n            public int compareTo(Node n) {\n                if (this.cnt == n.cnt) {\n                    return Integer.compare(this.i, n.i);\n                }\n                return Integer.compare(this.cnt, n.cnt);\n            }\n        }\n \n        public boolean done(int[] sp, int[] par) {\n            int root;\n \n            root = findSet(sp[0], par);\n \n            for (int i = 1; i < sp.length; i++) {\n                if (root != findSet(sp[i], par))\n                    return false;\n            }\n            return true;\n        }\n        public int findSet(int i, int[] par) {\n            int x = i;\n            boolean flag = false;\n            while (par[i] >= 0) {\n                flag = true;\n                i = par[i];\n            }\n            if (flag)\n                par[x] = i;\n            return i;\n        }\n \n        public void unionSet(int i, int j, int[] par) {\n            int x = findSet(i, par);\n            int y = findSet(j, par);\n            if (x < y) {\n                par[y] = x;\n            } else {\n                par[x] = y;\n            }\n        }\n \n        public long pow(long a, long b, long MOD) {\n            if (b == 0) {\n                return 1;\n            }\n            if (b == 1) {\n                return a;\n            }\n            long val = pow(a, b / 2, MOD);\n            if (b % 2 == 0) {\n                return val * val % MOD;\n            } else {\n                return val * (val * a % MOD) % MOD;\n \n            }\n \n        }\n\n        public boolean isPrime(int n)\n        {\n            for(int i=2;i<n;i++)\n            {\n                if(n%i==0)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n \n \n        public void minPrimeFactor(int n, int[] s) {\n            boolean prime[] = new boolean[n + 1];\n            Arrays.fill(prime, true);\n            s[1] = 1;\n            s[2] = 2;\n            for (int i = 4; i <= n; i += 2) {\n                prime[i] = false;\n                s[i] = 2;\n            }\n \n            for (int i = 3; i <= n; i += 2) {\n                if (prime[i]) {\n                    s[i] = i;\n                    for (int j = 2 * i; j <= n; j += i) {\n                        prime[j] = false;\n                        s[j] = i;\n                    }\n                }\n            }\n \n        }\n \n \n        public void findAllPrime(int n, ArrayList < Node > al, int s[]) {\n            int curr = s[n];\n            int cnt = 1;\n            while (n > 1) {\n                n /= s[n];\n                if (curr == s[n]) {\n                    cnt++;\n                    continue;\n \n                }\n                Node n1 = new Node(curr, cnt);\n                al.add(n1);\n \n                curr = s[n];\n                cnt = 1;\n            }\n        }\n \n \n \n        public int binarySearch(int n, int k) {\n            int left = 1;\n            int right = 100000000 + 5;\n            int ans = 0;\n            while (left <= right) {\n                int mid = (left + right) / 2;\n                if (n / mid >= k) {\n                    left = mid + 1;\n                    ans = mid;\n                } else {\n                    right = mid - 1;\n                }\n            }\n \n            return ans;\n        }\n        public boolean checkPallindrom(String s) {\n            char ch[] = s.toCharArray();\n \n            for (int i = 0; i < s.length() / 2; i++) {\n                if (ch[i] != ch[s.length() - 1 - i])\n                    return false;\n            }\n            return true;\n        }\n \n \n \n \n        public void remove(ArrayList < Integer > [] al, int x) {\n            for (int i = 0; i < al.length; i++) {\n                for (int j = 0; j < al[i].size(); j++) {\n \n                    if (al[i].get(j) == x)\n                        al[i].remove(j);\n \n                }\n            }\n        }\n \n        public long gcd(long a, long b) {\n            if (a == 0)\n                return b;\n            return gcd(b % a, a);\n        }\n \n \n        public void printDivisors(long n, ArrayList < Long > al) {\n            // Note that this loop runs till square root \n            for (long i = 1; i <= Math.sqrt(n); i++) {\n                if (n % i == 0) {\n                    // If divisors are equal, print only one \n                    if (n / i == i) {\n                        al.add(i);\n                    } else // Otherwise print both \n                    {\n                        al.add(i);\n                        al.add(n / i);\n                    }\n \n                }\n            }\n        }\n \n        public static long constructSegment(long seg[], long arr[], int low, int high, int pos) {\n            if (low == high) {\n                seg[pos] = arr[low];\n                return seg[pos];\n            }\n            int mid = (low + high) / 2;\n            long t1 = constructSegment(seg, arr, low, mid, (2 * pos) + 1);\n            long t2 = constructSegment(seg, arr, mid + 1, high, (2 * pos) + 2);\n            seg[pos] = t1 + t2;\n            return seg[pos];\n \n        }\n        public static long querySegment(long seg[], int low, int high, int qlow, int qhigh, int pos) {\n \n            if (qlow <= low && qhigh >= high) {\n                return seg[pos];\n            } else if (qlow > high || qhigh < low) {\n                return 0;\n            } else {\n                long ans = 0;\n                int mid = (low + high) / 2;\n                ans += querySegment(seg, low, mid, qlow, qhigh, (2 * pos) + 1);\n                ans += querySegment(seg, mid + 1, high, qlow, qhigh, (2 * pos) + 2);\n                return ans;\n            }\n \n        }\n        public static int lcs(char[] X, char[] Y, int m, int n) {\n            if (m == 0 || n == 0)\n                return 0;\n            if (X[m - 1] == Y[n - 1])\n                return 1 + lcs(X, Y, m - 1, n - 1);\n            else\n                return Integer.max(lcs(X, Y, m, n - 1), lcs(X, Y, m - 1, n));\n        }\n \n        public static long recursion(long start, long end, long cnt[], int a, int b) {\n \n            long min = 0;\n            long count = 0;\n            int ans1 = -1;\n            int ans2 = -1;\n            int l = 0;\n            int r = cnt.length - 1;\n            while (l <= r) {\n                int mid = (l + r) / 2;\n                if (cnt[mid] >= start) {\n                    ans1 = mid;\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n \n            l = 0;\n            r = cnt.length - 1;\n            while (l <= r) {\n                int mid = (l + r) / 2;\n                if (cnt[mid] <= end) {\n                    ans2 = mid;\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n \n            if (ans1 == -1 || ans2 == -1 || ans2 < ans1) {\n                // System.out.println(\"min1 \"+min);\n                min = a;\n                return a;\n \n            } else {\n                min = b * (end - start + 1) * (ans2 - ans1 + 1);\n            }\n            if (start == end) {\n                // System.out.println(\"min \"+min);\n                return min;\n            }\n            long mid = (end + start) / 2;\n            min = Long.min(min, recursion(start, mid, cnt, a, b) + recursion(mid + 1, end, cnt, a, b));\n            // System.out.println(\"min \"+min);\n            return min;\n        }\n \n \n \n \n \n        public int dfs_util(ArrayList < Integer > [] al, boolean vis[], int x, int[] s, int lvl[]) {\n \n            vis[x] = true;\n            int cnt = 1;\n            for (int i = 0; i < al[x].size(); i++) {\n \n                if (!vis[al[x].get(i)]) {\n                    lvl[al[x].get(i)] = lvl[x] + 1;\n                    cnt += dfs_util(al, vis, al[x].get(i), s, lvl);\n \n \n                }\n \n \n            }\n            s[x] = cnt;\n            return s[x];\n        }\n \n        public void dfs(ArrayList[] al, int[] s, int[] lvl) {\n \n            boolean vis[] = new boolean[al.length];\n            for (int i = 0; i < al.length; i++) {\n                if (!vis[i]) {\n                    lvl[i] = 1;\n                    dfs_util(al, vis, i, s, lvl);\n                }\n            }\n        }\n \n        public int[] computeLps(String s)\n        {\n            int ans[] =new int[s.length()];\n            char ch[] = s.toCharArray();\n            int n = s.length();\n            int i=1;\n            int len=0;\n            ans[0]=0;\n            while(i<n)\n            {\n                if(ch[i]==ch[len])\n                {\n                    len++;\n                    ans[i]=len;\n                    i++;\n                }\n                else\n                {\n                    if(len!=0)\n                    {\n                        len=ans[len-1];\n                    }\n                    else\n                    {\n                        ans[i]=len;\n                        i++;\n                    }\n                }\n            }\n\n            return ans;\n\n        }\n \n \n        private void solve(InputReader inp, PrintWriter out1) {\n            int n = inp.nextInt();\n            int m = inp.nextInt();\n            long k = inp.nextLong();\n            long arr[] = new long[n];\n\n            for(int i=0;i<n;i++)\n            {\n                arr[i] = inp.nextLong();\n\n            }\n            long ans=0;\n            for(int i=0;i<m;i++)\n            {\n                long sum=0;\n                for(int j=i;j<n;j++)\n                {\n                    \n\n                    if(j%m==i)\n                    {\n                        if(sum<0)\n                        {\n                           sum=0;\n                        }\n                        sum-=k;\n                    }\n                    \n                    sum+=arr[j];\n                    \n                    ans=Math.max(ans,sum);\n                }\n\n            \n\n            }\n\n            System.out.println(ans);\n           \n\n           \n            \n        }\n \n \n}\n \n \n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n \n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\nclass ele implements Comparable < ele > {\n    int value;\n    int i;\n    boolean flag;\n    public ele(int value, int i) {\n        this.value = value;\n        this.i = i;\n        this.flag = false;\n    }\n    public int compareTo(ele e) {\n        return Integer.compare(this.value, e.value);\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 530, "index": 530}
{"src": "\n// Java program to find longest \n// alternating subsequence in an array \nimport\njava.io.*; \n\nclass\nGFG { \n\n// Function to return longest \n// alternating subsequence length \nstatic\nint\nzzis(\nint\narr[], \nint\nn) \n{ \n\n/*las[i][0] = Length of the longest \n\nalternating subsequence ending at \n\nindex i and last element is \n\ngreater than its previous element \n\nlas[i][1] = Length of the longest \n\nalternating subsequence ending at \n\nindex i and last element is \n\nsmaller than its previous \n\nelement */\n\nint\nlas[][] = \nnew\nint\n[n][\n2\n]; \n\n\n/* Initialize all values from 1 */\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nlas[i][\n0\n] = las[i][\n1\n] = \n1\n; \n\n\nint\nres = \n1\n; \n// Initialize result \n\n\n/* Compute values in bottom up manner */\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n// Consider all elements as \n\n// previous of arr[i] \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n// If arr[i] is greater, then \n\n// check with las[j][1] \n\nif\n(arr[j] < arr[i] && \n\nlas[i][\n0\n] < las[j][\n1\n] + \n1\n) \n\nlas[i][\n0\n] = las[j][\n1\n] + \n1\n; \n\n\n// If arr[i] is smaller, then \n\n// check with las[j][0] \n\nif\n( arr[j] > arr[i] && \n\nlas[i][\n1\n] < las[j][\n0\n] + \n1\n) \n\nlas[i][\n1\n] = las[j][\n0\n] + \n1\n; \n\n} \n\n\n/* Pick maximum of both values at \n\nindex i */\n\nif\n(res < Math.max(las[i][\n0\n], las[i][\n1\n])) \n\nres = Math.max(las[i][\n0\n], las[i][\n1\n]); \n\n} \n\n\nreturn\nres; \n} \n\n/* Driver program */\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = { \n10\n, \n22\n, \n9\n, \n33\n, \n49\n, \n\n50\n, \n31\n, \n60\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of Longest \"\n+ \n\n\"alternating subsequence is \"\n+ \n\nzzis(arr, n)); \n} \n} \n// This code is contributed by Prerna Saini ", "complexity": "quadratic", "from": "CorCod", "problem": 531, "index": 531}
{"src": "\n// Java Program to construct ancestor matrix for a given tree \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// ancestorMatrix function to populate the matrix of \n\npublic\nstatic\nvoid\nancestorMatrix(Node root , \n\nint\nmatrix[][],\nint\nsize) \n\n{ \n\n\n// base case: \n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n// call recursively for a preorder {left} \n\nancestorMatrix(root.left, matrix, size); \n\n\n// call recursively for preorder {right} \n\nancestorMatrix(root.right, matrix, size); \n\n\n// here we will reach the root node automatically \n\n// try solving on pen and paper \n\n\nif\n(root.left != \nnull\n) \n\n{ \n\n// make the current node as parent of its children node \n\nmatrix[root.data][root.left.data] = \n1\n; \n\n\n// iterate through all the columns of children node \n\n// all nodes which are children to \n\n// children of root node will also \n\n// be children of root node \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\n// if children of root node is a parent \n\n// of someone (i.e 1) then make that node \n\n// as children of root also \n\nif\n(matrix[root.left.data][i] == \n1\n) \n\nmatrix[root.data][i] = \n1\n; \n\n} \n\n} \n\n\n// same procedure followed for right node as well \n\nif\n(root.right != \nnull\n) \n\n{ \n\nmatrix[root.data][root.right.data] = \n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nif\n(matrix[root.right.data][i]==\n1\n) \n\nmatrix[root.data][i] = \n1\n; \n\n} \n\n} \n\n\n\n} \n\n\n// Driver program to test the program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n// construct the binary tree as follows \n\nNode tree_root = \nnew\nNode(\n5\n); \n\ntree_root.left = \nnew\nNode (\n1\n); \n\ntree_root.right = \nnew\nNode(\n2\n); \n\ntree_root.left.left = \nnew\nNode(\n0\n); \n\ntree_root.left.right = \nnew\nNode(\n4\n); \n\ntree_root.right.left = \nnew\nNode(\n3\n); \n\n\n// size of matrix \n\nint\nsize = \n6\n; \n\nint\nmatrix [][] = \nnew\nint\n[size][size]; \n\n\nancestorMatrix(tree_root, matrix, size); \n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < size; j++) \n\n{ \n\nSystem.out.print(matrix[i][j]+\n\" \"\n); \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\n// node class for tree node \n\nstatic\nclass\nNode \n\n{ \n\npublic\nint\ndata ; \n\npublic\nNode left ,right; \n\npublic\nNode (\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.left = \nthis\n.right = \nnull\n; \n\n} \n\n} \n} \n\n// This code is contributed by Sparsh Singhal ", "complexity": "quadratic", "from": "CorCod", "problem": 532, "index": 532}
{"src": "\n// Java program to count number of times \n// S appears as a subsequence in T \nimport\njava.io.*; \n\nclass\nGFG { \n\nstatic\nint\nfindSubsequenceCount(String S, String T) \n\n{ \n\nint\nm = T.length(); \n\nint\nn = S.length(); \n\n\n// T can't appear as a subsequence in S \n\nif\n(m > n) \n\nreturn\n0\n; \n\n\n// mat[i][j] stores the count of \n\n// occurrences of T(1..i) in S(1..j). \n\nint\nmat[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\n\n// Initializing first column with \n\n// all 0s. An emptystring can't have \n\n// another string as suhsequence \n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\nmat[i][\n0\n] = \n0\n; \n\n\n// Initializing first row with all 1s. \n\n// An empty string is subsequence of all. \n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\nmat[\n0\n][j] = \n1\n; \n\n\n// Fill mat[][] in bottom up manner \n\nfor\n(\nint\ni = \n1\n; i <= m; i++) { \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) { \n\n// If last characters don't match, \n\n// then value is same as the value \n\n// without last character in S. \n\nif\n(T.charAt(i - \n1\n) != S.charAt(j - \n1\n)) \n\nmat[i][j] = mat[i][j - \n1\n]; \n\n\n// Else value is obtained considering two cases. \n\n// a) All substrings without last character in S \n\n// b) All substrings without last characters in \n\n// both. \n\nelse\n\nmat[i][j] = mat[i][j - \n1\n] + mat[i - \n1\n][j - \n1\n]; \n\n} \n\n} \n\n\n/* uncomment this to print matrix mat \n\nfor (int i = 1; i <= m; i++, cout << endl) \n\nfor (int j = 1; j <= n; j++) \n\nSystem.out.println ( mat[i][j] +\" \"); */\n\nreturn\nmat[m][n]; \n\n} \n\n\n// Driver code to check above method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString T = \n\"ge\"\n; \n\nString S = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(findSubsequenceCount(S, T)); \n\n} \n} \n// This code is contributed by vt_m ", "complexity": "quadratic", "from": "CorCod", "problem": 533, "index": 533}
{"src": "import javax.print.attribute.standard.RequestingUserName;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws NumberFormatException, IOException\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        int tc = in.nextInt();\n        for(int i = 0; i < tc; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class Task {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n\n            int k = in.nextInt();\n            int[] s = getArray(in.nextToken());\n            int[] a = getArray(in.nextToken());\n            int[] b = getArray(in.nextToken());\n\n            int[] per = new int[k];\n            boolean[] used = new boolean[k];\n            Arrays.fill(per , -1);\n\n            if(!check(s , a, per.clone(), k, used)){\n                out.println(\"NO\");\n                return;\n            }\n\n            for(int i = 0; i < s.length; i++){\n                if(per[s[i]] != -1){\n                    continue;\n                }\n                for(int j = 0; j < k; j++){\n                    if(used[j]){\n                        continue;\n                    }\n                    per[s[i]] = j;\n                    used[j] = true;\n                    if(check(s , a , per.clone() , k, used)){\n                        break;\n                    }\n                    per[s[i]] = -1;\n                    used[j] = false;\n                }\n            }\n\n            for(int i = 0; i < s.length; i++){\n                if(per[s[i]] == -1){\n                    out.println(\"NO\");\n                    return;\n                }\n                s[i] = per[s[i]];\n            }\n\n            if(cmp(s , b) > 0){\n                out.println(\"NO\");\n                return;\n            }\n\n\n            int last = 0;\n            for(int i = 0; i < k; i++){\n                if(per[i] == -1) {\n                    while(used[last])last++;\n                    per[i] = last;\n                    used[last] = true;\n                }\n            }\n\n            char[] result = new char[k];\n\n            for(int i = 0; i < k; i++){\n                result[i] = (char)('a' + per[i]);\n            }\n            out.println(\"YES\");\n            out.println(new String(result));\n        }\n\n        private int cmp(int[] a, int[] b){\n            for(int i = 0; i < a.length; i++){\n                if(a[i] != b[i]){\n                    return a[i] < b[i] ? -1 : 1;\n                }\n            }\n            return 0;\n        }\n\n\n        private boolean check(int[] s, int[] a, int[] per, int k, boolean[] used) {\n            int res[] = new int[s.length];\n            int last = k - 1;\n            for(int i = 0; i < res.length; ++i){\n\n                if(per[s[i]] == -1){\n\n                    while(last >= 0 && used[last]){\n                        last--;\n                    }\n\n                    if(last < 0){\n                        return false;\n                    }\n\n                    per[s[i]] = last;\n                    last--;\n                }\n                res[i] = per[s[i]];\n            }\n            return cmp(a , res) <= 0;\n        }\n\n        private int[] getArray(String nextToken) {\n            int result[] = new int[nextToken.length()];\n            for(int i = 0; i < nextToken.length(); i++){\n                result[i] = nextToken.charAt(i) - 'a';\n            }\n            return result;\n        }\n    }\n\n    static class InputReader {\n\n        BufferedReader in;\n        StringTokenizer tok;\n\n        public InputReader(InputStream stream){\n            in = new BufferedReader(new InputStreamReader(stream), 32768);\n            tok = null;\n        }\n\n        String nextToken()\n        {\n            String line = \"\";\n            while(tok == null || !tok.hasMoreTokens()) {\n                try {\n                    if((line = in.readLine()) != null)\n                        tok = new StringTokenizer(line);\n                    else\n                        return null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return null;\n                }\n            }\n            return tok.nextToken();\n        }\n        int nextInt(){\n            return Integer.parseInt(nextToken());\n        }\n        long nextLong()\t{\n            return Long.parseLong(nextToken());\n        }\n        double nextDouble()\t{\n            return Double.parseDouble(nextToken());\n        }\n\n    }\n\n}", "complexity": "quadratic", "from": "CorCod", "problem": 534, "index": 534}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces913F {\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner input = new Scanner(System.in);\n\t\tint n = input.nextInt();\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tinput.close();\n\t\tfinal int mod = 998244353;\n\t\t\n\t\tint frac = multiply(a, inverse(b, mod), mod);\n\t\tint reverse = (mod+1-frac)%mod;\n\t\t\n\t\tint[] fracpower = new int[n+1];\n\t\tint[] reversepower = new int[n+1];\n\t\tfracpower[0] = 1;\n\t\treversepower[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfracpower[i] = multiply(fracpower[i-1], frac, mod);\n\t\t\treversepower[i] = multiply(reversepower[i-1], reverse, mod);\n\t\t}\n\t\t\n\t\tint[][] dp1 = new int[n+1][n+1];\n\t\tdp1[2][1] = 1;\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tif (j == 1) {\n\t\t\t\t\tdp1[i][j] = fracpower[i-1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp1[i][j] = multiply(dp1[i-1][j-1], fracpower[i-j], mod);\n\t\t\t\t}\n\t\t\t\tif (j == i-1) {\n\t\t\t\t\tdp1[i][j] += reversepower[i-1];\n\t\t\t\t\tdp1[i][j] %= mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp1[i][j] += multiply(dp1[i-1][j], reversepower[j], mod);\n\t\t\t\t\tdp1[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] dp2 = new int[n+1][n+1];\n\t\tdp2[1][1] = 1;\n\t\tdp2[2][1] = 1;\n\t\tdp2[2][2] = 0;\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tint val = 0;\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tdp2[i][j] = multiply(dp2[j][j], dp1[i][j], mod);\n\t\t\t\tval += dp2[i][j];\n\t\t\t\tval %= mod;\n\t\t\t}\n\t\t\tdp2[i][i] = (mod+1-val)%mod;\n\t\t}\n\t\t\n\t\t/*for (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tSystem.out.print(dp2[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}*/\n\t\t\n\t\tint[] EV = new int[n+1];\n\t\tEV[1] = 0;\n\t\tEV[2] = 1;\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tint val = 0;\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tint r = j*(i-j) + (j*(j-1))/2 + EV[i-j] + EV[j];\n\t\t\t\tr %= mod;\n\t\t\t\tval += multiply(dp2[i][j], r, mod);\n\t\t\t\tval %= mod;\n\t\t\t}\n\t\t\tval += multiply((i*(i-1))/2, dp2[i][i], mod);\n\t\t\tval %= mod;\n\t\t\t\n\t\t\tint s = (mod+1-dp2[i][i])%mod;\n\t\t\tEV[i] = multiply(val, inverse(s, mod), mod);\n\t\t}\n\t\t\n\t\tSystem.out.println(EV[n]);\n\t}\n\t\n\tpublic static int multiply(int a, int b, int mod) {\n\t\tlong x = (long)a*(long)b;\n\t\treturn (int) (x%mod);\n\t}\n\t\n\tpublic static int inverse (int a, int n) {\n\t\tint m = n;\n\t\tint r1 = 1;\n\t\tint r2 = 0;\n\t\tint r3 = 0;\n\t\tint r4 = 1;\n\t\twhile ((a > 0) && (n > 0)) {\n\t\t\tif (n >= a) {\n\t\t\t\tr3 -= r1*(n/a);\n\t\t\t\tr4 -= r2*(n/a);\n\t\t\t\tn = n%a;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tmp = a;\n\t\t\t\ta = n;\n\t\t\t\tn = tmp;\n\t\t\t\ttmp = r1;\n\t\t\t\tr1 = r3;\n\t\t\t\tr3 = tmp;\n\t\t\t\ttmp = r2;\n\t\t\t\tr2 = r4;\n\t\t\t\tr4 = tmp;\n\t\t\t}\n\t\t}\n\t\tif (a == 0) {\n\t\t\tif (r3 >= 0)\n\t\t\t\treturn (r3%m);\n\t\t\telse\n\t\t\t\treturn (m+(r3%m));\n\t\t}\n\t\telse {\n\t\t\tif (r1 >= 0)\n\t\t\t\treturn (r1%m);\n\t\t\telse\n\t\t\t\treturn (m+(r1%m));\n\t\t}\n\n\t}\n}", "complexity": "quadratic", "from": "CorCod", "problem": 535, "index": 535}
{"src": "\n// Java program to find triplets in a given \n// array whose sum is zero \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n\n// function to print triplets with 0 sum \n\nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n\n{ \n\nboolean\nfound = \nfalse\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\n{ \n\n// Find all pairs with sum equals to \n\n// \"-arr[i]\" \n\nHashSet<Integer> s = \nnew\nHashSet<Integer>(); \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n{ \n\nint\nx = -(arr[i] + arr[j]); \n\nif\n(s.contains(x)) \n\n{ \n\nSystem.out.printf(\n\"%d %d %d\\n\"\n, x, arr[i], arr[j]); \n\nfound = \ntrue\n; \n\n} \n\nelse\n\n{ \n\ns.add(arr[j]); \n\n} \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\n{ \n\nSystem.out.printf(\n\" No Triplet Found\\n\"\n); \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindTriplets(arr, n); \n\n} \n} \n\n// This code contributed by Rajput-Ji ", "complexity": "quadratic", "from": "CorCod", "problem": 536, "index": 536}
{"src": "import java.io.*;\nimport java.math.BigInteger; \nimport java.util.*;\n\n\n\n//Mann Shah [ DAIICT ].\n//fast io\n\npublic class Main {\n\tstatic int mod = (int) (1e9+7);\n\tstatic InputReader in;\n    static PrintWriter out;\n    \n    \t\tpublic static int n;\n    \t\tpublic static int m;\n    \n    \t\tpublic static boolean valid(int i , int j) {\n    \t\t\t\n    \t\t\treturn ( i<n && j<m && i>=0 && j>=0);\n    \t\t}\n    \t\t\n   \n\t\tpublic static void main(String args[] )  {\n\t\t\t\n\t\t  in = new InputReader(System.in);\n\t      out = new PrintWriter(System.out);\n\t     \n\t     n = in.nextInt();\n\t    \t m = in.nextInt();\n\t    \n\t    \tString[] s = new String[n];\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\ts[i]= in.readString();\n\t    \t}\n\t    \tint f=0;\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\tfor(int j=0;j<s[i].length();j++) {\n\t    \t\t\tint val=-1;\n\t    \t\t\tif(s[i].charAt(j)=='.') {\n\t    \t\t\t\tval=0;\n\t    \t\t\t}\n\t    \t\t\telse if(s[i].charAt(j)=='*') {\n\t    \t\t\t\tcontinue;\n\t    \t\t\t}\n\t    \t\t\telse {\n\t    \t\t\t\tval = s[i].charAt(j)-'0';\n\t    \t\t\t}\n\t    \t\t\tint c=0;\n\t    \t\t\tif(valid(i-1,j) && s[i-1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j-1) && s[i-1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j+1) && s[i-1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j-1) && s[i].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j+1) && s[i].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j) && s[i+1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j+1) && s[i+1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j-1) && s[i+1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(c!=val) {\n\t    \t\t\t\tf=1;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \tif(f==0) {\n\t    \t\tout.println(\"YES\");\n\t    \t}\n\t    \telse {\n\t    \t\tout.println(\"NO\");\n\t    \t}\n\t     \n\t     \n\t     out.close();\n\t\t}\n\t\t\n\n\t\t\n\t\tstatic class InputReader\n\t    {\n\n\t        private final InputStream stream;\n\t        private final byte[] buf = new byte[8192];\n\t        private int curChar, snumChars;\n\t        private SpaceCharFilter filter;\n\n\t        public InputReader(InputStream stream)\n\t        {\n\t                this.stream = stream;\n\t        }\n\n\t        public int snext()\n\t        {\n\t                if (snumChars == -1)\n\t                        throw new InputMismatchException();\n\t                if (curChar >= snumChars)\n\t                {\n\t                        curChar = 0;\n\t                        try\n\t                        {\n\t                                snumChars = stream.read(buf);\n\t                        } catch (IOException e)\n\t                        {\n\t                                throw new InputMismatchException();\n\t                        }\n\t                        if (snumChars <= 0)\n\t                                return -1;\n\t                }\n\t                return buf[curChar++];\n\t        }\n\n\t        public int nextInt()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                int res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public long nextLong()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                long res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public int[] nextIntArray(int n)\n\t        {\n\t                int a[] = new int[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextInt();\n\t                }\n\t                return a;\n\t        }\n\n\t        public long[] nextLongArray(int n)\n\t        {\n\t                long a[] = new long[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextLong();\n\t                }\n\t                return a;\n\t        }\n\n\t        public String readString()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res.toString();\n\t        }\n\n\t        public String nextLine()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                        c = snext();\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isEndOfLine(c));\n\t                return res.toString();\n\t        }\n\n\t        public boolean isSpaceChar(int c)\n\t        {\n\t                if (filter != null)\n\t                        return filter.isSpaceChar(c);\n\t                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t        }\n\n\t        private boolean isEndOfLine(int c)\n\t        {\n\t                return c == '\\n' || c == '\\r' || c == -1;\n\t        }\n\n\t        public interface SpaceCharFilter\n\t        {\n\t                public boolean isSpaceChar(int ch);\n\t        }\n\n\t    }\n\t\t\n}\n\n//For Pair sorting\n\n//Arrays.sort(arr,new Comparator<Pair>() {\n//\t\t@Override public int compare(Pair p1, Pair p2) \n//{ \n//    return p1.x - p2.x; \n//} \n//});\n\n\n\n//Pair arr[] = new Pair[n]; \n//arr[0] = new Pair(10, 20); \nclass Pair { \n    int x; \n    int y; \n  \n    // Constructor \npublic Pair(int x, int y) \n    { \n        this.x = x; \n        this.y = y; \n    } \n} \n// class Compare { \n//\t  //void return by default.\n//     public  Pair[] compare(Pair arr[], int n) \n//    { \n//        // Comparator to sort the pair according to first element.\n//        Arrays.sort(arr, new Comparator<Pair>() { \n//            @Override public int compare(Pair p1, Pair p2) \n//            { \n//                return p1.x - p2.x; \n//            } \n//        }); \n//        \n//        \n//        return arr;\n//       /* for (int i = 0; i < n; i++) { \n//            System.out.print(arr[i].x + \" \" + arr[i].y + \" \"); \n//        } \n//        System.out.println(); */\n//    } \n//} \n//\n\n\n\nclass couple implements Comparable<couple>\n{ int x,y;\n  public couple(int m,int f) {\n \t x=m;\n \t y=f;\n  }\n\tpublic int compareTo(couple o) {\n\t\t\n\t\t \n\t\treturn x-o.x;\n\t}  \n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 537, "index": 537}
{"src": "\n// JAVA Code for Minimum number of jumps to reach end \nclass\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n// jumps[n-1] will hold the \n\n// result \n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n// if first element is 0, \n\n// end cannot be reached \n\n\njumps[\n0\n] = \n0\n; \n\n\n// Find the minimum number of jumps to reach arr[i] \n\n// from arr[0], and assign this value to jumps[i] \n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n// driver program to test above function \npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n} \n\n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "quadratic", "from": "CorCod", "problem": 538, "index": 538}
{"src": "\n// A Dynamic Programming based solution that uses table C[][] to \n// calculate the Binomial Coefficient \n\nclass\nBinomialCoefficient \n{ \n\n// Returns value of Binomial Coefficient C(n, k) \n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[][] = \nnew\nint\n[n+\n1\n][k+\n1\n]; \n\nint\ni, j; \n\n\n// Calculate value of Binomial Coefficient in bottom up manner \n\nfor\n(i = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(j = \n0\n; j <= min(i, k); j++) \n\n{ \n\n// Base Cases \n\nif\n(j == \n0\n|| j == i) \n\nC[i][j] = \n1\n; \n\n\n// Calculate value using previously stored values \n\nelse\n\nC[i][j] = C[i-\n1\n][j-\n1\n] + C[i-\n1\n][j]; \n\n} \n\n} \n\n\nreturn\nC[n][k]; \n\n} \n\n\n// A utility function to return minimum of two integers \n\nstatic\nint\nmin(\nint\na, \nint\nb) \n\n{ \n\nreturn\n(a<b)? a: b; \n\n} \n\n\n/* Driver program to test above function*/\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of C(\"\n+n+\n\",\"\n+k+\n\") is \"\n+binomialCoeff(n, k)); \n\n} \n} \n/*This code is contributed by Rajat Mishra*/", "complexity": "quadratic", "from": "CorCod", "problem": 539, "index": 539}
{"src": "import java.util.Scanner;;\npublic class JavaApplication2 {\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n= sc.nextInt();\n        int li[]=new int[n];\n        for(int i = 0 ;i<n;i++){\n            li[i]=sc.nextInt();\n        }\n        int max=0;\n         int c=0;\n        for(int i = 0;i<n;i++){\n           c=0;\n            for(int j=i;j<n;j++){\n                if(j!=n-1&&j!=0&&li[j]-li[j-1]==1&&li[j+1]-li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j!=n-1&&j==0&&li[j+1]-li[j]==1&&li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j==n-1&&j!=0&&li[j]-li[j-1]==1&&li[j]==1000){\n                    c++;\n                    i++;\n                }\n                else{ break;}\n            }\n            if(c>max){\n                max=c;\n            }\n        }\n        if(c>max){\n                max=c;\n            }\n        System.out.println(max);\n        \n       \n    }\n    \n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 540, "index": 540}
{"src": "\n// Java program to count number of triangles that can be \n// formed from given array \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nCountTriangles \n{ \n\n// Function to count all possible triangles with arr[] \n\n// elements \n\nstatic\nint\nfindNumberOfTriangles(\nint\narr[]) \n\n{ \n\nint\nn = arr.length; \n\n// Sort the array elements in non-decreasing order \n\nArrays.sort(arr); \n\n\n// Initialize count of triangles \n\nint\ncount = \n0\n; \n\n\n// Fix the first element. We need to run till n-3 as \n\n// the other two elements are selected from arr[i+1...n-1] \n\nfor\n(\nint\ni = \n0\n; i < n-\n2\n; ++i) \n\n{ \n\n// Initialize index of the rightmost third element \n\nint\nk = i + \n2\n; \n\n\n// Fix the second element \n\nfor\n(\nint\nj = i+\n1\n; j < n; ++j) \n\n{ \n\n/* Find the rightmost element which is smaller \n\nthan the sum of two fixed elements \n\nThe important thing to note here is, we use \n\nthe previous value of k. If value of arr[i] + \n\narr[j-1] was greater than arr[k], then arr[i] + \n\narr[j] must be greater than k, because the \n\narray is sorted. */\n\nwhile\n(k < n && arr[i] + arr[j] > arr[k]) \n\n++k; \n\n\n/* Total number of possible triangles that can be \n\nformed with the two fixed elements is k - j - 1. \n\nThe two fixed elements are arr[i] and arr[j]. All \n\nelements between arr[j+1] to arr[k-1] can form a \n\ntriangle with arr[i] and arr[j]. One is subtracted \n\nfrom k because k is incremented one extra in above \n\nwhile loop. k will always be greater than j. If j \n\nbecomes equal to k, then above loop will increment \n\nk, because arr[k] + arr[i] is always/ greater than \n\narr[k] */\n\nif\n(k>j) \n\ncount += k - j - \n1\n; \n\n} \n\n} \n\nreturn\ncount; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n21\n, \n22\n, \n100\n, \n101\n, \n200\n, \n300\n}; \n\nSystem.out.println(\n\"Total number of triangles is \"\n+ \n\nfindNumberOfTriangles(arr)); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "complexity": "quadratic", "from": "CorCod", "problem": 541, "index": 541}
{"src": "\n// Java program to find minimum removals \n// to make max-min <= K \nimport\njava.util.Arrays; \n\nclass\nGFG \n{ \n\nstatic\nint\nMAX=\n100\n; \n\nstatic\nint\ndp[][]=\nnew\nint\n[MAX][MAX]; \n\n\n// function to check all possible combinations \n\n// of removal and return the minimum one \n\nstatic\nint\ncountRemovals(\nint\na[], \nint\ni, \nint\nj, \nint\nk) \n\n{ \n\n// base case when all elements are removed \n\nif\n(i >= j) \n\nreturn\n0\n; \n\n\n// if condition is satisfied, no more \n\n// removals are required \n\nelse\nif\n((a[j] - a[i]) <= k) \n\nreturn\n0\n; \n\n\n// if the state has already been visited \n\nelse\nif\n(dp[i][j] != -\n1\n) \n\nreturn\ndp[i][j]; \n\n\n// when Amax-Amin>d \n\nelse\nif\n((a[j] - a[i]) > k) { \n\n\n// minimum is taken of the removal \n\n// of minimum element or removal \n\n// of the maximum element \n\ndp[i][j] = \n1\n+ Math.min(countRemovals(a, i + \n1\n, j, k), \n\ncountRemovals(a, i, j - \n1\n, k)); \n\n} \n\nreturn\ndp[i][j]; \n\n} \n\n\n// To sort the array and return the answer \n\nstatic\nint\nremovals(\nint\na[], \nint\nn, \nint\nk) \n\n{ \n\n// sort the array \n\nArrays.sort(a); \n\n\n// fill all stated with -1 \n\n// when only one element \n\nfor\n(\nint\n[] rows:dp) \n\nArrays.fill(rows,-\n1\n); \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\nelse\n\nreturn\ncountRemovals(a, \n0\n, n - \n1\n, k); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\na[] = { \n1\n, \n3\n, \n4\n, \n9\n, \n10\n, \n11\n, \n12\n, \n17\n, \n20\n}; \n\nint\nn = a.length; \n\nint\nk = \n4\n; \n\nSystem.out.print(removals(a, n, k)); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "quadratic", "from": "CorCod", "problem": 542, "index": 542}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class P1196D2 {\n\n    static boolean multipleIndependent = true;\n\n    void run() {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        char[] s = in.next().toCharArray();\n        int[] dp = new int[3];\n        char[] c = {'R', 'G', 'B'};\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < k; i++) {\n            dp[0] += s[i] == c[(i + 0) % 3] ? 0 : 1;\n            dp[1] += s[i] == c[(i + 1) % 3] ? 0 : 1;\n            dp[2] += s[i] == c[(i + 2) % 3] ? 0 : 1;\n        }\n        min = Math.min(Math.min(Math.min(dp[0], dp[1]), dp[2]), min);\n//        System.out.println(Arrays.toString(dp));\n        for (int i = k; i < n; i++) {\n            dp[0] += (s[i] == c[(i + 0) % 3] ? 0 : 1) - (s[i - k] == c[(i - k + 0) % 3] ? 0 : 1);\n            dp[1] += (s[i] == c[(i + 1) % 3] ? 0 : 1) - (s[i - k] == c[(i - k + 1) % 3] ? 0 : 1);\n            dp[2] += (s[i] == c[(i + 2) % 3] ? 0 : 1) - (s[i - k] == c[(i - k + 2) % 3] ? 0 : 1);\n            min = Math.min(Math.min(Math.min(dp[0], dp[1]), dp[2]), min);\n//            System.out.println(Arrays.toString(dp));\n        }\n        System.out.println(min);\n    }\n\n\n    /* -----: Template :----- */\n    static InputReader in = new InputReader(System.in);\n\n    public static void main(String[] args) {\n        P1196D2 p = new P1196D2();\n        int q = multipleIndependent ? in.nextInt() : 1;\n        while (q-- > 0) {\n            p.run();\n        }\n    }\n\n    int numLength(long n) {\n        int l = 0;\n        while (n > 0) {\n            n /= 10;\n            l++;\n        }\n        return l;\n    }\n\n    <R> long binarySearch(long lowerBound, long upperBound,\n            R value, Function<Long, R> generatorFunction, Comparator<R> comparator) {\n        if (lowerBound <= upperBound) {\n            long mid = (lowerBound + upperBound) / 2;\n            int compare = comparator.compare(generatorFunction.apply(mid), value);\n            if (compare == 0) {\n                return mid;\n            } else if (compare < 0) {\n                return binarySearch(mid + 1, upperBound, value, generatorFunction, comparator);\n            } else {\n                return binarySearch(lowerBound, mid - 1, value, generatorFunction, comparator);\n            }\n        } else {\n            return -1;\n        }\n    }\n\n    <T> Integer[] sortSimultaneously(T[] key, Comparator<T> comparator,\n            Object[]... moreArrays) {\n        int n = key.length;\n        for (Object[] array : moreArrays) {\n            if (array.length != n) {\n                throw new RuntimeException(\"Arrays must have equals lengths\");\n            }\n        }\n        Integer[] indices = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            indices[i] = i;\n        }\n        Comparator<Integer> delegatingComparator = (a, b) -> {\n            return comparator.compare(key[a], key[b]);\n        };\n        Arrays.sort(indices, delegatingComparator);\n        reorder(indices, key);\n        for (Object[] array : moreArrays) {\n            reorder(indices, array);\n        }\n        return indices;\n    }\n\n    void reorder(Integer[] indices, Object[] arr) {\n        if (indices.length != arr.length) {\n            throw new RuntimeException(\"Arrays must have equals lengths\");\n        }\n        int n = arr.length;\n        Object[] copy = new Object[n];\n        for (int i = 0; i < n; i++) {\n            copy[i] = arr[indices[i]];\n        }\n        System.arraycopy(copy, 0, arr, 0, n);\n    }\n\n    int prodMod(int a, int b, int mod) {\n        return (int) (((long) a) * b % mod);\n    }\n\n    long prodMod(long a, long b, long mod) {\n        long res = 0;\n        a %= mod;\n        b %= mod;\n        while (b > 0) {\n            if ((b & 1) > 0) {\n                res = (res + a) % mod;\n            }\n            a = (a << 1) % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    long sumMod(int[] b, long mod) {\n        long res = 0;\n        for (int i = 0; i < b.length; i++) {\n            res = (res + b[i] % mod) % mod;\n        }\n        return res;\n    }\n\n    long sumMod(long[] a, long mod) {\n        long res = 0;\n        for (int i = 0; i < a.length; i++) {\n            res = (res + a[i] % mod) % mod;\n        }\n        return res;\n    }\n\n    long sumProdMod(int[] a, long b, long mod) {\n        long res = sumMod(a, mod);\n        return prodMod(res, b, mod);\n    }\n\n    long sumProdMod(long[] a, long b, long mod) {\n        long res = sumMod(a, mod);\n        return prodMod(res, b, mod);\n    }\n\n    long sumProdMod(int[] a, int[] b, long mod) {\n        if (a.length != b.length) {\n            throw new RuntimeException(\"Arrays must have equals lengths\");\n        }\n        long res = 0;\n        for (int i = 0; i < a.length; i++) {\n            res = (res + prodMod(a[i], b[i], mod)) % mod;\n        }\n        return res;\n    }\n\n    long sumProdMod(long[] a, long[] b, long mod) {\n        if (a.length != b.length) {\n            throw new RuntimeException(\"Arrays must have equals lengths\");\n        }\n        long res = 0;\n        for (int i = 0; i < a.length; i++) {\n            res = (res + prodMod(a[i], b[i], mod)) % mod;\n        }\n        return res;\n    }\n\n    int[] toPrimitive(Integer[] arr) {\n        int[] res = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = arr[i];\n        }\n        return res;\n    }\n\n    int[][] toPrimitive(Integer[][] arr) {\n        int[][] res = new int[arr.length][];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = toPrimitive(arr[i]);\n        }\n        return res;\n    }\n\n    long[] toPrimitive(Long[] arr) {\n        long[] res = new long[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = arr[i];\n        }\n        return res;\n    }\n\n    long[][] toPrimitive(Long[][] arr) {\n        long[][] res = new long[arr.length][];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = toPrimitive(arr[i]);\n        }\n        return res;\n    }\n\n    Integer[] toWrapper(int[] arr) {\n        Integer[] res = new Integer[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = arr[i];\n        }\n        return res;\n    }\n\n    Integer[][] toWrapper(int[][] arr) {\n        Integer[][] res = new Integer[arr.length][];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = toWrapper(arr[i]);\n        }\n        return res;\n    }\n\n    Long[] toWrapper(long[] arr) {\n        Long[] res = new Long[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = arr[i];\n        }\n        return res;\n    }\n\n    Long[][] toWrapper(long[][] arr) {\n        Long[][] res = new Long[arr.length][];\n        for (int i = 0; i < arr.length; i++) {\n            res[i] = toWrapper(arr[i]);\n        }\n        return res;\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextInt();\n            }\n            return arr;\n        }\n\n        public <T> T[] nextIntArray(int n, Function<Integer, T> function, Class<T> c) {\n            T[] arr = (T[]) Array.newInstance(c, n);\n            for (int i = 0; i < n; i++) {\n                arr[i] = function.apply(nextInt());\n            }\n            return arr;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextLong();\n            }\n            return arr;\n        }\n\n        public <T> T[] nextLongArray(int n, Function<Long, T> function, Class<T> c) {\n            T[] arr = (T[]) Array.newInstance(c, n);\n            for (int i = 0; i < n; i++) {\n                arr[i] = function.apply(nextLong());\n            }\n            return arr;\n        }\n\n        public int[][] nextIntMap(int n, int m) {\n            int[][] map = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                map[i] = nextIntArray(m);\n            }\n            return map;\n        }\n\n        public long[][] nextLongMap(int n, int m) {\n            long[][] map = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                map[i] = nextLongArray(m);\n            }\n            return map;\n        }\n\n        public char[][] nextCharMap(int n) {\n            char[][] map = new char[n][];\n            for (int i = 0; i < n; i++) {\n                map[i] = next().toCharArray();\n            }\n            return map;\n        }\n\n        public void readColumns(Object[]... columns) {\n            int n = columns[0].length;\n            for (Object[] column : columns) {\n                if (column.length != n) {\n                    throw new RuntimeException(\"Arrays must have equals lengths\");\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                for (Object[] column : columns) {\n                    column[i] = read(column[i].getClass());\n                }\n            }\n        }\n\n        public <T> T read(Class<T> c) {\n            throw new UnsupportedOperationException(\"To be implemented\");\n        }\n\n    }\n\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 543, "index": 543}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n    \n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    public static void main(String args[] ) {\n        \n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] arr = new int[105];\n        \n        for(int i=0;i<m;i++){\n            int a = sc.nextInt();\n            arr[a]++;\n        }\n        \n        for(int i=1;i<=1000;i++){\n            int sum=0;\n            \n            for(int a:arr){\n                if(a!=0){\n                    sum+=(a/i);\n                }\n            }\n            \n            \n            if(sum<n){\n                System.out.println(i-1);\n                return;\n            }\n            \n        }\n    }\n\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 544, "index": 544}
{"src": "//package contest1196;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class D {\n\n\tpublic static int[][] dp = new int[200005][3];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tPrintWriter cout = new PrintWriter(System.out);\n\t\t\n\t\tint q = cin.nextInt();\n\t\tint[] a = new int[200005];\n\t\tint n, k;\n\t\twhile (q-- > 0) {\n\t\t\tn = cin.nextInt();\n\t\t\tk = cin.nextInt();\n\t\t\tString chuoi = cin.nextLine();\n\t\t\tchuoi = cin.nextLine();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tchar ch = chuoi.charAt(i-1);\n\t\t\t\tif (ch == 'R') a[i] = 1;\n\t\t\t\tif (ch == 'G') a[i] = 2;\n\t\t\t\tif (ch == 'B') a[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\t\tdp[i][x] = dp[i-1][x];\n\t\t\t\t\tif (a[i] != (x + i)%3) dp[i][x]++;\n\t\t\t\t}\n\t\t\t\n\t\t\tint res = 1000000007;\n\t\t\tfor (int i = k; i <= n; i++) \n\t\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\t\tres = Math.min(res, dp[i][x] - dp[i-k][x]);\n\t\t\t\t\t\n\t\t\tcout.println(res);\n\t\t}\n\t\tcout.close();\n\t}\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 545, "index": 545}
{"src": "\n// A Dynamic Programming solution for subset \n// sum problem \nclass\nGFG { \n\n\n// Returns true if there is a subset of \n\n// set[] with sun equal to given sum \n\nstatic\nboolean\nisSubsetSum(\nint\nset[], \n\nint\nn, \nint\nsum) \n\n{ \n\n// The value of subset[i][j] will be \n\n// true if there is a subset of \n\n// set[0..j-1] with sum equal to i \n\nboolean\nsubset[][] = \n\nnew\nboolean\n[sum+\n1\n][n+\n1\n]; \n\n\n// If sum is 0, then answer is true \n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nsubset[\n0\n][i] = \ntrue\n; \n\n\n// If sum is not 0 and set is empty, \n\n// then answer is false \n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\nsubset[i][\n0\n] = \nfalse\n; \n\n\n// Fill the subset table in botton \n\n// up manner \n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\n{ \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) \n\n{ \n\nsubset[i][j] = subset[i][j-\n1\n]; \n\nif\n(i >= set[j-\n1\n]) \n\nsubset[i][j] = subset[i][j] || \n\nsubset[i - set[j-\n1\n]][j-\n1\n]; \n\n} \n\n} \n\n\n/* // uncomment this code to print table \n\nfor (int i = 0; i <= sum; i++) \n\n{ \n\nfor (int j = 0; j <= n; j++) \n\nSystem.out.println (subset[i][j]); \n\n} */\n\n\nreturn\nsubset[sum][n]; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\nset[] = {\n3\n, \n34\n, \n4\n, \n12\n, \n5\n, \n2\n}; \n\nint\nsum = \n9\n; \n\nint\nn = set.length; \n\nif\n(isSubsetSum(set, n, sum) == \ntrue\n) \n\nSystem.out.println(\n\"Found a subset\"\n\n+ \n\" with given sum\"\n); \n\nelse\n\nSystem.out.println(\n\"No subset with\"\n\n+ \n\" given sum\"\n); \n\n} \n} \n\n/* This code is contributed by Rajat Mishra */", "complexity": "quadratic", "from": "CorCod", "problem": 546, "index": 546}
{"src": "\n// JAVA Code for Maximum length subsequence \n// with difference between adjacent elements \n// as either 0 or 1 \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// function to find maximum length subsequence \n\n// with difference between adjacent elements as \n\n// either 0 or 1 \n\npublic\nstatic\nint\nmaxLenSub(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmls[] = \nnew\nint\n[n], max = \n0\n; \n\n\n// Initialize mls[] values for all indexes \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmls[i] = \n1\n; \n\n\n// Compute optimized maximum length \n\n// subsequence values in bottom up manner \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(Math.abs(arr[i] - arr[j]) <= \n1\n\n&& mls[i] < mls[j] + \n1\n) \n\nmls[i] = mls[j] + \n1\n; \n\n\n// Store maximum of all 'mls' values in 'max' \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(max < mls[i]) \n\nmax = mls[i]; \n\n\n// required maximum length subsequence \n\nreturn\nmax; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n5\n, \n6\n, \n3\n, \n7\n, \n6\n, \n5\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum length subsequence = \"\n+ \n\nmaxLenSub(arr, n)); \n\n\n} \n} \n\n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "quadratic", "from": "CorCod", "problem": 547, "index": 547}
{"src": "\n// Java program to find Maximum path sum \n// start any column in row '0' and ends \n// up to any column in row 'n-1' \nimport\njava.util.*; \n\nclass\nGFG { \n\n\nstatic\nint\nN = \n4\n; \n\n\n// function find maximum sum path \n\nstatic\nint\nMaximumPath(\nint\nMat[][]) \n\n{ \n\nint\nresult = \n0\n; \n\n\n// creat 2D matrix to store the sum \n\n// of the path \n\nint\ndp[][] = \nnew\nint\n[N][N + \n2\n]; \n\n\n// initialize all dp matrix as '0' \n\nfor\n(\nint\n[] rows : dp) \n\nArrays.fill(rows, \n0\n); \n\n\n// copy all element of first column into \n\n// 'dp' first column \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ndp[\n0\n][i + \n1\n] = Mat[\n0\n][i]; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j <= N; j++) \n\ndp[i][j] = Math.max(dp[i - \n1\n][j - \n1\n], \n\nMath.max(dp[i - \n1\n][j], \n\ndp[i - \n1\n][j + \n1\n])) + \n\nMat[i][j - \n1\n]; \n\n\n// Find maximum path sum that end ups \n\n// at any column of last row 'N-1' \n\nfor\n(\nint\ni = \n0\n; i <= N; i++) \n\nresult = Math.max(result, dp[N - \n1\n][i]); \n\n\n// return maximum sum path \n\nreturn\nresult; \n\n} \n\n\n// driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nMat[][] = { { \n4\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n2\n, \n9\n, \n1\n, \n10\n}, \n\n{ \n15\n, \n1\n, \n3\n, \n0\n}, \n\n{ \n16\n, \n92\n, \n41\n, \n44\n} }; \n\n\nSystem.out.println(MaximumPath(Mat)); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "quadratic", "from": "CorCod", "problem": 548, "index": 548}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint l = 1000, r = 0, u = 1000, b = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++ ) {\n\t\t\tString str = in.next();\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tif(str.charAt(j) == 'B') {\n\t\t\t\t\tl = Math.min(j+1, l);\n\t\t\t\t\tr = Math.max(j+1, r);\n\t\t\t\t\tu = Math.min(i+1, u);\n\t\t\t\t\tb = Math.max(i+1, b);\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println((u+b)/2 + \" \" + (l+r)/2);\n\t\t\n\t\tin.close();\n\t}\n}\n\n\n\n", "complexity": "quadratic", "from": "CorCod", "problem": 549, "index": 549}
{"src": "\n// Java program for recursive level order traversal in spiral form \n\n/* A binary tree node has data, pointer to left child \n\nand a pointer to right child */\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n// Function to print the spiral traversal of tree \n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n/* ltr -> left to right. If this variable is set then the \n\ngiven label is traversed from left to right */\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n/*Revert ltr to traverse next level in opposite order*/\n\nltr = !ltr; \n\n} \n\n} \n\n\n/* Compute the \"height\" of a tree -- the number of \n\nnodes along the longest path from the root node \n\ndown to the farthest leaf node.*/\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n/* compute the height of each subtree */\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n/* use the larger one */\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n/* Print nodes at a given level */\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n/* Driver program to test the above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "quadratic", "from": "CorCod", "problem": 550, "index": 550}
{"src": "import com.sun.org.apache.xerces.internal.util.SynchronizedSymbolTable;\nimport jdk.management.cmm.SystemResourcePressureMXBean;\n\nimport java.awt.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.List;\nimport java.math.*;\n\npublic class Newbie {\n\n    static InputReader sc = new InputReader(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        solver s = new solver();\n        int t = 1;\n        while (t > 0) {\n            s.solve();\n            t--;\n        }\n        out.close();\n    }\n\n   /* static class descend implements Comparator<pair1> {\n        public int compare(pair1 o1, pair1 o2) {\n            if (o1.pop != o2.pop)\n                return (int) (o1.pop - o2.pop);\n            else\n                return o1.in - o2.in;\n        }\n    }*/\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n            token = null;\n        }\n\n        public String next() {\n            while (token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card {\n        long a;\n        int cnt;\n        int i;\n\n        public card(long a, int cnt, int i) {\n            this.a = a;\n            this.cnt = cnt;\n            this.i = i;\n        }\n    }\n\n    static class ascend implements Comparator<pair> {\n        public int compare(pair o1, pair o2) {\n            return o1.a - o2.a;\n        }\n    }\n\n    static class extra {\n\n        static boolean v[] = new boolean[100001];\n        static List<Integer> l = new ArrayList<>();\n        static int t;\n\n        static void shuffle(long a[]) {\n            List<Long> l = new ArrayList<>();\n            for (int i = 0; i < a.length; i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for (int i = 0; i < a.length; i++)\n                a[i] = l.get(i);\n        }\n\n        static long gcd(long a, long b) {\n            if (b == 0)\n                return a;\n            else\n                return gcd(b, a % b);\n        }\n\n        static boolean valid(int i, int j, int r, int c) {\n            if (i >= 0 && i < r && j >= 0 && j < c)\n                return true;\n            else\n                return false;\n        }\n\n        static void seive() {\n            for (int i = 2; i < 100001; i++) {\n                if (!v[i]) {\n                    t++;\n                    l.add(i);\n                    for (int j = 2 * i; j < 100001; j += i)\n                        v[j] = true;\n                }\n            }\n        }\n\n        static int binary(long a[], long val, int n) {\n            int mid = 0, l = 0, r = n - 1, ans = 0;\n            while (l <= r) {\n                mid = (l + r) >> 1;\n                if (a[mid] == val) {\n                    r = mid - 1;\n                    ans = mid;\n                } else if (a[mid] > val)\n                    r = mid - 1;\n                else {\n                    l = mid + 1;\n                    ans = l;\n                }\n            }\n            return (ans + 1);\n        }\n\n        static long fastexpo(int x, int y) {\n            long res = 1;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res *= x;\n                }\n                y = y >> 1;\n                x = x * x;\n            }\n            return res;\n        }\n\n        static long lfastexpo(int x, int y, int p) {\n            long res = 1;\n            x = x % p;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res = (res * x) % p;\n                }\n                y = y >> 1;\n                x = (x * x) % p;\n            }\n            return res;\n        }\n    }\n\n    static class pair {\n        int a;\n        int b;\n\n        public pair(int a, int i) {\n            this.a = a;\n            this.b = i;\n        }\n    }\n\n    static class pair1 {\n        pair p;\n        int in;\n\n        public pair1(pair a, int n) {\n            this.p = a;\n            this.in = n;\n        }\n    }\n\n    static long m = (long) 1e9 + 7;\n\n    static class solver {\n        void solve() {\n            int n = sc.nextInt();\n            int ans=0;\n            int a[]=new int[2*n];\n            for (int i = 0; i < 2 * n; i++) {\n               a[i]=sc.nextInt();\n            }\n            for(int i=0;i<2*n;i++)\n            {\n                if(a[i]>0)\n                {\n                    int j=0;\n                    for(j=i+1;a[i]!=a[j];j++)\n                    {\n                        if(a[j]>0)\n                            ans++;\n                    }\n                    a[j]=0;\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 551, "index": 551}
{"src": "\n/* Dynamic programming Java implementation \nof maximum product of an increasing \nsubsequence */\nimport\njava.util.Arrays; \nimport\njava.util.Collections; \n\nclass\nGFG { \n\n\n// Returns product of maximum product \n\n// increasing subsequence. \n\nstatic\nint\nlis(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\n[] mpis = \nnew\nint\n[n]; \n\nint\nmax = Integer.MIN_VALUE; \n\n\n/* Initialize MPIS values */\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmpis[i] = arr[i]; \n\n\n/* Compute optimized MPIS values \n\nconsidering every element as ending \n\nelement of sequence */\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && mpis[i] \n\n< (mpis[j] * arr[i])) \n\nmpis[i] = mpis[j] * arr[i]; \n\n\n/* Pick maximum of all product values \n\nusing for loop*/\n\nfor\n(\nint\nk = \n0\n; k < mpis.length; k++) \n\n{ \n\nif\n(mpis[k] > max) { \n\nmax = mpis[k]; \n\n} \n\n} \n\n\nreturn\nmax; \n\n} \n\n\n// Driver program to test above function \n\nstatic\npublic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] arr = { \n3\n, \n100\n, \n4\n, \n5\n, \n150\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(lis(arr, n)); \n\n} \n} \n\n// This code is contributed by parashar. ", "complexity": "quadratic", "from": "CorCod", "problem": 552, "index": 552}
{"src": " import java.util.Scanner;\n    public class New_Year_and_Curling {\n        static final double E = 0.00001;\n \n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n \n            int n = sc.nextInt();\n            int r = sc.nextInt();\n            double[] y = new double[n];\n            int arr[] = new int[n];\n \n            for (int i = 0; i < n; i++) {\n                arr[i] =sc.nextInt();\n                double top = r; // if we make it 0 and subtract from the result will get WA (do not know why!!!)\n                int x = arr[i];\n                for(int  j =0 ;j<i;j++)\n                {\n                    if(Math.abs(arr[j] -x )<=2*r) {\n \n                            top = Math.max(top  , y[j] + Math.sqrt((4 * r * r) - ((arr[j] - x) * (arr[j] - x))));\n \n                    }\n                }\n                y[i] = top ;\n                double res = y[i] ;\n                System.out.print(res+\" \");\n            }\n \n        }\n \n    }", "complexity": "quadratic", "from": "CorCod", "problem": 553, "index": 553}
{"src": "\nclass\nLeadersInArray \n{ \n\n/*Java Function to print leaders in an array */\n\nvoid\nprintLeaders(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nint\nj; \n\nfor\n(j = i + \n1\n; j < size; j++) \n\n{ \n\nif\n(arr[i] <= arr[j]) \n\nbreak\n; \n\n} \n\nif\n(j == size) \n// the loop didn't break \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nLeadersInArray lead = \nnew\nLeadersInArray(); \n\nint\narr[] = \nnew\nint\n[]{\n16\n, \n17\n, \n4\n, \n3\n, \n5\n, \n2\n}; \n\nint\nn = arr.length; \n\nlead.printLeaders(arr, n); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 554, "index": 554}
{"src": "\n// A Naive Java program to find \n// maximum sum rotation \nimport\njava.util.*; \nimport\njava.io.*; \n\nclass\nGFG { \n\n// Returns maximum value of i*arr[i] \nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n// Initialize result \nint\nres = Integer.MIN_VALUE; \n\n// Consider rotation beginning with i \n// for all possible values of i. \nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n// Initialize sum of current rotation \n\nint\ncurr_sum = \n0\n; \n\n\n// Compute sum of all values. We don't \n\n// actually rotation the array, but compute \n\n// sum by finding ndexes when arr[i] is \n\n// first element \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n// Update result if required \n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n} \n\n// This code is contributed by Sahil_Bansall ", "complexity": "quadratic", "from": "CorCod", "problem": 555, "index": 555}
{"src": "\n// Java program to check if there exist an edge whose \n// removal creates two trees of same size \n\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n// To calculate size of tree with given root \n\nint\ncount(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\nreturn\ncount(node.left) + count(node.right) + \n1\n; \n\n} \n\n\n// This function returns true if there is an edge \n\n// whose removal can divide the tree in two halves \n\n// n is size of tree \n\nboolean\ncheckRec(Node node, \nint\nn) \n\n{ \n\n// Base cases \n\nif\n(node == \nnull\n) \n\nreturn\nfalse\n; \n\n\n// Check for root \n\nif\n(count(node) == n - count(node)) \n\nreturn\ntrue\n; \n\n\n// Check for rest of the nodes \n\nreturn\ncheckRec(node.left, n) \n\n|| checkRec(node.right, n); \n\n} \n\n\n// This function mainly uses checkRec() \n\nboolean\ncheck(Node node) \n\n{ \n\n// Count total nodes in given tree \n\nint\nn = count(node); \n\n\n// Now recursively check all nodes \n\nreturn\ncheckRec(node, n); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n1\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nif\n(tree.check(tree.root)==\ntrue\n) \n\nSystem.out.println(\n\"YES\"\n); \n\nelse\n\nSystem.out.println(\n\"NO\"\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "complexity": "quadratic", "from": "CorCod", "problem": 556, "index": 556}
{"src": "\n// Java program to remove duplicates from unsorted \n// linked list \n\nclass\nLinkedList { \n\n\nstatic\nNode head; \n\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n/* Function to remove duplicates from an \n\nunsorted linked list */\n\nvoid\nremove_duplicates() { \n\nNode ptr1 = \nnull\n, ptr2 = \nnull\n, dup = \nnull\n; \n\nptr1 = head; \n\n\n/* Pick elements one by one */\n\nwhile\n(ptr1 != \nnull\n&& ptr1.next != \nnull\n) { \n\nptr2 = ptr1; \n\n\n/* Compare the picked element with rest \n\nof the elements */\n\nwhile\n(ptr2.next != \nnull\n) { \n\n\n/* If duplicate then delete it */\n\nif\n(ptr1.data == ptr2.next.data) { \n\n\n/* sequence of steps is important here */\n\ndup = ptr2.next; \n\nptr2.next = ptr2.next.next; \n\nSystem.gc(); \n\n} \nelse\n/* This is tricky */\n{ \n\nptr2 = ptr2.next; \n\n} \n\n} \n\nptr1 = ptr1.next; \n\n} \n\n} \n\n\nvoid\nprintList(Node node) { \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n12\n); \n\nlist.head.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n12\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next.next.next.next = \nnew\nNode(\n10\n); \n\n\nSystem.out.println(\n\"Linked List before removing duplicates : \\n \"\n); \n\nlist.printList(head); \n\n\nlist.remove_duplicates(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Linked List after removing duplicates : \\n \"\n); \n\nlist.printList(head); \n\n} \n} \n// This code has been contributed by Mayank Jaiswal ", "complexity": "quadratic", "from": "CorCod", "problem": 557, "index": 557}
{"src": "\n// Java implementation of simple method to find \n// minimum difference between any pair \n\nclass\nGFG \n{ \n\n// Returns minimum difference between any pair \n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n// Initialize difference as infinite \n\nint\ndiff = Integer.MAX_VALUE; \n\n\n// Find the min diff by comparing difference \n\n// of all possible pairs in given array \n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nfor\n(\nint\nj=i+\n1\n; j<n; j++) \n\nif\n(Math.abs((arr[i] - arr[j]) )< diff) \n\ndiff = Math.abs((arr[i] - arr[j])); \n\n\n// Return min diff \n\nreturn\ndiff; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 558, "index": 558}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class PartySweet {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt(), m = nextInt();\n\t\tint[] b = new int[n];\n\t\tint[] g = new int[m];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tb[i] = nextInt();\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tg[i] = nextInt();\n\t\tint total = 0;\n\t\tint max = 0, max2 = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(b[i] > b[max]) {\n\t\t\t\tmax2 = max;\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t\telse if(b[max2] < b[i])\n\t\t\t\tmax2 = i;\n\t\t}\n\t\ttotal += b[max] - b[max2];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(b[i] > g[j]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(i != max)\n\t\t\t\t\ttotal += b[i];\n\t\t\t\telse\n\t\t\t\t\ttotal += g[j];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(total);\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 559, "index": 559}
{"src": "\nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n/* Array should have at least two elements*/\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n/* Initialization of values */\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n} ", "complexity": "quadratic", "from": "CorCod", "problem": 560, "index": 560}
{"src": "\n/* Dynamic Programming Java \n\nimplementation of Maximum Sum \n\nIncreasing Subsequence (MSIS) \n\nproblem */\nclass\nGFG \n{ \n\n/* maxSumIS() returns the \n\nmaximum sum of increasing \n\nsubsequence in arr[] of size n */\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n/* Initialize msis values \n\nfor all indexes */\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n/* Compute maximum sum values \n\nin bottom up manner */\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n/* Pick maximum of all \n\nmsis values */\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n} \n\n// This code is contributed \n// by Rajat Mishra ", "complexity": "quadratic", "from": "CorCod", "problem": 561, "index": 561}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Codechef{\n      \n\n    public static void main(String []args){\n       Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n\t\tSet<HashSet> s3 = new HashSet<>();\n\n      \n         for(int j=0;j<n;j++){\n         \tString a=sc.next();\n         HashSet<Character> t = new HashSet<Character>();\n\t\t\tfor(char c:a.toCharArray()){\n\t\t\tt.add(c);\n\t\t\t}\n\n        s3.add(t);\n    \n          \n\n         }\n         System.out.println(s3.size());\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 562, "index": 562}
{"src": "\n// Java program to print \n// equal sum sets of array. \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// Function to print equal \n\n// sum sets of array. \n\nstatic\nvoid\nprintEqualSumSets(\nint\n[]arr, \n\nint\nn) \n\n{ \n\nint\ni, currSum, sum = \n0\n; \n\n\n// Finding sum of array elements \n\nfor\n(i = \n0\n; i < arr.length; i++) \n\nsum += arr[i]; \n\n\n// Check sum is even or odd. \n\n// If odd then array cannot \n\n// be partitioned. Print -1 \n\n// and return. \n\nif\n((sum & \n1\n) == \n1\n) \n\n{ \n\nSystem.out.print(\n\"-1\"\n); \n\nreturn\n; \n\n} \n\n\n// Divide sum by 2 to find \n\n// sum of two possible subsets. \n\nint\nk = sum >> \n1\n; \n\n\n// Boolean DP table to store \n\n// result of states. \n\n// dp[i,j] = true if there is a \n\n// subset of elements in first i \n\n// elements of array that has sum \n\n// equal to j. \n\nboolean\n[][]dp = \nnew\nboolean\n[n + \n1\n][k + \n1\n]; \n\n\n// If number of elements are zero, \n\n// then no sum can be obtained. \n\nfor\n(i = \n1\n; i <= k; i++) \n\ndp[\n0\n][i] = \nfalse\n; \n\n\n// Sum 0 can be obtained by \n\n// not selecting any element. \n\nfor\n(i = \n0\n; i <= n; i++) \n\ndp[i][\n0\n] = \ntrue\n; \n\n\n// Fill the DP table \n\n// in bottom up manner. \n\nfor\n(i = \n1\n; i <= n; i++) \n\n{ \n\nfor\n(currSum = \n1\n; \n\ncurrSum <= k; \n\ncurrSum++) \n\n{ \n\n\n// Excluding current element. \n\ndp[i][currSum] = dp[i - \n1\n][currSum]; \n\n\n// Including current element \n\nif\n(arr[i - \n1\n] <= currSum) \n\ndp[i][currSum] = dp[i][currSum] | \n\ndp[i - \n1\n][currSum - arr[i - \n1\n]]; \n\n} \n\n} \n\n\n// Required sets set1 and set2. \n\nList<Integer> set1 = \nnew\nArrayList<Integer>(); \n\nList<Integer> set2 = \nnew\nArrayList<Integer>(); \n\n\n// If partition is not possible \n\n// print -1 and return. \n\nif\n(!dp[n][k]) \n\n{ \n\nSystem.out.print(\n\"-1\\n\"\n); \n\nreturn\n; \n\n} \n\n\n// Start from last \n\n// element in dp table. \n\ni = n; \n\ncurrSum = k; \n\n\nwhile\n(i > \n0\n&& currSum >= \n0\n) \n\n{ \n\n\n// If current element does \n\n// not contribute to k, then \n\n// it belongs to set 2. \n\nif\n(dp[i - \n1\n][currSum]) \n\n{ \n\ni--; \n\nset2.add(arr[i]); \n\n} \n\n\n// If current element contribute \n\n// to k then it belongs to set 1. \n\nelse\nif\n(dp[i - \n1\n][currSum - arr[i - \n1\n]]) \n\n{ \n\ni--; \n\ncurrSum -= arr[i]; \n\nset1.add(arr[i]); \n\n} \n\n} \n\n\n// Print elements of both the sets. \n\nSystem.out.print(\n\"Set 1 elements: \"\n); \n\nfor\n(i = \n0\n; i < set1.size(); i++) \n\nSystem.out.print(set1.get(i) + \n\" \"\n); \n\n\nSystem.out.print(\n\"\\nSet 2 elements: \"\n); \n\n\nfor\n(i = \n0\n; i < set2.size(); i++) \n\nSystem.out.print(set2.get(i) + \n\" \"\n); \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = \nnew\nint\n[]{ \n5\n, \n5\n, \n1\n, \n11\n}; \n\nint\nn = arr.length; \n\nprintEqualSumSets(arr, n); \n\n} \n} \n\n// This code is contributed by \n// Manish Shaw(manishshaw1) ", "complexity": "quadratic", "from": "CorCod", "problem": 563, "index": 563}
{"src": "\n// Java program to implement sorting a \n// queue data structure \nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \nclass\nGFG \n{ \n\n// Queue elements after sortIndex are \n\n// already sorted. This function returns \n\n// index of minimum element from front to \n\n// sortIndex \n\npublic\nstatic\nint\nminIndex(Queue<Integer> list, \n\nint\nsortIndex) \n\n{ \n\nint\nmin_index = -\n1\n; \n\nint\nmin_value = Integer.MAX_VALUE; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\n\n// This is dequeue() in Java STL \n\nlist.poll(); \n\n\n// we add the condition i <= sortIndex \n\n// because we don't want to traverse \n\n// on the sorted part of the queue, \n\n// which is the right part. \n\nif\n(current <= min_value && i <= sortIndex) \n\n{ \n\nmin_index = i; \n\nmin_value = current; \n\n} \n\nlist.add(current); \n\n} \n\nreturn\nmin_index; \n} \n\n\n// Moves given minimum element \n\n// to rear of queue \n\npublic\nstatic\nvoid\ninsertMinToRear(Queue<Integer> list, \n\nint\nmin_index) \n\n{ \n\nint\nmin_value = \n0\n; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\nlist.poll(); \n\nif\n(i != min_index) \n\nlist.add(current); \n\nelse\n\nmin_value = current; \n\n} \n\nlist.add(min_value); \n\n} \n\n\npublic\nstatic\nvoid\nsortQueue(Queue<Integer> list) \n\n{ \n\nfor\n(\nint\ni = \n1\n; i <= list.size(); i++) \n\n{ \n\nint\nmin_index = minIndex(list,list.size() - i); \n\ninsertMinToRear(list, min_index); \n\n} \n\n} \n\n\n//Driver function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nQueue<Integer> list = \nnew\nLinkedList<Integer>(); \n\nlist.add(\n30\n); \n\nlist.add(\n11\n); \n\nlist.add(\n15\n); \n\nlist.add(\n4\n); \n\n\n//Sort Queue \n\nsortQueue(list); \n\n\n//print sorted Queue \n\nwhile\n(list.isEmpty()== \nfalse\n) \n\n{ \n\nSystem.out.print(list.peek() + \n\" \"\n); \n\nlist.poll(); \n\n} \n\n} \n} \n\n// This code is contributed by akash1295 ", "complexity": "quadratic", "from": "CorCod", "problem": 564, "index": 564}
{"src": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\nimport java.nio.charset.Charset;\nimport java.util.*;\n\nimport static java.lang.System.gc;\nimport static java.lang.System.out;\n\npublic class Main {\n\n    Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n\n    void solve() {\n\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        String s1 = scanner.nextLine();\n        String s2 = scanner.nextLine();\n\n\n        int ans = 0;\n        boolean a[] = new boolean[30];\n        boolean b[] = new boolean[30];\n\n        for (int i = 0; i < n; i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                ans ++;\n                a[s1.charAt(i)  - 'a'] = true;\n                b[s2.charAt(i)  - 'a'] = true;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (s1.charAt(i) != s2.charAt(i) && a[s2.charAt(i) - 'a'] && b[s1.charAt(i) - 'a']) {\n                for (int j = i + 1; j < n; j ++) {\n                    if (s1.charAt(i) == s2.charAt(j) && s1.charAt(j) == s2.charAt(i)) {\n                        out.println(ans - 2);\n                        out.println((i + 1) + \" \" + (j + 1));\n                        return;\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (s1.charAt(i) != s2.charAt(i) && (a[s2.charAt(i) - 'a'] || b[s1.charAt(i) - 'a'])) {\n                for (int j = i + 1; j < n; j ++) {\n                    if (s1.charAt(j) != s2.charAt(j) && (s1.charAt(i) == s2.charAt(j) || s1.charAt(j) == s2.charAt(i))) {\n                        out.println(ans - 1);\n                        out.println((i + 1) + \" \" + (j + 1));\n                        return;\n                    }\n                }\n            }\n        }\n\n        out.println(ans);\n        out.println(-1 + \" \" + -1);\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 565, "index": 565}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Solution {\n    private static int[] dx = {\n            -1, -1, -1,\n            0, 0,\n            1, 1, 1};\n    private static int[] dy = {\n            -1, 0, 1,\n            -1, 1,\n            -1, 0, 1};\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\n        int r = in.nextInt();\n        int c = in.nextInt();\n        boolean[][] m = new boolean[r + 1][c + 1];\n        boolean[][] inp = new boolean[r + 1][c + 1];\n        for (int i = 0; i < r; i++) {\n            String s = in.next();\n            //System.out.println(m[i]);\n            for (int j = 0; j < s.length(); j++) {\n                if (s.charAt(j) == '#') {\n                    m[i][j] = true;\n                    inp[i][j] = true;\n                }\n            }\n        }\n\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                if (canPress(i, j, r, c, inp)) {\n\n                    // make press\n                    for (int k = 0; k < 8; k++) {\n                        int xi = i + dx[k];\n                        int yi = j + dy[k];\n                        m[xi][yi] = false;\n                    }\n\n                }\n            }\n        }\n        boolean isLeftAny = false;\n        for (int i = 0; i < r && !isLeftAny; i++) {\n            for (int j = 0; j < c && !isLeftAny; j++) {\n                if (m[i][j]) {\n                    isLeftAny = true;\n                    break;\n                }\n            }\n        }\n        if(isLeftAny){\n            System.out.println(\"NO\");\n        }else{\n            System.out.println(\"YES\");\n        }\n    }\n\n    private static boolean canPress(int x, int y, int r, int c, boolean[][] inp) {\n        for (int i = 0; i < 8; i++) {\n            int xi = x + dx[i];\n            int yi = y + dy[i];\n            if (xi < 0 || yi < 0) {\n                return false;\n            }\n            if (xi >= r || yi >= c) {\n                return false;\n            }\n            if(!inp[xi][yi]){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n", "complexity": "quadratic", "from": "CorCod", "problem": 566, "index": 566}
{"src": "\n// A simple C++ program to count number of \n//substrings starting and ending with 1 \n\nclass\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[],\nint\nn) \n\n{ \n\nint\nres = \n0\n; \n// Initialize result \n\n\n// Pick a starting point \n\nfor\n(\nint\ni = \n0\n; i<n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\n{ \n\n// Search for all possible ending point \n\nfor\n(\nint\nj = i + \n1\n; j< n; j++) \n\n{ \n\nif\n(str[j] == \n'1'\n) \n\nres++; \n\n} \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n// Driver program to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str,n)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 567, "index": 567}
{"src": "\n// Java program to find the longest subsequence \n// such that the difference between adjacent \n// elements of the subsequence is one. \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Function to find the length of longest \n\n// subsequence \n\nstatic\nint\nlongestSubseqWithDiffOne(\nint\narr[], \n\nint\nn) \n\n{ \n\n// Initialize the dp[] array with 1 as a \n\n// single element will be of 1 length \n\nint\ndp[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i< n; i++) \n\ndp[i] = \n1\n; \n\n\n// Start traversing the given array \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n// Compare with all the previous \n\n// elements \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n// If the element is consecutive \n\n// then consider this subsequence \n\n// and update dp[i] if required. \n\nif\n((arr[i] == arr[j] + \n1\n) || \n\n(arr[i] == arr[j] - \n1\n)) \n\n\ndp[i] = Math.max(dp[i], dp[j]+\n1\n); \n\n} \n\n} \n\n\n// Longest length will be the maximum \n\n// value of dp array. \n\nint\nresult = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n ; i++) \n\nif\n(result < dp[i]) \n\nresult = dp[i]; \n\nreturn\nresult; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Longest subsequence with one \n\n// difference is \n\n// {1, 2, 3, 4, 3, 2} \n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n3\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(longestSubseqWithDiffOne( \n\narr, n)); \n\n} \n} \n\n// This code is contributed by Prerna Saini ", "complexity": "quadratic", "from": "CorCod", "problem": 568, "index": 568}
{"src": "\n// Java program to find n'th Bell number \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Function to find n'th Bell Number \n\nstatic\nint\nbellNumber(\nint\nn) \n\n{ \n\nint\n[][] bell = \nnew\nint\n[n+\n1\n][n+\n1\n]; \n\nbell[\n0\n][\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n// Explicitly fill for j = 0 \n\nbell[i][\n0\n] = bell[i-\n1\n][i-\n1\n]; \n\n\n// Fill for remaining values of j \n\nfor\n(\nint\nj=\n1\n; j<=i; j++) \n\nbell[i][j] = bell[i-\n1\n][j-\n1\n] + bell[i][j-\n1\n]; \n\n} \n\n\nreturn\nbell[n][\n0\n]; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nfor\n(\nint\nn=\n0\n; n<=\n5\n; n++) \n\nSystem.out.println(\n\"Bell Number \"\n+ n + \n\n\" is \"\n+bellNumber(n)); \n\n} \n} \n\n// This code is contributed by Pramod Kumar ", "complexity": "quadratic", "from": "CorCod", "problem": 569, "index": 569}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static void solve(InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        String[] sa = new String[n];\n        for (int i = 0; i < n; i++) {\n            sa[i] = in.next();\n        }\n\n        Set<Integer> switches = new HashSet<>();\n        for (int i = 0; i < m; i++) {\n            int cnt = 0, swtch = -1;\n            for (int j = 0; j < n; j++) {\n                if (sa[j].charAt(i) == '1') {\n                    cnt++;\n                    swtch = j;\n                    if (cnt > 1)\n                        break;\n                }\n            }\n\n            if (cnt == 1) {\n                switches.add(swtch);\n            }\n        }\n\n        out.print(switches.size() == n ? \"NO\" : \"YES\");\n    }\n\n    private static void shuffleArray(int[] array) {\n        int index;\n        Random random = new Random();\n        for (int i = array.length - 1; i > 0; i--) {\n            index = random.nextInt(i + 1);\n            if (index != i) {\n                array[index] ^= array[i];\n                array[i] ^= array[index];\n                array[index] ^= array[i];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        solve(in, out);\n        in.close();\n        out.close();\n    }\n\n    private static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        InputReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n            st = null;\n        }\n\n        String nextLine() {\n            String line = null;\n            try {\n                line = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return line;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = nextLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class OutputWriter {\n        BufferedWriter bw;\n\n        OutputWriter(OutputStream os) {\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n        }\n\n        void print(int i) {\n            print(Integer.toString(i));\n        }\n\n        void println(int i) {\n            println(Integer.toString(i));\n        }\n\n        void print(long l) {\n            print(Long.toString(l));\n        }\n\n        void println(long l) {\n            println(Long.toString(l));\n        }\n\n        void print(double d) {\n            print(Double.toString(d));\n        }\n\n        void println(double d) {\n            println(Double.toString(d));\n        }\n\n        void print(boolean b) {\n            print(Boolean.toString(b));\n        }\n\n        void println(boolean b) {\n            println(Boolean.toString(b));\n        }\n\n        void print(char c) {\n            try {\n                bw.write(c);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(char c) {\n            println(Character.toString(c));\n        }\n\n        void print(String s) {\n            try {\n                bw.write(s);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(String s) {\n            print(s);\n            print('\\n');\n        }\n\n        void close() {\n            try {\n                bw.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 570, "index": 570}
{"src": "\n// Java program to print postorder \n// traversal from preorder and \n// inorder traversals \nimport\njava.util.Arrays; \n\nclass\nGFG \n{ \n\n// A utility function to search x in arr[] of size n \nstatic\nint\nsearch(\nint\narr[], \nint\nx, \nint\nn) \n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] == x) \n\nreturn\ni; \n\nreturn\n-\n1\n; \n} \n\n// Prints postorder traversal from \n// given inorder and preorder traversals \nstatic\nvoid\nprintPostOrder(\nint\nin1[], \n\nint\npre[], \nint\nn) \n{ \n\n// The first element in pre[] is \n\n// always root, search it in in[] \n\n// to find left and right subtrees \n\nint\nroot = search(in1, pre[\n0\n], n); \n\n\n// If left subtree is not empty, \n\n// print left subtree \n\nif\n(root != \n0\n) \n\nprintPostOrder(in1, Arrays.copyOfRange(pre, \n1\n, n), root); \n\n\n// If right subtree is not empty, \n\n// print right subtree \n\nif\n(root != n - \n1\n) \n\nprintPostOrder(Arrays.copyOfRange(in1, root+\n1\n, n), \n\nArrays.copyOfRange(pre, \n1\n+root, n), n - root - \n1\n); \n\n\n// Print root \n\nSystem.out.print( pre[\n0\n] + \n\" \"\n); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nin1[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nn = in1.length; \n\nSystem.out.println(\n\"Postorder traversal \"\n); \n\nprintPostOrder(in1, pre, n); \n} \n} \n// This code is contributed by Arnab Kundu ", "complexity": "quadratic", "from": "CorCod", "problem": 571, "index": 571}
{"src": "//package codeforces;\n\nimport java.util.Scanner;\n\npublic class Fingerprints {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint[] code = new int[scanner.nextInt()];\n\t\tint[] prints = new int[scanner.nextInt()];\n\n\t\tfor (int i = 0; i < code.length; i++) {\n\t\t\tcode[i] = scanner.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < prints.length; i++) {\n\t\t\tprints[i] = scanner.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < code.length; i++) {\n\t\t\tfor (int j = 0; j < prints.length; j++) {\n\t\t\t\tif (code[i] == prints[j]) {\n\t\t\t\t\tSystem.out.print(prints[j] + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanner.close();\n\t}\n\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 572, "index": 572}
{"src": "//q4\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\npublic class q4 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        \n        int query = in.nextInt();\n        \n        while (query -- > 0) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            \n            char[] arr = new char[n];\n            //slot all n into char array\n            String code = in.next();\n            for (int i = 0; i < n; i++) {\n                arr[i] = code.charAt(i);\n                \n            }\n            \n            //R, G, B cycle\n            int r = 0;\n            int g = 0;\n            int b = 0;\n            \n            for (int i = 0; i < k; i++) {\n                if (i % 3 == 0) {\n                    if (arr[i] == 'R') {g++; b++;}\n                    else if (arr[i] == 'G') {r++; b++;}\n                    else {r++; g++;} //if is 'B'\n                } else if (i % 3 == 1) {\n                    if (arr[i] == 'G') {g++; b++;}\n                    else if (arr[i] == 'B') {r++; b++;}\n                    else {r++; g++;} //if is 'R'\n                } else { //if mod 3 is 2\n                    if (arr[i] == 'B') {g++; b++;}\n                    else if (arr[i] == 'R') {r++; b++;}\n                    else {r++; g++;} //if is 'G'     \n                }\n            }\n            \n            //starting from kth position, if different then add 1, and check (j-k)th position\n            int rMin = r;\n            int gMin = g;\n            int bMin = b;\n            for (int j = k; j < n; j++) {\n                //R cycle\n                if ((j % 3 == 0 && arr[j] != 'R') ||  \n                    (j % 3 == 1 && arr[j] != 'G') ||\n                    (j % 3 == 2 && arr[j] != 'B')) {\n                    r++;\n                }\n                //R cycle \n                if (((j - k) % 3 == 0 && arr[j - k] != 'R') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'G') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'B')) {\n                    r--;\n                }\n                rMin = Math.min(r, rMin);\n                //G cycle\n                if ((j % 3 == 0 && arr[j] != 'G') ||  \n                    (j % 3 == 1 && arr[j] != 'B') ||\n                    (j % 3 == 2 && arr[j] != 'R')) {\n                    g++;\n                } \n                if (((j - k) % 3 == 0 && arr[j - k] != 'G') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'B') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'R')) {\n                    g--;\n                }      \n                gMin = Math.min(gMin, g);\n                //B cycle\n                if ((j % 3 == 0 && arr[j] != 'B') ||  \n                    (j % 3 == 1 && arr[j] != 'R') ||\n                    (j % 3 == 2 && arr[j] != 'G')) {\n                    b++;\n                }       \n                if (((j - k) % 3 == 0 && arr[j - k] != 'B') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'R') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'G')) {\n                    b--;\n                } \n                bMin = Math.min(bMin, b);\n                \n            }\n            \n            System.out.println(Math.min(Math.min(rMin, gMin), bMin));\n            \n        }\n        \n    } \n    \n}", "complexity": "quadratic", "from": "CorCod", "problem": 573, "index": 573}
{"src": "\n// Java program to Count elements which \n// divides all numbers in range L-R \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// function to count element \n// Time complexity O(n^2) worst case \nstatic\nint\nanswerQuery(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n{ \n\n// answer for query \n\nint\ncount = \n0\n; \n\n\n// 0 based index \n\nl = l - \n1\n; \n\n\n// iterate for all elements \n\nfor\n(\nint\ni = l; i < r; i++) \n\n{ \n\nint\nelement = a[i]; \n\nint\ndivisors = \n0\n; \n\n\n// check if the element divides \n\n// all numbers in range \n\nfor\n(\nint\nj = l; j < r; j++) \n\n{ \n\n// no of elements \n\nif\n(a[j] % a[i] == \n0\n) \n\ndivisors++; \n\nelse\n\nbreak\n; \n\n} \n\n\n// if all elements are divisible by a[i] \n\nif\n(divisors == (r - l)) \n\ncount++; \n\n} \n\n\n// answer for every query \n\nreturn\ncount; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = { \n1\n, \n2\n, \n3\n, \n5\n}; \n\nint\nn = a.length; \n\n\nint\nl = \n1\n, r = \n4\n; \n\nSystem.out.println( answerQuery(a, n, l, r)); \n\n\nl = \n2\n; r = \n4\n; \n\nSystem.out.println( answerQuery(a, n, l, r)); \n} \n} \n\n// This code is contributed by anuj_67.. ", "complexity": "quadratic", "from": "CorCod", "problem": 574, "index": 574}
{"src": "import java.util.*;\nimport java.math.*;\npublic class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int a[]=new int[m+1];\n        int i,j;\n        int c=0;\n        for(i=0;i<n;i++)\n        {\n            int l=scan.nextInt();\n            int r=scan.nextInt();\n            for(j=l;j<=r;j++)\n            {\n                if(a[j]!=1)\n                {\n                    a[j]=1;\n                    c++;\n                }\n            }\n        }\n        System.out.println(m-c);\n        for(i=1;i<=m;i++)\n        {\n            if(a[i]==0)\n            {\n                System.out.print(i+\" \");\n            }\n        }\n    }\n}", "complexity": "quadratic", "from": "CorCod", "problem": 575, "index": 575}
{"src": "import java.util.*;\nimport java.io.*;\n \npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\t\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tvoid run(){\n\t    int q=in.nextInt();\n\t    for(int i=0;i<q;i++){\n\t        out.println(work());\n\t    }\n\t    out.flush();\n\t}\n\tint work() {\t\t\n\t\tint n=in.nextInt();\n\t    int k=in.nextInt();\n\t    String str=in.next();\n\t    char[] chs=new char[]{'R','G','B'};\n\t    int c1=0,c2=0,c3=0;\n\t    int ret=99999999;\n\t    for(int i=0,p1=0,p2=1,p3=2;i<n;i++,p1=(p1+1)%3,p2=(p2+1)%3,p3=(p3+1)%3){\n\t        char ch=str.charAt(i);\n\t        //c1\n\t        if(ch!=chs[p1]){\n\t            c1++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p1-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c1--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c1);\n\t        }\n\t        \n\t        //c2\n\t        if(ch!=chs[p2]){\n\t            c2++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p2-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c2--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c2);\n\t        }\n\t        \n\t        //c3\n\t        if(ch!=chs[p3]){\n\t            c3++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p3-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c3--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c3);\n\t        }\n\t    } \n\t    return ret;\n\t   \n\t}\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 576, "index": 576}
{"src": "import java.io.*;\nimport java.lang.*;\npublic class CF1003E{\n    public static void main(String args[]) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int d = Integer.parseInt(s[1]);\n        int k = Integer.parseInt(s[2]);\n        StringBuffer sb = new StringBuffer();\n        int[] rem = new int[n];\n        int[] deg = new int[n];\n        int i = 0;\n        if(k == 1){\n            if(n <= 2){\n\n            }else{\n                System.out.println(\"NO\");\n                return;\n            }\n        }\n        for(i=0;i<d;i++){\n            if(i>=n-1){\n                System.out.println(\"NO\");\n                return;\n            }\n            sb.append((i+1) +\" \" + (i+2)+\"\\n\");\n            rem[i] = Math.min(i, d-i);\n            deg[i]++;\n            if(i+1<n)\n            deg[i+1]++;\n        }\n        if(i<n){\n            rem[i] = 0;\n            deg[i] = 1;\n        }\n        i++;\n        int j  = 0;\n        for(;i<n;i++){\n            //For all remaining Nodes\n            while(true){\n                if(j>=n){\n                    System.out.println(\"NO\");\n                    return;\n                }\n                if(rem[j] > 0 && deg[j]<k){\n                    deg[j]++;\n                    rem[i] = rem[j] - 1;\n                    sb.append((j+1)+\" \"+(i+1)+\"\\n\");\n                    deg[i]++;\n                    break;\n                }else{\n                    j++;\n                }\n            }\n        }\n        System.out.println(\"YES\");\n        System.out.println(sb);\n    }\n}\n", "complexity": "quadratic", "from": "CorCod", "problem": 577, "index": 577}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author gaidash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            final int SIZE = 256;\n            final int UNDEF = -1;\n\n            int nPixels = in.nextInt();\n            int groupSize = in.nextInt();\n            int[] a = in.nextIntArray(nPixels);\n            boolean[] exists = new boolean[SIZE];\n            int[] left = new int[SIZE];\n            int[] right = new int[SIZE];\n            int[] ret = new int[nPixels];\n            Arrays.fill(ret, UNDEF);\n\n            for (int i = 0; i < nPixels; i++) {\n                for (int p = 0; p < SIZE; p++) {\n                    if (exists[p] && left[p] <= a[i] && a[i] <= right[p]) {\n                        ret[i] = left[p];\n                        left[a[i]] = left[p];\n                        right[a[i]] = right[p];\n                        break;\n                    }\n                }\n                if (ret[i] == UNDEF) {\n                    int l = Math.max(a[i] - groupSize + 1, 0);\n                    int r = l + groupSize - 1;\n                    for (int p = a[i] - 1; p >= 0; p--) {\n                        if (exists[p]) {\n                            if (p >= l) {\n                                int d = p - l;\n                                l = p + 1;\n                                r += d + 1;\n                            }\n                            if (right[p] >= l) {\n                                right[p] = l - 1;\n                            }\n                        }\n                    }\n                    for (int p = a[i] + 1; p < SIZE; p++) {\n                        if (exists[p] && left[p] <= r) {\n                            r = left[p] - 1;\n                        }\n                    }\n                    left[a[i]] = l;\n                    right[a[i]] = r;\n                    ret[i] = l;\n                }\n                exists[a[i]] = true;\n            }\n//        for (int p : a) {\n//            System.out.println(\"Segment for pixel \" + p + \" = \" + \"(\" + left[p] + \" , \" + right[p] + \")\");\n//        }\n\n            out.print(ret);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "from": "CorCod", "problem": 578, "index": 578}
{"src": "\n// Java program to CountKSubStr number of substrings \n// with exactly distinct characters in a given string \nimport\njava.util.Arrays; \n\npublic\nclass\nCountKSubStr \n{ \n\n// Function to count number of substrings \n\n// with exactly k unique characters \n\nint\ncountkDist(String str, \nint\nk) \n\n{ \n\n// Initialize result \n\nint\nres = \n0\n; \n\n\nint\nn = str.length(); \n\n\n// To store count of characters from 'a' to 'z' \n\nint\ncnt[] = \nnew\nint\n[\n26\n]; \n\n\n// Consider all substrings beginning with \n\n// str[i] \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndist_count = \n0\n; \n\n\n// Initializing count array with 0 \n\nArrays.fill(cnt, \n0\n); \n\n\n// Consider all substrings between str[i..j] \n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n// If this is a new character for this \n\n// substring, increment dist_count. \n\nif\n(cnt[str.charAt(j) - \n'a'\n] == \n0\n) \n\ndist_count++; \n\n\n// Increment count of current character \n\ncnt[str.charAt(j) - \n'a'\n]++; \n\n\n// If distinct character count becomes k, \n\n// then increment result. \n\nif\n(dist_count == k) \n\nres++; \n\n} \n\n} \n\n\nreturn\nres; \n\n} \n\n\n// Driver Program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountKSubStr ob = \nnew\nCountKSubStr(); \n\nString ch = \n\"abcbaa\"\n; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Total substrings with exactly \"\n+ \n\nk + \n\" distinct characters : \"\n\n+ ob.countkDist(ch, k)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 579, "index": 579}
{"src": "\n// Efficient java program to count total number \n// of special sequences of length n where \nclass\nSequences \n{ \n\n// DP based function to find the number of special \n\n// sequences \n\nstatic\nint\ngetTotalNumberOfSequences(\nint\nm, \nint\nn) \n\n{ \n\n// define T and build in bottom manner to store \n\n// number of special sequences of length n and \n\n// maximum value m \n\nint\nT[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\nfor\n(\nint\ni=\n0\n; i<m+\n1\n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<n+\n1\n; j++) \n\n{ \n\n// Base case : If length of sequence is 0 \n\n// or maximum value is 0, there cannot \n\n// exist any special sequence \n\nif\n(i == \n0\n|| j == \n0\n) \n\nT[i][j] = \n0\n; \n\n\n// if length of sequence is more than \n\n// the maximum value, special sequence \n\n// cannot exist \n\nelse\nif\n(i < j) \n\nT[i][j] = \n0\n; \n\n\n// If length of sequence is 1 then the \n\n// number of special sequences is equal \n\n// to the maximum value \n\n// For example with maximum value 2 and \n\n// length 1, there can be 2 special \n\n// sequences {1}, {2} \n\nelse\nif\n(j == \n1\n) \n\nT[i][j] = i; \n\n\n// otherwise calculate \n\nelse\n\nT[i][j] = T[i-\n1\n][j] + T[i/\n2\n][j-\n1\n]; \n\n} \n\n} \n\nreturn\nT[m][n]; \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nm = \n10\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(\n\"Total number of possible sequences \"\n+ \n\ngetTotalNumberOfSequences(m, n)); \n\n} \n} ", "complexity": "quadratic", "from": "CorCod", "problem": 580, "index": 580}
{"src": "\n// Java program to check if Binary tree is sum tree or not \n\n/* A binary tree node has data, left child and right child */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right, nextRight; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = nextRight = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* A utility function to get the sum of values in tree with root \n\nas root */\n\nint\nsum(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nreturn\nsum(node.left) + node.data + sum(node.right); \n\n} \n\n\n/* returns 1 if sum property holds for the given \n\nnode and both of its children */\n\nint\nisSumTree(Node node) \n\n{ \n\nint\nls, rs; \n\n\n/* If node is NULL or it's a leaf node then \n\nreturn true */\n\nif\n((node == \nnull\n) || (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n1\n; \n\n\n/* Get sum of nodes in left and right subtrees */\n\nls = sum(node.left); \n\nrs = sum(node.right); \n\n\n/* if the node and both of its children satisfy the \n\nproperty return 1 else 0*/\n\nif\n((node.data == ls + rs) && (isSumTree(node.left) != \n0\n) \n\n&& (isSumTree(node.right)) != \n0\n) \n\nreturn\n1\n; \n\n\nreturn\n0\n; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n26\n); \n\ntree.root.left = \nnew\nNode(\n10\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n3\n); \n\n\nif\n(tree.isSumTree(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree is a sum tree\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree is not a sum tree\"\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "quadratic", "from": "CorCod", "problem": 581, "index": 581}
{"src": "\n// Java Program to find max subarray \n// sum excluding some elements \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Function to check the element \n\n// present in array B \n\nstatic\nboolean\nisPresent(\nint\nB[], \n\nint\nm, \n\nint\nx) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(B[i] == x) \n\nreturn\ntrue\n; \n\n\nreturn\nfalse\n; \n\n} \n\n\n// Utility function for findMaxSubarraySum() \n\n// with the following parameters \n\n// A => Array A, \n\n// B => Array B, \n\n// n => Number of elements in Array A, \n\n// m => Number of elements in Array B \n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n// set max_so_far to INT_MIN \n\nint\nmax_so_far = -\n2147483648\n, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// if the element is present in B, \n\n// set current max to 0 and move to \n\n// the next element \n\nif\n(isPresent(B, m, A[i])) { \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n// Proceed as in Kadane's Algorithm \n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n// Wrapper for findMaxSubarraySumUtil() \n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n// This case will occour when all \n\n// elements of A are are present \n\n// in B, thus no subarray can be formed \n\nif\n(maxSubarraySum == -\n2147483648\n) { \n\nSystem.out.println(\n\"Maximum Subarray Sum\"\n\n+ \n\" \"\n+ \n\"can't be found\"\n); \n\n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"The Maximum Subarray Sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\nA[] = { \n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = { \n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n// Calling Function \n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n} \n\n// This code is contributed by Ajit. ", "complexity": "quadratic", "from": "CorCod", "problem": 582, "index": 582}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E solver = new E();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.ni(), K = in.ni();\n            long mod = 998244353;\n            long[][] dp = new long[n + 1][n + 1];\n            for (int lim = 1; lim <= n; lim++) {\n                long sum = 1;\n                dp[0][lim] = 1;\n                for (int i = 1; i <= n; i++) {\n                    dp[i][lim] = (dp[i][lim] + sum) % mod;\n                    sum = (sum + dp[i][lim]) % mod;\n                    if (i >= lim)\n                        sum = (sum - dp[i - lim][lim] + mod) % mod;\n                }\n            }\n            long ans = 0;\n            for (int k = 1; k < Math.min(K, n + 1); k++) {\n                long h = dp[n][k] - dp[n][k - 1];\n                int lim = K / k;\n                if (K % k == 0)\n                    lim--;\n                if (lim > n)\n                    lim = n;\n                ans += dp[n][lim] * h % mod;\n            }\n            out.println(2 * ans % mod);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n    }\n}\n\n", "complexity": "quadratic", "from": "CorCod", "problem": 583, "index": 583}
{"src": "\n// Java program to construct a tree using inorder and preorder traversal \n\n/* A binary tree node has data, pointer to left child \n\nand a pointer to right child */\nclass\nNode { \n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\nstatic\nint\npreIndex = \n0\n; \n\n\n/* Recursive function to construct binary of size len from \n\nInorder traversal in[] and Preorder traversal pre[]. \n\nInitial values of inStrt and inEnd should be 0 and len -1. \n\nThe function doesn't do any error checking for cases where \n\ninorder and preorder do not form a tree */\n\nNode buildTree(\nchar\nin[], \nchar\npre[], \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n/* Pick current node from Preorder traversal using preIndex \n\nand increment preIndex */\n\nNode tNode = \nnew\nNode(pre[preIndex++]); \n\n\n/* If this node has no children then return */\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n/* Else find the index of this node in Inorder traversal */\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n/* Using index in Inorder traversal, construct left and \n\nright subtress */\n\ntNode.left = buildTree(in, pre, inStrt, inIndex - \n1\n); \n\ntNode.right = buildTree(in, pre, inIndex + \n1\n, inEnd); \n\n\nreturn\ntNode; \n\n} \n\n\n/* UTILITY FUNCTIONS */\n\n\n/* Function to find index of value in arr[start...end] \n\nThe function assumes that value is present in in[] */\n\nint\nsearch(\nchar\narr[], \nint\nstrt, \nint\nend, \nchar\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\ni; \n\n} \n\n\n/* This funtcion is here just to test buildTree() */\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first recur on left child */\n\nprintInorder(node.left); \n\n\n/* then print the data of node */\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n/* now recur on right child */\n\nprintInorder(node.right); \n\n} \n\n\n// driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nchar\nin[] = \nnew\nchar\n[] { \n'D'\n, \n'B'\n, \n'E'\n, \n'A'\n, \n'F'\n, \n'C'\n}; \n\nchar\npre[] = \nnew\nchar\n[] { \n'A'\n, \n'B'\n, \n'D'\n, \n'E'\n, \n'C'\n, \n'F'\n}; \n\nint\nlen = in.length; \n\nNode root = tree.buildTree(in, pre, \n0\n, len - \n1\n); \n\n\n// building the tree by printing inorder traversal \n\nSystem.out.println(\n\"Inorder traversal of constructed tree is : \"\n); \n\ntree.printInorder(root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "quadratic", "from": "CorCod", "problem": 584, "index": 584}
{"src": "\n// Java program to maximize the sum of difference \n// between consecutive elements in circular array \nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nMaxSum \n{ \n\n// Return the maximum Sum of difference between \n\n// consecutive elements. \n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n; \n\n\n// Sorting the array. \n\nArrays.sort(arr); \n\n\n// Subtracting a1, a2, a3,....., a(n/2)-1, \n\n// an/2 twice and adding a(n/2)+1, a(n/2)+2, \n\n// a(n/2)+3,....., an - 1, an twice. \n\nfor\n(\nint\ni = \n0\n; i < n/\n2\n; i++) \n\n{ \n\nsum -= (\n2\n* arr[i]); \n\nsum += (\n2\n* arr[n - i - \n1\n]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n// Driver Program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n4\n, \n2\n, \n1\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n\n} \n} \n/*This code is contributed by Prakriti Gupta*/", "complexity": "nlogn", "from": "CorCod", "problem": 585, "index": 585}
{"src": "import java.util.*;\nimport java.math.*;\npublic class Split {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n= sc.nextInt();\n\t\tint k= sc.nextInt();\n\t\tint a[] = new int[n];\n\t\tint d[] = new int[n-1];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tif(i>0)\n\t\t\t\td[i-1] = a[i-1] - a[i];\n\t\t}\n\t\tArrays.sort(d);\n\t\tint t = 0;\n\t\tfor(int i=0;i<k-1;i++)\n\t\t\tt += d[i];\n\t\tSystem.out.println(a[n-1]-a[0]+t);\n\t}\n\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 586, "index": 586}
{"src": "\n// Java code to find minimum number of elements \n// such that their sum is greater than sum of \n// remaining elements of the array. \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Function to find minimum elements needed \n\nstatic\nint\nminElements(\nint\narr[], \nint\nn) \n\n{ \n\n// Calculating HALF of array sum \n\nint\nhalfSum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nhalfSum = halfSum + arr[i]; \n\nhalfSum = halfSum / \n2\n; \n\n\n\n// Sort the array in ascending order and \n\n// start traversing array from the ascending \n\n// sort in descending order. \n\nArrays.sort(arr); \n\n\nint\nres = \n0\n, curr_sum = \n0\n; \n\nfor\n(\nint\ni = n-\n1\n; i >= \n0\n; i--) { \n\n\ncurr_sum += arr[i]; \n\nres++; \n\n\n// Current sum greater than sum \n\nif\n(curr_sum > halfSum) \n\nreturn\nres; \n\n} \n\nreturn\nres; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n3\n, \n1\n, \n7\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(minElements(arr, n)); \n\n} \n\n} \n\n// This code is contributed by Gitanjali ", "complexity": "nlogn", "from": "CorCod", "problem": 587, "index": 587}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n \npublic class Main {\n    public static void main(String[] args) throws IOException {\n        PrintWriter out = new PrintWriter(System.out);\n        //Scanner sc = new Scanner();\n        Reader in = new Reader();\n        Main solver = new Main();\n        solver.solve(out, in);\n        out.flush();\n        out.close();\n \n    }\n \n    static int INF = (int)1e5*4*4+5;\n    static int maxn = (int)1e5*2+1;\n    static int mod=(int)1e9+7 ;\n    static int n,m,k,t,q,x,a,b,y;\n    \n    static ArrayList<Integer> adj[];\n    static int[] dist,parent,back;\n    static boolean[] vis,vist;\n    static int root=0,ans=1;\n    \n    \n    void solve(PrintWriter out, Reader in) throws IOException{\n        n = in.nextInt();\n\n\n        if(n==1) {out.println(1);return;}\n        adj = new ArrayList[n+1];\n        for(int i=1;i<=n;i++) \n            adj[i] = new ArrayList<Integer>();\n        \n        int u,v;\n        for(int i=0;i<n-1;i++){\n            u = in.nextInt();\n            v = in.nextInt();\n             \n            adj[u].add(v);\n            adj[v].add(u);\n        }\n        \n        vist = new boolean[n+1];\n        vis = new boolean[n+1];\n        vist[1] =true;\n        makeroot(1);\n        \n        parent = new int[n+1];\n        dist = new int[n+1];\n        back = new int[n+1];\n        \n        dfs(root,0);\n        calcdist(root);\n        \n        vist = new boolean[n+1];\n        vis = new boolean[n+1];\n        vist[root] =true;\n        \n        \n\n        PriorityQueue<Node> pq = new PriorityQueue<Node>();\n        for(int i=1;i<=n;i++){\n            if(i!=root) pq.add(new Node(i,dist[i]));\n        }\n        \n        Node elm;\n        int rt = root;\n        out.print(1);\n        \n        makeroot(root);\n        removeNodes(root,rt);\n        ans+=dist[rt];\n        out.print(\" \"+ans);\n        int itr=2;\n        for(int i=2;i<=n;i++){\n            \n            elm = pq.remove();\n            if(vis[elm.idx]) continue;\n            removeNodes(back[elm.idx],elm.idx);\n            ans += elm.dist+1;\n            out.print(\" \"+ans);\n            itr++;\n        }\n        for(int i=itr;i<n;i++)\n            out.print(\" \"+ans);\n        out.println();\n    }\n    \n    //<>\n    \n    static class Node implements Comparable<Node>{\n        int dist,idx;\n        \n        Node(int idx,int dist){\n            this.idx = idx;\n            this.dist = dist;\n        }\n        \n        public int compareTo(Node o) {\n            return o.dist-this.dist;\n        }\n    }\n    \n    static void removeNodes(int s,int e){\n        vis[s]=true;\n        while(s!=e){\n            vis[s] = true;\n            s = parent[s];\n        }\n        vis[s]=true;\n        return;\n    }\n    \n    static int calcdist(int s){\n        int res=0;\n        int tmp=0;\n        for(int e:adj[s]){\n            if(e!=parent[s]){\n                tmp= calcdist(e);\n                if(1+tmp>res){\n                    res = 1+tmp;\n                    back[s] = back[e];\n                }\n            }\n        }\n        \n        if(res==0) back[s]=s;\n        return dist[s] = res;\n    }\n    \n    static void dfs(int s,int p){\n        for(int e:adj[s]){\n            if(e!=p){\n                parent[e]=s;\n                dfs(e,s);\n            }\n        }\n        return;\n    }\n    \n    static void makeroot(int s){\n        Queue<Integer> q = new LinkedList<>();\n        q.add(s);\n        \n        int elm=0;\n        while(q.size()!=0){\n            elm = q.remove();\n            for(int e:adj[elm]){\n                if(!vist[e]){\n                    vist[e]=true;\n                    q.add(e);\n                    root = e;\n                }\n            }\n        }\n        return;\n    }\n    \n    \n    static class Reader {\n\n    private InputStream mIs;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public Reader() {\n        this(System.in);\n    }\n\n    public Reader(InputStream is) {\n        mIs = is;\n    }\n\n    public int read() {\n        if (numChars == -1) {\n            throw new InputMismatchException();\n\n    }\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = mIs.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) {\n                return -1;\n            }\n        }\n        return buf[curChar++];\n    }\n\n    public String nextLine() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n\n    public String next() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n\n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 588, "index": 588}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.util.Map.*;\npublic class codeforces {\n     static int count =0;\n     static boolean f=false;\n     static int [] arr;\n\tstatic \tPrintWriter pw=new PrintWriter(System.out);\n\tstatic void solve(int index , int mask) {\n\t\tif(index==arr.length) {\n\t\t\tint sum1=0; int sum2=0;\n\t\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\t\tif((mask & 1<<i)!=0) sum1+=arr[i];\n\t\t\t\t\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsolve(index+1, mask | 1<<index);\n\t\tsolve(index+1, mask);\n\t}\n\tpublic static void main(String [] args) throws IOException, InterruptedException {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint x=sc.nextInt();\n\t\tint y=sc.nextInt();\n\t\tpair [] arr=new pair[x];\n\t\tfor(int i=0;i<x;i++) arr[i]=new pair(i, sc.nextInt(),0);\n\t\tfor(int i=0;i<x;i++) arr[i].y=sc.nextInt();\n\t\tArrays.sort(arr);\n\t\tPriorityQueue<Integer> qq=new PriorityQueue<>();\n\t\t//pw.println(Arrays.toString(arr));\n\t\tLong [] list=new Long [x];\n\t\tlong sum=0; \n\t\tfor(int i=0;i<x;i++) {\n\t\t\tpair w=arr[i];\n\t\t\tif(qq.size()<y) {\n\t\t\t\tqq.add(w.y);\n\t\t\t\tsum+=w.y;\n\t\t\t\tlist[w.i]=sum;\n\n\t\t\t}else if(!qq.isEmpty()) {\n\t\t\t\tsum+=w.y;\n\t\t\t\tlist[w.i]=sum;\n\t\t\t\tint first=qq.poll();\n\t\t\t\tif(w.y>first) {\n\t\t\t\t\tsum-=first;\n\t\t\t\t\tqq.add(w.y);\n\t\t\t\t}else {\n\t\t\t\t\tqq.add(first);\n\t\t\t\t\tsum-=w.y;\n\t\t\t\t}\n\t\t\t} else list[w.i]=(long) w.y;\n\t\t\t//pw.println(qq);\n\t\t}\n\t\tfor(Long w:list) pw.print(w+\" \"); \n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\t\n\tstatic class pair implements Comparable<pair>{\n\t\tString  name; int x,y,i ;\n\t\tpublic pair(String name , int x) {\n\t\t\tthis.name=name; this.x=x;\n\t\t}\n\t\t\n\t\tpublic pair (int i,int x,int y) {\n\t\t\tthis.i=i; this.x=x; this.y=y; \n\t\t}\n\t\tpublic int compareTo(pair o) {\n\t\t\treturn x-o.x;\n\t\t}\n\t\tpublic int compareTo1(pair o) {\n\t\t\tif(!name.equals(o.name))\n\t\t\t\treturn name.compareTo(o.name);\n\t\t\treturn x-o.x;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn i+\" \"+x+\" \"+y;\n\t\t}\n\t}\n\n   static class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n\t}", "complexity": "nlogn", "from": "CorCod", "problem": 589, "index": 589}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        int l;\n        int r;\n        public card(int ch,int i)\n        {\n            this.l=ch;\n            this.r=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (int)(o1.l-o2.l);\n            else\n                return (int)(o1.r-o2.r);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }\n    static int ans1=Integer.MAX_VALUE,ans2=Integer.MAX_VALUE,ans3=Integer.MAX_VALUE,ans4=Integer.MAX_VALUE;\n    static boolean v[]=new boolean[101];\n    static void dfs(Integer so,Set<Integer> s[]){\n    if(!v[so.intValue()])\n    {\n    v[so]=true;\n    for(Integer h:s[so.intValue()])\n    {\n    if(!v[h.intValue()])\n    dfs(h,s);\n    }\n    }\n    }\n    static class Print{\n    public PrintWriter out;\n    Print(OutputStream o)\n    {\n    out=new PrintWriter(o);\n    }\n    }\n    static int CeilIndex(int A[], int l, int r, int key) \n    { \n    while (r - l > 1) { \n    int m = l + (r - l) / 2; \n    if (A[m] >= key) \n    r = m; \n    else\n    l = m; \n    } \n\n    return r; \n    } \n\n    static int LongestIncreasingSubsequenceLength(int A[], int size) \n    { \n    // Add boundary case, when array size is one \n    int[] tailTable = new int[size]; \n    int len; // always points empty slot \n    tailTable[0] = A[0]; \n    len = 1; \n    for (int i = 1; i < size; i++) { \n    if (A[i] < tailTable[0]) \n    // new smallest value \n    tailTable[0] = A[i]; \n\n    else if (A[i] > tailTable[len - 1]) \n    // A[i] wants to extend largest subsequence \n    tailTable[len++] = A[i]; \n\n    else\n    // A[i] wants to be current end candidate of an existing \n    // subsequence. It will replace ceil value in tailTable \n    tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; \n    } \n    return len; \n    }*/\n    /*static int binary(int n)\n    {\n    int s=1;\n    while(n>0)\n    {\n    s=s<<1;\n    n--;\n    }\n    return s-1;\n    }\n    static StringBuilder bin(int i,int n)\n    {\n    StringBuilder s=new StringBuilder();\n    while(i>0)\n    {\n    s.append(i%2);\n    i=i/2;\n    }\n    while(s.length()!=n)\n    {\n    s.append(0);\n    }\n    return s.reverse();\n    }*/\n    static boolean valid(int i,int j,int n,int m)\n    {\n        if(i<n && i>=0 && j<m && j>=0)\n            return true;\n        else\n            return false;\n    }\n\n    public static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        int s=sc.nextInt();\n        card c[]=new card[n];\n        for(int i=0;i<n;i++)\n        {\n            int x=sc.nextInt();\n            int y=sc.nextInt();\n            c[i]=new card(x,y);\n        }\n        Arrays.sort(c,new sort());\n        int time=0;\n        for(int i=n-1;i>=0;i--)\n        {\n            time+=s-c[i].l;\n            if((c[i].r-time)>0)\n            time+=c[i].r-time;\n            s=c[i].l;\n        }\n        if(c[0].l!=0)\n        time+=c[0].l;\n        System.out.println(time);\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 590, "index": 590}
{"src": "\n// The following implementation assumes that the activities \n// are already sorted according to their finish time \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nActivitySelection \n{ \n\n// Prints a maximum set of activities that can be done by a single \n\n// person, one at a time. \n\n// n --> Total number of activities \n\n// s[] --> An array that contains start time of all activities \n\n// f[] --> An array that contains finish time of all activities \n\npublic\nstatic\nvoid\nprintMaxActivities(\nint\ns[], \nint\nf[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\nSystem.out.print(\n\"Following activities are selected : n\"\n); \n\n\n// The first activity always gets selected \n\ni = \n0\n; \n\nSystem.out.print(i+\n\" \"\n); \n\n\n// Consider rest of the activities \n\nfor\n(j = \n1\n; j < n; j++) \n\n{ \n\n// If this activity has start time greater than or \n\n// equal to the finish time of previously selected \n\n// activity, then select it \n\nif\n(s[j] >= f[i]) \n\n{ \n\nSystem.out.print(j+\n\" \"\n); \n\ni = j; \n\n} \n\n} \n\n} \n\n\n// driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ns[] = {\n1\n, \n3\n, \n0\n, \n5\n, \n8\n, \n5\n}; \n\nint\nf[] = {\n2\n, \n4\n, \n6\n, \n7\n, \n9\n, \n9\n}; \n\nint\nn = s.length; \n\n\nprintMaxActivities(s, f, n); \n\n} \n\n} ", "complexity": "nlogn", "from": "CorCod", "problem": 591, "index": 591}
{"src": "\n// Java program to print the array in given order \nimport\njava.util.Arrays; \n\npublic\nclass\nGFG { \n\n\n// Function which arrange the array. \n\nstatic\nvoid\nrearrangeArray(\nint\narr[], \nint\nn) \n\n{ \n\n// Sorting the array elements \n\nArrays.sort(arr); \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n// To store modified array \n\n\n// Adding numbers from sorted array to \n\n// new array accordingly \n\nint\nArrIndex = \n0\n; \n\n\n// Traverse from begin and end simultaneously \n\nfor\n(\nint\ni = \n0\n, j = n-\n1\n; i <= n / \n2\n|| j > n / \n2\n; \n\ni++, j--) { \n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[i]; \n\nArrIndex++; \n\n} \n\n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[j]; \n\nArrIndex++; \n\n} \n\n} \n\n\n// Modifying original array \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = tempArr[i]; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n5\n, \n8\n, \n1\n, \n4\n, \n2\n, \n9\n, \n3\n, \n7\n, \n6\n}; \n\nint\nn = arr.length; \n\nrearrangeArray(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "nlogn", "from": "CorCod", "problem": 592, "index": 592}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static BufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer tok;\n    static boolean hasNext()\n    {\n        while(tok==null||!tok.hasMoreTokens())\n            try{\n                tok=new StringTokenizer(in.readLine());\n            }\n            catch(Exception e){\n                return false;\n            }\n        return true;\n    }\n    static String next()\n    {\n        hasNext();\n        return tok.nextToken();\n    }\n    static long nextLong()\n    {\n        return Long.parseLong(next());\n    }\n    static int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) {\n        Map<Integer,Integer> map = new HashMap();\n        map.put(0,1);\n        int n = nextInt();\n        int m = nextInt();\n        int index = -1;\n        int a[] = new int[n];\n        for(int i=0;i<n;i++){\n            a[i]=nextInt();\n            if(a[i]==m)\n                index=i;\n        }\n        int sum = 0;\n        for(int i=0;i<index;i++){\n            if (a[i]<m)\n                sum--;\n            else\n                sum++;\n            if (map.containsKey(sum)){\n                map.put(sum,map.get(sum)+1);\n            }else {\n                map.put(sum,1);\n            }\n        }\n        long ans = 0;\n        for(int i=index;i<n;i++){\n            if (a[i]<m)\n                sum--;\n            else if(a[i]>m)\n                sum++;\n            if (map.containsKey(sum))\n                ans+=map.get(sum);\n            if (map.containsKey(sum-1))\n                ans+=map.get(sum-1);\n        }\n        out.print(ans);\n        out.flush();\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 593, "index": 593}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(br.readLine());\n\t\tint[] A=new int[n];\n\t\tString[] s=br.readLine().split(\" \");\n\t\tfor(int i=0;i<n;i++){\n\t\t\tA[i]=Integer.parseInt(s[i]);\n\t\t}\n\t\tMap memo=new HashMap();\n\t\tint[] f=new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!memo.containsKey(A[i])){\n\t\t\t\tmemo.put(A[i],1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint ct=(int)memo.get(A[i]);\n\t\t\t\tmemo.put(A[i],ct+1);\n\t\t\t}\n\t\t\tint tot=0;\n\t\t\tif(memo.containsKey(A[i]-1)){\n\t\t\t\ttot+=(int)memo.get(A[i]-1);\n\t\t\t}\n\t\t\tif(memo.containsKey(A[i]+1)){\n\t\t\t\ttot+=(int)memo.get(A[i]+1);\n\t\t\t}\n\t\t\ttot+=(int)memo.get(A[i]);\n\t\t\tf[i]=tot;\n\t\t}\n\t\tBigInteger res=new BigInteger(\"0\");\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tot1=i+1-f[i];\n\t\t\tint tot2=0;\n\t\t\tif(memo.containsKey(A[i]-1)){\n\t\t\t\ttot2+=(int)memo.get(A[i]-1);\n\t\t\t}\n\t\t\tif(memo.containsKey(A[i]+1)){\n\t\t\t\ttot2+=(int)memo.get(A[i]+1);\n\t\t\t}\n\t\t\ttot2+=(int)memo.get(A[i]);\n\t\t\ttot2=n-i-1-(tot2-f[i]);\n\t\t\t//res+=(long)(tot1-tot2)*(long)A[i];\n\t\t\tres=res.add(BigInteger.valueOf((long)(tot1-tot2)*(long)A[i]));\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n}", "complexity": "nlogn", "from": "CorCod", "problem": 594, "index": 594}
{"src": "import java.util.*;\npublic class bOX {\n\n    public static void main(String ars[]){\n\n        Scanner  s = new Scanner(System.in);\n        int n = s.nextInt();\n        int max = 0;\n\n        Map<Integer,Integer> map = new HashMap<>();\n\n        for(int i=0;i<n;i++){\n            int x = s.nextInt();\n            if(!map.containsKey(x)){\n                map.put(x,1);\n                max = Math.max(max,1);\n            }\n            else{\n                map.put(x,map.get(x)+1);\n                max = Math.max(max,map.get(x));\n            }\n        }\n\n        System.out.println(max);\n    }\n\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 595, "index": 595}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int T;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        T = sc.nextInt();\n\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < T; i++) {\n            int n = sc.nextInt();\n            int[] a = sc.nextIntArray(n);\n            int[] ans = solve(n, a);\n            StringJoiner j = new StringJoiner(\" \");\n            for (int each : ans) {\n                j.add(String.valueOf(each));\n            }\n            pw.println(j.toString());\n        }\n        pw.flush();\n    }\n\n    static int[] solve(int N, int[] A) {\n        // a/b \u304c1\u306b\u8fd1\u3044\u3082\u306e\u3092\u63a2\u3059\n        shuffle(A);\n        Arrays.sort(A);\n        int cur = A[0];\n        int time = 1;\n        double r = 0;\n        int prev = -1;\n        int a = -1;\n        int b = -1;\n        for (int i = 1; i < N; i++) {\n            if( cur == A[i] ) {\n                time++;\n\n                if( time == 2 ) {\n                    if( prev != -1 ) {\n                        double r1 = (double)prev/cur;\n                        if( r1 > r ) {\n                            r = r1;\n                            a = prev;\n                            b = cur;\n                        }\n                    }\n                    prev = cur;\n                }\n\n                if( time == 4 ) {\n                    return new int[]{cur, cur, cur, cur};\n                }\n\n            } else {\n                time = 1;\n                cur = A[i];\n            }\n        }\n\n        return new int[]{a, a, b, b};\n    }\n\n    static void shuffle(int[] a) {\n        Random r = ThreadLocalRandom.current();\n        for (int i = a.length-1; i >= 0; i--) {\n            int j = r.nextInt(i+1);\n            int t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 596, "index": 596}
{"src": "\n// Java program to find the maximum profit job sequence \n// from a given array of jobs with deadlines and profits \nimport\njava.util.*; \n\n// A Simple Disjoint Set Data Structure \nclass\nDisjointSet \n{ \n\nint\nparent[]; \n\n\n// Constructor \n\nDisjointSet(\nint\nn) \n\n{ \n\nparent = \nnew\nint\n[n + \n1\n]; \n\n\n// Every node is a parent of itself \n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nparent[i] = i; \n\n} \n\n\n// Path Compression \n\nint\nfind(\nint\ns) \n\n{ \n\n/* Make the parent of the nodes in the path \n\nfrom u--> parent[u] point to parent[u] */\n\nif\n(s == parent[s]) \n\nreturn\ns; \n\nreturn\nparent[s] = find(parent[s]); \n\n} \n\n\n// Makes u as parent of v. \n\nvoid\nmerge(\nint\nu, \nint\nv) \n\n{ \n\n//update the greatest available \n\n//free slot to u \n\nparent[v] = u; \n\n} \n} \n\nclass\nJob \nimplements\nComparator<Job> \n{ \n\n// Each job has a unique-id, profit and deadline \n\nchar\nid; \n\nint\ndeadline, profit; \n\n\n// Constructors \n\npublic\nJob() { } \n\npublic\nJob(\nchar\nid,\nint\ndeadline,\nint\nprofit) \n\n{ \n\nthis\n.id = id; \n\nthis\n.deadline = deadline; \n\nthis\n.profit = profit; \n\n} \n\n\n// Returns the maximum deadline from the set of jobs \n\npublic\nstatic\nint\nfindMaxDeadline(ArrayList<Job> arr) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n\nfor\n(Job temp : arr) \n\nans = Math.max(temp.deadline, ans); \n\nreturn\nans; \n\n} \n\n\n// Prints optimal job sequence \n\npublic\nstatic\nvoid\nprintJobScheduling(ArrayList<Job> arr) \n\n{ \n\n// Sort Jobs in descending order on the basis \n\n// of their profit \n\nCollections.sort(arr, \nnew\nJob()); \n\n\n// Find the maximum deadline among all jobs and \n\n// create a disjoint set data structure with \n\n// maxDeadline disjoint sets initially. \n\nint\nmaxDeadline = findMaxDeadline(arr); \n\nDisjointSet dsu = \nnew\nDisjointSet(maxDeadline); \n\n\n// Traverse through all the jobs \n\nfor\n(Job temp : arr) \n\n{ \n\n// Find the maximum available free slot for \n\n// this job (corresponding to its deadline) \n\nint\navailableSlot = dsu.find(temp.deadline); \n\n\n\n// If maximum available free slot is greater \n\n// than 0, then free slot available \n\nif\n(availableSlot > \n0\n) \n\n{ \n\n// This slot is taken by this job 'i' \n\n// so we need to update the greatest free \n\n// slot. Note that, in merge, we make \n\n// first parameter as parent of second \n\n// parameter. So future queries for \n\n// availableSlot will return maximum slot \n\n// from set of \"availableSlot - 1\" \n\ndsu.merge(dsu.find(availableSlot - \n1\n), \n\navailableSlot); \n\nSystem.out.print(temp.id + \n\" \"\n); \n\n} \n\n} \n\nSystem.out.println(); \n\n} \n\n\n// Used to sort in descending order on the basis \n\n// of profit for each job \n\npublic\nint\ncompare(Job j1, Job j2) \n\n{ \n\nreturn\nj1.profit > j2.profit? -\n1\n: \n1\n; \n\n} \n} \n\n// Driver code \nclass\nMain \n{ \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nArrayList<Job> arr=\nnew\nArrayList<Job>(); \n\narr.add(\nnew\nJob(\n'a'\n,\n2\n,\n100\n)); \n\narr.add(\nnew\nJob(\n'b'\n,\n1\n,\n19\n)); \n\narr.add(\nnew\nJob(\n'c'\n,\n2\n,\n27\n)); \n\narr.add(\nnew\nJob(\n'd'\n,\n1\n,\n25\n)); \n\narr.add(\nnew\nJob(\n'e'\n,\n3\n,\n15\n)); \n\nSystem.out.println(\n\"Following jobs need to be \"\n+ \n\n\"executed for maximum profit\"\n); \n\nJob.printJobScheduling(arr); \n\n} \n} ", "complexity": "nlogn", "from": "CorCod", "problem": 597, "index": 597}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n    static class Pair {\n        int a;\n        int b;\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int floor = sc.nextInt();\n        int time = 0;\n\n        Pair[] arr = new Pair[n];\n        for(int i=0;i<n;i++) arr[i] = new Pair(sc.nextInt(), sc.nextInt());\n\n        Arrays.sort(arr, (Pair cur, Pair other) -> (other.a - cur.a));\n\n        for(int i=0;i<n;i++) {\n            time += floor - arr[i].a;\n            floor = arr[i].a;\n            time = Math.max(time, arr[i].b);\n            //pw.println(\"time: \" + time);\n        }\n\n        time += arr[n-1].a;\n\n        pw.println(time);\n        pw.close();\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 598, "index": 598}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Three{\n    public static void main(String[] args) {\n\tScanner in = new Scanner (System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tpair[] points = new pair [3];\n\tfor (int i = 0; i < 3; ++i) {\n\t    int x = in.nextInt();\n\t    int y = in.nextInt();\n\t    points[i] = new pair (x, y);\n\t}\n\n\tArrays.sort(points);\n\n\tint MaxY = Math.max(Math.max(points[0].y, points[1].y), points[2].y);\n\tint MinY = Math.min(Math.min(points[0].y, points[1].y), points[2].y);\n\n\tout.println(MaxY - MinY + points[2].x - points[0].x + 1);\n\tfor (int i = MinY; i <= MaxY; ++i)\n\t    out.println(points[1].x + \" \" + i);\n\tfor (int i = points[0].x; i < points[1].x; ++i)\n\t    out.println(i + \" \" + points[0].y);\n\tfor (int i = points[1].x + 1; i <= points[2].x; ++i)\n\t    out.println(i + \" \" + points[2].y);\n\t\n\tout.close();\n    }\n\n    public static class pair implements Comparable<pair> {\n\tint x, y;\n\tpublic pair (int x_, int y_) {\n\t    x = x_; y = y_;\n\t}\n\n\t@Override\n\tpublic int compareTo(pair o) {\n\t    return x - o.x;\n\t}\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 599, "index": 599}
{"src": "import java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        long totalBlocks = 0;\n        long a[] = new long[n];\n        for(int i = 0; i < n; ++i) {\n            a[i] = sc.nextLong();\n            totalBlocks += a[i];\n        }\n\n        Arrays.sort(a);\n\n        long selected = 0;\n        for(int i = 0; i < n; ++i) {\n            if(a[i] > selected)\n                selected++;\n        }\n\n        long leftCols = a[n - 1] - selected;\n        long remBlocks = totalBlocks - leftCols - n;\n\n        System.out.print(remBlocks);\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 600, "index": 600}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int N;\n    static int[] U, V;\n    static int[] A;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        U = new int[N-1];\n        V = new int[N-1];\n        for (int i = 0; i < N - 1; i++) {\n            U[i] = sc.nextInt()-1;\n            V[i] = sc.nextInt()-1;\n        }\n        A = sc.nextIntArray(N, -1);\n\n        System.out.println(solve() ? \"Yes\" : \"No\");\n    }\n\n    static boolean solve() {\n        if( A[0] != 0 ) return false;\n\n        int[][] G = adjB(N, U, V);\n\n        Map<Integer, Integer> parents = new HashMap<>();\n        for (Node node : orderFromRoot(N, G, 0)) {\n            parents.put(node.a, node.parent);\n        }\n        ArrayDeque<Integer> q = new ArrayDeque<>();\n        for (int next : G[0]) {\n            q.add(0);\n        }\n\n        int idx = 1;\n        while(!q.isEmpty()) {\n            int p = q.poll();\n            int a = A[idx++];\n            if( parents.get(a) != p ) {\n                return false;\n            }\n\n            for (int next : G[a]) {\n                if( next == p ) continue;\n\n                q.add(a);\n            }\n        }\n        return true;\n    }\n\n    static int[][] adjB(int n, int[] from, int[] to) {\n        int[][] adj = new int[n][];\n        int[] cnt = new int[n];\n        for (int f : from) {\n            cnt[f]++;\n        }\n        for (int t : to) {\n            cnt[t]++;\n        }\n        for (int i = 0; i < n; i++) {\n            adj[i] = new int[cnt[i]];\n        }\n        for (int i = 0; i < from.length; i++) {\n            adj[from[i]][--cnt[from[i]]] = to[i];\n            adj[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return adj;\n    }\n\n    static Node[] orderFromRoot(int N, int[][] G, int root) {\n        ArrayDeque<Node> q = new ArrayDeque<>();\n        Node[] ret = new Node[N];\n        int idx = 0;\n        q.add(new Node(-1, root));\n        while(!q.isEmpty()) {\n            Node n = q.poll();\n            ret[idx++] = n;\n            for (int next : G[n.a]) {\n                if( next == n.parent ) continue;\n\n                q.add(new Node(n.a, next));\n            }\n        }\n        return ret;\n    }\n\n    static class Node {\n        int parent, a;\n\n        public Node(int parent, int a) {\n            this.parent = parent;\n            this.a = a;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 601, "index": 601}
{"src": "/*\nKeep solving problems.\n*/\n\nimport java.util.*;\nimport java.io.*;\n\npublic class CFA {\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    private static long MOD = 1000L * 1000L * 1000L + 7;\n    private static final int[] dx = {0, -1, 0, 1};\n    private static final int[] dy = {1, 0, -1, 0};\n    private static final String yes = \"Yes\";\n    private static final String no = \"No\";\n\n    int n;\n    int m;\n    char[][] mat;\n    long base = 397;\n    void solve() throws IOException {\n        n = nextInt();\n        m = nextInt();\n        mat = new char[n][m];\n        for (int i = 0; i < n; i++) {\n            mat[i] = nextString().toCharArray();\n        }\n\n        int alpha = 26;\n        long[] pow = new long[alpha];\n        pow[0] = 1;\n        for (int i = 1; i < alpha; i++) {\n            pow[i] = pow[i - 1] * base % MOD;\n        }\n\n        long res = 0;\n        for (int l = 0; l < m; l++) {\n            //[l, r]\n            long[] hash = new long[n];\n            long[] mask = new long[n];\n            for (int r = l; r < m; r++) {\n                for (int i = 0; i < n; i++) {\n                    hash[i] += pow[mat[i][r] - 'a'];\n                    hash[i] %= MOD;\n                    mask[i] = mask[i] ^ (1L << (mat[i][r] - 'a'));\n                }\n\n                int start = 0;\n                while (start < n) {\n                    if ((mask[start] & (mask[start] - 1)) != 0) {\n                        start++;\n                        continue;\n                    }\n\n                    int end = start;\n                    List<Long> l1 = new ArrayList<>();\n                    while (end < n && (mask[end] & (mask[end] - 1)) == 0) {\n                        l1.add(hash[end]);\n                        end++;\n                    }\n\n                    start = end;\n                    res += manacher(l1);\n                }\n            }\n        }\n\n        outln(res);\n    }\n\n    long manacher(List<Long> arr) {\n        int len = arr.size();\n        long[] t = new long[len * 2 + 3];\n        t[0] = -1;\n        t[len * 2 + 2] = -2;\n        for (int i = 0; i < len; i++) {\n            t[2 * i + 1] = -3;\n            t[2 * i + 2] = arr.get(i);\n        }\n\n        t[len * 2 + 1] = -3;\n        int[] p = new int[t.length];\n        int center = 0, right = 0;\n        for (int i = 1; i < t.length - 1; i++) {\n            int mirror = 2 * center - i;\n            if (right > i) {\n                p[i] = Math.min(right - i, p[mirror]);\n            }\n\n            // attempt to expand palindrome centered at i\n            while (t[i + (1 + p[i])] == t[i - (1 + p[i])]) {\n                p[i]++;\n            }\n\n            // if palindrome centered at i expands past right,\n            // adjust center based on expanded palindrome.\n            if (i + p[i] > right) {\n                center = i;\n                right = i + p[i];\n            }\n        }\n\n        long res = 0;\n        for (int i = 0; i < 2 * len; i++) {\n            int parLength = p[i + 2];\n            if (i % 2 == 0) {\n                res += (parLength + 1) / 2;\n            }\n            else {\n                res += parLength / 2;\n            }\n        }\n\n        return res;\n    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n    long gcd(long a, long b) {\n        while(a != 0 && b != 0) {\n            long c = b;\n            b = a % b;\n            a = c;\n        }\n        return a + b;\n    }\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    private void formatPrint(double val) {\n        outln(String.format(\"%.9f%n\", val));\n    }\n    public CFA() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFA();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 602, "index": 602}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n / 2];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(p));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] p) {\n\t\treturn Math.min(computeMoveNum(p, 1), computeMoveNum(p, 2));\n\t}\n\n\tstatic int computeMoveNum(int[] p, int offset) {\n\t\tArrays.sort(p);\n\n\t\treturn IntStream.range(0, p.length).map(i -> Math.abs(p[i] - (i * 2 + offset))).sum();\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 603, "index": 603}
{"src": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in =new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tarr[i] = in.nextInt();\n\t\tfor(int i = n-1; i > 0; i--)\n\t\t\tarr[i] -= arr[i-1];\n\t\tarr[0] = 0;\n\t\tArrays.sort(arr);\n\t\tlong sum = 0;\n\t\tfor(int i = n-k; i >= 0; i--)\n\t\t\tsum += arr[i];\n\t\tSystem.out.println(sum);\n\t}\n}", "complexity": "nlogn", "from": "CorCod", "problem": 604, "index": 604}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class cf {\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n\n    static int mod = 1000000007;\n    \n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out); \n\n        int n=sc.nextInt(), k = sc.nextInt();\n        int[] a = new int[n+1];\n\n        for(int i=0;i<n;i++) {\n            a[i] = sc.nextInt();\n        }\n        a[n] = 0;\n        Arrays.sort(a);\n\n        for(int i=1;i<=n;i++) {\n            if(k == 0) {\n                break;\n            }\n            if(a[i] != a[i-1]) {\n                k--;\n                pw.println(a[i] - a[i-1]);\n            }\n        }\n        for(int i=0;i<k;i++) pw.println(0);\n        pw.close();\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 605, "index": 605}
{"src": "\n// Java code for kth smallest element \n// in an array \nimport\njava.util.Arrays; \nimport\njava.util.Collections; \n\nclass\nGFG \n{ \n\n// Function to return k'th smallest \n\n// element in a given array \n\npublic\nstatic\nint\nkthSmallest(Integer [] arr, \n\nint\nk) \n\n{ \n\n// Sort the given array \n\nArrays.sort(arr); \n\n\n// Return k'th element in \n\n// the sorted array \n\nreturn\narr[k-\n1\n]; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[]{\n12\n, \n3\n, \n5\n, \n7\n, \n19\n}; \n\nint\nk = \n2\n; \n\nSystem.out.print( \n\"K'th smallest element is \"\n+ \n\nkthSmallest(arr, k) ); \n\n} \n} \n\n// This code is contributed by Chhavi ", "complexity": "nlogn", "from": "CorCod", "problem": 606, "index": 606}
{"src": "\n// Java Program to find max subarray \n// sum excluding some elements \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n\n// Utility function for findMaxSubarraySum() \n\n// with the following parameters \n\n// A => Array A, \n\n// B => Array B, \n\n// n => Number of elements in Array A, \n\n// m => Number of elements in Array B \n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n// set max_so_far to INT_MIN \n\nint\nmax_so_far = Integer.MIN_VALUE, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n// if the element is present in B, \n\n// set current max to 0 and move to \n\n// the next element \n\nif\n(Arrays.binarySearch(B, A[i]) >= \n0\n) \n\n{ \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n// Proceed as in Kadane's Algorithm \n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n// Wrapper for findMaxSubarraySumUtil() \n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n// sort array B to apply Binary Search \n\nArrays.sort(B); \n\n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n// This case will occour when all elements \n\n// of A are present in B, thus no subarray \n\n// can be formed \n\nif\n(maxSubarraySum == Integer.MIN_VALUE) \n\n{ \n\nSystem.out.println(\n\"Maximum subarray sum cant be found\"\n); \n\n} \n\nelse\n\n{ \n\nSystem.out.println(\n\"The Maximum subarray sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = {\n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = {\n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n// Calling fucntion \n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n} \n\n// This code has been contributed by 29AjayKumar ", "complexity": "nlogn", "from": "CorCod", "problem": 607, "index": 607}
{"src": "import java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int a[] = new int[n];\n        int b[] = new int[n];\n        for (int i = 0; i < n; i++) a[i] = sc.nextInt();\n        for (int i = 0; i < n; i++) b[i] = sc.nextInt();\n        int c[] = new int[2 * n];\n        c[0] = a[0];\n        for (int i = 1; i < n; i++) {\n            c[i * 2] = a[i];\n            c[i * 2 - 1] = b[i];\n            if (a[i] == 1 || b[i] == 1) {\n                System.out.print(-1);\n                System.exit(0);\n            }\n        }\n        c[2 * n - 1] = b[0];\n        if (a[0] == 1 || b[0] == 1) {\n            System.out.print(-1);\n            System.exit(0);\n        }\n        System.out.println(bin_search(c, m));\n    }\n\n    private static double bin_search(int[] c, int m) {\n        double start = 0;\n        double end = Integer.MAX_VALUE;\n        double mid;\n        while (start + 0.0000001 < end) {\n            mid = (start + end) / 2;\n            if (test(mid, m, c)) end = mid;\n            else start = mid;\n        }\n        return end;\n    }\n\n    private static boolean test(double fuel, int m, int[] c) {\n        for (int i = 0; i < c.length; i++) {\n            fuel -= (m + fuel) / c[i];\n            if (fuel < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 608, "index": 608}
{"src": "\n// Java implementation of \n// above algorithm \nimport\njava.io.*; \nimport\njava.util.*; \n\npublic\nclass\nGFG { \n\n\nstatic\nint\nMaxSumDifference(Integer []a, \nint\nn) \n\n{ \n\n\n// final sequence stored in the vector \n\nList<Integer> finalSequence = \n\nnew\nArrayList<Integer>(); \n\n\n// sort the original array \n\n// so that we can retrieve \n\n// the large elements from \n\n// the end of array elements \n\nArrays.sort(a); \n\n\n// In this loop first we will insert \n\n// one smallest element not entered \n\n// till that time in final sequence \n\n// and then enter a highest element \n\n// (not entered till that time) in \n\n// final sequence so that we \n\n// have large difference value. This \n\n// process is repeated till all array \n\n// has completely entered in sequence. \n\n// Here, we have loop till n/2 because \n\n// we are inserting two elements at a \n\n// time in loop. \n\nfor\n(\nint\ni = \n0\n; i < n / \n2\n; ++i) { \n\nfinalSequence.add(a[i]); \n\nfinalSequence.add(a[n - i - \n1\n]); \n\n} \n\n\n// variable to store the \n\n// maximum sum of absolute \n\n// difference \n\nint\nMaximumSum = \n0\n; \n\n\n// In this loop absolute difference \n\n// of elements for the final sequence \n\n// is calculated. \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(i) \n\n- finalSequence.get(i + \n1\n)); \n\n} \n\n\n// absolute difference of last element \n\n// and 1st element \n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(n - \n1\n) \n\n- finalSequence.get(\n0\n)); \n\n\n// return the value \n\nreturn\nMaximumSum; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nInteger []a = { \n1\n, \n2\n, \n4\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxSumDifference(a, n)); \n\n} \n} \n\n// This code is contributed by \n// Manish Shaw (manishshaw1) ", "complexity": "nlogn", "from": "CorCod", "problem": 609, "index": 609}
{"src": "\n// Java code to find maximum triplet sum \nimport\njava.io.*; \nimport\njava.util.*; \n\n\nclass\nGFG { \n\n\n// This function assumes that there are \n\n// at least three elements in arr[]. \n\nstatic\nint\nmaxTripletSum(\nint\narr[], \nint\nn) \n\n{ \n\n// sort the given array \n\nArrays.sort(arr); \n\n\n// After sorting the array. \n\n// Add last three element \n\n// of the given array \n\nreturn\narr[n - \n1\n] + arr[n - \n2\n] + arr[n - \n3\n]; \n\n} \n\n\n// Driven code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n0\n, \n8\n, \n6\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxTripletSum(arr, n)); \n\n} \n} \n\n\n// This code is contributed by Nikita Tiwari. ", "complexity": "nlogn", "from": "CorCod", "problem": 610, "index": 610}
{"src": "import java.util.*;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tComp c1 = getComp(scanner);\n\t\tComp c2 = getComp(scanner);\n\t\tc1.sortByPrice();\n\t\tc2.sortByPrice();\t\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < c1.num || j < c2.num) {\n\t\t\tElem xi = (i < c1.num) ? c1.elems.get(i) : null;\n\t\t\tElem yj = (j < c2.num) ? c2.elems.get(j) : null;\n\t\t\tif(xi != null && yj != null) {\n\t\t\t\tif(xi.price >= yj.price) {\n\t\t\t\t\tif(!c2.resultSet.contains(xi)) {\n\t\t\t\t\t\tc1.resultSet.add(xi);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tif(!c1.resultSet.contains(yj)) {\n\t\t\t\t\t\tc2.resultSet.add(yj);\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t} else\n\t\t\tif(xi != null) {\n\t\t\t\tif(!c2.resultSet.contains(xi)) {\n\t\t\t\t\tc1.resultSet.add(xi);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tif(!c1.resultSet.contains(yj)) {\n\t\t\t\t\tc2.resultSet.add(yj);\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\t\t\t\t\n\t\t}\n\t\t\n\t\tlong result = c1.getResultPrice() + c2.getResultPrice();\n\t\tSystem.out.println(result);\n   }\n   \n   private static Comp getComp(Scanner scanner) {\n\t   Comp c = new Comp();\n\t   c.num = scanner.nextInt();\n\t   for(int i = 0; i < c.num; i++) {\n\t\t   c.addElem(scanner.nextLong(), scanner.nextLong());\n\t   }\n\t   return c;\n   }\n}\n\nclass Comp {\n\tint num;\n\tList<Elem> elems = new ArrayList<>();\n\tSet<Elem> resultSet = new HashSet<>();\n\t\n\tvoid addElem(long el, long pr) {\n\t\tElem elem = new Elem(el, pr);\n\t\telems.add(elem);\n\t}\n\t\n\tvoid sortByPrice() {\n\t\tCollections.sort(elems);\n\t}\n\t\n\tlong getResultPrice() {\n\t\tlong sumPrice = 0;\n\t\tfor(Elem elem : resultSet) {\n\t\t\tsumPrice += elem.price;\n\t\t}\n\t\t\n\t\treturn sumPrice;\n\t}\n}\n\nclass Elem implements Comparable<Elem> {\n\tlong elem;\n\tlong price;\n\t\n\tpublic Elem(long el, long pr) {\n\t\tthis.elem = el;\n\t\tthis.price = pr;\n\t}\n\t\n\tpublic int compareTo(Elem other) {\n\t\treturn (int) (other.price - price);\n\t}\n\t\n\tpublic boolean equals(Object o) {\n\t\tif(!(o instanceof Elem)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tElem other = (Elem) o;\n\t\treturn (other.elem == elem);\n\t}\n\t\n\tpublic int hashCode() {\n\t\treturn (int) elem;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"(\" + elem + \", \" + price + \")\";\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 611, "index": 611}
{"src": "\n// Java program to find the sum \n// in a given range in an array \n// using sparse table. \nclass\nGFG \n{ \n\n// Because 2^17 is larger than 10^5 \nstatic\nint\nk = \n16\n; \n\n// Maximum value of array \nstatic\nint\nN = \n100000\n; \n\n// k + 1 because we need \n// to access table[r][k] \nstatic\nlong\ntable[][] = \nnew\nlong\n[N][k + \n1\n]; \n\n// it builds sparse table. \nstatic\nvoid\nbuildSparseTable(\nint\narr[], \n\nint\nn) \n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntable[i][\n0\n] = arr[i]; \n\n\nfor\n(\nint\nj = \n1\n; j <= k; j++) \n\nfor\n(\nint\ni = \n0\n; i <= n - (\n1\n<< j); i++) \n\ntable[i][j] = table[i][j - \n1\n] + \n\ntable[i + (\n1\n<< (j - \n1\n))][j - \n1\n]; \n} \n\n// Returns the sum of the \n// elements in the range L and R. \nstatic\nlong\nquery(\nint\nL, \nint\nR) \n{ \n\n// boundaries of next query, \n\n// 0-indexed \n\nlong\nanswer = \n0\n; \n\nfor\n(\nint\nj = k; j >= \n0\n; j--) \n\n{ \n\nif\n(L + (\n1\n<< j) - \n1\n<= R) \n\n{ \n\nanswer = answer + table[L][j]; \n\n\n// instead of having L', we \n\n// increment L directly \n\nL += \n1\n<< j; \n\n} \n\n} \n\nreturn\nanswer; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n3\n, \n7\n, \n2\n, \n5\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nbuildSparseTable(arr, n); \n\n\nSystem.out.println(query(\n0\n, \n5\n)); \n\nSystem.out.println(query(\n3\n, \n5\n)); \n\nSystem.out.println(query(\n2\n, \n4\n)); \n} \n} \n\n// This code is contributed \n// by Kirti_Mangal ", "complexity": "nlogn", "from": "CorCod", "problem": 612, "index": 612}
{"src": "\n// Java program to find minimum sum of \n// absolute differences of two arrays. \nimport\njava.util.Arrays; \n\nclass\nMinSum \n{ \n\n// Returns minimum possible pairwise \n\n// absolute difference of two arrays. \n\nstatic\nlong\nfindMinSum(\nlong\na[], \nlong\nb[], \nlong\nn) \n\n{ \n\n// Sort both arrays \n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n// Find sum of absolute differences \n\nlong\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum = sum + Math.abs(a[i] - b[i]); \n\n\nreturn\nsum; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Both a[] and b[] must be of same size. \n\nlong\na[] = {\n4\n, \n1\n, \n8\n, \n7\n}; \n\nlong\nb[] = {\n2\n, \n3\n, \n6\n, \n5\n}; \n\nint\nn = a.length; \n\nSystem.out.println(findMinSum(a, b, n)); \n\n} \n} \n\n// This code is contributed by Raghav Sharma ", "complexity": "nlogn", "from": "CorCod", "problem": 613, "index": 613}
{"src": "//Author: Patel Rag\n//Java version \"1.8.0_211\"\nimport java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    //binary Modular exponentiation\n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    int n = fr.nextInt();\n    int q = fr.nextInt();\n    long[] a = new long[n];\n    long[] k = new long[q];\n    for(int i = 0; i < n; i++) a[i] = fr.nextLong();\n    for(int i = 0; i < q; i++) k[i] = fr.nextLong();\n    long[] pre = new long[n];\n    pre[0] = a[0];\n    for(int i = 1; i < n; i++) pre[i] = pre[i-1] + a[i];\n    long pd = 0;\n    for(int i = 0; i < q; i++)\n    {\n      int l = 0;\n      int r = n - 1;\n      while(r > l)\n      {\n        int mid = (l + r) >> 1;\n\n        if(pre[mid] - pd < k[i])\n        {\n          l = mid + 1;\n        }\n        else if(pre[mid] - pd > k[i])\n        {\n          r = mid - 1;\n        }\n        else\n        {\n          l = r = mid;\n        }\n      }\n      int ans = 0;\n      if(pre[l] - pd <= k[i])\n      {\n        ans = n - l - 1;\n      }\n      else\n      {\n        ans = n - l;\n      }\n      if(ans == 0) ans  = n;\n      pd = pd + k[i];\n      if(pd >= pre[n-1]) pd = 0;\n      System.out.println(ans);\n    }\n  }\n}\nclass pair\n{\n  public int first;\n  public int second;\n  public pair(int first,int second)\n  {\n    this.first = first;\n    this.second = second;\n  }\n  public pair(pair p)\n  {\n    this.first = p.first;\n    this.second = p.second;\n  }\n  public int first() { return first; }\n  public int second() { return second; }\n  public void setFirst(int first) { this.first = first; }\n  public void setSecond(int second) { this.second = second; }\n}\nclass myComp implements Comparator<pair>\n{\n  public int compare(pair a,pair b)\n  {\n    if(a.first != b.first) return (a.first - b.first);\n    return (b.second - a.second);\n  }\n}\nclass BIT       //Binary Indexed Tree aka Fenwick Tree\n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 614, "index": 614}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author \\/\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n\n            TaskC.pair[] songs = new TaskC.pair[n];\n            long sum = 0;\n            for (int i = 0; i < n; i++) {\n                songs[i] = new TaskC.pair(in.nextInt(), in.nextInt());\n                sum += songs[i].a;\n            }\n            Arrays.sort(songs);\n\n            int res = 0;\n            int idx = n - 1;\n            while (sum > m) {\n                if (idx < 0) {\n                    break;\n                }\n                sum -= (songs[idx].a - songs[idx].b);\n\n                res++;\n                idx--;\n            }\n\n            if (sum > m) {\n                out.println(-1);\n            } else {\n                out.println(res);\n            }\n        }\n\n        static class pair implements Comparable<TaskC.pair> {\n            int a;\n            int b;\n\n            pair(int a, int b) {\n                this.a = a;\n                this.b = b;\n            }\n\n            public int compareTo(TaskC.pair p) {\n                return (this.a - this.b) - (p.a - p.b);\n            }\n\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "from": "CorCod", "problem": 615, "index": 615}
{"src": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    static int n;\n     static long TotalTime;\n    static Problem[] problems;\n    static StringBuilder sb;\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        sb = new StringBuilder();\n        n = sc.nextInt();\n        TotalTime = sc.nextLong();\n        problems = new Problem[n];\n        for (int i = 0; i < n; i++) {\n            problems[i] = new Problem (sc.nextInt(), sc.nextLong(), i);\n        }\n        Arrays.sort(problems);\n        long num = -1;\n        long high = n;\n        long low = 0;\n        int iter = 0;\n        while (high - low > 1) {\n            num = (high + low) / 2;\n            if (test(num, false)) {\n                low = num;\n            }\n            else {\n                high = num;\n            }\n        }\n        if (test(high, false))\n            num = high;\n        else\n            num = low;\n        test(num, true);\n        System.out.print(sb);\n    }\n\n    public static boolean test (long num, boolean print) {\n        int count = 0;\n        long sum = 0L;\n        if (print) sb.append(num + \"\\n\" + num + \"\\n\");\n        for (int i = 0; i < n && count < num; i++) {\n            if (problems[i].a >= num) {\n                count++;\n                sum += problems[i].t;\n                if (print) sb.append((problems[i].index + 1) + \" \");\n            }\n        }\n        return (count == num) && (sum <= TotalTime);\n    }\n\n    public static class Problem implements Comparable<Problem>  {\n        int a;\n        long t;\n        int index;\n        \n        public int compareTo(Problem o) {\n          return Long.compare(t, o.t);\n        }\n        public Problem (int a, long t, int index) {\n            this.a = a;\n            this.t = t;\n            this.index = index;\n        }\n    }\n\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextLong();\n            }\n            return a;\n        }\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 616, "index": 616}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n\n    private static int[] a;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt(), m = sc.nextInt();\n\n        a = new int[101];\n        for (int i = 0; i < m; i++) {\n            int type = sc.nextInt();\n            a[type] = a[type] + 1;\n        }\n\n        int lo=1, hi=100, max=0;\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo)/2;\n            if (check(n, mid)) {\n                max = mid;\n                lo = mid+1;\n            } else {\n                hi = mid -1;\n            }\n        }\n        System.out.println(max);\n    }\n\n    public static boolean check(int n, int target) {\n        int result = 0;\n        for (int i=0; i <a.length; i++) {\n            result = result + (a[i] / target);\n        }\n        if (result >= n) {return true;}\n        return false;\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 617, "index": 617}
{"src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }\n    static boolean valid(int i,int j,int r,int c)\n    {\n    if(i<r && i>=0 && j<c && j>=0)\n    return true;\n    else\n    return false;\n    }*/\n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 618, "index": 618}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class c {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tlong bounty = in.nextInt(), increase = in.nextInt();\n\t\tint damage = in.nextInt();\n\t\tint[] mh = new int[n];\n\t\tint[] sh = new int[n];\n\t\tint[] reg = new int[n];\n\t\tlong countKilled = 0;\n\t\tArrayList<Event> es = new ArrayList<>();\n\t\tEvent[] regen = new Event[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tmh[i] = in.nextInt();\n\t\t\tsh[i] = in.nextInt();\n\t\t\treg[i] = in.nextInt();\n\t\t\tif(sh[i] <= damage)\n\t\t\t\tcountKilled++;\n\t\t\tif(reg[i] > 0) {\n\t\t\t\tint time = (damage+1 - sh[i]+reg[i]-1)/reg[i];\n\t\t\t\tif(time > 0 && mh[i] >= damage+1) {\n\t\t\t\t\tEvent e2 = new Event(time, i, damage+1);\n\t\t\t\t\tregen[i] = e2;\n\t\t\t\t\tes.add(e2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tEvent e = new Event(in.nextInt(), in.nextInt()-1, in.nextInt());\n\t\t\tes.add(e);\n\t\t\tif(reg[e.e] > 0) {\n\t\t\t\tint time = (damage+1 - e.h+reg[e.e]-1)/reg[e.e];\n\t\t\t\tif(time > 0 && mh[e.e] >= damage+1) {\n\t\t\t\t\tEvent e2 = new Event(e.t + time, e.e, damage+1);\n\t\t\t\t\te.regen = e2;\n\t\t\t\t\tes.add(e2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(es, (a,b) -> a.t-b.t);\n\t\tlong ans = countKilled*bounty;\n\t\tint lastTime = 0;\n\t\tfor(Event e : es) {\n\t\t\tif(e.t == -1) continue;\n\t\t\tif(regen[e.e] != e && regen[e.e] != null) {\n\t\t\t\tregen[e.e].t = -1;\n\t\t\t\tregen[e.e] = null;\n\t\t\t}\n\t\t\tif(lastTime != e.t) {\n\t\t\t\tans = Math.max(ans, countKilled*(bounty+(e.t-1)*increase));\n\t\t\t}\n\t\t\tif(sh[e.e] <= damage)\n\t\t\t\tcountKilled--;\n\t\t\tsh[e.e] = e.h;\n\t\t\tif(sh[e.e] <= damage)\n\t\t\t\tcountKilled++;\n\t\t\tif(e.regen != null) {\n\t\t\t\tregen[e.e] = e.regen;\n\t\t\t}\n\t\t\tlastTime = e.t;\n\t\t}\n\t\tif(countKilled != 0) {\n\t\t\tif(increase > 0)\n\t\t\t\tans = -1;\n\t\t\telse\n\t\t\t\tans = Math.max(ans, countKilled*bounty);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tstatic class Event {\n\t\tint t;\n\t\tint e;\n\t\tint h;\n\t\tEvent regen;\n\t\tpublic Event(int tt, int ee, int hh) {\n\t\t\tt = tt;\n\t\t\te = ee;\n\t\t\th = hh;\n\t\t}\n\t}\n\tstatic class FastScanner {\n\t    BufferedReader br;\n\t    StringTokenizer st;\n\t    public FastScanner(InputStream i) {\n\t        br = new BufferedReader(new InputStreamReader(i));\n\t        st = new StringTokenizer(\"\");\n\t    }\n\t    public String next() throws IOException {\n\t        if(st.hasMoreTokens())\n\t            return st.nextToken();\n\t        else\n\t            st = new StringTokenizer(br.readLine());\n\t        return next();\n\t    }\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    public long nextLong() throws IOException {\n\t        return Long.parseLong(next());\n\t    }\n\t    public double nextDouble() throws IOException {\n\t        return Double.parseDouble(next());\n\t    }\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 619, "index": 619}
{"src": "\n// Java program to print an array in alternate \n// sorted manner \nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nAlternativeString \n{ \n\n// Function to print alternate sorted values \n\nstatic\nvoid\nalternateSort(\nint\narr[], \nint\nn) \n\n{ \n\nArrays.sort(arr); \n\n\n// Printing the last element of array \n\n// first and then first element and then \n\n// second last element and then second \n\n// element and so on. \n\nint\ni = \n0\n, j = n-\n1\n; \n\nwhile\n(i < j) { \n\nSystem.out.print(arr[j--] + \n\" \"\n); \n\nSystem.out.print(arr[i++] + \n\" \"\n); \n\n} \n\n\n// If the total element in array is odd \n\n// then print the last middle element. \n\nif\n(n % \n2\n!= \n0\n) \n\nSystem.out.print(arr[i]); \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, \n4\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nalternateSort(arr, n); \n\n} \n} \n/*This code is contributed by Prakriti Gupta*/", "complexity": "nlogn", "from": "CorCod", "problem": 620, "index": 620}
{"src": "import java.util.*;\nimport java.io.*;\nimport static java.lang.System.in;\n\npublic class Main {\n    public static void main(String[] args)throws IOException{\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] point = new int[n][];\n        for(int i=0;i<n;i++) point[i] = new int[]{sc.nextInt(),sc.nextInt()};\n        Arrays.sort(point,(a,b)->((a[0]-a[1])-(b[0]-b[1])));\n        TreeMap<Integer,Integer> tm = new TreeMap<>();\n        int ans = 0;\n        for(int i=n-1;i>=0;i--){\n            int x = point[i][0], w = point[i][1];\n            Map.Entry<Integer,Integer> cur =  tm.ceilingEntry(x+w);\n            int curRes;\n            if(cur==null) curRes = 1;\n            else curRes = cur.getValue()+1;\n            ans = Math.max(ans,curRes);\n            Map.Entry<Integer,Integer> upper = tm.ceilingEntry(x-w);\n            if(upper==null||upper.getValue()<curRes) tm.put(x-w,curRes);\n            //Integer key = tm.\n        }\n        System.out.println(ans);\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 621, "index": 621}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author math2do\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int height = in.nextInt();\n            int width = in.nextInt();\n            int n1 = in.nextInt();\n            int n2 = in.nextInt();\n            int v = in.nextInt();\n            int[] p1 = new int[n1];\n            for (int i = 0; i < n1; ++i) p1[i] = in.nextInt();\n            int[] p2 = new int[n2];\n            for (int i = 0; i < n2; ++i) p2[i] = in.nextInt();\n            int nq = in.nextInt();\n            for (int iq = 0; iq < nq; ++iq) {\n                int r1 = in.nextInt();\n                int c1 = in.nextInt();\n                int r2 = in.nextInt();\n                int c2 = in.nextInt();\n                if (r1 == r2) {\n                    out.println(Math.abs(c1 - c2));\n                } else {\n                    long res = Long.MAX_VALUE;\n                    int pos = Arrays.binarySearch(p1, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    pos = Arrays.binarySearch(p2, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    out.println(res);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "from": "CorCod", "problem": 622, "index": 622}
{"src": "\n// Java program for Kruskal's algorithm to find Minimum \n// Spanning Tree of a given connected, undirected and \n// weighted graph \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nGraph \n{ \n\n// A class to represent a graph edge \n\nclass\nEdge \nimplements\nComparable<Edge> \n\n{ \n\nint\nsrc, dest, weight; \n\n\n// Comparator function used for sorting edges \n\n// based on their weight \n\npublic\nint\ncompareTo(Edge compareEdge) \n\n{ \n\nreturn\nthis\n.weight-compareEdge.weight; \n\n} \n\n}; \n\n\n// A class to represent a subset for union-find \n\nclass\nsubset \n\n{ \n\nint\nparent, rank; \n\n}; \n\n\nint\nV, E; \n// V-> no. of vertices & E->no.of edges \n\nEdge edge[]; \n// collection of all edges \n\n\n// Creates a graph with V vertices and E edges \n\nGraph(\nint\nv, \nint\ne) \n\n{ \n\nV = v; \n\nE = e; \n\nedge = \nnew\nEdge[E]; \n\nfor\n(\nint\ni=\n0\n; i<e; ++i) \n\nedge[i] = \nnew\nEdge(); \n\n} \n\n\n// A utility function to find set of an element i \n\n// (uses path compression technique) \n\nint\nfind(subset subsets[], \nint\ni) \n\n{ \n\n// find root and make root as parent of i (path compression) \n\nif\n(subsets[i].parent != i) \n\nsubsets[i].parent = find(subsets, subsets[i].parent); \n\n\nreturn\nsubsets[i].parent; \n\n} \n\n\n// A function that does union of two sets of x and y \n\n// (uses union by rank) \n\nvoid\nUnion(subset subsets[], \nint\nx, \nint\ny) \n\n{ \n\nint\nxroot = find(subsets, x); \n\nint\nyroot = find(subsets, y); \n\n\n// Attach smaller rank tree under root of high rank tree \n\n// (Union by Rank) \n\nif\n(subsets[xroot].rank < subsets[yroot].rank) \n\nsubsets[xroot].parent = yroot; \n\nelse\nif\n(subsets[xroot].rank > subsets[yroot].rank) \n\nsubsets[yroot].parent = xroot; \n\n\n// If ranks are same, then make one as root and increment \n\n// its rank by one \n\nelse\n\n{ \n\nsubsets[yroot].parent = xroot; \n\nsubsets[xroot].rank++; \n\n} \n\n} \n\n\n// The main function to construct MST using Kruskal's algorithm \n\nvoid\nKruskalMST() \n\n{ \n\nEdge result[] = \nnew\nEdge[V]; \n// Tnis will store the resultant MST \n\nint\ne = \n0\n; \n// An index variable, used for result[] \n\nint\ni = \n0\n; \n// An index variable, used for sorted edges \n\nfor\n(i=\n0\n; i<V; ++i) \n\nresult[i] = \nnew\nEdge(); \n\n\n// Step 1: Sort all the edges in non-decreasing order of their \n\n// weight. If we are not allowed to change the given graph, we \n\n// can create a copy of array of edges \n\nArrays.sort(edge); \n\n\n// Allocate memory for creating V ssubsets \n\nsubset subsets[] = \nnew\nsubset[V]; \n\nfor\n(i=\n0\n; i<V; ++i) \n\nsubsets[i]=\nnew\nsubset(); \n\n\n// Create V subsets with single elements \n\nfor\n(\nint\nv = \n0\n; v < V; ++v) \n\n{ \n\nsubsets[v].parent = v; \n\nsubsets[v].rank = \n0\n; \n\n} \n\n\ni = \n0\n; \n// Index used to pick next edge \n\n\n// Number of edges to be taken is equal to V-1 \n\nwhile\n(e < V - \n1\n) \n\n{ \n\n// Step 2: Pick the smallest edge. And increment \n\n// the index for next iteration \n\nEdge next_edge = \nnew\nEdge(); \n\nnext_edge = edge[i++]; \n\n\nint\nx = find(subsets, next_edge.src); \n\nint\ny = find(subsets, next_edge.dest); \n\n\n// If including this edge does't cause cycle, \n\n// include it in result and increment the index \n\n// of result for next edge \n\nif\n(x != y) \n\n{ \n\nresult[e++] = next_edge; \n\nUnion(subsets, x, y); \n\n} \n\n// Else discard the next_edge \n\n} \n\n\n// print the contents of result[] to display \n\n// the built MST \n\nSystem.out.println(\n\"Following are the edges in \"\n+ \n\n\"the constructed MST\"\n); \n\nfor\n(i = \n0\n; i < e; ++i) \n\nSystem.out.println(result[i].src+\n\" -- \"\n+ \n\nresult[i].dest+\n\" == \"\n+ result[i].weight); \n\n} \n\n\n// Driver Program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n/* Let us create following weighted graph \n\n10 \n\n0--------1 \n\n| \\ | \n\n6| 5\\ |15 \n\n| \\ | \n\n2--------3 \n\n4 */\n\nint\nV = \n4\n; \n// Number of vertices in graph \n\nint\nE = \n5\n; \n// Number of edges in graph \n\nGraph graph = \nnew\nGraph(V, E); \n\n\n// add edge 0-1 \n\ngraph.edge[\n0\n].src = \n0\n; \n\ngraph.edge[\n0\n].dest = \n1\n; \n\ngraph.edge[\n0\n].weight = \n10\n; \n\n\n// add edge 0-2 \n\ngraph.edge[\n1\n].src = \n0\n; \n\ngraph.edge[\n1\n].dest = \n2\n; \n\ngraph.edge[\n1\n].weight = \n6\n; \n\n\n// add edge 0-3 \n\ngraph.edge[\n2\n].src = \n0\n; \n\ngraph.edge[\n2\n].dest = \n3\n; \n\ngraph.edge[\n2\n].weight = \n5\n; \n\n\n// add edge 1-3 \n\ngraph.edge[\n3\n].src = \n1\n; \n\ngraph.edge[\n3\n].dest = \n3\n; \n\ngraph.edge[\n3\n].weight = \n15\n; \n\n\n// add edge 2-3 \n\ngraph.edge[\n4\n].src = \n2\n; \n\ngraph.edge[\n4\n].dest = \n3\n; \n\ngraph.edge[\n4\n].weight = \n4\n; \n\n\ngraph.KruskalMST(); \n\n} \n} \n//This code is contributed by Aakash Hasija ", "complexity": "nlogn", "from": "CorCod", "problem": 623, "index": 623}
{"src": "\n// Java program to find maximum pair sum whose \n// difference is less than K \n\nimport\njava.io.*; \nimport\njava .util.*; \n\nclass\nGFG { \n\n\n// Method to return maximum sum we can get by \n\n// finding less than K difference pairs \n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nk) \n\n{ \n\nint\nmaxSum = \n0\n; \n\n\n// Sort elements to ensure every i and i-1 is closest \n\n// possible pair \n\nArrays.sort(arr); \n\n\n// To get maximum possible sum, iterate from largest \n\n// to smallest, giving larger numbers priority over \n\n// smaller numbers. \n\nfor\n(\nint\ni = N-\n1\n; i > \n0\n; --i) \n\n{ \n\n// Case I: Diff of arr[i] and arr[i-1] is less then K, \n\n// add to maxSum \n\n// Case II: Diff between arr[i] and arr[i-1] is not less \n\n// then K, move to next i since with sorting we \n\n// know, arr[i]-arr[i-1] < arr[i]-arr[i-2] and \n\n// so on. \n\nif\n(arr[i] - arr[i-\n1\n] < k) \n\n{ \n\n//Assuming only positive numbers. \n\nmaxSum += arr[i]; \n\nmaxSum += arr[i-\n1\n]; \n\n\n//When a match is found skip this pair \n\n--i; \n\n} \n\n} \n\n\nreturn\nmaxSum; \n\n} \n\n\n// Driver code to test above methods \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n} \n} \n\n//This code is contributed by vt_m. ", "complexity": "nlogn", "from": "CorCod", "problem": 624, "index": 624}
{"src": "\n// Java program to solve fractional Knapsack Problem \nimport\njava.util.Arrays; \nimport\njava.util.Comparator; \n\n// Greedy approach \npublic\nclass\nFractionalKnapSack \n{ \n\n// Time complexity O(n log n) \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] wt = {\n10\n, \n40\n, \n20\n, \n30\n}; \n\nint\n[] val = {\n60\n, \n40\n, \n100\n, \n120\n}; \n\nint\ncapacity = \n50\n; \n\n\ndouble\nmaxValue = getMaxValue(wt, val, capacity); \n\nSystem.out.println(\n\"Maximum value we can obtain = \"\n+ \n\nmaxValue); \n\n\n} \n\n\n// function to get maximum value \n\nprivate\nstatic\ndouble\ngetMaxValue(\nint\n[] wt, \n\nint\n[] val, \nint\ncapacity) \n\n{ \n\nItemValue[] iVal = \nnew\nItemValue[wt.length]; \n\n\nfor\n(\nint\ni = \n0\n; i < wt.length; i++) \n\n{ \n\niVal[i] = \nnew\nItemValue(wt[i], val[i], i); \n\n} \n\n\n//sorting items by value; \n\nArrays.sort(iVal, \nnew\nComparator<ItemValue>() \n\n{ \n\n@Override\n\npublic\nint\ncompare(ItemValue o1, ItemValue o2) \n\n{ \n\nreturn\no2.cost.compareTo(o1.cost) ; \n\n} \n\n}); \n\n\n\ndouble\ntotalValue = 0d; \n\n\nfor\n(ItemValue i: iVal) \n\n{ \n\n\nint\ncurWt = (\nint\n) i.wt; \n\nint\ncurVal = (\nint\n) i.val; \n\n\nif\n(capacity - curWt >= \n0\n) \n\n{ \n\n// this weight can be picked while \n\ncapacity = capacity-curWt; \n\ntotalValue += curVal; \n\n\n} \n\nelse\n\n{ \n\n// item cant be picked whole \n\ndouble\nfraction = ((\ndouble\n)capacity/(\ndouble\n)curWt); \n\ntotalValue += (curVal*fraction); \n\ncapacity = (\nint\n)(capacity - (curWt*fraction)); \n\nbreak\n; \n\n} \n\n\n\n} \n\n\nreturn\ntotalValue; \n\n} \n\n\n// item value class \n\nstatic\nclass\nItemValue \n\n{ \n\nDouble cost; \n\ndouble\nwt, val, ind; \n\n\n// item value function \n\npublic\nItemValue(\nint\nwt, \nint\nval, \nint\nind) \n\n{ \n\nthis\n.wt = wt; \n\nthis\n.val = val; \n\nthis\n.ind = ind; \n\ncost = \nnew\nDouble(val/wt ); \n\n} \n\n} \n} ", "complexity": "nlogn", "from": "CorCod", "problem": 625, "index": 625}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            long x=Long.parseLong(s1[1]);\n            long y=Long.parseLong(s1[2]);\n            long S=0;\n            long mod=1000000007;\n            B a[]=new B[n];\n            TreeMap<Long,Long> tm=new TreeMap<Long,Long>();\n            long ans[]=new long[n];\n            for(int i=0;i<n;i++)\n            {\n              String s2[]=br.readLine().split(\" \");\n              long l=Long.parseLong(s2[0]);\n              long r=Long.parseLong(s2[1]);\n              B b1=new B(l,r);\n              a[i]=b1;\n            }\n            Arrays.sort(a,new The_Comp());\n            \n            for(int i=0;i<n;i++)\n            {\n                  long l=a[i].x;\n                  long r=a[i].y;\n                  if(tm.floorKey(l-1)!=null)\n                  {\n                        long u=tm.floorKey(l-1);\n                        long v=l;\n                        if((v-u)*y<x)\n                        { ans[i]=((r-u)*y)%mod; \n                          if(tm.get(u)>1)\n                           tm.put(u,tm.get(u)-1);\n                          else\n                          tm.remove(u); \n                        }\n                        else\n                        { ans[i]=(x+(r-l)*y)%mod; }\n                  }\n                  else\n                   ans[i]=(x+(r-l)*y)%mod;\n                  S=(S+ans[i])%mod;\n                  if(tm.containsKey(r))\n                   tm.put(r,1+tm.get(r));\n                  else\n                   tm.put(r,(long)1);\n            }\n            System.out.println(S);\n      }\n}\n\n\nclass The_Comp implements Comparator<B>\n{\n      public int compare(B b1,B b2)\n      {\n            if(b1.x>b2.x)\n             return 1;\n            else if(b1.x==b2.x)\n            {\n            if(b1.y>b2.y)\n             return 1;\n            else if(b1.y==b2.y)\n             return 0;\n            else\n             return -1;\n            }\n            else\n             return -1;\n      }\n}\nclass B\n{\n      long x=(long)1;\n      long y=(long)1;\n      public B(long l1,long l2)\n      { x=l1;  y=l2; }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 626, "index": 626}
{"src": "\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Andy Phan\n */\npublic class p1096f {\n    static long MOD = 998244353;\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        BIT invert = new BIT(n+5);\n        BIT neg = new BIT(n+5);\n        long res = 0;\n        int[] arr = new int[n];\n        boolean[] has = new boolean[n+1];\n        long num1 = 0;\n        for(int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n            if(arr[i] != -1) {\n                res += invert.read(n+5)-invert.read(arr[i]);\n                res %= MOD;\n                invert.update(arr[i], 1);\n                has[arr[i]] = true;\n            } else num1++;\n        }\n        if(num1 == 0) {\n            System.out.println(res);\n            return;\n        }\n        for(int i = 1; i <= n; i++) if(!has[i]) neg.update(i, 1);\n        long invertNum1 = modInv(num1, MOD);\n        res += ((num1*(num1-1))%MOD)*modInv(4, MOD);\n        res %= MOD;\n        long cnt = 0;\n        for(int i = 0; i < n; i++) {\n            if(arr[i] == -1) {\n                cnt++;\n                continue;\n            }\n            res += (((neg.read(n+5)-neg.read(arr[i]))*cnt)%MOD)*invertNum1;\n            res %= MOD;\n        }\n        cnt = 0;\n        for(int i = n-1; i >= 0; i--) {\n            if(arr[i] == -1) {\n                cnt++;\n                continue;\n            }\n            res += (((neg.read(arr[i]))*cnt)%MOD)*invertNum1;\n            res %= MOD;\n        }\n        System.out.println(res);\n    }\n    \n    //@\n    static class BIT {\n            int n;\n            int[] tree;\n            public BIT(int n) {\n                    this.n = n;\n                    tree = new int[n + 1];\n            }\n\n            int read(int i) {\n                    int sum = 0;\n                    while (i > 0) {\n                            sum += tree[i];\n                            i -= i & -i;\n                    }\n                    return sum;\n            }\n\n            void update(int i, int val) {\n                    while (i <= n) {\n                            tree[i] += val;\n                            i += i & -i;\n                    }\n            }\n            //$\n    }\n\n    \n    //@\n    // Computes the modular inverse of x\n    // Returns 0 if the GCD of x and mod is not 1\n    // O(log n)  :  Can be converted to use BigIntegers\n    static long modInv(long x, long mod) {\n        return (BigInteger.valueOf(x).modInverse(BigInteger.valueOf(mod))).longValue();\n    }\n\n    static long modInv(long a, long b, long y0, long y1, long q0, long q1) {\n            long y2 = y0 - y1*q0;\n            return b == 0 ? y2 : modInv(b, a % b, y1, y2, q1, a / b);\n    }\n    \n    //@\n    static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }\n    static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 627, "index": 627}
{"src": "\n// Java program to acquire \n// all n coins \nimport\njava.util.Arrays; \n\nclass\nGFG \n{ \n\n\n// function to calculate min cost \n\nstatic\nint\nminCost(\nint\ncoin[], \n\nint\nn, \nint\nk) \n\n{ \n\n\n// sort the coins value \n\nArrays.sort(coin); \n\n\n// calculate no. of \n\n// coins needed \n\nint\ncoins_needed = (\nint\n)Math.ceil(\n1.0\n* \n\nn / (k + \n1\n)); \n\n\n// calculate sum of \n\n// all selected coins \n\nint\nans = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i <= coins_needed - \n1\n; \n\ni++) \n\nans += coin[i]; \n\n\nreturn\nans; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ncoin[] = { \n8\n, \n5\n, \n3\n, \n10\n, \n\n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\nint\nk = \n3\n; \n\n\nSystem.out.print(minCost(coin, n, k)); \n\n} \n} \n\n// This code is contributed \n// by Anant Agarwal. ", "complexity": "nlogn", "from": "CorCod", "problem": 628, "index": 628}
{"src": "import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] wide = new int[n], sta = new int[n];\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n        for (int i = 0; i < n; i++) {\n        \twide[i] = sc.nextInt();\n        \thm.put(wide[i], i + 1);\n        }\n        Util.sort(wide);\n        sc.nextLine();\n        String s = sc.nextLine();\n        int tp = 0, pos = 0;\n        StringBuilder out = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n        \tint t;\n        \tif (s.charAt(i) == '0') {\n        \t\tt = wide[pos++];\n        \t\tsta[tp++] = t;\n        \t} else t = sta[--tp];\n        \tout.append(hm.get(t) + \" \");\n        }\n        System.out.println(out.toString());\n        sc.close();\n    }\n    public static class Util {\n    \t\n    \tpublic static <T extends Comparable<T> > void merge_sort(T[] a) {\n    \t\tObject[] aux = new Object[a.length];\n    \t\tmerge_sort0(a, aux, 0, a.length);\n    \t}\n    \t\n    \tpublic static <T extends Comparable<T> > void merge_sort(T[] a, int l, int r) {\n    \t\tObject[] aux = new Object[a.length];\n    \t\tmerge_sort0(a, aux, l, r);\n    \t}\n    \t\n    \t@SuppressWarnings(\"unchecked\")\n    \tprivate static <T extends Comparable<T> > void merge_sort0(T[] a, Object[] temp, int l, int r) {\n    \t\tif (l + 1 == r) return;\n    \t\tint mid = (l + r) >> 1;\n    \t\tmerge_sort0(a, temp, l, mid);\n    \t\tmerge_sort0(a, temp, mid, r);\n    \t\tint x = l, y = mid, c = l;\n    \t\twhile (x < mid || y < r) {\n    \t\t\tif (y == r || (x < mid && a[x].compareTo(a[y]) <= 0)) temp[c++] = a[x++];\n    \t\t\telse temp[c++] = a[y++];\n    \t\t}\n    \t\tfor (int i = l; i < r; i++) a[i] = (T)temp[i];\n    \t}\n    \t\n    \tstatic final Random RAN = new Random();\n    \t\n    \tpublic static <T extends Comparable<T> > void quick_sort(T[] a) {\n    \t\tquick_sort0(a, 0, a.length);\n    \t}\n    \t\n    \tpublic static <T extends Comparable<T> > void quick_sort(T[] a, int l, int r) {\n    \t\tquick_sort0(a, l, r);\n    \t}\n    \t\n    \tprivate static <T extends Comparable<T> > void quick_sort0(T[] a, int l, int r) {\n    \t\tif (l + 1 >= r) return;\n    \t\tint p = l + RAN.nextInt(r - l);\n    \t\tT t = a[p]; a[p] = a[l]; a[l] = t;\n    \t\tint x = l, y = r - 1;\n    \t\twhile (x < y) {\n    \t\t\twhile (x < y && a[y].compareTo(t) > 0) --y;\n    \t\t\twhile (x < y && a[x].compareTo(t) < 0) ++x;\n    \t\t\tif (x < y) {\n    \t\t\t\tT b = a[x]; a[x] = a[y]; a[y] = b;\n    \t\t\t\t++x; --y;\n    \t\t\t}\n    \t\t}\n    \t\tquick_sort0(a, l, y + 1);\n    \t\tquick_sort0(a, x, r);\n    \t}\n    \t\n    \tstatic final int BOUND = 8;\n    \t\n    \tpublic static void bucket_sort(int[] a) {\n    \t\tbucket_sort(a, 0, a.length);\n    \t}\n    \t\n    \tpublic static void bucket_sort(int[] a, int l, int r) {\n    \t\tint[] cnt = new int[1 << BOUND], b = new int[r - l + 1];\n    \t\tint y = 0;\n    \t\tfor (int i = l; i < r; i++) ++cnt[a[i] & (1 << BOUND) - 1];\n    \t\twhile (y < Integer.SIZE) {\n    \t\t\tfor (int i = 1; i < 1 << BOUND; i++) cnt[i] += cnt[i - 1];\n    \t\t\tfor (int i = r - 1; i >= l; i--) b[--cnt[a[i] >> y & (1 << BOUND) - 1]] = a[i];\n    \t\t\ty += BOUND;\n    \t\t\tArrays.fill(cnt, 0);\n    \t\t\tfor (int i = l; i < r; i++) {\n    \t\t\t\ta[i] = b[i - l];\n    \t\t\t\t++cnt[a[i] >> y & (1 << BOUND) - 1];\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \tpublic static void bucket_sort(long[] a) {\n    \t\tbucket_sort(a, 0, a.length);\n    \t}\n    \t\n    \tpublic static void bucket_sort(long[] a, int l, int r) {\n    \t\tint[] cnt = new int[1 << BOUND];\n    \t\tlong[] b = new long[r - l + 1];\n    \t\tint y = 0;\n    \t\twhile (y < Long.SIZE) {\n    \t\t\tArrays.fill(cnt, 0);\n    \t\t\tfor (int i = l; i < r; i++) ++cnt[(int) (a[i] >> y & (1 << BOUND) - 1)];\n    \t\t\tfor (int i = 1; i < 1 << BOUND; i++) cnt[i] += cnt[i - 1];\n    \t\t\tfor (int i = r - 1; i >= l; i--) b[--cnt[(int) (a[i] >> y & (1 << BOUND) - 1)]] = a[i];\n    \t\t\tfor (int i = l; i < r; i++) a[i] = b[i - l];\n    \t\t\ty += BOUND;\n    \t\t}\n    \t}\n    \t\n    \tpublic static void sort(int[] a) {\n    \t\tif (a.length <= 1 << BOUND) {\n    \t\t\tInteger[] b = new Integer[a.length];\n    \t\t\tfor (int i = 0; i < a.length; i++) b[i] = a[i];\n    \t\t\tquick_sort(b);\n    \t\t\tfor (int i = 0; i < a.length; i++) a[i] = b[i];\n    \t\t} else bucket_sort(a);\n    \t}\n\n    \tpublic static void sort(long[] a) {\n    \t\tif (a.length <= 1 << BOUND) {\n    \t\t\tLong[] b = new Long[a.length];\n    \t\t\tfor (int i = 0; i < a.length; i++) b[i] = a[i];\n    \t\t\tquick_sort(b);\n    \t\t\tfor (int i = 0; i < a.length; i++) a[i] = b[i];\n    \t\t} else bucket_sort(a);\n    \t}\n    \t\n    \tpublic static <T extends Comparable<T> > void sort(T[] a) {\n    \t\tquick_sort(a);\n    \t}\n    \t\n    \tpublic static void shuffle(int[] a) {\n    \t\tRandom ran = new Random();\n    \t\tfor (int i = 0; i < a.length; i++) {\n    \t\t\tint p = ran.nextInt(i + 1);\n    \t\t\tint q = a[p]; a[p] = a[i]; a[i] = q; \n    \t\t}\n    \t}\n    \t\n    \tpublic static void shuffle(long[] a) {\n    \t\tRandom ran = new Random();\n    \t\tfor (int i = 0; i < a.length; i++) {\n    \t\t\tint p = ran.nextInt(i + 1);\n    \t\t\tlong q = a[p]; a[p] = a[i]; a[i] = q; \n    \t\t}\n    \t}\n    \t\n    \tpublic static <T> void shuffle(T[] a) {\n    \t\tRandom ran = new Random();\n    \t\tfor (int i = 0; i < a.length; i++) {\n    \t\t\tint p = ran.nextInt(i + 1);\n    \t\t\tT q = a[p]; a[p] = a[i]; a[i] = q; \n    \t\t}\n    \t}\n    \t\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 629, "index": 629}
{"src": "// discussed with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF915E {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint q = Integer.parseInt(br.readLine());\n\t\tTreeMap<Integer, Integer> mp = new TreeMap<>();\n\t\tint ans = 0;\n\t\twhile (q-- > 0) {\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\tint l = Integer.parseInt(st.nextToken()) - 1;\n\t\t\tint r = Integer.parseInt(st.nextToken());\n\t\t\tint t = Integer.parseInt(st.nextToken());\n\t\t\tMap.Entry<Integer, Integer> e;\n\t\t\tint l_, r_;\n\t\t\tif (t == 1) {\n\t\t\t\tif ((e = mp.floorEntry(l)) != null && (r_ = e.getValue()) >= l) {\n\t\t\t\t\tl_ = e.getKey();\n\t\t\t\t\tans -= r_ - l_;\n\t\t\t\t\tl = l_;\n\t\t\t\t\tr = Math.max(r, r_);\n\t\t\t\t}\n\t\t\t\twhile ((e = mp.higherEntry(l)) != null && (l_ = e.getKey()) <= r) {\n\t\t\t\t\tr_ = e.getValue();\n\t\t\t\t\tans -= r_ - l_;\n\t\t\t\t\tr = Math.max(r, r_);\n\t\t\t\t\tmp.remove(l_);\n\t\t\t\t}\n\t\t\t\tans += r - l;\n\t\t\t\tmp.put(l, r);\n\t\t\t} else {\n\t\t\t\tr_ = l;\n\t\t\t\tif ((e = mp.floorEntry(l)) != null && (r_ = e.getValue()) > l) {\n\t\t\t\t\tl_ = e.getKey();\n\t\t\t\t\tif (l_ < l)\n\t\t\t\t\t\tmp.put(l_, l);\n\t\t\t\t\telse\n\t\t\t\t\t\tmp.remove(l_);\n\t\t\t\t\tans -= r_ - l;\n\t\t\t\t}\n\t\t\t\twhile ((e = mp.higherEntry(l)) != null && (l_ = e.getKey()) < r) {\n\t\t\t\t\tr_ = e.getValue();\n\t\t\t\t\tmp.remove(l_);\n\t\t\t\t\tans -= r_ - l_;\n\t\t\t\t}\n\t\t\t\tif (r_ > r) {\n\t\t\t\t\tmp.put(r, r_);\n\t\t\t\t\tans += r_ - r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpw.println(n - ans);\n\t\t}\n\t\tpw.close();\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 630, "index": 630}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeMap;\nimport java.util.Map;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Ribhav\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CGlassCarving solver = new CGlassCarving();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CGlassCarving {\n        public void solve(int testNumber, FastReader s, PrintWriter out) {\n            TreeMap<Long, Integer> mapH = new TreeMap<>();\n            TreeMap<Long, Integer> mapV = new TreeMap<>();\n            TreeMap<Long, Integer> hDiff = new TreeMap<>();\n            TreeMap<Long, Integer> vDiff = new TreeMap<>();\n            long width = s.nextInt();\n            long height = s.nextInt();\n            mapH.put(0L, 1);\n            mapV.put(0L, 1);\n            mapV.put(width, 1);\n            mapH.put(height, 1);\n            vDiff.put(width, 1);\n            hDiff.put(height, 1);\n            long maxV = height;\n            long maxH = width;\n            int n = s.nextInt();\n            for (int i = 0; i < n; i++) {\n                char ch = s.nextCharacter();\n                long cut = s.nextInt();\n                if (ch == 'H') {\n                    Long next = mapH.higherKey(cut);\n                    Long prev = mapH.lowerKey(cut);\n                    Long diff = next - prev;\n                    int freq = hDiff.get(diff);\n                    if (freq == 1) {\n                        hDiff.remove(diff);\n                    } else {\n                        hDiff.put(diff, freq - 1);\n                    }\n                    hDiff.put(next - cut, hDiff.getOrDefault(next - cut, 0) + 1);\n                    hDiff.put(cut - prev, hDiff.getOrDefault(cut - prev, 0) + 1);\n                    mapH.put(cut, mapH.getOrDefault(cut, 0) + 1);\n                } else {\n                    Long next = mapV.higherKey(cut);\n                    Long prev = mapV.lowerKey(cut);\n                    Long diff = next - prev;\n                    int freq = vDiff.get(diff);\n                    if (freq == 1) {\n                        vDiff.remove(diff);\n                    } else {\n                        vDiff.put(diff, freq - 1);\n                    }\n                    vDiff.put(next - cut, vDiff.getOrDefault(next - cut, 0) + 1);\n                    vDiff.put(cut - prev, vDiff.getOrDefault(cut - prev, 0) + 1);\n                    mapV.put(cut, mapV.getOrDefault(cut, 0) + 1);\n                }\n\n                out.println(hDiff.lastKey() * vDiff.lastKey());\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char nextCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "from": "CorCod", "problem": 631, "index": 631}
{"src": "\n// Sorting based Java program to find \n// all elements in array which have \n// atleast two greater elements itself. \nimport\njava.util.*; \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n2\n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n,\n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n\n} \n} \n\n// This code is contributed by Sahil_Bansall ", "complexity": "nlogn", "from": "CorCod", "problem": 632, "index": 632}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tstatic void insert(TreeMap<Integer, Integer>map,int v,int d)\n\t{\n\t\tif(!map.containsKey(v))map.put(v, 0);\n\t\tmap.put(v, d+map.get(v));\n\t\tif(map.get(v)==0)map.remove(v);\n\t}\n\t\n\tstatic void cut(TreeSet<Integer> cuts, TreeMap<Integer, Integer>segments,int v)\n\t{\n\t\tint upper = cuts.higher(v) , lower = cuts.lower(v);\n\t\tinsert(segments, upper-lower, -1);\n\t\tinsert(segments, upper-v, 1);\n\t\tinsert(segments, v-lower, 1);\n\t\tcuts.add(v);\n\t}\n\t\n\tpublic static void main(String[] args) throws Throwable {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint w = sc.nextInt(), h = sc.nextInt() , n = sc.nextInt();\n\t\tTreeSet<Integer> vCuts = new TreeSet<>() , hCuts = new TreeSet<>();\n\t\tTreeMap<Integer, Integer> vSegments = new TreeMap<>() , hSegments = new TreeMap<>();\n\t\tvCuts.add(0);vCuts.add(w);\n\t\thCuts.add(0);hCuts.add(h);\n\t\tinsert(vSegments, w, 1);\n\t\tinsert(hSegments, h, 1);\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(n-->0)\n\t\t{\n\t\t\tif(sc.next().equals(\"H\"))\n\t\t\t\tcut(hCuts, hSegments, sc.nextInt());\n\t\t\telse\n\t\t\t\tcut(vCuts, vSegments, sc.nextInt());\n\t\t\tsb.append(1l*hSegments.lastKey() * vSegments.lastKey() + \"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {br = new BufferedReader(new InputStreamReader(s));}\n\t\tpublic Scanner(String file) throws FileNotFoundException {br = new BufferedReader(new FileReader(file));}\n\t\tpublic String next() throws IOException {while (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();}\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\t\tpublic int[] nexIntArray() throws Throwable {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint[] a = new int[st.countTokens()];\n\t\t\tfor (int i = 0; i < a.length; i++)a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\t}\n}", "complexity": "nlogn", "from": "CorCod", "problem": 633, "index": 633}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[] args){\n        try {\n            new Main().solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    ArrayList<Edge>[]edge;\n    int n,m,cnt=0;\n    int ord;\n    int[]order;int[]vis;\n    Edge[] e;\n    private void solve() throws Exception{\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        n=in.nextInt();m=in.nextInt();\n        edge=new ArrayList[n+1];\n        e=new Edge[m];\n        vis=new int[n+1];\n        order=new int[n+1];\n        for(int i=1;i<=n;i++){\n            edge[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++){\n            int s=in.nextInt(),t=in.nextInt(),c=in.nextInt();\n            edge[s].add(new Edge(s,t,c,i));\n        }\n        int l=0,r=1000000000;\n        while (l<r){\n            int mid=(l+r)>>>1;\n            if(judge(mid,false))r=mid;\n            else l=mid+1;\n        }\n        out.print(l+\" \");\n        judge(l,true);\n        Arrays.sort(e,0,cnt,Comparator.comparingInt(x->x.id));\n        int ans=0;\n        int[]a=new int[m];\n        for(int i=0;i<cnt;i++){\n            if(order[e[i].s]<order[e[i].t])a[ans++]=e[i].id;\n        }\n        out.println(ans);\n        for(int i=0;i<ans;i++){\n            out.print(a[i]+\" \");\n        }\n        out.println();\n        out.flush();\n    }\n    boolean judge(int min,boolean mod){\n        Arrays.fill(vis,0);\n        cycle=false;\n        for(int i=1;i<=n;i++){\n            if(vis[i]==0){\n                dfs(i,min,mod);\n                if(cycle)return false;\n            }\n        }\n        return true;\n    }\n    boolean cycle=false;\n    void dfs(int cur,int min,boolean mod){\n        if(cycle)return;\n        vis[cur]=1;\n        for(Edge e:edge[cur]){\n            if(e.c<=min){\n                if(mod)this.e[cnt++]=e;\n                continue;\n            }\n            if(vis[e.t]==1){\n                cycle=true;return;\n            }\n            else if(vis[e.t]==0)dfs(e.t,min,mod);\n        }\n        vis[cur]=2;\n        if(mod)order[cur]=ord++;\n    }\n}\nclass Edge{\n    int s,t,c,id;\n    Edge(int a,int b,int c,int d){\n        s=a;t=b;this.c=c;id=d;\n    }\n}\nclass InputReader{\n    StreamTokenizer tokenizer;\n    public InputReader(InputStream stream){\n        tokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));\n        tokenizer.ordinaryChars(33,126);\n        tokenizer.wordChars(33,126);\n    }\n    public String next() throws IOException {\n        tokenizer.nextToken();\n        return tokenizer.sval;\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public boolean hasNext() throws IOException {\n        int res=tokenizer.nextToken();\n        tokenizer.pushBack();\n        return res!=tokenizer.TT_EOF;\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 634, "index": 634}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class Problem\n{\n\n    static int mod = (int) (1e9+7);\n    static InputReader in;\n    static PrintWriter out;\n    static int[] rt;\n    static int[] size;\n\n    static void initialize(int n){\n        rt = new int[n + 1];\n        size = new int[n + 1];\n        for(int i = 0; i < rt.length; i++){\n            rt[i] = i;\n            size[i] = 1;\n        }\n    }\n    \n    static int root(int x){\n        while(rt[x] != x){\n            rt[x] = rt[rt[x]];\n            x = rt[x];\n        }\n        return x;\n    }\n    \n    static long union(int x,int y){\n        int root_x = root(x);\n        int root_y = root(y);\n        if(root_x == root_y) return 0;\n        long val = size[root_x] *1l* size[root_y];\n        if(size[root_x]<size[root_y]){\n            rt[root_x] = rt[root_y];\n            size[root_y] += size[root_x];\n        }\n        else{\n            rt[root_y] = rt[root_x];\n            size[root_x] += size[root_y];            \n        }\n        \n        return val;\n    }\n    \n    static void solve()\n    {\n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out);            \n        \n        int t = 1;\n        \n        while(t-- > 0){\n            int n = in.nextInt();\n            int[] arr = in.nextIntArray(n);\n            ArrayList<Pair> list = new ArrayList<>();\n            \n            for(int i = 1; i < n; i++){\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                list.add(new Pair(u, v, Math.max(arr[u],arr[v])));\n            }\n            list.sort((p1,p2) -> Integer.compare(p1.i, p2.i));\n            initialize(n);\n            long s1 = 0;\n            for(int i = 0; i < list.size(); i++){\n                s1 += union(list.get(i).x, list.get(i).y) * list.get(i).i;\n            }\n            for(int i = 0; i < list.size(); i++){\n                Pair p = list.get(i);\n                p.i = Math.min(arr[p.x],arr[p.y]);\n            }\n            list.sort((p1,p2) -> -Integer.compare(p1.i, p2.i));\n            initialize(n);\n            long s2 = 0;\n            for(int i = 0; i < list.size(); i++){\n                s2 += union(list.get(i).x, list.get(i).y) * list.get(i).i;\n            }\n            \n            out.println(s1 - s2);\n        }\n        \n        out.close();\n    }\n    \n    public static void main(String[] args)\n    {\n        new Thread(null ,new Runnable(){\n            public void run(){\n                try{\n                    solve();\n                } catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n        },\"1\",1<<26).start();\n        \n    }\n\n    static class Pair implements Comparable<Pair>\n    {\n\n        int x,y;\n        int i;\n\n\n        Pair (int x,int y)\n        {\n                this.x = x;\n                this.y = y;\n        }\n\n        Pair (int x,int y, int i)\n        {\n                this.x = x;\n                this.y = y;\n                this.i = i;\n        }\n\n        public int compareTo(Pair o)\n        {\n            if(this.x != o.x)\n                return -Integer.compare(this.x, o.y);\n            return -Integer.compare(this.y,o.y);\n                //return 0;\n        }\n\n        public boolean equals(Object o)\n        {\n            if (o instanceof Pair)\n            {\n                Pair p = (Pair)o;\n                return p.x == x && p.y==y;\n            }\n            return false;\n        }\n\n        @Override\n        public String toString()\n        {\n            return x + \" \"+ y + \" \"+i;\n        }\n\n        /*public int hashCode()\n        {\n            return new Long(x).hashCode() * 31 + new Long(y).hashCode();\n        }*/\n\n    } \n\n    static long add(long a,long b){\n        long x=(a+b);\n        while(x>=mod) x-=mod;\n        return x;\n    }\n\n    static long sub(long a,long b){\n        long x=(a-b);\n        while(x<0) x+=mod;\n        return x;\n    }\n    \n    static long mul(long a,long b){\n        long x=(a*b);\n        while(x>=mod) x-=mod;\n        return x;\n    }\n    \n    static String rev(String s){\n        StringBuilder sb=new StringBuilder(s);\n        sb.reverse();\n        return sb.toString();\n    }\n    \n    static long gcd(long x,long y)\n    {\n        if(y==0)\n                return x;\n        else\n                return gcd(y,x%y);\n    }\n\n    static int gcd(int x,int y)\n    {\n        if(y==0)\n                return x;\n        else \n                return gcd(y,x%y);\n    }\n\n    static long pow(long n,long p,long m)\n    {\n         long  result = 1;\n          if(p==0){\n            return n;\n          }\n          \n        while(p!=0)\n        {\n            if(p%2==1)\n                result *= n;\n            if(result >= m)\n               result %= m;\n            p >>=1;\n            n*=n;\n            if(n >= m)\n                n%=m;\n        }\n        \n        return result;\n    }\n\n    static long pow(long n,long p)\n    {\n        long  result = 1;\n          if(p==0)\n            return 1;\n\n        while(p!=0)\n        {\n            if(p%2==1)\n                result *= n;\t    \n            p >>=1;\n            n*=n;\t    \n        }\n        return result;\n    }\n\n    static void debug(Object... o)\n    {\n            System.out.println(Arrays.deepToString(o));\n    }\n\n    static class InputReader\n    {\n\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n                this.stream = stream;\n        }\n\n        public int snext()\n        {\n                if (snumChars == -1)\n                        throw new InputMismatchException();\n                if (curChar >= snumChars)\n                {\n                        curChar = 0;\n                        try\n                        {\n                                snumChars = stream.read(buf);\n                        } catch (IOException e)\n                        {\n                                throw new InputMismatchException();\n                        }\n                        if (snumChars <= 0)\n                                return -1;\n                }\n                return buf[curChar++];\n        }\n\n        public int nextInt()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                {\n                        c = snext();\n                }\n                int sgn = 1;\n                if (c == '-')\n                {\n                        sgn = -1;\n                        c = snext();\n                }\n                int res = 0;\n                do\n                {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n\n        public long nextLong()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                {\n                        c = snext();\n                }\n                int sgn = 1;\n                if (c == '-')\n                {\n                        sgn = -1;\n                        c = snext();\n                }\n                long res = 0;\n                do\n                {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n\n        public int[] nextIntArray(int n)\n        {\n                int a[] = new int[n];\n                for (int i = 0; i < n; i++)\n                {\n                        a[i] = nextInt();\n                }\n                return a;\n        }\n\n        public long[] nextLongArray(int n)\n        {\n                long a[] = new long[n];\n                for (int i = 0; i < n; i++)\n                {\n                        a[i] = nextLong();\n                }\n                return a;\n        }\n\n        public String readString()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                {\n                        c = snext();\n                }\n                StringBuilder res = new StringBuilder();\n                do\n                {\n                        res.appendCodePoint(c);\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res.toString();\n        }\n\n        public String nextLine()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                        c = snext();\n                StringBuilder res = new StringBuilder();\n                do\n                {\n                        res.appendCodePoint(c);\n                        c = snext();\n                } while (!isEndOfLine(c));\n                return res.toString();\n        }\n\n        public boolean isSpaceChar(int c)\n        {\n                if (filter != null)\n                        return filter.isSpaceChar(c);\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c)\n        {\n                return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public interface SpaceCharFilter\n        {\n                public boolean isSpaceChar(int ch);\n        }\n\n    }\n}    \n", "complexity": "nlogn", "from": "CorCod", "problem": 635, "index": 635}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A4 {\n\n    public BufferedReader input;\n    public PrintWriter output;\n    public StringTokenizer stoken = new StringTokenizer(\"\");\n\n    public static void main(String[] args) throws IOException {\n        new A4();\n    }\n\n    A4() throws IOException {\n        input = new BufferedReader(new InputStreamReader(System.in));\n        output = new PrintWriter(System.out);\n        run();\n        input.close();\n        output.close();\n    }\n\n    private void run() throws IOException {\n        int n = Math.toIntExact(nextLong());\n        int m = Math.toIntExact(nextLong());\n        int[] coor = new int[n + 1];\n        int[] ss = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            coor[i] = Math.toIntExact(nextLong());\n        }\n        coor[n] = 1000000000;\n        Arrays.sort(coor);\n        for (int i = 0; i < m; i++) {\n            long x1 = nextLong();\n            long x2 = nextLong();\n            nextLong();\n            if (x1 == 1 && x2 >= coor[0]) {\n                int l = 0;\n                int r = n + 1;\n                while (r - l > 1) {\n                    int mi = (r + l) / 2;\n                    if (coor[mi] > x2) {\n                        r = mi;\n                    } else {\n                        l = mi;\n                    }\n                }\n                ss[l]++;\n            }\n        }\n        long[] ans = new long[n + 1];\n        ans[n] = ss[n] + n;\n        long min = ans[n];\n        for (int i = n - 1; i > -1; i--) {\n            ans[i] = ans[i + 1] - 1 + ss[i];\n            if (ans[i] < min) {\n                min = ans[i];\n            }\n        }\n        System.out.println(min);\n    }\n\n    private Long nextLong() throws NumberFormatException, IOException {\n        return Long.parseLong(nextString());\n    }\n\n    private String nextString() throws IOException {\n        while (!stoken.hasMoreTokens()) {\n            String st = input.readLine();\n            stoken = new StringTokenizer(st);\n        }\n        return stoken.nextToken();\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 636, "index": 636}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class ayyyyyy\n{\n\tpublic static void main(String[] args) { new ayyyyyy(); }\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint t, n;\n\tint[] a;\n\t\n\tayyyyyy()\n\t{\n\t\tt = in.nextInt();\n\t\twhile (t --> 0)\n\t\t{\n\t\t\ta = new int[n = in.nextInt()];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = in.nextInt();\n\t\t\tshuffle(a);\n\t\t\tArrays.sort(a);\n\t\t\tout.println(Math.min(n-2, a[n-2]-1));\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\t\n\tvoid shuffle(int[] x)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint swp = (int)(n*Math.random());\n\t\t\tint tmp = x[swp];\n\t\t\tx[swp] = x[i];\n\t\t\tx[i] = tmp;\n\t\t}\n\t}\n}", "complexity": "nlogn", "from": "CorCod", "problem": 637, "index": 637}
{"src": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tSolution solution = new Solution();\n\t\tSystem.out.println(solution.solve());\n\t}\n\n\tprivate int solve() {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\n\t\tint[] a = new int[m];\n\t\tfor (int i = 0; i < m; ++i) a[i] = in.nextInt();\n\n\t\tif (n > m) return 0;\n\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int k: a) map.put(k, map.getOrDefault(k, 0) + 1);\n\n\t\tList<Integer> keySet = new ArrayList<>(map.keySet());\n\t\tint end = m / n;\n\n\t\tkeySet.sort((u, v) -> -Integer.compare(u, v));\n\t\tdo {\n\t\t\tint count = 0;\n\t\t\tfor (int k: keySet) {\n\t\t\t\tcount += map.get(k) / end;\n\t\t\t\tif (count >= n) return end;\n\t\t\t}\n\t\t} while (--end > 0);\n\n\t\treturn 0;\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 638, "index": 638}
{"src": "import java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        long totalBlocks = 0;\n        long a[] = new long[n];\n        for(int i = 0; i < n; ++i) {\n            a[i] = sc.nextLong();\n            totalBlocks += a[i];\n        }\n\n        Arrays.sort(a);\n\n        long selected = 0;\n        for(int i = 0; i < n; ++i) {\n            if(a[i] > selected)\n                selected++;\n        }\n\n        long leftCols = a[n - 1] - selected;\n        long remBlocks = totalBlocks - leftCols - n;\n\n        System.out.print(remBlocks);\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 639, "index": 639}
{"src": "\n// Java code to find sum of \n// all area rectangle possible \nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nGFG \n{ \n\n// Function to find \n\n// area of rectangles \n\nstatic\nint\nMaxTotalRectangleArea(\nint\n[]a, \n\nint\nn) \n\n{ \n\n\n// sorting the array in \n\n// descending order \n\nArrays.sort(a); \n\n\n// store the final sum of \n\n// all the rectangles area \n\n// possible \n\nint\nsum = \n0\n; \n\nboolean\nflag = \nfalse\n; \n\n\n// temporary variable to \n\n// store the length of rectangle \n\nint\nlen = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n// Selecting the length of \n\n// rectangle so that difference \n\n// between any two number is 1 \n\n// only. Here length is selected \n\n// so flag is set \n\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n!flag) \n\n{ \n\n// flag is set means \n\n// we have got length of \n\n// rectangle \n\nflag = \ntrue\n; \n\n\n// length is set to \n\n// a[i+1] so that if \n\n// a[i] a[i+1] is less \n\n// than by 1 then also \n\n// we have the correct \n\n// choice for length \n\nlen = a[i + \n1\n]; \n\n\n// incrementing the counter \n\n// one time more as we have \n\n// considered a[i+1] element \n\n// also so. \n\ni++; \n\n} \n\n\n// Selecting the width of rectangle \n\n// so that difference between any \n\n// two number is 1 only. Here width \n\n// is selected so now flag is again \n\n// unset for next rectangle \n\nelse\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n(flag)) \n\n{ \n\n// area is calculated for \n\n// rectangle \n\nsum = sum + a[i + \n1\n] * len; \n\n\n// flag is set false \n\n// for another rectangle \n\n// which we can get from \n\n// elements in array \n\nflag = \nfalse\n; \n\n\n// incrementing the counter \n\n// one time more as we have \n\n// considered a[i+1] element \n\n// also so. \n\ni++; \n\n} \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\n[]a = { \n10\n, \n10\n, \n10\n, \n10\n, \n\n11\n, \n10\n, \n11\n, \n10\n, \n\n9\n, \n9\n, \n8\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxTotalRectangleArea(a, n)); \n\n} \n} \n// This code is contributed by \n// Manish Shaw(manishshaw1) ", "complexity": "nlogn", "from": "CorCod", "problem": 640, "index": 640}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskG solver = new TaskG();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG {\n        static int[][] g;\n        static int n;\n        static int[] a;\n        static int[][] edges;\n        static long[] dp;\n        static long[] dpPathToRootWithDetours;\n        static int time = 0;\n        static int[] appearance;\n        static int[] firstAppearance;\n        static int[] depth;\n\n        public static void dfs(int i, int parE) {\n            firstAppearance[i] = time;\n            appearance[time++] = i;\n            dp[i] = a[i];\n            for (int eIndex : g[i]) {\n                if (eIndex == parE) continue;\n                int child = i ^ edges[eIndex][0] ^ edges[eIndex][1];\n                dfs(child, eIndex);\n                appearance[time++] = i;\n                dp[i] += Math.max(dp[child] - edges[eIndex][2] * 2, 0);\n            }\n        }\n\n        public static void dfs2(int i, int parE) {\n            if (i == 0) {\n                dpPathToRootWithDetours[i] = dp[i];\n            } else {\n                int par = i ^ edges[parE][0] ^ edges[parE][1];\n                depth[i] = depth[par] + 1;\n                dpPathToRootWithDetours[i] = dpPathToRootWithDetours[par] - Math.max(0, dp[i] - edges[parE][2] * 2);\n                dpPathToRootWithDetours[i] -= edges[parE][2];\n                dpPathToRootWithDetours[i] += dp[i];\n\n                long myPathWeight = Math.max(dp[i] - edges[parE][2] * 2, 0);\n                long change = dp[par] - myPathWeight - edges[parE][2] * 2;\n                change = Math.max(change, 0);\n                dp[i] += change;\n            }\n            for (int eIndex : g[i]) {\n                if (eIndex == parE) continue;\n                dfs2(i ^ edges[eIndex][0] ^ edges[eIndex][1], eIndex);\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.NextInt();\n            int q = in.NextInt();\n            a = in.NextIntArray(n);\n            edges = new int[n - 1][3];\n            {\n                long[] count = new long[n];\n                for (int i = 0; i < n - 1; i++) {\n                    int u = in.NextInt() - 1;\n                    int v = in.NextInt() - 1;\n                    int w = in.NextInt();\n                    edges[i][0] = u;\n                    edges[i][1] = v;\n                    edges[i][2] = w;\n                    count[u]++;\n                    count[v]++;\n                }\n\n                g = new int[n][];\n                for (int i = 0; i < n; i++) {\n                    g[i] = new int[(int) count[i]];\n                }\n                for (int i = 0; i < n - 1; i++) {\n                    for (int j = 0; j < 2; j++) {\n                        g[edges[i][j]][(int) --count[edges[i][j]]] = i;\n                    }\n                }\n            }\n            dp = new long[n];\n            dpPathToRootWithDetours = new long[n];\n            depth = new int[n];\n            firstAppearance = new int[n];\n            appearance = new int[(n - 1) * 2 + 1];\n            dfs(0, -1);\n            dfs2(0, -1);\n            GraphLowestCommonAncestor.LCA lca = GraphLowestCommonAncestor.createLCA(appearance, firstAppearance, depth);\n            firstAppearance = null;\n            depth = null;\n            appearance = null;\n            edges = null;\n            g = null;\n            for (int i = 0; i < q; i++) {\n                int u = in.NextInt() - 1;\n                int v = in.NextInt() - 1;\n                int lcaI = lca.getLCA(u, v);\n                long res = dpPathToRootWithDetours[u] + dpPathToRootWithDetours[v] - 2 * dpPathToRootWithDetours[lcaI] + dp[lcaI];\n                out.println(res);\n            }\n        }\n\n    }\n\n    static class MinRangeSparseTable implements ISearchInRange {\n        private final int[][] sparseTables;\n        private final long[] array;\n        private final boolean reverseOrdered;\n\n        public MinRangeSparseTable(long[] array, boolean reverseOrdered) {\n            this.reverseOrdered = reverseOrdered;\n            this.array = array;\n            int LCALength = IntegerExtension.getNumberOfBits(array.length);\n            sparseTables = new int[LCALength][];\n            sparseTables[0] = new int[array.length];\n            for (int i = 0; i < array.length; i++) {\n                sparseTables[0][i] = i;\n            }\n            for (int i = 1; i < LCALength; i++) {\n                int size = 1 << i;\n                int jumpSize = 1 << (i - 1);\n                sparseTables[i] = new int[sparseTables[0].length - size + 1];\n                for (int j = 0; j < sparseTables[i].length; j++) {\n                    sparseTables[i][j] = min(sparseTables[i - 1][j], sparseTables[i - 1][j + jumpSize]);\n                }\n            }\n        }\n\n        private int min(int a, int b) {\n            return ((array[a] < array[b]) ^ reverseOrdered) ? a : b;\n        }\n\n\n        public Pair<Long, Long> queryIndexValueInRange(long l, long r) {\n            int size = (int) (r - l + 1);\n            int LCAIndex = IntegerExtension.getNumberOfBits(size) - 1;\n            int sizeNeeded = 1 << LCAIndex;\n            int res = min(sparseTables[LCAIndex][(int) l], sparseTables[LCAIndex][(int) (r - sizeNeeded + 1)]);\n            return new Pair<>((long) res, array[res]);\n        }\n\n        public MinRangeSparseTable(long[] array) {\n            this(array, false);\n        }\n\n    }\n\n    static class GraphLowestCommonAncestor {\n        public static GraphLowestCommonAncestor.LCA createLCA(int[] appearances, final int[] firstAppearance, final int[] depth) {\n            return new GraphLowestCommonAncestor.LCA_MinRangeSparseTable(appearances, firstAppearance, depth);\n        }\n\n        public interface LCA {\n            int getLCA(int a, int b);\n\n        }\n\n        private static class LCA_MinRangeSparseTable implements GraphLowestCommonAncestor.LCA {\n            private final MinRangeSparseTable minRangeSparseTable;\n            private final int[] firstAppearance;\n            private final int[] indexToNode;\n\n            public LCA_MinRangeSparseTable(int[] appearances, final int[] firstAppearance, final int[] depth) {\n                this.firstAppearance = firstAppearance;\n                this.indexToNode = appearances;\n                long[] depthOrder = new long[appearances.length];\n                for (int i = 0; i < depthOrder.length; i++) {\n                    depthOrder[i] = depth[appearances[i]];\n                }\n                minRangeSparseTable = new MinRangeSparseTable(depthOrder);\n            }\n\n\n            public int getLCA(int a, int b) {\n                a = firstAppearance[a];\n                b = firstAppearance[b];\n                int l = Math.min(a, b), r = Math.max(a, b);\n                return indexToNode[(int) (long) minRangeSparseTable.queryIndexValueInRange(l, r).first];\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] NextIntArray(int n) {\n            return NextIntArray(n, 0);\n        }\n\n        public int[] NextIntArray(int n, int offset) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = NextInt() + offset;\n            }\n            return a;\n        }\n\n    }\n\n    static interface ISearchInRange {\n    }\n\n    static class Pair<T1, T2> {\n        public T1 first;\n        public T2 second;\n\n        public Pair(T1 f, T2 s) {\n            first = f;\n            second = s;\n        }\n\n    }\n\n    static class IntegerExtension {\n        public static int getNumberOfBits(long i) {\n            return 64 - Long.numberOfLeadingZeros(i);\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "from": "CorCod", "problem": 641, "index": 641}
{"src": "//package fourninetysixDiv3;\nimport java.util.HashMap;\nimport java.util.Scanner;\npublic class Median_Segments_general {\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tSystem.out.println(func(n, m, arr)-func(n, m+1, arr));\n\t}\n\tpublic static long func(int n,int m,int[] arr) {\n\t\tHashMap<Long, Integer> map = new HashMap<>();\n\t\tmap.put((long) 0, 1);\n\t\tlong sum = 0;\n\t\tlong res = 0;\n\t\tlong add=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(arr[i]<m) {\n\t\t\t\tsum--;\n\t\t\t\tif(map.containsKey(sum)) {\n\t\t\t\t\tadd-=map.get(sum);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(map.containsKey(sum)) {\n\t\t\t\t\tadd+=map.get(sum);\n\t\t\t\t}\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tres+=add;\n\t\t\tif(map.containsKey(sum)) {\n\t\t\t\tmap.put(sum, map.get(sum)+1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(sum,1);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 642, "index": 642}
{"src": "\n//Java program to generate binary numbers from 1 to n \n\nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \n\npublic\nclass\nGenerateBNo \n{ \n\n// This function uses queue data structure to print binary numbers \n\nstatic\nvoid\ngeneratePrintBinary(\nint\nn) \n\n{ \n\n// Create an empty queue of strings \n\nQueue<String> q = \nnew\nLinkedList<String>(); \n\n\n// Enqueue the first binary number \n\nq.add(\n\"1\"\n); \n\n\n// This loops is like BFS of a tree with 1 as root \n\n// 0 as left child and 1 as right child and so on \n\nwhile\n(n-- > \n0\n) \n\n{ \n\n// print the front of queue \n\nString s1 = q.peek(); \n\nq.remove(); \n\nSystem.out.println(s1); \n\n\n// Store s1 before changing it \n\nString s2 = s1; \n\n\n// Append \"0\" to s1 and enqueue it \n\nq.add(s1 + \n\"0\"\n); \n\n\n// Append \"1\" to s2 and enqueue it. Note that s2 contains \n\n// the previous front \n\nq.add(s2 + \n\"1\"\n); \n\n} \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn=\n10\n; \n\ngeneratePrintBinary(n); \n\n} \n} \n//This code is contributed by Sumit Ghosh ", "complexity": "nlogn", "from": "CorCod", "problem": 643, "index": 643}
{"src": "\n// Java program to find maximum pair sum whose \n// difference is less than K \n\nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// method to return maximum sum we can get by \n\n// finding less than K difference pair \n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nK) \n\n{ \n\n\n// Sort input array in ascending order. \n\nArrays.sort(arr); \n\n\n// dp[i] denotes the maximum disjoint pair sum \n\n// we can achieve using first i elements \n\nint\ndp[] = \nnew\nint\n[N]; \n\n\n// if no element then dp value will be 0 \n\ndp[\n0\n] = \n0\n; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\n// first give previous value to dp[i] i.e. \n\n// no pairing with (i-1)th element \n\ndp[i] = dp[i-\n1\n]; \n\n\n// if current and previous element can form a pair \n\nif\n(arr[i] - arr[i-\n1\n] < K) \n\n{ \n\n\n// update dp[i] by choosing maximum between \n\n// pairing and not pairing \n\nif\n(i >= \n2\n) \n\ndp[i] = Math.max(dp[i], dp[i-\n2\n] + arr[i] + \n\narr[i-\n1\n]); \n\nelse\n\ndp[i] = Math.max(dp[i], arr[i] + arr[i-\n1\n]); \n\n} \n\n} \n\n\n// last index will have the result \n\nreturn\ndp[N - \n1\n]; \n\n} \n\n\n// Driver code to test above methods \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n\n} \n} \n\n//This code is contributed by vt_m. ", "complexity": "nlogn", "from": "CorCod", "problem": 644, "index": 644}
{"src": "import java.io.*; \nimport java.util.*; \n\n\npublic class p7{\n\t\n\tstatic class FastReader{ \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n\n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n\n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n\n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n\n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n\n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n\n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\t}\n\n\tpublic static void main(String[] args) \n\t{ \n        FastReader sc = new FastReader(); \n        //PrintWriter out = new PrintWriter(System.out); \n        int n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tlong one = (long)Math.pow(2, k) - 1;\n\t\t\n\t\tlong[] arr = new long[n+1];\n\t\t\n\t\tarr[0] = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tarr[i] = sc.nextLong();\n\t\t\tarr[i] ^= arr[i-1];\n\t\t}\n\n\t\tMap<Long, Long> count = new HashMap<>();\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tLong key = Math.min(arr[i], (arr[i]^one));\n\t\t\tLong val = count.get(key);\n\t\t\tif(val==null) val = 0L;\n\t\t\tcount.put(key, val+1);\n\t\t}\n\n\t\tlong num = n;\n\t\tlong ans = num*(num+1)/2;\n\t\t\n\t\tfor(Map.Entry<Long, Long> ent: count.entrySet()){\n\t\t\t\n\t\t\tLong cnt = ent.getValue();\n\t\t\t\n\t\t\tlong num1 = cnt/2;\n\t\t\tlong num2 = (cnt+1)/2;\n\t\t\t\n\t\t\tans -= ( (num1*(num1-1))/2 );\n\t\t\tans -= ( (num2*(num2-1))/2 );\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 645, "index": 645}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\npublic class Main {\n    \n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int N = sc.nextInt();\n        long dest = sc.nextLong();\n        long max = (long)N * ((long)N + 1L) / 2L;\n        if (dest < 2 * N - 1 || dest > max) {\n            out.println(\"No\");\n            out.close();\n            return;\n        }\n        int[] d = new int[N + 1];\n        int[] f = new int[N + 1];\n        int K = 1;\n        for (; K <= N; K++) {\n            long dep = 1L, cnt = 1L, c = 1L;\n            long t = 1L;\n            while (cnt < N) {\n                c = c * K;\n                dep++;\n                t += (dep * Math.min(c, N - cnt));\n                cnt += c;\n            }\n            if (t <= dest) break;\n        }\n        out.println(\"Yes\");\n        int dep = 1; long cnt = 1L, c = 1L;\n        long t = 1L;\n        d[1] = 1;\n        while (cnt < N) {\n            dep++; c = c * K; \n            long x = (long)N - cnt;\n            int min;\n            if (c >= x) min = (int)x;\n            else min = (int)c;\n            d[dep] = min;\n            t += (dep * Math.min(c, (long)N - cnt)); cnt += c;\n        }\n        dest -= t;\n        int curDep = dep; int nextDep = dep + 1;\n        while (dest > 0) {\n            if (d[curDep] <= 1) curDep--;\n            d[curDep]--;\n            long next = Math.min(nextDep++, dest + curDep);\n            dest -= ((int)next - curDep);\n            d[(int)next]++;\n        }\n        int first = 1;\n        for (int i = 2; i < nextDep; i++) {\n            int p = 0, fn = first - d[i - 1] + 1;\n            for (int j = first + 1; j <= first + d[i]; j++) {\n                if (p == K) {\n                    fn++; p = 0;\n                }\n                p++; f[j] = fn;\n            }\n            first += d[i];\n        }\n        for (int i = 2; i <= N; i++)\n            out.format(\"%d \", f[i]);\n        out.close();\n    }\n            \n        \n    static class FastScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n        \n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n        \n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n       /* public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        \n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }*/\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 646, "index": 646}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ReaderFastIO in = new ReaderFastIO(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DConcatenatedMultiples solver = new DConcatenatedMultiples();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DConcatenatedMultiples {\n        public void solve(int testNumber, ReaderFastIO in, PrintWriter out) {\n\n            Map<Integer, Integer>[] mapMods = new HashMap[11];\n\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int[] a = in.readArrayInt(n);\n\n            for (int i = 0; i < 11; i++) {\n                mapMods[i] = new HashMap<>();\n            }\n\n            for (int i = 0; i < n; i++) {\n                int pot = getPot(a[i]);\n                mapMods[pot].put(a[i] % k, mapMods[pot].getOrDefault(a[i] % k, 0) + 1);\n            }\n\n            long ct = 0;\n\n            for (int i = 0; i < n; i++) {\n\n                int ownPot = getPot(a[i]);\n                long suffix = a[i] * 10L;\n                for (int j = 1; j <= 10; j++) {\n\n                    int mod = (int) (suffix % k);\n                    int comMod = (k - mod) % k;\n                    int qt = mapMods[j].getOrDefault(comMod, 0);\n\n                    if (j == ownPot && (a[i] % k) == comMod) {\n                        qt--;\n                    }\n\n                    ct += qt;\n\n                    suffix = (suffix * 10L) % k;\n                }\n\n            }\n\n            out.println(ct);\n        }\n\n        public int getPot(int x) {\n\n            int ct = 0;\n\n            while (x != 0) {\n                x /= 10;\n                ct++;\n            }\n\n            return ct;\n        }\n\n    }\n\n    static class ReaderFastIO {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public ReaderFastIO() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public ReaderFastIO(InputStream input) {\n            br = new BufferedReader(new InputStreamReader(input));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readArrayInt(int n) {\n\n            int[] array = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                array[i] = nextInt();\n            }\n\n            return array;\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "from": "CorCod", "problem": 647, "index": 647}
{"src": "import org.omg.PortableServer.AdapterActivator;\n\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.net.CookieHandler;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport static java.lang.Math.*;\n\npublic class TaskA implements Runnable {\n    long m = (int)1e9+7;\n    PrintWriter w;\n    InputReader c;\n    public void run() {\n        c = new InputReader(System.in);\n        w = new PrintWriter(System.out);\n        int n = c.nextInt();\n        int a[] = scanArrayI(n);\n        int maxtime = Integer.MAX_VALUE,ind = -1;\n        for(int i=0;i<n;i++){\n            int time = Integer.MAX_VALUE;\n            if(a[i]<i+1)\n                time = i;\n            else{\n                time = (int)ceil((a[i] - i)/(double)n) * n + i;\n            }\n            if(time<maxtime){\n                maxtime = time;\n                ind = i;\n            }\n        }\n        w.println(ind+1);\n        w.close();\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static void sortbyColumn(int arr[][], int col){\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f)    {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    public void printArray(int[] a){\n        for(int i=0;i<a.length;i++)\n            w.print(a[i]+\" \");\n        w.println();\n    }\n    public int[] scanArrayI(int n){\n        int a[] = new int[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextInt();\n        return a;\n    }\n    public long[] scanArrayL(int n){\n        long a[] = new long[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextLong();\n        return a;\n    }\n    public void printArray(long[] a){\n        for(int i=0;i<a.length;i++)\n            w.print(a[i]+\" \");\n        w.println();\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new TaskA(),\"TaskA\",1<<26).start();\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 648, "index": 648}
{"src": "import java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class BigInteger7 {\n    public static void main(String[] args) {\n        //https://codeforces.com/contest/1011/problem/A\n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 649, "index": 649}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            TaskD.Pair[] p = new TaskD.Pair[n];\n            for (int i = 0; i < n; ++i) {\n                p[i] = new TaskD.Pair(in.nextLong(), in.nextLong());\n            }\n            Arrays.sort(p);\n            int last = 0;\n            int ans = 1;\n            for (int i = 1; i < n; ++i) {\n                if (p[i].x - p[i].w >= p[last].x + p[last].w) {\n                    last = i;\n                    ++ans;\n                }\n            }\n            out.println(ans);\n        }\n\n        static class Pair implements Comparable<TaskD.Pair> {\n            long x;\n            long w;\n\n            public Pair(long x, long w) {\n                this.x = x;\n                this.w = w;\n            }\n\n            public int compareTo(TaskD.Pair o) {\n                return Long.compare(x + w, o.x + o.w);\n            }\n\n            public String toString() {\n                return x + \" \" + w;\n            }\n\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "from": "CorCod", "problem": 650, "index": 650}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic StreamTokenizer st=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\tpublic static void main(String[] args) {\n\t\tint n=nextInt();\n\t\tint m=nextInt();\n\t\tlong b[]=new long[n];\n\t\tlong g[]=new long[m];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tb[i]=nextInt();\n\t\tfor(int i=0;i<m;i++)\n\t\t\tg[i]=nextInt();\n\t\tArrays.sort(b);\n\t\tArrays.sort(g);\n\t\tif(b[n-1]>g[0])\n\t\t\tSystem.out.println(\"-1\");\n\t\telse if(b[n-1]==g[0]){\n\t\t\tlong sum=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\tsum+=g[i];\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tsum+=(m*b[i]);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}else{\n\t\t\tlong sum=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\tsum+=g[i];\n\t\t\tsum+=b[n-1];\n\t\t\tsum+=(b[n-2]*(m-1));\n\t\t\tfor(int i=0;i<n-2;i++){\n\t\t\t\tsum+=(m*b[i]);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\tstatic int nextInt(){\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (int)st.nval;\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 651, "index": 651}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class MicroWorld {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\t\n\t\tint[] temp = new int[1000001];\n\t\t\n\t\tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t\n\t\t\ttemp[Integer.parseInt(st1.nextToken())]++;\n\t\t}\n\t\t\n\t\tint b = k + 1;\n\t\t\n\t\tfor (int i = 1000000; i > 0; i--){\n\t\t\t\n\t\t\tif (temp[i] > 0){\n\t\t\t\tif (b <= k){\n\t\t\t\t\tn -= temp[i];\n\t\t\t\t}\n\t\t\t\tb = 1;\n\t\t\t}else{\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(n);\n\t\t\n\t}\n\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 652, "index": 652}
{"src": "\n// Java code to find largest \n// three elements in an array \n\n\nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\nvoid\nfind3largest(\nint\n[] arr) \n\n{ \n\nArrays.sort(arr); \n//It uses Tuned Quicksort with \n\n//avg. case Time complexity = O(nLogn) \n\nint\nn = arr.length; \n\nint\ncheck = \n0\n, count = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++){ \n\n\nif\n(count<\n4\n){ \n\nif\n(check!=arr[n-i]) \n\n{ \n\n// to handle duplicate values \n\nSystem.out.print(arr[n-i]+\n\" \"\n); \n\ncheck = arr[n-i]; \n\ncount++; \n\n} \n\n} \n\nelse\n\nbreak\n; \n\n} \n\n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nGFG obj = \nnew\nGFG(); \n\nint\n[] arr={\n12\n,\n45\n,\n1\n,-\n1\n,\n45\n,\n54\n,\n23\n,\n5\n,\n0\n,-\n10\n}; \n\nobj.find3largest(arr); \n\n} \n\n} \n//This code is contibuted by Prashant Malik ", "complexity": "nlogn", "from": "CorCod", "problem": 653, "index": 653}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author aryssoncf\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            try {\n                int n = in.readInt();\n                int[] x = new int[n], w = new int[n];\n                in.readIntArrays(x, w);\n                int[] begin = new int[n], end = new int[n];\n                Arrays.setAll(begin, i -> x[i] - w[i]);\n                Arrays.setAll(end, i -> x[i] + w[i]);\n                int m = ArrayUtils.compress(begin, end).length;\n                int[] dp = new int[m + 1], order = ArrayUtils.order(end);\n                int idx = 0;\n                for (int i = 0; i < m; i++) {\n                    if (i > 0) {\n                        dp[i] = dp[i - 1];\n                    }\n                    while (idx < n && end[order[idx]] == i) {\n                        dp[i] = Math.max(dp[i], dp[begin[order[idx]]] + 1);\n                        idx++;\n                    }\n                }\n                int res = dp[m - 1];\n                out.printLine(res);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    static class Sorter {\n        private static final int INSERTION_THRESHOLD = 16;\n\n        private Sorter() {\n        }\n\n        public static void sort(IntList list, IntComparator comparator) {\n            quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,\n                    comparator);\n        }\n\n        private static void quickSort(IntList list, int from, int to, int remaining, IntComparator comparator) {\n            if (to - from < INSERTION_THRESHOLD) {\n                insertionSort(list, from, to, comparator);\n                return;\n            }\n            if (remaining == 0) {\n                heapSort(list, from, to, comparator);\n                return;\n            }\n            remaining--;\n            int pivotIndex = (from + to) >> 1;\n            int pivot = list.get(pivotIndex);\n            list.swap(pivotIndex, to);\n            int storeIndex = from;\n            int equalIndex = to;\n            for (int i = from; i < equalIndex; i++) {\n                int value = comparator.compare(list.get(i), pivot);\n                if (value < 0) {\n                    list.swap(storeIndex++, i);\n                } else if (value == 0) {\n                    list.swap(--equalIndex, i--);\n                }\n            }\n            quickSort(list, from, storeIndex - 1, remaining, comparator);\n            for (int i = equalIndex; i <= to; i++) {\n                list.swap(storeIndex++, i);\n            }\n            quickSort(list, storeIndex, to, remaining, comparator);\n        }\n\n        private static void heapSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = (to + from - 1) >> 1; i >= from; i--) {\n                siftDown(list, i, to, comparator, from);\n            }\n            for (int i = to; i > from; i--) {\n                list.swap(from, i);\n                siftDown(list, from, i - 1, comparator, from);\n            }\n        }\n\n        private static void siftDown(IntList list, int start, int end, IntComparator comparator, int delta) {\n            int value = list.get(start);\n            while (true) {\n                int child = ((start - delta) << 1) + 1 + delta;\n                if (child > end) {\n                    return;\n                }\n                int childValue = list.get(child);\n                if (child + 1 <= end) {\n                    int otherValue = list.get(child + 1);\n                    if (comparator.compare(otherValue, childValue) > 0) {\n                        child++;\n                        childValue = otherValue;\n                    }\n                }\n                if (comparator.compare(value, childValue) >= 0) {\n                    return;\n                }\n                list.swap(start, child);\n                start = child;\n            }\n        }\n\n        private static void insertionSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = from + 1; i <= to; i++) {\n                int value = list.get(i);\n                for (int j = i - 1; j >= from; j--) {\n                    if (comparator.compare(list.get(j), value) <= 0) {\n                        break;\n                    }\n                    list.swap(j, j + 1);\n                }\n            }\n        }\n\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void set(int index, int value);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public void swap(int first, int second) {\n            if (first == second) {\n                return;\n            }\n            int temp = get(first);\n            set(first, get(second));\n            set(second, temp);\n        }\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n        default public IntList sort(IntComparator comparator) {\n            Sorter.sort(this, comparator);\n            return this;\n        }\n\n        default IntList unique() {\n            int last = Integer.MIN_VALUE;\n            IntList result = new IntArrayList();\n            int size = size();\n            for (int i = 0; i < size; i++) {\n                int current = get(i);\n                if (current != last) {\n                    result.add(current);\n                    last = current;\n                }\n            }\n            return result;\n        }\n\n        default public IntList subList(final int from, final int to) {\n            return new IntList() {\n                private final int shift;\n                private final int size;\n\n                {\n                    if (from < 0 || from > to || to > IntList.this.size()) {\n                        throw new IndexOutOfBoundsException(\"from = \" + from + \", to = \" + to + \", size = \" + size());\n                    }\n                    shift = from;\n                    size = to - from;\n                }\n\n                public int size() {\n                    return size;\n                }\n\n                public int get(int at) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    return IntList.this.get(at + shift);\n                }\n\n                public void addAt(int index, int value) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void removeAt(int index) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void set(int at, int value) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    IntList.this.set(at + shift, value);\n                }\n\n                public IntList compute() {\n                    return new IntArrayList(this);\n                }\n            };\n        }\n\n    }\n\n    static interface IntComparator {\n        IntComparator DEFAULT = Integer::compare;\n\n        int compare(int first, int second);\n\n    }\n\n    static class Range {\n        public static IntList range(int from, int to) {\n            int[] result = new int[Math.abs(from - to)];\n            int current = from;\n            if (from <= to) {\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = current++;\n                }\n            } else {\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = current--;\n                }\n            }\n            return new IntArray(result);\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        IntIterator intIterator();\n\n        default Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public void readIntArrays(int[]... arrays) {\n            for (int i = 0; i < arrays[0].length; i++) {\n                for (int j = 0; j < arrays.length; j++) {\n                    arrays[j][i] = readInt();\n                }\n            }\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public int[] toArray() {\n            int size = size();\n            int[] array = new int[size];\n            int i = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                array[i++] = it.value();\n            }\n            return array;\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void addAt(int index, int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void set(int index, int value) {\n            data[index] = value;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static int[] range(int from, int to) {\n            return Range.range(from, to).toArray();\n        }\n\n        public static int[] createOrder(int size) {\n            return range(0, size);\n        }\n\n        public static int[] sort(int[] array, IntComparator comparator) {\n            return sort(array, 0, array.length, comparator);\n        }\n\n        public static int[] sort(int[] array, int from, int to, IntComparator comparator) {\n            if (from == 0 && to == array.length) {\n                new IntArray(array).sort(comparator);\n            } else {\n                new IntArray(array).subList(from, to).sort(comparator);\n            }\n            return array;\n        }\n\n        public static int[] order(final int[] array) {\n            return sort(createOrder(array.length), (first, second) -> Integer.compare(array[first], array[second]));\n        }\n\n        public static int[] unique(int[] array) {\n            return new IntArray(array).unique().toArray();\n        }\n\n        public static int[] compress(int[]... arrays) {\n            int totalLength = 0;\n            for (int[] array : arrays) {\n                totalLength += array.length;\n            }\n            int[] all = new int[totalLength];\n            int delta = 0;\n            for (int[] array : arrays) {\n                System.arraycopy(array, 0, all, delta, array.length);\n                delta += array.length;\n            }\n            sort(all, IntComparator.DEFAULT);\n            all = unique(all);\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i] = Arrays.binarySearch(all, array[i]);\n                }\n            }\n            return all;\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n        public void set(int index, int value) {\n            if (index >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            data[index] = value;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "from": "CorCod", "problem": 654, "index": 654}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class MicroWorld {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        Integer[] a = new Integer[n];\n\n        st = new StringTokenizer(br.readLine());\n        for(int i=0; i<n; i++){\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n\n        Arrays.sort(a);\n\n        int count = 1;\n        int remaining = n;\n        for(int i=0; i<n-1; i++){\n            if((int)a[i] == (int)a[i+1]){\n                count++;\n                continue;\n            }\n            if((a[i] + k) >= a[i+1]){\n                remaining -= count;\n            }\n            count = 1;\n        }\n        System.out.println(remaining);\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 655, "index": 655}
{"src": "import java.awt.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(), m = scanner.nextInt();\n        int[] vertical = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            vertical[i] = scanner.nextInt();\n        }\n\n        Arrays.sort(vertical);\n\n\n        ArrayList<Integer> horisontal = new ArrayList<>();\n        int amount = 0;\n        for (int i = 0; i < m; i++) {\n            int x1 = scanner.nextInt(), x2 = scanner.nextInt(), y = scanner.nextInt();\n            if (x1 == 1) {\n                amount++;\n                horisontal.add(x2);\n            }\n        }\n\n        Collections.sort(horisontal);\n\n\n        if (amount == 0) {\n            System.out.println(0);\n            return;\n        }\n\n\n        int minVal = amount, horSize = horisontal.size(), verLen = vertical.length;\n        int h = 0, v = 0;\n\n        for (; v < verLen && h < horSize; ) {\n\n           while (h < horSize && horisontal.get(h) < vertical[v]){\n               h++;\n               amount--;\n           }\n           minVal = Math.min(minVal, amount + v);\n\n            while (h < horSize && v < verLen && horisontal.get(h) >= vertical[v]){\n                minVal = Math.min(minVal, amount + v);\n                v++;\n            }\n\n        }\n\n        if(horisontal.get(horSize - 1) < 1E9){\n            minVal = Math.min(minVal, v);\n        }\n\n\n\n        System.out.println(minVal);\n\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 656, "index": 656}
{"src": "\n// Java program to find the \n// to calculate the product \n// of max element of first \n// array and min element of \n// second array \nimport\njava.util.*; \nimport\njava.lang.*; \n\nclass\nGfG \n{ \n\n\n// Function to calculate \n\n// the product \n\npublic\nstatic\nint\nminMaxProduct(\nint\narr1[], \n\nint\narr2[], \n\nint\nn1, \n\nint\nn2) \n\n{ \n\n\n// Sort the arrays to find the \n\n// maximum and minimum elements \n\n// in given arrays \n\nArrays.sort(arr1); \n\nArrays.sort(arr2); \n\n\n// Return product of maximum \n\n// and minimum. \n\nreturn\narr1[n1 - \n1\n] * arr2[\n0\n]; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String argc[]) \n\n{ \n\nint\n[] arr1= \nnew\nint\n[]{ \n10\n, \n2\n, \n3\n, \n\n6\n, \n4\n, \n1\n}; \n\nint\n[] arr2 = \nnew\nint\n[]{ \n5\n, \n1\n, \n4\n, \n\n2\n, \n6\n, \n9\n}; \n\nint\nn1 = \n6\n; \n\nint\nn2 = \n6\n; \n\nSystem.out.println(minMaxProduct(arr1, \n\narr2, \n\nn1, n2)); \n\n} \n} \n\n/*This code is contributed by Sagar Shukla.*/", "complexity": "nlogn", "from": "CorCod", "problem": 657, "index": 657}
{"src": "\n// Java program for Prim's MST for \n// adjacency list representation of graph \nimport\njava.util.LinkedList; \nimport\njava.util.TreeSet; \nimport\njava.util.Comparator; \n\npublic\nclass\nprims { \n\nclass\nnode1 { \n\n\n// Stores destination vertex in adjacency list \n\nint\ndest; \n\n\n// Stores weight of a vertex in the adjacency list \n\nint\nweight; \n\n\n// Constructor \n\nnode1(\nint\na, \nint\nb) \n\n{ \n\ndest = a; \n\nweight = b; \n\n} \n\n} \n\nstatic\nclass\nGraph { \n\n\n// Number of vertices in the graph \n\nint\nV; \n\n\n// List of adjacent nodes of a given vertex \n\nLinkedList<node1>[] adj; \n\n\n// Constructor \n\nGraph(\nint\ne) \n\n{ \n\nV = e; \n\nadj = \nnew\nLinkedList[V]; \n\nfor\n(\nint\no = \n0\n; o < V; o++) \n\nadj[o] = \nnew\nLinkedList<>(); \n\n} \n\n} \n\n\n// class to represent a node in PriorityQueue \n\n// Stores a vertex and its corresponding \n\n// key value \n\nclass\nnode { \n\nint\nvertex; \n\nint\nkey; \n\n} \n\n\n// Comparator class created for PriorityQueue \n\n// returns 1 if node0.key > node1.key \n\n// returns 0 if node0.key < node1.key and \n\n// returns -1 otherwise \n\nclass\ncomparator \nimplements\nComparator<node> { \n\n\n@Override\n\npublic\nint\ncompare(node node0, node node1) \n\n{ \n\nreturn\nnode0.key - node1.key; \n\n} \n\n} \n\n\n// method to add an edge \n\n// between two vertices \n\nvoid\naddEdge(Graph graph, \nint\nsrc, \nint\ndest, \nint\nweight) \n\n{ \n\n\nnode1 node0 = \nnew\nnode1(dest, weight); \n\nnode1 node = \nnew\nnode1(src, weight); \n\ngraph.adj[src].addLast(node0); \n\ngraph.adj[dest].addLast(node); \n\n} \n\n\n// method used to find the mst \n\nvoid\nprims_mst(Graph graph) \n\n{ \n\n\n// Whether a vertex is in PriorityQueue or not \n\nBoolean[] mstset = \nnew\nBoolean[graph.V]; \n\nnode[] e = \nnew\nnode[graph.V]; \n\n\n// Stores the parents of a vertex \n\nint\n[] parent = \nnew\nint\n[graph.V]; \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) \n\ne[o] = \nnew\nnode(); \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) { \n\n\n// Initialize to false \n\nmstset[o] = \nfalse\n; \n\n\n// Initialize key values to infinity \n\ne[o].key = Integer.MAX_VALUE; \n\ne[o].vertex = o; \n\nparent[o] = -\n1\n; \n\n} \n\n\n// Include the source vertex in mstset \n\nmstset[\n0\n] = \ntrue\n; \n\n\n// Set key value to 0 \n\n// so that it is extracted first \n\n// out of PriorityQueue \n\ne[\n0\n].key = \n0\n; \n\n\n// Use TreeSet instead of PriorityQueue as the remove function of the PQ is O(n) in java. \n\nTreeSet<node> queue = \nnew\nTreeSet<node>(\nnew\ncomparator()); \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) \n\nqueue.add(e[o]); \n\n\n// Loops until the queue is not empty \n\nwhile\n(!queue.isEmpty()) { \n\n\n// Extracts a node with min key value \n\nnode node0 = queue.pollFirst(); \n\n\n// Include that node into mstset \n\nmstset[node0.vertex] = \ntrue\n; \n\n\n// For all adjacent vertex of the extracted vertex V \n\nfor\n(node1 iterator : graph.adj[node0.vertex]) { \n\n\n// If V is in queue \n\nif\n(mstset[iterator.dest] == \nfalse\n) { \n\n// If the key value of the adjacent vertex is \n\n// more than the extracted key \n\n// update the key value of adjacent vertex \n\n// to update first remove and add the updated vertex \n\nif\n(e[iterator.dest].key > iterator.weight) { \n\nqueue.remove(e[iterator.dest]); \n\ne[iterator.dest].key = iterator.weight; \n\nqueue.add(e[iterator.dest]); \n\nparent[iterator.dest] = node0.vertex; \n\n} \n\n} \n\n} \n\n} \n\n\n// Prints the vertex pair of mst \n\nfor\n(\nint\no = \n1\n; o < graph.V; o++) \n\nSystem.out.println(parent[o] + \n\" \"\n\n+ \n\"-\"\n\n+ \n\" \"\n+ o); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nV = \n9\n; \n\n\nGraph graph = \nnew\nGraph(V); \n\n\nprims e = \nnew\nprims(); \n\n\ne.addEdge(graph, \n0\n, \n1\n, \n4\n); \n\ne.addEdge(graph, \n0\n, \n7\n, \n8\n); \n\ne.addEdge(graph, \n1\n, \n2\n, \n8\n); \n\ne.addEdge(graph, \n1\n, \n7\n, \n11\n); \n\ne.addEdge(graph, \n2\n, \n3\n, \n7\n); \n\ne.addEdge(graph, \n2\n, \n8\n, \n2\n); \n\ne.addEdge(graph, \n2\n, \n5\n, \n4\n); \n\ne.addEdge(graph, \n3\n, \n4\n, \n9\n); \n\ne.addEdge(graph, \n3\n, \n5\n, \n14\n); \n\ne.addEdge(graph, \n4\n, \n5\n, \n10\n); \n\ne.addEdge(graph, \n5\n, \n6\n, \n2\n); \n\ne.addEdge(graph, \n6\n, \n7\n, \n1\n); \n\ne.addEdge(graph, \n6\n, \n8\n, \n6\n); \n\ne.addEdge(graph, \n7\n, \n8\n, \n7\n); \n\n\n// Method invoked \n\ne.prims_mst(graph); \n\n} \n} \n// This code is contributed by Vikash Kumar Dubey ", "complexity": "nlogn", "from": "CorCod", "problem": 658, "index": 658}
{"src": "\nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n// Variables to keep track of current sum and minimum sum \n\nint\nsum, min_sum = \n999999\n; \n\n\n// left and right index variables \n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n// variable to keep track of the left and right pair for min_sum \n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n/* Array should have at least two elements*/\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n/* Sort the elements */\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n/*If abs(sum) is less then update the result items*/\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n/* Functions for QuickSort */\n\n\n/* This function takes last element as pivot, \n\nplaces the pivot element at its correct \n\nposition in sorted array, and places all \n\nsmaller (smaller than pivot) to left of \n\npivot and all greater elements to right \n\nof pivot */\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n// index of smaller element \n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n// If current element is smaller than or \n\n// equal to pivot \n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n// swap arr[i] and arr[j] \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n// swap arr[i+1] and arr[high] (or pivot) \n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n/* The main function that implements QuickSort() \n\narr[] --> Array to be sorted, \n\nlow --> Starting index, \n\nhigh --> Ending index */\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n/* pi is partitioning index, arr[pi] is \n\nnow at right place */\n\nint\npi = partition(arr, low, high); \n\n\n// Recursively sort elements before \n\n// partition and after partition \n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n} ", "complexity": "nlogn", "from": "CorCod", "problem": 659, "index": 659}
{"src": "\n// Java implementation of counting the \n// inversion using merge sort \n\nclass\nTest { \n\n\n/* This method sorts the input array and returns the \n\nnumber of inversions in the array */\n\nstatic\nint\nmergeSort(\nint\narr[], \nint\narray_size) \n\n{ \n\nint\ntemp[] = \nnew\nint\n[array_size]; \n\nreturn\n_mergeSort(arr, temp, \n0\n, array_size - \n1\n); \n\n} \n\n\n/* An auxiliary recursive method that sorts the input array and \n\nreturns the number of inversions in the array. */\n\nstatic\nint\n_mergeSort(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nright) \n\n{ \n\nint\nmid, inv_count = \n0\n; \n\nif\n(right > left) { \n\n/* Divide the array into two parts and call _mergeSortAndCountInv() \n\nfor each of the parts */\n\nmid = (right + left) / \n2\n; \n\n\n/* Inversion count will be the sum of inversions in left-part, right-part \n\nand number of inversions in merging */\n\ninv_count = _mergeSort(arr, temp, left, mid); \n\ninv_count += _mergeSort(arr, temp, mid + \n1\n, right); \n\n\n/*Merge the two parts*/\n\ninv_count += merge(arr, temp, left, mid + \n1\n, right); \n\n} \n\nreturn\ninv_count; \n\n} \n\n\n/* This method merges two sorted arrays and returns inversion count in \n\nthe arrays.*/\n\nstatic\nint\nmerge(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nmid, \nint\nright) \n\n{ \n\nint\ni, j, k; \n\nint\ninv_count = \n0\n; \n\n\ni = left; \n/* i is index for left subarray*/\n\nj = mid; \n/* j is index for right subarray*/\n\nk = left; \n/* k is index for resultant merged subarray*/\n\nwhile\n((i <= mid - \n1\n) && (j <= right)) { \n\nif\n(arr[i] <= arr[j]) { \n\ntemp[k++] = arr[i++]; \n\n} \n\nelse\n{ \n\ntemp[k++] = arr[j++]; \n\n\n/*this is tricky -- see above explanation/diagram for merge()*/\n\ninv_count = inv_count + (mid - i); \n\n} \n\n} \n\n\n/* Copy the remaining elements of left subarray \n\n(if there are any) to temp*/\n\nwhile\n(i <= mid - \n1\n) \n\ntemp[k++] = arr[i++]; \n\n\n/* Copy the remaining elements of right subarray \n\n(if there are any) to temp*/\n\nwhile\n(j <= right) \n\ntemp[k++] = arr[j++]; \n\n\n/*Copy back the merged elements to original array*/\n\nfor\n(i = left; i <= right; i++) \n\narr[i] = temp[i]; \n\n\nreturn\ninv_count; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\nSystem.out.println(\n\"Number of inversions are \"\n+ mergeSort(arr, \n5\n)); \n\n} \n} ", "complexity": "nlogn", "from": "CorCod", "problem": 660, "index": 660}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new PrintStream(System.out));\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        long[] arrB = new long[n];\n        long[] arrG = new long[m];\n        st=new StringTokenizer(f.readLine());\n        for(int i=0;i<n;i++){\n            arrB[i]=Long.parseLong(st.nextToken());\n        }\n        st=new StringTokenizer(f.readLine());\n        for(int j=0;j<m;j++){\n            arrG[j]=Long.parseLong(st.nextToken());\n        }\n        Arrays.sort(arrB);\n        Arrays.sort(arrG);\n        long ans = 0;\n//        for (int i = 0; i < n; i++) ans += arrB[i] * m;\n//        for (int i = 0; i < m - 1; i++) ans += arrG[i] - arrB[0];\n//        if (arrB[m - 1] != arrB[0]) {\n//            if (arrB.length == 1) {\n//                ans=-1;\n//            }\n//            else ans += arrG[m - 1] - arrB[1];\n//        }\n//        if (arrG[m-1] < arrB[0]) {\n//            ans=-1;\n//        }\n        for(int i=0;i<n;i++){\n            ans+=arrB[i]*(long)m;\n        }\n        for(int i=1;i<m;i++){\n            ans+=arrG[i]-arrB[n-1];\n        }\n        if(arrB[n-1]!=arrG[0]){\n            if(n==1){\n                ans=-1;\n            }\n            else{\n                //smallest g goes to second to last\n                ans+=arrG[0]-arrB[n-2];\n            }\n        }\n        if(arrB[n-1]>arrG[0]){\n            ans=-1;\n        }\n        System.out.println(ans);\n        f.close();\n        out.close();\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 661, "index": 661}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.Collection;\nimport java.util.AbstractList;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\nimport java.util.NoSuchElementException;\nimport java.util.ConcurrentModificationException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author cunbidun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DPairOfLines solver = new DPairOfLines();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DPairOfLines {\n        private static final int INF = (int) 2e9 + 7;\n        private InputReader in;\n        private PrintWriter out;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            int n = in.nextInt();\n            if (n <= 4) {\n                out.println(\"YES\");\n                return;\n            }\n            TreeList<PairII> list = new TreeList<>();\n            PairII[] a = new PairII[n + 1];\n            for (int i = 1; i <= n; i++) {\n                a[i] = (new PairII(in.nextInt(), in.nextInt()));\n                list.add(a[i]);\n            }\n            PairII pos1 = new PairII(INF, INF);\n            PairII pos2 = new PairII(INF, INF);\n            for (int i = 1; i <= 5; i++) {\n                for (int j = i + 1; j <= 5; j++) {\n                    for (int k = j + 1; k <= 5; k++) {\n                        int x1 = a[i].first;\n                        int y1 = a[i].second;\n                        int x2 = a[j].first;\n                        int y2 = a[j].second;\n                        int x = a[k].first;\n                        int y = a[k].second;\n                        long s = (long) (y2 - y1) * x + (long) (x1 - x2) * y + ((long) x2 * y1 - (long) x1 * y2);\n                        if (s == 0) {\n                            pos1 = a[i];\n                            pos2 = a[j];\n                        }\n                    }\n                }\n            }\n\n            if (pos1.equals(new PairII(INF, INF))) {\n                out.println(\"NO\");\n                return;\n            }\n            int x1 = pos1.first;\n            int y1 = pos1.second;\n            int x2 = pos2.first;\n            int y2 = pos2.second;\n            for (int i = 0; i < list.size(); i++) {\n                int x = list.get(i).first;\n                int y = list.get(i).second;\n                long s = (long) (y2 - y1) * x + (long) (x1 - x2) * y + ((long) x2 * y1 - (long) x1 * y2);\n                if (s == 0) {\n                    list.remove(i);\n                    i--;\n                }\n            }\n            if (list.size() <= 2) {\n                out.println(\"YES\");\n                return;\n            }\n            x1 = list.get(0).first;\n            y1 = list.get(0).second;\n            x2 = list.get(1).first;\n            y2 = list.get(1).second;\n            for (int i = 0; i < list.size(); i++) {\n                int x = list.get(i).first;\n                int y = list.get(i).second;\n                long s = (long) (y2 - y1) * x + (long) (x1 - x2) * y + ((long) x2 * y1 - (long) x1 * y2);\n                if (s == 0) {\n                    list.remove(i);\n                    i--;\n                }\n            }\n            if (list.size() == 0) {\n                out.println(\"YES\");\n            } else out.println(\"NO\");\n        }\n\n    }\n\n    static interface OrderedIterator<E> extends Iterator<E> {\n    }\n\n    static class PairII implements Comparable<PairII> {\n        public int first;\n        public int second;\n\n        public PairII(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            PairII pair = (PairII) o;\n\n            return first == pair.first && second == pair.second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(PairII o) {\n            int value = Integer.compare(first, o.first);\n            if (value != 0) {\n                return value;\n            }\n            return Integer.compare(second, o.second);\n        }\n\n    }\n\n    static class TreeList<E> extends AbstractList<E> {\n        private TreeList.AVLNode<E> root;\n        private int size;\n\n        public TreeList() {\n            super();\n        }\n\n        public TreeList(final Collection<? extends E> coll) {\n            super();\n            if (!coll.isEmpty()) {\n                root = new TreeList.AVLNode<>(coll);\n                size = coll.size();\n            }\n        }\n\n        public E get(final int index) {\n            return root.get(index).getValue();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public Iterator<E> iterator() {\n            // override to go 75% faster\n            return listIterator(0);\n        }\n\n        public ListIterator<E> listIterator() {\n            // override to go 75% faster\n            return listIterator(0);\n        }\n\n        public ListIterator<E> listIterator(final int fromIndex) {\n            return new TreeList.TreeListIterator<>(this, fromIndex);\n        }\n\n        public int indexOf(final Object object) {\n            // override to go 75% faster\n            if (root == null) {\n                return -1;\n            }\n            return root.indexOf(object, root.relativePosition);\n        }\n\n        public boolean contains(final Object object) {\n            return indexOf(object) >= 0;\n        }\n\n        public Object[] toArray() {\n            final Object[] array = new Object[size()];\n            if (root != null) {\n                root.toArray(array, root.relativePosition);\n            }\n            return array;\n        }\n\n        public void add(final int index, final E obj) {\n            modCount++;\n            if (root == null) {\n                root = new TreeList.AVLNode<>(index, obj, null, null);\n            } else {\n                root = root.insert(index, obj);\n            }\n            size++;\n        }\n\n        public boolean addAll(final Collection<? extends E> c) {\n            if (c.isEmpty()) {\n                return false;\n            }\n            modCount += c.size();\n            final TreeList.AVLNode<E> cTree = new TreeList.AVLNode<>(c);\n            root = root == null ? cTree : root.addAll(cTree, size);\n            size += c.size();\n            return true;\n        }\n\n        public E set(final int index, final E obj) {\n            final TreeList.AVLNode<E> node = root.get(index);\n            final E result = node.value;\n            node.setValue(obj);\n            return result;\n        }\n\n        public E remove(final int index) {\n            modCount++;\n            final E result = get(index);\n            root = root.remove(index);\n            size--;\n            return result;\n        }\n\n        public void clear() {\n            modCount++;\n            root = null;\n            size = 0;\n        }\n\n        static class AVLNode<E> {\n            private TreeList.AVLNode<E> left;\n            private boolean leftIsPrevious;\n            private TreeList.AVLNode<E> right;\n            private boolean rightIsNext;\n            private int height;\n            private int relativePosition;\n            private E value;\n\n            private AVLNode(final int relativePosition, final E obj,\n                            final TreeList.AVLNode<E> rightFollower, final TreeList.AVLNode<E> leftFollower) {\n                this.relativePosition = relativePosition;\n                value = obj;\n                rightIsNext = true;\n                leftIsPrevious = true;\n                right = rightFollower;\n                left = leftFollower;\n            }\n\n            private AVLNode(final Collection<? extends E> coll) {\n                this(coll.iterator(), 0, coll.size() - 1, 0, null, null);\n            }\n\n            private AVLNode(final Iterator<? extends E> iterator, final int start, final int end,\n                            final int absolutePositionOfParent, final TreeList.AVLNode<E> prev, final TreeList.AVLNode<E> next) {\n                final int mid = start + (end - start) / 2;\n                if (start < mid) {\n                    left = new TreeList.AVLNode<>(iterator, start, mid - 1, mid, prev, this);\n                } else {\n                    leftIsPrevious = true;\n                    left = prev;\n                }\n                value = iterator.next();\n                relativePosition = mid - absolutePositionOfParent;\n                if (mid < end) {\n                    right = new TreeList.AVLNode<>(iterator, mid + 1, end, mid, this, next);\n                } else {\n                    rightIsNext = true;\n                    right = next;\n                }\n                recalcHeight();\n            }\n\n            E getValue() {\n                return value;\n            }\n\n            void setValue(final E obj) {\n                this.value = obj;\n            }\n\n            TreeList.AVLNode<E> get(final int index) {\n                final int indexRelativeToMe = index - relativePosition;\n\n                if (indexRelativeToMe == 0) {\n                    return this;\n                }\n\n                final TreeList.AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n                if (nextNode == null) {\n                    return null;\n                }\n                return nextNode.get(indexRelativeToMe);\n            }\n\n            int indexOf(final Object object, final int index) {\n                if (getLeftSubTree() != null) {\n                    final int result = left.indexOf(object, index + left.relativePosition);\n                    if (result != -1) {\n                        return result;\n                    }\n                }\n                if (value == null ? value == object : value.equals(object)) {\n                    return index;\n                }\n                if (getRightSubTree() != null) {\n                    return right.indexOf(object, index + right.relativePosition);\n                }\n                return -1;\n            }\n\n            void toArray(final Object[] array, final int index) {\n                array[index] = value;\n                if (getLeftSubTree() != null) {\n                    left.toArray(array, index + left.relativePosition);\n                }\n                if (getRightSubTree() != null) {\n                    right.toArray(array, index + right.relativePosition);\n                }\n            }\n\n            TreeList.AVLNode<E> next() {\n                if (rightIsNext || right == null) {\n                    return right;\n                }\n                return right.min();\n            }\n\n            TreeList.AVLNode<E> previous() {\n                if (leftIsPrevious || left == null) {\n                    return left;\n                }\n                return left.max();\n            }\n\n            TreeList.AVLNode<E> insert(final int index, final E obj) {\n                final int indexRelativeToMe = index - relativePosition;\n\n                if (indexRelativeToMe <= 0) {\n                    return insertOnLeft(indexRelativeToMe, obj);\n                }\n                return insertOnRight(indexRelativeToMe, obj);\n            }\n\n            private TreeList.AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n                if (getLeftSubTree() == null) {\n                    setLeft(new TreeList.AVLNode<>(-1, obj, this, left), null);\n                } else {\n                    setLeft(left.insert(indexRelativeToMe, obj), null);\n                }\n\n                if (relativePosition >= 0) {\n                    relativePosition++;\n                }\n                final TreeList.AVLNode<E> ret = balance();\n                recalcHeight();\n                return ret;\n            }\n\n            private TreeList.AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n                if (getRightSubTree() == null) {\n                    setRight(new TreeList.AVLNode<>(+1, obj, right, this), null);\n                } else {\n                    setRight(right.insert(indexRelativeToMe, obj), null);\n                }\n                if (relativePosition < 0) {\n                    relativePosition--;\n                }\n                final TreeList.AVLNode<E> ret = balance();\n                recalcHeight();\n                return ret;\n            }\n\n            private TreeList.AVLNode<E> getLeftSubTree() {\n                return leftIsPrevious ? null : left;\n            }\n\n            private TreeList.AVLNode<E> getRightSubTree() {\n                return rightIsNext ? null : right;\n            }\n\n            private TreeList.AVLNode<E> max() {\n                return getRightSubTree() == null ? this : right.max();\n            }\n\n            private TreeList.AVLNode<E> min() {\n                return getLeftSubTree() == null ? this : left.min();\n            }\n\n            TreeList.AVLNode<E> remove(final int index) {\n                final int indexRelativeToMe = index - relativePosition;\n\n                if (indexRelativeToMe == 0) {\n                    return removeSelf();\n                }\n                if (indexRelativeToMe > 0) {\n                    setRight(right.remove(indexRelativeToMe), right.right);\n                    if (relativePosition < 0) {\n                        relativePosition++;\n                    }\n                } else {\n                    setLeft(left.remove(indexRelativeToMe), left.left);\n                    if (relativePosition > 0) {\n                        relativePosition--;\n                    }\n                }\n                recalcHeight();\n                return balance();\n            }\n\n            private TreeList.AVLNode<E> removeMax() {\n                if (getRightSubTree() == null) {\n                    return removeSelf();\n                }\n                setRight(right.removeMax(), right.right);\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n                recalcHeight();\n                return balance();\n            }\n\n            private TreeList.AVLNode<E> removeMin() {\n                if (getLeftSubTree() == null) {\n                    return removeSelf();\n                }\n                setLeft(left.removeMin(), left.left);\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n                recalcHeight();\n                return balance();\n            }\n\n            private TreeList.AVLNode<E> removeSelf() {\n                if (getRightSubTree() == null && getLeftSubTree() == null) {\n                    return null;\n                }\n                if (getRightSubTree() == null) {\n                    if (relativePosition > 0) {\n                        left.relativePosition += relativePosition;\n                    }\n                    left.max().setRight(null, right);\n                    return left;\n                }\n                if (getLeftSubTree() == null) {\n                    right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n                    right.min().setLeft(null, left);\n                    return right;\n                }\n\n                if (heightRightMinusLeft() > 0) {\n                    // more on the right, so delete from the right\n                    final TreeList.AVLNode<E> rightMin = right.min();\n                    value = rightMin.value;\n                    if (leftIsPrevious) {\n                        left = rightMin.left;\n                    }\n                    right = right.removeMin();\n                    if (relativePosition < 0) {\n                        relativePosition++;\n                    }\n                } else {\n                    // more on the left or equal, so delete from the left\n                    final TreeList.AVLNode<E> leftMax = left.max();\n                    value = leftMax.value;\n                    if (rightIsNext) {\n                        right = leftMax.right;\n                    }\n                    final TreeList.AVLNode<E> leftPrevious = left.left;\n                    left = left.removeMax();\n                    if (left == null) {\n                        // special case where left that was deleted was a double link\n                        // only occurs when height difference is equal\n                        left = leftPrevious;\n                        leftIsPrevious = true;\n                    }\n                    if (relativePosition > 0) {\n                        relativePosition--;\n                    }\n                }\n                recalcHeight();\n                return this;\n            }\n\n            private TreeList.AVLNode<E> balance() {\n                switch (heightRightMinusLeft()) {\n                    case 1:\n                    case 0:\n                    case -1:\n                        return this;\n                    case -2:\n                        if (left.heightRightMinusLeft() > 0) {\n                            setLeft(left.rotateLeft(), null);\n                        }\n                        return rotateRight();\n                    case 2:\n                        if (right.heightRightMinusLeft() < 0) {\n                            setRight(right.rotateRight(), null);\n                        }\n                        return rotateLeft();\n                    default:\n                        throw new RuntimeException(\"tree inconsistent!\");\n                }\n            }\n\n            private int getOffset(final TreeList.AVLNode<E> node) {\n                if (node == null) {\n                    return 0;\n                }\n                return node.relativePosition;\n            }\n\n            private int setOffset(final TreeList.AVLNode<E> node, final int newOffest) {\n                if (node == null) {\n                    return 0;\n                }\n                final int oldOffset = getOffset(node);\n                node.relativePosition = newOffest;\n                return oldOffset;\n            }\n\n            private void recalcHeight() {\n                height = Math.max(\n                        getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n                        getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n            }\n\n            private int getHeight(final TreeList.AVLNode<E> node) {\n                return node == null ? -1 : node.height;\n            }\n\n            private int heightRightMinusLeft() {\n                return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n            }\n\n            private TreeList.AVLNode<E> rotateLeft() {\n                final TreeList.AVLNode<E> newTop = right; // can't be faedelung!\n                final TreeList.AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n\n                final int newTopPosition = relativePosition + getOffset(newTop);\n                final int myNewPosition = -newTop.relativePosition;\n                final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n                setRight(movedNode, newTop);\n                newTop.setLeft(this, null);\n\n                setOffset(newTop, newTopPosition);\n                setOffset(this, myNewPosition);\n                setOffset(movedNode, movedPosition);\n                return newTop;\n            }\n\n            private TreeList.AVLNode<E> rotateRight() {\n                final TreeList.AVLNode<E> newTop = left;\n                final TreeList.AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n\n                final int newTopPosition = relativePosition + getOffset(newTop);\n                final int myNewPosition = -newTop.relativePosition;\n                final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n                setLeft(movedNode, newTop);\n                newTop.setRight(this, null);\n\n                setOffset(newTop, newTopPosition);\n                setOffset(this, myNewPosition);\n                setOffset(movedNode, movedPosition);\n                return newTop;\n            }\n\n            private void setLeft(final TreeList.AVLNode<E> node, final TreeList.AVLNode<E> previous) {\n                leftIsPrevious = node == null;\n                left = leftIsPrevious ? previous : node;\n                recalcHeight();\n            }\n\n            private void setRight(final TreeList.AVLNode<E> node, final TreeList.AVLNode<E> next) {\n                rightIsNext = node == null;\n                right = rightIsNext ? next : node;\n                recalcHeight();\n            }\n\n            private TreeList.AVLNode<E> addAll(TreeList.AVLNode<E> otherTree, final int currentSize) {\n                final TreeList.AVLNode<E> maxNode = max();\n                final TreeList.AVLNode<E> otherTreeMin = otherTree.min();\n\n                // We need to efficiently merge the two AVL trees while keeping them\n                // balanced (or nearly balanced). To do this, we take the shorter\n                // tree and combine it with a similar-height subtree of the taller\n                // tree. There are two symmetric cases:\n                //   * this tree is taller, or\n                //   * otherTree is taller.\n                if (otherTree.height > height) {\n                    // CASE 1: The other tree is taller than this one. We will thus\n                    // merge this tree into otherTree.\n\n                    // STEP 1: Remove the maximum element from this tree.\n                    final TreeList.AVLNode<E> leftSubTree = removeMax();\n\n                    // STEP 2: Navigate left from the root of otherTree until we\n                    // contains a subtree, s, that is no taller than me. (While we are\n                    // navigating left, we store the nodes we encounter in a stack\n                    // so that we can re-balance them in step 4.)\n                    final Deque<TreeList.AVLNode<E>> sAncestors = new ArrayDeque<>();\n                    TreeList.AVLNode<E> s = otherTree;\n                    int sAbsolutePosition = s.relativePosition + currentSize;\n                    int sParentAbsolutePosition = 0;\n                    while (s != null && s.height > getHeight(leftSubTree)) {\n                        sParentAbsolutePosition = sAbsolutePosition;\n                        sAncestors.push(s);\n                        s = s.left;\n                        if (s != null) {\n                            sAbsolutePosition += s.relativePosition;\n                        }\n                    }\n\n                    // STEP 3: Replace s with a newly constructed subtree whose root\n                    // is maxNode, whose left subtree is leftSubTree, and whose right\n                    // subtree is s.\n                    maxNode.setLeft(leftSubTree, null);\n                    maxNode.setRight(s, otherTreeMin);\n                    if (leftSubTree != null) {\n                        leftSubTree.max().setRight(null, maxNode);\n                        leftSubTree.relativePosition -= currentSize - 1;\n                    }\n                    if (s != null) {\n                        s.min().setLeft(null, maxNode);\n                        s.relativePosition = sAbsolutePosition - currentSize + 1;\n                    }\n                    maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                    otherTree.relativePosition += currentSize;\n\n                    // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                    s = maxNode;\n                    while (!sAncestors.isEmpty()) {\n                        final TreeList.AVLNode<E> sAncestor = sAncestors.pop();\n                        sAncestor.setLeft(s, null);\n                        s = sAncestor.balance();\n                    }\n                    return s;\n                }\n                otherTree = otherTree.removeMin();\n\n                final Deque<TreeList.AVLNode<E>> sAncestors = new ArrayDeque<>();\n                TreeList.AVLNode<E> s = this;\n                int sAbsolutePosition = s.relativePosition;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(otherTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.right;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                otherTreeMin.setRight(otherTree, null);\n                otherTreeMin.setLeft(s, maxNode);\n                if (otherTree != null) {\n                    otherTree.min().setLeft(null, otherTreeMin);\n                    otherTree.relativePosition++;\n                }\n                if (s != null) {\n                    s.max().setRight(null, otherTreeMin);\n                    s.relativePosition = sAbsolutePosition - currentSize;\n                }\n                otherTreeMin.relativePosition = currentSize - sParentAbsolutePosition;\n\n                s = otherTreeMin;\n                while (!sAncestors.isEmpty()) {\n                    final TreeList.AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setRight(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n\n        }\n\n        static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n            private final TreeList<E> parent;\n            private TreeList.AVLNode<E> next;\n            private int nextIndex;\n            private TreeList.AVLNode<E> current;\n            private int currentIndex;\n            private int expectedModCount;\n\n            private TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException {\n                super();\n                this.parent = parent;\n                this.expectedModCount = parent.modCount;\n                this.next = parent.root == null ? null : parent.root.get(fromIndex);\n                this.nextIndex = fromIndex;\n                this.currentIndex = -1;\n            }\n\n            private void checkModCount() {\n                if (parent.modCount != expectedModCount) {\n                    throw new ConcurrentModificationException();\n                }\n            }\n\n            public boolean hasNext() {\n                return nextIndex < parent.size();\n            }\n\n            public E next() {\n                checkModCount();\n                if (!hasNext()) {\n                    throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n                }\n                if (next == null) {\n                    next = parent.root.get(nextIndex);\n                }\n                final E value = next.getValue();\n                current = next;\n                currentIndex = nextIndex++;\n                next = next.next();\n                return value;\n            }\n\n            public boolean hasPrevious() {\n                return nextIndex > 0;\n            }\n\n            public E previous() {\n                checkModCount();\n                if (!hasPrevious()) {\n                    throw new NoSuchElementException(\"Already at start of list.\");\n                }\n                if (next == null) {\n                    next = parent.root.get(nextIndex - 1);\n                } else {\n                    next = next.previous();\n                }\n                final E value = next.getValue();\n                current = next;\n                currentIndex = --nextIndex;\n                return value;\n            }\n\n            public int nextIndex() {\n                return nextIndex;\n            }\n\n            public int previousIndex() {\n                return nextIndex() - 1;\n            }\n\n            public void remove() {\n                checkModCount();\n                if (currentIndex == -1) {\n                    throw new IllegalStateException();\n                }\n                parent.remove(currentIndex);\n                if (nextIndex != currentIndex) {\n                    // remove() following next()\n                    nextIndex--;\n                }\n                // the AVL node referenced by next may have become stale after a remove\n                // reset it now: will be retrieved by next call to next()/previous() via nextIndex\n                next = null;\n                current = null;\n                currentIndex = -1;\n                expectedModCount++;\n            }\n\n            public void set(final E obj) {\n                checkModCount();\n                if (current == null) {\n                    throw new IllegalStateException();\n                }\n                current.setValue(obj);\n            }\n\n            public void add(final E obj) {\n                checkModCount();\n                parent.add(nextIndex, obj);\n                current = null;\n                currentIndex = -1;\n                nextIndex++;\n                expectedModCount++;\n            }\n\n        }\n\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "nlogn", "from": "CorCod", "problem": 662, "index": 662}
{"src": "\nimport java.util.*;\n\n\npublic class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 663, "index": 663}
{"src": "\n// Java program to find the row \n// with maximum number of 1s \nimport\njava.io.*; \n\nclass\nGFG { \n\nstatic\nint\nR = \n4\n, C = \n4\n; \n\n// Function to find the index of first index \n\n// of 1 in a boolean array arr[] \n\nstatic\nint\nfirst(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) { \n\n// Get the middle index \n\nint\nmid = low + (high - low) / \n2\n; \n\n\n// Check if the element at middle index is first 1 \n\nif\n((mid == \n0\n|| (arr[mid - \n1\n] == \n0\n)) && arr[mid] == \n1\n) \n\nreturn\nmid; \n\n\n// If the element is 0, recur for right side \n\nelse\nif\n(arr[mid] == \n0\n) \n\nreturn\nfirst(arr, (mid + \n1\n), high); \n\n\n// If element is not first 1, recur for left side \n\nelse\n\nreturn\nfirst(arr, low, (mid - \n1\n)); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n// Function that returns index of row \n\n// with maximum number of 1s. \n\nstatic\nint\nrowWithMax1s(\nint\nmat[][]) \n\n{ \n\n// Initialize max values \n\nint\nmax_row_index = \n0\n, max = -\n1\n; \n\n\n// Traverse for each row and count number of \n\n// 1s by finding the index of first 1 \n\nint\ni, index; \n\nfor\n(i = \n0\n; i < R; i++) { \n\nindex = first(mat[i], \n0\n, C - \n1\n); \n\nif\n(index != -\n1\n&& C - index > max) { \n\nmax = C - index; \n\nmax_row_index = i; \n\n} \n\n} \n\n\nreturn\nmax_row_index; \n\n} \n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n0\n, \n0\n, \n0\n, \n1\n}, \n\n{ \n0\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n0\n, \n0\n, \n0\n, \n0\n} }; \n\nSystem.out.println(\n\"Index of row with maximum 1s is \"\n\n+ rowWithMax1s(mat)); \n\n} \n} \n\n// This code is contributed by 'Gitanjali'. ", "complexity": "nlogn", "from": "CorCod", "problem": 664, "index": 664}
{"src": "\n// Java code to calculate maximum unique \n// element of every segment of array \nimport\njava.io.*; \nimport\njava.util.*; \nclass\nGFG { \n\n\nstatic\nvoid\nfind_max(\nint\n[] A, \nint\nN, \nint\nK) \n\n{ \n\n// Storing counts of first K-1 elements \n\n// Also storing distinct elements. \n\nHashMap<Integer, Integer> Count = \nnew\nHashMap<>(); \n\nfor\n(\nint\ni = \n0\n; i < K - \n1\n; i++) \n\nif\n(Count.containsKey(A[i])) \n\nCount.put(A[i], \n1\n+ Count.get(A[i])); \n\nelse\n\nCount.put(A[i], \n1\n); \n\n\nTreeSet<Integer> Myset = \nnew\nTreeSet<Integer>(); \n\nfor\n(Map.Entry x : Count.entrySet()) { \n\nif\n(Integer.parseInt(String.valueOf(x.getValue())) == \n1\n) \n\nMyset.add(Integer.parseInt(String.valueOf(x.getKey()))); \n\n} \n\n\n// Before every iteration of this loop, \n\n// we maintain that K-1 elements of current \n\n// window are processed. \n\nfor\n(\nint\ni = K - \n1\n; i < N; i++) { \n\n\n// Process K-th element of current window \n\nif\n(Count.containsKey(A[i])) \n\nCount.put(A[i], \n1\n+ Count.get(A[i])); \n\nelse\n\nCount.put(A[i], \n1\n); \n\n\nif\n(Integer.parseInt(String.valueOf(Count.get(A[i]))) == \n1\n) \n\nMyset.add(A[i]); \n\nelse\n\nMyset.remove(A[i]); \n\n\n// If there are no distinct \n\n// elements in current window \n\nif\n(Myset.size() == \n0\n) \n\nSystem.out.println(\n\"Nothing\"\n); \n\n\n// Set is ordered and last element \n\n// of set gives us maximum element. \n\nelse\n\nSystem.out.println(Myset.last()); \n\n\n// Remove first element of current \n\n// window before next iteration. \n\nint\nx = A[i - K + \n1\n]; \n\nCount.put(x, Count.get(x) - \n1\n); \n\n\nif\n(Integer.parseInt(String.valueOf(Count.get(x))) == \n1\n) \n\nMyset.add(x); \n\nif\n(Integer.parseInt(String.valueOf(Count.get(x))) == \n0\n) \n\nMyset.remove(x); \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] a = { \n1\n, \n2\n, \n2\n, \n3\n, \n3\n}; \n\nint\nn = a.length; \n\nint\nk = \n3\n; \n\nfind_max(a, n, k); \n\n} \n} \n\n// This code is contributed by rachana soma ", "complexity": "nlogn", "from": "CorCod", "problem": 665, "index": 665}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\n\n\t\tpublic class codeforces\n\t\t{\t\n\t\t\tpublic static void main(String[] args)\n\t\t\t{\n\t\t\t\tInputReader in = new InputReader(System.in);\n\t\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tlong U = in.nextLong();\n\t\t\t\tlong[] E = new long[n];\n\t\t\t\tdouble max = -1;\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\tE[i] = in.nextLong();\n\t\t\t\t\n\t\t\t\tfor(int k=1;k<n-1;k++)\n\t\t\t\t{\n\t\t\t\t\tint i = k + 1, j = n - 1, mid = 0;\n\t\t\t\t\tdouble T = 0;\n\t\t\t\t\t\n\t\t\t\t\twhile(i < j)\n\t\t\t\t\t{\n\t\t\t\t\t\tmid = (int)Math.ceil((double)(i+j)/2);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(E[mid] - E[k-1] <= U)\n\t\t\t\t\t\t\ti = mid;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tj = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tj = k;\n\t\t\t\t\tk = i;\n\t\t\t\t\ti = j - 1;\n\t\t\t\t\t\n\t\t\t\t\tT = E[k] - E[j];\n\t\t\t\t\tT /= E[k] - E[i];\n\t\t\t\t\t\n\t\t\t\t\tif(E[k] - E[i] <= U)\n\t\t\t\t\t\tmax = Math.max(max, T);\n\t\t\t\t\t\n\t\t\t\t\tk = j;\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\tpw.println(max);\n\t\t\t\t\n\t\t\t\tpw.flush();\n\t\t\t\tpw.close();\n\t\t\t}\n\t\t\t\n\t\t/*\tpublic static void DFS(int sourse)\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tvisited[sourse] = true;\n\t\t\t\t\n\t\t\t\tfor(int u : adj[sourse])\n\t\t\t\t{\n\t\t\t\t\tif(!visited[u])\n\t\t\t\t\t{\n\t\t\t\t\t\tDFS(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}*/\n\t\t\t\n\t\t\tpublic static ArrayList Divisors(long n)\n\t\t\t{\n\t\t\t    ArrayList<Long> div = new ArrayList<>();\n\t\t\t    \n\t\t\t    for (long i=1; i<=Math.sqrt(n); i++)\n\t\t\t    {\n\t\t\t        if (n%i == 0)\n\t\t\t        {\n\t\t\t        \tdiv.add(i);\n\t\t\t                \n\t\t\t            if(n/i != i)\n\t\t\t            \tdiv.add(n/i);\n\t\t\t        }\n\t\t\t    }\n\t\t\t    return div;\n\t\t\t}\n\t\t\n\t\t\tpublic static int BinarySearch(long[] a, long k)\n\t\t\t{\n\t\t\t\tint n = a.length;\n\t\t\t\tint i = 0, j = n-1;\n\t\t\t\tint mid = 0;\n\t\t\t\t\n\t\t\t\tif(k < a[0])\n\t\t\t\t\treturn 0;\n\t\t\t\telse if(k >= a[n-1])\n\t\t\t\t\treturn n;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile(j - i > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmid = (i+j)/2;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(k >= a[mid])\n\t\t\t\t\t\t\ti = mid;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tj = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn i+1;\n\t\t\t}\n\t\t\tpublic static long GCD(long a,long b)\n\t\t\t{\n\t\t\t\tif(b==0)\n\t\t\t\t\treturn a;\n\t\t\t\telse\n\t\t\t\t\treturn GCD(b,a%b);\n\t\t\t}\n\t\t\t\n\t\t\tstatic class pair implements Comparable<pair>\n\t\t\t{\n\t\t\t\tInteger x, y;\n\t\t\t\tpair(int x,int y)\n\t\t\t\t{\n\t\t\t\t\tthis.x=x;\n\t\t\t\t\tthis.y=y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic int compareTo(pair o) {\n\t\t\t\t\tint result = x.compareTo(o.x);\n\t\t\t\t\tif(result==0)\n\t\t\t\t\t\tresult = y.compareTo(o.y);\n\t\t\t\t\t\n\t\t\t\t\treturn result;\n\t\t\t\t}  \n\t\t\t\t\n\t\t\t\tpublic String toString()\n\t\t\t\t{\n\t\t\t\t\treturn x+\" \"+y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic boolean equals(Object o)\n\t\t\t\t{\n\t\t\t\t\tif (o instanceof pair)\n\t\t\t\t    {\n\t\t\t\t\t\tpair p = (pair)o;\n\t\t\t\t\t\treturn p.x - x == 0 && p.y - y == 0 ;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic int hashCode()\n\t\t\t\t{\n\t\t\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstatic class InputReader \n\t\t\t{\n\t\t\t\t \n\t\t\t\tprivate final InputStream stream;\n\t\t\t\tprivate final byte[] buf = new byte[8192];\n\t\t\t\tprivate int curChar, snumChars;\n\t\t\t\tprivate SpaceCharFilter filter;\n\t\t \n\t\t\t\tpublic InputReader(InputStream stream) \n\t\t\t\t{\n\t\t\t\t\tthis.stream = stream;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int snext() \n\t\t\t\t{\n\t\t\t\t\tif (snumChars == -1)\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tif (curChar >= snumChars) \n\t\t\t\t\t{\n\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\ttry \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t\t\t} \n\t\t\t\t\t\tcatch (IOException e) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int nextInt() \n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-')\n\t\t\t\t    {\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint res = 0;\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic long nextLong()\n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-') \n\t\t\t\t\t{\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tlong res = 0;\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int[] nextIntArray(int n) \n\t\t\t\t{\n\t\t\t\t\tint a[] = new int[n];\n\t\t\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t\t\t{\n\t\t\t\t\t\ta[i] = nextInt();\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic String readString()\n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic String nextLine() \n\t\t\t\t{\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isEndOfLine(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t\t{\n\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t}\n\t\t \n\t\t\t\tprivate boolean isEndOfLine(int c) \n\t\t\t\t{\n\t\t\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic interface SpaceCharFilter\n\t\t\t    {\n\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstatic class CodeX {\n\t        public static void sort(long arr[]) {\n\t            merge_sort(arr, 0, arr.length - 1);\n\t        }\n\t\n\t        private static void merge_sort(long A[], long start, long end) {\n\t            if (start < end) {\n\t                long mid = (start + end) / 2;\n\t                merge_sort(A, start, mid);\n\t                merge_sort(A, mid + 1, end);\n\t                merge(A, start, mid, end);\n\t            }\n\t\n\t        }\n\t\n\t        private static void merge(long A[], long start,long mid, long end) {\n\t            long p = start, q = mid + 1;\n\t            long Arr[] = new long[(int)(end - start + 1)];\n\t            long k = 0;\n\t\n\t            for (int i = (int)start; i <= end; i++) {\n\t                if (p > mid)\n\t                    Arr[(int)k++] = A[(int)q++];\n\t\n\t                else if (q > end)\n\t                    Arr[(int)k++] = A[(int)p++];\n\t\n\t                else if (A[(int)p] < A[(int)q])\n\t                    Arr[(int)k++] = A[(int)p++];\n\t\n\t                else\n\t                    Arr[(int)k++] = A[(int)q++];\n\t            }\n\t            for (int i = 0; i < k; i++) {\n\t                A[(int)start++] = Arr[i];\n\t            }\n\t\n\t        }\n\t\n\t    }\n\t\t}\t\n\t\t\n\n\t\t\t", "complexity": "nlogn", "from": "CorCod", "problem": 666, "index": 666}
{"src": "\n// Program to find minimum number of platforms \n\nimport\njava.util.*; \n\nclass\nGFG { \n\n// Returns minimum number of platforms reqquired \nstatic\nint\nfindPlatform(\nint\narr[], \nint\ndep[], \nint\nn) \n{ \n\n// Sort arrival and departure arrays \n\nArrays.sort(arr); \n\nArrays.sort(dep); \n\n\n// plat_needed indicates number of platforms \n\n// needed at a time \n\nint\nplat_needed = \n1\n, result = \n1\n; \n\nint\ni = \n1\n, j = \n0\n; \n\n\n// Similar to merge in merge sort to process \n\n// all events in sorted order \n\nwhile\n(i < n && j < n) \n\n{ \n\n// If next event in sorted order is arrival, \n\n// increment count of platforms needed \n\nif\n(arr[i] <= dep[j]) \n\n{ \n\nplat_needed++; \n\ni++; \n\n\n// Update result if needed \n\nif\n(plat_needed > result) \n\nresult = plat_needed; \n\n} \n\n\n// Else decrement count of platforms needed \n\nelse\n\n{ \n\nplat_needed--; \n\nj++; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n// Driver program to test methods of graph class \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n900\n, \n940\n, \n950\n, \n1100\n, \n1500\n, \n1800\n}; \n\nint\ndep[] = {\n910\n, \n1200\n, \n1120\n, \n1130\n, \n1900\n, \n2000\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Minimum Number of Platforms Required = \"\n\n+ findPlatform(arr, dep, n)); \n} \n} ", "complexity": "nlogn", "from": "CorCod", "problem": 667, "index": 667}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class D {\n\n\tstatic final boolean stdin = true;\n\tstatic final String filename = \"\";\n\tstatic FastScanner br;\n\tstatic PrintWriter pw;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (stdin) {\n\t\t\tbr = new FastScanner();\n\t\t\tpw = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t} else {\n\t\t\tbr = new FastScanner(filename + \".in\");\n\t\t\tpw = new PrintWriter(new FileWriter(filename + \".out\"));\n\t\t}\n\n\t\tSolver solver = new Solver();\n\t\tsolver.solve(br, pw);\n\t}\n\n\tstatic class Solver {\n\t\tstatic long mod = (long) (1e10);\n\n\t\tpublic void solve(FastScanner br, PrintWriter pw) throws IOException {\n\t\t\tint n = br.ni();\n\t\t\tInteger[] in = br.nIa(n);\n\t\t\tTreeSet<Integer> ts = new TreeSet<Integer>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tts.add(in[i]);\n\t\t\t}\n\t\t\tString twoSol = \"\";\n\t\t\tfor (int i = 0; i <= 30; i++) {\n\t\t\t\tfor (int j : in) {\n\t\t\t\t\tif (ts.contains(j + (int) Math.pow(2, i))) {\n\t\t\t\t\t\tif (ts.contains(j - (int) Math.pow(2, i))) {\n\t\t\t\t\t\t\tpw.println(3);\n\t\t\t\t\t\t\tpw.println(j + \" \" + (j + (int) Math.pow(2, i)) + \" \" + (j - (int) Math.pow(2, i)));\n\t\t\t\t\t\t\tpw.close();\n\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttwoSol = (j + \" \" + (j + (int) Math.pow(2, i)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (twoSol.isEmpty()) {\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(in[0]);\n\t\t\t} else {\n\t\t\t\tpw.println(2);\n\t\t\t\tpw.println(twoSol);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\tif (a > b)\n\t\t\t\treturn gcd(b, a);\n\t\t\tif (a == 0)\n\t\t\t\treturn b;\n\t\t\treturn gcd(b % a, a);\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\n\t\tstatic long pow(long a, long b) {\n\t\t\tif (b == 0)\n\t\t\t\treturn 1L;\n\t\t\tlong val = pow(a, b / 2);\n\t\t\tif (b % 2 == 0)\n\t\t\t\treturn val * val % mod;\n\t\t\telse\n\t\t\t\treturn val * val % mod * a % mod;\n\t\t}\n\n\t}\n\n\tstatic class Point implements Comparable<Point> {\n\t\tint a;\n\t\tint b;\n\n\t\tPoint(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn this.a - o.a;\n\t\t}\n\n\t}\n\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tArrayList<Integer>[] ng(int n, int e) {\n\t\t\tArrayList<Integer>[] adj = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint a = ni() - 1;\n\t\t\t\tint b = ni() - 1;\n\t\t\t\tadj[a].add(b);\n\t\t\t\tadj[b].add(a);\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\n\t\tInteger[] nIa(int n) {\n\t\t\tInteger[] arr = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = ni();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] nia(int n) {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = ni();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tLong[] nLa(int n) {\n\t\t\tLong[] arr = new Long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nl();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] nla(int n) {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nl();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tString[] nsa(int n) {\n\t\t\tString[] arr = new String[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tString nt() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint ni() {\n\t\t\treturn Integer.parseInt(nt());\n\t\t}\n\n\t\tlong nl() {\n\t\t\treturn Long.parseLong(nt());\n\t\t}\n\n\t\tdouble nd() {\n\t\t\treturn Double.parseDouble(nt());\n\t\t}\n\n\t}\n}", "complexity": "nlogn", "from": "CorCod", "problem": 668, "index": 668}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int m=Integer.parseInt(s1[1]);\n            int a[]=new int[n];\n            String s2[]=br.readLine().split(\" \");\n            long S=0;\n            for(int i=0;i<n;i++)\n            { a[i]=Integer.parseInt(s2[i]);  S+=(long)a[i]; }\n            \n            Arrays.sort(a);\n            m=a[n-1];\n            int last=1;\n            int t=1;\n            for(int i=1;i<n-1;i++)\n            {\n                  if(a[i]==last)\n                   t++;\n                  else\n                  {\n                        t++;\n                        last=last+1;\n                  }\n            }\n            if(last<m)\n            { t+=m-last; }\n            else\n             t++;\n            System.out.println(S-t);\n      }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 669, "index": 669}
{"src": "\n// Java program to find possibility to sort \n// by multiple subarray reverse operation \nimport\njava.util.*; \nclass\nGFG { \n\n\nstatic\nboolean\nifPossible(\nint\narr[], \nint\nn) \n\n{ \n\n\n// making the copy of the original array \n\nint\ncopy[] = Arrays.copyOf(arr, arr.length); \n\n\n// sorting the copied array \n\nArrays.sort(copy); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// checking mirror image of elements of \n\n// sorted copy array and equivalent element \n\n// of original array \n\nif\n(!(arr[i] == copy[i]) && !(arr[n - \n1\n- i] == copy[i])) \n\nreturn\nfalse\n; \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n// driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n7\n, \n6\n, \n4\n, \n5\n, \n3\n, \n2\n, \n8\n}; \n\nint\nn = arr.length; \n\nif\n(ifPossible(arr, n)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n} ", "complexity": "nlogn", "from": "CorCod", "problem": 670, "index": 670}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class CoveredPointsCount {\n\t\n\t//UPSOLVE\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t        \n\t\tint n = Integer.parseInt(st.nextToken());\n\t     \n\t\tlong[] myArray = new long[2 * n];\n\t        \n\t\t\tfor (int i = 0; i < n; i++)  {\n\t        \tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t        \tmyArray[2 * i] = Long.parseLong(st1.nextToken()) * 2;\n\t        \tmyArray[2 * i + 1] = Long.parseLong(st1.nextToken()) * 2 + 1;\n\t        }  \n\t        \n\t        Arrays.sort(myArray);\n\t        long[] ans = new long[n + 1];\n\t        int cnt = 0;\n\t       \n\t        for (int i = 0; i < 2 * n - 1; i++)   {\n\t            if (myArray[i] % 2 == 0) cnt++; else cnt--;\n\t            ans[cnt] += (myArray[i + 1] + 1) / 2 - (myArray[i] + 1) / 2;\n\t        }   \n\t        \n\t        StringBuilder answer = new StringBuilder();\n\t        \n\t        for (int i = 1; i < n + 1; i++) {\n\t        \tanswer.append(ans[i]);\n\t        \tanswer.append(\" \");\n\t        }  \n\t        \n\t        System.out.println(answer);\n\n\t}\n\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 671, "index": 671}
{"src": "\n// Java program to find the minimum possible \n// difference between maximum and minimum \n// elements when we have to add/subtract \n// every number by k \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Modifies the array by subtracting/adding \n\n// k to every element such that the difference \n\n// between maximum and minimum is minimized \n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n// Sort all elements \n\nArrays.sort(arr); \n\n\n// Initialize result \n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n// Handle corner elements \n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n// Traverse middle elements \n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n// If both subtraction and addition \n\n// do not change diff \n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n// Either subtraction causes a smaller \n\n// number or addition causes a greater \n\n// number. Update small or big using \n\n// greedy approach (If big - subtract \n\n// causes smaller diff, update small \n\n// Else update big) \n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n// Driver function to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n} \n// This code is contributed by Prerna Saini ", "complexity": "nlogn", "from": "CorCod", "problem": 672, "index": 672}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigInteger;\n\npublic class stacks {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastIO sc = new FastIO(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tlong remove = 0;\n\t\t\n\t\tint[] heights = new int[n+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\theights[i] = sc.nextInt();\n\t\t\tremove += heights[i];\n\t\t}\n\t\t\n\t\tArrays.sort(heights);\n\t\t//System.out.println(Arrays.toString(heights));\n\t\tlong keep = 0;\n\t\tfor(int i = n; i> 0; i--) {\n\t\t\tif(heights[i-1] >= heights[i]) {\n\t\t\t\theights[i-1] = heights[i]-1;\n\t\t\t}\n\t\t\tkeep += heights[i] - heights[i-1];\n\t\t}\n\t\t//System.out.println(Arrays.toString(heights));\n\t\t\n\t\tpw.println(remove - keep);\n\t\tpw.close();\n\t}\n\n\tstatic class FastIO {\n\n\t\t//Is your Fast I/O being bad?\n\n\t\tInputStream dis;\n\t\tbyte[] buffer = new byte[1 << 17];\n\t\tint pointer = 0;\n\n\t\tpublic FastIO(String fileName) throws Exception {\n\t\t\tdis = new FileInputStream(fileName);\n\t\t}\n\n\t\tpublic FastIO(InputStream is) throws Exception {\n\t\t\tdis = is;\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\tint ret = 0;\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\tboolean negative = false;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = nextByte();\n\t\t\t}\n\t\t\twhile (b >= '0' && b <= '9') {\n\t\t\t\tret = 10 * ret + b - '0';\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn (negative) ? -ret : ret;\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\tlong ret = 0;\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\tboolean negative = false;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = nextByte();\n\t\t\t}\n\t\t\twhile (b >= '0' && b <= '9') {\n\t\t\t\tret = 10 * ret + b - '0';\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn (negative) ? -ret : ret;\n\t\t}\n\n\t\tbyte nextByte() throws Exception {\n\t\t\tif (pointer == buffer.length) {\n\t\t\t\tdis.read(buffer, 0, buffer.length);\n\t\t\t\tpointer = 0;\n\t\t\t}\n\t\t\treturn buffer[pointer++];\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\tStringBuffer ret = new StringBuffer();\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\twhile (b > ' ') {\n\t\t\t\tret.appendCodePoint(b);\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn ret.toString();\n\t\t}\n\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 673, "index": 673}
{"src": "import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class gambling {\n    public static void main(String[] args) throws IOException{\n        Reader rd = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = rd.nextInt();\n        Integer[] a = new Integer[n];\n        Integer[] b = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = rd.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = rd.nextInt();\n        }\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, Integer[] a, Integer[] b, PrintWriter out) {\n        Arrays.sort(a, Collections.reverseOrder());\n        Arrays.sort(b, Collections.reverseOrder());\n        int aP = 0, bP = 0;\n        long aScore = 0, bScore = 0;\n        for (int i = 0; i < n * 2; i++) {\n                if(i % 2 == 0) {\n                    if(bP ==  n || (aP < n && a[aP] > b[bP])){\n                        aScore += a[aP];\n                        aP++;\n                    }\n                    else bP++;\n                }\n                else{\n                    if(aP == n || (bP < n && b[bP] > a[aP])) {\n                        bScore += b[bP];\n                        bP++;\n                    }\n                    else aP++;\n                }\n        }\n        out.println(aScore-bScore);\n    }\n\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 674, "index": 674}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class ladder {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int problems = sc.nextInt();\n        for (int i = 0; i < problems; i++) {\n            int numPlanks = sc.nextInt();\n            solve(numPlanks, sc);\n        }\n\n\n\n\n\n    }\n    public static void solve(int numPlanks, Scanner sc) {\n        int answer;\n        ArrayList<Integer> planks  = new ArrayList<>();\n        for (int i = 0; i < numPlanks; i++) {\n            planks.add(sc.nextInt());\n        }\n\n        Collections.sort(planks);\n\n        planks.remove(numPlanks - 1);\n        planks.add(planks.get(numPlanks - 2));\n        int base = planks.get(numPlanks - 1) - 1;\n        if ((numPlanks - 2) > base) {\n            answer = base;\n        }\n        else {\n            answer = numPlanks - 2;\n        }\n        if (base == 0) {\n            answer = 0;\n        }\n        System.out.println(answer);\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 675, "index": 675}
{"src": "\n// Java implementation to find the \n// minimum and maximum amount \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Function to find the minimum \n\n// amount to buy all candies \n\nstatic\nint\nfindMinimum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n// Buy current candy \n\nres += arr[i]; \n\n\n// And take k candies for free \n\n// from the last \n\nn = n - k; \n\n} \n\nreturn\nres; \n\n} \n\n\n// Function to find the maximum \n\n// amount to buy all candies \n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n, index = \n0\n; \n\n\nfor\n(\nint\ni = n - \n1\n; i >= index; i--) \n\n{ \n\n// Buy candy with maximum amount \n\nres += arr[i]; \n\n\n// And get k candies for free from \n\n// the starting \n\nindex += k; \n\n} \n\nreturn\nres; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n3\n, \n2\n, \n1\n, \n4\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\nArrays.sort(arr); \n\n\nSystem.out.println(findMinimum(arr, n, k) + \n\n\" \"\n+ findMaximum(arr, n, k)); \n\n} \n} \n\n// This code is contributed by prerna saini ", "complexity": "nlogn", "from": "CorCod", "problem": 676, "index": 676}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\npublic class LessorEqual_CodeForces {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString temp[]=br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(temp[0]);\n\t\tint k = Integer.parseInt(temp[1]);\n\t\ttemp=br.readLine().split(\" \");\n\t\tint [] num = new int[n];\n//\t\tint [] freq = new int [1000000000];\n\t\tPriorityQueue<Integer>pq = new PriorityQueue<Integer>();  \n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i]=Integer.parseInt(temp[i]);\n\t\t\tpq.add(num[i]);\n\t\t//\tfreq[num[i]]++;\n\t\t\t\t\t\t\n\t\t}\n\t\tif(k==0){\n\t\t\tint y= pq.poll();\n\t\t\tif(y==1){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tSystem.out.println(y-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\t//System.out.println(pq);\n\t\tint count=0;\n\t\tint max=0;\n\t\twhile (!pq.isEmpty()){\n\t\t\tint x = pq.poll();\n\t\t\twhile(count<=k&&!pq.isEmpty()&& pq.peek()==x){\n\t\t\t\tpq.poll();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t//\tSystem.out.println(x);\n\t\t\tcount++;\n\t\t\tmax=x;\n\t\t\tif(count==k)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//System.out.println(\"the count is \"+ count);\n\t\tif(count==k){\n\t\t\tif(!pq.contains(max+1)&& max<1e9)\n\t\t\t\tSystem.out.println(max+1);\n\t\t\telse \n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\telse \n\t\t\tSystem.out.println(-1);\n \n\t\t\n\t}\n\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 677, "index": 677}
{"src": "\n// Java program to sort an array according absolute \n// difference with x. \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n\n// Function to sort an array according absolute \n\n// difference with x. \n\nstatic\nvoid\nrearrange(\nint\n[] arr, \nint\nn, \nint\nx) \n\n{ \n\nTreeMap<Integer, ArrayList<Integer>> m = \nnew\nTreeMap<>(); \n\n\n// Store values in a map with the difference \n\n// with X as key \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndiff = Math.abs(x - arr[i]); \n\nif\n(m.containsKey(diff)) \n\n{ \n\nArrayList<Integer> al = m.get(diff); \n\nal.add(arr[i]); \n\nm.put(diff, al); \n\n} \n\nelse\n\n{ \n\nArrayList<Integer> al = \nnew\nArrayList<>(); \n\nal.add(arr[i]); \n\nm.put(diff,al); \n\n} \n\n} \n\n\n// Update the values of array \n\nint\nindex = \n0\n; \n\nfor\n(Map.Entry entry : m.entrySet()) \n\n{ \n\nArrayList<Integer> al = m.get(entry.getKey()); \n\nfor\n(\nint\ni = \n0\n; i < al.size(); i++) \n\narr[index++] = al.get(i); \n\n} \n\n} \n\n\n// Function to print the array \n\nstatic\nvoid\nprintArray(\nint\n[] arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] arr = {\n10\n, \n5\n, \n3\n, \n9\n,\n2\n}; \n\nint\nn = arr.length; \n\nint\nx = \n7\n; \n\nrearrange(arr, n, x); \n\nprintArray(arr, n); \n\n} \n} \n\n// This code is contributed by rachana soma ", "complexity": "nlogn", "from": "CorCod", "problem": 678, "index": 678}
{"src": "import javafx.util.Pair;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Beacon8 {\n    public static void main(String[] args) throws IOException {\n//        int[] arr = {1, 3, 7, 18};\n//        int bIndex = Arrays.binarySearch(arr, 4);\n//        System.out.println(bIndex);\n\n\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        Map<Integer, Integer> beacons = new TreeMap<>();\n\n        for (int i = 0; i < n; i++) {\n            int index = scan.nextInt();\n            int power = scan.nextInt();\n            beacons.put(index, power);\n        }\n        int[] indicesArr = new int[n];\n        int arrInd = 0;\n        for (int index : beacons.keySet()) {\n            indicesArr[arrInd] = index;\n            arrInd++;\n        }\n       // Integer[] indicesArr = ((Integer[])beacons.keySet().toArray());\n        int[] nDestroys = new int[n];\n        for (int i = 0; i < n; i++) {\n            int bIndex = Arrays.binarySearch(indicesArr, indicesArr[i] - beacons.get(indicesArr[i]));\n            if (bIndex < 0)\n                bIndex = -(bIndex + 1);\n            nDestroys[i] = i - bIndex;\n        }\n        int[] totalBeacons = new int[n];\n        int maxBeacons = 1;\n        totalBeacons[0] = 1;\n        for (int i = 1; i < n; i++) {\n            if (nDestroys[i] == 0)\n                totalBeacons[i] = totalBeacons[i - 1] + 1;\n            else {\n                if ((i - nDestroys[i] - 1) >= 0)\n                    totalBeacons[i] = totalBeacons[i - nDestroys[i] - 1] + 1;\n                else\n                    totalBeacons[i] = 1;\n            }\n               // totalBeacons[i] = totalBeacons[i - nDestroys[i]] + 1;\n            //totalBeacons[i] = i - nDestroys[i] + totalBeacons[i - nDestroys[i]] + 1;\n            if(totalBeacons[i] > maxBeacons)\n                maxBeacons = totalBeacons[i];\n        }\n//        System.out.println(\"\\ntotalBeacons array\");\n//        for (int i = 0; i < n; i++) {\n//            System.out.print(totalBeacons[i] + \" \");\n//        }\n//        if (maxBeacons == -1)\n//            System.out.println(n);\n        System.out.println(n - maxBeacons);\n    }\n\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 679, "index": 679}
{"src": "\nimport java.util.*;\n\n\npublic class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 680, "index": 680}
{"src": "\n// Java program to find minimum \n// increment/decrement operations \n// to make array elements same. \nimport\njava.util.Arrays; \nimport\njava.io.*; \n\nclass\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nb[], \n\nint\nn) \n{ \n\n// sorting both arrays \n\n// in ascending order \n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n// variable to store \n\n// the final result \n\nint\nresult = \n0\n; \n\n\n// After sorting both arrays \n\n// Now each array is in non- \n\n// decreasing order. Thus, \n\n// we will now compare each \n\n// element of the array and \n\n// do the increment or decrement \n\n// operation depending upon the \n\n// value of array b[]. \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\nif\n(a[i] > b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n\nelse\nif\n(a[i] < b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n} \n\n\nreturn\nresult; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = {\n3\n, \n1\n, \n1\n}; \n\nint\nb[] = {\n1\n, \n2\n, \n2\n}; \n\nint\nn = a.length; \n\nSystem.out.println(MinOperation(a, b, n)); \n} \n} \n\n// This code is contributed \n// by akt_mit ", "complexity": "nlogn", "from": "CorCod", "problem": 681, "index": 681}
{"src": "import java.util.*;\npublic class test{\npublic static void main(String args[])\n{\nScanner s=new Scanner(System.in);\nint n=s.nextInt();\nint m=s.nextInt();\nint arr[]=new int[n];\nint max = Integer.MIN_VALUE;\n        long sum = 0;\n        for(int i=0;i<n;i++)\n        {\n            arr[i] = s.nextInt();\n            sum = sum + arr[i];\n            max = Math.max(max,arr[i]);\n        }\n        Arrays.sort(arr);\n        int i = 0;\n        int count = 0;\n        int d = 0;\n        for(i=0; i<n; i++)\n        {\n            if(arr[i] > d)\n            {\n                count++;\n                d++;\n            }\n            else if(arr[i] == d && arr[i] > 0)\n            {\n                count++;\n            }\n        }\n        //System.out.println(count + \" \" + max);\n        if(max - d > 0)\n        {\n            count = count + max - d;\n        }\n        System.out.println(sum - count);}}", "complexity": "nlogn", "from": "CorCod", "problem": 682, "index": 682}
{"src": "\n// C# program to acquire all n coins at \n// minimum cost with multiple values of k. \nimport\njava .io.*; \nimport\njava.util.Arrays; \n\npublic\nclass\nGFG { \n\n\n// Converts coin[] to prefix sum array \n\nstatic\nvoid\npreprocess(\nint\n[]coin, \nint\nn) \n\n{ \n\n\n// sort the coins value \n\nArrays.sort(coin); \n\n\n// Maintain prefix sum array \n\nfor\n(\nint\ni = \n1\n; i <= n - \n1\n; i++) \n\ncoin[i] += coin[i - \n1\n]; \n\n} \n\n\n// Function to calculate min cost when we \n\n// can get k extra coins after paying \n\n// cost of one. \n\nstatic\nint\nminCost(\nint\n[]coin, \nint\nn, \nint\nk) \n\n{ \n\n\n// calculate no. of coins needed \n\nint\ncoins_needed =(\nint\n) Math.ceil(\n1.0\n\n* n / (k + \n1\n)); \n\n\n// return sum of from prefix array \n\nreturn\ncoin[coins_needed - \n1\n]; \n\n} \n\n\n// Driver Code \n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]coin = {\n8\n, \n5\n, \n3\n, \n10\n, \n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\n\npreprocess(coin, n); \n\n\nint\nk = \n3\n; \n\nSystem.out.println(minCost(coin, n, k)); \n\n\nk = \n7\n; \n\nSystem.out.println( minCost(coin, n, k)); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "complexity": "nlogn", "from": "CorCod", "problem": 683, "index": 683}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n\npublic class pr988B {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = Integer.parseInt(br.readLine());\n\n        ArrayList<String> a = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            a.add(br.readLine());\n        }\n\n        if(solve(n, a)){\n            out.println(\"YES\");\n            for (String s : a) {\n                out.println(s);\n            }\n        }\n        else\n            out.println(\"NO\");\n\n        out.flush();\n        out.close();\n    }\n\n    private static boolean solve(int n, ArrayList<String> a) {\n        a.sort(Comparator.comparingInt(String::length));\n        for (int i = 0; i < n - 1; i++) {\n            if(!a.get(i+1).contains(a.get(i))) return false;\n        }\n        return true;\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 684, "index": 684}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class RadioStation {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tmap.put(t, s);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tSystem.out.println(s + \" \" + t + \" #\" + map.get(t.substring(0, t.length()-1)));\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "nlogn", "from": "CorCod", "problem": 685, "index": 685}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n//BigInteger A;\n//A= BigInteger.valueOf(54);\n//ArrayList<Integer> a=new ArrayList<>();\n//TreeSet<Integer> ts=new TreeSet<>();\n//HashMap<Integer,Integer> hm=new HashMap<>();\npublic final class Cf\n{\n    public static void main(String[]args)\n    {\n        FastReader ob=new FastReader();\n        //int t=ob.nextInt();\n        //while(t-->0)\n        {\n            int n=ob.nextInt();\n            int k=ob.nextInt();\n            int a[]=new int[n];\n            for(int i=0;i<n;i++)\n            a[i]=ob.nextInt();\n            int x=a[n-1]-a[0];\n            ArrayList<Integer> b=new ArrayList<>();\n            for(int i=0;i<n-1;i++)\n            b.add(-a[i+1]+a[i]);\n            Collections.sort(b);\n            for(int i=0;i<k-1;i++)\n            x+=b.get(i);\n            System.out.println(x);\n        }\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextLine()\n    {\n        String s=\"\";\n        try {\n        s=br.readLine();\n        } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        return s;\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 686, "index": 686}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class A {\n    static MyScanner sc;\n    static PrintWriter pw;\n\n    public static void main(String[] args) throws Throwable {\n        sc = new MyScanner();\n        pw = new PrintWriter(System.out);\n\n        n = sc.nextInt();\n        T = sc.nextLong();\n        p = new int[n];\n        l = new int[n];\n        x = new int[n];\n        t = new int[n];\n        adj = new ArrayList[n];\n\n        for (int i = 0; i < n; i++)\n            x[i] = sc.nextInt();\n        for (int i = 0; i < n; i++)\n            t[i] = sc.nextInt();\n        adj[0] = new ArrayList<>();\n        for (int i = 1; i < n; i++) {\n            adj[i] = new ArrayList<>();\n            p[i] = sc.nextInt() - 1;\n            l[i] = sc.nextInt();\n            adj[p[i]].add(i);\n        }\n\n        ftCnt = new long[N];\n        ftSum = new long[N];\n        ans = new long[n];\n\n        dfs(0);\n        pw.println(ans[0]);\n\n        pw.flush();\n        pw.close();\n    }\n\n    static int n;\n    static long T;\n    static int[] p, l, x, t;\n    static ArrayList<Integer>[] adj;\n\n    static long[] ans;\n\n    static void dfs(int u) {\n        update(t[u], x[u], 1L * x[u] * t[u]);\n        ans[u] = getMaxCnt();\n        long[] vals = {-1, -1, -1};\n        for (int v : adj[u]) {\n            T -= 2 * l[v];\n            dfs(v);\n            vals[0] = ans[v];\n            Arrays.sort(vals);\n            T += 2 * l[v];\n        }\n        if (u != 0) {\n            if (vals[1] != -1)\n                ans[u] = Math.max(ans[u], vals[1]);\n        } else {\n            if (vals[2] != -1)\n                ans[u] = Math.max(ans[u], vals[2]);\n        }\n        update(t[u], -x[u], -1L * x[u] * t[u]);\n    }\n\n    static int N = (int) 1e6 + 2;\n    static long[] ftCnt, ftSum;\n\n    static void update(int idx, long cnt, long val) {\n        while (idx < N) {\n            ftCnt[idx] += cnt;\n            ftSum[idx] += val;\n            idx += (idx & -idx);\n        }\n    }\n\n    static long getSum(int idx) {\n        long ret = 0;\n        while (idx > 0) {\n            ret += ftSum[idx];\n            idx -= (idx & -idx);\n        }\n        return ret;\n    }\n\n    static long getCnt(int idx) {\n        long ret = 0;\n        while (idx > 0) {\n            ret += ftCnt[idx];\n            idx -= (idx & -idx);\n        }\n        return ret;\n    }\n\n    static long getMaxCnt() {\n        int start = 1, end = N - 1, ans = N - 1;\n        while (start <= end) {\n            int mid = (start + end) / 2;\n            if (getSum(mid) >= T) {\n                ans = mid;\n                end = mid - 1;\n            } else\n                start = mid + 1;\n        }\n        long remT = T - (ans > 1 ? getSum(ans - 1) : 0);\n        long cnt = (ans > 1 ? getCnt(ans - 1) : 0);\n        long cntOfVal = getCnt(ans) - cnt;\n        cnt += Math.min(cntOfVal, remT / ans);\n        return cnt;\n    }\n\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 687, "index": 687}
{"src": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.StringJoiner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Test {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = reader.readLine().split(\" \");\n        int w = Integer.valueOf(line[0]);\n        int h = Integer.valueOf(line[1]);\n        int n = Integer.valueOf(line[2]);\n\n        Request[] requests = new Request[n];\n\n        for (int i = 0; i < n; i++) {\n            line = reader.readLine().split(\" \");\n            requests[i] = new Request(line[0], Integer.valueOf(line[1]));\n        }\n\n        for (long e : solve(h, w, requests))\n            System.out.println(e);\n\n//        int w = 200000, h = 200000, n = 400000;\n//        Request[] requests = generate(w, h, n);\n//\n//        long start = System.currentTimeMillis();\n//        solve(h, w, requests);\n//        long end = System.currentTimeMillis();\n//\n//        System.out.println(\"Time: \" + (end - start) + \" ms\");\n    }\n\n    private static Request[] generate(int w, int h, int n) {\n        Request[] requests = new Request[n];\n        Random rnd = new Random();\n\n        for (int i = 0; i < n; i++) {\n            requests[i] = rnd.nextBoolean() ? new Request(\"V\", rnd.nextInt(w)) : new Request(\"H\", rnd.nextInt(h));\n        }\n\n        return requests;\n    }\n\n    private static long[] solve(int h, int w, Request[] requests) {\n        TreeSet<Integer> hTree = new TreeSet<>();\n        TreeSet<Integer> wTree = new TreeSet<>();\n\n        Queue<CoordinateWithSize> hHeap = new PriorityQueue<>();\n        Queue<CoordinateWithSize> wHeap = new PriorityQueue<>();\n\n        hTree.add(0);\n        hTree.add(h);\n        wTree.add(0);\n        wTree.add(w);\n\n        hHeap.add(new CoordinateWithSize(0, h));\n        wHeap.add(new CoordinateWithSize(0, w));\n\n        long[] res = new long[requests.length];\n        for (int i = 0; i < requests.length; i++) {\n            Request request = requests[i];\n\n            switch (request.type) {\n                case \"H\": {\n                    if (!hTree.contains(request.coordinate)) {\n                        int higher = hTree.higher(request.coordinate);\n                        int lower = hTree.lower(request.coordinate);\n\n                        hHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        hHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        hTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                case \"V\": {\n                    if (!wTree.contains(request.coordinate)) {\n                        int higher = wTree.higher(request.coordinate);\n                        int lower = wTree.lower(request.coordinate);\n\n                        wHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        wHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        wTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                default:\n                    throw new IllegalStateException(\"Unknown type [type=\" + request.type + \"]\");\n            }\n\n            while (true) {\n                CoordinateWithSize c = hHeap.peek();\n                if (hTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                hHeap.remove();\n            }\n\n            while (true) {\n                CoordinateWithSize c = wHeap.peek();\n                if (wTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                wHeap.remove();\n            }\n\n            res[i] = 1L * hHeap.peek().size * wHeap.peek().size;\n        }\n\n        return res;\n    }\n\n    private static class CoordinateWithSize implements Comparable<CoordinateWithSize> {\n\n        private final int coordinate;\n\n        private final int size;\n\n        public CoordinateWithSize(int coordinate, int size) {\n            this.coordinate = coordinate;\n            this.size = size;\n        }\n\n        @Override public int compareTo(CoordinateWithSize o) {\n            return Integer.compare(o.size, size);\n        }\n    }\n\n    private static class Request {\n\n        private final String type;\n\n        private final int coordinate;\n\n        public Request(String type, int coordinate) {\n            this.type = type;\n            this.coordinate = coordinate;\n        }\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 688, "index": 688}
{"src": "import java.util.Scanner;\npublic class JavaApplication7 {\n\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n= sc.nextInt();\n        int m=sc.nextInt();\n        long sum=0;\n        long []d=new long[n];\n        long[]ds=new long[n];\n        for(int i =0;i<n;i++){\n            d[i]=sc.nextLong();\n            sum+=d[i];\n            ds[i]=sum;\n        }\n        long[]le=new long[m];\n        for(int i =0;i<m;i++){\n            le[i]=sc.nextLong();\n        }\n        int l=0;\n        int h=n;\n        int k=(h-l)/2;\n        k+=l;\n        for(int i=0;i<m;i++){\n        l=0;\n        h=n;\n        k=(h-l)/2;\n        k+=l;\n            for(;l<=h;){\n                k=(h-l)/2;\n                k+=l;\n                if(ds[k]<le[i]){\n                    l=k+1;\n                }\n                else if(ds[k]==le[i]){break;}\n                else{\n                    h=k-1;\n                }\n            }\n            //System.out.println(k);\n            if(ds[k]<le[i]){\n                    k++;\n                }\n          if(k==0){\n              System.out.println((int)(k+1)+\" \"+le[i]);\n           }\n            else{\n                System.out.println((int)(k+1)+\" \"+(long)(le[i]-ds[k-1]));\n           }\n        }\n        \n    }\n    \n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 689, "index": 689}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class ChainReaction implements Closeable {\n\n  private InputReader in = new InputReader(System.in);\n  private PrintWriter out = new PrintWriter(System.out);\n  \n  private class Beacon implements Comparable<Beacon> {\n    private int position, range, score;\n\n    private Beacon(int position, int range) {\n      this.position = position;\n      this.range = range;\n    }\n\n    public void setScore(int score) {\n      this.score = score;\n    }\n\n    @Override\n    public int compareTo(Beacon o) {\n      return Integer.compare(this.position, o.position);\n    }\n  }\n\n  public void solve() {\n    int n = in.ni();\n    if (n == 1) {\n      out.println(0);\n      return;\n    }\n    beacons = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      beacons.add(new Beacon(in.ni(), in.ni()));\n    }\n    beacons.sort(Comparator.naturalOrder());\n    for (int i = 1; i < n; i++) {\n      int left = 0, right = i - 1, position = beacons.get(i).position, range = beacons.get(i).range;\n      int leftmost = i;\n      while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (position - range <= beacons.get(mid).position) {\n          leftmost = Math.min(leftmost, mid);\n          right = mid - 1;\n        } else {\n          left = mid + 1;\n        }\n      }\n      beacons.get(i).setScore(i - leftmost);\n    }\n    dp = new Integer[n];\n    int ans = Integer.MAX_VALUE;\n    for (int i = n - 1; i >= 0; i--) {\n      ans = Math.min(n - 1 - i + recurse(i), ans);\n    }\n    out.println(ans);\n  }\n  \n  private List<Beacon> beacons;\n  private Integer[] dp;\n  \n  private int recurse(int idx) {\n    if (idx <= 0) return 0;\n    \n    if (dp[idx] != null) return dp[idx];\n    \n    int destroyed = beacons.get(idx).score;\n    int ans = destroyed + recurse(idx - destroyed - 1);\n    return dp[idx] = ans;\n  }\n  \n  @Override\n  public void close() throws IOException {\n    in.close();\n    out.close();\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int ni() {\n      return Integer.parseInt(next());\n    }\n\n    public long nl() {\n      return Long.parseLong(next());\n    }\n\n    public void close() throws IOException {\n      reader.close();\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    try (ChainReaction instance = new ChainReaction()) {\n      instance.solve();\n    }\n  }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 690, "index": 690}
{"src": "import java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int a[] = new int[n];\n        int b[] = new int[n];\n        for (int i = 0; i < n; i++) a[i] = sc.nextInt();\n        for (int i = 0; i < n; i++) b[i] = sc.nextInt();\n        int c[] = new int[2 * n];\n        c[0] = a[0];\n        for (int i = 1; i < n; i++) {\n            c[i * 2] = a[i];\n            c[i * 2 - 1] = b[i];\n            if (a[i] == 1 || b[i] == 1) {\n                System.out.print(-1);\n                System.exit(0);\n            }\n        }\n        c[2 * n - 1] = b[0];\n        if (a[0] == 1 || b[0] == 1) {\n            System.out.print(-1);\n            System.exit(0);\n        }\n        System.out.println(bin_search(c, m));\n    }\n\n    private static double bin_search(int[] c, int m) {\n        double start = 0;\n        double end = Integer.MAX_VALUE;\n        double mid;\n        while (start + 0.0000001 < end) {\n            mid = (start + end) / 2;\n            if (test(mid, m, c)) end = mid;\n            else start = mid;\n        }\n        return end;\n    }\n\n    private static boolean test(double fuel, int m, int[] c) {\n        for (int i = 0; i < c.length; i++) {\n            fuel -= (m + fuel) / c[i];\n            if (fuel < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 691, "index": 691}
{"src": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.security.SecureRandom;\n\npublic class WCS {\n\t\n\tpublic static class Vector implements Comparable <Vector>  {\n\t\tlong x, y;\n\t\tint position;\n\t\tVector first, second;\n\t\tboolean toReverse;\n\t\t\n\t\tpublic Vector(long xx, long yy, int p) {\n\t\t\tx = xx;\n\t\t\ty = yy;\n\t\t\tposition = p;\n\t\t\tfirst = null;\n\t\t\tsecond = null;\n\t\t\ttoReverse = false;\n\t\t}\n\t\t\n\t\tpublic Vector negate() {\n\t\t\tVector vv = new Vector(-x, -y, position);\n\t\t\tvv.first = first;\n\t\t\tvv.second = second;\n\t\t\tvv.toReverse = !toReverse;\n\t\t\treturn vv;\n\t\t}\n\t\t\n\t\tpublic Vector add(Vector v) {\n\t\t\tVector sum = new Vector(this.x + v.x, this.y + v.y, position);\n\t\t\tsum.first = this;\n\t\t\tsum.second = v;\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tpublic Vector subtract(Vector v) {\n\t\t\treturn this.add(v.negate());\n\t\t}\n\t\t\n\t\tpublic double euclideanNorm() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Vector v) {\n\t\t\tdouble thisa = Math.atan2(this.y, this.x);\n\t\t\tdouble va = Math.atan2(v.y, v.x);\n\t\t\tif(thisa < 0)\n\t\t\t\tthisa += 2 * Math.PI;\n\t\t\tif(va < 0)\n\t\t\t\tva += 2 * Math.PI;\n\t\t\tif(thisa < va)\n\t\t\t\treturn -1;\n\t\t\tif(thisa > va)\n\t\t\t\treturn 1;\n\t\t\treturn Integer.compare(this.position, v.position);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y;\n\t\t}\n\t}\n\t\n\tpublic static void dfs(Vector curr, int[] ans) {\n\t\tif(curr.first == null) {\n\t\t\tans[curr.position] = curr.toReverse ? -1 : 1;\n\t\t\treturn;\n\t\t}\n\t\tcurr.first.toReverse ^= curr.toReverse;\n\t\tcurr.second.toReverse ^= curr.toReverse;\n\t\tdfs(curr.first, ans);\n\t\tdfs(curr.second, ans);\n\t}\n\t\n\tpublic static boolean ok(Vector v1, Vector v2) {\n\t\treturn v1.add(v2).euclideanNorm() <= Math.max(v1.euclideanNorm(), v2.euclideanNorm());\n\t}\n\t\n\tpublic static void stop(long k) {\n\t\tlong time = System.currentTimeMillis();\n\t\twhile(System.currentTimeMillis() - time < k);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = in.nextInt();\n\t\tTreeSet <Vector> vectors = new TreeSet <> ();\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\tVector v = new Vector(in.nextLong(), in.nextLong(), i);\n\t\t\tvectors.add(v);\n\t\t}\n\t\twhile(vectors.size() > 2) {\n\t\t\t//System.out.println(vectors);\n\t\t\t//stop(500);\n\t\t\t\n\t\t\tTreeSet <Vector> support = new TreeSet <> ();\n\t\t\t\n\t\t\twhile(vectors.size() > 0) {\n\t\t\t\tVector curr = vectors.pollFirst();\n\t\t\t\tVector next1 = vectors.higher(curr);\n\t\t\t\tVector next2 = vectors.lower(curr.negate());\n\t\t\t\tVector next3 = vectors.higher(curr.negate());\n\t\t\t\tVector next4 = vectors.lower(curr);\n\t\t\t\t\n\t\t\t\t//System.out.println(\"CURR: \" + curr + \"\\n\" + next1 + \"\\n\" + next2);\n\t\t\t\t\n\t\t\t\tif(next1 != null) {\n\t\t\t\t\tif(ok(curr, next1)) {\n\t\t\t\t\t\tsupport.add(curr.add(next1));\n\t\t\t\t\t\tvectors.remove(next1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next1 != null) {\n\t\t\t\t\tif(ok(curr, next1.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next1));\n\t\t\t\t\t\tvectors.remove(next1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next2 != null) {\n\t\t\t\t\tif(ok(curr, next2)) {\n\t\t\t\t\t\tsupport.add(curr.add(next2));\n\t\t\t\t\t\tvectors.remove(next2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next2 != null) {\n\t\t\t\t\tif(ok(curr, next2.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next2));\n\t\t\t\t\t\tvectors.remove(next2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next3 != null) {\n\t\t\t\t\tif(ok(curr, next3)) {\n\t\t\t\t\t\tsupport.add(curr.add(next3));\n\t\t\t\t\t\tvectors.remove(next3);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next3 != null) {\n\t\t\t\t\tif(ok(curr, next3.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next3));\n\t\t\t\t\t\tvectors.remove(next3);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next4 != null) {\n\t\t\t\t\tif(ok(curr, next4)) {\n\t\t\t\t\t\tsupport.add(curr.add(next4));\n\t\t\t\t\t\tvectors.remove(next4);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next4 != null) {\n\t\t\t\t\tif(ok(curr, next4.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next4));\n\t\t\t\t\t\tvectors.remove(next4);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsupport.add(curr);\n\t\t\t}\n\t\t\t\n\t\t\tvectors = support;\n\t\t}\n\t\t\n\t\tif(vectors.size() == 2) {\n\t\t\tVector curr = vectors.pollFirst();\n\t\t\tVector next = vectors.pollFirst();\n\t\t\tVector add = curr.add(next);\n\t\t\tVector sub = curr.subtract(next);\n\t\t\tif(sub.euclideanNorm() <= add.euclideanNorm())\n\t\t\t\tvectors.add(sub);\n\t\t\telse\n\t\t\t\tvectors.add(add);\n\t\t}\n\t\t\n\t\t//System.out.println(vectors.first().euclideanNorm());\n\t\t\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint[] ans = new int[n];\n\t\tdfs(vectors.pollFirst(), ans);\n\t\tfor(int i = 0; i < n; i ++)\n\t\t\tbuffer.append(ans[i] + \" \");\n\t\tSystem.out.println(buffer);\n\t}\n    \n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        BigInteger nextBigInteger() {\n        \treturn new BigInteger(in.next());\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        char nextChar() {\n            return in.next().charAt(0);\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    static FastReader in = new FastReader();\n    static OutputStream out = new BufferedOutputStream(System.out);\n    \n    public static byte[] toByte(Object o) {\n        return String.valueOf(o).getBytes();\n    }\n    \n    public static void sop(Object o) {\n        System.out.print(o);\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 692, "index": 692}
{"src": "import java.io.BufferedReader;\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\nimport java.io.InputStream ;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\n\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        PrintWriter out = new PrintWriter(System.out);\n        //Scanner sc = new Scanner();\n        Reader in = new Reader();\n        Main solver = new Main();\n        solver.solve(out, in);\n        out.flush();\n        out.close();\n\n    }\n    \n    \n    void solve(PrintWriter out, Reader in) throws IOException{   \n        int n = in.nextInt();\n        int m = in.nextInt();\n        \n        \n        \n        int[] vert = new int[n+1];\n        for(int i=0 ;i<n ;i++) vert[i] = in.nextInt();\n        vert[n] = (int)1e9;\n        \n        int cnt=0,x,y;\n        ArrayList<Integer> arr = new ArrayList<>();\n        for(int i=0 ;i<m ;i++) {\n            x = in.nextInt();\n            y = in.nextInt();\n            in.nextInt();\n            \n            if(x==1) arr.add(y);\n        }\n        \n        horz = new int[arr.size()];\n        for(int i=0 ;i<arr.size();i++) horz[i] = arr.get(i);\n        \n        Arrays.sort(horz);\n        Arrays.sort(vert);\n        \n        int ans = 2*(int)1e5+10;\n        for(int i=0 ;i<=n ;i++){\n            int lesshorz = bs(vert[i],horz.length);\n            ans = Math.min(ans,i+horz.length-lesshorz-1);\n        }\n        out.println(ans);\n    }\n    \n    static int[] horz;\n    \n    static int bs(int num,int m){\n        int mid,lo=0,hi=m-1,r=-1;\n        \n        while(lo<=hi){\n            mid = (lo+hi)/2;\n            if(horz[mid]<num){\n                lo = mid+1;\n                r = mid;\n            }else{\n                hi =mid-1;\n            }\n        }\n        return r;\n    }\n    \n    static class Reader {\n \n        private InputStream mIs;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n     \n        public Reader() {\n            this(System.in);\n        }\n     \n        public Reader(InputStream is) {\n            mIs = is;\n        }\n     \n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n        \n        }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = mIs.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n     \n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n     \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n     \n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n     \n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 693, "index": 693}
{"src": "\n// Java program to rearrange the array \n// as per the given condition \nimport\njava.util.*; \nimport\njava.lang.*; \n\npublic\nclass\nGfG{ \n\n// function to rearrange the array \n\npublic\nstatic\nvoid\nrearrangeArr(\nint\narr[], \n\nint\nn) \n\n{ \n\n// total even positions \n\nint\nevenPos = n / \n2\n; \n\n\n// total odd positions \n\nint\noddPos = n - evenPos; \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n\n\n// copy original array in an \n\n// auxiliary array \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntempArr[i] = arr[i]; \n\n\n// sort the auxiliary array \n\nArrays.sort(tempArr); \n\n\nint\nj = oddPos - \n1\n; \n\n\n// fill up odd position in \n\n// original array \n\nfor\n(\nint\ni = \n0\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj--; \n\n} \n\n\nj = oddPos; \n\n\n// fill up even positions in \n\n// original array \n\nfor\n(\nint\ni = \n1\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj++; \n\n} \n\n\n// display array \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\nint\n[] arr = \nnew\nint\n[]{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n\n6\n, \n7\n}; \n\nint\nsize = \n7\n; \n\nrearrangeArr(arr, size); \n\n\n} \n} \n\n/* This code is contributed by Sagar Shukla */", "complexity": "nlogn", "from": "CorCod", "problem": 694, "index": 694}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n\n    private static int[] a;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt(), m = sc.nextInt();\n\n        a = new int[101];\n        for (int i = 0; i < m; i++) {\n            int type = sc.nextInt();\n            a[type] = a[type] + 1;\n        }\n\n        int lo=1, hi=100, max=0;\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo)/2;\n            if (check(n, mid)) {\n                max = mid;\n                lo = mid+1;\n            } else {\n                hi = mid -1;\n            }\n        }\n        System.out.println(max);\n    }\n\n    public static boolean check(int n, int target) {\n        int result = 0;\n        for (int i=0; i <a.length; i++) {\n            result = result + (a[i] / target);\n        }\n        if (result >= n) {return true;}\n        return false;\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 695, "index": 695}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    static class Data{\n        int x,i;\n        Data(int x,int i){\n            this.x = x;\n            this.i = i;\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\"\\\\s\");\n        int N = Integer.parseInt(s[0]);\n        int K = Integer.parseInt(s[1]);\n        s = br.readLine().split(\"\\\\s\");\n        int[] arr = new int[N];\n        for(int i=0;i<N;++i) arr[i] = Integer.parseInt(s[i]);\n        solve(N,K,arr);   \n    }\n    \n    private static void solve(int N,int K,int[] arr){\n       PriorityQueue<Data> pq = new PriorityQueue<Data>(2000,(a,b) -> a.x - b.x == 0 ? b.i - a.i : b.x - a.x);\n       for(int i=0;i<arr.length;++i){\n           pq.offer(new Data(arr[i],i));\n       }\n       \n       int tot_sum = 0;\n       List<Integer> ls = new ArrayList<>();\n       Set<Integer> set = new HashSet<>();\n       \n       for(int i=1;i<=K;++i){\n           Data t = pq.poll();\n           tot_sum += t.x;\n           set.add(t.i);\n       }\n       int last = -1;\n       for(int i =0;i<arr.length;++i){\n           if(set.contains(i)){\n               K--;\n               //System.out.println(i);\n               if(K == 0) ls.add(arr.length-last-1);\n               else ls.add(i-last);\n               last = i;\n           }\n       }\n       \n       System.out.println(tot_sum);\n       int size = ls.size();\n       for(int i=0;i<size;++i){\n           System.out.print(ls.get(i) + \" \");\n       }\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 696, "index": 696}
{"src": "import java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class BigInteger7 {\n    public static void main(String[] args) {\n        //https://codeforces.com/contest/1011/problem/A\n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 697, "index": 697}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport javax.lang.model.util.ElementScanner6;\npublic class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer nk=new StringTokenizer(br.readLine());\n        int n=Integer.parseInt(nk.nextToken());\n        int k=Integer.parseInt(nk.nextToken());\n        String st[]=br.readLine().split(\" \");\n        \n        int ans[]=new int[n];\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            ans[i]=Integer.parseInt(st[i]);  \n\n        for(int i=1;i<n;i++)\n            a[i]=ans[i]-ans[i-1];\n        a[0]=-1;\n\n        Arrays.sort(a);\n        int count=0,sum=0;\n        for(int i=0;i<n;i++)\n            if(a[i]<0)\n                count++;\n            else\n                sum=sum+a[i];\n        \n        k=k-count;\n        int i=n-1;\n        while(k>0 && i>=0)\n        {\n            if(a[i]>-1)\n            {\n                sum=sum-a[i];\n                k--;\n            }\n            i--;\n        }\n        System.out.println(sum);\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 698, "index": 698}
{"src": "\n// Program to make all array equal \nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n// function for calculating min operations \n\nstatic\nint\nminOps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n// max elements of array \n\nArrays.sort(arr); \n\nint\nmax = arr[arr.length - \n1\n]; \n\nint\nres = \n0\n; \n\n\n// iterate for all elements \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// check if element can make equal to \n\n// max or not if not then return -1 \n\nif\n((max - arr[i]) % k != \n0\n) \n\nreturn\n-\n1\n; \n\n\n// else update res for required operations \n\nelse\n\nres += (max - arr[i]) / k; \n\n} \n\n\n// return result \n\nreturn\nres; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n21\n, \n33\n, \n9\n, \n45\n, \n63\n}; \n\nint\nn = arr.length; \n\nint\nk = \n6\n; \n\nSystem.out.println(minOps(arr, n, k)); \n\n} \n} \n\n// This code is contributed by vt_m ", "complexity": "nlogn", "from": "CorCod", "problem": 699, "index": 699}
{"src": "\n// Java program to find length of longest increasing subsequence \n// in O(n Log n) time \nimport\njava.io.*; \nimport\njava.util.*; \nimport\njava.lang.Math; \n\nclass\nLIS { \n\n// Binary search (note boundaries in the caller) \n\n// A[] is ceilIndex in the caller \n\nstatic\nint\nCeilIndex(\nint\nA[], \nint\nl, \nint\nr, \nint\nkey) \n\n{ \n\nwhile\n(r - l > \n1\n) { \n\nint\nm = l + (r - l) / \n2\n; \n\nif\n(A[m] >= key) \n\nr = m; \n\nelse\n\nl = m; \n\n} \n\n\nreturn\nr; \n\n} \n\n\nstatic\nint\nLongestIncreasingSubsequenceLength(\nint\nA[], \nint\nsize) \n\n{ \n\n// Add boundary case, when array size is one \n\n\nint\n[] tailTable = \nnew\nint\n[size]; \n\nint\nlen; \n// always points empty slot \n\n\ntailTable[\n0\n] = A[\n0\n]; \n\nlen = \n1\n; \n\nfor\n(\nint\ni = \n1\n; i < size; i++) { \n\nif\n(A[i] < tailTable[\n0\n]) \n\n// new smallest value \n\ntailTable[\n0\n] = A[i]; \n\n\nelse\nif\n(A[i] > tailTable[len - \n1\n]) \n\n// A[i] wants to extend largest subsequence \n\ntailTable[len++] = A[i]; \n\n\nelse\n\n// A[i] wants to be current end candidate of an existing \n\n// subsequence. It will replace ceil value in tailTable \n\ntailTable[CeilIndex(tailTable, -\n1\n, len - \n1\n, A[i])] = A[i]; \n\n} \n\n\nreturn\nlen; \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n2\n, \n5\n, \n3\n, \n7\n, \n11\n, \n8\n, \n10\n, \n13\n, \n6\n}; \n\nint\nn = A.length; \n\nSystem.out.println(\n\"Length of Longest Increasing Subsequence is \"\n+ LongestIncreasingSubsequenceLength(A, n)); \n\n} \n} \n/* This code is contributed by Devesh Agrawal*/", "complexity": "nlogn", "from": "CorCod", "problem": 700, "index": 700}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.System.out;\n\npublic class Main {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n    private List<Integer>[] gr = new ArrayList[1000_000+5];\n    private int dp[][] = new int[21][1000_000+5];\n    private boolean used[] = new boolean[1000_000+5];\n\n    void init(int v, int p) {\n        Stack<Integer> st = new Stack<>();\n        st.push(v);\n        st.push(p);\n        while (!st.isEmpty()) {\n            p = st.pop();\n            v = st.pop();\n            used[v] = true;\n\n            dp[0][v] =  p;\n            for (int i = 1; i <= 20; i++) {\n                if (dp[i - 1][v] != -1) {\n                    dp[i][v] = dp[i - 1][dp[i - 1][v]];\n                }\n            }\n\n            for (int next : gr[v]) {\n                if (!used[next]) {\n                    st.push(next);\n                    st.push(v);\n                }\n            }\n\n        }\n    }\n\n\n    private void solve() {\n        int n = scanner.nextInt(), k = scanner.nextInt();\n        boolean[] ans = new boolean[1000_000 + 5];\n\n        for (int i = 0; i < n; i++) {\n            gr[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < n - 1; i ++) {\n            int u = scanner.nextInt() - 1, v = scanner.nextInt() - 1;\n            gr[u].add(v);\n            gr[v].add(u);\n        }\n\n        k = n - k - 1;\n        ans[n - 1] = true;\n\n        init(n - 1 , n - 1);\n\n        int t, d, next;\n        for (int i = n - 2; i >= 0; i--) {\n            t = i;\n            d = 1;\n            if (ans[i]) {\n                continue;\n            }\n            for (int j = 20; j >= 0; j--){\n                next = dp[j][t];\n                if (next != -1 && !ans[next]) {\n                    t = next;\n                    d +=  1 << j;\n                }\n            }\n\n            if (d <= k) {\n                k -=d;\n                t = i;\n\n                while (!ans[t]) {\n                    ans[t] = true;\n                    t = dp[0][t];\n                }\n            }\n            if (k == 0) {\n                break;\n            }\n        }\n        StringBuilder sb = new StringBuilder(\"\");\n        for (int i = 0; i < n; i++) {\n            if (!ans[i]) {\n                sb.append(i + 1).append(\" \");\n            }\n        }\n        System.out.println(sb.toString());\n    }\n\n    class FastScanner {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 701, "index": 701}
{"src": "\n// Java code to count the change required to \n// convert the array into non-increasing array \nimport\njava.util.PriorityQueue; \n\nclass\nGFG \n{ \n\npublic\nstatic\nint\nDecreasingArray(\nint\na[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n, dif = \n0\n; \n\n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<>(); \n\n\n// Here in the loop we will \n\n// check that whether the upcoming \n\n// element of array is less than top \n\n// of priority queue. If yes then we \n\n// calculate the difference. After \n\n// that we will remove that element \n\n// and push the current element in \n\n// queue. And the sum is incremented \n\n// by the value of difference \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(!pq.isEmpty() && pq.element() < a[i]) \n\n{ \n\ndif = a[i] - pq.element(); \n\nsum += dif; \n\npq.remove(); \n\npq.add(a[i]); \n\n} \n\npq.add(a[i]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] a = {\n3\n, \n1\n, \n2\n, \n1\n}; \n\n\nint\nn = a.length; \n\n\nSystem.out.println(DecreasingArray(a, n)); \n\n} \n} \n\n// This Code is contributed by sanjeev2552 ", "complexity": "nlogn", "from": "CorCod", "problem": 702, "index": 702}
{"src": "\n// Java implementation of smallest difference \n// triplet \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n\n// function to find maximum number \n\nstatic\nint\nmaximum(\nint\na, \nint\nb, \nint\nc) \n\n{ \n\nreturn\nMath.max(Math.max(a, b), c); \n\n} \n\n\n// function to find minimum number \n\nstatic\nint\nminimum(\nint\na, \nint\nb, \nint\nc) \n\n{ \n\nreturn\nMath.min(Math.min(a, b), c); \n\n} \n\n\n// Finds and prints the smallest Difference \n\n// Triplet \n\nstatic\nvoid\nsmallestDifferenceTriplet(\nint\narr1[], \n\nint\narr2[], \nint\narr3[], \nint\nn) \n\n{ \n\n\n// sorting all the three arrays \n\nArrays.sort(arr1); \n\nArrays.sort(arr2); \n\nArrays.sort(arr3); \n\n\n// To store resultant three numbers \n\nint\nres_min=\n0\n, res_max=\n0\n, res_mid=\n0\n; \n\n\n// pointers to arr1, arr2, arr3 \n\n// respectively \n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n// Loop until one array reaches to its end \n\n// Find the smallest difference. \n\nint\ndiff = \n2147483647\n; \n\n\nwhile\n(i < n && j < n && k < n) \n\n{ \n\nint\nsum = arr1[i] + arr2[j] + arr3[k]; \n\n\n// maximum number \n\nint\nmax = maximum(arr1[i], arr2[j], arr3[k]); \n\n\n// Find minimum and increment its index. \n\nint\nmin = minimum(arr1[i], arr2[j], arr3[k]); \n\nif\n(min == arr1[i]) \n\ni++; \n\nelse\nif\n(min == arr2[j]) \n\nj++; \n\nelse\n\nk++; \n\n\n// comparing new difference with the \n\n// previous one and updating accordingly \n\nif\n(diff > (max - min)) \n\n{ \n\ndiff = max - min; \n\nres_max = max; \n\nres_mid = sum - (max + min); \n\nres_min = min; \n\n} \n\n} \n\n\n// Print result \n\nSystem.out.print(res_max + \n\", \"\n+ res_mid \n\n+ \n\", \"\n+ res_min); \n\n} \n\n\n//driver code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\narr1[] = {\n5\n, \n2\n, \n8\n}; \n\nint\narr2[] = {\n10\n, \n7\n, \n12\n}; \n\nint\narr3[] = {\n9\n, \n14\n, \n6\n}; \n\n\nint\nn = arr1.length; \n\n\nsmallestDifferenceTriplet(arr1, arr2, arr3, n); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "complexity": "nlogn", "from": "CorCod", "problem": 703, "index": 703}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        HashMap<Integer, Integer> map = new HashMap<>();\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            int x = Integer.parseInt(st.nextToken());\n            arr[i] = x;\n            if (!map.containsKey(x)) {\n                map.put(x, 1);\n            } else {\n                map.replace(x, map.get(x) + 1);\n            }\n        }\n        int[] power = new int[31];\n        for (int i = 0; i < 31; i++) {\n            power[i] = 1 << i; // 0 100=4 1000=8 10000=16\n        }\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n        boolean f = false;\n        for (int j = 0; j <= 30; j++) {\n        int check = power[j] - arr[i];\n                if ((map.containsKey(check) && check != arr[i])) {\n                f = true; break;}\n                if((map.containsKey(check) && check == arr[i] && map.get(check) >=2)) {\n                    f = true; break;\n                }\n            }\n            if (!f) {\n                c++;\n            }\n        }\n        System.out.println(c);\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 704, "index": 704}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Sol {\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tInteger[] a = new Integer[n*k];\n\t\tfor(int i = 0; i < n*k; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tif (a[n - 1] - a[0] > l) {\n\t\t\tout.println(0);\n\t\t} else {\n\t\t\tint maxPos = n*k - 1;\n\t\t\tfor (int i = 0; i < n*k; i++) {\n\t\t\t\tif (a[i] - a[0] > l) {\n\t\t\t\t\tmaxPos = i-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong o = a[0];\n\t\t\tint s = 0;\n\t\t\tint t = 1;\n\t\t\tfor (int i = 1; i <= maxPos; i++) {\n\t\t\t\t//System.out.print(a[i]);\n\t\t\t\tif (s < k - 1 && maxPos-i+1 > n-t) {\n\t\t\t\t\t//System.out.println(\" @\");\n\t\t\t\t\ts++;\n\t\t\t\t} else {\n\t\t\t\t\t//System.out.println(\" #\");\n\t\t\t\t\ts = 0;\n\t\t\t\t\tt++;\n\t\t\t\t\to += a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(o);\n\t\t}\n\t\tout.close();\n\t}\n\n\t// -----------PrintWriter for faster output-------------\n\tpublic static PrintWriter out;\n\n\t// -----------MyScanner class for faster input----------\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t}\n\t// --------------------------------------------------------\n}", "complexity": "nlogn", "from": "CorCod", "problem": 705, "index": 705}
{"src": "\n\nimport java.util.Scanner;\n\npublic class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             // System.out.println(\"For fuel:\" + mid + \" isValid: \" + v + \", max:\" + max + \", min:\" + min);\n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 //System.out.println(\"max: \" + max + \" , min:\" + min);\n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        //System.out.println(found);\n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 706, "index": 706}
{"src": "\nimport\njava.util.PriorityQueue; \nimport\njava.util.Scanner; \nimport\njava.util.Comparator; \n\n// node class is the basic structure \n// of each node present in the Huffman - tree. \nclass\nHuffmanNode { \n\n\nint\ndata; \n\nchar\nc; \n\n\nHuffmanNode left; \n\nHuffmanNode right; \n} \n\n// comparator class helps to compare the node \n// on the basis of one of its attribute. \n// Here we will be compared \n// on the basis of data values of the nodes. \nclass\nMyComparator \nimplements\nComparator<HuffmanNode> { \n\npublic\nint\ncompare(HuffmanNode x, HuffmanNode y) \n\n{ \n\n\nreturn\nx.data - y.data; \n\n} \n} \n\npublic\nclass\nHuffman { \n\n\n// recursive function to print the \n\n// huffman-code through the tree traversal. \n\n// Here s is the huffman - code generated. \n\npublic\nstatic\nvoid\nprintCode(HuffmanNode root, String s) \n\n{ \n\n\n// base case; if the left and right are null \n\n// then its a leaf node and we print \n\n// the code s generated by traversing the tree. \n\nif\n(root.left \n\n== \nnull\n\n&& root.right \n\n== \nnull\n\n&& Character.isLetter(root.c)) { \n\n\n// c is the character in the node \n\nSystem.out.println(root.c + \n\":\"\n+ s); \n\n\nreturn\n; \n\n} \n\n\n// if we go to left then add \"0\" to the code. \n\n// if we go to the right add\"1\" to the code. \n\n\n// recursive calls for left and \n\n// right sub-tree of the generated tree. \n\nprintCode(root.left, s + \n\"0\"\n); \n\nprintCode(root.right, s + \n\"1\"\n); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nScanner s = \nnew\nScanner(System.in); \n\n\n// number of characters. \n\nint\nn = \n6\n; \n\nchar\n[] charArray = { \n'a'\n, \n'b'\n, \n'c'\n, \n'd'\n, \n'e'\n, \n'f'\n}; \n\nint\n[] charfreq = { \n5\n, \n9\n, \n12\n, \n13\n, \n16\n, \n45\n}; \n\n\n// creating a priority queue q. \n\n// makes a min-priority queue(min-heap). \n\nPriorityQueue<HuffmanNode> q \n\n= \nnew\nPriorityQueue<HuffmanNode>(n, \nnew\nMyComparator()); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// creating a Huffman node object \n\n// and add it to the priority queue. \n\nHuffmanNode hn = \nnew\nHuffmanNode(); \n\n\nhn.c = charArray[i]; \n\nhn.data = charfreq[i]; \n\n\nhn.left = \nnull\n; \n\nhn.right = \nnull\n; \n\n\n// add functions adds \n\n// the huffman node to the queue. \n\nq.add(hn); \n\n} \n\n\n// create a root node \n\nHuffmanNode root = \nnull\n; \n\n\n// Here we will extract the two minimum value \n\n// from the heap each time until \n\n// its size reduces to 1, extract until \n\n// all the nodes are extracted. \n\nwhile\n(q.size() > \n1\n) { \n\n\n// first min extract. \n\nHuffmanNode x = q.peek(); \n\nq.poll(); \n\n\n// second min extarct. \n\nHuffmanNode y = q.peek(); \n\nq.poll(); \n\n\n// new node f which is equal \n\nHuffmanNode f = \nnew\nHuffmanNode(); \n\n\n// to the sum of the frequency of the two nodes \n\n// assigning values to the f node. \n\nf.data = x.data + y.data; \n\nf.c = \n'-'\n; \n\n\n// first extracted node as left child. \n\nf.left = x; \n\n\n// second extracted node as the right child. \n\nf.right = y; \n\n\n// marking the f node as the root node. \n\nroot = f; \n\n\n// add this node to the priority-queue. \n\nq.add(f); \n\n} \n\n\n// print the codes by traversing the tree \n\nprintCode(root, \n\"\"\n); \n\n} \n} \n\n// This code is contributed by Kunwar Desh Deepak Singh ", "complexity": "nlogn", "from": "CorCod", "problem": 707, "index": 707}
{"src": "\n// Java code for k largest elements in an array \nimport\njava.util.Arrays; \nimport\njava.util.Collections; \n\nclass\nGFG { \n\npublic\nstatic\nvoid\nkLargest(Integer[] arr, \nint\nk) \n\n{ \n\n// Sort the given array arr in reverse order \n\n// This method doesn't work with primitive data \n\n// types. So, instead of int, Integer type \n\n// array will be used \n\nArrays.sort(arr, Collections.reverseOrder()); \n\n\n// Print the first kth largest elements \n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[] { \n1\n, \n23\n, \n12\n, \n9\n, \n\n30\n, \n2\n, \n50\n}; \n\nint\nk = \n3\n; \n\nkLargest(arr, k); \n\n} \n} \n// This code is contributed by Kamal Rawal ", "complexity": "nlogn", "from": "CorCod", "problem": 708, "index": 708}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n             \n            int n=sc.nextInt();\n            long s=sc.nextLong();\n            long arr[]=new long[n];\n            int i=0;\n            for(i=0;i<n;i++)\n            {\n                              arr[i]=sc.nextLong();\n            }\n            Arrays.sort(arr);\n            \n            /*for(i=0;i<n;i++)\n            {\n                              w.println(arr[i]);\n            }*/\n            long count=0;\n            if(arr[n/2]==s)\n            {\n                              \n                              w.print(0);\n            }\n            else\n            {\n                              int temp=n/2;\n                              \n                              if(arr[temp]>s)\n                              {\n                                                while(arr[temp]>s)\n                                                {\n                                                                  count=count+(arr[temp]-s);\n                                                                  temp--;\n                                                                  if(temp<0)\n                                                                  {\n                                                                                    break;\n                                                                  }\n                                                }\n                              }\n                              else\n                              {\n                                               \n                                               while(arr[temp]<s)\n                                               {\n                                                                 \n                                                                 count=count+(s-arr[temp]);\n                                                                 temp++;\n                                                                 if(temp>=n)\n                                                                 {\n                                                                                   break;\n                                                                 }\n                                               }\n                              }\n                              w.print(count);\n            }\n            \n               \n               \n\n        w.close();\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 709, "index": 709}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        InputReader.OutputWriter out = new InputReader.OutputWriter(outputStream);\n\n\n        int n = in.nextInt();\n        int s = in.nextInt();\n        Lift [] lifts = new Lift[n];\n        for (int i = 0; i < n; i++) {\n            lifts[i] = new Lift(in.nextInt(),in.nextInt());\n        }\n        Arrays.sort(lifts,(x,y)->y.getLevel() - x.getLevel());\n        \n        int ans = 0;\n        for (int i = 0; i < lifts.length; i++) {\n            Lift current = lifts[i];\n            ans+=s-current.getLevel();\n            if(current.getTime()>ans) {\n                ans+=current.getTime() - ans;\n            }\n            s = current.getLevel();\n        }\n        ans+=s;\n        out.println(ans);\n        out.flush();\n    }\n}\n\nclass Lift {\n\n    int level;\n    int time;\n\n    public int getLevel() {\n        return level;\n    }\n\n    public int getTime() {\n        return time;\n    }\n\n    public Lift(int level, int time) {\n        this.level = level;\n        this.time = time;\n    }\n}\n\nclass InputReader extends BufferedReader {\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n        super(new InputStreamReader(inputStream), 32768);\n    }\n\n    public InputReader(String filename) {\n        super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(readLine());\n            } catch (IOException e) {\n                throw new RuntimeException();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public Integer nextInt() {\n        return Integer.valueOf(next());\n    }\n    public Long nextLong() {return  Long.valueOf(next());}\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 710, "index": 710}
{"src": "\nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n// Variables to keep track of current sum and minimum sum \n\nint\nsum, min_sum = \n999999\n; \n\n\n// left and right index variables \n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n// variable to keep track of the left and right pair for min_sum \n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n/* Array should have at least two elements*/\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n/* Sort the elements */\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n/*If abs(sum) is less then update the result items*/\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n/* Functions for QuickSort */\n\n\n/* This function takes last element as pivot, \n\nplaces the pivot element at its correct \n\nposition in sorted array, and places all \n\nsmaller (smaller than pivot) to left of \n\npivot and all greater elements to right \n\nof pivot */\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n// index of smaller element \n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n// If current element is smaller than or \n\n// equal to pivot \n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n// swap arr[i] and arr[j] \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n// swap arr[i+1] and arr[high] (or pivot) \n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n/* The main function that implements QuickSort() \n\narr[] --> Array to be sorted, \n\nlow --> Starting index, \n\nhigh --> Ending index */\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n/* pi is partitioning index, arr[pi] is \n\nnow at right place */\n\nint\npi = partition(arr, low, high); \n\n\n// Recursively sort elements before \n\n// partition and after partition \n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n} ", "complexity": "nlogn", "from": "CorCod", "problem": 711, "index": 711}
{"src": "\n\nimport java.util.Scanner;\n\npublic class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             // System.out.println(\"For fuel:\" + mid + \" isValid: \" + v + \", max:\" + max + \", min:\" + min);\n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 //System.out.println(\"max: \" + max + \" , min:\" + min);\n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        //System.out.println(found);\n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 712, "index": 712}
{"src": "\n// Java program to find minimum difference between \n// any pair in an unsorted array \n\nimport\njava.util.Arrays; \n\nclass\nGFG \n{ \n\n// Returns minimum difference between any pair \n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n// Sort array in non-decreasing order \n\nArrays.sort(arr); \n\n\n// Initialize difference as infinite \n\nint\ndiff = Integer.MAX_VALUE; \n\n\n// Find the min diff by comparing adjacent \n\n// pairs in sorted array \n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nif\n(arr[i+\n1\n] - arr[i] < diff) \n\ndiff = arr[i+\n1\n] - arr[i]; \n\n\n// Return min diff \n\nreturn\ndiff; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n} ", "complexity": "nlogn", "from": "CorCod", "problem": 713, "index": 713}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class Main {\n\tprivate static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tString[] s = br.readLine().trim().split(\" \");\n\t\tint n = Integer.parseInt(s[0]);\n\t\tint m = Integer.parseInt(s[1]);\n\t\tlong b[] = new long[n];\n\t\ts = br.readLine().trim().split(\" \");\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tb[i] = Integer.parseInt(s[i]);\n\t\t}\n\t\tlong g[] = new long[m];\n\t\ts = br.readLine().trim().split(\" \");\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tg[i] = Integer.parseInt(s[i]);\n\t\t}\n\t\tArrays.sort(b);\n\t\tArrays.sort(g);\n\t\tif(g[0] < b[n-1]) {\n\t\t\tSystem.out.println(\"-1\");\n\t\t}\n\t\telse if(g[0] == b[n-1]){\n\t\t\tlong ans = 0;\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tans += g[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < n-1; i++) {\n\t\t\t\tans += (m)*b[i];\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t\telse {\n\t\t\tlong ans = 0;\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tans += g[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < n-1; i++) {\n\t\t\t\tans += (m)*b[i];\n\t\t\t}\n\t\t\tans += b[n-1]-b[n-2];\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n}", "complexity": "nlogn", "from": "CorCod", "problem": 714, "index": 714}
{"src": "\n// Java program to find maximum height pyramid \n// from the given object width. \nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n\n// Returns maximum number of pyramidcal \n\n// levels n boxes of given widths. \n\nstatic\nint\nmaxLevel(\nint\n[]boxes, \nint\nn) \n\n{ \n\n\n// Sort objects in increasing order \n\n// of widths \n\nArrays.sort(boxes); \n\n\nint\nans = \n1\n; \n// Initialize result \n\n\n// Total width of previous level \n\n// and total number of objects in \n\n// previous level \n\nint\nprev_width = boxes[\n0\n]; \n\nint\nprev_count = \n1\n; \n\n\n// Number of object in current \n\n// level. \n\nint\ncurr_count = \n0\n; \n\n\n// Width of current level. \n\nint\ncurr_width = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n// Picking the object. So \n\n// increase current width \n\n// and number of object. \n\ncurr_width += boxes[i]; \n\ncurr_count += \n1\n; \n\n\n// If current width and \n\n// number of object \n\n// are greater than previous. \n\nif\n(curr_width > prev_width && \n\ncurr_count > prev_count) \n\n{ \n\n\n// Update previous width, \n\n// number of object on \n\n// previous level. \n\nprev_width = curr_width; \n\nprev_count = curr_count; \n\n\n// Reset width of current \n\n// level, number of object \n\n// on current level. \n\ncurr_count = \n0\n; \n\ncurr_width = \n0\n; \n\n\n// Increment number of \n\n// level. \n\nans++; \n\n} \n\n} \n\n\nreturn\nans; \n\n} \n\n\n// Driver Program \n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]boxes = {\n10\n, \n20\n, \n30\n, \n50\n, \n60\n, \n70\n}; \n\nint\nn = boxes.length; \n\nSystem.out.println(maxLevel(boxes, n)); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "complexity": "nlogn", "from": "CorCod", "problem": 715, "index": 715}
{"src": "\n// Java program to connect n ropes with minimum cost \n\n// A class for Min Heap \nclass\nMinHeap { \n\nint\n[] harr; \n// Array of elements in heap \n\nint\nheap_size; \n// Current number of elements in min heap \n\nint\ncapacity; \n// maximum possible size of min heap \n\n\n// Constructor: Builds a heap from \n\n// a given array a[] of given size \n\npublic\nMinHeap(\nint\na[], \nint\nsize) \n\n{ \n\nheap_size = size; \n\ncapacity = size; \n\nharr = a; \n\nint\ni = (heap_size - \n1\n) / \n2\n; \n\nwhile\n(i >= \n0\n) { \n\nMinHeapify(i); \n\ni--; \n\n} \n\n} \n\n\n// A recursive method to heapify a subtree \n\n// with the root at given index \n\n// This method assumes that the subtrees \n\n// are already heapified \n\nvoid\nMinHeapify(\nint\ni) \n\n{ \n\nint\nl = left(i); \n\nint\nr = right(i); \n\nint\nsmallest = i; \n\nif\n(l < heap_size && harr[l] < harr[i]) \n\nsmallest = l; \n\nif\n(r < heap_size && harr[r] < harr[smallest]) \n\nsmallest = r; \n\nif\n(smallest != i) { \n\nswap(i, smallest); \n\nMinHeapify(smallest); \n\n} \n\n} \n\n\nint\nparent(\nint\ni) { \nreturn\n(i - \n1\n) / \n2\n; } \n\n\n// to get index of left child of node at index i \n\nint\nleft(\nint\ni) { \nreturn\n(\n2\n* i + \n1\n); } \n\n\n// to get index of right child of node at index i \n\nint\nright(\nint\ni) { \nreturn\n(\n2\n* i + \n2\n); } \n\n\n// Method to remove minimum element (or root) from min heap \n\nint\nextractMin() \n\n{ \n\nif\n(heap_size <= \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\nif\n(heap_size == \n1\n) { \n\nheap_size--; \n\nreturn\nharr[\n0\n]; \n\n} \n\n\n// Store the minimum value, and remove it from heap \n\nint\nroot = harr[\n0\n]; \n\nharr[\n0\n] = harr[heap_size - \n1\n]; \n\nheap_size--; \n\nMinHeapify(\n0\n); \n\n\nreturn\nroot; \n\n} \n\n\n// Inserts a new key 'k' \n\nvoid\ninsertKey(\nint\nk) \n\n{ \n\nif\n(heap_size == capacity) { \n\nSystem.out.println(\n\"Overflow: Could not insertKey\"\n); \n\nreturn\n; \n\n} \n\n\n// First insert the new key at the end \n\nheap_size++; \n\nint\ni = heap_size - \n1\n; \n\nharr[i] = k; \n\n\n// Fix the min heap property if it is violated \n\nwhile\n(i != \n0\n&& harr[parent(i)] > harr[i]) { \n\nswap(i, parent(i)); \n\ni = parent(i); \n\n} \n\n} \n\n\n// A utility function to check \n\n// if size of heap is 1 or not \n\nboolean\nisSizeOne() \n\n{ \n\nreturn\n(heap_size == \n1\n); \n\n} \n\n\n// A utility function to swap two elements \n\nvoid\nswap(\nint\nx, \nint\ny) \n\n{ \n\nint\ntemp = harr[x]; \n\nharr[x] = harr[y]; \n\nharr[y] = temp; \n\n} \n\n\n// The main function that returns the \n\n// minimum cost to connect n ropes of \n\n// lengths stored in len[0..n-1] \n\nstatic\nint\nminCost(\nint\nlen[], \nint\nn) \n\n{ \n\nint\ncost = \n0\n; \n// Initialize result \n\n\n// Create a min heap of capacity equal \n\n// to n and put all ropes in it \n\nMinHeap minHeap = \nnew\nMinHeap(len, n); \n\n\n// Iterate while size of heap doesn't become 1 \n\nwhile\n(!minHeap.isSizeOne()) { \n\n// Extract two minimum length ropes from min heap \n\nint\nmin = minHeap.extractMin(); \n\nint\nsec_min = minHeap.extractMin(); \n\n\ncost += (min + sec_min); \n// Update total cost \n\n\n// Insert a new rope in min heap with length equal to sum \n\n// of two extracted minimum lengths \n\nminHeap.insertKey(min + sec_min); \n\n} \n\n\n// Finally return total minimum \n\n// cost for connecting all ropes \n\nreturn\ncost; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nlen[] = { \n4\n, \n3\n, \n2\n, \n6\n}; \n\nint\nsize = len.length; \n\n\nSystem.out.println(\n\"Total cost for connecting ropes is \"\n+ minCost(len, size)); \n\n} \n}; \n\n// This code is contributed by shubham96301 ", "complexity": "nlogn", "from": "CorCod", "problem": 716, "index": 716}
{"src": "\n// Java program to calculate max_difference between \n// the sum of two subarrays of length k and N - k \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// Function to calculate max_difference \nstatic\nint\nmaxDifference(\nint\narr[], \nint\nN, \nint\nk) \n{ \n\nint\nM, S = \n0\n, S1 = \n0\n, max_difference = \n0\n; \n\n\n// Sum of the array \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nS += arr[i]; \n\nint\ntemp; \n\n\n// Sort the array in descending order \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\n{ \n\nif\n(arr[i] < arr[j]) \n\n{ \n\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n} \n\n\nM = Math.max(k, N - k); \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nS1 += arr[i]; \n\n\n// Calculating max_difference \n\nmax_difference = S1 - (S - S1); \n\nreturn\nmax_difference; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n8\n, \n4\n, \n5\n, \n2\n, \n10\n}; \n\nint\nN = arr.length; \n\nint\nk = \n2\n; \n\nSystem.out.println(maxDifference(arr, N, k)); \n} \n} \n\n// This code is contributed by \n// Surendra_Gangwar ", "complexity": "nlogn", "from": "CorCod", "problem": 717, "index": 717}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\npublic class gr1 {\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card{\n        long a;\n        int cnt;\n        int i;\n        public card(long a,int cnt,int i)\n        {\n            this.a=a;\n            this.cnt=cnt;\n            this.i=i;\n        }\n    }\n\n    static class ascend implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.b!=o2.b)\n                return (int)(o1.b-o2.b);\n            else \n                return (int)(o1.a-o2.a);\n        }\n    }\n\n    /*static class descend implements Comparator<pair>\n    {\n    public int compare(pair o1,pair o2)\n    {\n    if(o1.a!=o2.a){\n    return (o1.a-o2.a)*-1;\n    } else {\n    return (o1.b-o2.b);\n    }\n    }\n    }*/\n\n    static class extra\n    {\n\n        static void shuffle(long a[])\n        {\n            List<Long> l=new ArrayList<>();\n            for(int i=0;i<a.length;i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for(int i=0;i<a.length;i++)\n                a[i]=l.get(i);\n        }\n\n        static long gcd(long a,long b)\n        {\n            if(b==0)\n                return a;\n            else\n                return gcd(b,a%b);\n        }\n\n        static boolean valid(int i,int j,int r,int c)\n        {\n            if(i>=0 && i<r && j>=0 && j<c)\n                return true;\n            else\n                return false;\n        }\n\n        static boolean v[]=new boolean[100001];\n        static List<Integer> l=new ArrayList<>();\n        static int t;\n        static void seive()\n        {\n            for(int i=2;i<100001;i++)\n            {\n                if(!v[i])\n                {\n                    t++;\n                    l.add(i);\n                    for(int j=2*i;j<100001;j+=i)\n                        v[j]=true;\n                }\n            }\n        }\n\n        static int binary(pair a[],int val,int n)\n        {\n            int mid=0,l=0,r=n-1,ans=0;\n            while(l<=r)\n            {\n                mid=(l+r)>>1;\n                if(a[mid].a==val)\n                {\n                    r=mid-1;\n                    ans=mid;\n                }\n                else if(a[mid].a>val)\n                    r=mid-1;\n                else\n                {\n                    l=mid+1;\n                    ans=l;\n                }\n            }\n            return (ans);\n        }\n    }\n\n    static class pair{\n        long a;\n        int b;\n        public pair(long a,int n)\n        {\n            this.a=a;\n            this.b=n;\n        }\n    }\n    static InputReader sc=new InputReader(System.in);\n    static PrintWriter out=new PrintWriter(System.out);\n    public static void main(String[] args) {\n        solver s=new solver();\n        int t=1;\n        while(t>0)\n        {\n            s.solve();\n            t--;\n        }\n    }\n    static class solver\n    {\n        void solve()\n        {\n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int sum=0;\n            for(int i=0;i<n;i++)\n            {\n                a[i]=sc.nextInt();\n                sum+=a[i];\n            }\n            Arrays.sort(a);\n            int k=(int)Math.round(4.5*n)-sum;\n           // System.out.println((int)Math.round(4.5*n)+\" \"+k+\" \"+sum);\n            if(k<=0)\n            {\n                System.out.println(0);\n            }\n            else\n            {\n                int p=0,ans=0;\n                for(int i=0;i<n;i++)\n                {\n                    if(a[i]!=5)\n                    {\n                        p+=5-a[i];\n                        if(p>=k){\n                            ans++;\n                            System.out.println(ans);\n                            break;\n                        }\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 718, "index": 718}
{"src": "\n// Java program to find minimum \n// difference between groups of \n// highest and lowest sums. \nimport\njava.util.Arrays; \nimport\njava.util.Collections; \nimport\njava.util.Vector; \n\n\nclass\nGFG { \n\nstatic\nlong\ncalculate(\nlong\na[], \nint\nn) \n{ \n\n// Sorting the whole array. \n\nArrays.sort(a); \n\nint\ni,j; \n\n\n// Generating sum groups. \n\nVector<Long> s = \nnew\nVector<>(); \n\nfor\n(i = \n0\n, j = n - \n1\n; i < j; i++, j--) \n\ns.add((a[i] + a[j])); \n\n\nlong\nmini = Collections.min(s); \n\nlong\nmaxi = Collections.max(s); \n\nreturn\nMath.abs(maxi - mini); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nlong\na[] = { \n2\n, \n6\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(calculate(a, n)); \n\n} \n} \n// This code is contributed by 29AjayKumar ", "complexity": "nlogn", "from": "CorCod", "problem": 719, "index": 719}
{"src": "\n// Java program to implement merge sort in singly linked list \n\n// Linked List Class \nclass\nLinkedList { \n\n\nstatic\nNode head; \n// head of list \n\n\n/* Node Class */\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next, prev; \n\n\n// Constructor to create a new node \n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\nvoid\nprint(Node node) { \n\nNode temp = node; \n\nSystem.out.println(\n\"Forward Traversal using next pointer\"\n); \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\ntemp = node; \n\nnode = node.next; \n\n} \n\nSystem.out.println(\n\"\\nBackward Traversal using prev pointer\"\n); \n\nwhile\n(temp != \nnull\n) { \n\nSystem.out.print(temp.data + \n\" \"\n); \n\ntemp = temp.prev; \n\n} \n\n} \n\n\n// Split a doubly linked list (DLL) into 2 DLLs of \n\n// half sizes \n\nNode split(Node head) { \n\nNode fast = head, slow = head; \n\nwhile\n(fast.next != \nnull\n&& fast.next.next != \nnull\n) { \n\nfast = fast.next.next; \n\nslow = slow.next; \n\n} \n\nNode temp = slow.next; \n\nslow.next = \nnull\n; \n\nreturn\ntemp; \n\n} \n\n\nNode mergeSort(Node node) { \n\nif\n(node == \nnull\n|| node.next == \nnull\n) { \n\nreturn\nnode; \n\n} \n\nNode second = split(node); \n\n\n// Recur for left and right halves \n\nnode = mergeSort(node); \n\nsecond = mergeSort(second); \n\n\n// Merge the two sorted halves \n\nreturn\nmerge(node, second); \n\n} \n\n\n// Function to merge two linked lists \n\nNode merge(Node first, Node second) { \n\n// If first linked list is empty \n\nif\n(first == \nnull\n) { \n\nreturn\nsecond; \n\n} \n\n\n// If second linked list is empty \n\nif\n(second == \nnull\n) { \n\nreturn\nfirst; \n\n} \n\n\n// Pick the smaller value \n\nif\n(first.data < second.data) { \n\nfirst.next = merge(first.next, second); \n\nfirst.next.prev = first; \n\nfirst.prev = \nnull\n; \n\nreturn\nfirst; \n\n} \nelse\n{ \n\nsecond.next = merge(first, second.next); \n\nsecond.next.prev = second; \n\nsecond.prev = \nnull\n; \n\nreturn\nsecond; \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n30\n); \n\nlist.head.next.next = \nnew\nNode(\n3\n); \n\nlist.head.next.next.next = \nnew\nNode(\n4\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n20\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n5\n); \n\n\n\nNode node = \nnull\n; \n\nnode = list.mergeSort(head); \n\nSystem.out.println(\n\"Linked list after sorting :\"\n); \n\nlist.print(node); \n\n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "complexity": "nlogn", "from": "CorCod", "problem": 720, "index": 720}
{"src": "\n// Java code for kth smallest element \n// in an array \nimport\njava.util.Arrays; \nimport\njava.util.Collections; \n\nclass\nGFG \n{ \n\n// Function to return k'th smallest \n\n// element in a given array \n\npublic\nstatic\nint\nkthSmallest(Integer [] arr, \n\nint\nk) \n\n{ \n\n// Sort the given array \n\nArrays.sort(arr); \n\n\n// Return k'th element in \n\n// the sorted array \n\nreturn\narr[k-\n1\n]; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[]{\n12\n, \n3\n, \n5\n, \n7\n, \n19\n}; \n\nint\nk = \n2\n; \n\nSystem.out.print( \n\"K'th smallest element is \"\n+ \n\nkthSmallest(arr, k) ); \n\n} \n} \n\n// This code is contributed by Chhavi ", "complexity": "nlogn", "from": "CorCod", "problem": 721, "index": 721}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        int n = scanner.nextInt();\n\n\n        int a[][] = new int[n][3];\n\n        for (int i = 0; i < n; i++) {\n            a[i][0] = scanner.nextInt();\n            a[i][1] = scanner.nextInt();\n            a[i][2] = i;\n        }\n\n        int l = -1, r = -1;\n\n        Arrays.sort(a, (o1, o2) -> {\n            if (o1[0] != o2[0]) {\n                return o1[0] - o2[0];\n            } else {\n                return o2[1] - o1[1];\n            }\n        });\n\n        int maxr = -1, maxi = -1;\n        for (int i = 0; i < n; i++) {\n            if (a[i][1] <= maxr) {\n                l = a[i][2] + 1;\n                r = maxi + 1;\n                break;\n            }\n            if (a[i][1] > maxr) {\n                maxi = a[i][2];\n                maxr = a[i][1];\n            }\n        }\n\n        System.out.println(l + \" \" + r);\n\n\n    }\n\n    boolean check(int cnt[][], int[] tcnt, int mid) {\n        boolean ok = true;\n\n        for (int j = 0; j < 27; j++) {\n            if (cnt[mid][j] < tcnt[j]) {\n                ok = false;\n            }\n        }\n        return ok;\n    }\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 722, "index": 722}
{"src": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tSolution solution = new Solution();\n\t\tSystem.out.println(solution.solve());\n\t}\n\n\tprivate int solve() {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\n\t\tint[] a = new int[m];\n\t\tfor (int i = 0; i < m; ++i) a[i] = in.nextInt();\n\n\t\tif (n > m) return 0;\n\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int k: a) map.put(k, map.getOrDefault(k, 0) + 1);\n\n\t\tList<Integer> keySet = new ArrayList<>(map.keySet());\n\t\tint end = m / n;\n\n\t\tkeySet.sort((u, v) -> -Integer.compare(u, v));\n\t\tdo {\n\t\t\tint count = 0;\n\t\t\tfor (int k: keySet) {\n\t\t\t\tcount += map.get(k) / end;\n\t\t\t\tif (count >= n) return end;\n\t\t\t}\n\t\t} while (--end > 0);\n\n\t\treturn 0;\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 723, "index": 723}
{"src": "\n// Java program to find minimum sum of two numbers \n// formed from all digits in a given array. \nimport\njava.util.PriorityQueue; \n\nclass\nMinSum \n{ \n\n// Returns sum of two numbers formed \n\n// from all digits in a[] \n\npublic\nstatic\nlong\nsolve(\nint\n[] a) \n\n{ \n\n// min Heap \n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<Integer>(); \n\n\n// to store the 2 numbers formed by array elements to \n\n// minimize the required sum \n\nStringBuilder num1 = \nnew\nStringBuilder(); \n\nStringBuilder num2 = \nnew\nStringBuilder(); \n\n\n// Adding elements in Priority Queue \n\nfor\n(\nint\nx : a) \n\npq.add(x); \n\n\n// checking if the priority queue is non empty \n\nwhile\n(!pq.isEmpty()) \n\n{ \n\nnum1.append(pq.poll()+ \n\"\"\n); \n\nif\n(!pq.isEmpty()) \n\nnum2.append(pq.poll()+ \n\"\"\n); \n\n} \n\n\n// the required sum calculated \n\nlong\nsum = Long.parseLong(num1.toString()) + \n\nLong.parseLong(num2.toString()); \n\n\nreturn\nsum; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n6\n, \n8\n, \n4\n, \n5\n, \n2\n, \n3\n}; \n\nSystem.out.println(\n\"The required sum is \"\n+ solve(arr)); \n\n} \n} ", "complexity": "nlogn", "from": "CorCod", "problem": 724, "index": 724}
{"src": "import com.sun.org.apache.xpath.internal.operations.Bool;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        MyScanner scan = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int n = scan.nextInt();\n        int[] vals = new int[n];\n        for (int i = 0; i < n; i++) {\n            vals[i] = scan.nextInt();\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (solve(i, vals)) {\n                out.print('A');\n            } else {\n                out.print('B');\n            }\n        }\n\n        out.close();\n    }\n\n    static HashMap<Integer, Boolean> dpResult = new HashMap<>();\n\n    private static boolean solve(int pos, int[] vals) {\n        if (dpResult.containsKey(pos)) return dpResult.get(pos);\n        int val = vals[pos];\n        boolean hasLose = false;\n        for (int i = pos; i < vals.length; i += val) {\n            if (i == pos) continue;\n            if (vals[i] <= vals[pos]) continue;\n            if (hasLose) break;\n            if (!solve(i, vals)) {\n                hasLose = true;\n            }\n        }\n        for (int i = pos; i >= 0; i -= val) {\n            if (i == pos) continue;\n            if (vals[i] <= vals[pos]) continue;\n            if (hasLose) break;\n            if (!solve(i, vals)) {\n                hasLose = true;\n            }\n        }\n        dpResult.put(pos, hasLose);\n        return hasLose;\n    }\n\n\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n    //--------------------------------------------------------\n\n}", "complexity": "nlogn", "from": "CorCod", "problem": 725, "index": 725}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class CoveredPointsCount {\n\t\n\t//UPSOLVE\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t        \n\t\tint n = Integer.parseInt(st.nextToken());\n\t     \n\t\tlong[] myArray = new long[2 * n];\n\t        \n\t\t\tfor (int i = 0; i < n; i++)  {\n\t        \tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t        \tmyArray[2 * i] = Long.parseLong(st1.nextToken()) * 2;\n\t        \tmyArray[2 * i + 1] = Long.parseLong(st1.nextToken()) * 2 + 1;\n\t        }  \n\t        \n\t        Arrays.sort(myArray);\n\t        long[] ans = new long[n + 1];\n\t        int cnt = 0;\n\t       \n\t        for (int i = 0; i < 2 * n - 1; i++)   {\n\t            if (myArray[i] % 2 == 0) cnt++; else cnt--;\n\t            ans[cnt] += (myArray[i + 1] + 1) / 2 - (myArray[i] + 1) / 2;\n\t        }   \n\t        \n\t        StringBuilder answer = new StringBuilder();\n\t        \n\t        for (int i = 1; i < n + 1; i++) {\n\t        \tanswer.append(ans[i]);\n\t        \tanswer.append(\" \");\n\t        }  \n\t        \n\t        System.out.println(answer);\n\n\t}\n\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 726, "index": 726}
{"src": "\n// Java program to find the minimum possible \n// difference between maximum and minimum \n// elements when we have to add/subtract \n// every number by k \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Modifies the array by subtracting/adding \n\n// k to every element such that the difference \n\n// between maximum and minimum is minimized \n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n// Sort all elements \n\nArrays.sort(arr); \n\n\n// Initialize result \n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n// Handle corner elements \n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n// Traverse middle elements \n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n// If both subtraction and addition \n\n// do not change diff \n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n// Either subtraction causes a smaller \n\n// number or addition causes a greater \n\n// number. Update small or big using \n\n// greedy approach (If big - subtract \n\n// causes smaller diff, update small \n\n// Else update big) \n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n// Driver function to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n} \n// This code is contributed by Prerna Saini ", "complexity": "nlogn", "from": "CorCod", "problem": 727, "index": 727}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n    static int[] a;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        a = sc.nextIntArray(n);\n        long inversions = divide(0, n - 1);\n//        out.println(inversions);\n//        System.err.println(Arrays.toString(a));\n        if (n == 5) out.println(\"Petr\");\n        else {\n            if (n % 2 == 0) out.println(inversions % 2 == 0 ? \"Petr\" : \"Um_nik\");\n            else out.println(inversions % 2 != 0 ? \"Petr\" : \"Um_nik\");\n        }\n        out.flush();\n        out.close();\n    }\n\n    static long divide(int b, int e) {\n        if (b == e) return 0;\n        long cnt = 0;\n        int mid = b + e >> 1;\n        cnt += divide(b, mid);\n        cnt += divide(mid + 1, e);\n        cnt += merge(b, mid, e);\n        return cnt;\n    }\n\n    static long merge(int b, int mid, int e) {\n        long cnt = 0;\n        int len = e - b + 1;\n        int[] tmp = new int[len];\n        int i = b, j = mid + 1;\n        for (int k = 0; k < len; k++) {\n            if (i == mid + 1 || (j != e + 1 && a[i] > a[j])) {\n                tmp[k] = a[j++];\n                cnt += (mid + 1 - i);\n            } else tmp[k] = a[i++];\n        }\n        for (int k = 0; k < len; k++)\n            a[b + k] = tmp[k];\n        return cnt;\n    }\n\n    static class Scanner {\n\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n        public short nextShort() throws IOException {\n            return Short.parseShort(next());\n        }\n\n    }\n}", "complexity": "nlogn", "from": "CorCod", "problem": 728, "index": 728}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.util.Arrays;\n\npublic class Main\n{\n    \n     static void merge(int arr[], int l, int m, int r) \n    { \n        // Find sizes of two subarrays to be merged \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        /* Create temp arrays */\n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        /* Merge the temp arrays */\n  \n        // Initial indexes of first and second subarrays \n        int i = 0, j = 0; \n  \n        // Initial index of merged subarry array \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        /* Copy remaining elements of L[] if any */\n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        /* Copy remaining elements of R[] if any */\n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    // Main function that sorts arr[l..r] using \n    // merge() \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            // Find the middle point \n            int m = (l+r)/2; \n  \n            // Sort first and second halves \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            // Merge the sorted halves \n            merge(arr, l, m, r); \n        } \n    } \n  \n    public static void main(String args[]) throws Exception\n    {\n        Scanner sc=new Scanner(System.in);\n        int q=sc.nextInt();\n        while(q>0)\n        {\n            \n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int i=0;\n            for(i=0;i<n;i++)\n                a[i]=sc.nextInt();\n           sort(a,0,n-1);\n           int p=a[n-2]-1;\n            if(n-2>=p)\n                System.out.println(p);\n            else if (n-2==0)\n            System.out.println(0);\n            else \n                System.out.println(n-2);\n            q--;\n        }\n        \n    }\n        \n    }", "complexity": "nlogn", "from": "CorCod", "problem": 729, "index": 729}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Div1_526C {\n\n\tstatic int nV;\n\n\tstatic ArrayList<Integer>[] chldn;\n\n\tstatic int root;\n\n\tstatic int[][] anc;\n\tstatic int[] depth;\n\n\tstatic int[] num;\n\n\tstatic int[] nLoc;\n\n\tstatic int[][] tree;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tnV = Integer.parseInt(reader.readLine());\n\n\t\tchldn = new ArrayList[nV];\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\tchldn[i] = new ArrayList<>();\n\t\t}\n\n\t\tanc = new int[nV][21];\n\t\tdepth = new int[nV];\n\n\t\tnum = new int[nV];\n\t\tnLoc = new int[nV];\n\t\ttree = new int[nV * 4][2];\n\t\tfor (int[] a : tree) {\n\t\t\ta[0] = a[1] = -1;\n\t\t}\n\n\t\troot = 0;\n\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\tnum[i] = Integer.parseInt(inputData.nextToken());\n\t\t\tnLoc[num[i]] = i;\n\t\t}\n\n\t\tinputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 1; i < nV; i++) {\n\t\t\tanc[i][0] = Integer.parseInt(inputData.nextToken()) - 1;\n\t\t\tchldn[anc[i][0]].add(i);\n\t\t}\n\n\t\tpreprocess();\n\n\t\tbuild(1, 0, nV - 1);\n\n\t\tint nQ = Integer.parseInt(reader.readLine());\n\n\t\twhile (nQ-- > 0) {\n\t\t\tinputData = new StringTokenizer(reader.readLine());\n\t\t\tif (inputData.nextToken().equals(\"1\")) {\n\t\t\t\tint a = Integer.parseInt(inputData.nextToken()) - 1;\n\t\t\t\tint b = Integer.parseInt(inputData.nextToken()) - 1;\n\n\t\t\t\tint temp = num[a];\n\t\t\t\tnum[a] = num[b];\n\t\t\t\tnum[b] = temp;\n\n\t\t\t\tnLoc[num[a]] = a;\n\t\t\t\tnLoc[num[b]] = b;\n\n\t\t\t\tupdate(1, 0, nV - 1, num[a]);\n\t\t\t\tupdate(1, 0, nV - 1, num[b]);\n\t\t\t} else {\n\t\t\t\tprinter.println(query(1, 0, nV - 1, nLoc[0], nLoc[0]) + 1);\n\t\t\t}\n\t\t}\n\t\tprinter.close();\n\t}\n\n\tstatic void build(int nI, int cL, int cR) {\n\t\tif (cL == cR) {\n\t\t\ttree[nI][0] = nLoc[cL];\n\t\t\ttree[nI][1] = nLoc[cL];\n\t\t} else {\n\t\t\tint mid = (cL + cR) >> 1;\n\t\t\tbuild(nI * 2, cL, mid);\n\t\t\tbuild(nI * 2 + 1, mid + 1, cR);\n\t\t\tif (tree[nI * 2][0] != -1 && tree[nI * 2 + 1][0] != -1) {\n\t\t\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], tree[nI * 2 + 1][0], tree[nI * 2 + 1][1]);\n\t\t\t\ttree[nI][0] = mResp[0];\n\t\t\t\ttree[nI][1] = mResp[1];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int query(int nI, int cL, int cR, int e1, int e2) {\n\t\tif (cL == cR) {\n\t\t\tmerge(e1, e2, nLoc[cL], nLoc[cL]);\n\t\t\tif (mResp[0] != -1) {\n\t\t\t\treturn cL;\n\t\t\t} else {\n\t\t\t\treturn cL - 1;\n\t\t\t}\n\t\t}\n\t\tint mid = (cL + cR) >> 1;\n\n\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], e1, e2);\n\t\tif (mResp[0] != -1) {\n\t\t\treturn query(nI * 2 + 1, mid + 1, cR, mResp[0], mResp[1]);\n\t\t}\n\t\treturn query(nI * 2, cL, mid, e1, e2);\n\t}\n\n\tstatic void update(int nI, int cL, int cR, int uI) {\n\t\tif (cL == cR) {\n\t\t\ttree[nI][0] = nLoc[cL];\n\t\t\ttree[nI][1] = nLoc[cL];\n\t\t} else {\n\t\t\tint mid = (cL + cR) >> 1;\n\t\t\tif (uI <= mid) {\n\t\t\t\tupdate(nI * 2, cL, mid, uI);\n\t\t\t} else {\n\t\t\t\tupdate(nI * 2 + 1, mid + 1, cR, uI);\n\t\t\t}\n\t\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], tree[nI * 2 + 1][0], tree[nI * 2 + 1][1]);\n\t\t\ttree[nI][0] = mResp[0];\n\t\t\ttree[nI][1] = mResp[1];\n\t\t}\n\t}\n\n\tstatic int[] mResp = new int[2];\n\n\tstatic void merge1(int... a) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (a[i] == -1) {\n\t\t\t\tmResp[0] = mResp[1] = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (onPath(a[0], a[1], a[2])) {\n\t\t\tmResp[0] = a[0];\n\t\t\tmResp[1] = a[1];\n\t\t\treturn;\n\t\t}\n\t\tif (onPath(a[0], a[2], a[1])) {\n\t\t\tmResp[0] = a[0];\n\t\t\tmResp[1] = a[2];\n\t\t\treturn;\n\t\t}\n\t\tif (onPath(a[1], a[2], a[0])) {\n\t\t\tmResp[0] = a[1];\n\t\t\tmResp[1] = a[2];\n\t\t\treturn;\n\t\t}\n\t\tmResp[0] = mResp[1] = -1;\n\t}\n\n\tstatic void merge(int... a) {\n\t\tmerge1(a[0], a[1], a[2]);\n\t\tmerge1(mResp[0], mResp[1], a[3]);\n\t}\n\n\tstatic boolean onPath(int a, int b, int c) {\n\t\tif (a == c || b == c) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (depth[a] > depth[c]) {\n\t\t\ta = jump(a, depth[a] - depth[c] - 1);\n\t\t}\n\t\tif (depth[b] > depth[c]) {\n\t\t\tb = jump(b, depth[b] - depth[c] - 1);\n\t\t}\n\t\tif (a == b) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (anc[a][0] == c || anc[b][0] == c) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// good for depth of up to 1_048_576 = 2^20\n\n\tstatic void preprocess() {\n\t\tanc[root][0] = root;\n\t\tfParent(root);\n\n\t\tfor (int k = 1; k <= 20; k++) {\n\t\t\tfor (int i = 0; i < nV; i++) {\n\t\t\t\tanc[i][k] = anc[anc[i][k - 1]][k - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void fParent(int cV) {\n\t\tfor (int aV : chldn[cV]) {\n\t\t\tanc[aV][0] = cV;\n\t\t\tdepth[aV] = depth[cV] + 1;\n\t\t\tfParent(aV);\n\t\t}\n\t}\n\n\tstatic int fLCA(int a, int b) {\n\t\tif (depth[a] > depth[b]) {\n\t\t\tint temp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\t\tb = jump(b, depth[b] - depth[a]);\n\t\tif (a == b) {\n\t\t\treturn a;\n\t\t}\n\t\tfor (int i = 20; i >= 0; i--) {\n\t\t\tif (anc[a][i] != anc[b][i]) {\n\t\t\t\ta = anc[a][i];\n\t\t\t\tb = anc[b][i];\n\t\t\t}\n\t\t}\n\t\treturn anc[a][0];\n\t}\n\n\tstatic int jump(int cV, int d) {\n\t\tfor (int i = 0; i <= 20; i++) {\n\t\t\tif ((d & (1 << i)) != 0) {\n\t\t\t\tcV = anc[cV][i];\n\t\t\t}\n\t\t}\n\t\treturn cV;\n\t}\n\n\tstatic Comparator<Integer> BY_DEPTH = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn -Integer.compare(depth[o1], depth[o2]); // greatest depth first\n\t\t}\n\t};\n}", "complexity": "nlogn", "from": "CorCod", "problem": 730, "index": 730}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) a[i] = Long.parseLong(st.nextToken());\n        Queue<Long> ts = new PriorityQueue<Long>();\n        for(int i=1;i<n;i++) ts.add(a[i]-a[i-1]);\n        long sum = 0;\n        for(int i=0;i<n-k;i++){\n            sum += ts.poll();\n        }\n        System.out.println(sum);\n    }\n}\n\n", "complexity": "nlogn", "from": "CorCod", "problem": 731, "index": 731}
{"src": "\n// Java program to find number of pairs \n// and minimal possible value \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// function for finding pairs and min value \n\nstatic\nvoid\npairs(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n// initialize smallest and count \n\nint\nsmallest = Integer.MAX_VALUE; \n\nint\ncount=\n0\n; \n\n\n// iterate over all pairs \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nfor\n(\nint\nj=i+\n1\n; j<n; j++) \n\n{ \n\n// is abs value is smaller than \n\n// smallest update smallest and \n\n// reset count to 1 \n\nif\n( Math.abs(arr[i] + arr[j] - k) < \n\nsmallest ) \n\n{ \n\nsmallest = Math.abs(arr[i] + arr[j] \n\n- k); \n\ncount = \n1\n; \n\n} \n\n\n// if abs value is equal to smallest \n\n// increment count value \n\nelse\nif\n(Math.abs(arr[i] + arr[j] - k) \n\n== smallest) \n\ncount++; \n\n} \n\n\n// print result \n\nSystem.out.println(\n\"Minimal Value = \"\n+ \n\nsmallest); \n\nSystem.out.println(\n\"Total Pairs = \"\n+ \n\ncount); \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n3\n, \n5\n, \n7\n, \n5\n, \n1\n, \n9\n, \n9\n}; \n\nint\nk = \n12\n; \n\nint\nn = arr.length; \n\npairs(arr, n, k); \n\n} \n} \n// This code is contributed by Arnav Kr. Mandal. ", "complexity": "nlogn", "from": "CorCod", "problem": 732, "index": 732}
{"src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic final class Codeforces\n{\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint temp=sc.nextInt();\n\t\t\t\tlist.add(temp);\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tif(n%2==0)\n\t\t\tSystem.out.println(list.get((n/2)-1));\n\t\t\telse\n\t\t\tSystem.out.println(list.get(n/2));\n\t}\n}\n", "complexity": "nlogn", "from": "CorCod", "problem": 733, "index": 733}
{"src": "import sun.reflect.generics.tree.Tree;\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.net.Inet4Address;\nimport java.util.*;\n\npublic class l {\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMMMM      MMMMMM      OOO      OOO        SSSS   SSS     EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEE           MMMM MMM  MMM MMMM    OOO          OOO    SSSS       SSS   EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM  MMMMMM  MMMM   OOO            OOO   SSSS             EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM  OOO              OOO   SSSSSSS         EEEEE          /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO      SSSSSS       EEEEEEEEEEE    /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO         SSSSSSS   EEEEEEEEEEE    /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM   OOO            OOO              SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM    OOO          OOO     SSS       SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM      OOO      OOO        SSS    SSSS    EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    static long mod = (int) (1e9 + 7);\n    static int n;\n    static StringBuilder sol;\n\n    static class pair implements Comparable<pair> {\n        int L,R;\n        public pair( int x,int y) {\n            L=x;R=y;\n        }\n\n\n        public int compareTo(pair o) {\n            if (L!=o.L)return L-o.L;\n            return o.R-R;\n        }\n        public String toString(){\n            return L+\" \"+R;\n        }\n    }\n    static boolean is;\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        //FileWriter f = new FileWriter(\"C:\\\\Users\\\\Ibrahim\\\\out.txt\");\n        PrintWriter pw = new PrintWriter(System.out);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        TreeSet<Integer>length= new TreeSet<>();\n        length.add(0);\n        length.add(n);\n        TreeSet<Integer>width= new TreeSet<>();\n        width.add(0);\n        width.add(m);\n        TreeMap<Integer,Integer>len= new TreeMap<>();\n        len.put(n,1);\n        TreeMap<Integer,Integer>wid= new TreeMap<>();\n        wid.put(m,1);\n        while (q-->0){\n            String t= sc.next();\n            if (t.equals(\"H\")) {\n                int x = sc.nextInt();\n                int k1 = length.ceiling(x);\n                int k2 = length.floor(x);\n                if (x != k1) {\n                    int s = k1 - k2;\n                    int con = len.get(s);\n                    if (con == 1) len.remove(s);\n                    else len.put(s, con - 1);\n                    len.put((k1 - x), len.getOrDefault((k1 - x), 0) + 1);\n                    len.put((x - k2), len.getOrDefault((x - k2), 0) + 1);\n                    length.add(x);\n                }\n            }\n            else {\n                int x = sc.nextInt();\n                int k1 = width.ceiling(x);\n                int k2 = width.floor(x);\n                if (x != k1) {\n                    int s = k1 - k2;\n                    //System.out.println(s+\" \"+k1+\" \"+k2);\n                    int con = wid.get(s);\n                    if (con == 1) wid.remove(s);\n                    else wid.put(s, con - 1);\n                    wid.put((k1 - x), wid.getOrDefault((k1 - x), 0) + 1);\n                    wid.put((x - k2), wid.getOrDefault((x - k2), 0) + 1);\n                    width.add(x);\n                }\n            }\n            pw.println(1l*len.lastKey()*wid.lastKey());\n        }\n\n        pw.flush();\n    }\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n    }\n\n}", "complexity": "nlogn", "from": "CorCod", "problem": 734, "index": 734}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Dont {\n    static BufferedReader jin = new BufferedReader( new InputStreamReader( System.in ) );\n    static long n;\n    static long x, y;\n\n    public static void main(String[] args) throws Exception {\n        n = nextLong();\n        x = nextLong();\n        y = nextLong();\n        System.out.println( (max(n-x, n-y) < max(x-1, y-1))? \"Black\" : \"White\" );\n    }\n\n    static long max(long a, long b) {\n        return (a > b)? a : b ;\n    }\n\n    static long nextLong() throws Exception {\n        long res = 0;\n        int ch = jin.read();\n        while(ch < '0' || '9' < ch) ch = jin.read();\n        while('0'<= ch && ch <= '9') {\n            res = res*10 + ch - '0';\n            ch = jin.read();\n        }\n        return res;\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 735, "index": 735}
{"src": "import java.io.BufferedReader;\nimport java.io.PrintWriter;\n\nimport java.io.InputStreamReader;\n\nimport java.io.IOException;\n\nimport java.util.StringTokenizer;\n\npublic class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int x = in.nextInt(),\n            y = in.nextInt(),\n            z = in.nextInt(),\n            t1 = in.nextInt(),\n            t2 = in.nextInt(),\n            t3 = in.nextInt()*3,\n            d = Math.abs(x - y);\n        out.print(((Math.abs(x - z) + d) * t2 + t3 > d * t1 ? \"NO\" : \"YES\"));\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 736, "index": 736}
{"src": "//Author: Patel Rag\n//Java version \"1.8.0_211\"\nimport java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    //binary Modular exponentiation\n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    System.out.println((int)(fr.nextInt()/2) + 1);\n\n  }\n}\nclass pair\n{\n  public int first;\n  public int second;\n  public pair(int first,int second)\n  {\n    this.first = first;\n    this.second = second;\n  }\n  public int first() { return first; }\n  public int second() { return second; }\n  public void setFirst(int first) { this.first = first; }\n  public void setSecond(int second) { this.second = second; }\n}\nclass myComp implements Comparator<pair>\n{\n  public int compare(pair a,pair b)\n  {\n    return (a.first - b.first);\n  }\n}\nclass BIT       //Binary Indexed Tree aka Fenwick Tree\n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 737, "index": 737}
{"src": "import java.util.*;\n\nimport java.lang.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.*;\n \npublic class Main {\n        \n    public static void main(String[] args) throws Exception{\n        FastReader sc=new FastReader(); \n        OutputStream outputStream = System.out;\n        PrintWriter out = new PrintWriter(outputStream);\n        int n=sc.nextInt();\n        HashMap<String,Integer> map=new HashMap<String,Integer>();\n        for(int i=0;i<n;i++) {\n            map.put(sc.next(), 1);\n        }\n        ArrayList<String> list=new ArrayList<String>();\n        int count=0;\n        if(!map.containsKey(\"purple\")) {\n            count++;\n            list.add(\"Power\");\n        }\nif(!map.containsKey(\"green\")) {\n    count++;\n    list.add(\"Time\");\n        }\n\nif(!map.containsKey(\"blue\")) {\n    count++;\n    list.add(\"Space\");\n}\n\nif(!map.containsKey(\"orange\")) {\n    count++;\n    list.add(\"Soul\");\n}\n\nif(!map.containsKey(\"red\")) {\n    count++;\n    list.add(\"Reality\");\n}\n\nif(!map.containsKey(\"yellow\")) {\n    count++;\n    list.add(\"Mind\");\n}System.out.println(count);\n    for(String s:list) {\n        System.out.println(s);\n    }\n    }\n}\n\nclass FastReader \n{ \n    BufferedReader br; \n    StringTokenizer st; \n \n    public FastReader() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n \n    String next() \n    { \n        while (st == null || !st.hasMoreElements()) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n \n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n \n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n \n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n \n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n} ", "complexity": "constant", "from": "CorCod", "problem": 738, "index": 738}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n    public static void main (String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            String parameterStringList[] = reader.readLine().split(\" \");\n            int x = Integer.parseInt(parameterStringList[0]);\n            int y = Integer.parseInt(parameterStringList[1]);\n            int z = Integer.parseInt(parameterStringList[2]);\n            int t1 = Integer.parseInt(parameterStringList[3]);\n            int t2 = Integer.parseInt(parameterStringList[4]);\n            int t3 = Integer.parseInt(parameterStringList[5]);\n\n            int T1 = Math.abs(x-y) * t1;\n            int T2 = Math.abs(x-z) * t2 + 3*t3 + Math.abs(x-y) * t2;\n\n            if(T2 <= T1) System.out.println(\"YES\");\n            else System.out.println(\"NO\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 739, "index": 739}
{"src": "import java.io.*;\nimport java.util.NoSuchElementException;\n\n\npublic class Main_1100C {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\n\t\tdouble sin = Math.sin(Math.PI / n);\n\t\tdouble ans = r * sin / (1 - sin);\n\t\t\n\t\tpr.printf(\"%.7f%n\", ans);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\t\t\t\n\t\tsolve();\n\t\t\t\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tint[][] nextIntArrays(int n, int m) {\n\t\t\tint[][] ret = new int[m][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tret[j][i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t\t\n\t\tvoid printInts(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printLongs(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder(64);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printStrings(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 740, "index": 740}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author @Ziklon\n */\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    ABirthday solver = new ABirthday();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class ABirthday {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      long N = in.readLong(), M = in.readLong(), K = in.readLong(), L = in.readLong();\n\n      long ans = ((L + K) - 1) / M + 1;\n      if (ans * M > N || ans * M - K < L) out.printLine(-1);\n      else out.printLine(ans);\n    }\n  }\n\n  static class OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n    public void printLine(long i) {\n      writer.println(i);\n    }\n\n    public void printLine(int i) {\n      writer.println(i);\n    }\n  }\n\n  static class InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private InputReader.SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (numChars == -1) {\n        throw new InputMismatchException();\n      }\n      if (curChar >= numChars) {\n        curChar = 0;\n        try {\n          numChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (numChars <= 0) {\n          return -1;\n        }\n      }\n      return buf[curChar++];\n    }\n\n    public long readLong() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      long res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n      if (filter != null) {\n        return filter.isSpaceChar(c);\n      }\n      return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n      public boolean isSpaceChar(int ch);\n    }\n  }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 741, "index": 741}
{"src": "import java.util.*;\nimport java.io.*;\n\n\n\n public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   //-----------MyScanner class for faster input----------\n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}\n   ", "complexity": "constant", "from": "CorCod", "problem": 742, "index": 742}
{"src": "/**\n *   Author: Ridam Nagar\n *   Date: 27 February 2019\n *   Time: 01:17:36\n**/\n/* \npackage codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Codechef\n{     \n  static String reverse(String s){\n    String reverse=\"\";\n    for(int i=s.length()-1;i>=0;i--){\n        reverse=reverse + s.charAt(i);\n    }\n    return reverse;\n  }\n\n      \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc=new Scanner(System.in);\n         int n=sc.nextInt();\n         int m=sc.nextInt();\n         int x=m%(int)Math.pow(2,n);\n         System.out.println(x);\n\n\n\n}\n}", "complexity": "constant", "from": "CorCod", "problem": 743, "index": 743}
{"src": "import java.io.*;\n\npublic class n5D\n{\n    public static void main(String[] args)\n    {\n        double a = 0, v = 0, l = 0, d = 0, w = 0;\n        try\n        {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] str = br.readLine().split(\" \");\n            a = Double.parseDouble(str[0]);\n            v = Double.parseDouble(str[1]);\n            str = br.readLine().split(\" \");\n            l = Double.parseDouble(str[0]);\n            d = Double.parseDouble(str[1]);\n            w = Double.parseDouble(str[2]);\n        }\n        catch(Exception e)\n        {\n            System.out.println(e);\n        }\n\n        double t1, t2, t3, t4, t5, t, D = 0;\n        \n        if (w > v) w = v;\n        t2 = d / v - v / a + w * w / 2 / a / v;\n        if (t2 >= 0)\n        {\n            t1 = v / a; \n            t3 = t1 - w / a;\n        }\n        else\n        {\n            if (Math.sqrt(2 * d / a) > (w / a))\n            {\n                t1 = Math.sqrt((2 * a * d + w * w) / (a * a * 2));\n                t3 = t1 - w / a;\n            }\n            else\n            {\n                t1 = Math.sqrt(2 * d / a);\n                t3 = 0;\n            }\n            t2 = 0;\n        }\n        t5 = (l - d - v * v / 2 / a + a * (t1 - t3) * (t1 - t3) / 2) / v;\n        if (t5 >= 0) t4 = v / a - (t1 - t3);\n        else\n        {\n            t5 = 0;\n            t4 = -t1 + t3 + Math.sqrt((t1 - t3) * (t1 - t3) + 2 * (l - d) / a);\n        }\n        t = t1 + t2 + t3 + t4 + t5;\n        System.out.println(t);\n        //System.out.println(t1 + \" \" + t2 + \" \" + t3 + \" \" + t4 + \" \" + t5);\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 744, "index": 744}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Sid\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        A979 solver = new A979();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A979 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            long n = in.nextLong();\n            n = n + 1;\n            if (n % 2 == 0) {\n                out.println(n / 2);\n            } else {\n                if (n != 1) {\n                    out.println(n);\n                } else {\n                    out.println(0);\n                }\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "constant", "from": "CorCod", "problem": 745, "index": 745}
{"src": "import java.util.Scanner;\n\npublic class Main {\n//kai\n\tpublic static void main(String[] args) {\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}\n \t \t  \t\t\t\t \t \t      \t\t \t\t \t\t", "complexity": "constant", "from": "CorCod", "problem": 746, "index": 746}
{"src": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n%2==0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t \t  \t\t\t\t\t\t  \t\t\t \t\t\t   \t \t\t \t\t", "complexity": "constant", "from": "CorCod", "problem": 747, "index": 747}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int a=Integer.parseInt(s1[0]);\n            int b=Integer.parseInt(s1[1]);\n            int c=Integer.parseInt(s1[2]);\n            int n=Integer.parseInt(s1[3]);\n            int S=a+b-c;\n            if(n-S<1 || c>Math.min(a,b))\n             System.out.println(\"-1\");\n            else\n             System.out.println(n-S);\n      }\n}", "complexity": "constant", "from": "CorCod", "problem": 748, "index": 748}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class aaaaaaaaaaaaaaaa {\n\tpublic void run() throws Exception {\n\t\tScanner file = new Scanner(System.in);\n\t\tint a = file.nextInt(), b= file.nextInt(), c = file.nextInt(), n = file.nextInt();\n\t\ta -= c;\n\t\tb -= c;\n\t\tif (a < 0 || b < 0) System.out.println(-1);\n\t\telse {\n\t\t\tint x = a + b + c;\n\t\t\tif (x >= n) System.out.println(-1);\n\t\t\telse System.out.println(n - x);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew aaaaaaaaaaaaaaaa().run();\n\t}\n\n}", "complexity": "constant", "from": "CorCod", "problem": 749, "index": 749}
{"src": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n\t\t\t\t\t  \t \t     \t      \t\t \t\t\t", "complexity": "constant", "from": "CorCod", "problem": 750, "index": 750}
{"src": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              long a[] = new long[14];\n              for(int i = 0; i < 14; i++)\n                     a[i] = sc.nextLong();\n              long cpy[] = new long[14];\n              long max = 0;\n              for(int i = 0; i < 14; i++){\n                     if(a[i] == 0)continue;\n                     long score = 0;\n                     long curr = a[i];\n                     for(int j = 0; j < 14; j++)\n                            cpy[j] = a[j];\n                     cpy[i] = 0;\n                     long amnt = curr / 14l;\n                     for(int j = 0; j < 14; j++){\n                            cpy[j] += amnt;\n                     }\n                     amnt = curr % 14;\n                     for(int j = i + 1; j < i + 1 + amnt; j++){\n                            cpy[j % 14]++;\n                     }\n                     for(int j = 0; j < 14; j++){\n                            if(cpy[j] % 2 == 0)\n                                   score += cpy[j];\n                     }\n                     max = Math.max(max, score);\n              }\n              System.out.println(max);\n      }\n}", "complexity": "constant", "from": "CorCod", "problem": 751, "index": 751}
{"src": "import java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong();\n        long s = sc.nextLong();\n\n        long ans = (s - 1) / n + 1;\n        System.out.print(ans);\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 752, "index": 752}
{"src": "//Author: Patel Rag\n//Java version \"1.8.0_211\"\nimport java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    //binary Modular exponentiation\n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    long n = fr.nextLong();\n    long x = fr.nextLong();\n    long y = fr.nextLong();\n    long w = Long.min(x,y) - 1 + (x - Long.min(x,y)) + (y - Long.min(x,y));\n    long b = n - Long.max(x,y) + (Long.max(x,y) - x) + (Long.max(x,y) - y);\n    if(w <= b) System.out.println(\"White\");\n    else System.out.println(\"Black\");\n\n  }\n}\nclass Pair<U, V>  // Pair class\n{\n    public final U first;       // first field of a Pair\n    public final V second;      // second field of a Pair\n\n    private Pair(U first, V second)\n    {\n      this.first = first;\n      this.second = second;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n      if (this == o) return true;\n\n      if (o == null || getClass() != o.getClass()) return false;\n\n      Pair<?, ?> pair = (Pair<?, ?>) o;\n\n      if (!first.equals(pair.first)) return false;\n      return second.equals(pair.second);\n    }\n\n    @Override\n    public int hashCode()\n    {\n      return 31 * first.hashCode() + second.hashCode();\n    }\n\n    public static <U, V> Pair <U, V> of(U a, V b)\n    {\n      return new Pair<>(a, b);\n    }\n}\nclass myComp implements Comparator<Pair>\n{\n  public int compare(Pair a,Pair b)\n  {\n    if(a.first != b.first) return ((int)a.first - (int)b.first);\n    if(a.second != b.second) return ((int)a.second - (int)b.second);\n    return 0;\n  }\n}\nclass BIT       //Binary Indexed Tree aka Fenwick Tree\n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 753, "index": 753}
{"src": "import java.util.*;\nimport java.io.*;\n\n\n\n public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   //-----------MyScanner class for faster input----------\n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}\n   ", "complexity": "constant", "from": "CorCod", "problem": 754, "index": 754}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\nimport java.math.*;\nimport static java.lang.Integer.*;\nimport static java.lang.Double.*;\nimport java.lang.Math.*;\n\npublic class two_squares {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew two_squares().run();\n\t}\n\n\tpublic void run() throws Exception {\n\t\tFastIO file = new FastIO();\n\t\tdouble x1 = file.nextInt();\n\t\tdouble y1 = file.nextInt();\n\t\tdouble x2 = file.nextInt();\n\t\tdouble y2 = file.nextInt();\n\t\tdouble x3 = file.nextInt();\n\t\tdouble y3 = file.nextInt();\n\t\tdouble x4 = file.nextInt();\n\t\tdouble y4 = file.nextInt();\n\t\tdouble minx1, maxx1, miny1, maxy1;\n\t\tminx1 = Math.min(x1, Math.min(x2, Math.min(x3, x4)));\n\t\tmaxx1 = Math.max(x1, Math.max(x2, Math.max(x3, x4)));\n\t\tminy1 = Math.min(y1, Math.min(y2, Math.min(y3, y4)));\n\t\tmaxy1 = Math.max(y1, Math.max(y2, Math.max(y3, y4)));\n\t\tdouble x5 = file.nextInt();\n\t\tdouble y5 = file.nextInt();\n\t\tdouble x6 = file.nextInt();\n\t\tdouble y6 = file.nextInt();\n\t\tdouble x7 = file.nextInt();\n\t\tdouble y7 = file.nextInt();\n\t\tdouble x8 = file.nextInt();\n\t\tdouble y8 = file.nextInt();\n\t\tdouble minx2, maxx2, miny2, maxy2;\n\t\tminx2 = Math.min(x5, Math.min(x6, Math.min(x7, x8)));\n\t\tmaxx2 = Math.max(x5, Math.max(x6, Math.max(x7, x8)));\n\t\tminy2 = Math.min(y5, Math.min(y6, Math.min(y7, y8)));\n\t\tmaxy2 = Math.max(y5, Math.max(y6, Math.max(y7, y8)));\n\t\tPoint _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16;\n\t\t_1 = new Point(x1, y1);\n\t\t_2 = new Point(x2, y2);\n\t\t_3 = new Point(x3, y3);\n\t\t_4 = new Point(x4, y4);\n\t\t_5 = new Point(x5, y5);\n\t\t_6 = new Point(x6, y6);\n\t\t_7 = new Point(x7, y7);\n\t\t_8 = new Point(x8, y8);\n\t\t_9 = new Point(minx1, maxy1);\n\t\t_10 = new Point(minx1, miny1);\n\t\t_11 = new Point(maxx1, maxy1);\n\t\t_12 = new Point(maxx1, miny1);\n\t\tdouble m1 = (minx2 + maxx2) / 2;\n\t\tdouble m2 = (miny2 + maxy2) / 2;\n\t\t_13 = new Point(minx2, m2);\n\t\t_14 = new Point(m1, miny2);\n\t\t_15 = new Point(maxx2, m2);\n\t\t_16 = new Point(m1, maxy2);\n\t\tPoint[] a = {_1, _2, _3, _4};\n\t\tPoint[] b = {_5, _6, _7, _8};\n\t\tboolean works = false;\n\t\tLine[] aa = {new Line(_9,_10), new Line(_10, _12), new Line(_12, _11), new Line(_11, _9)};\n\t\tLine[] bb = {new Line(_13, _14), new Line(_14, _15), new Line(_15, _16), new Line(_16, _13)};\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (aa[i].intersection(bb[i]) != null) {\n\t\t\t\t\tworks = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Point p : b) {\n\t\t\tif (p.x >= minx1 && p.x <= maxx1 && p.y >= miny1 && p.y <= maxy1) {\n\t\t\t\tworks = true;\n\t\t\t}\n\t\t}\n\t\tfor (Point p : a) {\n\t\t\tboolean result = false;\n\t\t      for (int i = 0, j = b.length - 1; i < b.length; j = i++) {\n\t\t        if ((b[i].y > p.y) != (b[j].y > p.y) &&\n\t\t            (p.x < (b[j].x - b[i].x) * (p.y - b[i].y) / (b[j].y-b[i].y) + b[i].x)) {\n\t\t          result = !result;\n\t\t         }\n\t\t      }\n\t\t      if (result) works = true;\n\t\t}\n\t\tSystem.out.println(works ? \"YES\" : \"NO\");\n\t}\n\tpublic static class Point {\n\t\tdouble x, y;\n\t\tpublic Point(double a, double b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\t}\n\tpublic static class Line {\n\t\tPoint a, b;\n\t\tpublic Line(Point x, Point y) {\n\t\t\ta = x;\n\t\t\tb = y;\n\t\t}\n\t\tpublic Point intersection(Line o) {\n\t\t\tdouble x1 = a.x;\n\t\t\tdouble y1 = a.y;\n\t\t\tdouble x2 = b.x;\n\t\t\tdouble y2 = b.y;\n\t\t\tdouble x3 = o.a.x;\n\t\t\tdouble y3 = o.a.y;\n\t\t\tdouble x4 = o.b.x;\n\t\t\tdouble y4 = o.b.y;\n\t\t\tdouble denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\t\t\t  double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3))/denom;\n\t\t\t  double ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3))/denom;\n\t\t\t    if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {\n\t\t\t        return new Point((int) (x1 + ua*(x2 - x1)), (int) (y1 + ua*(y2 - y1)));\n\t\t\t    }\n\n\t\t\t  return null;\n\t\t}\n\t}\n\tpublic static class FastIO {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastIO() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\tpublic static long pow(long n, long p, long mod) {\n\t\tif (p == 0)\n\t\t\treturn 1;\n\t\tif (p == 1)\n\t\t\treturn n % mod;\n\t\tif (p % 2 == 0) {\n\t\t\tlong temp = pow(n, p / 2, mod);\n\t\t\treturn (temp * temp) % mod;\n\t\t} else {\n\t\t\tlong temp = pow(n, p / 2, mod);\n\t\t\ttemp = (temp * temp) % mod;\n\t\t\treturn (temp * n) % mod;\n\n\t\t}\n\t}\n\n\tpublic static long pow(long n, long p) {\n\t\tif (p == 0)\n\t\t\treturn 1;\n\t\tif (p == 1)\n\t\t\treturn n;\n\t\tif (p % 2 == 0) {\n\t\t\tlong temp = pow(n, p / 2);\n\t\t\treturn (temp * temp);\n\t\t} else {\n\t\t\tlong temp = pow(n, p / 2);\n\t\t\ttemp = (temp * temp);\n\t\t\treturn (temp * n);\n\n\t\t}\n\t}\n\n\tpublic static long gcd(long x, long y) {\n\t\tif (x == 0)\n\t\t\treturn y;\n\t\telse\n\t\t\treturn gcd(y % x, x);\n\t}\n\n\tpublic static boolean isPrime(int n) {\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\n\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\treturn false;\n\n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\n\t\treturn true;\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 755, "index": 755}
{"src": "import java.util.*;\npublic class C {\n\tpublic static void main(String[]args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble n=sc.nextDouble(),r=sc.nextDouble();\n\t\tSystem.out.println(r/(1/Math.sin(Math.PI/n)-1));\n\t\tsc.close();\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 756, "index": 756}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Solve4 {\n\n    public static void main(String[] args) throws IOException {\n      FastReader sc = new FastReader();\n      int x= sc.nextInt();\n      int y= sc.nextInt();\n      int z= sc.nextInt();\n      int t1= sc.nextInt();\n      int t2= sc.nextInt();\n      int t3= sc.nextInt();\n      if(Math.abs(x-y)*t1 < (Math.abs(x-z)+Math.abs(x-y))*t2+3*t3 ) System.out.println(\"NO\");\n      else System.out.println(\"YES\");\n    }\n\n    static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch (IOException ex) {\n            }\n            return s;\n        }\n    }\n\n}\n", "complexity": "constant", "from": "CorCod", "problem": 757, "index": 757}
{"src": "import java.util.*;\nimport java.lang.Math;\npublic class tab\n{\npublic static void main(String[] args)\n{\nint n,pos,l,r;\nScanner sc=new Scanner(System.in);\nn=sc.nextInt();\npos=sc.nextInt();\nl=sc.nextInt();\nr=sc.nextInt();\nint sum;\nint a=(n-r)+(l-1);\nif((Math.abs(pos-l)<Math.abs(r-pos))&&a!=0)\n{\n if(l!=1)\n   {sum=Math.abs(pos-l);\n    sum++;\n    if(r!=n)\n      sum+=(r-l)+1;\n   }\n else\n   sum=Math.abs(r-pos)+1;\n}\nelse if(a==0)\n  sum=0; \nelse\n{\n  if(r!=n)\n  {  sum=Math.abs(r-pos);\n     sum++;\n     if(l!=1) \n     sum+=(r-l)+1;\n  }\n  else\n   sum=Math.abs(pos-l)+1;\n}\nSystem.out.println(sum);\n}}", "complexity": "constant", "from": "CorCod", "problem": 758, "index": 758}
{"src": "import java.io.*;\npublic class coins\n{\n public static void main(String args[])throws IOException\n {\n  InputStreamReader read=new InputStreamReader(System.in);\n  BufferedReader in=new BufferedReader(read);\n  int i,k,n,v;\n  String a;\n  a=in.readLine();\n  for(i=0;i<a.length();i++)\n  {\n   if(a.charAt(i)==' ')\n   break;\n  }\n  n=Integer.parseInt(a.substring(0,i));\n  v=Integer.parseInt(a.substring(i+1));\n  k=v%n;\n  v=v/n;\n  if(k>0)\n  v++;\n  System.out.println(v);\n }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 759, "index": 759}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.lang.String;\npublic class Solution\n{\n    public static void main(String[] args)\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try\n        {\n            String str = br.readLine();\n            int q = Integer.parseInt(str);\n            //int q = 7;\n            //int q = 1345679;\n        if(q%2 == 0 && q!=2)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n            \n        }\n        catch(IOException e)\n        {\n            System.out.println(\"Input Error\");\n        }\n        \n        \n \n       /* String str = \"hello\";\n        String str1 = Character.toUpperCase(str.charAt(0))+str.substring(1);\n        System.out.println(str1);\n        */\n \n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 760, "index": 760}
{"src": "import java.util.*;\nimport java.math.*;\npublic class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        long n=scan.nextLong();\n        long m=scan.nextLong();\n        n=(long)Math.pow(2,n);\n        long ans=m%n;\n        System.out.println(ans);\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 761, "index": 761}
{"src": "import java.util.*;\nimport java.util.Scanner;\npublic class task1{\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        int n=in.nextInt();\n        int pos=in.nextInt();\n        int l=in.nextInt();\n        int r=in.nextInt();\n        boolean b=false;\n        boolean c=true;\n        if(l==1&&r==n){\n            c=false;\n            System.out.println(0);\n        }\n        if(c){\n            if(l==1){\n            if(pos<r){\n                System.out.println(r-pos+1);\n                b=true;}\n            else{\n                System.out.println(pos-r+1);\n                b=true;\n            }\n        }\n        if(r==n){\n            if(pos>l){\n                System.out.println(pos-l+1);\n                b=true;}\n            else{\n                System.out.println(l-pos+1);\n                b=true;\n            }\n        }\n        }\n        if(b==false&&c){\n            if(pos<l){\n            System.out.println(l-pos+1+r-l+1);\n        }\n        else if(pos>r){\n            System.out.println(pos-r+1+r-l+1);\n        }\n        else{\n            if(((pos-l)<(r-pos))){\n                System.out.println(pos-l+1+r-l+1);\n                \n            }\n            \n            else if((pos-l)>(r-pos)){\n                System.out.println(r-pos+1+r-l+1);\n                \n            }\n            else{\n                System.out.println((r-pos)*3+2);\n                \n            }\n        }\n        }\n        \n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 762, "index": 762}
{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n         int hp = scanner.nextInt();\n        if (hp%4 == 1){\n            System.out.println(\"0 A\");\n        }\n        else if (hp%4 == 2){\n            System.out.println(\"1 B\");\n        }\n        else if (hp%4 == 3){\n            System.out.println(\"2 A\");\n        }\n        else {\n            System.out.println(\"1 A\");\n        }\n\n    }\n    }\n", "complexity": "constant", "from": "CorCod", "problem": 763, "index": 763}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class B {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        // int n = Integer.parseInt(bf.readLine());\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        StringBuilder ans1 = new StringBuilder();\n        StringBuilder ans2 = new StringBuilder();\n        for(int i=0; i<2229; i++) ans1.append('5');\n        ans1.append('6');\n        for(int i=0; i<2230; i++) ans2.append('4');\n        out.println(ans1.toString());\n        out.println(ans2.toString());\n        out.close(); System.exit(0);\n    }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 764, "index": 764}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Codechef{\n\tstatic int max=Integer.MIN_VALUE;\n\tstatic int res=0;\n\tstatic int[] checkMax(int arr[],int j){\n             int sum=0;\n             int x=arr[j];\n        \t\twhile(x!=0){\n        \t\t        if(j+1==15){\n        \t\t        \tj=0;\n        \t\t        }else{\n        \t\t        \tarr[j+1]=arr[j+1]+1;\n        \t\t        }\n        \t\t        // if(arr[j+1]%2==0){\n        \t\t        // \tsum=sum+arr[j+1];\n        \t\t        // \tif(sum>=max){\n        \t\t        // \tmax=sum;\n        \t\t        // }\n        \t\t        // }\n\n        \t\t        \n        \t\t        x--;\n        \t\t        j++;\n        \t\t}\n        \t\t     return arr;\n\n\t}\n      \n\n    public static void main(String []args){\n       Scanner sc = new Scanner (System.in);\n    long a [] = new long [14];\n    long b [] = new long [14];\n    long p,q,r,s,max = 0;\n    for(int i = 0; i < 14; i++) a[i] = sc.nextInt();\n    for(int i = 0; i < 14; i++){\n      p = a[i]%14;\n      q = a[i]/14;\n      r = 0;\n      s = 0;\n      for(int j = 0; j < 14; j++) b[j] = a[j];\n      b[i] = 0;\n      int j = (i+1)%14;\n      for(; r < p; r++) {\n        b[j]++;\n        j=(j+1)%14;\n      }\n      for( j = 0; j < 14; j++) {\n        b[j] += q;\n        if(b[j] % 2 == 0) s+= b[j];\n      }\n      max = Math.max(max,s);\n    }\n    System.out.println(max);\n\n\n\n    }\n\n}", "complexity": "constant", "from": "CorCod", "problem": 765, "index": 765}
{"src": "import java.util.Scanner;\n\n/**\n * Solution\n */\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), s = sc.nextInt();\n        int coins;\n        if(s%n != 0)\n            coins = s/n + 1;\n        else\n            coins = s/n;\n\n        System.out.println(coins);\n\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 766, "index": 766}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A1008 {\n    public static void main(String [] args) /*throws Exception*/ {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);//new InputReader(new FileInputStream(new File(\"input.txt\")));new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);//new PrintWriter(new FileOutputStream(new File(\"output.txt\")));\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        pw.print((n + k - 1) / n);\n\n    }\n\n    private static void Qsort(int[] array, int low, int high) {\n\n        int i = low;\n        int j = high;\n        int x = array[low + (high - low) / 2];\n\n        do {\n            while (array[i] < x) ++i;\n            while (array[j] > x) --j;\n            if (i <= j) {\n                int tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                i++;\n                j--;\n            }\n        } while (i <= j);\n\n        if (low < j) Qsort(array, low, j);\n        if (i < high) Qsort(array, i, high);\n\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "complexity": "constant", "from": "CorCod", "problem": 767, "index": 767}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main\n{\n\t//static long k = 0;\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tBufferedReader st = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer s = new StringTokenizer(st.readLine());\n\t\tlong n = Long.parseLong(s.nextToken());\n\t\tlong k = Long.parseLong(s.nextToken());\n\t\tlong ans = k/n;\n\t\tif(k%n != 0) ans++;\n\t\tSystem.out.println(ans+\"\");\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 768, "index": 768}
{"src": "import java.util.*;\n\npublic class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int q=scan.nextInt();\n        int i;\n        for(i=1;i<=q;i++)\n        {\n            int a=scan.nextInt();\n            int ans=a/7+1;\n            System.out.println(ans);\n        }\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 769, "index": 769}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class pr1023B {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        long n = sc.nextLong();\n        long k = sc.nextLong();\n\n        out.println(solve(n, k));\n        out.flush();\n        out.close();\n    }\n\n\n    static long solve(long n, long k) {\n        if(k <= n) return (long)Math.floor((double)(k-1)/2);\n        else{\n            long mx = n;\n            long mn = k-n;\n            return Math.max(0, (long)Math.floor((double)(mx-mn+1)/2));\n        }\n    }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 770, "index": 770}
{"src": "\n// Java program to count \n// the number of indexes \n// in range L R such that \n// Ai=Ai+1 \n\nclass\nGFG { \n\npublic\nstatic\nint\nN = \n1000\n; \n\n// Array to store count \n// of index from 0 to \n// i that obey condition \nstatic\nint\nprefixans[] = \nnew\nint\n[\n1000\n]; \n\n// precomputing prefixans[] array \npublic\nstatic\nvoid\ncountIndex(\nint\na[], \nint\nn) \n{ \n\n\n// traverse to compute \n\n// the prefixans[] array \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(i + \n1\n< n && a[i] == a[i + \n1\n]) \n\nprefixans[i] = \n1\n; \n\n\nif\n(i != \n0\n) \n\nprefixans[i] += prefixans[i - \n1\n]; \n\n} \n} \n\n// function that answers \n// every query in O(1) \npublic\nstatic\nint\nanswer_query(\nint\nl, \nint\nr) \n{ \n\nif\n(l == \n0\n) \n\nreturn\nprefixans[r - \n1\n]; \n\nelse\n\nreturn\nprefixans[r - \n1\n] - \n\nprefixans[l - \n1\n]; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = \n9\n; \n\n\n// pre-computation \n\ncountIndex(a, n); \n\n\nint\nL, R; \n\n\n// 1-st query \n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println(answer_query(L, R)); \n\n\n// 2nd query \n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println(answer_query(L, R)); \n} \n} \n\n// This code is contributed by Jaideep Pyne ", "complexity": "constant", "from": "CorCod", "problem": 771, "index": 771}
{"src": "import java .util.*;\nimport java .io.*;\npublic class Main{\n\tpublic static void main(String[]YAHIA_MOSTAFA){\n\t\tScanner sc =new Scanner(System.in);\n\t\tlong n=sc.nextLong(),x=sc.nextLong(),y=sc.nextLong();\n\t\tlong xb,xw,yb,yw;\n\t\txw=x-1;yw=y-1;xb=n-x;yb=n-y;\n\t\tif (x==n&&y==n){\n\t\t\tSystem.out.println(\"Black\");return;\n\t\t}\n\t\tlong c1=0,c2=0;\n\t\tlong f =Math.max(xb,yb);\n\t\tlong h =Math.max(xw,yw);\n\t\t//System.out.println(h+\" \"+f+\" \"+(h-f));\n\t\tif (h<=f)\n\t\t\tSystem.out.println(\"White\");\n\t\telse\n\t\t\tSystem.out.println(\"Black\");\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 772, "index": 772}
{"src": "\nimport java.io.*;\nimport java.util.StringTokenizer;\n\n/**\n * CodeForces Round 5D. Follow Traffic Rules\n * Created by Darren on 14-9-14.\n */\npublic class Main {\n    Reader in = new Reader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    int a, v;\n    int l, d, w;\n\n    void run() throws IOException {\n        a = in.nextInt();\n        v = in.nextInt();\n        l = in.nextInt();\n        d = in.nextInt();\n        w = in.nextInt();\n\n        double totalTime = 0.0;\n        if (v >= w) {\n            if (w*w >= 2*a*d) {\n                double x = Math.sqrt(2*a*d);\n                totalTime = x / a;\n                if ((v*v-x*x) >= 2*a*(l-d))\n                    totalTime += (-2*x+Math.sqrt(4*x*x+8*a*(l-d))) / (2*a);\n                else\n                    totalTime += (v-x)/(1.0*a) + (l-d-(v*v-x*x)/(2.0*a))/v;\n            } else {\n//                totalTime = (-2*w+Math.sqrt(4*w*w+8*a*(l-d))) / (2*a);\n                if (2*v*v-w*w <= 2*a*d) {\n                    totalTime = v / (1.0*a) + (v-w) / (1.0*a) + (d-(2*v*v-w*w)/(2.0*a)) / v;\n                } else {\n                    double x = Math.sqrt((2*a*d+w*w)/2.0);\n                    totalTime = x / a + (x-w) / a;\n                }\n                if ((v*v-w*w) >= 2*a*(l-d))\n                    totalTime += (-2*w+Math.sqrt(4*w*w+8*a*(l-d))) / (2*a);\n                else\n                    totalTime += (v-w)/(1.0*a) + (l-d-(v*v-w*w)/(2.0*a))/v;\n            }\n        } else {\n            if (v*v >= 2*a*l)\n                totalTime = Math.sqrt(l*2.0/a);\n            else\n                totalTime = v / (1.0*a) + (l-v*v/(2.0*a)) / v;\n        }\n\n        out.printf(\"%.10f\", totalTime);\n        out.flush();\n    }\n\n    void solve() throws IOException {\n\n    }\n\n    static class Reader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public Reader(InputStream input) {\n            reader = new BufferedReader(new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        /** get next word */\n        String nextToken() throws IOException {\n            while ( ! tokenizer.hasMoreTokens() ) {\n                //TODO add check for eof if necessary\n                tokenizer = new StringTokenizer( reader.readLine() );\n            }\n            return tokenizer.nextToken();\n        }\n\n        String readLine() throws IOException {\n            return reader.readLine();\n        }\n\n        char nextChar() throws IOException {\n            return (char)reader.read();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt( nextToken() );\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong( nextToken() );\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble( nextToken() );\n        }\n    }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 773, "index": 773}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class C\n{\n\n\tstatic StringBuilder st = new StringBuilder();\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint [] freq = new int [5] ; \n\t\t\n\t\tint k = 3;  \n\t\twhile(k -- >0)\n\t\t{\n\t\t\tint x = sc.nextInt();\n\t\t\t\n\t\t\tif(x <= 4) freq[x]++;\n\t\t\t\n\t\t}\n\t\tfreq[2] += freq[4]/ 2 ;\n\t\t\n\t\tif(freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)\n\t\t\tout.println(\"YES\");\n\t\telse\n\t\t\tout.println(\"NO\");\n\t\t\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in) \n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}", "complexity": "constant", "from": "CorCod", "problem": 774, "index": 774}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class A {\n\tstatic FastReader scan;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tSolver solver = new Solver();\n\t\tscan = new FastReader();\n\t\tout = new PrintWriter(System.out);\n\t\tint testCases = 1;\n\t\tfor(int i = 1; i <= testCases; i++) {\n//\t\t\tout.print(\"Case #\" + i + \": \");\n\t\t\tsolver.solve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic class Solver {\n\t\t\n\t\tvoid solve() {\n\t\t\tint a = scan.nextInt(), b = scan.nextInt();\n\t\t\tif(b <= a) out.println(1);\n\t\t\telse out.println(b/a + Math.min(1, b%a));\n\t\t}\n\t\t\n\t}\n\n\t// Sathvik's Template Stuff BELOW!!!!!!!!!!!!!!!!!!!!!!\n\n\tstatic class DSU {\n\t\tint[] root, size;\n\t\tint n;\n\n\t\tDSU(int n) {\n\t\t\tthis.n = n;\n\t\t\troot = new int[n];\n\t\t\tsize = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\troot[i] = i;\n\t\t\t\tsize[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tint findParent(int idx) {\n\t\t\twhile (root[idx] != idx) {\n\t\t\t\troot[idx] = root[root[idx]];\n\t\t\t\tidx = root[idx];\n\t\t\t}\n\t\t\treturn idx;\n\t\t}\n\n\t\tboolean union(int x, int y) {\n\t\t\tint parX = findParent(x);\n\t\t\tint parY = findParent(y);\n\t\t\tif (parX == parY)\n\t\t\t\treturn false;\n\t\t\tif (size[parX] < size[parY]) {\n\t\t\t\troot[parY] = parX;\n\t\t\t\tsize[parX] += size[parY];\n\t\t\t} else {\n\t\t\t\troot[parX] = parY;\n\t\t\t\tsize[parY] += size[parX];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic class Extra {\n\t\tstatic void sort(int[] a) {\n\t\t\tInteger[] aa = new Integer[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(long[] a) {\n\t\t\tLong[] aa = new Long[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(double[] a) {\n\t\t\tDouble[] aa = new Double[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(char[] a) {\n\t\t\tCharacter[] aa = new Character[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\twhile (b > 0) {\n\t\t\t\tlong temp = b;\n\t\t\t\tb = a % b;\n\t\t\t\ta = temp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\n\t\tstatic boolean isPrime(long n) {\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tif (n <= 3)\n\t\t\t\treturn true;\n\t\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\t\treturn false;\n\t\t\tfor (long i = 5; i * i <= n; i = i + 6) {\n\t\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tstatic HashSet<Integer> sieve(int n) {\n\t\t\tboolean[] prime = new boolean[n + 1];\n\t\t\tHashSet<Integer> res = new HashSet<>();\n\t\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\tif (!prime[p]) {\n\t\t\t\t\tres.add(p);\n\t\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\t\tprime[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic HashMap<Long, Integer> primeFactorization(long n) {\n\t\t\tHashMap<Long, Integer> res = new HashMap<>();\n\t\t\twhile (n % 2 == 0) {\n\t\t\t\tres.put(2L, res.getOrDefault(2L, 0) + 1);\n\t\t\t\tn /= 2;\n\t\t\t}\n\t\t\tfor (long i = 3; i * i <= n; i += 2) {\n\t\t\t\twhile (n % i == 0) {\n\t\t\t\t\tres.put(i, res.getOrDefault(i, 0) + 1);\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n > 2)\n\t\t\t\tres.put(n, 1);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] a = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextDouble();\n\t\t\treturn a;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n}", "complexity": "constant", "from": "CorCod", "problem": 775, "index": 775}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        SpeedScanner speedScanner = new SpeedScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        taskSolver(speedScanner, out);\n        out.close();\n    }\n\n\n    public static void taskSolver(SpeedScanner speedScanner, PrintWriter out) {\n        long n = speedScanner.nextLong();\n        long m = speedScanner.nextLong();\n        long k = speedScanner.nextLong();\n        long l = speedScanner.nextLong();\n\n        long tempM ;\n\n        if ((k+l) < m){\n            if (n<m)\n                out.print(-1);\n            else\n                out.print(1);\n        }else {\n            tempM = (k+l)/m;\n            if ((k+l)%m == 0){\n                if (tempM*m <= n)\n                    out.print(tempM);\n                else\n                    out.print(-1);\n            }else {\n                if ((tempM+1)*m <= n)\n                    out.print(tempM+1);\n                else\n                    out.print(-1);\n            }\n        }\n    }\n\n\n    public static class SpeedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public SpeedScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n}\n", "complexity": "constant", "from": "CorCod", "problem": 776, "index": 776}
{"src": "import java.util.Scanner;\n\npublic class AlexAndARhombus {\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t\tsc.close();\n\t}\n\n}\n", "complexity": "constant", "from": "CorCod", "problem": 777, "index": 777}
{"src": "\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class e {\n\npublic static class FastReader {\n\tBufferedReader br;\n\tStringTokenizer st;\n\t//it reads the data about the specified point and divide the data about it ,it is quite fast\n\t//than using direct \n\n\tpublic FastReader() {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tString next() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception r) {\n\t\t\t\tr.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());//converts string to integer\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tString nextLine() {\n\t\tString str = \"\";\n\t\ttry {\n\t\t\tstr = br.readLine();\n\t\t} catch (Exception r) {\n\t\t\tr.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n}\nstatic ArrayList<String>list1=new ArrayList<String>();\nstatic void combine(String instr, StringBuffer outstr, int index,int k)\n{\n\tif(outstr.length()==k)\n\t{\n\t\tlist1.add(outstr.toString());return;\n\t}\n\tif(outstr.toString().length()==0)\n\toutstr.append(instr.charAt(index));\n    for (int i = 0; i < instr.length(); i++)\n    {\n        outstr.append(instr.charAt(i));\n       \n        combine(instr, outstr, i + 1,k);\n        outstr.deleteCharAt(outstr.length() - 1);\n    }\n   index++;\n} \nstatic ArrayList<ArrayList<Integer>>l=new ArrayList<>();\nstatic void comb(int n,int k,int ind,ArrayList<Integer>list)\n{\n\tif(k==0)\n\t{\n\t\tl.add(new ArrayList<>(list));\n\n\t\treturn;\n\t}\n\t\n\t\n\tfor(int i=ind;i<=n;i++)\n\t{\n\t\tlist.add(i);\n\t\tcomb(n,k-1,ind+1,list);\n\t\t\n\t\tlist.remove(list.size()-1);\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\t\n\n}\n\n\npublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\tFastReader in=new FastReader();\n\tHashMap<Integer,Integer>map=new HashMap<Integer,Integer>();\n\n\tint n=in.nextInt();\n\tint r=in.nextInt();\n\t \n\tdouble theta=(double)360/(double)n;\n\t \n\tdouble b=1-((double)2/(double)(1-Math.cos((double)2*Math.PI/(double)n)));\n\tdouble x=Math.sqrt(1-b)-1;\n\tdouble ans=(double)r/(double)x;\n\tSystem.out.println(ans);\n\n\n\n\n\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 778, "index": 778}
{"src": "\n// A O(1) Java program to \n// find number of strings \n// that can be made under \n// given constraints. \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nint\ncountStr(\nint\nn) \n\n{ \n\nreturn\n1\n+ (n * \n2\n) + \n\n(n * ((n * n) - \n1\n) / \n2\n); \n\n} \n\n// Driver code \npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\nn = \n3\n; \n\nSystem.out.println( countStr(n)); \n} \n} \n\n// This code is contributed by ajit ", "complexity": "constant", "from": "CorCod", "problem": 779, "index": 779}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.math.BigInteger;\n \npublic class Main {\n \n    private static final FS scanner = new FS(System.in);\n\t//private static final Scanner scanner = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) throws Exception {\n\n        int n = scanner.nextInt();\n        int sumA = 0;\n        int sumB = 0;\n        int rem = n % 4;\n        for (int i = rem; i >= 1 ; i--) {\n            if (sumB <= sumA) {\n                sumB += i;\n            }\n            else {\n                sumA +=i;\n            }\n        }\n\n        System.out.println(Math.abs(sumA - sumB));\n    }\n\t\n    static class FS {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FS(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n \n}", "complexity": "constant", "from": "CorCod", "problem": 780, "index": 780}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint k = input.nextInt();\n\t\tint n = input.nextInt();\n\t\tint s = input.nextInt();\n\t\tint p = input.nextInt();\n\n\t\tint each = n / s;\n\t\tif (n % s != 0)\n\t\t{\n\t\t\teach++;\n\t\t}\n\t\tint all = each * k;\n\n\t\tif (all % p == 0)\n\t\t{\n\t\t\tSystem.out.println(all / p);\n\t\t} else\n\t\t{\n\t\t\tSystem.out.println(all / p + 1);\n\t\t}\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 781, "index": 781}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class AAA {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\t\n\t\tint n=Integer.parseInt(st.nextToken());\n\t\tint m=Integer.parseInt(st.nextToken());\n\t\tString a=\"\";\n\t\tString b=\"\";\n\t\tfor(int i=0;i<1129;i++) {\n\t\t\ta+=\"1\";\n\t\t\tb+=\"8\";\n\t\t}\n\t\ta+=\"9\";\n\t\tb+=\"1\";\n\t\t\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t}\n\t\t\n}\n", "complexity": "constant", "from": "CorCod", "problem": 782, "index": 782}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class cf {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        pw.println(n/2+1);\n        pw.close();\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 783, "index": 783}
{"src": "import com.sun.org.apache.xalan.internal.xslt.Process;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class main {\n    public static void main(String[] args) throws IOException {\n        init();//\"prizes.in\", \"prizes.out\");\n        int x = nextInt();\n        int y = nextInt();\n        int z = nextInt();\n        int t1 = nextInt();\n        int t2 = nextInt();\n        int t3 = nextInt();\n        int lift = Math.abs(z - x) * t2 + 2 * t3 + Math.abs(x - y) * t2 + t3;\n        int stair = Math.abs(x - y) * t1;\n        if (lift <= stair) {\n            pw.print(\"YES\");\n        } else {\n            pw.print(\"NO\");\n        }\n        pw.close();\n    }\n\n    static StringTokenizer st;\n    static BufferedReader sc;\n    static PrintWriter pw;\n\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreElements()) {\n            st = new StringTokenizer(sc.readLine());\n        }\n        return st.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static void init(String in, String out) throws IOException {\n        sc = new BufferedReader(new FileReader(in));\n        pw = new PrintWriter(out);\n    }\n\n    static void init() {\n        sc = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n    }\n}\n\nclass DSU {\n    int parent[];\n    public DSU(int n){\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int get(int i){\n        if (i == parent[i]){\n            return i;\n        }\n        int p = get(parent[i]);\n        parent[i] = p;\n        return p;\n    }\n\n    boolean union(int a, int b){\n        a = get(a);\n        b = get(b);\n        if (a == b) return false;\n        parent[a] = b;\n        return true;\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 784, "index": 784}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class AlexAndARhombus {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 785, "index": 785}
{"src": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class RENAMETHISBITCH {\n\t\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tBigInteger m = sc.nextBigInteger();\n\t\t\t\n\t\t\tSystem.out.println(m.mod(BigInteger.valueOf(2).pow(n)));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 786, "index": 786}
{"src": "\nimport java.util.*;\nimport java.io.*;\n\npublic class TokitsukazeAndEnhancement {\n\t\n\tstatic char check(int n) {\n\t\tif(n%4 == 0)\n\t\t\treturn 'D';\n\t\tif(n%4 == 1)\n\t\t\treturn 'A';\n\t\tif(n%4 == 2)\n\t\t\treturn 'C';\n\t\treturn 'B';\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tStringTokenizer st;\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint a = n + 1;\n\t\tint b = n + 2;\n\t\tchar n1 = check(n);\n\t\tchar a1 = check(a);\n\t\tchar b1 = check(b);\n\t\tchar sol = (char) Math.min(Math.min(a1, b1),n1);\n\t\tif(sol == n1)\n\t\t\tpw.println(0 + \" \" + sol);\n\t\telse if(sol == a1)\n\t\t\tpw.println(1 + \" \" + sol);\n\t\telse if(sol == b1)\n\t\t\tpw.println(2 + \" \" + sol);\n\t\tpw.close();\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 787, "index": 787}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class bhaa {\n\n    InputStream is;\n    PrintWriter o;\n    /////////////////// CODED++ BY++ ++ ++ ++ BHAVYA++ ARORA++ ++ ++ ++ FROM++ JAYPEE++ INSTITUTE++ OF++ INFORMATION++ TECHNOLOGY++ ////////////////\n\n///////////////////////// Make it work, make it right, make it fast. Make it work, make it right, make it fast. Make it work, make it right, make it fast. Make it work, make it right, make it fast. /////////////////\n\n    boolean chpr(int n)\n    {\n    \tif(n==1)\n    \t{\n    \t\treturn true;\n    \t}if(n==2)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n==3)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n%2==0)\n    \t{\n    \t\treturn false;\n\n    \t}\n    \tif(n%3==0)\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tint w=2;\n \t\tint i=5;\n    \twhile(i*i<=n)\n    \t{\n    \t\tif(n%i==0)\n    \t\t{\n    \t\t\treturn false;\n    \t\t}\n    \t\ti+=w;\n    \t\tw=6-w;\n    \t}\n    \treturn true;\n\n    }\n    \n    void solve() {\n\n\n        int n=ni();\n        int k=ni();\n        int rr=2*n;\n        int gr=5*n;\n        int br=8*n;\n        o.println((long)(Math.ceil(rr*1.0/k)+Math.ceil(gr*1.0/k)+Math.ceil(br*1.0/k)));\n\n\n\n    \t\n\n    }\n\n\n\n\n\n   \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    //---------- I/O Template ----------\n    \n    public static void main(String[] args) { new bhaa().run(); }\n    void run() { \n        is = System.in; \n        o = new PrintWriter(System.out);\n        solve();\n        o.flush();\n    }\n    \n    byte input[] = new byte[1024];\n    int len = 0, ptr = 0;\n    \n    int readByte() { \n        if(ptr >= len) { ptr = 0; \n            try { len = is.read(input); } \n            catch(IOException e) { throw new InputMismatchException(); } \n            if(len <= 0) { return -1; } \n        } return input[ptr++];\n    }\n    boolean isSpaceChar(int c) { return !( c >= 33 && c <= 126 ); }\n    int skip() { \n        int b = readByte(); \n        while(b != -1 && isSpaceChar(b)) { b = readByte(); } \n        return b;\n    }\n    \n    char nc() { return (char)skip(); }\n    String ns() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while(!isSpaceChar(b)) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    String nLine() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while( !(isSpaceChar(b) && b != ' ') ) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    int ni() { \n        int n = 0, b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        if(b == -1) { return -1; }  //no input \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n    long nl() { \n        long n = 0L;    int b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n\n    double nd() { return Double.parseDouble(ns()); }\n    float nf() { return Float.parseFloat(ns()); }\n    int[] nia(int n) { \n        int a[] = new int[n]; \n        for(int i = 0; i < n; i++) { a[i] = ni(); } \n        return a;\n    }\n    long[] nla(int n) { \n        long a[] = new long[n]; \n        for(int i = 0; i < n; i++) { a[i] = nl(); } \n        return a;\n    }\n    int [][] nim(int n)\n    {\n        int mat[][]=new int[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=ni();\n            }\n        }\n        return mat;\n    }\n    long [][] nlm(int n)\n    {\n        long mat[][]=new long[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=nl();\n            }\n        }\n        return mat;\n    }\n    \n\n\n\n\n    \n    char[] ns(int n) { \n        char c[] = new char[n]; \n        int i, b = skip(); \n        for(i = 0; i < n; i++) { \n            if(isSpaceChar(b)) { break; } \n            c[i] = (char)b; b = readByte(); \n        } return i == n ? c : Arrays.copyOf(c,i);\n    }\n    void piarr(int arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    void plarr(long arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    \n    void pimat(int mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n    }\n    void plmat(long mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n\n    }\n\n\n\n\n    //////////////////////////////////// template finished //////////////////////////////////////\n\n\n\n}", "complexity": "constant", "from": "CorCod", "problem": 788, "index": 788}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A_KingEscape {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int Qx = inp.nextInt(), Qy = inp.nextInt();\n            int Kx = inp.nextInt(), Ky = inp.nextInt();\n            int Tx = inp.nextInt(), Ty = inp.nextInt();\n            if (((Kx < Qx && Tx < Qx) || (Kx > Qx && Tx > Qx)) && ((Ky < Qy && Ty < Qy) || (Ky > Qy && Ty > Qy))) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 789, "index": 789}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n\npublic class Main {\n\n\tstatic class Task {\n\t\t\n\t\tint NN = 500005;\n\t\tint MOD = 1000000007;\n\t\tint INF = 2000000000;\n\t\tlong INFINITY = 2000000000000000000L;\n\t\t\n\t\tpublic void solve(InputReader in, PrintWriter out) {\n\t\t\tint t = in.nextInt();\n\t\t\twhile(t-->0) {\n\t\t\t\tlong n =in.nextLong();\n\t\t\t\tlong m = in.nextLong();\n\t\t\t\tlong x1 = in.nextLong();\n\t\t\t\tlong y1 = in.nextLong();\n\t\t\t\tlong x2 = in.nextLong();\n\t\t\t\tlong y2 = in.nextLong();\n\t\t\t\tlong x3 = in.nextLong();\n\t\t\t\tlong y3 = in.nextLong();\n\t\t\t\tlong x4 = in.nextLong();\n\t\t\t\tlong y4 = in.nextLong();\n\t\t\t\tlong w = white(1, 1, m, n);\n\t\t\t\tlong b = black(1, 1, m, n);\n\t\t\t\tlong whited = 0;\n\t\t\t\tif(x3 > x2 || x4 < x1 || y3 > y2 || y4 < y1) {\n\t\t\t\t\twhited = black(x1, y1, x2, y2);\n\t\t\t\t} else {\n\t\t\t\t\twhited = black(x1, y1, x2, y2);\n\t\t\t\t\tlong xm1 = Math.max(x1, x3);\n\t\t\t\t\tlong ym1 = Math.max(y1, y3);\n\t\t\t\t\tlong xm2 = Math.min(x2, x4);\n\t\t\t\t\tlong ym2 = Math.min(y2, y4);\n\t\t\t\t\twhited -= black(xm1, ym1, xm2, ym2);\n\t\t\t\t}\n\t\t\t\tb -= whited;w += whited;\n\t\t\t\tlong blacked = white(x3, y3, x4, y4);\n\t\t\t\tw-= blacked;b += blacked;\n\t\t\t\tout.println(w + \" \" + b);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong black(long x1, long y1, long x2, long y2) {\n\t\t\tlong dx = (x2 - x1) + 1;\n\t\t\tlong dy = (y2 - y1) + 1;\n\t\t\tif((x1+y1)%2!=0) {\n\t\t\t\treturn ((dy+1)/2)*((dx+1)/2)+(dy/2)*(dx/2);\n\t\t\t}\n\t\t\treturn ((dy+1)/2)*((dx)/2)+(dy/2)*((dx+1)/2);\n\t\t}\n\t\t\n\t\tlong white(long x1, long y1, long x2, long y2) {\n\t\t\tlong dx = (x2 - x1) + 1;\n\t\t\tlong dy = (y2 - y1) + 1;\n\t\t\tif((x1+y1)%2==0) {\n\t\t\t\treturn ((dy+1)/2)*((dx+1)/2)+(dy/2)*(dx/2);\n\t\t\t}\n\t\t\treturn ((dy+1)/2)*(dx/2)+(dy/2)*((dx+1)/2);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic void prepareIO(boolean isFileIO) {\n\t\t//long t1 = System.currentTimeMillis();\n\t\tTask solver = new Task();\n\t\t// Standard IO\n\t\tif(!isFileIO) { \n\t\t\tInputStream inputStream = System.in;\n\t        OutputStream outputStream = System.out;\n\t        InputReader in = new InputReader(inputStream);\n\t        PrintWriter out = new PrintWriter(outputStream);\n\t        solver.solve(in, out);\n\t        //out.println(\"time(s): \" + (1.0*(System.currentTimeMillis()-t1))/1000.0);\n\t        out.close();\n\t\t}\n        // File IO\n\t\telse {\n\t\t\tString IPfilePath = System.getProperty(\"user.home\") + \"/Downloads/ip.in\";\n\t        String OPfilePath = System.getProperty(\"user.home\") + \"/Downloads/op.out\";\n\t        InputReader fin = new InputReader(IPfilePath);\n\t        PrintWriter fout = null;\n\t        try {\n\t\t\t\tfout = new PrintWriter(new File(OPfilePath));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t        solver.solve(fin, fout);\n\t        //fout.println(\"time(s): \" + (1.0*(System.currentTimeMillis()-t1))/1000.0);\n\t        fout.close();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n        prepareIO(false);\n\t}\n\t\n\tstatic class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        \n        public InputReader(String filePath) {\n        \tFile file = new File(filePath);\n            try {\n\t\t\t\treader = new BufferedReader(new FileReader(file));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n            tokenizer = null;\n        }\n        \n        public String nextLine() {\n        \tString str = \"\";\n        \ttry {\n\t\t\t\tstr = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n        \treturn str;\n        }\n        \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n        \treturn Double.parseDouble(next());\n        }\n        \n    }\n\n}", "complexity": "constant", "from": "CorCod", "problem": 790, "index": 790}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.Math;\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tlong n = Long.parseLong(input.split(\" \")[0]);\n\t        long k = Long.parseLong(input.split(\" \")[1]);\n\t        long red = (long) (Math.ceil((n * 2.0)/k));\n\t        long blue = (long) (Math.ceil((n * 5.0)/k));\n\t        long green = (long) (Math.ceil((n * 8.0)/k));\n\t        System.out.println(red + blue +green);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n", "complexity": "constant", "from": "CorCod", "problem": 791, "index": 791}
{"src": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint a = in.nextInt();\n\n\t\tif(a>=1 && a<=100){\n\t\t\tif(a>2){\n\t\t\t\tif(a%2==0){\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 792, "index": 792}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n\n\tstatic long MOD = 1_000_000_000 + 7;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tlong n = Long.parseLong(st.nextToken());\n\t\tlong m = Long.parseLong(st.nextToken());\n\t\tlong k = Long.parseLong(st.nextToken());\n\t\tlong l = Long.parseLong(st.nextToken());\n\n\t\tlong p = (l + k) / m;\n\n\t\tif (p * m != l + k) {\n\t\t\tp++;\n\t\t}\n\n\t\tif (m * p <= n) {\n\t\t\tSystem.out.println(p);\n\t\t} else {\n\t\t\tSystem.out.println(-1);\n\t\t}\n\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 793, "index": 793}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n//kai\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}\n \t   \t\t\t\t \t   \t\t\t \t\t  \t  \t \t \t", "complexity": "constant", "from": "CorCod", "problem": 794, "index": 794}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n    static Scanner scan = new Scanner(System.in);\n\n    public static void main(String [] args){\n        int num = scan.nextInt();\n        for(int i=0;i<num;i++){\n            int a = scan.nextInt();\n            int b = scan.nextInt();\n            System.out.println(a+\" \"+2*a);\n        }\n    }\n}\n\t  \t    \t    \t\t \t  \t\t\t\t \t\t \t\t\t", "complexity": "constant", "from": "CorCod", "problem": 795, "index": 795}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class KingEscape {\n\n    public static void main(String[] args) {\n        Reader read = new Reader();\n\n        int n = read.nextInt();\n        int a1 = read.nextInt();\n        int a2 = read.nextInt();\n        int b1 = read.nextInt();\n        int b2 = read.nextInt();\n        int c1 = read.nextInt();\n        int c2 = read.nextInt();\n\n        if (b1 > a1 && b2 > a2 && c1 > a1 && c2 > a2)\n            System.out.print(\"YES\");\n        else if (b1 > a1 && b2 < a2 && c1 > a1 && c2 < a2)\n            System.out.print(\"YES\");\n        else if (b1 < a1 && b2 > a2 && c1 < a1 && c2 > a2)\n            System.out.print(\"YES\");\n        else if (b1 < a1 && b2 < a2 && c1 < a1 && c2 < a2)\n            System.out.print(\"YES\");\n        else\n            System.out.print(\"NO\");\n    }\n\n    private static class Reader {\n\n        private final BufferedReader reader;\n        private final String separator;\n        private String ln;\n        private String[] tokens;\n        private int ptr;\n\n        Reader(String separator, InputStream input) {\n            this.reader = new BufferedReader(new InputStreamReader(input));\n            this.separator = separator;\n            this.ptr = -1;\n        }\n\n        Reader(String separator) { this(separator, System.in); }\n\n        Reader() { this(\" \"); }\n\n        String nextStr(){\n            if (Objects.isNull(ln)) {\n                try {\n                    ln = reader.readLine();\n                } catch (IOException e) {\n                    System.out.println(e.getMessage());\n                }\n                if (Objects.nonNull(ln)) {\n                    tokens = ln.split(separator);\n                    ptr = 0;\n                } else {\n                    throw new NoSuchElementException(\"no next element\");\n                }\n\n            } else if (ptr == tokens.length) {\n                ln = null;\n                tokens = null;\n                ptr = -1;\n                return nextStr();\n            }\n\n            return tokens[ptr++];\n        }\n\n        int nextInt() { return Integer.parseInt(nextStr()); }\n\n        long nextLong() { return Long.parseLong(nextStr()); }\n\n        double nextDouble() { return Double.parseDouble(nextStr()); }\n    }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 796, "index": 796}
{"src": "import java.io.*;\n\n\npublic class DS {\n\n    /*\n     * Complete the twoStacks function below.\n     */\n   \n\n\n\n    public static void main(String[] args) throws IOException {\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       int x=Integer.parseInt(br.readLine());\n         \nif (x==1)\n            System.out.println(-1);\nelse\n            System.out.println(x+\" \"+x);\n\n        }\n\n        \n    }", "complexity": "constant", "from": "CorCod", "problem": 797, "index": 797}
{"src": "//package Contest573;\n\n\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class mainA {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        int x=enter.nextInt();\n        if(x%4==0){\n            System.out.println(1 +\" A\");\n        }\n        else if(x%4==1){\n            System.out.println(0+\" A\");\n        }\n        else if(x%4==2){\n            System.out.println(1+\" B\");\n        }\n        else if(x%4==3){\n            System.out.println(2+\" A\");\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 798, "index": 798}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Test3 {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tint x=Integer.parseInt(br.readLine());\n\t\tint y=Integer.parseInt(br.readLine());\n\t\tSystem.out.print((int)(y%(Math.pow(2, x))));\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 799, "index": 799}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A1008 {\n    public static void main(String [] args) /*throws Exception*/ {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);//new InputReader(new FileInputStream(new File(\"input.txt\")));new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);//new PrintWriter(new FileOutputStream(new File(\"output.txt\")));\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        long l = Math.max(1, k - n), r = (k + 1) / 2;\n        l = Math.max(0, r - l);\n        pw.print(l);\n\n    }\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "complexity": "constant", "from": "CorCod", "problem": 800, "index": 800}
{"src": "\n\nimport java.io.PrintWriter;\n\nimport java.util.*;\nimport java.util.Arrays ; \nimport java .lang.String.* ;\nimport java .lang.StringBuilder ;\n\n\npublic class Test{\n    static int pos = 0 ; \n    static int  arr[] ; \n  static LinkedList l1 = new  LinkedList() ; \nstatic void find(int p ,char[]x,int put[],String s){\n    int c= 0 ; \n    for (int i = 0; i < s.length(); i++) {\n        if(x[p]==s.charAt(i)){\n        c++ ; }\n    }\n    put[p] = c ;  \n}\nstatic int mode(int m ,int[]x ){\n    int temp = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return m-temp ; \n             \n        }\n    }\n     return m-temp ; \n}\nstatic int mode2(int m ,int[]x ){\n    int temp = 0 ; \n    \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return x[i] ; \n             \n        }\n    }\n     return 0 ; \n}\nstatic int find(int x[],int temp){\n    int j = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]==temp) return j+1 ; \n        j++ ; \n    }\n    return -1 ; \n}\nstatic String ch(long[]x,long b){\n    for (int i = 0; i < x.length; i++) {\n        if(x[i]==b)return \"YES\" ;\n    }\n    return \"NO\" ; \n}\n\n    public static void main(String[] args)  {\n\n        Scanner in = new Scanner(System.in) ;\n        PrintWriter pw = new PrintWriter(System.out);   \n     int k=in.nextInt(), n=in.nextInt(), s=in.nextInt(), p=in.nextInt() ;\n     int paper =n/s; \n     if(n%s!=0) paper++ ; \n     paper*=k ; \n     int fin = paper/p ; \n     if(paper%p!=0) fin++ ; \n        System.out.println( fin );\n       \n       \n }               \n}\n\n", "complexity": "constant", "from": "CorCod", "problem": 801, "index": 801}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n \n \npublic class HelloWorld {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Palindrome solver = new Palindrome();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class Palindrome {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long l = in.nextLong();\n            \n            if(l%4 == 0 || l%4 == 3)\n            {\n                out.print(\"0\");\n            }\n            else\n            {\n                out.print(\"1\");\n            }\n        }\n \n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n \n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 802, "index": 802}
{"src": "import java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class C {\n\n\tstatic StringBuilder st = new StringBuilder();\n\n\t\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tPoint [] square = new Point [4] ; \n\t\tPoint [] rotSquare = new Point[4] ; \n\t\t\n\t\tfor(int i = 0 ; i < 4 ;i++)\n\t\t\tsquare[i] = new Point(sc.nextInt() , sc.nextInt());\n\t\t\n\t\tfor(int i = 0 ; i < 4 ;i++)\n\t\t\trotSquare[i] = new Point(sc.nextInt() , sc.nextInt());\n\t\t\n\t\tboolean can = false ; \n\t\t\n\t\tfor(int x = -100 ; x <= 100 ; x++)\n\t\t\tfor(int y = -100 ; y <= 100 ; y++)\n\t\t\t\tcan |= inside(new Point(x , y), square) & inside(new Point (x , y), rotSquare);\n\t\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tout.println(can ? \"YES\" : \"NO\");\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\tstatic int crossProduct(Point a , Point b)\n\t{\n\t\tint ans = a.x * b.y - a.y * b.x ; \n\t\t\n\t\tif(ans < 0)return -1 ;\n\t\tif(ans == 0) return 0 ;\n\t\treturn 1 ; \n\t}\n\t\n\tstatic boolean inside(Point a , Point [] points)\n\t{\n\t\tboolean allPos = true ; \n\t\tboolean allNeg = true ; \n\t\t\n\t\tfor(int i = 0 ; i < 4 ; i++)\n\t\t{\n\t\t\tPoint v1 = new Point (points[i].x - a.x , points[i].y - a.y) ; \n\t\t\tPoint v2 = new Point (points[(i + 1) % 4].x - a.x , points[(i + 1) % 4].y - a.y) ; \n\t\t\t\n\t\t\tallPos &= crossProduct(v1, v2) >= 0;\n\t\t\tallNeg &= crossProduct(v1, v2) <= 0;\n\t\t}\n\t\treturn allPos | allNeg ; \n\t\t\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}", "complexity": "constant", "from": "CorCod", "problem": 803, "index": 803}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class CF1068A {\n\tpublic CF1068A() {\n\t\tFS scan = new FS();\n\t\tlong n = scan.nextLong(), m = scan.nextLong(), k = scan.nextLong(), l = scan.nextLong();\n\t\tlong ceil = (k + l + m - 1) / m;\n\t\tif(k + l <= n && ceil * m <= n) System.out.println(ceil);\n\t\telse System.out.println(-1);\n\t}\n\tclass FS {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\tpublic String next() {\n\t\t\twhile(!st.hasMoreTokens()) {\n\t\t\t\ttry { st = new StringTokenizer(br.readLine()); }\n\t\t\t\tcatch(Exception e) { e.printStackTrace(); }\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() { return Integer.parseInt(next()); }\n\t\tpublic long nextLong() { return Long.parseLong(next()); }\n\t}\n\tpublic static void main(String[] args) { new CF1068A(); }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 804, "index": 804}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int S=Integer.parseInt(s1[1]);\n            if(S%n==0)\n             System.out.println(S/n);\n            else\n             System.out.println(S/n+1);\n      }\n}", "complexity": "constant", "from": "CorCod", "problem": 805, "index": 805}
{"src": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n\n// author @mdazmat9\npublic  class codeforces{\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int test = 1;\n        for (int ind = 0; ind < test; ind++) {\n          int [] a=new int[3];\n          a[0]=sc.nextInt();\n          a[1]=sc.nextInt();\n          a[2]=sc.nextInt();\n          Arrays.sort(a);\n          int k1=a[0];\n          int k2=a[1];\n          int k3=a[2];\n          if(k1==1 || k2==1 || k3==1){\n              out.println(\"YES\");\n          }\n          else if((k1==2 && k2==2)||(k2==2 && k3==2)){\n              out.println(\"YES\");\n            }\n            else if(k1==3 && k2==3 && k3==3){\n              out.println(\"YES\");\n          }\n          else if(k1==2 && k2==4 && k3==4){\n              out.println(\"YES\");\n          }\n          else\n              out.println(\"NO\");\n\n        }\n        out.flush();\n    }\n\n\n\n\n\n    static   void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n    static long gcd(long a , long b)\n    {\n        if(b == 0)\n            return a;\n        return gcd(b , a % b);\n    }\n\n}\nclass Scanner {\n    public BufferedReader reader;\n    public StringTokenizer st;\n\n    public Scanner(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        st = null;\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                String line = reader.readLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            } catch (Exception e) {\n                throw (new RuntimeException());\n            }\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n\nclass OutputWriter {\n    BufferedWriter writer;\n\n    public OutputWriter(OutputStream stream) {\n        writer = new BufferedWriter(new OutputStreamWriter(stream));\n    }\n\n    public void print(int i) throws IOException {\n        writer.write(i);\n    }\n\n    public void print(String s) throws IOException {\n        writer.write(s);\n    }\n\n    public void print(char[] c) throws IOException {\n        writer.write(c);\n    }\n\n    public void close() throws IOException {\n        writer.close();\n    }\n\n}", "complexity": "constant", "from": "CorCod", "problem": 806, "index": 806}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 807, "index": 807}
{"src": "//package codeforces;\nimport java.util.Scanner;\npublic class ex5 {\npublic static void main(String[] args) {\n\tScanner scan = new Scanner(System.in);\n\tString S [] = new String[3];\n\t\n\tint m=0,s=0,p=0;\n\tint temp=0;\n\t\n\tfor (int i = 0; i < S.length; i++) {\n\t\tS[i]=scan.next();\n\t\tif(S[i].indexOf('m')!=-1) m++;\n\t\tif(S[i].indexOf('s')!=-1) s++;\n\t\tif(S[i].indexOf('p')!=-1) p++;\n\t}\n\t\n\t\n\tint n1 = Integer.parseInt(S[0].substring(0,1));\n\tint n2 = Integer.parseInt(S[1].substring(0,1));\n\tint n3 = Integer.parseInt(S[2].substring(0,1));\n\t\n\t\n\t\n\t    int d3 = Math.abs(n1-n2);\n\t\tint d4 = Math.abs(n1-n3);\n\t\tint d5 = Math.abs(n2-n3);\n\t\t\n\t\n\tif(m==3||s==3||p==3) {\n\t\t\n\t\t    if(d3==1&d5==1&d4==2||d3==1&d4==1&d5==2||d5==1&d4==1&d3==2)\n\t\t\tSystem.out.println(0);\n\t\telse \n\t\t    if(d3==0&d4==0) System.out.println(0);\n\t\telse \n\t\t\tif(d3<d5&d3<d4) {\n\t\t\t    if(d3==1||d3==2||d3==0) System.out.println(1);\n\t\t        else                 System.out.println(2);\n\t\t\t    }\n\t\t\telse if (d5<d4&d5<d3){\n\t\t\t\t if(d5==1||d5==2||d5==0) System.out.println(1);\n\t\t\t\t\telse                 System.out.println(2);\n\t\t\t}\n\t\t\telse if(d4<d5&d4<d3) {\n\t\t\t\tif(d4==1||d4==2||d4==0) System.out.println(1);\n\t\t\t\telse                 System.out.println(2);\n\t\t\t}\n\t\t\telse if(d3==2&d5==2||d4==2&d5==2||d3==2&d4==2||d3==1&d5==1||d4==1&d5==1||d3==2&d4==1)\n\t\t\t\tSystem.out.println(1);\n\t\t\telse System.out.println(2);\n\t\t\t\n\t\t\t\n\t\t\n\t\t \n\t\t    \n\t\t    \n\t}\n\t\n\tif(m==2||s==2||p==2) {\n\t\t\n\t\t\n\t\t\n\t\tchar c1 = S[0].charAt(1);\n\t\tchar c2 = S[1].charAt(1);\n\t\tchar c3 = S[2].charAt(1);\n\t\t\n\t\t\n\t\tif(c1==c2) {\n\t\t\tif(n1==n2) System.out.println(1);\n\t\t\telse if(d3==1||d3==2) System.out.println(1);\n\t\t\telse System.out.println(2);\n\t\t}\n\t\tif(c1==c3) {\n\t\t\tif(n1==n3) System.out.println(1);\n\t\t\telse if(d4==1||d4==2) System.out.println(1);\n\t\t\telse System.out.println(2);\n\t\t}\n\t\tif(c2==c3) {\n\t\t\tif(n2==n3) System.out.println(1);\n\t\t\telse if(d5==1||d5==2) System.out.println(1);\n\t\t\telse System.out.println(2);\n\t\t}\n\t}\n\t\n\tif(m==1&s==1&p==1) System.out.println(2);\n\t\t\n\t\n\t\n}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 808, "index": 808}
{"src": "import java.io.IOException;\nimport java.util.*;\n\npublic class Main implements Runnable {\n  static String readLn(int maxLength) {\n\n    byte line[] = new byte[maxLength];\n    int length = 0;\n    int input = -1;\n    try {\n      while (length < maxLength) {\n        input = System.in.read();\n        if ((input < 0) || (input == '\\n')) {\n          break;\n        }\n\n        line[length++] += input;\n      }\n\n      if ((input < 0) && (length == 0)) {\n        return null;\n      }\n\n      return new String(line, 0, length);\n    } catch (IOException e) {\n      return null;\n    }\n  }\n\n  public static void main(String args[]) {\n    Main myWork = new Main();\n    myWork.run();\n  }\n\n  public void run() {\n    new Watermelon().run();\n  }\n}\n\nclass Watermelon implements Runnable {\n  public void run() {\n    String line = Main.readLn(100).trim();\n    int weight = Integer.parseInt(line);\n    System.out.println(weight % 2 == 0 && weight > 2 ? \"YES\": \"NO\");\n  }\n}", "complexity": "constant", "from": "CorCod", "problem": 809, "index": 809}
{"src": "\timport java.io.BufferedReader;\n\t\n\timport java.io.IOException;\n\timport java.io.InputStream;\n\timport java.io.InputStreamReader;\n\timport java.io.PrintWriter;\n\timport java.util.*;\n\t\n\timport javax.print.attribute.standard.QueuedJobCount;\n\t\n\tpublic class A {\n\t\tstatic int n;\n\t\tstatic TreeSet<Integer> Primes;\n\t\tstatic int[] arr;\n\t\tstatic int[] arr2;\n\t\n\t\tpublic static int[] copyOf(int[] arr) {\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tarr2[i] += arr[i];\n\t\t\treturn arr2;\n\t\t}\n\t\n\t\tpublic static long addEvens(int[] arr) {\n\t\t\tlong r = 0;\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tif (arr[i] % 2 == 0)\n\t\t\t\t\tr += arr[i];\n\t\t\treturn r;\n\t\t}\n\t\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\tarr = new int[14];\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tarr[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint x = 5535;\n\t\t\tint y = x;\n\t\t\tint s;\n\t\t\tlong max = Integer.MIN_VALUE;\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tint a = arr[i];\n\t\t\t\tarr2 = new int[14];\n\t\t\t\tarr2 = copyOf(arr);\n\t\t\t\tarr2[i]=0;\n\t\t\t\tint j =0;\n\t\t\t\tint rem = arr[i] / 14;\n\t\t\t\tint steps = 0;\n\t\t\t\tint c = 0;\n\t\t\t\tfor (  j = i+1;c<14; j++) {\n\t\t\t\t\tif (j >=14 )\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[c] += rem;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tsteps = arr[i] % 14;\n\t\t\t\tj = i;\n\t\t\t\tc=0;\n\t\t\t\tint adasd;\n\t\t\t\tfor ( j = i+1;c<steps; j++) {\n\t\t\t\t\tif (j >= 14)\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[j] += 1;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, addEvens(arr2));\n\t\t\t}\n\t\t\tpw.print(max);\n\t\n\t\t\tpw.flush();\n\t\t}\n\t\n\t\n\t\n\t}\n", "complexity": "constant", "from": "CorCod", "problem": 810, "index": 810}
{"src": "import java.util.Scanner;\n\npublic class SashaAndHisTrip {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int v = in.nextInt();\n        if (v > N) {\n            System.out.println(N-1);\n        }\n        else {\n            int price = v + ((N-v-1) * (2+ N - v))/2;\n            int counter = 0;\n            System.out.println(price);\n        }\n    }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 811, "index": 811}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Codechef{\n\t\n\n    public static void main(String []args){\n    \t\t\tScanner in = new Scanner(System.in);\n\n    long n=in.nextLong();\n\t\tlong m=in.nextLong();\n\t\tlong k=in.nextLong();\n\t\tlong l=in.nextLong();\n \n\t\tlong j=((k+l)/m);\n\t\tif((k+l)%m!=0)j++;\n\t\tif((k+l>n) || j*m>n) {\n\t\t\tSystem.out.println(-1);\n\t\t}else {\n\t\t\t\n\t\t\tSystem.out.println(j);\n\t\t}\n\n\n    }\n\n}", "complexity": "constant", "from": "CorCod", "problem": 812, "index": 812}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class cf2 {\n\tstatic final double EPS = 1e-9;\n\n  public static void main(String[] args) throws IOException {\n\t Scanner sc = new Scanner(System.in);\n\t\n\t //rec\n\t int xr1=sc.nextInt(), yr1=sc.nextInt(), xr2=sc.nextInt(),yr2=sc.nextInt();\n\t int xr3=sc.nextInt(), yr3=sc.nextInt(), xr4=sc.nextInt(),yr4=sc.nextInt();\n\t\n\t Point pr1 = new Point(xr1, yr1);\n\t Point pr2 = new Point(xr2, yr2);\n\t Point pr3 = new Point(xr3, yr3);\n\t Point pr4 = new Point(xr4, yr4);\n\t \n\t LineSegment lr1 = new LineSegment(pr1, pr2);\n\t LineSegment lr2 = new LineSegment(pr2, pr3);\n\t LineSegment lr3 = new LineSegment(pr3, pr4);\n\t LineSegment lr4 = new LineSegment(pr4, pr1);\n\t \n\t //diamond\n\t int xd1=sc.nextInt(), yd1=sc.nextInt(), xd2=sc.nextInt(),yd2=sc.nextInt();\n\t int xd3=sc.nextInt(), yd3=sc.nextInt(), xd4=sc.nextInt(),yd4=sc.nextInt();\n\t \n\t Point p1 = new Point(xd1, yd1);\n\t Point p2 = new Point(xd2, yd2);\n\t Point p3 = new Point(xd3, yd3);\n\t Point p4 = new Point(xd4, yd4);\n\t \n\t Point [] pt = new Point [5];\n\t pt[0]=p1;  pt[1]=p2;  pt[2]=p3;  pt[3]=p4;  pt[4]=p1;\n\t Polygon pg = new Polygon(pt);\n\t \n\t if(pg.inside(pr1)||pg.inside(pr2)||pg.inside(pr3)||pg.inside(pr4)) {\n\t\t System.out.println(\"YES\");\n\t\t return;\n\t }\n\t\n\t \n\t LineSegment ld1 = new LineSegment(p1, p2);\n\t LineSegment ld2 = new LineSegment(p2, p3);\n\t LineSegment ld3 = new LineSegment(p3, p4);\n\t LineSegment ld4 = new LineSegment(p4, p1);\n\t \n\t Rectangle rec = new Rectangle(new Point(Math.min(Math.min(xr3,xr4),Math.min(xr1,xr2)), Math.min(Math.min(yr3,yr4),Math.min(yr1,yr2))), \n\t\t\t new Point(Math.max(Math.max(xr3,xr4),Math.max(xr1,xr2)), Math.max(Math.max(yr3,yr4),Math.max(yr1,yr2))) );\n\t \n\t if(rec.contains(p1)||rec.contains(p2)||rec.contains(p3)||rec.contains(p4)) {\n\t\t System.out.println(\"YES\");\n\t     return;\n\t }\n\t \n\t if(ld1.intersect(lr1)||ld1.intersect(lr3)||ld1.intersect(lr3)||ld1.intersect(lr4)) {\n\t\t System.out.println(\"YES\");\n\t     return;\n\t }\n\t \n\t if(ld2.intersect(lr1)||ld2.intersect(lr3)||ld2.intersect(lr3)||ld2.intersect(lr4)) {\n\t\t System.out.println(\"YES\");\n\t     return;\n\t }\n\t \n\t if(ld3.intersect(lr1)||ld3.intersect(lr3)||ld3.intersect(lr3)||ld3.intersect(lr4)) {\n\t\t System.out.println(\"YES\");\n\t     return;\n\t }\n\t \n\t if(ld4.intersect(lr1)||ld4.intersect(lr3)||ld4.intersect(lr3)||ld4.intersect(lr4)) {\n\t\t System.out.println(\"YES\");\n\t     return;\n\t }\n\t \n\t System.out.println(\"NO\");\n\t \n\t \n\t \n\t \n}\n  \n  public static class Polygon { \n\t\t// Cases to handle: collinear points, polygons with n < 3\n\n\t\tstatic final double EPS = 1e-9;\n\t\t\n\t\tPoint[] g; \t\t\t//first point = last point, counter-clockwise representation\n\t\t\n\t\tPolygon(Point[] o) { g = o; }\n\n\t\tdouble perimeter()\n\t\t{\n\t\t\tdouble sum = 0.0;\n\t\t\tfor(int i = 0; i < g.length - 1; ++i)\n\t\t\t\tsum += g[i].dist(g[i+1]);\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tdouble area() \t\t//clockwise/anti-clockwise check, for convex/concave polygons\n\t\t{\n\t\t\tdouble area = 0.0;\n\t\t\tfor(int i = 0; i < g.length - 1; ++i)\n\t\t\t\tarea += g[i].x * g[i+1].y - g[i].y * g[i+1].x;\n\t\t\treturn Math.abs(area) / 2.0;\t\t\t//negative value in case of clockwise\n\t\t}\n\n\t\n\t\t\n\t\tboolean inside(Point p)\t//for convex/concave polygons - winding number algorithm \n\t\t{\n\t\t\tdouble sum = 0.0;\n\t\t\tfor(int i = 0; i < g.length - 1; ++i)\n\t\t\t{\n\t\t\t\tdouble angle = Point.angle(g[i], p, g[i+1]);\n\t\t\t\tif((Math.abs(angle) < EPS || Math.abs(angle - Math.PI) < EPS) && p.between(g[i], g[i+1]))\n\t\t\t\t\treturn true;\n\t\t\t\tif(Point.ccw(p, g[i], g[i+1]))\n\t\t\t\t\tsum += angle;\n\t\t\t\telse\n\t\t\t\t\tsum -= angle;\n\t\t\t}\n\n\t\t\treturn Math.abs(2 * Math.PI - Math.abs(sum)) < EPS;\t\t//abs makes it work for clockwise\n\t\t}\n\t\t/*\n\t\t * Another way if the polygon is convex\n\t\t * 1. Triangulate the poylgon through p\n\t\t * 2. Check if sum areas == poygon area\n\t\t * 3. Handle empty polygon\n\t\t */\n\t\t\n\t\t\n\n\t\n\t\tPoint centroid()\t\t//center of mass\n\t\t{\n\t\t\tdouble cx = 0.0, cy = 0.0;\n\t\t\tfor(int i = 0; i < g.length - 1; i++)\n\t\t\t{\n\t\t\t\tdouble x1 = g[i].x, y1 = g[i].y;\n\t\t\t\tdouble x2 = g[i+1].x, y2 = g[i+1].y;\n\n\t\t\t\tdouble f = x1 * y2 - x2 * y1;\n\t\t\t\tcx += (x1 + x2) * f;\n\t\t\t\tcy += (y1 + y2) * f;\n\t\t\t}\n\t\t\tdouble area = area();\t\t//remove abs\n\t\t\tcx /= 6.0 * area;\n\t\t\tcy /= 6.0 * area;\n\t\t\treturn new Point(cx, cy);\n\t\t}\n\t}\n  \n   static class LineSegment {\n\n\t\tPoint p, q;\n\t\t\n\t\tLineSegment(Point a, Point b) { p = a; q = b; }\n\t\t\n\n\t\tboolean intersect(LineSegment ls)\n\t\t{\n\t\t\tLine l1 = new Line(p, q), l2 = new Line(ls.p, ls.q);\n\t\t\tif(l1.parallel(l2))\n\t\t\t{\n\t\t\t\tif(l1.same(l2))\n\t\t\t\t\treturn p.between(ls.p, ls.q) || q.between(ls.p, ls.q) || ls.p.between(p, q) || ls.q.between(p, q);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tPoint c = l1.intersect(l2);\n\t\t\treturn c.between(p, q) && c.between(ls.p, ls.q);\n\t\t}\n\n\t}\n  \n   static class Rectangle {\n\n\t\tstatic final double EPS = 1e-9;\n\t\t\n\t\tPoint ll, ur;\n\n\t\tRectangle(Point a, Point b) { ll = a; ur = b; }\n\n\t\tdouble area() { return (ur.x - ll.x) * (ur.y - ll.y); }\n\n\t\tboolean contains(Point p)\n\t\t{\n\t\t\treturn p.x <= ur.x + EPS && p.x + EPS >= ll.x && p.y <= ur.y + EPS && p.y + EPS >= ll.y;\n\t\t}\n\n\t\tRectangle intersect(Rectangle r)\n\t\t{\n\t\t\tPoint ll = new Point(Math.max(this.ll.x, r.ll.x), Math.max(this.ll.y, r.ll.y));\n\t\t\tPoint ur = new Point(Math.min(this.ur.x, r.ur.x), Math.min(this.ur.y, r.ur.y));\n\t\t\tif(Math.abs(ur.x - ll.x) > EPS && Math.abs(ur.y - ll.y) > EPS && this.contains(ll) && this.contains(ur) && r.contains(ll) && r.contains(ur))\n\t\t\t\treturn new Rectangle(ll, ur);\n\t\t\treturn null;\n\t\t}\n\n\t}\n   static class Line {\n\n\t\tstatic final double INF = 1e9, EPS = 1e-9;\n\t\t\n\t\tdouble a, b, c;\n\t\t\n\t\tLine(Point p, Point q)\n\t\t{\n\t\t\tif(Math.abs(p.x - q.x) < EPS) {\ta = 1; b = 0; c = -p.x;\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta = (p.y - q.y) / (q.x - p.x);\n\t\t\t\tb = 1.0;\n\t\t\t\tc = -(a * p.x + p.y);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t}\n\t\t\n\t\tLine(Point p, double m) { a = -m; b = 1; c =  -(a * p.x + p.y); } \n\t\t\n\t\tboolean parallel(Line l) { return Math.abs(a - l.a) < EPS && Math.abs(b - l.b) < EPS; }\n\t\t\n\t\tboolean same(Line l) { return parallel(l) && Math.abs(c - l.c) < EPS; }\n\t\t\n\t\tPoint intersect(Line l)\n\t\t{\n\t\t\tif(parallel(l))\n\t\t\t\treturn null;\n\t\t\tdouble x = (b * l.c - c * l.b) / (a * l.b - b * l.a);\n\t\t\tdouble y;\n\t\t\tif(Math.abs(b) < EPS)\n\t\t\t\t y = -l.a * x - l.c;\n\t\t\telse\n\t\t\t\ty = -a * x - c;\n\t\t\t\n\t\t\treturn new Point(x, y);\n\t\t}\n\t\t\n\t\tPoint closestPoint(Point p)\n\t\t{\n\t\t\tif(Math.abs(b) < EPS) return new Point(-c, p.y);\n\t\t\tif(Math.abs(a) < EPS) return new Point(p.x, -c);\n\t\t\treturn intersect(new Line(p, 1 / a));\n\t\t}\n\t\t\t\t\n\t}\n\n   public static class Vector {\n\n\t\tdouble x, y; \n\n\t\tVector(double a, double b) { x = a; y = b; }\n\n\t\tVector(Point a, Point b) { this(b.x - a.x, b.y - a.y); }\n\n\t\tVector scale(double s) { return new Vector(x * s, y * s); }              //s is a non-negative value\n\n\t\tdouble dot(Vector v) { return (x * v.x + y * v.y); }\n\n\t\tdouble cross(Vector v) { return x * v.y - y * v.x; }\n\n\t\tdouble norm2() { return x * x + y * y; }\n\n\t\tVector reverse() { return new Vector(-x, -y); }\n\n\t\tVector normalize() \n\t\t{ \n\t\t\tdouble d = Math.sqrt(norm2());\n\t\t\treturn scale(1 / d);\n\t\t}\t\t\n\t}\n   \n   static class Point implements Comparable<Point>{\n\n\t\tstatic final double EPS = 1e-9;\n\n\t\tdouble x, y;                  \n\n\t\tPoint(double a, double b) { x = a; y = b; }  \n\t\t\n\t\tpublic int compareTo(Point p)\n\t\t{\n\t\t\tif(Math.abs(x - p.x) > EPS) return x > p.x ? 1 : -1;\n\t\t\tif(Math.abs(y - p.y) > EPS) return y > p.y ? 1 : -1;\n\t\t\treturn 0;\n\t\t}\n\t\tstatic double angle(Point a, Point o, Point b)  // angle AOB\n\t\t{\n\t\t\tVector oa = new Vector(o, a), ob = new Vector(o, b);\n\t\t\treturn Math.acos(oa.dot(ob) / Math.sqrt(oa.norm2() * ob.norm2()));\n\t\t}\n\t\tstatic boolean ccw(Point p, Point q, Point r)\n\t\t{\n\t\t\treturn new Vector(p, q).cross(new Vector(p, r)) > 0;\n\t\t}\n\t\t\n\t\tpublic double dist(Point p) { return Math.sqrt(sq(x - p.x) + sq(y - p.y)); }\n\t\t\n\t\tstatic double sq(double x) { return x * x; }\n\t\t\n\t\tPoint rotate(double angle)\n\t\t{\n\t\t\tdouble c = Math.cos(angle), s = Math.sin(angle);\n\t\t\treturn new Point(x * c - y * s, x * s + y * c);\n\t\t}\n\t\t// for integer points and rotation by 90 (counterclockwise) : swap x and y, negate x\n\t\t\n\t\n\t\t\n\t\tboolean between(Point p, Point q)\n\t\t{\n\t\t\treturn x < Math.max(p.x, q.x) + EPS && x + EPS > Math.min(p.x, q.x)\n\t\t\t\t\t&& y < Math.max(p.y, q.y) + EPS && y + EPS > Math.min(p.y, q.y);\n\t\t}\n\t\t\n\t\t//returns true if it is on the line defined by a and b\n\t\n\t\t//returns true if it is on the ray whose start point is a and passes through b\n\t\t// Another way: find closest point and calculate the distance between it and p\n\t}\n  \n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic Scanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic long nextlong() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tlong res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 813, "index": 813}
{"src": "import java.util.*;import java.lang.*;import java.io.*;\npublic class Codechef\n{   static PrintWriter out=new PrintWriter(System.out);\n\tstatic FastScanner in = new FastScanner(System.in);\n     static class FastScanner {BufferedReader br;StringTokenizer stok;FastScanner(InputStream is) {br = new BufferedReader(new InputStreamReader(is));}\n        String next() throws IOException {while (stok == null || !stok.hasMoreTokens()) {String s = br.readLine();if (s == null) {return null;}\n                stok = new StringTokenizer(s);}return stok.nextToken();}\n        int ni() throws IOException {    return Integer.parseInt(next());}\n        long nl() throws IOException {return Long.parseLong(next());}\n        double nd() throws IOException {return Double.parseDouble(next());}\n        char nc() throws IOException {return (char) (br.read());}\n        String ns() throws IOException {return br.readLine();}\n        int[] nia(int n) throws IOException{int a[] = new int[n];for (int i = 0; i < n; i++)a[i] = ni();return a;}\n        long[] nla(int n) throws IOException {\n            long a[] = new long[n];for (int i = 0; i < n; i++)a[i] = nl();return a;}\n        double[] nda(int n)throws IOException {double a[] = new double[n];for (int i = 0; i < n; i++)        a[i] = nd();    return a;}\n        int [][] imat(int n,int m) throws IOException\n        {   int mat[][]=new int[n][m];for(int i=0;i<n;i++){   for(int j=0;j<m;j++)mat[i][j]=ni();}return mat;}\n    }\n        \n    ///MAIN METHOD\n    \n    \n    \n    \n\tstatic long mod=Long.MAX_VALUE;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{   int i,j;\n\t    HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();\n\t\t/*  if(hm.containsKey(z))\n\t\t        hm.put(z,hm.get(z)+1);\n\t\t    else\n\t\t        hm.put(z,1);\n\t\t */       \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        HashSet<Integer> set=new HashSet<Integer>();\n        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\n        /*  int n = in.ni();\n            int m = in.ni();\n            String s=in.ns();\n            int a[]=in.nia(n);\n            int b[][]=in.im(n,m);\n            pia(a);\n\t\t    pimat(b);\n            sort(a,0,a.length-1);\n        */\n        long n=in.nl();\n        long v=in.nl();\n        long temp=n-1;\n        long ans=0;\n          \n        ans+=Math.min(v,temp);\n        temp-=v;\n\t    \n\t    if(temp>0)\n            ans+=((temp+1)*(temp+2))/(long)2-1;\n        \n        \n        out.println(ans);\n        out.close();\n\t}\n\t\n\t\n\t\n\t\n\t\n\tstatic long gcd(long a,long b)\n\t{   if(b==0)\n\t        return a;\n\t    return gcd(b,a%b);    \n\t}\n\tstatic long exponent(long a,long n)\n\t{   long ans=1;\n\t    while(n!=0)\n\t    {   if(n%2==1)\n\t            ans=(ans*a)%mod;\n\t       a=(a*a)%mod;\n\t       n=n>>1;\n\t    }\n\t    return ans;\n\t}\n\tstatic int binarySearch(int a[], int item, int low, int high) \n    {   if (high <= low) \n            return (item > a[low])?  (low + 1): low; \n        int mid = (low + high)/2; \n        if(item == a[mid]) \n            return mid+1; \n        if(item > a[mid]) \n            return binarySearch(a, item, mid+1, high); \n        return binarySearch(a, item, low, mid-1); \n    } \n   static void merge(int arr[], int l, int m, int r) \n    {   int n1 = m - l + 1; int n2 = r - m; int L[] = new int [n1]; int R[] = new int [n2]; \n        \n        for (int i=0; i<n1; ++i) L[i] = arr[l + i]; for (int j=0; j<n2; ++j) R[j] = arr[m + 1+ j]; int i = 0, j = 0; int k = l; \n        while (i < n1 && j < n2) {   if (L[i] <= R[j]) {   arr[k] = L[i]; i++; } else{   arr[k] = R[j]; j++; } k++; } while (i < n1){   arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j];   j++;     k++; } \n    } \n    static void Sort(int arr[], int l, int r) \n    {    if (l < r) {   int m = (l+r)/2; Sort(arr, l, m); Sort(arr , m+1, r); merge(arr, l, m, r); } } \n    \n    static void sort(int a[])\n    {Sort(a,0,a.length-1);}\n\n}", "complexity": "constant", "from": "CorCod", "problem": 814, "index": 814}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n    static StringBuilder data;\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt();\n               long answ = 0;\n        if (n * 2 > k) {\n         if((n*2)%k==0){\n             answ+=(n*2)/k;\n         }else{\n             answ+=((n*2)/k)+1;\n         }\n        }else{\n            answ++;\n        }\n        if (n * 5 > k) {\n            if((n*5)%k==0){\n                answ+=(n*5)/k;\n            }else{\n                answ+=((n*5)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n        if (n * 8 > k) {\n            if((n*8)%k==0){\n                answ+=(n*8)/k;\n            }else{\n                answ+=((n*8)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "complexity": "constant", "from": "CorCod", "problem": 815, "index": 815}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.Stack;\n\n\nimport java.util.StringTokenizer;\n\n\n public class Test\n {\n    \n     static PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args)throws Exception\n    {\n        Reader.init(System.in);\n        int n = Reader.nextInt();\n        int p = Reader.nextInt();\n        int L = Reader.nextInt();\n        int R = Reader.nextInt();\n        int a = 1;\n        int b = n;\n        int res = 0;\n        \n        if(a == L && b == R)\n        {\n            res = 0;\n        }\n        else if(L != a && R != b && p >= L && p <= R)\n        {\n            res = Math.min(p-L, R-p);\n            res += R- L + 2;\n        }\n        else if(L != a && R != b && p < L )\n        {\n            res += L-p + 1;\n            res += R - L +1;\n        }\n        else if(L != a && R != b && p > R)\n        {\n            res += p-R + 1;\n            res += R - L +1;\n        }\n        else if(a == L && p >=L && p<=R)\n        {\n            res += R - p + 1;\n        }\n        else if(R == b && p>=L && p<=R)\n        {\n            res += p - L + 1;\n        }\n        else if(a == L && p > R)\n        {\n            res += p - R + 1;\n        }\n        else if(R == b && p<L)\n        {\n            res += L - p + 1;\n        }\n            \n            \n        pw.print(res);\n        pw.close();\n \n    }\n        \n}\n\nclass Reader {\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    public static int pars(String x) {\n        int num = 0;\n        int i = 0;\n        if (x.charAt(0) == '-') {\n            i = 1;\n        }\n        for (; i < x.length(); i++) {\n            num = num * 10 + (x.charAt(i) - '0');\n        }\n\n        if (x.charAt(0) == '-') {\n            return -num;\n        }\n\n        return num;\n    }\n\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                new InputStreamReader(input));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    static void init(FileReader input) {\n        reader = new BufferedReader(input);\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(\n                    reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return pars(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 816, "index": 816}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\t\tlong n,s,p;\n\t\t\tScanner in=new Scanner(System.in);\n\t\t\tn=in.nextLong();\n\t\t\ts=in.nextLong();\n\t\t\tif(n==1 && s<=1)\n\t\t\t{\n\t\t\t    System.out.print(n-1);\n\t\t\t}\n\t        else if(s<n)\n\t        {\n\t            if(s%2!=0)\n\t\t        {System.out.print(s/2);}\n\t\t        else\n\t\t        {System.out.print(s/2-1);}\n\t        }\n\t        else if(s==n)\n\t{\n\t    if(s%2==0)\n\t\t{System.out.println((n/2)-1);}\n\t\telse\n\t\t{System.out.println(n/2);}\n\t}\n\telse if(s<=(2*n-1))\t\n\t{\n\t\tSystem.out.print((2*n+1-s)/2);\n\t}\n\telse\n\t{\n\t\tSystem.out.print(0);\n\t}\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 817, "index": 817}
{"src": "import java.util.*;\n\npublic class A912 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tint A = scan.nextInt();\n\t\tint B = scan.nextInt();\n\t\tlong x = scan.nextInt();\n\t\tlong y = scan.nextInt();\n\t\tlong z = scan.nextInt();\n\t\t\n\t\tlong requiredA = x * 2 + y;\n\t\tlong requiredB = y + z * 3;\n\t\t\n\t\tlong neededA = Math.max(0, requiredA - A);\n\t\tlong neededB = Math.max(0, requiredB - B);\n\t\tSystem.out.print(neededA + neededB);\n\t}\n\n}\n", "complexity": "constant", "from": "CorCod", "problem": 818, "index": 818}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint a = in.nextInt();\n\t\tint b = in.nextInt();\n\t\tint c = in.nextInt();\n\t\tint n = in.nextInt();\n\n\t\tint ans = n - (a + b - c);\n\t\tif(ans < 1 || a >= n || b >= n || c > a || c > b)\n\t\t\tans = -1;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 819, "index": 819}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class PizzaPizzaPizza {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong n = nextLong();\n\t\tif (n == 0)\n\t\t\tSystem.out.println(0);\n\t\telse if (n % 2 == 0)\n\t\t\tSystem.out.println(n+1);\n\t\telse\n\t\t\tSystem.out.println((n+1)/2);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 820, "index": 820}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class DS {\n\n    /*\n     * Complete the twoStacks function below.\n     */\n   \n\n\n\n    public static void main(String[] args) throws IOException {\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       int x=Integer.parseInt(br.readLine());\n         \nif (x==1)\n            System.out.println(-1);\nelse\n            System.out.println(x+\" \"+x);\n\n        }\n\n        \n    }", "complexity": "constant", "from": "CorCod", "problem": 821, "index": 821}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tlong n = sc.nextLong();\n\t\tlong k = sc.nextLong();\n\t\tSystem.out.println(solve(n, k));\n\n\t\tsc.close();\n\t}\n\n\tstatic long solve(long n, long k) {\n\t\treturn Math.max(0, Math.min(n, k - 1) - ((k + 2) / 2) + 1);\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 822, "index": 822}
{"src": "\nimport java.util.Scanner;\n\npublic class origami {\n\tpublic static void main(String args[]){\n\t\tScanner input = new Scanner(System.in);\n\t\tdouble n = input.nextInt();\n\t\tdouble k = input.nextInt();\n\t\tdouble red = 0;\n\t\tdouble green = 0;\n\t\tdouble blue = 0;\n\t\tdouble ans = 0;\n\t\tred = (2 * n) / k;\n\t\tgreen = (5 * n) / k;\n\t\tblue = (8 * n) / k;\n\n\t\tdouble red1 = Math.ceil(red) ;\n\t\tdouble green1 = Math.ceil(green);\n\t\tdouble blue1 = Math.ceil(blue);\n\n\t\tans+=red1;\n\t\tans+=green1;\n\t\tans+=blue1;\n\t\tDouble answer = new Double(ans);\n\t\tint finished = answer.intValue();\n\t\tSystem.out.println(finished);\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 823, "index": 823}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class C_NNAndTheOpticalIllusion {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            double n = inp.nextInt(), r = inp.nextInt();\n            double x = Math.cos((n - 2) * Math.PI / (2 * n));\n            out.print((r * x) / (1 - x));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 824, "index": 824}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tint n = Integer.parseInt(input);\n\t\t\tinput = br.readLine();\n\t\t\tint qx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint qy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint kx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint ky = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint gx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint gy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tif((kx<qx && gx<qx)||(kx>qx && gx>qx)) {\n\t\t\t\tif((ky<qy && gy<qy)||(ky>qy && gy>qy))System.out.println(\"YES\");\n\t\t\t\telse System.out.println(\"NO\");\n\t\t\t}else System.out.println(\"NO\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n", "complexity": "constant", "from": "CorCod", "problem": 825, "index": 825}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author fintech\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        KingEscape solver = new KingEscape();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class KingEscape {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int qx = in.nextInt();\n            int qy = in.nextInt();\n            int kx = in.nextInt();\n            int ky = in.nextInt();\n            int safex = in.nextInt();\n            int safey = in.nextInt();\n            boolean possible = false;\n            if (qx > Math.max(kx, safex) || qx < Math.min(kx, safex)) {\n                if (qy > Math.max(ky, safey) || qy < Math.min(ky, safey)) {\n                    possible = true;\n                }\n            }\n            if (possible) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "complexity": "constant", "from": "CorCod", "problem": 826, "index": 826}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static char returnLetter(int n)\n\t{\n\t\tif(n%4==1)\n\t\t{\n\t\t\treturn 'A';\n\t\t}\n\t\telse if(n%4==3)\n\t\t{\n\t\t\treturn 'B';\n\t\t}\n\t\telse if(n%4==2)\n\t\t{\n\t\t\treturn 'C';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'D';\n\t\t}\n\t}\n\t/*public static void main(String[] args) throws IOException {\n\t\tint n=sc.nextInt();\n\t\t\n\t\tint zero=n;\n\t\tint one=n+1;\n\t\tint two=n+2;\n\t\tchar z=returnLetter(zero);\n\t\tchar o=returnLetter(one);\n\t\tchar t=returnLetter(two);\n\t\t\n\t\tif(z<o && z<t)\n\t\t{\n\t\t\tSystem.out.println(\"0 \" + z);\n\t\t}\n\t\telse if(o<z && o<t)\n\t\t{\n\t\t\tSystem.out.println(\"1 \" + o);\n\t\t}\n\t\telse if(t<z && o>t)\n\t\t{\n\t\t\tSystem.out.println(\"2 \" + t);\n\t\t}\n\t}*/\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tString[] a= new String[3];\n\t\t\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i]=sc.next();\n\t\t}\n\t\tboolean equal=true;\n\t\t\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)!=a[i-1].charAt(0))\n\t\t\t{\n\t\t\t\tequal=false;break;\n\t\t\t}\n\t\t}\n\t\tif(equal)\n\t\t{\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tArrays.sort(a);\n\t\t\tboolean ord=true;\n\t\t\t\n\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)-a[i-1].charAt(0)!=1)\n\t\t\t\t{\n\t\t\t\t\tord=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord)\n\t\t\t{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)==a[0].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[1].charAt(0)==a[2].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tint start = 0;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 827, "index": 827}
{"src": "\n// Java program to keep track of maximum \n// element in a stack \nimport\njava.util.*; \nclass\nGfG { \n\nstatic\nclass\nStackWithMax \n{ \n\n// main stack \n\nstatic\nStack<Integer> mainStack = \nnew\nStack<Integer> (); \n\n\n// tack to keep track of max element \n\nstatic\nStack<Integer> trackStack = \nnew\nStack<Integer> (); \n\nstatic\nvoid\npush(\nint\nx) \n\n{ \n\nmainStack.push(x); \n\nif\n(mainStack.size() == \n1\n) \n\n{ \n\ntrackStack.push(x); \n\nreturn\n; \n\n} \n\n\n// If current element is greater than \n\n// the top element of track stack, push \n\n// the current element to track stack \n\n// otherwise push the element at top of \n\n// track stack again into it. \n\nif\n(x > trackStack.peek()) \n\ntrackStack.push(x); \n\nelse\n\ntrackStack.push(trackStack.peek()); \n\n} \n\n\nstatic\nint\ngetMax() \n\n{ \n\nreturn\ntrackStack.peek(); \n\n} \n\n\nstatic\nvoid\npop() \n\n{ \n\nmainStack.pop(); \n\ntrackStack.pop(); \n\n} \n}; \n\n// Driver program to test above functions \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nStackWithMax s = \nnew\nStackWithMax(); \n\ns.push(\n20\n); \n\nSystem.out.println(s.getMax()); \n\ns.push(\n10\n); \n\nSystem.out.println(s.getMax()); \n\ns.push(\n50\n); \n\nSystem.out.println(s.getMax()); \n} \n} ", "complexity": "constant", "from": "CorCod", "problem": 828, "index": 828}
{"src": "\n// Java program to split a number into maximum \n// number of composite numbers. \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// function to calculate the maximum number of \n\n// composite numbers adding upto n \n\nstatic\nint\ncount(\nint\nn) \n\n{ \n\n// 4 is the smallest composite number \n\nif\n(n < \n4\n) \n\nreturn\n-\n1\n; \n\n\n// stores the remainder when n is divided \n\n// by 4 \n\nint\nrem = n % \n4\n; \n\n\n// if remainder is 0, then it is perfectly \n\n// divisible by 4. \n\nif\n(rem == \n0\n) \n\nreturn\nn / \n4\n; \n\n\n// if the remainder is 1 \n\nif\n(rem == \n1\n) { \n\n\n// If the number is less then 9, that \n\n// is 5, then it cannot be expressed as \n\n// 4 is the only composite number less \n\n// than 5 \n\nif\n(n < \n9\n) \n\nreturn\n-\n1\n; \n\n\n// If the number is greater then 8, and \n\n// has a remainder of 1, then express n \n\n// as n-9 a and it is perfectly divisible \n\n// by 4 and for 9, count 1. \n\nreturn\n(n - \n9\n) / \n4\n+ \n1\n; \n\n} \n\n\n\n// When remainder is 2, just subtract 6 from n, \n\n// so that n is perfectly divisible by 4 and \n\n// count 1 for 6 which is subtracted. \n\nif\n(rem == \n2\n) \n\nreturn\n(n - \n6\n) / \n4\n+ \n1\n; \n\n\n\n// if the number is 7, 11 which cannot be \n\n// expressed as sum of any composite numbers \n\nif\n(rem == \n3\n) \n\n{ \n\nif\n(n < \n15\n) \n\nreturn\n-\n1\n; \n\n\n// when the remainder is 3, then subtract \n\n// 15 from it and n becomes perfectly \n\n// divisible by 4 and we add 2 for 9 and 6, \n\n// which is getting subtracted to make n \n\n// perfectly divisible by 4. \n\nreturn\n(n - \n15\n) / \n4\n+ \n2\n; \n\n} \n\nreturn\n0\n; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n90\n; \n\nSystem.out.println(count(n)); \n\n\nn = \n143\n; \n\nSystem.out.println(count(n)); \n\n} \n} \n\n// This code is contributed by vt_m. ", "complexity": "constant", "from": "CorCod", "problem": 829, "index": 829}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class simple implements Runnable {\n\n\n    public void run()\n    {\n\n        InputReader input = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = input.nextInt();\n\n            System.out.println((2*n*n)-(2*n)+1);\n    }\n\n\n\n    class Graph{\n        private final int v;\n        private List<List<Integer>> adj;\n        Graph(int v){\n            this.v = v;\n            adj = new ArrayList<>(v);\n            for(int i=0;i<v;i++){\n                adj.add(new LinkedList<>());\n            }\n        }\n        private void addEdge(int a,int b){\n            adj.get(a).add(b);\n        }\n        private boolean isCyclic()\n        {\n            boolean[] visited = new boolean[v];\n            boolean[] recStack = new boolean[v];\n            for (int i = 0; i < v; i++)\n                if (isCyclicUtil(i, visited, recStack))\n                    return true;\n\n            return false;\n        }\n        private boolean isCyclicUtil(int i, boolean[] visited, boolean[] recStack)\n        {\n            if (recStack[i])\n                return true;\n            if (visited[i])\n                return false;\n            visited[i] = true;\n            recStack[i] = true;\n            List<Integer> children = adj.get(i);\n            for (Integer c: children)\n                if (isCyclicUtil(c, visited, recStack))\n                    return true;\n            recStack[i] = false;\n            return false;\n        }\n    }\n    public static void sortbyColumn(int arr[][], int col)\n    {\n\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f)\n    {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new simple(),\"TaskA\",1<<26).start();\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 830, "index": 830}
{"src": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class problem2 {\n    static class tile implements Comparable<tile> {\n        int number;\n        int suit;\n\n        public int compareTo(tile b){\n\n            return number - b.number;\n        }\n\n    }\n    public static void main(String[] args) {\n\n\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] parts = line.split(\" \");\n\n        tile[] tiles = new tile[3];\n        for(int i = 0; i < 3; i++){\n\n            tiles[i] = new tile();\n            tiles[i].number = parts[i].charAt(0) - '0';\n            if(parts[i].substring(1,2).equals(\"s\"))tiles[i].suit = 1;\n            if(parts[i].substring(1,2).equals(\"m\"))tiles[i].suit = 2;\n            if(parts[i].substring(1,2).equals(\"p\"))tiles[i].suit = 3;\n            //System.out.println(tiles[i].number + \" \"+ tiles[i].suit);\n        }\n        Arrays.sort(tiles);\n\n        int[][] tilesObtained = new int[10][4];\n        int[][] stairCases = new int[10][4];\n        int[][] stairCases2 = new int[10][4];\n        for(int i = 0; i < 3; i++){\n            int currNumber = tiles[i].number;\n            int currSuit = tiles[i].suit;\n\n            tilesObtained[currNumber][currSuit]++;\n            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber-1][currSuit];\n            if(currNumber != 1){\n                if(stairCases2[currNumber-2][currSuit] != 0){\n                    stairCases2[currNumber][currSuit] = 2;\n                }\n                else{\n                    stairCases2[currNumber][currSuit] = 1;\n                }\n            }\n            else{\n                stairCases2[currNumber][currSuit]++;\n            }\n\n\n        }\n        int best = 3;\n\n        for(int i = 1; i <= 9; i++){\n\n            for(int j = 1; j <= 3; j++){\n\n                best = Math.min(best, 3 - tilesObtained[i][j]);\n                best = Math.min(best, 3 - stairCases[i][j]);\n                best = Math.min(best, 3- stairCases2[i][j]);\n                if(best <0)best = 0;\n            }\n        }\n        System.out.println(best);\n\n\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 831, "index": 831}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class B \n{\n\t\n\tstatic StringBuilder st ; \n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner () ;\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tString first = \"\" ; \n\t\tString second = \"\" ; \n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < 126 ;i++ )\n\t\t{\n\t\t\tfirst+= \"9\";\n\t\t\tsecond+=\"9\";\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 125 ;i++ )\n\t\t\tfirst+= \"0\";\n\t\t\n\t\tfirst += \"1\";\n\t\t\n\t\tout.println(first+\" \"+second);\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t\n\t}\n\t\n\tstatic int sumDigits(int num)\n\t{\n\t\tint ans = 0 ;\n\t\t\n\t\twhile(num > 0)\n\t\t{\n\t\t\tans += num % 10  ;\n\t\t\t\n\t\t\tnum /= 10;\n\t\t}\n\t\t\n\t\treturn ans ;\n\t\t\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\n\t\tString next() throws Exception \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception { return Integer.parseInt(next()); }\n\t\t\n\t\tlong nextLong() throws Exception { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble() throws Exception { return Double.parseDouble(next()); }\n\n\t\tchar nextChar() throws Exception { return next().charAt(0); }\n\t\t\n\t\tchar [] nextCharArray() throws Exception{ return next().toCharArray() ; }\n\t}\n\n}\n", "complexity": "constant", "from": "CorCod", "problem": 832, "index": 832}
{"src": "\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class e {\n\npublic static class FastReader {\n\tBufferedReader br;\n\tStringTokenizer st;\n\t//it reads the data about the specified point and divide the data about it ,it is quite fast\n\t//than using direct \n\n\tpublic FastReader() {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tString next() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception r) {\n\t\t\t\tr.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());//converts string to integer\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tString nextLine() {\n\t\tString str = \"\";\n\t\ttry {\n\t\t\tstr = br.readLine();\n\t\t} catch (Exception r) {\n\t\t\tr.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n}\nstatic ArrayList<String>list1=new ArrayList<String>();\nstatic void combine(String instr, StringBuffer outstr, int index,int k)\n{\n\tif(outstr.length()==k)\n\t{\n\t\tlist1.add(outstr.toString());return;\n\t}\n\tif(outstr.toString().length()==0)\n\toutstr.append(instr.charAt(index));\n    for (int i = 0; i < instr.length(); i++)\n    {\n        outstr.append(instr.charAt(i));\n       \n        combine(instr, outstr, i + 1,k);\n        outstr.deleteCharAt(outstr.length() - 1);\n    }\n   index++;\n} \nstatic ArrayList<ArrayList<Integer>>l=new ArrayList<>();\nstatic void comb(int n,int k,int ind,ArrayList<Integer>list)\n{\n\tif(k==0)\n\t{\n\t\tl.add(new ArrayList<>(list));\n\n\t\treturn;\n\t}\n\t\n\t\n\tfor(int i=ind;i<=n;i++)\n\t{\n\t\tlist.add(i);\n\t\tcomb(n,k-1,ind+1,list);\n\t\t\n\t\tlist.remove(list.size()-1);\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\t\n\n}\n\n\npublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\tFastReader in=new FastReader();\n\tHashMap<Integer,Integer>map=new HashMap<Integer,Integer>();\n\n\tint n=in.nextInt();\n\tint r=in.nextInt();\n\t \n\tdouble theta=(double)360/(double)n;\n\t \n\tdouble b=1-((double)2/(double)(1-Math.cos((double)2*Math.PI/(double)n)));\n\tdouble x=Math.sqrt(1-b)-1;\n\tdouble ans=(double)r/(double)x;\n\tSystem.out.println(ans);\n\n\n\n\n\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 833, "index": 833}
{"src": "import java.util.Scanner;\n\npublic class MargariteBestPresent_1080B {\n\n\tprivate static int f(int x) {\n\t\treturn (x%2==0)?x/2:(x-1)/2-x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n,r,l;\n\t\tn = sc.nextInt();\n\t\twhile(n-->0) {\n\t\t\tl = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\n\t\t\tSystem.out.println(f(r)-f(l-1));\n\t\t}\n\t\tsc.close();\n\t}\n\n}\n", "complexity": "constant", "from": "CorCod", "problem": 834, "index": 834}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class EhabAndAnotherConstructionProblem {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint x = nextInt();\n\t\tSystem.out.println(x == 1 ? -1 : x + \" \" + x);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 835, "index": 835}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n *\n * @author luismiguel\n */\npublic class FirstApp {\n    \n    \n \n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solve = new TaskA();\n        solve.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int number = in.nextInt();\n\n            if(number > 2 && number % 2 == 0) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n    }\n    \n}\n", "complexity": "constant", "from": "CorCod", "problem": 836, "index": 836}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class b {\n\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner zizo = new Scanner(System.in);\n\t\tPrintWriter wr = new PrintWriter(System.out);\n\t\t\n\t\tint n1 = 0,n2 = 0,n3 = 0,n4 = 0;\n\t\tint n = 3;\n\t\twhile(n --> 0) {\n\t\t\tint x = zizo.nextInt();\n\t\t\tswitch(x) {\n\t\t\tcase 1:n1++;break;\n\t\t\tcase 4:n4++;break;\n\t\t\tcase 2:n2++;break;\n\t\t\tcase 3:n3++;break;\n\t\t\t}\n\t\t}\n\t\tn2 += n4/2;\n\t\tif(n1>0 || n2>1 || n3>2)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t\twr.close();\n\t}\n}\nclass pair{\n\tint l,r;\n\tpair(int a,int b){l = a;r = b;}\n}\n\nclass Scanner \n{\n\tStringTokenizer st;\n\tBufferedReader br;\n\n\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\tpublic String next() throws IOException \n\t{\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\tpublic double nextDouble() throws IOException\n\t{\n\t\tString x = next();\n\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\tdouble res = 0, f = 1;\n\t\tboolean dec = false, neg = false;\n\t\tint start = 0;\n\t\tif(x.charAt(0) == '-')\n\t\t{\n\t\t\tneg = true;\n\t\t\tstart++;\n\t\t}\n\t\tfor(int i = start; i < x.length(); i++)\n\t\t\tif(x.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\tdec = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\tif(dec)\n\t\t\t\t\tf *= 10;\n\t\t\t}\n\t\tres += Long.parseLong(sb.toString()) / f;\n\t\treturn res * (neg?-1:1);\n\t}\n\n\tpublic boolean ready() throws IOException {return br.ready();}\n}", "complexity": "constant", "from": "CorCod", "problem": 837, "index": 837}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 838, "index": 838}
{"src": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\tint n = sc.nextInt();\n\t\tint pos = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\t/*if(l==r) {\n\t\t\tSystem.out.print(Math.abs(r-pos)+1);\n\t\t}*/\n\t\tif(l==1&&r==n) {\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(l==1&&r<n) {\n\t\t\tSystem.out.println(Math.abs(r-pos)+1);\n\t\t}\n\t\telse if(l>1&&r==n) {\n\t\t\tSystem.out.println(Math.abs(l-pos)+1);\n\t\t}\n\t\telse if(l>1&&r<n) {\n\t\t\tint c = Math.min(Math.abs(r-pos), Math.abs(l-pos));//Math.abs(r-pos)>Math.abs(l-pos)?Math.abs(l-pos):Math.abs(r-pos);\n\t\t\tSystem.out.println(c+2+r-l);\n\t\t}\n\t\t}\n\t}\t\n}\n\n\n\n\n\n", "complexity": "constant", "from": "CorCod", "problem": 839, "index": 839}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class programA {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\tint t1 = (int)Math.ceil((double)n*2/k);\n\t\tint t2 = (int)Math.ceil((double)n*5/k);\n\t\tint t3 = (int)Math.ceil((double)n*8/k);\n\t\tSystem.out.println(t1+t2+t3);\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 840, "index": 840}
{"src": "\n// Java program to delete a node from \n// Doubly Linked List \n\n// Class for Doubly Linked List \npublic\nclass\nDLL { \n\nNode head; \n// head of list \n\n\n/* Doubly Linked list Node*/\n\nclass\nNode { \n\nint\ndata; \n\nNode prev; \n\nNode next; \n\n\n// Constructor to create a new node \n\n// next and prev is by default initialized \n\n// as null \n\nNode(\nint\nd) { data = d; } \n\n} \n\n\n// Adding a node at the front of the list \n\npublic\nvoid\npush(\nint\nnew_data) \n\n{ \n\n// 1. allocate node \n\n// 2. put in the data \n\nNode new_Node = \nnew\nNode(new_data); \n\n\n// 3. Make next of new node as head \n\n// and previous as NULL \n\nnew_Node.next = head; \n\nnew_Node.prev = \nnull\n; \n\n\n// 4. change prev of head node to new node \n\nif\n(head != \nnull\n) \n\nhead.prev = new_Node; \n\n\n// 5. move the head to point to the new node \n\nhead = new_Node; \n\n} \n\n\n// This function prints contents of linked list \n\n// starting from the given node \n\npublic\nvoid\nprintlist(Node node) \n\n{ \n\nNode last = \nnull\n; \n\n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nlast = node; \n\nnode = node.next; \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n// Function to delete a node in a Doubly Linked List. \n\n// head_ref --> pointer to head node pointer. \n\n// del --> data of node to be deleted. \n\nvoid\ndeleteNode(Node head_ref, Node del) \n\n{ \n\n\n// Base case \n\nif\n(head == \nnull\n|| del == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n// If node to be deleted is head node \n\nif\n(head == del) { \n\nhead = del.next; \n\n} \n\n\n// Change next only if node to be deleted \n\n// is NOT the last node \n\nif\n(del.next != \nnull\n) { \n\ndel.next.prev = del.prev; \n\n} \n\n\n// Change prev only if node to be deleted \n\n// is NOT the first node \n\nif\n(del.prev != \nnull\n) { \n\ndel.prev.next = del.next; \n\n} \n\n\n// Finally, free the memory occupied by del \n\nreturn\n; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Start with the empty list \n\nDLL dll = \nnew\nDLL(); \n\n\n// Insert 2. So linked list becomes 2->NULL \n\ndll.push(\n2\n); \n\n\n// Insert 4. So linked list becomes 4->2->NULL \n\ndll.push(\n4\n); \n\n\n// Insert 8. So linked list becomes 8->4->2->NULL \n\ndll.push(\n8\n); \n\n\n// Insert 10. So linked list becomes 10->8->4->2->NULL \n\ndll.push(\n10\n); \n\n\nSystem.out.print(\n\"Created DLL is: \"\n); \n\ndll.printlist(dll.head); \n\n\n// Deleting first node \n\ndll.deleteNode(dll.head, dll.head); \n\n\n// List after deleting first node \n\n// 8->4->2 \n\nSystem.out.print(\n\"\\nList after deleting first node: \"\n); \n\ndll.printlist(dll.head); \n\n\n// Deleting middle node from 8->4->2 \n\ndll.deleteNode(dll.head, dll.head.next); \n\n\nSystem.out.print(\n\"\\nList after Deleting middle node: \"\n); \n\ndll.printlist(dll.head); \n\n} \n} ", "complexity": "constant", "from": "CorCod", "problem": 841, "index": 841}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class SashaAndHisTrip {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\t\n\t\tif (v >= n-1)\n\t\t\tSystem.out.println(n-1);\n\t\telse\n\t\t\tSystem.out.println((n-v)*(n-v+1)/2+v-1);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 842, "index": 842}
{"src": "import java.util.Scanner;\n\n\npublic class IfAtFIrstYouDIdnt {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tint c = input.nextInt();\n\t\tint n  = input.nextInt();\n\t\tif(a<n && b<n && c < n && (a+b-c)<n && c<=a && c<=b){\n\t\t\tSystem.out.println((n)-(a+b-c));\n\t\t}\n\t\telse\n\t\t\tSystem.out.println(\"-1\");\n\t}\n\n}\n", "complexity": "constant", "from": "CorCod", "problem": 843, "index": 843}
{"src": "\n\t\n\t\n\timport java.io.BufferedReader;\n\timport java.io.IOException;\n\timport java.io.InputStreamReader;\n\timport java.io.PrintWriter;\n\timport java.math.BigInteger;\n\timport java.util.*;\n\t\n\t\n\tpublic class usd {\n\t\t\n\t\tstatic int r=0;static int c=0;\n\t\tstatic void fillzero(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[j][i]==0&&a[j+1][i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][i]=1;a[j+1][i]=1;\n\t\t\t\t\t\tr=j;c=i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic void fillone(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[i][j]==0&&a[i][j+1]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i][j]=1;a[i][j+1]=1;\n\t\t\t\t\t\tr=i;c=j;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void check(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[i][0]==1&&a[i][1]==1&&a[i][2]==1&&a[i][3]==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][0]=0;a[i][1]=0;a[i][2]=0;a[i][3]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[0][i]==1&&a[1][i]==1&&a[2][i]==1&&a[3][i]==1)\n\t\t\t\t{\n\t\t\t\t\ta[0][i]=0;a[1][i]=0;a[2][i]=0;a[3][i]=0;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t\t\n\t\t\t\n\t\tScanner in=new Scanner (System.in);\n\t\tHashMap<String,Integer>map=new HashMap<String,Integer>();\n\t\tArrayList<Integer>list=new ArrayList<Integer>();\n\t\nlong n=in.nextLong();\nlong ans=Long.MAX_VALUE;\nlong sum=0;long sum2=(n*(n+1))/2;\nif(sum2%2==0)\nSystem.out.println(0);\nelse\n\tSystem.out.println(1);\n\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n", "complexity": "constant", "from": "CorCod", "problem": 844, "index": 844}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static String conv(String str) {\n\t\tboolean[] Arr = new boolean[26];\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tArr[str.charAt(i) - 'a'] = true;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (Arr[i])\n\t\t\t\tsb.append((char) (i + 'a'));\n\t\t}\n\t\treturn \"\" + sb;\n\t}\n\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<String> hs = new HashSet<String>();\n\t\tint[] Arr = new int[14];\n\t\tlong max = 0;\n\t\tfor (int i = 0; i < 14; i++) {\n\t\t\tArr[i] = sc.nextInt();\n\t\t}\n\n\t\tfor (int i = 0; i < 14; i++) {\n\t\t\tint[] arr = Arr.clone();\n\n\t\t\tlong sum = 0;\n\t\t\tint r = arr[i];\n\t\t\tarr[i] = 0;\n\t\t\tfor (int j = i + 1; j < arr.length && r > 0; j++) {\n\t\t\t\tarr[j]++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tfor (int j = 0; j < arr.length; j++) {\n\t\t\t\tarr[j] +=( r / 14);\n\t\t\t\tif (j + 1 <= (r % 14)) {\n\t\t\t\t\tarr[j]++;\n\t\t\t\t}\n\t\t\t\tif (arr[j] % 2 == 0) {\n\t\t\t\t\tsum += arr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, sum);\n\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 845, "index": 845}
{"src": "import java.util.*;\nimport java.io.*;\n\n\npublic class C994{\n\tstatic double area(double x1,double y1,double x2,double y2,double x3,double y3){\n\t\treturn Math.abs((x1 * (y2 - y3) +  \n        x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0); \n\t}\n\tpublic static void main(String args[])throws IOException{\n\t\tScanner sc=new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\tint x11=sc.nextInt();\n\t\tint y11=sc.nextInt();\n\t\tint x12=sc.nextInt();\n\t\tint y12=sc.nextInt();\n\t\tint x13=sc.nextInt();\n\t\tint y13=sc.nextInt();\n\t\tint x14=sc.nextInt();\n\t\tint y14=sc.nextInt();\n\t\tdouble x1c=(x11+x12+x13+x14)/4.0;\n\t\tdouble y1c=(y11+y12+y13+y14)/4.0;\n\t\tint x21=sc.nextInt();\n\t\tint y21=sc.nextInt();\n\t\tint x22=sc.nextInt();\n\t\tint y22=sc.nextInt();\n\t\tint x23=sc.nextInt();\n\t\tint y23=sc.nextInt();\n\t\tint x24=sc.nextInt();\n\t\tint y24=sc.nextInt();\n\t\tdouble x2c=(x21+x22+x23+x24)/4.0;\n\t\tdouble y2c=(y21+y22+y23+y24)/4.0;\n\t\tdouble a1=area(x11,y11,x12,y12,x13,y13)+area(x11,y11,x13,y13,x14,y14);\n\t\tdouble a2=area(x21,y21,x22,y22,x23,y23)+area(x21,y21,x23,y23,x24,y24);\n\t\tif(a1==area(x11,y11,x12,y12,x21,y21)+area(x11,y11,x21,y21,x14,y14)+area(x21,y21,x12,y12,x13,y13)+area(x21,y21,x14,y14,x13,y13)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a1==area(x11,y11,x12,y12,x22,y22)+area(x11,y11,x22,y22,x14,y14)+area(x22,y22,x12,y12,x13,y13)+area(x22,y22,x14,y14,x13,y13)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a1==area(x11,y11,x12,y12,x23,y23)+area(x11,y11,x23,y23,x14,y14)+area(x23,y23,x12,y12,x13,y13)+area(x23,y23,x14,y14,x13,y13)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a1==area(x11,y11,x12,y12,x24,y24)+area(x11,y11,x24,y24,x14,y14)+area(x24,y24,x12,y12,x13,y13)+area(x24,y24,x14,y14,x13,y13)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a1==area(x11,y11,x12,y12,x2c,y2c)+area(x11,y11,x2c,y2c,x14,y14)+area(x2c,y2c,x12,y12,x13,y13)+area(x2c,y2c,x14,y14,x13,y13)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a2==area(x21,y21,x22,y22,x11,y11)+area(x21,y21,x11,y11,x24,y24)+area(x11,y11,x22,y22,x23,y23)+area(x11,y11,x24,y24,x23,y23)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a2==area(x21,y21,x22,y22,x12,y12)+area(x21,y21,x12,y12,x24,y24)+area(x12,y12,x22,y22,x23,y23)+area(x12,y12,x24,y24,x23,y23)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a2==area(x21,y21,x22,y22,x13,y13)+area(x21,y21,x13,y13,x24,y24)+area(x13,y13,x22,y22,x23,y23)+area(x13,y13,x24,y24,x23,y23)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a2==area(x21,y21,x22,y22,x14,y14)+area(x21,y21,x14,y14,x24,y24)+area(x14,y14,x22,y22,x23,y23)+area(x14,y14,x24,y24,x23,y23)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a2==area(x21,y21,x22,y22,x1c,y1c)+area(x21,y21,x14,y14,x2c,y2c)+area(x1c,y1c,x22,y22,x23,y23)+area(x1c,y1c,x24,y24,x23,y23)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tpw.println(\"NO\");\n\t\tpw.close();\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 846, "index": 846}
{"src": "import java.io.BufferedReader;\nimport java.io.PrintWriter;\n\nimport java.io.InputStreamReader;\n\nimport java.io.IOException;\n\nimport java.util.StringTokenizer;\n\nimport java.util.Arrays;\n\npublic class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        long n = in.nextLong(), m = in.nextLong();\n        out.print(m / n + (m % n == 0 ? 0 : 1));\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 847, "index": 847}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tSystem.out.println(input.nextInt() / 2 + 1);\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 848, "index": 848}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class programA {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tif(n%2 == 0)System.out.println(n/2 +1);\n\t\telse System.out.println((int)Math.ceil((double)n/2));\n\t}\n}\n\n\n\n\n", "complexity": "constant", "from": "CorCod", "problem": 849, "index": 849}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\npublic class ElevatorOrStairs {\n\n\tprivate static final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final OutputStreamWriter writer = new OutputStreamWriter(System.out);\n\t\n\tpublic static void main(String...strings) throws Exception {\n\t\tString[] specs = reader.readLine().split(\" \");\n\t\t\n\t\tint x = Integer.parseInt(specs[0]);\n\t\tint y = Integer.parseInt(specs[1]);\n\t\tint z = Integer.parseInt(specs[2]);\n\t\tint t1 = Integer.parseInt(specs[3]);\n\t\tint t2 = Integer.parseInt(specs[4]);\n\t\tint t3 = Integer.parseInt(specs[5]);\n\t\t\n\t\treader.close();\n\t\tString ans = solve(x, y, z, t1, t2, t3);\n\t\twriter.append(ans);\n\t\twriter.flush();\n\t\twriter.close();\n\t}\n\t\n\tprivate static String solve(int x, int y, int z, int t1, int t2, int t3) {\n\t\tint time_using_stairs = Math.abs(x - y) * t1;\n\t\tint elevator_time_between_floor = Math.abs(x - z) * t2;\n\t\tint elevator_from_z_to_x = elevator_time_between_floor + 2*t3;\n\t\t\n \t\tint time_using_elevator = elevator_from_z_to_x + (Math.abs(x - y) * t2) + t3;\n \t\t\n \t\tif(time_using_elevator <= time_using_stairs) {\n \t\t\treturn \"YES\";\n \t\t}\n \t\treturn \"NO\";\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 850, "index": 850}
{"src": "import java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong();\n        long s = sc.nextLong();\n\n        long ans = (s - 1) / n + 1;\n        System.out.print(ans);\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 851, "index": 851}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong m = in.nextLong();\n\t\t\n\t\tlong ans = m / n;\n\t\t\n\t\tif(m % n > 0)\n\t\t\tans++;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\n\n", "complexity": "constant", "from": "CorCod", "problem": 852, "index": 852}
{"src": "import java.util.*;\nimport java.io.*;\n\n\n\n public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n       long l2 =param.nextLong();\n       long dice1=param.nextLong();\n       long dice2=param.nextLong();\n      \n       long l1=1;\n       long r1=1;\n       long r2=l2;\n       long count=0;\n       long check=0;\n       count=l2-dice1;\n       count=count+(r2-dice2);\n       check=dice1-l1;\n       check=check+(dice2-r1);\n       if(check<=count){\n          System.out.println(\"White\");\n       }\n       else{\n          System.out.println(\"Black\");\n       }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   //-----------MyScanner class for faster input----------\n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}\n   ", "complexity": "constant", "from": "CorCod", "problem": 853, "index": 853}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong ans = n+1;\n\t\t\n\t\tif(ans == 1)\n\t\t\tans = 0;\n\t\tif(ans % 2 == 0)\n\t\t\tans /= 2;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 854, "index": 854}
{"src": "    import java.util.Scanner;\n\n    public class Sasha1113A {\n\n        static int solution(int n, int v){\n            int count;\n            if(v>=n)\n                return n-1;\n            else{\n                count = (v-1) + ((n-v)*(n-v+1))/2;\n            }\n            return count;\n        }\n\n        public static void main(String[] args){\n            Scanner scan = new Scanner(System.in);\n            int n = scan.nextInt();\n            int v = scan.nextInt();\n\n            System.out.print(solution(n, v));\n        }\n    }\n", "complexity": "constant", "from": "CorCod", "problem": 855, "index": 855}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    \n    static void merge(int arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(int arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    } \n    \n    static void merge(long arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        long L[] = new long [n1]; \n        long R[] = new long [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(long arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    }\n    static int gcd(int a, int b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    }\n    static long gcd(long a, long b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    } \n    public long m=(long)1e9+7;;\n    \n    public void run() {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int a=in.nextInt(),b=in.nextInt(),c=in.nextInt(),n=in.nextInt();\n        int nnew=a+b-c;\n        if((n>nnew) && (a>=c) && (b>=c))\n            out.println(n-nnew);\n        else\n            out.println(-1);\n        \n        out.close();\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 856, "index": 856}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int S=Integer.parseInt(s1[1]);\n            if(S%n==0)\n             System.out.println(S/n);\n            else\n             System.out.println(S/n+1);\n      }\n}", "complexity": "constant", "from": "CorCod", "problem": 857, "index": 857}
{"src": " \n \n\n\nimport java.util.Scanner;\nimport javafx.geometry.Point2D;\n\n \npublic class ChessKing {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\nScanner input = new Scanner(System.in);\nlong size = input.nextLong();\nlong a = input.nextLong();\nlong b = input.nextLong();\n  long sum = a+b;\n   long d = sum-2;\n   long d1 = size*2 - sum;\nif(d<d1) System.out.println(\"White\");\nelse if(d>d1) System.out.println(\"Black\");\nelse System.out.println(\"White\");\n\n\n    }\n    \n}\n", "complexity": "constant", "from": "CorCod", "problem": 858, "index": 858}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class TestClass1 {\n\n\n    public static void main(String[] args) throws  Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s[] = br.readLine().split(\" \");\n\n        long A,B,y,g,b;\n        A= Long.parseLong(s[0]);\n        B= Long.parseLong(s[1]);\n        s=br.readLine().split(\" \");\n\n        y = Long.parseLong(s[0]);\n        g = Long.parseLong(s[1]);\n        b = Long.parseLong(s[2]);\n\nlong ans=0;\n        if(A-2*y-g < 0){\n            ans+=Math.abs(A-2*y-g);\n        }\n        \n        if(B-g-3*b < 0){\n            ans+=Math.abs(B-g-3*b);\n        }\n        System.out.println(ans);\n\n\n\n    }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 859, "index": 859}
{"src": "import java.util.*;\n\npublic class Main {\n\tstatic int mod = 1000000007;\n  static int size = 200000;\n\tstatic long[] fac = new long[size];\n\tstatic long[] finv = new long[size];\n\tstatic long[] inv = new long[size];\n\tstatic int INF = Integer.MAX_VALUE;\n\n \tpublic static void main(String[] args){\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString[] s = new String[2];\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\ts[i] = scanner.next();\n\t\t}\n\t\tint n = s[0].length();\n\t\tchar[][] c = new char[2][n];\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tc[i][j] = s[i].charAt(j);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tif(c[0][i] == '0' && c[1][i] == '0' && c[0][i+1] == '0'){\n\t\t\t\tc[0][i] = 'X';\n\t\t\t\tc[1][i] = 'X';\n\t\t\t\tc[0][i+1] = 'X';\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(c[0][i] == '0' && c[1][i] == '0' && c[1][i+1] == '0'){\n\t\t\t\tc[0][i] = 'X';\n\t\t\t\tc[1][i] = 'X';\n\t\t\t\tc[1][i+1] = 'X';\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(c[0][i] == '0' && c[0][i+1] == '0' && c[1][i+1] == '0'){\n\t\t\t\tc[0][i] = 'X';\n\t\t\t\tc[0][i+1] = 'X';\n\t\t\t\tc[1][i+1] = 'X';\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(c[0][i+1] == '0' && c[1][i+1] == '0' && c[1][i] == '0'){\n\t\t\t\tc[1][i] = 'X';\n\t\t\t\tc[0][i+1] = 'X';\n\t\t\t\tc[1][i+1] = 'X';\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static boolean isPrime(int n){\n\t\tif(n == 1) return false;\n\t\tif(n == 2 || n == 3) return true;\n\t\tfor(int i = 2; i <= Math.sqrt(n); i++){\n\t\t\tif(n % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t// tar \u306e\u65b9\u304c\u6570\u5b57\u304c\u5927\u304d\u3044\u304b\u3069\u3046\u304b\n\tstatic boolean compare(String tar, String src) {\n\t\tif (src == null) return true;\n\t\tif (src.length() == tar.length()) {\n\t\t\tint len = tar.length();\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tif (src.charAt(i) > tar.charAt(i)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (src.charAt(i) < tar.charAt(i)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tar.compareTo(src) > 0 ? true : false;\n\t\t} else if (src.length() < tar.length()) {\n\t\t\treturn true;\n\t\t} else if (src.length() > tar.length()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static class Edge{\n\t\tint to;\n\t\tEdge(int to){\n\t\t\tthis.to = to;\n\t\t}\n\t}\n\tpublic static void swap(long a, long b){\n\t\tlong tmp = 0;\n\t\tif(a > b){\n\t\t\ttmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t}\n  static class Pair implements Comparable<Pair>{\n    int first, second;\n    Pair(int a, int b){\n        first = a;\n        second = b;\n    }\n    @Override\n    public boolean equals(Object o){\n        if (this == o) return true;\n        if (!(o instanceof Pair)) return false;\n        Pair p = (Pair) o;\n        return first == p.first && second == p.second;\n    }\n    @Override\n    public int compareTo(Pair p){\n        return first == p.first ? second - p.second : first - p.first; //first\u3067\u6607\u9806\u306b\u30bd\u30fc\u30c8\n        //return (first == p.first ? second - p.second : first - p.first) * -1; //first\u3067\u964d\u9806\u306b\u30bd\u30fc\u30c8\n        //return second == p.second ? first - p.first : second - p.second;//second\u3067\u6607\u9806\u306b\u30bd\u30fc\u30c8\n        //return (second == p.second ? first - p.first : second - p.second)*-1;//second\u3067\u964d\u9806\u306b\u30bd\u30fc\u30c8\n    }\n  }\n\n  //\u7e70\u308a\u8fd4\u3057\u4e8c\u4e57\u6cd5\n  public static long pow(long x, long n){\n    long ans = 1;\n    while(n > 0){\n      if((n & 1) == 1){\n        ans = ans * x;\n        ans %= mod;\n      }\n      x = x * x % mod;\n      n >>= 1;\n    }\n    return ans;\n  }\n\n\tpublic static long div(long x, long y){\n\t\treturn (x*pow(y, mod-2))%mod;\n\t}\n\n  //fac, inv, finv\u30c6\u30fc\u30d6\u30eb\u306e\u521d\u671f\u5316\u3001\u3053\u308c\u4f7f\u3046\u5834\u5408\u306finitComb()\u3067\u521d\u671f\u5316\u5fc5\u8981\n\tpublic static  void initComb(){\n\t\tfac[0] = finv[0] = inv[0] = fac[1] = finv[1] = inv[1] = 1;\n\t\tfor (int i = 2; i < size; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % mod;\n\t\t\tinv[i] = mod - (mod / i) * inv[(int) (mod % i)] % mod;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t\t}\n\t}\n\n\t//nCk % mod\n\tpublic static long comb(int n, int k){\n\t\treturn fac[n] * finv[k] % mod * finv[n - k] % mod;\n\t}\n\n\t//n! % mod\n\tpublic static long fact(int n){\n\t\treturn fac[n];\n\t}\n\n\t//(n!)^-1 with % mod\n\tpublic static long finv(int n){\n\t\treturn finv[n];\n\t}\n\n  static class UnionFind {\n    int[] parent;\n    public UnionFind(int size) {\n      parent = new int[size];\n      Arrays.fill(parent, -1);\n    }\n    public boolean unite(int x, int y) {\n      x = root(x);\n      y = root(y);\n      if (x != y) {\n        if (parent[y] < parent[x]) {\n          int tmp = y;\n          y = x;\n          x = tmp;\n        }\n        parent[x] += parent[y];\n        parent[y] = x;\n        return true;\n      }\n      return false;\n    }\n    public boolean same(int x, int y) {\n      return root(x) == root(y);\n    }\n    public int root(int x) {\n      return parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n    }\n    public int size(int x) {\n      return -parent[root(x)];\n    }\n  }\n\tpublic static int upperBound(int[] array, int value) {\n\t\t\t int low = 0;\n\t\t\t int high = array.length;\n\t\t\t int mid;\n\t\t\t while( low < high ) {\n\t\t\t\t\t mid = ((high - low) >>> 1) + low; // (high + low) / 2\n\t\t\t\t\t if( array[mid] <= value ) {\n\t\t\t\t\t\t\t low = mid + 1;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t\t high = mid;\n\t\t\t\t\t }\n\t\t\t }\n\t\t\t return low;\n\t }\n\t public static final int lowerBound(final int[] arr, final int value) {\n    \tint low = 0;\n    \tint high = arr.length;\n    \tint mid;\n    \twhile (low < high){\n        \tmid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n        \tif (arr[mid] < value) {\n          \tlow = mid + 1;\n        \t} else {\n            high = mid;\n        \t}\n    \t}\n    \treturn low;\n\t\t}\n  //n,m\u306e\u6700\u5927\u516c\u7d04\u6570\n  public static long gcd(long n, long m){\n    if(m > n) return gcd(m,n);\n    if(m == 0) return n;\n    return gcd(m, n%m);\n  }\n\t//3\u8981\u7d20\u306e\u30bd\u30fc\u30c8\n\tprivate class Pair2 implements Comparable<Pair2> {\n\t\tString s;\n\t\tint p;\n\t\tint index;\n\t\tpublic Pair2(String s, int p, int index) {\n\t\t\t\tthis.s = s;\n\t\t\t\tthis.p = p;\n\t\t\t\tthis.index = index;\n\t\t}\n\n\t\tpublic int compareTo(Pair2 other) {\n\t\t\t\tif (s.equals(other.s)) {\n\t\t\t\t\t\treturn other.p - this.p;\n\t\t\t\t}\n\t\t\t\treturn this.s.compareTo(other.s);\n\t\t}\n\t}\n\t//c -> int\u306b\u5909\u63db\npublic static int c2i(char c){\n\tif('A' <= c && c <= 'Z'){\n\t\treturn c - 'A';\n\t}else{\n\t\treturn c - 'a' + 26;\n\t}\n}\n// int -> char\u306b\u5909\u63db\npublic static char i2c(int i){\n\tif(0 <= i && i < 26){\n\t\t\treturn (char)(i + 'A');\n\t}else{\n\t\t\treturn (char)(i + 'a' - 26);\n\t}\n}\n\n}\n", "complexity": "constant", "from": "CorCod", "problem": 860, "index": 860}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner read = new Scanner(System.in);\n        double a = (double)read.nextInt();\n        double v = (double)read.nextInt();\n        double l = (double)read.nextInt();\n        double d = (double)read.nextInt();\n        double w = (double)read.nextInt();\n        double t=0;\n        if(w>=v){\n            double d1=v*v/(2*a);\n            if(d1>l){\n                t+= Math.sqrt(2*l/a);\n            }\n            else{\n                t+= v/a + (l-d1)/v;\n            }\n        }\n        else{\n            double temp = (v-w)/a;\n            double d1 = v*v/(2*a);\n            double d2 = d - v*temp + a*temp*temp/2;\n            if(d1>d2){\n                double temp2 = Math.sqrt(2*a*d);\n                if(temp2<w){\n                    w=temp2;\n                    temp=(v-w)/a;\n                    t+= temp2/a;\n                }\n                else{\n                    double vx=Math.sqrt(v*v/2+a*d2);\n                    t+= (vx/a) + ((vx-w)/a);\n                }\n            }\n            else{\n                t+= (v/a) + ((d2-d1)/v) + (temp);\n            }\n            double d3 = d + w*temp + a*temp*temp/2;\n            if(d3>l){\n                t+= (-w+Math.sqrt(w*w+2*a*(l-d)))/a;\n            }\n            else{\n                t+= (temp) + ((l-d3)/v);\n            }\n        }\n        System.out.printf(\"%.6f\", t);\n        read.close();\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 861, "index": 861}
{"src": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int a[] = new int[1501];\n              for(int i = 0; i < 3; i++){\n                     a[sc.nextInt()]++;\n              }\n              if(a[1] > 0 || a[2] > 1 || a[3] > 2 || (a[4] == 2 && a[2] == 1)){\n                     System.out.println(\"YES\");\n              }else{\n                     System.out.println(\"NO\");\n              }\n      }\n}", "complexity": "constant", "from": "CorCod", "problem": 862, "index": 862}
{"src": "import java.awt.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        long n = scanner.nextLong();\n        long x = scanner.nextLong(), y = scanner.nextLong();\n        long whiteSteps, blackSteps;\n\n        if(x == 1 || y == 1){\n            whiteSteps = (x - 1) + (y - 1);\n        } else {\n            whiteSteps = Math.min((x - 1) + Math.abs(y - x), (y - 1) + Math.abs(y - x));\n        }\n\n        if(x == n || y == n){\n            blackSteps = (n - x) + (n - y);\n        } else {\n            blackSteps = Math.min((n - x) + Math.abs(y - x), (n - y) + Math.abs(y - x));\n        }\n\n        if (whiteSteps <= blackSteps){\n            System.out.println(\"White\");\n        } else {\n            System.out.println(\"Black\");\n        }\n\n    }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 863, "index": 863}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n    public static void main(String args[]) {\n        FastScanner scn = new FastScanner();\n        int n = scn.nextInt();\n        int s = scn.nextInt();\n        if (s <= n) {\n            System.out.println(1);\n        } else if (s > n) {\n            if(s%n == 0){\n                System.out.println(s/n);\n            } else {\n                System.out.println(s/n + 1);\n            }\n        }\n\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 864, "index": 864}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class AAA {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\t\n\t\tint n=Integer.parseInt(st.nextToken());\n\t\tint m=Integer.parseInt(st.nextToken());\n\t\tString a=\"\";\n\t\tString b=\"\";\n\t\tfor(int i=0;i<1129;i++) {\n\t\t\ta+=\"1\";\n\t\t\tb+=\"8\";\n\t\t}\n\t\ta+=\"9\";\n\t\tb+=\"1\";\n\t\t\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t}\n\t\t\n}\n", "complexity": "constant", "from": "CorCod", "problem": 865, "index": 865}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class IntegerSequenceDividing {\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n%2==0)\n\t\t{\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}else\n\t\t{\n\t\t\tn++;\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 866, "index": 866}
{"src": "import java.util.*;\npublic class A\n{\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        long n=sc.nextLong();\n        if(n==0)\n        System.out.println(0);\n        else if(n%2==1)\n        System.out.println((n+1)/2);\n        else\n        System.out.println(n+1);\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 867, "index": 867}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        FastReader fr = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fr.nextInt(), v = fr.nextInt();\n        if (v >= n)\n            out.println(n - 1);\n        else\n            out.println((n - v) * (n - v + 1) / 2 + v - 1);\n        out.flush();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        int[] memset(int n, int val) {\n            int ar[] = new int[n];\n            Arrays.fill(ar, val);\n            return ar;\n        }\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 868, "index": 868}
{"src": "import java.util.*;\npublic class Pizza {\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong num = sc.nextLong() + 1;\n\t\tsc.close();\n\t\tSystem.out.println(num % 2 == 0 || num == 1 ? num / 2 : num);\n\t}\n\t\n}\n", "complexity": "constant", "from": "CorCod", "problem": 869, "index": 869}
{"src": "import java.util.*;\n\npublic class OrangeJuice{\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint s=in.nextInt();\n\t\tif(n>=1&&n<=100000&&s>=1&&s<=1000000000){\n\t\t\tif(s%n==0){\n\t\t\t\tSystem.out.println(s/n);\n\t\t\t}else{\n\t\t\t\tint o=s%n;\n\t\t\t\tSystem.out.println((s-o)/n+1);\n\t\t\t}\n\t\t}\n\t}\n}", "complexity": "constant", "from": "CorCod", "problem": 870, "index": 870}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\npublic class FunctionHeight {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        long n = sc.nl();\n        long k = sc.nl();\n        long ans = (n+k-1)/n;\n        System.out.println(ans);\n    }\n\n    /////////// TEMPLATE FROM HERE /////////////////\n    private static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int ni() {\n            return Integer.parseInt(next());\n        }\n\n        float nf() {\n            return Float.parseFloat(next());\n        }\n\n        long nl() {\n            return Long.parseLong(next());\n        }\n\n        double nd() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 871, "index": 871}
{"src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        long a;\n        int i;\n        public card(long a,int i)\n        {\n            this.a=a;\n            this.i=i;\n        }\n    }\n    static class sort implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.a!=o2.a)\n                return (int)(o1.a-o2.a);\n            else\n                return (int)(o1.b-o2.b);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }*/\n    /*static boolean valid(int i,int j)\n    {\n    if(i<4 && i>=0 && j<4 && j>=0)\n    return true;\n    else\n    return false;\n    }*/\n    static class pair{\n        int a,b;\n        public pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int k=sc.nextInt();\n        int n=sc.nextInt();\n        int s=sc.nextInt();\n        int p=sc.nextInt();\n        long d=(long)Math.ceil((double)n/s);\n        if(d==0)\n        d=1;\n        d=k*d;\n        long ans=(long)Math.ceil((double)d/p);\n        System.out.println(ans);\n    }\n}", "complexity": "constant", "from": "CorCod", "problem": 872, "index": 872}
{"src": "\nimport java.io.PrintWriter;\n\nimport java.util.*;\nimport java.util.Arrays ; \nimport java .lang.String.* ;\nimport java .lang.StringBuilder ;\n\n\npublic class Test{\n    static int pos = 0 ; \n    static int  arr[] ; \n  static LinkedList l1 = new  LinkedList() ; \nstatic void find(int p ,char[]x,int put[],String s){\n    int c= 0 ; \n    for (int i = 0; i < s.length(); i++) {\n        if(x[p]==s.charAt(i)){\n        c++ ; }\n    }\n    put[p] = c ;  \n}\nstatic int mode(int m ,int[]x ){\n    int temp = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return m-temp ; \n             \n        }\n    }\n     return m-temp ; \n}\nstatic int mode2(int m ,int[]x ){\n    int temp = 0 ; \n    \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return x[i] ; \n             \n        }\n    }\n     return 0 ; \n}\nstatic int find(int x[],int temp){\n    int j = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]==temp) return j+1 ; \n        j++ ; \n    }\n    return -1 ; \n}\nstatic String ch(long[]x,long b){\n    for (int i = 0; i < x.length; i++) {\n        if(x[i]==b)return \"YES\" ;\n    }\n    return \"NO\" ; \n}\n\n    public static void main(String[] args)  {\n\n        Scanner in = new Scanner(System.in) ;\n        PrintWriter pw = new PrintWriter(System.out);   \n        long n = in.nextLong() ; \n        long count =1 ; \n        long temp =n/2;\n     temp+=count ;\n      \n       \n        System.out.println(temp);\n }               \n}\n\n", "complexity": "constant", "from": "CorCod", "problem": 873, "index": 873}
{"src": "import java.io.*;\n\npublic class VJudgeProblem2{\n    public static void main(String[] args) throws IOException{\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        int x = Integer.parseInt(reader.readLine());\n\n        if (x == 1)\n            System.out.println(-1);\n        else\n            System.out.println(x + \" \" + x);    \n    }\n        \n}", "complexity": "constant", "from": "CorCod", "problem": 874, "index": 874}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n \n/**\n *\n * @author Antonio \"Teo\" Alurralde\n */\npublic class Main {\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    int n = Integer.parseInt(br.readLine());\n    StringTokenizer tok = new StringTokenizer(br.readLine());\n    int ax = Integer.parseInt(tok.nextToken());\n    int ay = Integer.parseInt(tok.nextToken());\n    tok = new StringTokenizer(br.readLine());\n    int bx = Integer.parseInt(tok.nextToken());\n    int by = Integer.parseInt(tok.nextToken());\n    tok = new StringTokenizer(br.readLine());\n    int cx = Integer.parseInt(tok.nextToken());\n    int cy = Integer.parseInt(tok.nextToken());\n    boolean ans = (bx < ax && cx < ax && by < ay && cy < ay) ||\n    (bx < ax && cx < ax && by > ay && cy > ay) ||\n    (bx > ax && cx > ax && by < ay && cy < ay) ||\n    (bx > ax && cx > ax && by > ay && cy > ay);\n    System.out.print(ans?\"YES\":\"NO\");\n  }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 875, "index": 875}
{"src": "import java.util.*;\npublic class D5 {\npublic static void main(String[] args)\n{\n    Scanner input = new Scanner(System.in);\n    int a = input.nextInt(), v = input.nextInt();\n    int l = input.nextInt(), d = input.nextInt(), w = input.nextInt();\n    double lo = 0, hi = v;\n    for(int iter = 0; iter < 1000; iter++)\n    {\n        double mid = (lo+hi)/2;\n        if(can(mid, a, d, w)) lo = mid;\n        else hi = mid;\n    }\n    //System.out.println(lo);\n    double t1 = lo / a;\n    double gone = .5 * t1 * t1 * a;\n    if(lo > w)\n    {\n        gone += -a * .5 * (lo - w) / a * (lo - w) / a + lo * (lo - w) / a;\n        t1 += (lo - w) / a;\n    }\n    t1 += (d - gone) / lo;\n    //System.out.println(t1);\n    double v0 = Math.min(lo, w);\n    double togo = l - d;\n    double toAdd = (-v0 + Math.sqrt(v0 * v0 + 4 * togo * .5 * a)) / a;\n    if(toAdd * a + v0 > v)\n    {\n        double tt = (v - v0) / a;\n        t1 += tt;\n        togo -= .5 * a * tt * tt + v0 * tt;\n        t1 += togo / v;\n    }\n    else t1 += toAdd;\n    System.out.println(t1);\n}\nstatic boolean can(double v, double a, double d, double max)\n{\n    double t1 = v / a;\n    double distGone = .5 * a * t1 * t1;\n    if(v > max)\n    {\n        t1 = (v - max) / a;\n        distGone += -.5 * a * t1 * t1 + v * t1;\n    }\n    return distGone <= d;\n}\n}\n", "complexity": "constant", "from": "CorCod", "problem": 876, "index": 876}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class TwoSquares {\n    \n    int INF = 1000;\n    \n    void solve() {\n        int[][] s1 = new int[4][2];\n        for (int i = 0; i < 4; i++) {\n            s1[i][0] = in.nextInt();\n            s1[i][1] = in.nextInt();\n        }\n        \n        int[][] s2 = new int[4][2];\n        for (int i = 0; i < 4; i++) {\n            s2[i][0] = in.nextInt();\n            s2[i][1] = in.nextInt();\n        }\n        \n        if (ok(s1, s2)) {\n            out.println(\"Yes\");\n            return;\n        }\n        \n        rotate(s1);\n        rotate(s2);\n        \n        if (ok(s2, s1)) {\n            out.println(\"Yes\");\n            return;\n        }\n        \n        out.println(\"No\");\n    }\n    \n    void rotate(int[][] s) {\n        for (int i = 0; i < 4; i++) {\n            int x = s[i][0], y = s[i][1];\n            s[i][0] = x - y;\n            s[i][1] = x + y;\n        }\n    }\n    \n    boolean ok(int[][] s1, int[][] s2) {\n        int xmin = INF, xmax = -INF, ymin = INF, ymax = -INF;\n        for (int i = 0; i < 4; i++) {\n            xmin = Math.min(xmin, s1[i][0]);\n            xmax = Math.max(xmax, s1[i][0]);\n            ymin = Math.min(ymin, s1[i][1]);\n            ymax = Math.max(ymax, s1[i][1]);\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            if (s2[i][0] >= xmin && s2[i][0] <= xmax && s2[i][1] >= ymin && s2[i][1] <= ymax) return true;\n        }\n        \n        int[] mid2 = new int[]{s2[0][0] + s2[2][0], s2[0][1] + s2[2][1]};\n        return mid2[0] >= xmin * 2 && mid2[0] <= xmax * 2 && mid2[1] >= ymin * 2 && mid2[1] <= ymax * 2;\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new TwoSquares().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "constant", "from": "CorCod", "problem": 877, "index": 877}
{"src": "/**\n* Given a binary array sorted in non-increasing order, count the number of 1\u2019s in it. \n**/\n/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Ideone\n{\tpublic static int countOnes(int arr[], int low, int high)\n\t{\n  \t\tif(high >= low)\n  \t\t{\n    \t\t// get the middle index\n    \t\tint mid = low + (high - low)/2;\n\n    \t\t// check if the element at middle index is last 1\n    \t\tif ( (mid == high || arr[mid+1] == 0) && (arr[mid] == 1))\n      \t\t\treturn mid+1;\n\n    \t\t// If element is not last 1, recur for right side\n    \t\tif (arr[mid] == 1)\n      \t\t\treturn countOnes(arr, (mid + 1), high);\n\n    \t\t// else recur for left side\n    \t\treturn countOnes(arr, low, (mid -1));\n  \t\t}\n  \t\treturn 0;\n\t}\n\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    int arr[] = {1, 1, 1, 1, 0, 0, 0};\n      int n = arr.length;\n      System.out.println(\"Count of 1's in given array is \" + countOnes(arr, 0, n-1));\n\t}\n", "complexity": "logn", "from": "CorCod", "problem": 878, "index": 878}
{"src": "package geek.livingstone.problems.arrays;\n\n/**\n * Full problem at\n * http://www.geeksforgeeks.org/search-floor-and-ceil-in-a-sorted-array/\n * \n * @author emmanuel\n * \n */\npublic class FloorInSortedArray {\n\tpublic static int floor(int[] A, int val) throws Exception {\n\t\tif (val < A[0])\n\t\t\tthrow new Exception(\"All elements are greater than val\");\n\t\telse if (val > A[A.length - 1])\n\t\t\treturn A[A.length - 1];\n\t\treturn floor(A, 0, A.length - 1, val);\n\t}\n\n\tprivate static int floor(int[] A, int l, int r, int val) throws Exception {\n\t\tif (l > r) {\n\t\t\tthrow new Exception(\"Not found\");\n\t\t}\n\t\tint mid = (l + r) / 2;\n\t\tif (val == A[mid])\n\t\t\treturn A[mid];\n\t\telse if (val < A[mid]) {\n\t\t\tif (val >= A[mid - 1])\n\t\t\t\treturn A[mid - 1];\n\t\t\treturn floor(A, l, mid - 1, val);\n\t\t} else {\n\t\t\tif (val < A[mid + 1])\n\t\t\t\treturn A[mid];\n\t\t\treturn floor(A, mid + 1, r, val);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[] { 1, 3, 4, 7, 8, 12, 32, 45, 78, 98 };\n\t\t// System.out.println(floor(A, -45));\n\t\tSystem.out.println(floor(A, 11));\n\t\tSystem.out.println(floor(A, 32));\n\t\tSystem.out.println(floor(A, 70));\n\t\tSystem.out.println(floor(A, 125));\n\t}\n\n}", "complexity": "logn", "from": "CorCod", "problem": 879, "index": 879}
{"src": "\n// Java program to count occurrences \n// of an element \n\nclass\nMain \n{ \n\n/* if x is present in arr[] then returns \n\nthe count of occurrences of x, \n\notherwise returns -1. */\n\nstatic\nint\ncount(\nint\narr[], \nint\nx, \nint\nn) \n\n{ \n\n// index of first occurrence of x in arr[0..n-1] \n\nint\ni; \n\n\n// index of last occurrence of x in arr[0..n-1] \n\nint\nj; \n\n\n/* get the index of first occurrence of x */\n\ni = first(arr, \n0\n, n-\n1\n, x, n); \n\n\n/* If x doesn't exist in arr[] then return -1 */\n\nif\n(i == -\n1\n) \n\nreturn\ni; \n\n\n/* Else get the index of last occurrence of x. \n\nNote that we are only looking in the \n\nsubarray after first occurrence */\n\nj = last(arr, i, n-\n1\n, x, n); \n\n\n/* return count */\n\nreturn\nj-i+\n1\n; \n\n} \n\n\n/* if x is present in arr[] then returns the \n\nindex of FIRST occurrence of x in arr[0..n-1], \n\notherwise returns -1 */\n\nstatic\nint\nfirst(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx, \nint\nn) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n/*low + (high - low)/2;*/\n\nint\nmid = (low + high)/\n2\n; \n\nif\n( ( mid == \n0\n|| x > arr[mid-\n1\n]) && arr[mid] == x) \n\nreturn\nmid; \n\nelse\nif\n(x > arr[mid]) \n\nreturn\nfirst(arr, (mid + \n1\n), high, x, n); \n\nelse\n\nreturn\nfirst(arr, low, (mid -\n1\n), x, n); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n/* if x is present in arr[] then returns the \n\nindex of LAST occurrence of x in arr[0..n-1], \n\notherwise returns -1 */\n\nstatic\nint\nlast(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx, \nint\nn) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n/*low + (high - low)/2;*/\n\nint\nmid = (low + high)/\n2\n; \n\nif\n( ( mid == n-\n1\n|| x < arr[mid+\n1\n]) && arr[mid] == x ) \n\nreturn\nmid; \n\nelse\nif\n(x < arr[mid]) \n\nreturn\nlast(arr, low, (mid -\n1\n), x, n); \n\nelse\n\nreturn\nlast(arr, (mid + \n1\n), high, x, n); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n3\n, \n3\n, \n3\n, \n3\n}; \n\n\n// Element to be counted in arr[] \n\nint\nx = \n3\n; \n\nint\nn = arr.length; \n\nint\nc = count(arr, x, n); \n\nSystem.out.println(x+\n\" occurs \"\n+c+\n\" times\"\n); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 880, "index": 880}
{"src": "\n// Java program to find minimum element in a sorted and rotated array \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nMinimum \n{ \n\nstatic\nint\nfindMin(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n// This condition is needed to handle the case when array \n\n// is not rotated at all \n\nif\n(high < low) \nreturn\narr[\n0\n]; \n\n\n// If there is only one element left \n\nif\n(high == low) \nreturn\narr[low]; \n\n\n// Find mid \n\nint\nmid = low + (high - low)/\n2\n; \n/*(low + high)/2;*/\n\n\n// Check if element (mid+1) is minimum element. Consider \n\n// the cases like {3, 4, 5, 1, 2} \n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\narr[mid+\n1\n]; \n\n\n// Check if mid itself is minimum element \n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n// Decide whether we need to go to left half or right half \n\nif\n(arr[high] > arr[mid]) \n\nreturn\nfindMin(arr, low, mid-\n1\n); \n\nreturn\nfindMin(arr, mid+\n1\n, high); \n\n} \n\n\n// Driver Program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr1[] = {\n5\n, \n6\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr1, \n0\n, n1-\n1\n)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr2, \n0\n, n2-\n1\n)); \n\n\nint\narr3[] = {\n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr3, \n0\n, n3-\n1\n)); \n\n\nint\narr4[] = {\n1\n, \n2\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr4, \n0\n, n4-\n1\n)); \n\n\nint\narr5[] = {\n2\n, \n1\n}; \n\nint\nn5 = arr5.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr5, \n0\n, n5-\n1\n)); \n\n\nint\narr6[] = {\n5\n, \n6\n, \n7\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn6 = arr6.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr6, \n0\n, n6-\n1\n)); \n\n\nint\narr7[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn7 = arr7.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr7, \n0\n, n7-\n1\n)); \n\n\nint\narr8[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n1\n}; \n\nint\nn8 = arr8.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr8, \n0\n, n8-\n1\n)); \n\n\nint\narr9[] = {\n3\n, \n4\n, \n5\n, \n1\n, \n2\n}; \n\nint\nn9 = arr9.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr9, \n0\n, n9-\n1\n)); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 881, "index": 881}
{"src": "\nclass\nMain \n{ \n\n/* Function to get index of \n\nceiling of x in arr[low..high]*/\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\nmid; \n\n\n/* If x is smaller than or equal to the \n\nfirst element, then return the first element */\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n/* If x is greater than the last \n\nelement, then return -1 */\n\nif\n(x > arr[high]) \n\nreturn\n-\n1\n; \n\n\n/* get the index of middle element \n\nof arr[low..high]*/\n\nmid = (low + high)/\n2\n; \n/* low + (high - low)/2 */\n\n\n/* If x is same as middle element, \n\nthen return mid */\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n/* If x is greater than arr[mid], then \n\neither arr[mid + 1] is ceiling of x or \n\nceiling lies in arr[mid+1...high] */\n\nelse\nif\n(arr[mid] < x) \n\n{ \n\nif\n(mid + \n1\n<= high && x <= arr[mid+\n1\n]) \n\nreturn\nmid + \n1\n; \n\nelse\n\nreturn\nceilSearch(arr, mid+\n1\n, high, x); \n\n} \n\n\n/* If x is smaller than arr[mid], \n\nthen either arr[mid] is ceiling of x \n\nor ceiling lies in arr[mid-1...high] */\n\nelse\n\n{ \n\nif\n(mid - \n1\n>= low && x > arr[mid-\n1\n]) \n\nreturn\nmid; \n\nelse\n\nreturn\nceilSearch(arr, low, mid - \n1\n, x); \n\n} \n\n} \n\n\n\n/* Driver program to check above functions */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n8\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 882, "index": 882}
{"src": "package com.interview.binarysearch;\n\n/**\n * http://www.geeksforgeeks.org/check-for-majority-element-in-a-sorted-array/\n */\npublic class FirstOccurrenceOfNumberInSortedArray {\n\n    public int firstOccurrence(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        \n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x && (middle == 0 || input[middle-1] < x)){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        FirstOccurrenceOfNumberInSortedArray fos = new FirstOccurrenceOfNumberInSortedArray();\n        int input[] = {1,2,2,2,2,2,5,7,7};\n        System.out.println(fos.firstOccurrence(input, 6));\n    }\n    \n}", "complexity": "logn", "from": "CorCod", "problem": 883, "index": 883}
{"src": "package com.interview.binarysearch;\n\n/**\n * http://www.geeksforgeeks.org/find-the-point-where-a-function-becomes-negative/\n */\npublic class MonotonicallyIncreasingFunctionBecomesPositive {\n\n    private int f(int x){\n        return x*x - 10*x - 20;\n    }\n    \n    public int findPoint(){\n        int i=1;\n        while(f(i) <=0 ){\n            i = i*2;\n        }\n        return binarySearch(i/2,i);\n    }\n    \n    private int binarySearch(int start,int end){\n        int mid = (start+end)/2;\n        while(start < end){\n            mid = (start+end)/2;\n            if(f(mid) >0 && f(mid-1) <=0){\n                return mid;\n            }\n            if(f(mid) <=0 && f(mid+1)>0){\n                return mid+1;\n            }\n            if(f(mid) <= 0){\n                start = mid+1;\n            }else{\n                end = mid-1;\n            }\n        }\n        return mid;\n    }\n    \n    public static void main(String args[]){\n        MonotonicallyIncreasingFunctionBecomesPositive mif = new MonotonicallyIncreasingFunctionBecomesPositive();\n        System.out.print(mif.findPoint());\n    }\n}\n", "complexity": "logn", "from": "CorCod", "problem": 884, "index": 884}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void solve() {\n        int t = in.nextInt();\n\n        for (int sdfsdf = 0; sdfsdf < t; sdfsdf++) {\n            long n = in.nextLong();\n            long k = in.nextLong();\n\n            if (n == 1) {\n                if (k == 1)  {\n                    out.println(\"YES 0\");\n                } else {\n                    out.println(\"NO\");\n                }\n                continue;\n            }\n\n            if (k == 3) {\n                if (n == 2) {\n                    out.println(\"NO\");\n                } else {\n                    out.println(\"YES \" + (n - 1));\n                }\n                continue;\n            }\n\n            long cuts = 1;\n            long squares = 4;\n            int zoom = 1;\n\n            while (k > cuts + squares) {\n                cuts += squares;\n                squares *= 4;\n                zoom++;\n            }\n\n            if (zoom > n) {\n                out.println(\"NO\");\n                continue;\n            }\n\n            if (zoom == n && k > cuts) {\n                out.println(\"NO\");\n                continue;\n            }\n\n            long current_cuts = k - cuts;\n\n            if (current_cuts > squares - (2L * Math.sqrt(squares) - 1L)) {\n                out.println(\"YES \" + (n - zoom - 1L));\n            } else {\n                out.println(\"YES \" + (n - zoom));\n            }\n        }\n    }\n}\n", "complexity": "logn", "from": "CorCod", "problem": 885, "index": 885}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        FastReader in;\n        PrintWriter out;\n        int n;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.nextInt();\n            if (n % 4 != 0) {\n                out.println(\"! -1\");\n                return;\n            }\n            int low = 0;\n            int high = n >> 1;\n            if (BValue(low) == 0) {\n                out.println(\"! \" + (low + 1));\n                return;\n            }\n            boolean value = BValue(low) > 0;\n            while (high - low > 1) {\n                int mid = (high + low) >> 1;\n                int BVal = BValue(mid);\n                if (BVal == 0) {\n                    out.println(\"! \" + (mid + 1));\n                    return;\n                }\n                if (value) {\n                    if (BVal < 0) {\n                        high = mid;\n                    } else {\n                        low = mid;\n                    }\n                } else {\n                    if (BVal > 0) {\n                        high = mid;\n                    } else {\n                        low = mid;\n                    }\n                }\n            }\n            out.println(\"! -1\");\n        }\n\n        public int BValue(int index) {\n            out.println(\"? \" + (index + 1));\n            out.flush();\n            int f = in.nextInt();\n            out.println(\"? \" + (index + 1 + (n >> 1)));\n            out.flush();\n            int s = in.nextInt();\n            return f - s;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "logn", "from": "CorCod", "problem": 886, "index": 886}
{"src": "package com.interview.algorithms.array;\n\n/**\n * Given a sorted array and a value x, the ceiling of x is the smallest element\n * in array greater than or equal to x, and the floor is the greatest element\n * smaller than or equal to x. Assume than the array is sorted in non-decreasing\n * order. Write efficient functions to find floor and ceiling of x.\n * \n * For example, let the input array be {1, 2, 8, 10, 10, 12, 19}\n *  For x = 0:floor doesn't exist in array, ceil = 1\n *  For x = 1: floor = 1, ceil = 1 \n *  For x = 5: floor = 2, ceil = 8\n *   For x = 20: floor= 19, ceil doesn't exist in array\n *\n *\n * @author ajitkoti\n */\npublic class FloorAndCeilingInASortedArray {\n\n\t/**\n\t * Instead of using linear search, binary search is used here to find out\n\t * the index. Binary search reduces time complexity to O(Logn).\n\t * \n\t * @param arr\n\t * @param low\n\t * @param high\n\t * @param x\n\t * @return\n\t */\n\tprivate static int ceilSearch(int arr[], int low, int high, int x) {\n\t\tint mid;\n\n\t\t/*\n\t\t * If x is smaller than or equal to the first element, then return the\n\t\t * first element\n\t\t */\n\t\tif (x <= arr[low])\n\t\t\treturn low;\n\n\t\t/* If x is greater than the last element, then return -1 */\n\t\tif (x > arr[high])\n\t\t\treturn -1;\n\n\t\t/* get the index of middle element of arr[low..high] */\n\t\tmid = (low + high) / 2; /* low + (high - low)/2 */\n\n\t\t/* If x is same as middle element, then return mid */\n\t\tif (arr[mid] == x)\n\t\t\treturn mid;\n\n\t\t/*\n\t\t * If x is greater than arr[mid], then either arr[mid + 1] is ceiling of\n\t\t * x or ceiling lies in arr[mid+1...high]\n\t\t */\n\t\telse if (x > arr[mid]) {\n\t\t\tif (mid + 1 <= high && x <= arr[mid + 1])\n\t\t\t\treturn mid + 1;\n\t\t\telse\n\t\t\t\treturn ceilSearch(arr, mid + 1, high, x);\n\t\t}\n\n\t\t/*\n\t\t * If x is smaller than arr[mid], then either arr[mid] is ceiling of x\n\t\t * or ceiling lies in arr[mid-1...high]\n\t\t */\n\t\telse {\n\t\t\tif (mid - 1 >= low && x > arr[mid - 1])\n\t\t\t\treturn mid;\n\t\t\telse\n\t\t\t\treturn ceilSearch(arr, low, mid - 1, x);\n\t\t}\n\t}\n\n\t/* Driver program to check above functions */\n\tpublic static void main(String[] args) {\n\t\tint arr[] = { 1, 2, 8, 10, 10, 12, 19 };\n\t\tint n = arr.length;\n\t\tint x = 11;\n\t\tint index = ceilSearch(arr, 0, n - 1, x);\n\t\tif (index == -1)\n\t\t\tSystem.out.println(\"Ceiling of doesn't exist in array \" + x);\n\t\telse\n\t\t\tSystem.out.println(\"ceiling of\" + x + \" is \" + arr[index]);\n\n\t}\n\n}", "complexity": "logn", "from": "CorCod", "problem": 887, "index": 887}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\npublic class NastyaWardrobe {\n    static long modulo = 1000000007;\n    static long ans = 0;\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader inp = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = inp.readLine().split(\" \");\n        long clothes = Long.parseLong(s1[0]);\n        long months = Long.parseLong(s1[1]);\n\n        //formula 2^k(2x-1)+1;\n        calc(clothes,months);\n        System.out.print(ans);\n    }\n    static void calc(long clothes,long months){\n        if(clothes!=0) {\n            long a;\n            long count = 0;\n            ArrayList<Long> list = new ArrayList<>();\n            if (months >= 2) {\n                a = 2;\n                long c = months;\n\n                while (c > 1) {\n                    if (c % 2 == 1) {\n                        count++;\n                        list.add(a);\n                    }\n                    c = c / 2;\n\n                    a = (a * a) % modulo;\n                }\n                while (count > 0) {\n                    long b = list.get(0);\n                    list.remove(0);\n                    a = (a * b) % modulo;\n                    count--;\n                }\n\n            } else {\n                a = (long) Math.pow(2, months);\n            }\n\n\n            long b = clothes;\n\n            //System.out.println(b);\n            b = (2 * b - 1) % modulo;\n            ans = (a * b) % modulo;\n            ans = (ans + 1) % modulo;\n        }else{\n            ans = 0;\n        }\n\n    }\n}\n", "complexity": "logn", "from": "CorCod", "problem": 888, "index": 888}
{"src": "\n// Java program to find number of \n// rotations in a sorted and rotated \n// array. \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nBinarySearch \n{ \n\n// Returns count of rotations for an array \n\n// which is first sorted in ascending order, \n\n// then rotated \n\nstatic\nint\ncountRotations(\nint\narr[], \nint\nlow, \n\nint\nhigh) \n\n{ \n\n// This condition is needed to handle \n\n// the case when array is not rotated \n\n// at all \n\nif\n(high < low) \n\nreturn\n0\n; \n\n\n// If there is only one element left \n\nif\n(high == low) \n\nreturn\nlow; \n\n\n// Find mid \n\n// /*(low + high)/2;*/ \n\nint\nmid = low + (high - low)/\n2\n; \n\n\n// Check if element (mid+1) is minimum \n\n// element. Consider the cases like \n\n// {3, 4, 5, 1, 2} \n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\n(mid + \n1\n); \n\n\n// Check if mid itself is minimum element \n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\nmid; \n\n\n// Decide whether we need to go to left \n\n// half or right half \n\nif\n(arr[high] > arr[mid]) \n\nreturn\ncountRotations(arr, low, mid - \n1\n); \n\n\nreturn\ncountRotations(arr, mid + \n1\n, high); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n15\n, \n18\n, \n2\n, \n3\n, \n6\n, \n12\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(countRotations(arr, \n0\n, n-\n1\n)); \n\n} \n} \n// This code is contributed by Chhavi ", "complexity": "logn", "from": "CorCod", "problem": 889, "index": 889}
{"src": "package com.interview.binarysearch;\n\n/**\n * @author Tushar Roy\n * Date 01/22/17\n *\n * Search in sorted and rotated array. In one version duplicate is not allowed and\n * in another version duplicate is allowed.\n *\n * Time complexity with no duplicate - O(logn)\n * Time complexity with duplicates - O(n)\n *\n * https://leetcode.com/problems/search-in-rotated-sorted-array/\n * https://leetcode.com/problems/search-in-rotated-sorted-array-ii/\n */\npublic class SortedAndRotatedArraySearch {\n\n    /**\n     * Duplicates are not allowed in arr.\n     */\n    public int search(int arr[],int search){\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search){\n                return mid;\n            }\n            \n            if(arr[mid] < arr[high]){\n                if(arr[mid] < search && search <= arr[high]){\n                    low = mid+1;\n                }else{\n                    high = mid-1;\n                }\n            }else{\n                if(search >= arr[low] && search < arr[mid]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Duplicates are allowed in arr.\n     */\n    public boolean searchWithDuplicates(int[] arr, int search) {\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search) {\n                return true;\n            }\n            //if low is same as mid then increment low.\n            if (arr[mid] == arr[low]) {\n                low++;\n            } else if (arr[mid] == arr[high]) { //if high is same as mid then decrement high.\n                high--;\n            } else if (arr[mid] < arr[high]) {\n                if(arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if(search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String args[]){\n        SortedAndRotatedArraySearch ras = new SortedAndRotatedArraySearch();\n        int arr1[] = {1,2,5,6,7,8,11,21};\n        System.out.print(ras.search(arr1, 1));\n        System.out.print(ras.search(arr1, 5));\n        System.out.print(ras.search(arr1, 22));\n        System.out.println();\n    \n        int arr2[] = {18,21,1,2,5,6,7,8,10,15};\n        System.out.print(ras.search(arr2, 1));\n        System.out.print(ras.search(arr2, 5));\n        System.out.print(ras.search(arr2, 10));\n        System.out.print(ras.search(arr2, 14));\n        System.out.println();\n\n        int arr3[] = {7,8,15,17,18,21,1,2,5,6};\n        System.out.print(ras.search(arr3, 1));\n        System.out.print(ras.search(arr3, 5));\n        System.out.print(ras.search(arr3, 10));\n        System.out.print(ras.search(arr3, 7));\n        System.out.print(ras.search(arr3, 6));\n        System.out.print(ras.search(arr3, 16));\n    }\n}", "complexity": "logn", "from": "CorCod", "problem": 890, "index": 890}
{"src": "import java.util.*;\n\npublic class ehab4 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint a = 0, b = 0;\n\tSystem.out.println( \"? 0 0 \" );\n\tSystem.out.flush();\n\tint c = in.nextInt();\n\tfor ( int i = 29; i >= 0; i-- ) {\n\t    System.out.println( \"? \" + ( a + ( 1 << i ) ) + \" \" + b );\n\t    System.out.flush();\n\t    int q1 = in.nextInt();\n\t    System.out.println( \"? \" + a + \" \" + ( b + ( 1 << i ) ) );\n\t    System.out.flush();\n\t    int q2 = in.nextInt();\n\t    if ( q1 == q2 ) {\n\t\tif ( c == 1 )\n\t\t    a += ( 1 << i );\n\t\telse if ( c == -1 )\n\t\t    b += ( 1 << i );\n\t\tc = q1;\n\t    }\n\t    else if ( q1 == -1 ) {\n\t\ta += ( 1 << i );\n\t\tb += ( 1 << i );\n\t    }\n\t    else if ( q1 == -2 )\n\t\treturn;\n\t}\n\tSystem.out.println( \"! \" + a + \" \" + b );\n\tSystem.out.flush();\n    }\n}\n", "complexity": "logn", "from": "CorCod", "problem": 891, "index": 891}
{"src": "package com.interview.binarysearch;\n\n/**\n * There are two sorted arrays nums1 and nums2 of size m and n respectively.\n * Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n *\n * Solution\n * Take minimum size of two array. Possible number of partitions are from 0 to m in m size array.\n * Try every cut in binary search way. When you cut first array at i then you cut second array at (m + n + 1)/2 - i\n * Now try to find the i where a[i-1] <= b[j] and b[j-1] <= a[i]. So this i is partition around which lies the median.\n *\n * Time complexity is O(log(min(x,y))\n * Space complexity is O(1)\n *\n * https://leetcode.com/problems/median-of-two-sorted-arrays/\n * https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation/4\n */\npublic class MedianOfTwoSortedArrayOfDifferentLength {\n\n    public double findMedianSortedArrays(int input1[], int input2[]) {\n        //if input1 length is greater than switch them so that input1 is smaller than input2.\n        if (input1.length > input2.length) {\n            return findMedianSortedArrays(input2, input1);\n        }\n        int x = input1.length;\n        int y = input2.length;\n\n        int low = 0;\n        int high = x;\n        while (low <= high) {\n            int partitionX = (low + high)/2;\n            int partitionY = (x + y + 1)/2 - partitionX;\n\n            //if partitionX is 0 it means nothing is there on left side. Use -INF for maxLeftX\n            //if partitionX is length of input then there is nothing on right side. Use +INF for minRightX\n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : input1[partitionX - 1];\n            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : input1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : input2[partitionY - 1];\n            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : input2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                //We have partitioned array at correct place\n                // Now get max of left elements and min of right elements to get the median in case of even length combined array size\n                // or get max of left for odd length combined array size.\n                if ((x + y) % 2 == 0) {\n                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY))/2;\n                } else {\n                    return (double)Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) { //we are too far on right side for partitionX. Go on left side.\n                high = partitionX - 1;\n            } else { //we are too far on left side for partitionX. Go on right side.\n                low = partitionX + 1;\n            }\n        }\n\n        //Only we we can come here is if input arrays were not sorted. Throw in that scenario.\n        throw new IllegalArgumentException();\n    }\n\n    public static void main(String[] args) {\n        int[] x = {1, 3, 8, 9, 15};\n        int[] y = {7, 11, 19, 21, 18, 25};\n\n        MedianOfTwoSortedArrayOfDifferentLength mm = new MedianOfTwoSortedArrayOfDifferentLength();\n        mm.findMedianSortedArrays(x, y);\n    }\n}", "complexity": "logn", "from": "CorCod", "problem": 892, "index": 892}
{"src": "// http://www.geeksforgeeks.org/count-1s-sorted-binary-array/\nclass CountOne {\n\n  public static void main(String[] args) {\n    int[] arr={0, 0, 0, 0, 0, 0, 0};\n    //int[] arr={1, 1, 1, 1, 1, 1, 1};\n    //int[] arr = {1, 1, 1, 0, 0, 0, 0};  \n    countOne(arr);\n  }\n\n  public static void countOne(int[] a)\n  {\n       int l = 0;\n       int h = a.length-1;\n       int mid = -1;\n      \n       while(l<=h)\n       {\n         mid = (l+h)/2;\n         \n         if( (mid == h || a[mid+1] == 0) && a[mid] == 1)\n         {\n             System.out.println(\"Count \" + (mid + 1));\n             return;\n         }\n           \n         if( a[mid] < 1)\n         {\n             h = mid - 1;\n         } else {\n             l = mid + 1;\n         } \n       }\n       System.out.println(\" No one's found \");\n       return;\n  }\n}", "complexity": "logn", "from": "CorCod", "problem": 893, "index": 893}
{"src": "\n// A Java program to divide and conquer based \n// efficient solution to find \n// median of two sorted arrays \n// of same size. \nimport\njava.util.*; \nclass\nGfG { \n\n/* This function returns median \nof ar1[] and ar2[]. \nAssumptions in this function: \n\nBoth ar1[] and ar2[] are \n\nsorted arrays \n\nBoth have n elements */\nstatic\nint\ngetMedian(\nint\nar1[], \nint\nar2[], \nint\nn) \n{ \n\n/* return -1 for \n\ninvalid input */\n\nif\n(n <= \n0\n) \n\nreturn\n-\n1\n; \n\nif\n(n == \n1\n) \n\nreturn\n(ar1[\n0\n] + ar2[\n0\n]) / \n2\n; \n\nif\n(n == \n2\n) \n\nreturn\n(Math.max(ar1[\n0\n], ar2[\n0\n]) + Math.min(ar1[\n1\n], ar2[\n1\n])) / \n2\n; \n\n\n/* get the median of \n\nthe first array */\n\nint\nm1 = median(ar1, n); \n\n\n/* get the median of \n\nthe second array */\n\nint\nm2 = median(ar2, n); \n\n\n/* If medians are equal then \n\nreturn either m1 or m2 */\n\nif\n(m1 == m2) \n\nreturn\nm1; \n\n\n/* if m1 < m2 then median must \n\nexist in ar1[m1....] and \n\nar2[....m2] */\n\nif\n(m1 < m2) \n\n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar1 + n / \n2\n- \n1\n, ar2, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar1 + n / \n2\n, ar2, n - n / \n2\n); \n\n} \n\n\n/* if m1 > m2 then median must \n\nexist in ar1[....m1] and \n\nar2[m2...] */\n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar2 + n / \n2\n- \n1\n, ar1, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar2 + n / \n2\n, ar1, n - n / \n2\n); \n} \n\n/* Function to get median \nof a sorted array */\nstatic\nint\nmedian(\nint\narr[], \nint\nn) \n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\n(arr[n / \n2\n] + arr[n / \n2\n- \n1\n]) / \n2\n; \n\nelse\n\nreturn\narr[n / \n2\n]; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nar1[] = {\n1\n, \n2\n, \n3\n, \n6\n}; \n\nint\nar2[] = {\n4\n, \n6\n, \n8\n, \n10\n}; \n\nint\nn1 = ar1.length; \n\nint\nn2 = ar2.length; \n\nif\n(n1 == n2) \n\nSystem.out.println(\n\"Median is \"\n+ getMedian(ar1, ar2, n1)); \n\nelse\n\nSystem.out.println(\n\"Doesn't work for arrays \"\n+ \n\"of unequal size\"\n); \n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 894, "index": 894}
{"src": "import java.util.*;\npublic class mad{\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int cura = 0,curb = 0;\n        int ver;\n        System.out.println(\"? 0 0\");\n        System.out.flush();\n        ver = sc.nextInt();\n        for(int i=29;i>=0;i--){\n            System.out.println(\"? \"+(cura+(1<<i))+\" \"+curb);\n            System.out.flush();\n            int temp1 = sc.nextInt();\n            System.out.println(\"? \"+cura+\" \"+(curb+(1<<i)));\n            System.out.flush();\n            int temp2 = sc.nextInt();\n            if(temp1!=temp2){\n                if(temp2==1){\n                    cura += (1<<i);\n                    curb += (1<<i);\n                }\n            }\n            else{\n                if(ver==1) cura += (1<<i);\n                if(ver==-1) curb += (1<<i);\n                \n                ver = temp1;\n            }\n        }\n        System.out.println(\"! \"+cura+\" \"+curb);\n    }\n    \n}", "complexity": "logn", "from": "CorCod", "problem": 895, "index": 895}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BTheHat solver = new BTheHat();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BTheHat {\n        PrintWriter out;\n        InputReader in;\n        int n;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            n = in.NextInt();\n            int desiredPair = -1;\n            int result = query(1);\n            if (result != 0) {\n                int l = 2, r = 1 + n / 2;\n                while (l < r) {\n                    int m = (l + r) / 2;\n                    int mRes = query(m);\n                    if (mRes == 0) {\n                        desiredPair = m;\n                        break;\n                    } else if (mRes == result) {\n                        l = m + 1;\n                    } else {\n                        r = m;\n                    }\n                }\n            } else {\n                desiredPair = 1;\n            }\n            out.println(\"! \" + desiredPair);\n        }\n\n        private int query(int i) {\n            int iV = queryValue(i);\n            int iN2V = queryValue(i + n / 2);\n            if (iV < iN2V) {\n                return -1;\n            } else if (iV > iN2V) {\n                return 1;\n            }\n            return 0;\n        }\n\n        private int queryValue(int i) {\n            out.println(\"? \" + i);\n            out.flush();\n            return in.NextInt();\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "complexity": "logn", "from": "CorCod", "problem": 896, "index": 896}
{"src": "import java.util.*;\n\npublic class ehab4 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint a = 0, b = 0;\n\tSystem.out.println( \"? 0 0 \" );\n\tSystem.out.flush();\n\tint c = in.nextInt();\n\tfor ( int i = 29; i >= 0; i-- ) {\n\t    System.out.println( \"? \" + ( a + ( 1 << i ) ) + \" \" + b );\n\t    System.out.flush();\n\t    int q1 = in.nextInt();\n\t    System.out.println( \"? \" + a + \" \" + ( b + ( 1 << i ) ) );\n\t    System.out.flush();\n\t    int q2 = in.nextInt();\n\t    if ( q1 == q2 ) {\n\t\tif ( c == 1 )\n\t\t    a += ( 1 << i );\n\t\telse if ( c == -1 )\n\t\t    b += ( 1 << i );\n\t\tc = q1;\n\t    }\n\t    else if ( q1 == -1 ) {\n\t\ta += ( 1 << i );\n\t\tb += ( 1 << i );\n\t    }\n\t    else if ( q1 == -2 )\n\t\treturn;\n\t}\n\tSystem.out.println( \"! \" + a + \" \" + b );\n\tSystem.out.flush();\n    }\n}\n", "complexity": "logn", "from": "CorCod", "problem": 897, "index": 897}
{"src": "\n// Java program to find an element \n// in an almost sorted array \nclass\nGFG \n{ \n\n// A recursive binary search based function. \n\n// It returns index of x in given array \n\n// arr[l..r] is present, otherwise -1 \n\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r >= l) \n\n{ \n\nint\nmid = l + (r - l) / \n2\n; \n\n\n// If the element is present at \n\n// one of the middle 3 positions \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\nif\n(mid > l && arr[mid - \n1\n] == x) \n\nreturn\n(mid - \n1\n); \n\nif\n(mid < r && arr[mid + \n1\n] == x) \n\nreturn\n(mid + \n1\n); \n\n\n// If element is smaller than mid, then \n\n// it can only be present in left subarray \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid - \n2\n, x); \n\n\n// Else the element can only be present \n\n// in right subarray \n\nreturn\nbinarySearch(arr, mid + \n2\n, r, x); \n\n} \n\n\n// We reach here when element is \n\n// not present in array \n\nreturn\n-\n1\n; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nGFG ob = \nnew\nGFG(); \n\nint\narr[] = {\n3\n, \n2\n, \n10\n, \n4\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n4\n; \n\nint\nresult = ob.binarySearch(arr, \n0\n, n - \n1\n, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element is not present in array\"\n); \n\nelse\n\nSystem.out.println(\n\"Element is present at index \"\n+ \n\nresult); \n\n} \n} \n\n// This code is contributed by Rajat Mishra ", "complexity": "logn", "from": "CorCod", "problem": 898, "index": 898}
{"src": "\n// Java program to demonstrate working of \n// an algorithm that finds an element in an \n// array of infinite size \n\nclass\nTest \n{ \n\n// Simple binary search algorithm \n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r>=l) \n\n{ \n\nint\nmid = l + (r - l)/\n2\n; \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid-\n1\n, x); \n\nreturn\nbinarySearch(arr, mid+\n1\n, r, x); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n// Method takes an infinite size array and a key to be \n\n// searched and returns its position if found else -1. \n\n// We don't know size of arr[] and we can assume size to be \n\n// infinite in this function. \n\n// NOTE THAT THIS FUNCTION ASSUMES arr[] TO BE OF INFINITE SIZE \n\n// THEREFORE, THERE IS NO INDEX OUT OF BOUND CHECKING \n\nstatic\nint\nfindPos(\nint\narr[],\nint\nkey) \n\n{ \n\nint\nl = \n0\n, h = \n1\n; \n\nint\nval = arr[\n0\n]; \n\n\n// Find h to do binary search \n\nwhile\n(val < key) \n\n{ \n\nl = h; \n// store previous high \n\n//check that 2*h doesn't exceeds array \n\n//length to prevent ArrayOutOfBoundException \n\nif\n(\n2\n*h < arr.length-\n1\n) \n\nh = \n2\n*h; \n\nelse\n\nh = arr.length-\n1\n; \n\n\nval = arr[h]; \n// update new val \n\n} \n\n\n// at this point we have updated low \n\n// and high indices, thus use binary \n\n// search between them \n\nreturn\nbinarySearch(arr, l, h, key); \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n3\n, \n5\n, \n7\n, \n9\n, \n10\n, \n90\n, \n\n100\n, \n130\n, \n140\n, \n160\n, \n170\n}; \n\nint\nans = findPos(arr,\n10\n); \n\n\nif\n(ans==-\n1\n) \n\nSystem.out.println(\n\"Element not found\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at index \"\n+ ans); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 899, "index": 899}
{"src": "\n// Java program for Binary Search \nimport\njava.util.*; \n\nclass\nBinary \n{ \n\npublic\nstatic\nint\nf(\nint\nx) \n\n{ \nreturn\n(x*x - \n10\n*x - \n20\n); } \n\n\n// Returns the value x where above \n\n// function f() becomes positive \n\n// first time. \n\npublic\nstatic\nint\nfindFirstPositive() \n\n{ \n\n// When first value itself is positive \n\nif\n(f(\n0\n) > \n0\n) \n\nreturn\n0\n; \n\n\n// Find 'high' for binary search \n\n// by repeated doubling \n\nint\ni = \n1\n; \n\nwhile\n(f(i) <= \n0\n) \n\ni = i * \n2\n; \n\n\n// Call binary search \n\nreturn\nbinarySearch(i / \n2\n, i); \n\n} \n\n\n// Searches first positive value of \n\n// f(i) where low <= i <= high \n\npublic\nstatic\nint\nbinarySearch(\nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n/* mid = (low + high)/2 */\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n// If f(mid) is greater than 0 and \n\n// one of the following two \n\n// conditions is true: \n\n// a) mid is equal to low \n\n// b) f(mid-1) is negative \n\nif\n(f(mid) > \n0\n&& (mid == low || f(mid-\n1\n) <= \n0\n)) \n\nreturn\nmid; \n\n\n// If f(mid) is smaller than or equal to 0 \n\nif\n(f(mid) <= \n0\n) \n\nreturn\nbinarySearch((mid + \n1\n), high); \n\nelse\n// f(mid) > 0 \n\nreturn\nbinarySearch(low, (mid -\n1\n)); \n\n} \n\n\n/* Return -1 if there is no positive \n\nvalue in given range */\n\nreturn\n-\n1\n; \n\n} \n\n\n// driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print (\n\"The value n where f() \"\n+ \n\n\"becomes positive first is \"\n+ \n\nfindFirstPositive()); \n\n} \n} \n\n// This code is contributed by rishabh_jain ", "complexity": "logn", "from": "CorCod", "problem": 900, "index": 900}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class OlyaAndMagicalSquare {\n    void solve() {\n        long[] dp = new long[32];\n        dp[0] = 0;\n        for (int i = 1; i < 32; i++) {\n            dp[i] = 4 * dp[i - 1] + 1;\n        }\n        \n        int T = in.nextInt();\n        L:\n        while (T-- > 0) {\n            int n = in.nextInt(); long k = in.nextLong();\n            \n            if (n > 31) {\n                out.println(\"YES \" + (n - 1));\n                continue;\n            }\n            \n            long tot = 0;\n            for (int a = n - 1; a >= 0; a--) {\n                k -= (1L << (n - a)) - 1;\n                if (k < 0) break;\n                if (k == 0) {\n                    out.println(\"YES \" + a);\n                    continue L;\n                }\n                long limit = (1L << (n + 1 - a)) - 3;\n                if (k <= tot || dp[a] > 0 && (k - tot + dp[a] - 1) / dp[a] <= limit) {\n                    out.println(\"YES \" + a);\n                    continue L;\n                }\n                tot += dp[a] * limit;\n            }\n            out.println(\"NO\");\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new OlyaAndMagicalSquare().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "complexity": "logn", "from": "CorCod", "problem": 901, "index": 901}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class EhabAndAnotherAnotherXorProblem implements Closeable {\n\n  private InputReader in = new InputReader(System.in);\n  private PrintWriter out = new PrintWriter(System.out);\n\n  public void solve() {\n    int initial = ask(0, 0);\n    int a = 0, b = 0;\n    if (initial == 0) {\n      for (int i = 0; i < 30; i++) {\n        int response = ask(1 << i, 0);\n        if (response == -1) {\n          a |= (1 << i);\n        }\n      }\n      b = a;\n    } else {\n      for (int i = 29; i >= 0; i--) {\n        int response = ask(a | (1 << i), b | (1 << i));\n        if (response != initial) {\n          if (response == 1) {\n            b |= (1 << i);\n          } else {\n            a |= (1 << i);\n          }\n          initial = ask(a, b);\n        } else {\n          response = ask(a | (1 << i), b);\n          if (response == -1) {\n            a |= (1 << i);\n            b |= (1 << i);\n          }\n        }\n        \n      }\n    }\n    answer(a, b);\n  }\n\n  private int ask(int c, int d) {\n    out.printf(\"? %d %d\\n\", c, d);\n    out.flush();\n    return in.ni();\n  }\n\n  private void answer(int a, int b) {\n    out.printf(\"! %d %d\\n\", a, b);\n    out.flush();\n  }\n\n  @Override\n  public void close() throws IOException {\n    in.close();\n    out.close();\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int ni() {\n      return Integer.parseInt(next());\n    }\n\n    public long nl() {\n      return Long.parseLong(next());\n    }\n\n    public void close() throws IOException {\n      reader.close();\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    try (EhabAndAnotherAnotherXorProblem instance = new EhabAndAnotherAnotherXorProblem()) {\n      instance.solve();\n    }\n  }\n}\n", "complexity": "logn", "from": "CorCod", "problem": 902, "index": 902}
{"src": "import java.util.*;\nimport java.lang.*;\npublic class Main {\n    static long m = 1000000007;\n    static long powmod(long x, long y, long p)\n    {\n        // Initialize result\n        long res = 1;\n\n        // Update x if it is more\n        // than or equal to p\n        x = x % p;\n\n        while (y > 0)\n        {\n            // If y is odd, multiply x\n            // with result\n            if((y & 1)==1)\n                res = (res * x) % p;\n\n            // y must be even now\n            // y = y / 2\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    static long mulmod(long a, long b, long mod){\n        long res=0;\n        a = a % mod;\n        while (b > 0)\n        {\n            // If b is odd, add 'a' to result\n            if (b % 2 == 1)\n                res = (res + a) % mod;\n\n            // Multiply 'a' with 2\n            a = (a * 2) % mod;\n\n            // Divide b by 2\n            b /= 2;\n        }\n\n        // Return result\n        return res % mod;\n    }\n\n    public static void main(String args[] ) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        long x = sc.nextLong();\n        long k = sc.nextLong();\n        if(x>0) {\n            long d= powmod(2,k,m);\n            long ans= mulmod(d,2,m)%m;\n            ans= mulmod(ans,x,m)%m;\n            ans++;\n            ans%=m;\n            ans= (ans-d+m)%m;\n            System.out.println(ans);\n        }\n        else\n            System.out.println(0);\n    }\n}", "complexity": "logn", "from": "CorCod", "problem": 903, "index": 903}
{"src": "public class Search {\n\n    public static boolean find2(int[] array, int begin, int end, int element) {\n        if (begin <= end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return true;\n            else if (medium > begin && array[medium - 1] == element) return true;\n            else if (medium < end && array[medium + 1] == element) return true;\n\n            if (array[medium] > element) return find2(array, 0, medium - 2, element);\n            return find2(array, medium + 2, end, element);\n        }\n        return false;\n    }\n    \n    public static int find(int[] array, int begin, int end, int element) {\n        if (begin < end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return medium;\n            else if (medium > begin && array[medium - 1] == element) return medium - 1;\n            else if (medium < end && array[medium + 1] == element) return medium + 1;\n\n            if (array[medium] > element) return find(array, 0, medium - 2, element);\n            return find(array, medium + 2, end, element);\n\n\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] array = {12,13, 21, 36, 3, 43, 65, 76, 88, 91, 100};\n        System.out.println(find2(array, 0, array.length-1, 13));\n    }\n\n\n}", "complexity": "logn", "from": "CorCod", "problem": 904, "index": 904}
{"src": "\n/* Program to check for majority element in a sorted array */\nimport\njava.io.*; \n\nclass\nMajority { \n\n\n/* If x is present in arr[low...high] then returns the index of \n\nfirst occurrence of x, otherwise returns -1 */\n\nstatic\nint\n_binarySearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nif\n(high >= low) \n\n{ \n\nint\nmid = (low + high)/\n2\n; \n/*low + (high - low)/2;*/\n\n\n/* Check if arr[mid] is the first occurrence of x. \n\narr[mid] is first occurrence if x is one of the following \n\nis true: \n\n(i) mid == 0 and arr[mid] == x \n\n(ii) arr[mid-1] < x and arr[mid] == x \n\n*/\n\nif\n( (mid == \n0\n|| x > arr[mid-\n1\n]) && (arr[mid] == x) ) \n\nreturn\nmid; \n\nelse\nif\n(x > arr[mid]) \n\nreturn\n_binarySearch(arr, (mid + \n1\n), high, x); \n\nelse\n\nreturn\n_binarySearch(arr, low, (mid -\n1\n), x); \n\n} \n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n/* This function returns true if the x is present more than n/2 \n\ntimes in arr[] of size n */\n\nstatic\nboolean\nisMajority(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n/* Find the index of first occurrence of x in arr[] */\n\nint\ni = _binarySearch(arr, \n0\n, n-\n1\n, x); \n\n\n/* If element is not present at all, return false*/\n\nif\n(i == -\n1\n) \n\nreturn\nfalse\n; \n\n\n/* check if the element is present more than n/2 times */\n\nif\n(((i + n/\n2\n) <= (n -\n1\n)) && arr[i + n/\n2\n] == x) \n\nreturn\ntrue\n; \n\nelse\n\nreturn\nfalse\n; \n\n} \n\n\n/*Driver function to check for above functions*/\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n3\n, \n3\n, \n3\n, \n10\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nif\n(isMajority(arr, n, x)==\ntrue\n) \n\nSystem.out.println(x + \n\" appears more than \"\n+ \n\nn/\n2\n+ \n\" times in arr[]\"\n); \n\nelse\n\nSystem.out.println(x + \n\" does not appear more than \"\n+ \n\nn/\n2\n+ \n\" times in arr[]\"\n); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "complexity": "logn", "from": "CorCod", "problem": 905, "index": 905}
{"src": "\n// Java program to reverse the number \n// using a stack \nimport\njava.util.Stack; \n\npublic\nclass\nGFG \n{ \n\n// Stack to maintain order of digits \n\nstatic\nStack<Integer> st= \nnew\nStack<>(); \n\n\n// Function to push digits into stack \n\nstatic\nvoid\npush_digits(\nint\nnumber) \n\n{ \n\nwhile\n(number != \n0\n) \n\n{ \n\nst.push(number % \n10\n); \n\nnumber = number / \n10\n; \n\n} \n\n} \n\n\n// Function to reverse the number \n\nstatic\nint\nreverse_number(\nint\nnumber) \n\n{ \n\n// Function call to push number's \n\n// digits to stack \n\npush_digits(number); \n\nint\nreverse = \n0\n; \n\nint\ni = \n1\n; \n\n\n// Popping the digits and forming \n\n// the reversed number \n\nwhile\n(!st.isEmpty()) \n\n{ \n\nreverse = reverse + (st.peek() * i); \n\nst.pop(); \n\ni = i * \n10\n; \n\n} \n\n\n// Return the reversed number formed \n\nreturn\nreverse; \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nnumber = \n39997\n; \n\nSystem.out.println(reverse_number(number)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "complexity": "logn", "from": "CorCod", "problem": 906, "index": 906}
{"src": "\n// java program to find maximum \n// element \n\nclass\nMain \n{ \n\n// function to find the \n\n// maximum element \n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n\n/* Base Case: Only one element is \n\npresent in arr[low..high]*/\n\nif\n(low == high) \n\nreturn\narr[low]; \n\n\n/* If there are two elements and \n\nfirst is greater then the first \n\nelement is maximum */\n\nif\n((high == low + \n1\n) && arr[low] >= arr[high]) \n\nreturn\narr[low]; \n\n\n/* If there are two elements and \n\nsecond is greater then the second \n\nelement is maximum */\n\nif\n((high == low + \n1\n) && arr[low] < arr[high]) \n\nreturn\narr[high]; \n\n\n/*low + (high - low)/2;*/\n\nint\nmid = (low + high)/\n2\n; \n\n\n/* If we reach a point where arr[mid] \n\nis greater than both of its adjacent \n\nelements arr[mid-1] and arr[mid+1], \n\nthen arr[mid] is the maximum element*/\n\nif\n( arr[mid] > arr[mid + \n1\n] && arr[mid] > arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n/* If arr[mid] is greater than the next \n\nelement and smaller than the previous \n\nelement then maximum lies on left side \n\nof mid */\n\nif\n(arr[mid] > arr[mid + \n1\n] && arr[mid] < arr[mid - \n1\n]) \n\nreturn\nfindMaximum(arr, low, mid-\n1\n); \n\nelse\n\nreturn\nfindMaximum(arr, mid + \n1\n, high); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n3\n, \n50\n, \n10\n, \n9\n, \n7\n, \n6\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"The maximum element is \"\n+ \n\nfindMaximum(arr, \n0\n, n-\n1\n)); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 907, "index": 907}
{"src": "package com.interview.binarysearch;\n\n/**\n * http://www.geeksforgeeks.org/search-floor-and-ceil-in-a-sorted-array/\n */\npublic class FloorAndCeilingSortedArray {\n\n    public int floor(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] < x && (middle == input.length-1 || input[middle+1] > x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n\n    public int ceiling(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] > x && (middle == 0 || input[middle-1] < x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        int input[] = {1,2,5,6,11,15};\n        FloorAndCeilingSortedArray foc = new FloorAndCeilingSortedArray();\n        System.out.println(foc.floor(input, 15));\n        System.out.println(foc.ceiling(input, 2));\n    }\n}", "complexity": "logn", "from": "CorCod", "problem": 908, "index": 908}
{"src": "\n/* Java program to search an element \n\nin a sorted and pivoted array*/\n\nclass\nMain \n{ \n\n\n/* Searches an element key in a \n\npivoted sorted array arrp[] \n\nof size n */\n\nstatic\nint\npivotedBinarySearch(\nint\narr[], \nint\nn, \nint\nkey) \n\n{ \n\nint\npivot = findPivot(arr, \n0\n, n-\n1\n); \n\n\n// If we didn't find a pivot, then \n\n// array is not rotated at all \n\nif\n(pivot == -\n1\n) \n\nreturn\nbinarySearch(arr, \n0\n, n-\n1\n, key); \n\n\n// If we found a pivot, then first \n\n// compare with pivot and then \n\n// search in two subarrays around pivot \n\nif\n(arr[pivot] == key) \n\nreturn\npivot; \n\nif\n(arr[\n0\n] <= key) \n\nreturn\nbinarySearch(arr, \n0\n, pivot-\n1\n, key); \n\nreturn\nbinarySearch(arr, pivot+\n1\n, n-\n1\n, key); \n\n} \n\n\n/* Function to get pivot. For array \n\n3, 4, 5, 6, 1, 2 it returns \n\n3 (index of 6) */\n\nstatic\nint\nfindPivot(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n// base cases \n\nif\n(high < low) \n\nreturn\n-\n1\n; \n\nif\n(high == low) \n\nreturn\nlow; \n\n\n/* low + (high - low)/2; */\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(mid < high && arr[mid] > arr[mid + \n1\n]) \n\nreturn\nmid; \n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\n(mid-\n1\n); \n\nif\n(arr[low] >= arr[mid]) \n\nreturn\nfindPivot(arr, low, mid-\n1\n); \n\nreturn\nfindPivot(arr, mid + \n1\n, high); \n\n} \n\n\n/* Standard Binary Search function */\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nkey) \n\n{ \n\nif\n(high < low) \n\nreturn\n-\n1\n; \n\n\n/* low + (high - low)/2; */\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(key == arr[mid]) \n\nreturn\nmid; \n\nif\n(key > arr[mid]) \n\nreturn\nbinarySearch(arr, (mid + \n1\n), high, key); \n\nreturn\nbinarySearch(arr, low, (mid -\n1\n), key); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n// Let us search 3 in below array \n\nint\narr1[] = {\n5\n, \n6\n, \n7\n, \n8\n, \n9\n, \n10\n, \n1\n, \n2\n, \n3\n}; \n\nint\nn = arr1.length; \n\nint\nkey = \n3\n; \n\nSystem.out.println(\n\"Index of the element is : \"\n\n+ pivotedBinarySearch(arr1, n, key)); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 909, "index": 909}
{"src": "package com.rampatra.searching;\n\n/**\n * Created by IntelliJ IDEA.\n *\n * @author rampatra\n * @version 9/1/15\n */\npublic class BinarySearch {\n\n    /**\n     * Searches an element {@param n} in a sorted array {@param a}\n     * and returns its index in O(log n) time. The Index may not\n     * correspond to the first occurrence of the element.\n     *\n     * @param a sorted array to be searched\n     * @param n number to be searched in the array\n     * @return index of {@param n} or {@code -1} if not present\n     */\n    private static int binarySearch(int[] a, int n) {\n        return binarySearch(a, n, 0, a.length - 1);\n    }\n\n    public static int binarySearch(int[] a, int n, int low, int high) {\n\n        if (low <= high) {\n            int mid = (low + high) / 2; // to prevent overflow you can instead do: mid = low + (high - low) / 2\n\n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                return binarySearch(a, n, 0, mid - 1);\n            } else {\n                return binarySearch(a, n, mid + 1, high);\n            }\n        } else {\n            return -1;\n        }\n    }\n\n    /**\n     * Non-recursive version of binary search.\n     *\n     * @param a sorted array to be searched\n     * @param n number to be searched in the array\n     * @return index of {@param n} or {@code -1} if not present\n     */\n    private static int binarySearchNonRecursive(int[] a, int n) {\n        int low = 0, high = a.length, mid;\n        while (low <= high) {\n            mid = (low + high) / 2; // to prevent overflow you can instead do: mid = low + (high - low) / 2\n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Driver for testing.\n     *\n     * @param a\n     */\n    public static void main(String[] args) {\n        System.out.println(binarySearch(new int[]{0, 2}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearch(new int[]{0, 2}, 0));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 2, 2, 3, 3}, 2)); // doesn't return index of first occurrence\n        System.out.println(\"---------\");\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 0));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));\n    }\n}", "complexity": "logn", "from": "CorCod", "problem": 910, "index": 910}
{"src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Codechef\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner in=new Scanner(System.in);\n\t\tlong x=in.nextLong();\n\t\tlong k=in.nextLong();\n\t\t\n\t\tlong mod=1000000007;\n\t\tlong get=power(2,k,mod);\n\t\tlong ans=((get%mod)*((2*x)%mod))%mod-get+1;\n\t\tif(ans<0)\n\t\tans+=mod;\n\t\tif(x==0)\n\t\tans=0;\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\tstatic long power(long x, long y, long p)\n    {\n        // Initialize result\n        long res = 1;     \n        \n        // Update x if it is more  \n        // than or equal to p\n        x = x % p; \n     \n        while (y > 0)\n        {\n            // If y is odd, multiply x\n            // with result\n            if((y & 1)==1)\n                res = (res * x) % p;\n     \n            // y must be even now\n            // y = y / 2\n            y = y >> 1; \n            x = (x * x) % p; \n        }\n        return res;\n    }\n}\n", "complexity": "logn", "from": "CorCod", "problem": 911, "index": 911}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Liavontsi Brechka\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DEhabIEsheOdnaOcherednayaZadachaNaXor solver = new DEhabIEsheOdnaOcherednayaZadachaNaXor();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DEhabIEsheOdnaOcherednayaZadachaNaXor {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int c = 0;\n            int d = 0;\n\n            int prevSign = 0;\n            int nextSign;\n            boolean zeroOut = true;\n            for (int i = 29; i >= 0; i--) {\n                if (zeroOut) {\n                    print(c, d, out);\n                    prevSign = read(in);\n                }\n\n                print((1 << i) | c, (1 << i) | d, out);\n                nextSign = read(in);\n\n                if (prevSign == nextSign) {\n                    zeroOut = false;\n\n                    print((1 << i) | c, d, out);\n                    nextSign = read(in);\n\n                    if (nextSign < 0) {\n                        c = (1 << i) | c;\n                        d = (1 << i) | d;\n                    }\n                } else {\n                    zeroOut = true;\n\n                    if (nextSign < 0) c = (1 << i) | c;\n                    else d = (1 << i) | d;\n                }\n            }\n\n            out.printf(\"! %d %d\", c, d);\n            out.flush();\n        }\n\n        private void print(int c, int d, PrintWriter out) {\n            out.printf(\"? %d %d\\n\", c, d);\n            out.flush();\n        }\n\n        private int read(InputReader in) {\n            return in.nextInt();\n        }\n\n    }\n\n    static class InputReader {\n        private final BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String readLine() {\n            String line;\n            try {\n                line = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return line;\n        }\n\n    }\n}\n\n", "complexity": "logn", "from": "CorCod", "problem": 912, "index": 912}
{"src": "\n// Java program to find minimum element in a sorted and rotated array \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nMinimum \n{ \n\nstatic\nint\nfindMin(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n// This condition is needed to handle the case when array \n\n// is not rotated at all \n\nif\n(high < low) \nreturn\narr[\n0\n]; \n\n\n// If there is only one element left \n\nif\n(high == low) \nreturn\narr[low]; \n\n\n// Find mid \n\nint\nmid = low + (high - low)/\n2\n; \n/*(low + high)/2;*/\n\n\n// Check if element (mid+1) is minimum element. Consider \n\n// the cases like {3, 4, 5, 1, 2} \n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\narr[mid+\n1\n]; \n\n\n// Check if mid itself is minimum element \n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n// Decide whether we need to go to left half or right half \n\nif\n(arr[high] > arr[mid]) \n\nreturn\nfindMin(arr, low, mid-\n1\n); \n\nreturn\nfindMin(arr, mid+\n1\n, high); \n\n} \n\n\n// Driver Program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr1[] = {\n5\n, \n6\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr1, \n0\n, n1-\n1\n)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr2, \n0\n, n2-\n1\n)); \n\n\nint\narr3[] = {\n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr3, \n0\n, n3-\n1\n)); \n\n\nint\narr4[] = {\n1\n, \n2\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr4, \n0\n, n4-\n1\n)); \n\n\nint\narr5[] = {\n2\n, \n1\n}; \n\nint\nn5 = arr5.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr5, \n0\n, n5-\n1\n)); \n\n\nint\narr6[] = {\n5\n, \n6\n, \n7\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn6 = arr6.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr6, \n0\n, n6-\n1\n)); \n\n\nint\narr7[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn7 = arr7.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr7, \n0\n, n7-\n1\n)); \n\n\nint\narr8[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n1\n}; \n\nint\nn8 = arr8.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr8, \n0\n, n8-\n1\n)); \n\n\nint\narr9[] = {\n3\n, \n4\n, \n5\n, \n1\n, \n2\n}; \n\nint\nn9 = arr9.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr9, \n0\n, n9-\n1\n)); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 913, "index": 913}
{"src": "\n// A Java program to find a peak element element using divide and conquer \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nPeakElement \n{ \n\n// A binary search based function that returns index of a peak \n\n// element \n\nstatic\nint\nfindPeakUtil(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nn) \n\n{ \n\n// Find index of middle element \n\nint\nmid = low + (high - low)/\n2\n; \n/* (low + high)/2 */\n\n\n// Compare middle element with its neighbours (if neighbours \n\n// exist) \n\nif\n((mid == \n0\n|| arr[mid-\n1\n] <= arr[mid]) && (mid == n-\n1\n|| \n\narr[mid+\n1\n] <= arr[mid])) \n\nreturn\nmid; \n\n\n// If middle element is not peak and its left neighbor is \n\n// greater than it,then left half must have a peak element \n\nelse\nif\n(mid > \n0\n&& arr[mid-\n1\n] > arr[mid]) \n\nreturn\nfindPeakUtil(arr, low, (mid -\n1\n), n); \n\n\n// If middle element is not peak and its right neighbor \n\n// is greater than it, then right half must have a peak \n\n// element \n\nelse\nreturn\nfindPeakUtil(arr, (mid + \n1\n), high, n); \n\n} \n\n\n// A wrapper over recursive function findPeakUtil() \n\nstatic\nint\nfindPeak(\nint\narr[], \nint\nn) \n\n{ \n\nreturn\nfindPeakUtil(arr, \n0\n, n-\n1\n, n); \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n3\n, \n20\n, \n4\n, \n1\n, \n0\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Index of a peak point is \"\n+ \n\nfindPeak(arr, n)); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 914, "index": 914}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\nimport java.util.stream.IntStream;\n\npublic class B {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\n        Solver solver = new Solver();\n        solver.solve(in, out);\n        out.close();\n    }\n\n    static class Solver {\n        int n;\n        int n2;\n        InputReader in;\n        PrintWriter out;\n\n        public void solve(InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.readInt();\n            n2 = n/2;\n\n            int res = find();\n            out.print(\"! \");\n            out.println(res);\n        }\n\n        public int find() {\n            if (n%4 != 0) return -1;\n            int c = compare(0);\n            if (c == 0) return 1;\n            int s = 1;\n            int f = n2-1;\n            if (c > 0) {\n                s = n2+1;\n                f = n-1;\n            }\n            while (s <= f) {\n                int m = (s+f)/2;\n                int v = compare(m);\n                if (v == 0) return m+1;\n                else if (v < 0) s = m+1;\n                else f = m-1;\n            }\n            return -1;\n        }\n\n        public int compare(int z) {\n            out.print(\"? \");\n            out.println(z+1);\n            out.flush();\n            int r1 = in.readInt();\n            out.print(\"? \");\n            out.println((z+n2)%n+1);\n            out.flush();\n            int r2 = in.readInt();\n            return r1-r2;\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            this.reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String read() {\n            try {\n                if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n            } catch (IOException ex) {\n                throw new RuntimeException(ex);\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int readInt() {\n            return Integer.parseInt(read());\n        }\n\n        public long readLong() {\n            return Long.parseLong(read());\n        }\n\n        public void readIntArrays(int[]... arrays) {\n            for (int i = 0; i < arrays[0].length; i++) {\n                for (int j = 0; j < arrays.length; j++) {\n                    arrays[j][i] = readInt();\n                }\n            }\n        }\n    }\n\n}", "complexity": "logn", "from": "CorCod", "problem": 915, "index": 915}
{"src": "import java.util.*;\nimport java.io.*;\npublic class code{\n    public static void main(String[] args) throws IOException{\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int ok,ok2;\n        int va,vb;\n        va = 0;\n        vb = 0;\n        out.println(\"? \"+va+\" \"+vb);\n        out.flush();\n        ok = sc.nextInt();\n        for(int i=29;i>=0;i--){\n            if(ok==0){\n                va += (1<<i);\n                out.println(\"? \"+va+\" \"+vb);\n                out.flush();\n                ok2 = sc.nextInt();\n                if(ok2==1){\n                    va -= (1<<i);\n                }else{\n                    vb += (1<<i);\n                }\n            }else{\n                va += (1<<i);\n                vb += (1<<i);\n                out.println(\"? \"+va+\" \"+vb);\n                out.flush();\n                ok2 = sc.nextInt();\n                if(ok==ok2){\n                    vb -= (1<<i);\n                    out.println(\"? \"+va+\" \"+vb);\n                    out.flush();\n                    ok2 = sc.nextInt();\n                    if(ok2==1){\n                        va -= (1<<i);\n                    }else{\n                        vb += (1<<i);\n                    }\n                }else{\n                    if(ok==1){\n                        vb -= (1<<i);\n                        out.println(\"? \"+va+\" \"+vb);\n                        out.flush();\n                        ok = sc.nextInt();\n                    }\n                    else {\n                        va -= (1<<i);\n                        out.println(\"? \"+va+\" \"+vb);\n                        out.flush();\n                        ok = sc.nextInt();\n                    }\n                }\n            }\n        }\n        out.println(\"! \"+va+\" \"+vb);\n        out.flush();\n    }\n}", "complexity": "logn", "from": "CorCod", "problem": 916, "index": 916}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author programajor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        BigInteger mod = new BigInteger(\"1000000007\");\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            BigInteger x = new BigInteger(in.next());\n            BigInteger k = new BigInteger(in.next());\n            if (x.longValue() == 0) {\n                out.print(x);\n                return;\n            }\n            BigInteger pow = powerWithMod(new BigInteger(\"2\"), k);\n            BigInteger current = x.mod(mod).multiply(pow).mod(mod);\n            BigInteger result = current.multiply(new BigInteger(\"2\")).mod(mod)\n                    .subtract(pow.subtract(new BigInteger(\"1\")).mod(mod))\n                    .mod(mod);\n            out.print(result);\n        }\n\n        BigInteger powerWithMod(BigInteger base, BigInteger exponent) {\n            if (exponent.longValue() == 0) {\n                return new BigInteger(\"1\");\n            }\n            BigInteger temp = powerWithMod(base, exponent.divide(new BigInteger(\"2\")));\n            BigInteger term = temp.mod(mod);\n            if (exponent.mod(new BigInteger(\"2\")).intValue() == 0) {\n                return term.multiply(term.mod(mod)).mod(mod);\n            } else {\n                return term.multiply(term.mod(mod)).multiply(base.mod(mod)).mod(mod);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n    }\n}\n\n", "complexity": "logn", "from": "CorCod", "problem": 917, "index": 917}
{"src": "\n// Java program to count 1's in a sorted array \nclass\nCountOnes \n{ \n\n/* Returns counts of 1's in arr[low..high]. The \n\narray is assumed to be sorted in non-increasing \n\norder */\n\nint\ncountOnes(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n// get the middle index \n\nint\nmid = low + (high - low)/\n2\n; \n\n\n// check if the element at middle index is last 1 \n\nif\n( (mid == high || arr[mid+\n1\n] == \n0\n) && \n\n(arr[mid] == \n1\n)) \n\nreturn\nmid+\n1\n; \n\n\n// If element is not last 1, recur for right side \n\nif\n(arr[mid] == \n1\n) \n\nreturn\ncountOnes(arr, (mid + \n1\n), high); \n\n\n// else recur for left side \n\nreturn\ncountOnes(arr, low, (mid -\n1\n)); \n\n} \n\nreturn\n0\n; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nCountOnes ob = \nnew\nCountOnes(); \n\nint\narr[] = {\n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n0\n, \n0\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Count of 1's in given array is \"\n+ \n\nob.countOnes(arr, \n0\n, n-\n1\n) ); \n\n} \n} \n/* This code is contributed by Rajat Mishra */", "complexity": "logn", "from": "CorCod", "problem": 918, "index": 918}
{"src": "\n// Java program to check fixed point \n// in an array using binary search \n\nclass\nMain \n{ \n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n/* low + (high - low)/2; */\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(mid == arr[mid]) \n\nreturn\nmid; \n\nif\n(mid > arr[mid]) \n\nreturn\nbinarySearch(arr, (mid + \n1\n), high); \n\nelse\n\nreturn\nbinarySearch(arr, low, (mid -\n1\n)); \n\n} \n\n\n/* Return -1 if there is \n\nno Fixed Point */\n\nreturn\n-\n1\n; \n\n} \n\n\n//main function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {-\n10\n, -\n1\n, \n0\n, \n3\n, \n10\n, \n11\n, \n30\n, \n50\n, \n100\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Fixed Point is \"\n\n+ binarySearch(arr,\n0\n, n-\n1\n)); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 919, "index": 919}
{"src": "class findMedianTwoArrays\n{\n  public static double main(\n    int[] arr1, int start1, int end1, int[] arr2, int start2, int end2) {\n    if ( end1 - start1 == 1 && end2 - start2 == 1 ) {\n        return ( Math.max(arr1[start1], arr2[start2]) + Math.min(arr1[end1], arr2[end2]) ) / 2;\n    }    \n  \n  int median1Index = Math.floor((start1 + end1 ) / 2);\n  int median2Index = Math.floor((start2 + end2 ) / 2);\n  int median1 = arr1[median1Index];\n  int median2 = arr2[median2Index];\n\n  if ( median1 == median2 ) {\n    return median1;\n  }    \n\n  if ( median1 < median2 ) {\n    start1 = median1Index;\n    if ( end2 - start2 > 1 ) { \n        end2 = median2Index;\n    }        \n  } else {\n    start2 = median2Index;\n    if ( end1 - start1 > 1 ) { \n        end1 = median1Index;\n    }    \n  }            \n\n  return main(arr1, start1, end1, arr2, start2, end2);\n  }\n}\n\nclass test {\n  public static void main(String[] args) {\n    int[] A = { 1, 2, 3, 4, 4 };\n    int[] B = { 6, 9, 10, 11, 15};\n    findMedianTwoArrays findMedian = new findMedianTwoArrays();\n    System.out.println(\"Hello Java\");\n    System.out.println(findMedian.main(A, 0, 4, B, 0, 4));\n  }    \n} ", "complexity": "logn", "from": "CorCod", "problem": 920, "index": 920}
{"src": "\nclass\nMain \n{ \n\n/* Function to get index of \n\nceiling of x in arr[low..high]*/\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\nmid; \n\n\n/* If x is smaller than or equal to the \n\nfirst element, then return the first element */\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n/* If x is greater than the last \n\nelement, then return -1 */\n\nif\n(x > arr[high]) \n\nreturn\n-\n1\n; \n\n\n/* get the index of middle element \n\nof arr[low..high]*/\n\nmid = (low + high)/\n2\n; \n/* low + (high - low)/2 */\n\n\n/* If x is same as middle element, \n\nthen return mid */\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n/* If x is greater than arr[mid], then \n\neither arr[mid + 1] is ceiling of x or \n\nceiling lies in arr[mid+1...high] */\n\nelse\nif\n(arr[mid] < x) \n\n{ \n\nif\n(mid + \n1\n<= high && x <= arr[mid+\n1\n]) \n\nreturn\nmid + \n1\n; \n\nelse\n\nreturn\nceilSearch(arr, mid+\n1\n, high, x); \n\n} \n\n\n/* If x is smaller than arr[mid], \n\nthen either arr[mid] is ceiling of x \n\nor ceiling lies in arr[mid-1...high] */\n\nelse\n\n{ \n\nif\n(mid - \n1\n>= low && x > arr[mid-\n1\n]) \n\nreturn\nmid; \n\nelse\n\nreturn\nceilSearch(arr, low, mid - \n1\n, x); \n\n} \n\n} \n\n\n\n/* Driver program to check above functions */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n8\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 921, "index": 921}
{"src": "\n// Java implementation of iterative Binary Search \nclass\nBinarySearch { \n\n// Returns index of x if it is present in arr[], \n\n// else return -1 \n\nint\nbinarySearch(\nint\narr[], \nint\nx) \n\n{ \n\nint\nl = \n0\n, r = arr.length - \n1\n; \n\nwhile\n(l <= r) { \n\nint\nm = l + (r - l) / \n2\n; \n\n\n// Check if x is present at mid \n\nif\n(arr[m] == x) \n\nreturn\nm; \n\n\n// If x greater, ignore left half \n\nif\n(arr[m] < x) \n\nl = m + \n1\n; \n\n\n// If x is smaller, ignore right half \n\nelse\n\nr = m - \n1\n; \n\n} \n\n\n// if we reach here, then element was \n\n// not present \n\nreturn\n-\n1\n; \n\n} \n\n\n// Driver method to test above \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinarySearch ob = \nnew\nBinarySearch(); \n\nint\narr[] = { \n2\n, \n3\n, \n4\n, \n10\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n10\n; \n\nint\nresult = ob.binarySearch(arr, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element not present\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at \"\n\n+ \n\"index \"\n+ result); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 922, "index": 922}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\nimport java.util.PriorityQueue;\nimport static java.lang.Math.*;\n\npublic class solution implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\tstatic int mod = (int)1e9+7;\n\tpublic static long fastexpo(long pow)\n\t{\n\t\tlong expo = 2;\n\t\tlong ans = 1;\n\t\twhile(pow!=0)\n\t\t{\n\t\t\tif((pow&1)==1)\n\t\t\t{\n\t\t\t\tans = (ans*expo)%mod;\n\t\t\t}\n\t\t\texpo = (expo*expo)%mod;\n\t\t\tpow = pow>>1;\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic static void main(String args[]) throws Exception {\n        new Thread(null, new solution(),\"Main\",1<<26).start();\n    }\n\tpublic void run() {\n        InputReader sc  = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong x = sc.nextLong();\n\t\tif(x==0)\n\t\t{\n\t\t\tout.println(0);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\tlong k = sc.nextLong();\n\t\tlong a = ((fastexpo(k+1)%mod)*(x%mod))%mod;\n\t\tlong b = (-1*fastexpo(k)%mod+mod)%mod;\n\t\tlong ans = (a+b+1)%mod;\n\t\tout.println(ans);\n\t\tout.close();\n    }\n}", "complexity": "logn", "from": "CorCod", "problem": 923, "index": 923}
{"src": "\n// Java program to count \n// occurrences of an element \nclass\nGFG \n{ \n\n\n// A recursive binary search \n\n// function. It returns location \n\n// of x in given array arr[l..r] \n\n// is present, otherwise -1 \n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n\n{ \n\nif\n(r < l) \n\nreturn\n-\n1\n; \n\n\nint\nmid = l + (r - l) / \n2\n; \n\n\n// If the element is present \n\n// at the middle itself \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n// If element is smaller than \n\n// mid, then it can only be \n\n// present in left subarray \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, \n\nmid - \n1\n, x); \n\n\n// Else the element can \n\n// only be present in \n\n// right subarray \n\nreturn\nbinarySearch(arr, mid + \n1\n, r, x); \n\n} \n\n\n// Returns number of times x \n\n// occurs in arr[0..n-1] \n\nstatic\nint\ncountOccurrences(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\nint\nind = binarySearch(arr, \n0\n, \n\nn - \n1\n, x); \n\n\n// If element is not present \n\nif\n(ind == -\n1\n) \n\nreturn\n0\n; \n\n\n// Count elements on left side. \n\nint\ncount = \n1\n; \n\nint\nleft = ind - \n1\n; \n\nwhile\n(left >= \n0\n&& \n\narr[left] == x) \n\n{ \n\ncount++; \n\nleft--; \n\n} \n\n\n// Count elements \n\n// on right side. \n\nint\nright = ind + \n1\n; \n\nwhile\n(right < n && \n\narr[right] == x) \n\n{ \n\ncount++; \n\nright++; \n\n} \n\n\nreturn\ncount; \n\n} \n\n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n\n3\n, \n4\n, \n7\n, \n8\n, \n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.print(countOccurrences(arr, n, x)); \n\n} \n} \n\n// This code is contributed \n// by ChitraNayal ", "complexity": "logn", "from": "CorCod", "problem": 924, "index": 924}
{"src": "\nclass\nSmallestMissing \n{ \n\nint\nfindFirstMissing(\nint\narray[], \nint\nstart, \nint\nend) \n\n{ \n\nif\n(start > end) \n\nreturn\nend + \n1\n; \n\n\nif\n(start != array[start]) \n\nreturn\nstart; \n\n\nint\nmid = (start + end) / \n2\n; \n\n\n// Left half has all elements from 0 to mid \n\nif\n(array[mid] == mid) \n\nreturn\nfindFirstMissing(array, mid+\n1\n, end); \n\n\nreturn\nfindFirstMissing(array, start, mid); \n\n} \n\n\n// Driver program to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSmallestMissing small = \nnew\nSmallestMissing(); \n\nint\narr[] = {\n0\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"First Missing element is : \"\n\n+ small.findFirstMissing(arr, \n0\n, n - \n1\n)); \n\n} \n} ", "complexity": "logn", "from": "CorCod", "problem": 925, "index": 925}
{"src": "package com.interview.binarysearch;\n\n/**\n * Date 07/31/2016\n * @author Tushar Roy\n *\n * Given a sorted array of integers, find the starting and ending position of a given target value.\n *\n * Time complexity O(logn)\n * Space complexity O(1)\n * \n * https://leetcode.com/problems/search-for-a-range/\n */\npublic class SearchForRange {\n    public int[] searchRange(int[] nums, int target) {\n        int first = firstOccurence(nums, target);\n        if (first == -1) {\n            return new int[]{-1, -1};\n        }\n        int last = lastOccurence(nums, target);\n        return new int[]{first, last};\n    }\n\n    private int firstOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {\n                return mid;\n            } else if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    private int lastOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {\n                return mid;\n            } else if (nums[mid] <= target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        SearchForRange searchForRange = new SearchForRange();\n        int[] nums = {0, 1, 1, 3, 6, 9, 11};\n        int[] r = searchForRange.searchRange(nums, 11);\n        System.out.println(r[0] + \" \" + r[1]);\n        r = searchForRange.searchRange(nums, 0);\n        System.out.println(r[0] + \" \" + r[1]);\n    }\n}", "complexity": "logn", "from": "CorCod", "problem": 926, "index": 926}
{"src": "package com.interview.binarysearch;\n\n/**\n * Regular binary search\n */\npublic class BinarySearch {\n\n    public int search(final int input[], int search) {\n        int low = 0;\n        int high = input.length - 1;\n        int mid;\n        while (low <= high) {\n            mid = low + ((high - low) / 2);\n            if (input[mid] == search) {\n                return mid;\n            } else if (input[mid] < search) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        BinarySearch bSearch = new BinarySearch();\n        final int arr1[] = {1, 2, 4, 5, 7, 8};\n        System.out.println(bSearch.search(arr1, -1));\n        System.out.println(bSearch.search(arr1, 1));\n        System.out.println(bSearch.search(arr1, 8));\n        System.out.println(bSearch.search(arr1, 2));\n    }\n}", "complexity": "logn", "from": "CorCod", "problem": 927, "index": 927}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        FastReader in;\n        PrintWriter out;\n        int n;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.nextInt();\n            if (n % 4 != 0) {\n                out.println(\"! -1\");\n                return;\n            }\n            int low = 0;\n            int high = n >> 1;\n            int fSign = Integer.signum(BValue(low));\n            if (fSign == 0) {\n                out.println(\"! \" + (low + 1));\n                return;\n            }\n            while (high - low > 1) {\n                int mid = (high + low) >> 1;\n                int mSign = Integer.signum(BValue(mid));\n                if (mSign == 0) {\n                    out.println(\"! \" + (mid + 1));\n                    return;\n                }\n                if (mSign == -fSign) {\n                    high = mid;\n                } else {\n                    low = mid;\n                }\n            }\n            out.println(\"! -1\");\n        }\n\n        public int BValue(int index) {\n            out.println(\"? \" + (index + 1));\n            out.flush();\n            int f = in.nextInt();\n            out.println(\"? \" + (index + 1 + (n >> 1)));\n            out.flush();\n            int s = in.nextInt();\n            return f - s;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "logn", "from": "CorCod", "problem": 928, "index": 928}
{"src": "package com.interview.binarysearch;\n\n/**\n * http://www.careercup.com/question?id=4877486110277632\n * Given a circle with N defined points and a point M outside the circle, \n * find the point that is closest to M among the set of N. O(LogN)\n * Test cases\n * 1) smallest element at center\n * 2) smallest element at left/right end\n * 3) largest element at center\n * 4) smallest element at left side\n * 5) smallest element at right side\n */\npublic class CircularBinarySearch {\n\n    //if mid is greater than both ends than result is low of two ends else move in direction\n    //where either mid-1 or mid+1 is less\n    public int search(int arr[]) {\n        int low = 0;\n        int high = arr.length - 1;\n        int mid = 0;\n        while (low < high) {\n            mid = (low + high) / 2;\n            //if middle is less than both mid-1 and mid+1 then mid is the answer\n            if((low == mid || arr[mid] < arr[mid-1])&& arr[mid] < arr[mid+1]){\n                return arr[mid];\n            }\n            if ((arr[mid] >= arr[low] && arr[mid] >= arr[high])){\n                if(arr[low] < arr[high]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }else{\n                if(arr[mid-1] < arr[mid+1]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return arr[low];\n    }\n\n    public static void main(String args[]) {\n        CircularBinarySearch cbs = new CircularBinarySearch();\n        int arr[] = { 7, 10, 8, 5, 2, 3, 5 };\n        System.out.print(cbs.search(arr));\n\n        int arr1[] = { 5, 8, 10, 7, 5, 3, 2 };\n        System.out.print(cbs.search(arr1));\n\n        int arr2[] = { 3, 5, 7, 10, 8, 5, 2 };\n        System.out.print(cbs.search(arr2));\n\n        int arr3[] = { 8, 5, 2, 3, 5, 7, 10 };\n        System.out.print(cbs.search(arr3));\n\n        int arr4[] = { 5, 3, 2, 5, 8, 10, 7 };\n        System.out.print(cbs.search(arr4));\n\n        int arr5[] = {100,20,10,5,2,8,11,16,19};\n        System.out.print(cbs.search(arr5));\n\n        int arr6[] = {200,2,10,15,20,80,110,160,190};\n        System.out.print(cbs.search(arr6));\n\n        int arr7[] = {5,10,20,50,200,800,1100,1600,1900,2};\n        System.out.print(cbs.search(arr7));\n\n        int arr8[] = {2,5,10,20,50,200,800,1100,1600,1900};\n        System.out.print(cbs.search(arr8));\n        \n        int arr9[] = {3,1,8,5,4};\n        System.out.print(cbs.search(arr9));\n        \n    }\n}", "complexity": "logn", "from": "CorCod", "problem": 929, "index": 929}
{"src": "package com.interview.binarysearch;\n\n/**\n * @author Tushar Roy\n * Date 01/17/2107\n * A peak element is an element that is greater than its neighbors. Find index of peak element in the array.\n *\n * Space complexity is O(1)\n * Time complexity is O(n)\n *\n * https://leetcode.com/problems/find-peak-element/\n */\npublic class PeakElement {\n\n    public int findPeakElement(int[] nums) {\n        int low = 0;\n        int high = nums.length - 1;\n        int middle = 0;\n        while (low <= high) {\n            middle = (low + high)/2;\n            int before = Integer.MIN_VALUE;\n            if (middle > 0) {\n                before = nums[middle - 1];\n            }\n            int after = Integer.MIN_VALUE;\n            if (middle < nums.length - 1) {\n                after = nums[middle + 1];\n            }\n            if (nums[middle] > before && nums[middle] > after) {\n                return middle;\n            } else if (before > after) {\n                high = middle - 1;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return middle;\n    }\n\n    public static void main(String args[]){\n        int arr[] = {10,5,15,2,23,90,67};\n        PeakElement pe = new PeakElement();\n        System.out.println(pe.findPeakElement(arr));\n        int arr1[] = {10,20,30,40,50};\n        System.out.println(pe.findPeakElement(arr1));\n        int arr2[] = {100,90,80,70,60};\n        System.out.println(pe.findPeakElement(arr2));\n                \n    }\n}\n", "complexity": "logn", "from": "CorCod", "problem": 930, "index": 930}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        FastReader in;\n        PrintWriter out;\n        int n;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.nextInt();\n            if (n % 4 != 0) {\n                out.println(\"! -1\");\n                return;\n            }\n            int low = 0;\n            int high = n >> 1;\n            if (BValue(low) == 0) {\n                out.println(\"! \" + (low + 1));\n                return;\n            }\n            int fSign = Integer.signum(BValue(low));\n            while (high - low > 1) {\n                int mid = (high + low) >> 1;\n                int mSign = Integer.signum(BValue(mid));\n                if (mSign == 0) {\n                    out.println(\"! \" + (mid + 1));\n                    return;\n                }\n                if (mSign == -fSign) {\n                    high = mid;\n                } else {\n                    low = mid;\n                }\n            }\n            out.println(\"! -1\");\n        }\n\n        public int BValue(int index) {\n            out.println(\"? \" + (index + 1));\n            out.flush();\n            int f = in.nextInt();\n            out.println(\"? \" + (index + 1 + (n >> 1)));\n            out.flush();\n            int s = in.nextInt();\n            return f - s;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "complexity": "logn", "from": "CorCod", "problem": 931, "index": 931}
{"src": "\n// Java implementation of recursive Binary Search \nclass\nBinarySearch { \n\n// Returns index of x if it is present in arr[l.. \n\n// r], else return -1 \n\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r >= l) { \n\nint\nmid = l + (r - l) / \n2\n; \n\n\n// If the element is present at the \n\n// middle itself \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n// If element is smaller than mid, then \n\n// it can only be present in left subarray \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid - \n1\n, x); \n\n\n// Else the element can only be present \n\n// in right subarray \n\nreturn\nbinarySearch(arr, mid + \n1\n, r, x); \n\n} \n\n\n// We reach here when element is not present \n\n// in array \n\nreturn\n-\n1\n; \n\n} \n\n\n// Driver method to test above \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinarySearch ob = \nnew\nBinarySearch(); \n\nint\narr[] = { \n2\n, \n3\n, \n4\n, \n10\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n10\n; \n\nint\nresult = ob.binarySearch(arr, \n0\n, n - \n1\n, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element not present\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at index \"\n+ result); \n\n} \n} \n/* This code is contributed by Rajat Mishra */", "complexity": "logn", "from": "CorCod", "problem": 932, "index": 932}
