src,from,problem,index,complexity
"
// Java program to find union of two 
// sorted arrays (Handling Duplicates) 
class
FindUnion 
{ 


static
void
UnionArray(
int
arr1[], 

int
arr2[]) 

{ 

// Taking max element present in either array 

int
m = arr1[arr1.length - 
1
]; 

int
n = arr2[arr2.length - 
1
]; 


int
ans = 
0
; 


if
(m > n) 

{ 

ans = m; 

} 

else

ans = n; 


// Finding elements from 1st array 

// (non duplicates only). Using 

// another array for storing union 

// elements of both arrays 

// Assuming max element present 

// in array is not more than 10^7 

int
newtable[] = 
new
int
[ans + 
1
]; 


// First element is always 

// present in final answer 

System.out.print(arr1[
0
] + 
"" ""
); 


// Incrementing the First element's count 

// in it's corresponding index in newtable 

++newtable[arr1[
0
]]; 


// Starting traversing the first 

// array from 1st index till last 

for
(
int
i = 
1
; i < arr1.length; i++) 

{ 

// Checking whether current element 

// is not equal to it's previous element 

if
(arr1[i] != arr1[i - 
1
]) 

{ 

System.out.print(arr1[i] + 
"" ""
); 

++newtable[arr1[i]]; 

} 

} 


// Finding only non common 

// elements from 2nd array 

for
(
int
j = 
0
; j < arr2.length; j++) 

{ 

// By checking whether it's already 

// present in newtable or not 

if
(newtable[arr2[j]] == 
0
) 

{ 

System.out.print(arr2[j] + 
"" ""
); 

++newtable[arr2[j]]; 

} 

} 

} 


// Driver Code 

public
static
void
main(String args[]) 

{ 

int
arr1[] = {
1
, 
2
, 
2
, 
2
, 
3
}; 

int
arr2[] = {
2
, 
3
, 
4
, 
5
}; 


UnionArray(arr1, arr2); 

} 
} ",CorCod,368,368,linear
"import java.io.*;
import java.util.Scanner;
public class DivideCandies {
	public static void main(String[] args){
		Scanner input = new Scanner(System.in);
		long n = input.nextLong();
		int m = input.nextInt();
		long[] a = new long[m];
		for(int i = 0; i < m; i++)
		{
			if(i <= (n%m) && i != 0)
			{
				a[i] = n/m + 1;
			}
			else
			{
				a[i] = n/m;
			}
		}
		long result = 0L;
		for(int i = 0; i < m; i++)
		{
			for(int j = 0; j < m; j++)
			{
				if((i * i + j * j) % m == 0)
				{
					result += a[i] * a[j];
				}
			}
		}
		System.out.println(result);
	}
}



",CorCod,526,526,quadratic
"
// Java program to find the maximum stolen value 
import
java.io.*; 

class
GFG 
{ 

// Function to calculate the maximum stolen value 

static
int
maxLoot(
int
hval[], 
int
n) 

{ 

if
(n == 
0
) 

return
0
; 


int
value1 = hval[
0
]; 

if
(n == 
1
) 

return
value1; 


int
value2 = Math.max(hval[
0
], hval[
1
]); 

if
(n == 
2
) 

return
value2; 


// contains maximum stolen value at the end 

int
max_val = 
0
; 


// Fill remaining positions 

for
(
int
i=
2
; i<n; i++) 

{ 

max_val = Math.max(hval[i]+value1, value2); 

value1 = value2; 

value2 = max_val; 

} 


return
max_val; 

} 


// driver program 

public
static
void
main (String[] args) 

{ 

int
hval[] = {
6
, 
7
, 
1
, 
3
, 
8
, 
2
, 
4
}; 

int
n = hval.length; 

System.out.println(
""Maximum loot value : ""
+ maxLoot(hval, n)); 

} 
} 

// Contributed by Pramod kumar ",CorCod,173,173,linear
"import java.util.*;
import java.lang.Math;
public class tab
{
public static void main(String[] args)
{
int n,pos,l,r;
Scanner sc=new Scanner(System.in);
n=sc.nextInt();
pos=sc.nextInt();
l=sc.nextInt();
r=sc.nextInt();
int sum;
int a=(n-r)+(l-1);
if((Math.abs(pos-l)<Math.abs(r-pos))&&a!=0)
{
 if(l!=1)
   {sum=Math.abs(pos-l);
    sum++;
    if(r!=n)
      sum+=(r-l)+1;
   }
 else
   sum=Math.abs(r-pos)+1;
}
else if(a==0)
  sum=0; 
else
{
  if(r!=n)
  {  sum=Math.abs(r-pos);
     sum++;
     if(l!=1) 
     sum+=(r-l)+1;
  }
  else
   sum=Math.abs(pos-l)+1;
}
System.out.println(sum);
}}",CorCod,758,758,constant
"
// Java program to find nth ugly number 
import
java.lang.Math; 

class
UglyNumber 
{ 

/* Function to get the nth ugly number*/

int
getNthUglyNo(
int
n) 

{ 

int
ugly[] = 
new
int
[n]; 
// To store ugly numbers 

int
i2 = 
0
, i3 = 
0
, i5 = 
0
; 

int
next_multiple_of_2 = 
2
; 

int
next_multiple_of_3 = 
3
; 

int
next_multiple_of_5 = 
5
; 

int
next_ugly_no = 
1
; 


ugly[
0
] = 
1
; 


for
(
int
i = 
1
; i < n; i++) 

{ 

next_ugly_no = Math.min(next_multiple_of_2, 

Math.min(next_multiple_of_3, 

next_multiple_of_5)); 


ugly[i] = next_ugly_no; 

if
(next_ugly_no == next_multiple_of_2) 

{ 

i2 = i2+
1
; 

next_multiple_of_2 = ugly[i2]*
2
; 

} 

if
(next_ugly_no == next_multiple_of_3) 

{ 

i3 = i3+
1
; 

next_multiple_of_3 = ugly[i3]*
3
; 

} 

if
(next_ugly_no == next_multiple_of_5) 

{ 

i5 = i5+
1
; 

next_multiple_of_5 = ugly[i5]*
5
; 

} 

} 
/*End of for loop (i=1; i<n; i++) */

return
next_ugly_no; 

} 


/* Driver program to test above functions */

public
static
void
main(String args[]) 

{ 

int
n = 
150
; 

UglyNumber obj = 
new
UglyNumber(); 

System.out.println(obj.getNthUglyNo(n)); 

} 
} 

// This code has been contributed by Amit Khandelwal (Amit Khandelwal 1) ",CorCod,69,69,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;
import java.util.StringTokenizer;

public class c {
	public static void main(String[] args) throws IOException {
		FastScanner in = new FastScanner(System.in);
		int n = in.nextInt(), m = in.nextInt();
		long bounty = in.nextInt(), increase = in.nextInt();
		int damage = in.nextInt();
		int[] mh = new int[n];
		int[] sh = new int[n];
		int[] reg = new int[n];
		long countKilled = 0;
		ArrayList<Event> es = new ArrayList<>();
		Event[] regen = new Event[n];
		for(int i=0;i<n;i++) {
			mh[i] = in.nextInt();
			sh[i] = in.nextInt();
			reg[i] = in.nextInt();
			if(sh[i] <= damage)
				countKilled++;
			if(reg[i] > 0) {
				int time = (damage+1 - sh[i]+reg[i]-1)/reg[i];
				if(time > 0 && mh[i] >= damage+1) {
					Event e2 = new Event(time, i, damage+1);
					regen[i] = e2;
					es.add(e2);
				}
			}
		}
		for(int i=0;i<m;i++) {
			Event e = new Event(in.nextInt(), in.nextInt()-1, in.nextInt());
			es.add(e);
			if(reg[e.e] > 0) {
				int time = (damage+1 - e.h+reg[e.e]-1)/reg[e.e];
				if(time > 0 && mh[e.e] >= damage+1) {
					Event e2 = new Event(e.t + time, e.e, damage+1);
					e.regen = e2;
					es.add(e2);
				}
			}
		}
		Collections.sort(es, (a,b) -> a.t-b.t);
		long ans = countKilled*bounty;
		int lastTime = 0;
		for(Event e : es) {
			if(e.t == -1) continue;
			if(regen[e.e] != e && regen[e.e] != null) {
				regen[e.e].t = -1;
				regen[e.e] = null;
			}
			if(lastTime != e.t) {
				ans = Math.max(ans, countKilled*(bounty+(e.t-1)*increase));
			}
			if(sh[e.e] <= damage)
				countKilled--;
			sh[e.e] = e.h;
			if(sh[e.e] <= damage)
				countKilled++;
			if(e.regen != null) {
				regen[e.e] = e.regen;
			}
			lastTime = e.t;
		}
		if(countKilled != 0) {
			if(increase > 0)
				ans = -1;
			else
				ans = Math.max(ans, countKilled*bounty);
		}
		System.out.println(ans);
	}
	static class Event {
		int t;
		int e;
		int h;
		Event regen;
		public Event(int tt, int ee, int hh) {
			t = tt;
			e = ee;
			h = hh;
		}
	}
	static class FastScanner {
	    BufferedReader br;
	    StringTokenizer st;
	    public FastScanner(InputStream i) {
	        br = new BufferedReader(new InputStreamReader(i));
	        st = new StringTokenizer("""");
	    }
	    public String next() throws IOException {
	        if(st.hasMoreTokens())
	            return st.nextToken();
	        else
	            st = new StringTokenizer(br.readLine());
	        return next();
	    }
	    public int nextInt() throws IOException {
	        return Integer.parseInt(next());
	    }
	    public long nextLong() throws IOException {
	        return Long.parseLong(next());
	    }
	    public double nextDouble() throws IOException {
	        return Double.parseDouble(next());
	    }
	}
}
",CorCod,619,619,nlogn
"/* package codechef; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Codechef
{
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
		Scanner in=new Scanner(System.in);
		long x=in.nextLong();
		long k=in.nextLong();
		
		long mod=1000000007;
		long get=power(2,k,mod);
		long ans=((get%mod)*((2*x)%mod))%mod-get+1;
		if(ans<0)
		ans+=mod;
		if(x==0)
		ans=0;
		System.out.println(ans);
		
	}
	static long power(long x, long y, long p)
    {
        // Initialize result
        long res = 1;     
        
        // Update x if it is more  
        // than or equal to p
        x = x % p; 
     
        while (y > 0)
        {
            // If y is odd, multiply x
            // with result
            if((y & 1)==1)
                res = (res * x) % p;
     
            // y must be even now
            // y = y / 2
            y = y >> 1; 
            x = (x * x) % p; 
        }
        return res;
    }
}
",CorCod,911,911,logn
"
// A Dynamic Programming solution for Rod cutting problem 
class
RodCutting 
{ 

/* Returns the best obtainable price for a rod of 

length n and price[] as prices of different pieces */

static
int
cutRod(
int
price[],
int
n) 

{ 

int
val[] = 
new
int
[n+
1
]; 

val[
0
] = 
0
; 


// Build the table val[] in bottom up manner and return 

// the last entry from the table 

for
(
int
i = 
1
; i<=n; i++) 

{ 

int
max_val = Integer.MIN_VALUE; 

for
(
int
j = 
0
; j < i; j++) 

max_val = Math.max(max_val, 

price[j] + val[i-j-
1
]); 

val[i] = max_val; 

} 


return
val[n]; 

} 


/* Driver program to test above functions */

public
static
void
main(String args[]) 

{ 

int
arr[] = 
new
int
[] {
1
, 
5
, 
8
, 
9
, 
10
, 
17
, 
17
, 
20
}; 

int
size = arr.length; 

System.out.println(
""Maximum Obtainable Value is ""
+ 

cutRod(arr, size)); 

} 
} 
/* This code is contributed by Rajat Mishra */",CorCod,442,442,quadratic
"import java.util.Scanner;

public class Main {
//kai
	public static void main(String[] args) {
		Scanner kai = new Scanner(System.in);
		while (kai.hasNext()) {
			int a = kai.nextInt();
			if ((a & 1) == 0) {
				System.out.println(""Mahmoud"");
			}else {
				System.out.println(""Ehab"");
			}
		}
	}
}
 	 	  				 	 	      		 		 		",CorCod,746,746,constant
"import java.util.*;
import java.io.*;
import java.lang.reflect.Array;

		public class codeforces
		{	
			public static void main(String[] args)
			{
				InputReader in = new InputReader(System.in);
				PrintWriter pw = new PrintWriter(System.out);

				int n = in.nextInt();
				long U = in.nextLong();
				long[] E = new long[n];
				double max = -1;
				
				for(int i=0;i<n;i++)
					E[i] = in.nextLong();
				
				for(int k=1;k<n-1;k++)
				{
					int i = k + 1, j = n - 1, mid = 0;
					double T = 0;
					
					while(i < j)
					{
						mid = (int)Math.ceil((double)(i+j)/2);
						
						if(E[mid] - E[k-1] <= U)
							i = mid;
						else
							j = mid - 1;
					}
					
					j = k;
					k = i;
					i = j - 1;
					
					T = E[k] - E[j];
					T /= E[k] - E[i];
					
					if(E[k] - E[i] <= U)
						max = Math.max(max, T);
					
					k = j;
				}	
				
				pw.println(max);
				
				pw.flush();
				pw.close();
			}
			
		/*	public static void DFS(int sourse)
			{
				int count = 0;
				visited[sourse] = true;
				
				for(int u : adj[sourse])
				{
					if(!visited[u])
					{
						DFS(u);
					}
				}
				
				
			}*/
			
			public static ArrayList Divisors(long n)
			{
			    ArrayList<Long> div = new ArrayList<>();
			    
			    for (long i=1; i<=Math.sqrt(n); i++)
			    {
			        if (n%i == 0)
			        {
			        	div.add(i);
			                
			            if(n/i != i)
			            	div.add(n/i);
			        }
			    }
			    return div;
			}
		
			public static int BinarySearch(long[] a, long k)
			{
				int n = a.length;
				int i = 0, j = n-1;
				int mid = 0;
				
				if(k < a[0])
					return 0;
				else if(k >= a[n-1])
					return n;
				else
				{
					while(j - i > 1)
					{
						mid = (i+j)/2;
						
						if(k >= a[mid])
							i = mid;
						else
							j = mid;
					}
				}
				
				return i+1;
			}
			public static long GCD(long a,long b)
			{
				if(b==0)
					return a;
				else
					return GCD(b,a%b);
			}
			
			static class pair implements Comparable<pair>
			{
				Integer x, y;
				pair(int x,int y)
				{
					this.x=x;
					this.y=y;
				}
				
				public int compareTo(pair o) {
					int result = x.compareTo(o.x);
					if(result==0)
						result = y.compareTo(o.y);
					
					return result;
				}  
				
				public String toString()
				{
					return x+"" ""+y;
				}
				
				public boolean equals(Object o)
				{
					if (o instanceof pair)
				    {
						pair p = (pair)o;
						return p.x - x == 0 && p.y - y == 0 ;
					}
					return false;
				}
				
				public int hashCode()
				{
					return new Long(x).hashCode()*31 + new Long(y).hashCode();
				}
			}
			
			static class InputReader 
			{
				 
				private final InputStream stream;
				private final byte[] buf = new byte[8192];
				private int curChar, snumChars;
				private SpaceCharFilter filter;
		 
				public InputReader(InputStream stream) 
				{
					this.stream = stream;
				}
		 
				public int snext() 
				{
					if (snumChars == -1)
						throw new InputMismatchException();
					if (curChar >= snumChars) 
					{
						curChar = 0;
						try 
						{
							snumChars = stream.read(buf);
						} 
						catch (IOException e) 
						{
							throw new InputMismatchException();
						}
						if (snumChars <= 0)
							return -1;
					}
					return buf[curChar++];
				}
		 
				public int nextInt() 
			    {
					int c = snext();
					while (isSpaceChar(c)) 
					{
						c = snext();
					}
					int sgn = 1;
					if (c == '-')
				    {
						sgn = -1;
						c = snext();
					}
					int res = 0;
					do 
					{
						if (c < '0' || c > '9')
							throw new InputMismatchException();
						res *= 10;
						res += c - '0';
						c = snext();
					} while (!isSpaceChar(c));
					return res * sgn;
				}
		 
				public long nextLong()
			    {
					int c = snext();
					while (isSpaceChar(c)) 
					{
						c = snext();
					}
					int sgn = 1;
					if (c == '-') 
					{
						sgn = -1;
						c = snext();
					}
					long res = 0;
					do 
					{
						if (c < '0' || c > '9')
							throw new InputMismatchException();
						res *= 10;
						res += c - '0';
						c = snext();
					} while (!isSpaceChar(c));
					return res * sgn;
				}
		 
				public int[] nextIntArray(int n) 
				{
					int a[] = new int[n];
					for (int i = 0; i < n; i++) 
					{
						a[i] = nextInt();
					}
					return a;
				}
		 
				public String readString()
			    {
					int c = snext();
					while (isSpaceChar(c)) 
					{
						c = snext();
					}
					StringBuilder res = new StringBuilder();
					do 
					{
						res.appendCodePoint(c);
						c = snext();
					} while (!isSpaceChar(c));
					return res.toString();
				}
		 
				public String nextLine() 
				{
					int c = snext();
					while (isSpaceChar(c))
						c = snext();
					StringBuilder res = new StringBuilder();
					do 
					{
						res.appendCodePoint(c);
						c = snext();
					} while (!isEndOfLine(c));
					return res.toString();
				}
		 
				public boolean isSpaceChar(int c) 
				{
					if (filter != null)
						return filter.isSpaceChar(c);
					return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
				}
		 
				private boolean isEndOfLine(int c) 
				{
					return c == '\n' || c == '\r' || c == -1;
				}
		 
				public interface SpaceCharFilter
			    {
					public boolean isSpaceChar(int ch);
				}
			}
			
			static class CodeX {
	        public static void sort(long arr[]) {
	            merge_sort(arr, 0, arr.length - 1);
	        }
	
	        private static void merge_sort(long A[], long start, long end) {
	            if (start < end) {
	                long mid = (start + end) / 2;
	                merge_sort(A, start, mid);
	                merge_sort(A, mid + 1, end);
	                merge(A, start, mid, end);
	            }
	
	        }
	
	        private static void merge(long A[], long start,long mid, long end) {
	            long p = start, q = mid + 1;
	            long Arr[] = new long[(int)(end - start + 1)];
	            long k = 0;
	
	            for (int i = (int)start; i <= end; i++) {
	                if (p > mid)
	                    Arr[(int)k++] = A[(int)q++];
	
	                else if (q > end)
	                    Arr[(int)k++] = A[(int)p++];
	
	                else if (A[(int)p] < A[(int)q])
	                    Arr[(int)k++] = A[(int)p++];
	
	                else
	                    Arr[(int)k++] = A[(int)q++];
	            }
	            for (int i = 0; i < k; i++) {
	                A[(int)start++] = Arr[i];
	            }
	
	        }
	
	    }
		}	
		

			",CorCod,666,666,nlogn
"
class
Main 
{ 

/* Function to get index of 

ceiling of x in arr[low..high]*/

static
int
ceilSearch(
int
arr[], 
int
low, 
int
high, 
int
x) 

{ 

int
mid; 


/* If x is smaller than or equal to the 

first element, then return the first element */

if
(x <= arr[low]) 

return
low; 


/* If x is greater than the last 

element, then return -1 */

if
(x > arr[high]) 

return
-
1
; 


/* get the index of middle element 

of arr[low..high]*/

mid = (low + high)/
2
; 
/* low + (high - low)/2 */


/* If x is same as middle element, 

then return mid */

if
(arr[mid] == x) 

return
mid; 


/* If x is greater than arr[mid], then 

either arr[mid + 1] is ceiling of x or 

ceiling lies in arr[mid+1...high] */

else
if
(arr[mid] < x) 

{ 

if
(mid + 
1
<= high && x <= arr[mid+
1
]) 

return
mid + 
1
; 

else

return
ceilSearch(arr, mid+
1
, high, x); 

} 


/* If x is smaller than arr[mid], 

then either arr[mid] is ceiling of x 

or ceiling lies in arr[mid-1...high] */

else

{ 

if
(mid - 
1
>= low && x > arr[mid-
1
]) 

return
mid; 

else

return
ceilSearch(arr, low, mid - 
1
, x); 

} 

} 



/* Driver program to check above functions */

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
2
, 
8
, 
10
, 
10
, 
12
, 
19
}; 

int
n = arr.length; 

int
x = 
8
; 

int
index = ceilSearch(arr, 
0
, n-
1
, x); 

if
(index == -
1
) 

System.out.println(
""Ceiling of ""
+x+
"" doesn't exist in array""
); 

else

System.out.println(
""ceiling of ""
+x+
"" is ""
+arr[index]); 

} 
} ",CorCod,882,882,logn
"import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Dont {
    static BufferedReader jin = new BufferedReader( new InputStreamReader( System.in ) );
    static long n;
    static long x, y;

    public static void main(String[] args) throws Exception {
        n = nextLong();
        x = nextLong();
        y = nextLong();
        System.out.println( (max(n-x, n-y) < max(x-1, y-1))? ""Black"" : ""White"" );
    }

    static long max(long a, long b) {
        return (a > b)? a : b ;
    }

    static long nextLong() throws Exception {
        long res = 0;
        int ch = jin.read();
        while(ch < '0' || '9' < ch) ch = jin.read();
        while('0'<= ch && ch <= '9') {
            res = res*10 + ch - '0';
            ch = jin.read();
        }
        return res;
    }
}",CorCod,735,735,constant
"
import
java.util.Arrays; 

public
class
Test 
{ 

static
int
arr[] = 
new
int
[]{
1
, 
2
, 
3
, 
4
, 
5
}; 


// Method for rotation 

static
void
rotate() 

{ 

int
x = arr[arr.length-
1
], i; 

for
(i = arr.length-
1
; i > 
0
; i--) 

arr[i] = arr[i-
1
]; 

arr[
0
] = x; 

} 


/* Driver program */

public
static
void
main(String[] args) 

{ 

System.out.println(
""Given Array is""
); 

System.out.println(Arrays.toString(arr)); 


rotate(); 


System.out.println(
""Rotated Array is""
); 

System.out.println(Arrays.toString(arr)); 

} 
} ",CorCod,112,112,linear
"
// Java implementation of simple method to find 
// minimum difference between any pair 

class
GFG 
{ 

// Returns minimum difference between any pair 

static
int
findMinDiff(
int
[] arr, 
int
n) 

{ 

// Initialize difference as infinite 

int
diff = Integer.MAX_VALUE; 


// Find the min diff by comparing difference 

// of all possible pairs in given array 

for
(
int
i=
0
; i<n-
1
; i++) 

for
(
int
j=i+
1
; j<n; j++) 

if
(Math.abs((arr[i] - arr[j]) )< diff) 

diff = Math.abs((arr[i] - arr[j])); 


// Return min diff 

return
diff; 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

int
arr[] = 
new
int
[]{
1
, 
5
, 
3
, 
19
, 
18
, 
25
}; 

System.out.println(
""Minimum difference is ""
+ 

findMinDiff(arr, arr.length)); 


} 
} ",CorCod,558,558,quadratic
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;
public class gr1 {

    static class InputReader {
        public BufferedReader br;
        public StringTokenizer token;
        public InputReader(InputStream stream)
        {
            br=new BufferedReader(new InputStreamReader(stream),32768);
            token=null;
        }

        public String next()
        {
            while(token==null || !token.hasMoreTokens())
            {
                try
                {
                    token=new StringTokenizer(br.readLine());
                }
                catch(IOException e)
                {
                    throw new RuntimeException(e);
                }
            }
            return token.nextToken();
        }

        public int nextInt()
        {
            return Integer.parseInt(next());
        }

        public long nextLong()
        {
            return Long.parseLong(next());
        }

        public double nextDouble()
        {
            return Double.parseDouble(next());
        }
    }

    static class card{
        long a;
        int cnt;
        int i;
        public card(long a,int cnt,int i)
        {
            this.a=a;
            this.cnt=cnt;
            this.i=i;
        }
    }

    static class ascend implements Comparator<pair>
    {
        public int compare(pair o1,pair o2)
        {
            if(o1.b!=o2.b)
                return (int)(o1.b-o2.b);
            else 
                return (int)(o1.a-o2.a);
        }
    }

    /*static class descend implements Comparator<pair>
    {
    public int compare(pair o1,pair o2)
    {
    if(o1.a!=o2.a){
    return (o1.a-o2.a)*-1;
    } else {
    return (o1.b-o2.b);
    }
    }
    }*/

    static class extra
    {

        static void shuffle(long a[])
        {
            List<Long> l=new ArrayList<>();
            for(int i=0;i<a.length;i++)
                l.add(a[i]);
            Collections.shuffle(l);
            for(int i=0;i<a.length;i++)
                a[i]=l.get(i);
        }

        static long gcd(long a,long b)
        {
            if(b==0)
                return a;
            else
                return gcd(b,a%b);
        }

        static boolean valid(int i,int j,int r,int c)
        {
            if(i>=0 && i<r && j>=0 && j<c)
                return true;
            else
                return false;
        }

        static boolean v[]=new boolean[100001];
        static List<Integer> l=new ArrayList<>();
        static int t;
        static void seive()
        {
            for(int i=2;i<100001;i++)
            {
                if(!v[i])
                {
                    t++;
                    l.add(i);
                    for(int j=2*i;j<100001;j+=i)
                        v[j]=true;
                }
            }
        }

        static int binary(pair a[],int val,int n)
        {
            int mid=0,l=0,r=n-1,ans=0;
            while(l<=r)
            {
                mid=(l+r)>>1;
                if(a[mid].a==val)
                {
                    r=mid-1;
                    ans=mid;
                }
                else if(a[mid].a>val)
                    r=mid-1;
                else
                {
                    l=mid+1;
                    ans=l;
                }
            }
            return (ans);
        }
    }

    static class pair{
        long a;
        int b;
        public pair(long a,int n)
        {
            this.a=a;
            this.b=n;
        }
    }
    static InputReader sc=new InputReader(System.in);
    static PrintWriter out=new PrintWriter(System.out);
    public static void main(String[] args) {
        solver s=new solver();
        int t=1;
        while(t>0)
        {
            s.solve();
            t--;
        }
    }
    static class solver
    {
        void solve()
        {
            int n=sc.nextInt();
            int a[]=new int[n];
            int sum=0;
            for(int i=0;i<n;i++)
            {
                a[i]=sc.nextInt();
                sum+=a[i];
            }
            Arrays.sort(a);
            int k=(int)Math.round(4.5*n)-sum;
           // System.out.println((int)Math.round(4.5*n)+"" ""+k+"" ""+sum);
            if(k<=0)
            {
                System.out.println(0);
            }
            else
            {
                int p=0,ans=0;
                for(int i=0;i<n;i++)
                {
                    if(a[i]!=5)
                    {
                        p+=5-a[i];
                        if(p>=k){
                            ans++;
                            System.out.println(ans);
                            break;
                        }
                        ans++;
                    }
                }
            }
        }
    }
}",CorCod,718,718,nlogn
"
// Java program to find the maximum 
// sum such that no three are 
// consecutive using recursion. 
import
java.util.Arrays; 

class
GFG 
{ 

static
int
arr[] = {
100
, 
1000
, 
100
, 
1000
, 
1
}; 
static
int
sum[] = 
new
int
[
10000
]; 

// Returns maximum subsequence 
// sum such that no three 
// elements are consecutive 
static
int
maxSumWO3Consec(
int
n) 
{ 

if
(sum[n] != -
1
) 

return
sum[n]; 


//Base cases (process first three elements) 


if
(n == 
0
) 

return
sum[n] = 
0
; 


if
(n == 
1
) 

return
sum[n] = arr[
0
]; 


if
(n == 
2
) 

return
sum[n] = arr[
1
] + arr[
0
]; 


// Process rest of the elements 

// We have three cases 

return
sum[n] = Math.max(Math.max(maxSumWO3Consec(n - 
1
), 

maxSumWO3Consec(n - 
2
) + arr[n - 
1
]), 

arr[n - 
2
] + arr[n - 
1
] + maxSumWO3Consec(n - 
3
)); 


} 

// Driver code 
public
static
void
main(String[] args) 
{ 

int
n = arr.length; 

Arrays.fill(sum, -
1
); 

System.out.println(maxSumWO3Consec(n)); 
} 
} 

// This code is contributed by Rajput-Ji ",CorCod,32,32,linear
"import java.util.*;
public class Pizza {

	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		long num = sc.nextLong() + 1;
		sc.close();
		System.out.println(num % 2 == 0 || num == 1 ? num / 2 : num);
	}
	
}
",CorCod,869,869,constant
"package geek.livingstone.problems.arrays;

/**
 * Full problem at
 * http://www.geeksforgeeks.org/search-floor-and-ceil-in-a-sorted-array/
 * 
 * @author emmanuel
 * 
 */
public class FloorInSortedArray {
	public static int floor(int[] A, int val) throws Exception {
		if (val < A[0])
			throw new Exception(""All elements are greater than val"");
		else if (val > A[A.length - 1])
			return A[A.length - 1];
		return floor(A, 0, A.length - 1, val);
	}

	private static int floor(int[] A, int l, int r, int val) throws Exception {
		if (l > r) {
			throw new Exception(""Not found"");
		}
		int mid = (l + r) / 2;
		if (val == A[mid])
			return A[mid];
		else if (val < A[mid]) {
			if (val >= A[mid - 1])
				return A[mid - 1];
			return floor(A, l, mid - 1, val);
		} else {
			if (val < A[mid + 1])
				return A[mid];
			return floor(A, mid + 1, r, val);
		}
	}

	public static void main(String[] args) throws Exception {
		int[] A = new int[] { 1, 3, 4, 7, 8, 12, 32, 45, 78, 98 };
		// System.out.println(floor(A, -45));
		System.out.println(floor(A, 11));
		System.out.println(floor(A, 32));
		System.out.println(floor(A, 70));
		System.out.println(floor(A, 125));
	}

}",CorCod,879,879,logn
"//package fourninetysixDiv3;
import java.util.HashMap;
import java.util.Scanner;
public class Median_Segments_general {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int n = s.nextInt();
		int m = s.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = s.nextInt();
		}
		System.out.println(func(n, m, arr)-func(n, m+1, arr));
	}
	public static long func(int n,int m,int[] arr) {
		HashMap<Long, Integer> map = new HashMap<>();
		map.put((long) 0, 1);
		long sum = 0;
		long res = 0;
		long add=0;
		for(int i=0;i<n;i++) {
			if(arr[i]<m) {
				sum--;
				if(map.containsKey(sum)) {
					add-=map.get(sum);
				}
			}
			else {
				if(map.containsKey(sum)) {
					add+=map.get(sum);
				}
				sum++;
			}
			res+=add;
			if(map.containsKey(sum)) {
				map.put(sum, map.get(sum)+1);
			}
			else {
				map.put(sum,1);
			}
		}
		return res;
	}
}
",CorCod,642,642,nlogn
"
// Java program to find lexicographically minimum 
// value after k swaps. 
class
GFG { 


// Modifies arr[0..n-1] to lexicographically 

// smallest with k swaps. 

static
void
minimizeWithKSwaps(
int
arr[], 
int
n, 
int
k) 

{ 

for
(
int
i = 
0
; i < n-
1
&& k > 
0
; ++i) 

{ 


// Set the position where we want 

// to put the smallest integer 

int
pos = i; 

for
(
int
j = i+
1
; j < n ; ++j) 

{ 


// If we exceed the Max swaps 

// then terminate the loop 

if
(j - i > k) 

break
; 


// Find the minimum value from i+1 to 

// max k or n 

if
(arr[j] < arr[pos]) 

pos = j; 

} 


// Swap the elements from Minimum position 

// we found till now to the i index 

int
temp; 


for
(
int
j = pos; j>i; --j) 

{ 

temp=arr[j]; 

arr[j]=arr[j-
1
]; 

arr[j-
1
]=temp; 

} 


// Set the final value after swapping pos-i 

// elements 

k -= pos-i; 

} 

} 


// Driver method 

public
static
void
main(String[] args) 

{ 


int
arr[] = {
7
, 
6
, 
9
, 
2
, 
1
}; 

int
n = arr.length; 

int
k = 
3
; 


minimizeWithKSwaps(arr, n, k); 


//Print the final Array 

for
(
int
i=
0
; i<n; ++i) 

System.out.print(arr[i] +
"" ""
); 

} 
} 

// This code is contributed by Anant Agarwal. ",CorCod,524,524,quadratic
"import javafx.util.Pair;

import java.io.*;
import java.util.*;

public class Beacon8 {
    public static void main(String[] args) throws IOException {
//        int[] arr = {1, 3, 7, 18};
//        int bIndex = Arrays.binarySearch(arr, 4);
//        System.out.println(bIndex);


        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        Map<Integer, Integer> beacons = new TreeMap<>();

        for (int i = 0; i < n; i++) {
            int index = scan.nextInt();
            int power = scan.nextInt();
            beacons.put(index, power);
        }
        int[] indicesArr = new int[n];
        int arrInd = 0;
        for (int index : beacons.keySet()) {
            indicesArr[arrInd] = index;
            arrInd++;
        }
       // Integer[] indicesArr = ((Integer[])beacons.keySet().toArray());
        int[] nDestroys = new int[n];
        for (int i = 0; i < n; i++) {
            int bIndex = Arrays.binarySearch(indicesArr, indicesArr[i] - beacons.get(indicesArr[i]));
            if (bIndex < 0)
                bIndex = -(bIndex + 1);
            nDestroys[i] = i - bIndex;
        }
        int[] totalBeacons = new int[n];
        int maxBeacons = 1;
        totalBeacons[0] = 1;
        for (int i = 1; i < n; i++) {
            if (nDestroys[i] == 0)
                totalBeacons[i] = totalBeacons[i - 1] + 1;
            else {
                if ((i - nDestroys[i] - 1) >= 0)
                    totalBeacons[i] = totalBeacons[i - nDestroys[i] - 1] + 1;
                else
                    totalBeacons[i] = 1;
            }
               // totalBeacons[i] = totalBeacons[i - nDestroys[i]] + 1;
            //totalBeacons[i] = i - nDestroys[i] + totalBeacons[i - nDestroys[i]] + 1;
            if(totalBeacons[i] > maxBeacons)
                maxBeacons = totalBeacons[i];
        }
//        System.out.println(""\ntotalBeacons array"");
//        for (int i = 0; i < n; i++) {
//            System.out.print(totalBeacons[i] + "" "");
//        }
//        if (maxBeacons == -1)
//            System.out.println(n);
        System.out.println(n - maxBeacons);
    }

}
",CorCod,679,679,nlogn
" import java.util.Scanner;
    public class New_Year_and_Curling {
        static final double E = 0.00001;
 
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
 
            int n = sc.nextInt();
            int r = sc.nextInt();
            double[] y = new double[n];
            int arr[] = new int[n];
 
            for (int i = 0; i < n; i++) {
                arr[i] =sc.nextInt();
                double top = r; // if we make it 0 and subtract from the result will get WA (do not know why!!!)
                int x = arr[i];
                for(int  j =0 ;j<i;j++)
                {
                    if(Math.abs(arr[j] -x )<=2*r) {
 
                            top = Math.max(top  , y[j] + Math.sqrt((4 * r * r) - ((arr[j] - x) * (arr[j] - x))));
 
                    }
                }
                y[i] = top ;
                double res = y[i] ;
                System.out.print(res+"" "");
            }
 
        }
 
    }",CorCod,553,553,quadratic
"
// Recursive Java program to print odd level nodes 
class
GfG { 

static
class
Node { 

int
data; 

Node left, right; 
} 

static
void
printOddNodes(Node root, 
boolean
isOdd) 
{ 

// If empty tree 

if
(root == 
null
) 

return
; 


// If current node is of odd level 

if
(isOdd == 
true
) 

System.out.print(root.data + 
"" ""
); 


// Recur for children with isOdd 

// switched. 

printOddNodes(root.left, !isOdd); 

printOddNodes(root.right, !isOdd); 
} 

// Utility method to create a node 
static
Node newNode(
int
data) 
{ 

Node node = 
new
Node(); 

node.data = data; 

node.left = 
null
; 

node.right = 
null
; 

return
(node); 
} 

// Driver code 
public
static
void
main(String[] args) 
{ 

Node root = newNode(
1
); 

root.left = newNode(
2
); 

root.right = newNode(
3
); 

root.left.left = newNode(
4
); 

root.left.right = newNode(
5
); 

printOddNodes(root, 
true
); 

} 
} ",CorCod,51,51,linear
"
// Java program to find the row 
// with maximum number of 1s 
import
java.io.*; 

class
GFG { 

static
int
R = 
4
, C = 
4
; 

// Function to find the index of first index 

// of 1 in a boolean array arr[] 

static
int
first(
int
arr[], 
int
low, 
int
high) 

{ 

if
(high >= low) { 

// Get the middle index 

int
mid = low + (high - low) / 
2
; 


// Check if the element at middle index is first 1 

if
((mid == 
0
|| (arr[mid - 
1
] == 
0
)) && arr[mid] == 
1
) 

return
mid; 


// If the element is 0, recur for right side 

else
if
(arr[mid] == 
0
) 

return
first(arr, (mid + 
1
), high); 


// If element is not first 1, recur for left side 

else

return
first(arr, low, (mid - 
1
)); 

} 

return
-
1
; 

} 


// Function that returns index of row 

// with maximum number of 1s. 

static
int
rowWithMax1s(
int
mat[][]) 

{ 

// Initialize max values 

int
max_row_index = 
0
, max = -
1
; 


// Traverse for each row and count number of 

// 1s by finding the index of first 1 

int
i, index; 

for
(i = 
0
; i < R; i++) { 

index = first(mat[i], 
0
, C - 
1
); 

if
(index != -
1
&& C - index > max) { 

max = C - index; 

max_row_index = i; 

} 

} 


return
max_row_index; 

} 

// Driver Code 

public
static
void
main(String[] args) 

{ 

int
mat[][] = { { 
0
, 
0
, 
0
, 
1
}, 

{ 
0
, 
1
, 
1
, 
1
}, 

{ 
1
, 
1
, 
1
, 
1
}, 

{ 
0
, 
0
, 
0
, 
0
} }; 

System.out.println(
""Index of row with maximum 1s is ""

+ rowWithMax1s(mat)); 

} 
} 

// This code is contributed by 'Gitanjali'. ",CorCod,664,664,nlogn
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class D {

    private void solve() {
        br = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);

        int n = nextInt(), m = nextInt();
        boolean[][] used = new boolean[n + 1][m + 1];

        for (int j = 1; j <= (m + 1) / 2; j++) {
            int x1 = 1, x2 = n;
            for (int i = 1; i <= n; i++) {
                if (x1 <= n && !used[x1][j]) {
                    out.println(x1 + "" "" + j);
                    used[x1++][j] = true;
                }
                if (x2 > 0 && !used[x2][m - j + 1]) {
                    out.println(x2 + "" "" + (m - j + 1));
                    used[x2--][m - j + 1] = true;
                }
            }
        }

        out.close();
    }

    public static void main(String[] args) {
        new D().solve();
    }

    private BufferedReader br;
    private StringTokenizer st;
    private PrintWriter out;

    private String next() {
        while (st == null || !st.hasMoreTokens()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return st.nextToken();
    }

    private int nextInt() {
        return Integer.parseInt(next());
    }

    private long nextLong() {
        return Long.parseLong(next());
    }

    private double nextDouble() {
        return Double.parseDouble(next());
    }
}
",CorCod,430,430,quadratic
"
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.*;
import java.util.*;
import java.util.Map.Entry;

public class Main {

	public static void main(String[] args) throws IOException {
		FastReader in = new FastReader(System.in);
		PrintWriter out = new PrintWriter(System.out);
		long n = in.nextLong();
		long k = in.nextLong();
		long s = in.nextLong();
		if (k > s || k * (n - 1) < s) {
			out.println(""NO"");
		} else {
			out.println(""YES"");
			long cur = 1;
			while (k > 0) {
				long x = Math.min(n - 1, s - k + 1);
				cur = ( cur - x > 0 ? cur  - x : cur + x);
				out.print(cur + "" "");
				s -= x;
				k--;
			}

		}
		out.flush();
		out.close();
	}

	static class FastReader {
		StringTokenizer st;
		BufferedReader br;

		public FastReader(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public FastReader(FileReader fileReader) {
			br = new BufferedReader(fileReader);
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public boolean ready() throws IOException {
			return br.ready();
		}
	}

}",CorCod,332,332,linear
"
// java program to find maximum 
// element 

class
Main 
{ 

// function to find the 

// maximum element 

static
int
findMaximum(
int
arr[], 
int
low, 
int
high) 

{ 


/* Base Case: Only one element is 

present in arr[low..high]*/

if
(low == high) 

return
arr[low]; 


/* If there are two elements and 

first is greater then the first 

element is maximum */

if
((high == low + 
1
) && arr[low] >= arr[high]) 

return
arr[low]; 


/* If there are two elements and 

second is greater then the second 

element is maximum */

if
((high == low + 
1
) && arr[low] < arr[high]) 

return
arr[high]; 


/*low + (high - low)/2;*/

int
mid = (low + high)/
2
; 


/* If we reach a point where arr[mid] 

is greater than both of its adjacent 

elements arr[mid-1] and arr[mid+1], 

then arr[mid] is the maximum element*/

if
( arr[mid] > arr[mid + 
1
] && arr[mid] > arr[mid - 
1
]) 

return
arr[mid]; 


/* If arr[mid] is greater than the next 

element and smaller than the previous 

element then maximum lies on left side 

of mid */

if
(arr[mid] > arr[mid + 
1
] && arr[mid] < arr[mid - 
1
]) 

return
findMaximum(arr, low, mid-
1
); 

else

return
findMaximum(arr, mid + 
1
, high); 

} 


// main function 

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
3
, 
50
, 
10
, 
9
, 
7
, 
6
}; 

int
n = arr.length; 

System.out.println(
""The maximum element is ""
+ 

findMaximum(arr, 
0
, n-
1
)); 

} 
} ",CorCod,907,907,logn
"import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Built using CHelper plug-in Actual solution is at the top
 */
public class Practice {

    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            String[] arr1 = new String[n];
            String[] arr2 = new String[n];
            for (int i = 0; i < n; i++) {
                arr1[i] = in.next();
            }
            for (int i = 0; i < n; i++) {
                arr2[i] = in.next();
            }
            int ans = 0;
            boolean arr[]=new boolean[n];
            boolean found=false;
            for (int i = 0; i < arr1.length; i++) {
                for(int j=0;j<arr1.length;j++){
                    found=false;
                    if(arr1[i].equals(arr2[j]) && !arr[j]){
                        found=true;
                        arr[j]=true;
                        break;
                    }
                }
                if(!found){
                    ans++;
                }
            }
            out.println(ans);
        }
    }

    public static boolean checkPrime(int n, int p) {
        for (int i = 2; i <= Math.sqrt(n) && i <= p; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static void mergeArrays(int[] arr1, int[] arr2, int n1,
            int n2, int[] arr3) {
        int i = 0, j = 0, k = 0;
        while (i < n1 && j < n2) {
            if (arr1[i] < arr2[j]) {
                arr3[k++] = arr1[i++];
            } else {
                arr3[k++] = arr2[j++];
            }
        }
        while (i < n1) {
            arr3[k++] = arr1[i++];
        }
        while (j < n2) {
            arr3[k++] = arr2[j++];
        }
    }

    public long GCD(long a, long b) {
        if (b == 0) {
            return a;
        }
        return GCD(b, a % b);
    }

    public static long nCr(int n, int r) {
        return n * (n - 1) / 2;
    }

    static class InputReader {

        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

    }

}
",CorCod,510,510,quadratic
"import java.util.*;

public class helloWorld 
{
	public static void main(String[] args) 
	{		
		Scanner in = new Scanner(System.in);
		long n = in.nextLong();
		long ans = n+1;
		
		if(ans == 1)
			ans = 0;
		if(ans % 2 == 0)
			ans /= 2;
		
		System.out.println(ans);
		
		in.close();
	}
}",CorCod,854,854,constant
"import com.sun.org.apache.xpath.internal.operations.Bool;

import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {
        MyScanner scan = new MyScanner();
        out = new PrintWriter(new BufferedOutputStream(System.out));

        int n = scan.nextInt();
        int[] vals = new int[n];
        for (int i = 0; i < n; i++) {
            vals[i] = scan.nextInt();
        }

        for (int i = 0; i < n; i++) {
            if (solve(i, vals)) {
                out.print('A');
            } else {
                out.print('B');
            }
        }

        out.close();
    }

    static HashMap<Integer, Boolean> dpResult = new HashMap<>();

    private static boolean solve(int pos, int[] vals) {
        if (dpResult.containsKey(pos)) return dpResult.get(pos);
        int val = vals[pos];
        boolean hasLose = false;
        for (int i = pos; i < vals.length; i += val) {
            if (i == pos) continue;
            if (vals[i] <= vals[pos]) continue;
            if (hasLose) break;
            if (!solve(i, vals)) {
                hasLose = true;
            }
        }
        for (int i = pos; i >= 0; i -= val) {
            if (i == pos) continue;
            if (vals[i] <= vals[pos]) continue;
            if (hasLose) break;
            if (!solve(i, vals)) {
                hasLose = true;
            }
        }
        dpResult.put(pos, hasLose);
        return hasLose;
    }


    //-----------PrintWriter for faster output---------------------------------
    public static PrintWriter out;

    //-----------MyScanner class for faster input----------
    public static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

    }
    //--------------------------------------------------------

}",CorCod,725,725,nlogn
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class D {

    private void solve() {
        br = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);

        int n = nextInt(), m = nextInt(), u = 1, d = n;

        while (u < d) {
            for (int i = 1; i <= m; i++) {
                out.println(u + "" "" + i);
                out.println(d + "" "" + (m - i + 1));
            }
            u++;
            d--;
        }
        if (u == d) {
            int l = 1, r = m;
            while (l < r) {
                out.println(u + "" "" + l++);
                out.println(d + "" "" + r--);
            }
            if (l == r) out.println(u + "" "" + l);
        }

        out.close();
    }

    public static void main(String[] args) {
        new D().solve();
    }

    private BufferedReader br;
    private StringTokenizer st;
    private PrintWriter out;

    private String next() {
        while (st == null || !st.hasMoreTokens()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return st.nextToken();
    }

    private int nextInt() {
        return Integer.parseInt(next());
    }

    private long nextLong() {
        return Long.parseLong(next());
    }

    private double nextDouble() {
        return Double.parseDouble(next());
    }
}
",CorCod,503,503,quadratic
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.ArrayList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author caoash
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        EMilitaryProblem solver = new EMilitaryProblem();
        solver.solve(1, in, out);
        out.close();
    }

    static class EMilitaryProblem {
        ArrayList<Integer>[] adj;
        int[] sz;
        int[] preorder;
        int curPos;
        int[] pos;

        public void solve(int testNumber, FastScanner br, PrintWriter pw) {
            int n = br.nextInt();
            int q = br.nextInt();
            preorder = new int[n];
            sz = new int[n];
            pos = new int[n];
            curPos = 0;
            adj = new ArrayList[n];
            for (int i = 0; i < n; i++) adj[i] = new ArrayList<Integer>();
            for (int i = 1; i < n; i++) {
                int u = br.nextInt();
                u--;
                adj[u].add(i);
            }
            dfs(0);
            for (int i = 0; i < n; i++) {
                pos[preorder[i]] = i;
            }
            for (int i = 0; i < q; i++) {
                int u = br.nextInt();
                int k = br.nextInt();
                u--;
                if (sz[u] < k) {
                    pw.println(""-1"");
                } else {
                    pw.println(preorder[pos[u] + k - 1] + 1);
                }
            }
            pw.close();
        }

        public int dfs(int u) {
            preorder[curPos] = u;
            curPos++;
            sz[u]++;
            for (int e : adj[u]) {
                sz[u] += dfs(e);
            }
            return sz[u];
        }

    }

    static class FastScanner {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private FastScanner.SpaceCharFilter filter;

        public FastScanner(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",CorCod,150,150,linear
"
// Java code for kth smallest element 
// in an array 
import
java.util.Arrays; 
import
java.util.Collections; 

class
GFG 
{ 

// Function to return k'th smallest 

// element in a given array 

public
static
int
kthSmallest(Integer [] arr, 

int
k) 

{ 

// Sort the given array 

Arrays.sort(arr); 


// Return k'th element in 

// the sorted array 

return
arr[k-
1
]; 

} 


// driver program 

public
static
void
main(String[] args) 

{ 

Integer arr[] = 
new
Integer[]{
12
, 
3
, 
5
, 
7
, 
19
}; 

int
k = 
2
; 

System.out.print( 
""K'th smallest element is ""
+ 

kthSmallest(arr, k) ); 

} 
} 

// This code is contributed by Chhavi ",CorCod,606,606,nlogn
"
// java program to find the maximum sum 
// such that no three are consecutive 
import
java.io.*; 

class
GFG { 


// Returns maximum subsequence sum such that no three 

// elements are consecutive 

static
int
maxSumWO3Consec(
int
arr[], 
int
n) 

{ 

// Stores result for subarray arr[0..i], i.e., 

// maximum possible sum in subarray arr[0..i] 

// such that no three elements are consecutive. 

int
sum[] = 
new
int
[n]; 


// Base cases (process first three elements) 

if
(n >= 
1
) 

sum[
0
] = arr[
0
]; 


if
(n >= 
2
) 

sum[
1
] = arr[
0
] + arr[
1
]; 


if
(n > 
2
) 

sum[
2
] = Math.max(sum[
1
], Math.max(arr[
1
] + arr[
2
], arr[
0
] + arr[
2
])); 


// Process rest of the elements 

// We have three cases 

// 1) Exclude arr[i], i.e., sum[i] = sum[i-1] 

// 2) Exclude arr[i-1], i.e., sum[i] = sum[i-2] + arr[i] 

// 3) Exclude arr[i-2], i.e., sum[i-3] + arr[i] + arr[i-1] 

for
(
int
i = 
3
; i < n; i++) 

sum[i] = Math.max(Math.max(sum[i - 
1
], sum[i - 
2
] + arr[i]), 

arr[i] + arr[i - 
1
] + sum[i - 
3
]); 


return
sum[n - 
1
]; 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
100
, 
1000
, 
100
, 
1000
, 
1
}; 

int
n = arr.length; 

System.out.println(maxSumWO3Consec(arr, n)); 

} 
} 

// This code is contributed by vt_m ",CorCod,39,39,linear
"
// Java program to find maximum average subarray 
// of given length. 

import
java.io.*; 

class
GFG { 


// Returns beginning index of maximum average 

// subarray of length 'k' 

static
int
findMaxAverage(
int
arr[], 
int
n, 
int
k) 

{ 


// Check if 'k' is valid 

if
(k > n) 

return
-
1
; 


// Compute sum of first 'k' elements 

int
sum = arr[
0
]; 

for
(
int
i = 
1
; i < k; i++) 

sum += arr[i]; 


int
max_sum = sum, max_end = k-
1
; 


// Compute sum of remaining subarrays 

for
(
int
i = k; i < n; i++) 

{ 

sum = sum + arr[i] - arr[i-k]; 

if
(sum > max_sum) 

{ 

max_sum = sum; 

max_end = i; 

} 

} 


// Return starting index 

return
max_end - k + 
1
; 

} 


// Driver program 

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
12
, -
5
, -
6
, 
50
, 
3
}; 

int
k = 
4
; 

int
n = arr.length; 

System.out.println( 
""The maximum average""

+ 
"" subarray of length ""
+ k 

+ 
"" begins at index ""

+ findMaxAverage(arr, n, k)); 

} 
} 

// This code is contributed by anuj_67. ",CorCod,21,21,linear
"import java.util.*;

public class Solution {
	public static void main(String[] args) {
		
		Scanner sc= new Scanner(System.in);
		int n=sc.nextInt(),m=sc.nextInt();
		int loca[]=new int[n+m];
		int res[]=new int[m];
		for(int i=0;i<n+m;i++)
			loca[i]=sc.nextInt();
		
		int y=0;
		int driver[]=new int[m];
		for(int i=0;i<n+m;i++){
			int x=sc.nextInt();
			if(x==1)
				driver[y++]=i;
		}
		
		int i=0,j=0,p=0,q=0;
		for(i=0;i<m+n;i++) {
			if(i==driver[0])
				{i++;break;}
			if(loca[i]<loca[driver[0]])
				res[0]++;
			else
				break;
		}
		
		//j=1;
		
		for(;i<n+m;i++){
			
			int coor=loca[i];
			
			/*if(coor>q&&j!=0)
				j++;*/
			
			if(j==m-1)
				break;
			
			p=driver[j];q=driver[j+1];		

			if(i==j)
				continue;
			
			int d1=coor-loca[p],d2=loca[q]-coor;
			
			if(d2==0)
				{j++;continue;}
			if(d1<=d2)
				res[j]++;
			else
				res[j+1]++;
			
			//add check for j+1<m
			//handle cases for j==0 && j==m-1
		}
		
		for(;i<m+n;i++) {
			
			if(i==driver[j])
			{i++;break;}
			
			if(loca[i]>loca[driver[j]])
				res[j]++;
			else
				break;
		}
		
		for(i=0;i<m;i++)
			System.out.print(res[i]+"" "");
	}
}",CorCod,353,353,linear
"
// Java program to convert a given Binary Tree to 
// Doubly Linked List 

/* Structure for tree and Linked List */
class
Node 
{ 

int
data; 

Node left, right; 


public
Node(
int
data) 

{ 

this
.data = data; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

// 'root' - root of binary tree 

Node root; 


// 'head' - reference to head node of created 

//double linked list 

Node head; 


// A simple recursive function to convert a given 

// Binary tree to Doubly Linked List 

void
BToDLL(Node root) 

{ 

// Base cases 

if
(root == 
null
) 

return
; 


// Recursively convert right subtree 

BToDLL(root.right); 


// insert root into DLL 

root.right = head; 


// Change left pointer of previous head 

if
(head != 
null
) 

(head).left = root; 


// Change head of Doubly linked list 

head = root; 


// Recursively convert left subtree 

BToDLL(root.left); 

} 


// Utility function for printing double linked list. 

void
printList(Node head) 

{ 

System.out.println(
""Extracted Double Linked List is : ""
); 

while
(head != 
null
) 

{ 

System.out.print(head.data + 
"" ""
); 

head = head.right; 

} 

} 


// Driver program to test the above functions 

public
static
void
main(String[] args) 

{ 

/* Constructing below tree 

5 

/ \ 

3 6 

/ \ \ 

1 4 8 

/ \ / \ 

0 2 7 9 */


BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
5
); 

tree.root.left = 
new
Node(
3
); 

tree.root.right = 
new
Node(
6
); 

tree.root.left.right = 
new
Node(
4
); 

tree.root.left.left = 
new
Node(
1
); 

tree.root.right.right = 
new
Node(
8
); 

tree.root.left.left.right = 
new
Node(
2
); 

tree.root.left.left.left = 
new
Node(
0
); 

tree.root.right.right.left = 
new
Node(
7
); 

tree.root.right.right.right = 
new
Node(
9
); 


tree.BToDLL(tree.root); 

tree.printList(tree.head); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,264,264,linear
"
// Java program to count number of distinct 
// subsequences of a given string. 
import
java.util.ArrayList; 
import
java.util.Arrays; 
public
class
Count_Subsequences { 


static
final
int
MAX_CHAR = 
256
; 


// Returns count of distinct sunsequences of str. 

static
int
countSub(String str) 

{ 

// Create an array to store index 

// of last 

int
[] last = 
new
int
[MAX_CHAR]; 

Arrays.fill(last, -
1
); 


// Length of input string 

int
n = str.length(); 


// dp[i] is going to store count of distinct 

// subsequences of length i. 

int
[] dp = 
new
int
[n+
1
]; 


// Empty substring has only one subsequence 

dp[
0
] = 
1
; 


// Traverse through all lengths from 1 to n. 

for
(
int
i=
1
; i<=n; i++) 

{ 

// Number of subsequences with substring 

// str[0..i-1] 

dp[i] = 
2
*dp[i-
1
]; 


// If current character has appeared 

// before, then remove all subsequences 

// ending with previous occurrence. 

if
(last[(
int
)str.charAt(i-
1
)] != -
1
) 

dp[i] = dp[i] - dp[last[(
int
)str.charAt(i-
1
)]]; 


// Mark occurrence of current character 

last[(
int
)str.charAt(i-
1
)] = (i-
1
); 

} 


return
dp[n]; 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

System.out.println(countSub(
""gfg""
)); 

} 
} 
// This code is contributed by Sumit Ghosh ",CorCod,381,381,linear
"
// Java program to convert BTT to DLL using 
// simple inorder traversal 

public
class
BinaryTreeToDLL 
{ 

static
class
node 

{ 

int
data; 

node left, right; 


public
node(
int
data) 

{ 

this
.data = data; 

} 

} 


static
node prev; 


// Changes left pointers to work as previous 

// pointers in converted DLL The function 

// simply does inorder traversal of Binary 

// Tree and updates left pointer using 

// previously visited node 

static
void
fixPrevptr(node root) 

{ 

if
(root == 
null
) 

return
; 


fixPrevptr(root.left); 

root.left = prev; 

prev = root; 

fixPrevptr(root.right); 


} 


// Changes right pointers to work 

// as next pointers in converted DLL 

static
node fixNextptr(node root) 

{ 

// Find the right most node in 

// BT or last node in DLL 

while
(root.right != 
null
) 

root = root.right; 


// Start from the rightmost node, traverse 

// back using left pointers. While traversing, 

// change right pointer of nodes 

while
(root != 
null
&& root.left != 
null
) 

{ 

node left = root.left; 

left.right = root; 

root = root.left; 

} 


// The leftmost node is head of linked list, return it 

return
root; 

} 


static
node BTTtoDLL(node root) 

{ 

prev = 
null
; 


// Set the previous pointer 

fixPrevptr(root); 


// Set the next pointer and return head of DLL 

return
fixNextptr(root); 

} 


// Traverses the DLL from left tor right 

static
void
printlist(node root) 

{ 

while
(root != 
null
) 

{ 

System.out.print(root.data + 
"" ""
); 

root = root.right; 

} 

} 


// Standard Inorder traversal of tree 

static
void
inorder(node root) 

{ 

if
(root == 
null
) 

return
; 

inorder(root.left); 

System.out.print(root.data + 
"" ""
); 

inorder(root.right); 

} 


public
static
void
main(String[] args) 

{ 

// Let us create the tree shown in above diagram 

node root = 
new
node(
10
); 

root.left = 
new
node(
12
); 

root.right = 
new
node(
15
); 

root.left.left = 
new
node(
25
); 

root.left.right = 
new
node(
30
); 

root.right.left = 
new
node(
36
); 


System.out.println(
""Inorder Tree Traversal""
); 

inorder(root); 


node head = BTTtoDLL(root); 


System.out.println(
""\nDLL Traversal""
); 

printlist(head); 

} 
} 

// This code is contributed by Rishabh Mahrsee ",CorCod,153,153,linear
"
// Java program to reverse alternate levels of a tree 
class
Sol 
{ 

static
class
Node 
{ 

char
key; 

Node left, right; 
}; 

static
void
preorder( Node root1, Node root2, 
int
lvl) 
{ 

// Base cases 

if
(root1 == 
null
|| root2==
null
) 

return
; 


// Swap subtrees if level is even 

if
(lvl % 
2
== 
0
) 

{ 

char
t = root1.key; 

root1.key = root2.key; 

root2.key = t; 

} 


// Recur for left and right subtrees (Note : left of root1 

// is passed and right of root2 in first call and opposite 

// in second call. 

preorder(root1.left, root2.right, lvl+
1
); 

preorder(root1.right, root2.left, lvl+
1
); 
} 

// This function calls preorder() for left and right children 
// of root 
static
void
reverseAlternate( Node root) 
{ 

preorder(root.left, root.right, 
0
); 
} 

// Inorder traversal (used to print initial and 
// modified trees) 
static
void
printInorder( Node root) 
{ 

if
(root == 
null
) 

return
; 

printInorder(root.left); 

System.out.print( root.key + 
"" ""
); 

printInorder(root.right); 
} 

// A utility function to create a new node 
static
Node newNode(
int
key) 
{ 

Node temp = 
new
Node(); 

temp.left = temp.right = 
null
; 

temp.key = (
char
)key; 

return
temp; 
} 

// Driver program to test above functions 
public
static
void
main(String args[]) 
{ 

Node root = newNode(
'a'
); 

root.left = newNode(
'b'
); 

root.right = newNode(
'c'
); 

root.left.left = newNode(
'd'
); 

root.left.right = newNode(
'e'
); 

root.right.left = newNode(
'f'
); 

root.right.right = newNode(
'g'
); 

root.left.left.left = newNode(
'h'
); 

root.left.left.right = newNode(
'i'
); 

root.left.right.left = newNode(
'j'
); 

root.left.right.right = newNode(
'k'
); 

root.right.left.left = newNode(
'l'
); 

root.right.left.right = newNode(
'm'
); 

root.right.right.left = newNode(
'n'
); 

root.right.right.right = newNode(
'o'
); 


System.out.print(
""Inorder Traversal of given tree\n""
); 

printInorder(root); 


reverseAlternate(root); 


System.out.print(
""\n\nInorder Traversal of modified tree\n""
); 

printInorder(root); 

} 
} 

// This code is contributed by Arnab Kundu ",CorCod,219,219,linear
"
import java.io.*;
import java.util.StringTokenizer;

/**
 * CodeForces Round 5D. Follow Traffic Rules
 * Created by Darren on 14-9-14.
 */
public class Main {
    Reader in = new Reader(System.in);
    PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) throws IOException {
        new Main().run();
    }

    int a, v;
    int l, d, w;

    void run() throws IOException {
        a = in.nextInt();
        v = in.nextInt();
        l = in.nextInt();
        d = in.nextInt();
        w = in.nextInt();

        double totalTime = 0.0;
        if (v >= w) {
            if (w*w >= 2*a*d) {
                double x = Math.sqrt(2*a*d);
                totalTime = x / a;
                if ((v*v-x*x) >= 2*a*(l-d))
                    totalTime += (-2*x+Math.sqrt(4*x*x+8*a*(l-d))) / (2*a);
                else
                    totalTime += (v-x)/(1.0*a) + (l-d-(v*v-x*x)/(2.0*a))/v;
            } else {
//                totalTime = (-2*w+Math.sqrt(4*w*w+8*a*(l-d))) / (2*a);
                if (2*v*v-w*w <= 2*a*d) {
                    totalTime = v / (1.0*a) + (v-w) / (1.0*a) + (d-(2*v*v-w*w)/(2.0*a)) / v;
                } else {
                    double x = Math.sqrt((2*a*d+w*w)/2.0);
                    totalTime = x / a + (x-w) / a;
                }
                if ((v*v-w*w) >= 2*a*(l-d))
                    totalTime += (-2*w+Math.sqrt(4*w*w+8*a*(l-d))) / (2*a);
                else
                    totalTime += (v-w)/(1.0*a) + (l-d-(v*v-w*w)/(2.0*a))/v;
            }
        } else {
            if (v*v >= 2*a*l)
                totalTime = Math.sqrt(l*2.0/a);
            else
                totalTime = v / (1.0*a) + (l-v*v/(2.0*a)) / v;
        }

        out.printf(""%.10f"", totalTime);
        out.flush();
    }

    void solve() throws IOException {

    }

    static class Reader {
        BufferedReader reader;
        StringTokenizer tokenizer;

        public Reader(InputStream input) {
            reader = new BufferedReader(new InputStreamReader(input));
            tokenizer = new StringTokenizer("""");
        }

        /** get next word */
        String nextToken() throws IOException {
            while ( ! tokenizer.hasMoreTokens() ) {
                //TODO add check for eof if necessary
                tokenizer = new StringTokenizer( reader.readLine() );
            }
            return tokenizer.nextToken();
        }

        String readLine() throws IOException {
            return reader.readLine();
        }

        char nextChar() throws IOException {
            return (char)reader.read();
        }

        int nextInt() throws IOException {
            return Integer.parseInt( nextToken() );
        }

        long nextLong() throws IOException {
            return Long.parseLong( nextToken() );
        }

        double nextDouble() throws IOException {
            return Double.parseDouble( nextToken() );
        }
    }
}
",CorCod,773,773,constant
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Sid
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        A979 solver = new A979();
        solver.solve(1, in, out);
        out.close();
    }

    static class A979 {
        public void solve(int testNumber, InputReader in, OutputWriter out) {

            long n = in.nextLong();
            n = n + 1;
            if (n % 2 == 0) {
                out.println(n / 2);
            } else {
                if (n != 1) {
                    out.println(n);
                } else {
                    out.println(0);
                }
            }

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void println(long i) {
            writer.println(i);
        }

        public void println(int i) {
            writer.println(i);
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",CorCod,745,745,constant
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

public class CodeForces
{
	public static void main(String[] args)
	{
		Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

		System.out.println(input.nextInt() / 2 + 1);
	}
}",CorCod,848,848,constant
"
/* Java program to search an element 

in a sorted and pivoted array*/

class
Main 
{ 


/* Searches an element key in a 

pivoted sorted array arrp[] 

of size n */

static
int
pivotedBinarySearch(
int
arr[], 
int
n, 
int
key) 

{ 

int
pivot = findPivot(arr, 
0
, n-
1
); 


// If we didn't find a pivot, then 

// array is not rotated at all 

if
(pivot == -
1
) 

return
binarySearch(arr, 
0
, n-
1
, key); 


// If we found a pivot, then first 

// compare with pivot and then 

// search in two subarrays around pivot 

if
(arr[pivot] == key) 

return
pivot; 

if
(arr[
0
] <= key) 

return
binarySearch(arr, 
0
, pivot-
1
, key); 

return
binarySearch(arr, pivot+
1
, n-
1
, key); 

} 


/* Function to get pivot. For array 

3, 4, 5, 6, 1, 2 it returns 

3 (index of 6) */

static
int
findPivot(
int
arr[], 
int
low, 
int
high) 

{ 

// base cases 

if
(high < low) 

return
-
1
; 

if
(high == low) 

return
low; 


/* low + (high - low)/2; */

int
mid = (low + high)/
2
; 

if
(mid < high && arr[mid] > arr[mid + 
1
]) 

return
mid; 

if
(mid > low && arr[mid] < arr[mid - 
1
]) 

return
(mid-
1
); 

if
(arr[low] >= arr[mid]) 

return
findPivot(arr, low, mid-
1
); 

return
findPivot(arr, mid + 
1
, high); 

} 


/* Standard Binary Search function */

static
int
binarySearch(
int
arr[], 
int
low, 
int
high, 
int
key) 

{ 

if
(high < low) 

return
-
1
; 


/* low + (high - low)/2; */

int
mid = (low + high)/
2
; 

if
(key == arr[mid]) 

return
mid; 

if
(key > arr[mid]) 

return
binarySearch(arr, (mid + 
1
), high, key); 

return
binarySearch(arr, low, (mid -
1
), key); 

} 


// main function 

public
static
void
main(String args[]) 

{ 

// Let us search 3 in below array 

int
arr1[] = {
5
, 
6
, 
7
, 
8
, 
9
, 
10
, 
1
, 
2
, 
3
}; 

int
n = arr1.length; 

int
key = 
3
; 

System.out.println(
""Index of the element is : ""

+ pivotedBinarySearch(arr1, n, key)); 

} 
} ",CorCod,909,909,logn
"
// Java program to find remaining 
// chocolates after k iterations 
class
GFG 
{ 
// A O(n) C++ program to count 
// even length binary sequences 
// such that the sum of first 
// and second half bits is same 

// Returns the count of 
// even length sequences 
static
int
countSeq(
int
n) 
{ 

int
nCr = 
1
, res = 
1
; 


// Calculate SUM ((nCr)^2) 

for
(
int
r = 
1
; r <= n ; r++) 

{ 

// Compute nCr using nC(r-1) 

// nCr/nC(r-1) = (n+1-r)/r; 

nCr = (nCr * (n + 
1
- r)) / r; 


res += nCr * nCr; 

} 


return
res; 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

int
n = 
2
; 

System.out.print(
""Count of sequences is ""
); 

System.out.println(countSeq(n)); 
} 
} 

// This code is contributed 
// by Shivi_Aggarwal ",CorCod,252,252,linear
"import java.util.*;
public class Main {

    public static void main(String args[]) {
        Scanner scan = new Scanner(System.in);
        int n=scan.nextInt();
        int m=scan.nextInt();
        int[] game=new int[n];
        int[] bill=new int[m];
        for (int i = 0; i <n ; i++) {
            game[i]=scan.nextInt();
        }
        for (int i = 0; i <m ; i++) {
            bill[i]=scan.nextInt();
        }
        int i=0;
        int j=0;
        int ans=0;
        while (i<m){
            boolean f=true;
            for (int k = j; k <n ; k++) {
                if (bill[i]>=game[k]){
                    ans++;
                    i++;
                    j=k+1;
                    f=false;
                    break;
                }
            }
            if (f){
                break;
            }
        }
        System.out.println(ans);
    }
}


",CorCod,279,279,linear
"
// Java program to find a pair with a given 
// sum in a sorted and rotated array 
class
PairInSortedRotated 
{ 

// This function returns true if arr[0..n-1] 

// has a pair with sum equals to x. 

static
boolean
pairInSortedRotated(
int
arr[], 

int
n, 
int
x) 

{ 

// Find the pivot element 

int
i; 

for
(i = 
0
; i < n - 
1
; i++) 

if
(arr[i] > arr[i+
1
]) 

break
; 


int
l = (i + 
1
) % n; 
// l is now index of 

// smallest element 


int
r = i; 
// r is now index of largest 

//element 


// Keep moving either l or r till they meet 

while
(l != r) 

{ 

// If we find a pair with sum x, we 

// return true 

if
(arr[l] + arr[r] == x) 

return
true
; 


// If current pair sum is less, move 

// to the higher sum 

if
(arr[l] + arr[r] < x) 

l = (l + 
1
) % n; 


else
// Move to the lower sum side 

r = (n + r - 
1
) % n; 

} 

return
false
; 

} 


/* Driver program to test above function */

public
static
void
main (String[] args) 

{ 

int
arr[] = {
11
, 
15
, 
6
, 
8
, 
9
, 
10
}; 

int
sum = 
16
; 

int
n = arr.length; 


if
(pairInSortedRotated(arr, n, sum)) 

System.out.print(
""Array has two elements""
+ 

"" with sum 16""
); 

else

System.out.print(
""Array doesn't have two""
+ 

"" elements with sum 16 ""
); 

} 
} 
/*This code is contributed by Prakriti Gupta*/",CorCod,6,6,linear
"import java.util.*;
import java.io.*;
public class A
{
      public static void main(String ar[]) throws Exception
      {
            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
            String s1[]=br.readLine().split("" "");
            int n=Integer.parseInt(s1[0]);
            int S=Integer.parseInt(s1[1]);
            if(S%n==0)
             System.out.println(S/n);
            else
             System.out.println(S/n+1);
      }
}",CorCod,805,805,constant
"import java.util.*;
import java.io.*;
public class A
{
      public static void main(String ar[]) throws Exception
      {
            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
            String s1[]=br.readLine().split("" "");
            int n=Integer.parseInt(s1[0]);
            int S=Integer.parseInt(s1[1]);
            if(S%n==0)
             System.out.println(S/n);
            else
             System.out.println(S/n+1);
      }
}",CorCod,857,857,constant
"import java.util.*;
public class Main {
    public static int n, m;
    public static int[] vert, group;
    public static int[][] horiz;
    public static boolean ok(int a, int b, int g) {
        int start, end;
        if (g == 0) {
            start = 1;
            end = vert.length > 0 ? vert[0] : (int)Math.pow(10, 9);
        } else if (g == group.length - 1) {
            start = vert[g - 1];
            end = (int)Math.pow(10, 9);
        } else {
            start = vert[g - 1];
            end = vert[g];
        }
        return a <= start && b >= end;
    }
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        vert = new int[n];
        for (int i = 0; i < n; i++) {
            vert[i] = in.nextInt();
        }
        horiz = new int[m][3];
        for (int i = 0; i < m; i++) {
            horiz[i] = new int[]{in.nextInt(), in.nextInt(), in.nextInt()};
        }
        group = new int[n + 1];
        Arrays.fill(group, 0);
        for (int i = 0; i < m; i++) {
            int a = horiz[i][0];
            int b = horiz[i][1];
            for (int j = 0; j < group.length; j++) {
                if (ok(a, b, j)) {
                    group[j]++;
                }
            }
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < group.length; i++) {
            min = Math.min(min, group[i] + i);
        }
        System.out.println(min);
    }
}",CorCod,480,480,quadratic
"
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Scanner;

public class A1 {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        long size = scan.nextLong();
        int numberOfSpecial = scan.nextInt();
        long pageSize = scan.nextLong();

        long[] specialItemsArray = new long[numberOfSpecial];
        for (int i = 0; i < numberOfSpecial; i++) {
            specialItemsArray[i] = scan.nextLong();
        }

        int totalRemoved = 0;
        int step = 0;

        long currentPageIndex = BigDecimal.valueOf(specialItemsArray[0]).divide(BigDecimal.valueOf(pageSize),2, RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();
        int specialItemArrayIndex = 1;

        while (specialItemArrayIndex < numberOfSpecial) {
            long pageIndex = BigDecimal.valueOf(specialItemsArray[specialItemArrayIndex] - totalRemoved).divide(BigDecimal.valueOf(pageSize),2,RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();
            if (currentPageIndex != pageIndex) {
                step++;
                totalRemoved = specialItemArrayIndex;
                currentPageIndex =  BigDecimal.valueOf(specialItemsArray[specialItemArrayIndex] - totalRemoved).divide(BigDecimal.valueOf(pageSize),2,RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();
            }
            specialItemArrayIndex++;
        }


        System.out.println(step + 1);

    }

}
",CorCod,186,186,linear
"import java.io.*;
import java.util.*;
import java.math.*;

public class Main
{
	//static long k = 0;
	public static void main(String[] args) throws IOException
	{
		BufferedReader st = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer s = new StringTokenizer(st.readLine());
		long n = Long.parseLong(s.nextToken());
		long k = Long.parseLong(s.nextToken());
		long ans = k/n;
		if(k%n != 0) ans++;
		System.out.println(ans+"""");
	}
}",CorCod,768,768,constant
"
import java.util.*;
import java.io.*;
import java.math.*;
public class loser
{
    static class InputReader {
        public BufferedReader br;
        public StringTokenizer token;
        public InputReader(InputStream stream)
        {
            br=new BufferedReader(new InputStreamReader(stream),32768);
            token=null;
        }

        public String next()
        {
            while(token==null || !token.hasMoreTokens())
            {
                try
                {
                    token=new StringTokenizer(br.readLine());
                }
                catch(IOException e)
                {
                    throw new RuntimeException(e);
                }
            }
            return token.nextToken();
        }

        public int nextInt()
        {
            return Integer.parseInt(next());
        }

        public long nextLong()
        {
            return Long.parseLong(next());
        }
    }
    static class card{
        String s;
        int l;
        public card(String s,int i)
        {
            this.s=s;
            this.l=i;
        }
    }
    static class sort implements Comparator<card>
    {
        public int compare(card o1,card o2)
        {
            if(o1.l!=o2.l)
                return (o1.l-o2.l);
            else
                return o1.s.compareTo(o2.s);
        }
    }
    static void shuffle(long a[])
    {
        List<Long> l=new ArrayList<>();
        for(int i=0;i<a.length;i++)
            l.add(a[i]);
        Collections.shuffle(l);
        for(int i=0;i<a.length;i++)
            a[i]=l.get(i);
    }

    /*static long gcd(long a,long b)
    {
    if(b==0)
    return a;
    else
    return gcd(b,a%b);
    }
    static boolean valid(int i,int j,int r,int c)
    {
    if(i<r && i>=0 && j<c && j>=0)
    return true;
    else
    return false;
    }*/
    static class Pair
    {
        int a;int b;
        public Pair(int a,int b)
        {
            this.a =a;
            this.b =b;
        }
    }
    public  static void main(String[] args) 
    {
        InputReader sc=new InputReader(System.in);
        int n=sc.nextInt();
        HashMap<String ,Integer> m=new HashMap<>();
        for(int i=0;i<n;i++)
        {
            String t=sc.next();
            if(m.containsKey(t))
            m.put(t,m.get(t)+1);
            else
            m.put(t,1);
        }
        int ans=0;
        for(int i=0;i<n;i++)
        {
            String t=sc.next();
            if(m.containsKey(t) && m.get(t)>0)
            {
                m.put(t,m.get(t)-1);
                ans++;
            }
        }
        System.out.println(n-ans);
    }
}",CorCod,618,618,nlogn
"import java.util.Scanner;


public class FUck {

		public static void main(String args[])
		{
			Scanner scan=new Scanner(System.in);
			int n=scan.nextInt();
			int k=scan.nextInt();
			String t=scan.next();
			int mx=0;
			for(int i=1;i<n;i++)
			{
				int gd=1;
				for(int j=0;j<i;j++)
				{
					
					if(t.charAt(j)!=t.charAt((n-i)+j))
					{
						
						gd=0;
						// i think i can break here
					}
					}
				if(gd==1){
					mx=i;
					
				}
			}
			System.out.print(t);
			for(int i=2;i<=k;i++)
			{
				for(int j=mx;j<n;j++)
				{
					System.out.print(t.charAt(j));
				}
			}
		}
}
",CorCod,481,481,quadratic
"
// Most efficient Java program to count all 
// substrings with same first and last characters. 
public
class
GFG { 


// assuming lower case only 

static
final
int
MAX_CHAR = 
26
; 


static
int
countSubstringWithEqualEnds(String s) 

{ 

int
result = 
0
; 

int
n = s.length(); 


// Calculating frequency of each character 

// in the string. 

int
[] count = 
new
int
[MAX_CHAR]; 

for
(
int
i = 
0
; i < n; i++) 

count[s.charAt(i)-
'a'
]++; 


// Computing result using counts 

for
(
int
i = 
0
; i < MAX_CHAR; i++) 

result += (count[i] * (count[i] + 
1
) / 
2
); 


return
result; 

} 


// Driver function 

public
static
void
main(String args[]) 

{ 

String s = 
""abcab""
; 

System.out.println(countSubstringWithEqualEnds(s)); 

} 
} 
// This code is contributed by Sumit Ghosh ",CorCod,194,194,linear
"
// Java program to find the maximum profit job sequence 
// from a given array of jobs with deadlines and profits 
import
java.util.*; 

// A Simple Disjoint Set Data Structure 
class
DisjointSet 
{ 

int
parent[]; 


// Constructor 

DisjointSet(
int
n) 

{ 

parent = 
new
int
[n + 
1
]; 


// Every node is a parent of itself 

for
(
int
i = 
0
; i <= n; i++) 

parent[i] = i; 

} 


// Path Compression 

int
find(
int
s) 

{ 

/* Make the parent of the nodes in the path 

from u--> parent[u] point to parent[u] */

if
(s == parent[s]) 

return
s; 

return
parent[s] = find(parent[s]); 

} 


// Makes u as parent of v. 

void
merge(
int
u, 
int
v) 

{ 

//update the greatest available 

//free slot to u 

parent[v] = u; 

} 
} 

class
Job 
implements
Comparator<Job> 
{ 

// Each job has a unique-id, profit and deadline 

char
id; 

int
deadline, profit; 


// Constructors 

public
Job() { } 

public
Job(
char
id,
int
deadline,
int
profit) 

{ 

this
.id = id; 

this
.deadline = deadline; 

this
.profit = profit; 

} 


// Returns the maximum deadline from the set of jobs 

public
static
int
findMaxDeadline(ArrayList<Job> arr) 

{ 

int
ans = Integer.MIN_VALUE; 

for
(Job temp : arr) 

ans = Math.max(temp.deadline, ans); 

return
ans; 

} 


// Prints optimal job sequence 

public
static
void
printJobScheduling(ArrayList<Job> arr) 

{ 

// Sort Jobs in descending order on the basis 

// of their profit 

Collections.sort(arr, 
new
Job()); 


// Find the maximum deadline among all jobs and 

// create a disjoint set data structure with 

// maxDeadline disjoint sets initially. 

int
maxDeadline = findMaxDeadline(arr); 

DisjointSet dsu = 
new
DisjointSet(maxDeadline); 


// Traverse through all the jobs 

for
(Job temp : arr) 

{ 

// Find the maximum available free slot for 

// this job (corresponding to its deadline) 

int
availableSlot = dsu.find(temp.deadline); 



// If maximum available free slot is greater 

// than 0, then free slot available 

if
(availableSlot > 
0
) 

{ 

// This slot is taken by this job 'i' 

// so we need to update the greatest free 

// slot. Note that, in merge, we make 

// first parameter as parent of second 

// parameter. So future queries for 

// availableSlot will return maximum slot 

// from set of ""availableSlot - 1"" 

dsu.merge(dsu.find(availableSlot - 
1
), 

availableSlot); 

System.out.print(temp.id + 
"" ""
); 

} 

} 

System.out.println(); 

} 


// Used to sort in descending order on the basis 

// of profit for each job 

public
int
compare(Job j1, Job j2) 

{ 

return
j1.profit > j2.profit? -
1
: 
1
; 

} 
} 

// Driver code 
class
Main 
{ 

public
static
void
main(String args[]) 

{ 

ArrayList<Job> arr=
new
ArrayList<Job>(); 

arr.add(
new
Job(
'a'
,
2
,
100
)); 

arr.add(
new
Job(
'b'
,
1
,
19
)); 

arr.add(
new
Job(
'c'
,
2
,
27
)); 

arr.add(
new
Job(
'd'
,
1
,
25
)); 

arr.add(
new
Job(
'e'
,
3
,
15
)); 

System.out.println(
""Following jobs need to be ""
+ 

""executed for maximum profit""
); 

Job.printJobScheduling(arr); 

} 
} ",CorCod,597,597,nlogn
"import java.util.*;

public class ehab4 {
    public static void main( String[] args ) {
        Scanner in = new Scanner( System.in );
	int a = 0, b = 0;
	System.out.println( ""? 0 0 "" );
	System.out.flush();
	int c = in.nextInt();
	for ( int i = 29; i >= 0; i-- ) {
	    System.out.println( ""? "" + ( a + ( 1 << i ) ) + "" "" + b );
	    System.out.flush();
	    int q1 = in.nextInt();
	    System.out.println( ""? "" + a + "" "" + ( b + ( 1 << i ) ) );
	    System.out.flush();
	    int q2 = in.nextInt();
	    if ( q1 == q2 ) {
		if ( c == 1 )
		    a += ( 1 << i );
		else if ( c == -1 )
		    b += ( 1 << i );
		c = q1;
	    }
	    else if ( q1 == -1 ) {
		a += ( 1 << i );
		b += ( 1 << i );
	    }
	    else if ( q1 == -2 )
		return;
	}
	System.out.println( ""! "" + a + "" "" + b );
	System.out.flush();
    }
}
",CorCod,897,897,logn
"import java.util.*;

public class helloWorld 
{
	public static void main(String[] args) 
	{		
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int cnt = 0;
		String ans = ""Yes"";
		
		for(int i = 0; i < n; i++)
			cnt += in.nextInt();
		for(int i = 0; i < n; i++)
			cnt -= in.nextInt();
		
		if(cnt < 0)
			ans = ""No"";
		
		System.out.println(ans);
				
		in.close();
	}
}
",CorCod,26,26,linear
"import java.util.*;
import java.lang.*;
public class Main {
    static long m = 1000000007;
    static long powmod(long x, long y, long p)
    {
        // Initialize result
        long res = 1;

        // Update x if it is more
        // than or equal to p
        x = x % p;

        while (y > 0)
        {
            // If y is odd, multiply x
            // with result
            if((y & 1)==1)
                res = (res * x) % p;

            // y must be even now
            // y = y / 2
            y = y >> 1;
            x = (x * x) % p;
        }
        return res;
    }

    static long mulmod(long a, long b, long mod){
        long res=0;
        a = a % mod;
        while (b > 0)
        {
            // If b is odd, add 'a' to result
            if (b % 2 == 1)
                res = (res + a) % mod;

            // Multiply 'a' with 2
            a = (a * 2) % mod;

            // Divide b by 2
            b /= 2;
        }

        // Return result
        return res % mod;
    }

    public static void main(String args[] ) throws Exception {
        Scanner sc = new Scanner(System.in);
        long x = sc.nextLong();
        long k = sc.nextLong();
        if(x>0) {
            long d= powmod(2,k,m);
            long ans= mulmod(d,2,m)%m;
            ans= mulmod(ans,x,m)%m;
            ans++;
            ans%=m;
            ans= (ans-d+m)%m;
            System.out.println(ans);
        }
        else
            System.out.println(0);
    }
}",CorCod,903,903,logn
"
// Java Code to find the last man Standing 
public
class
GFG { 


// Node class to store data 

static
class
Node 

{ 

public
int
data ; 

public
Node next; 

public
Node( 
int
data ) 

{ 

this
.data = data; 

} 

} 


/* Function to find the only person left 

after one in every m-th node is killed 

in a circle of n nodes */

static
void
getJosephusPosition(
int
m, 
int
n) 

{ 

// Create a circular linked list of 

// size N. 

Node head = 
new
Node(
1
); 

Node prev = head; 

for
(
int
i = 
2
; i <= n; i++) 

{ 

prev.next = 
new
Node(i); 

prev = prev.next; 

} 


// Connect last node to first 

prev.next = head; 


/* while only one node is left in the 

linked list*/

Node ptr1 = head, ptr2 = head; 


while
(ptr1.next != ptr1) 

{ 


// Find m-th node 

int
count = 
1
; 

while
(count != m) 

{ 

ptr2 = ptr1; 

ptr1 = ptr1.next; 

count++; 

} 


/* Remove the m-th node */

ptr2.next = ptr1.next; 

ptr1 = ptr2.next; 

} 

System.out.println (
""Last person left standing ""
+ 

""(Josephus Position) is ""
+ ptr1.data); 

} 


/* Driver program to test above functions */

public
static
void
main(String args[]) 

{ 

int
n = 
14
, m = 
2
; 

getJosephusPosition(m, n); 

} 
} ",CorCod,436,436,quadratic
"import java.util.*;
import java.io.*;
import static java.lang.System.in;

public class Main {
    public static void main(String[] args)throws IOException{
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] point = new int[n][];
        for(int i=0;i<n;i++) point[i] = new int[]{sc.nextInt(),sc.nextInt()};
        Arrays.sort(point,(a,b)->((a[0]-a[1])-(b[0]-b[1])));
        TreeMap<Integer,Integer> tm = new TreeMap<>();
        int ans = 0;
        for(int i=n-1;i>=0;i--){
            int x = point[i][0], w = point[i][1];
            Map.Entry<Integer,Integer> cur =  tm.ceilingEntry(x+w);
            int curRes;
            if(cur==null) curRes = 1;
            else curRes = cur.getValue()+1;
            ans = Math.max(ans,curRes);
            Map.Entry<Integer,Integer> upper = tm.ceilingEntry(x-w);
            if(upper==null||upper.getValue()<curRes) tm.put(x-w,curRes);
            //Integer key = tm.
        }
        System.out.println(ans);
    }
}
",CorCod,621,621,nlogn
"import java.util.*;
import java.io.*;
import java.math.BigInteger;

public class Main
{
    static final long mod=(int)1e9+7;
    public static void main(String[] args) throws Exception
    {
    	FastReader in=new FastReader();
    	PrintWriter pw=new PrintWriter(System.out);
    	int n=in.nextInt();
    	long ans=0;
    	for(int i=2;2*i<=n;i++)
    	{
    		ans+=i*(n/i-1);
    	}
    	ans*=4;
    	pw.print(ans);
    	pw.flush();
    }
}

class pair
{
	int f,s;
}

class FastReader
{
    BufferedReader br;
    StringTokenizer st;
 
    public FastReader()
    {
        br=new BufferedReader(new InputStreamReader(System.in));
    }
 
    public String next() throws IOException
    {
        if(st==null || !st.hasMoreElements())
        {
            st=new StringTokenizer(br.readLine());
        }
        return st.nextToken();
    }
 
    public int nextInt() throws IOException
    {
        return Integer.parseInt(next());
    }
 
    public long nextLong() throws IOException
    {
        return Long.parseLong(next());
    }
}",CorCod,33,33,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class AnnoyingPresent {

	
	//UPSOLVED
	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
        long n = Long.parseLong(st.nextToken()) , m = Long.parseLong(st.nextToken());
        
        long sum = 0;
        
        for(int i=0;i<m;i++){
        	StringTokenizer st1 = new StringTokenizer(br.readLine());
            sum+= n* Long.parseLong(st1.nextToken());
            Long a= Long.parseLong(st1.nextToken());
            if(a < 0){
                if(n % 2 == 0)
                    sum += n*n / 4*a;
                else{
                    sum += (n/2) * (n/2+1) * a;
                }
            }
            else
                sum += (a*(n) * (n-1) / 2);
            
        }
        System.out.println((double)sum/n);
	}

}
",CorCod,191,191,linear
"import java.io.BufferedReader;
import java.io.InputStreamReader;
public class TestClass1 {


    public static void main(String[] args) throws  Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s[] = br.readLine().split("" "");

        long A,B,y,g,b;
        A= Long.parseLong(s[0]);
        B= Long.parseLong(s[1]);
        s=br.readLine().split("" "");

        y = Long.parseLong(s[0]);
        g = Long.parseLong(s[1]);
        b = Long.parseLong(s[2]);

long ans=0;
        if(A-2*y-g < 0){
            ans+=Math.abs(A-2*y-g);
        }
        
        if(B-g-3*b < 0){
            ans+=Math.abs(B-g-3*b);
        }
        System.out.println(ans);



    }
}
",CorCod,859,859,constant
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Priya
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        contest1 solver = new contest1();
        solver.solve(1, in, out);
        out.close();
    }

    static class contest1 {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int a = in.nextInt();
            int b = in.nextInt();
            int x = in.nextInt();
            String s = """";
            int count = 0;

            int copya = a;
            int copyb = b;
            int change = 0;

            if (x == 1) {
                if (copya > copyb) {
                    while (a > 0) {
                        s += '0';
                        a--;
                    }
                    while (b > 0) {
                        s += '1';
                        b--;
                    }
                } else {
                    while (b > 0) {
                        s += '1';
                        b--;
                    }
                    while (a > 0) {
                        s += '0';
                        a--;
                    }

                }

            } else {
                // out.println(""got in"");
                if (copya > copyb) {
                    while (change <= x - 1) {
                        if (change % 2 == 0) {
                            s += '0';
                            change++;
                            a--;
                        } else {
                            s += '1';
                            change++;
                            b--;
                        }
                    }

                } else if (copyb >= copya) {
                    //out.println(""got in in "");
                    while (change <= x - 1) {
                        //out.println(change+"" hmm"");
                        if (change % 2 == 0) {
                            s += '1';
                            change++;
                            b--;
                        } else {
                            s += '0';
                            change++;
                            a--;
                        }
                    }
                }

                char z = s.charAt(s.length() - 1);
                //out.println(z+"" hm"");
                if (z == '0') {
                    while (a > 0) {
                        s += '0';
                        a--;
                    }
                    while (b > 0) {
                        s += '1';
                        b--;
                    }
                } else {
                    while (b > 0) {
                        s += '1';
                        b--;
                    }
                    while (a > 0) {
                        s += '0';
                        a--;
                    }
                }
            }
            out.println(s);
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",CorCod,97,97,linear
"
// Java implementation to find the first negative 
// integer in every window of size k 
import
java.util.*; 

class
solution 
{ 

// function to find the first negative 
// integer in every window of size k 
static
void
printFirstNegativeInteger(
int
arr[], 
int
n, 
int
k) 
{ 

// flag to check whether window contains 

// a negative integer or not 

boolean
flag; 


// Loop for each subarray(window) of size k 

for
(
int
i = 
0
; i<(n-k+
1
); i++) 

{ 

flag = 
false
; 


// traverse through the current window 

for
(
int
j = 
0
; j<k; j++) 

{ 

// if a negative integer is found, then 

// it is the first negative integer for 

// current window. Print it, set the flag 

// and break 

if
(arr[i+j] < 
0
) 

{ 

System.out.print((arr[i+j])+
"" ""
); 

flag = 
true
; 

break
; 

} 

} 


// if the current window does not 

// contain a negative integer 

if
(!flag) 

System.out.print(
""0""
+
"" ""
); 

} 
} 

// Driver program to test above functions 
public
static
void
main(String args[]) 
{ 

int
arr[] = {
12
, -
1
, -
7
, 
8
, -
15
, 
30
, 
16
, 
28
}; 

int
n = arr.length; 

int
k = 
3
; 

printFirstNegativeInteger(arr, n, k); 

} 
} 
// This code is contributed by 
// Shashank_Sharma ",CorCod,477,477,quadratic
"
// Java program to find smallest and second smallest elements 
import
java.io.*; 

class
SecondSmallest 
{ 

/* Function to print first smallest and second smallest 

elements */

static
void
print2Smallest(
int
arr[]) 

{ 

int
first, second, arr_size = arr.length; 


/* There should be atleast two elements */

if
(arr_size < 
2
) 

{ 

System.out.println(
"" Invalid Input ""
); 

return
; 

} 


first = second = Integer.MAX_VALUE; 

for
(
int
i = 
0
; i < arr_size ; i ++) 

{ 

/* If current element is smaller than first 

then update both first and second */

if
(arr[i] < first) 

{ 

second = first; 

first = arr[i]; 

} 


/* If arr[i] is in between first and second 

then update second */

else
if
(arr[i] < second && arr[i] != first) 

second = arr[i]; 

} 

if
(second == Integer.MAX_VALUE) 

System.out.println(
""There is no second""
+ 

""smallest element""
); 

else

System.out.println(
""The smallest element is ""
+ 

first + 
"" and second Smallest""
+ 

"" element is ""
+ second); 

} 


/* Driver program to test above functions */

public
static
void
main (String[] args) 

{ 

int
arr[] = {
12
, 
13
, 
1
, 
10
, 
34
, 
1
}; 

print2Smallest(arr); 

} 
} 
/*This code is contributed by Devesh Agrawal*/",CorCod,16,16,linear
"
// Java program to Rearrange positive 
// and negative numbers in a array 
import
java.io.*; 

class
GFG { 

/* Function to print an array */

static
void
printArray(
int
A[], 
int
size) 

{ 

for
(
int
i = 
0
; i < size; i++) 

System.out.print(A[i] + 
"" ""
); 

System.out.println(); 

} 


// Merges two subarrays of arr[]. 

// First subarray is arr[l..m] 

// Second subarray is arr[m+1..r] 

static
void
merge(
int
arr[], 
int
l, 
int
m, 
int
r) 

{ 

int
i, j, k; 

int
n1 = m - l + 
1
; 

int
n2 = r - m; 


/* create temp arrays */

int
L[] = 
new
int
[n1]; 

int
R[] = 
new
int
[n2]; 


/* Copy data to temp arrays L[] and R[] */

for
(i = 
0
; i < n1; i++) 

L[i] = arr[l + i]; 

for
(j = 
0
; j < n2; j++) 

R[j] = arr[m + 
1
+ j]; 


/* Merge the temp arrays back into arr[l..r]*/

// Initial index of first subarray 

i = 
0
; 


// Initial index of second subarray 

j = 
0
; 


// Initial index of merged subarray 

k = l; 


// Note the order of appearance of elements should 

// be maintained - we copy elements of left subarray 

// first followed by that of right subarray 


// copy negative elements of left subarray 

while
(i < n1 && L[i] < 
0
) 

arr[k++] = L[i++]; 


// copy negative elements of right subarray 

while
(j < n2 && R[j] < 
0
) 

arr[k++] = R[j++]; 


// copy positive elements of left subarray 

while
(i < n1) 

arr[k++] = L[i++]; 


// copy positive elements of right subarray 

while
(j < n2) 

arr[k++] = R[j++]; 

} 


// Function to Rearrange positive and negative 

// numbers in a array 

static
void
RearrangePosNeg(
int
arr[], 
int
l, 
int
r) 

{ 

if
(l < r) { 

// Same as (l + r)/2, but avoids overflow for 

// large l and h 

int
m = l + (r - l) / 
2
; 


// Sort first and second halves 

RearrangePosNeg(arr, l, m); 

RearrangePosNeg(arr, m + 
1
, r); 


merge(arr, l, m, r); 

} 

} 


// Driver program 

public
static
void
main(String[] args) 

{ 

int
arr[] = { -
12
, 
11
, -
13
, -
5
, 
6
, -
7
, 
5
, -
3
, -
6
}; 

int
arr_size = arr.length; 

RearrangePosNeg(arr, 
0
, arr_size - 
1
); 

printArray(arr, arr_size); 

} 
} 

// This code is contributed by vt_m. ",CorCod,504,504,quadratic
"import java.util.*;
import java.math.*;
public class Solution{
    private long [] sums;
    private void solve(){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        int [] arr = new int[n];
        this.sums = new long[n];
        for(int i = 0; i < n; i++){
            arr[i] = sc.nextInt();
            sums[i] = arr[i] + (i == 0 ? 0 : sums[i - 1]);
        }
        long ans = 0;
        for(int i = 1; i <= n && i <= m; i++){
            ans = Math.max(ans, sum(0, i - 1) - k);
        }
        long [] dp = new long[n];
        for(int i = 0; i < n; i++){
            if(i + 1 >= m){
                long cur = sum(i - m + 1, i) - k;
                if(i - m >= 0){
                    cur += dp[i - m];
                }
                dp[i] = Math.max(dp[i], cur);
            }
            for(int j = 0; j <= m && i + j < n; j++){
                ans = Math.max(ans, dp[i] + sum(i + 1, i + j) - k * (j > 0 ? 1 : 0));
            }
        }
        System.out.println(ans);
    }
    private long sum(int l, int r){
        if(l <= 0){
            return sums[r];
        }else{
            return sums[r] - sums[l - 1];
        }
    }
    public static void main(String [] args){
        new Solution().solve();
    }
}",CorCod,460,460,quadratic
"import java.util.Scanner;

/**
 * Solution
 */
public class Solution {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), s = sc.nextInt();
        int coins;
        if(s%n != 0)
            coins = s/n + 1;
        else
            coins = s/n;

        System.out.println(coins);

    }
}",CorCod,766,766,constant
"
// Java program to find union of 
// two sorted arrays 

class
FindUnion 
{ 

/* Function prints union of arr1[] and arr2[] 

m is the number of elements in arr1[] 

n is the number of elements in arr2[] */

static
int
printUnion(
int
arr1[], 
int
arr2[], 
int
m, 
int
n) 

{ 

int
i = 
0
, j = 
0
; 

while
(i < m && j < n) 

{ 

if
(arr1[i] < arr2[j]) 

System.out.print(arr1[i++]+
"" ""
); 

else
if
(arr2[j] < arr1[i]) 

System.out.print(arr2[j++]+
"" ""
); 

else

{ 

System.out.print(arr2[j++]+
"" ""
); 

i++; 

} 

} 


/* Print remaining elements of 

the larger array */

while
(i < m) 

System.out.print(arr1[i++]+
"" ""
); 

while
(j < n) 

System.out.print(arr2[j++]+
"" ""
); 


return
0
; 

} 


public
static
void
main(String args[]) 

{ 

int
arr1[] = {
1
, 
2
, 
4
, 
5
, 
6
}; 

int
arr2[] = {
2
, 
3
, 
5
, 
7
}; 

int
m = arr1.length; 

int
n = arr2.length; 

printUnion(arr1, arr2, m, n); 

} 
} ",CorCod,50,50,linear
"import java.io.PrintWriter;
import java.util.Scanner;
import java.util.ArrayList;

import static java.lang.Math.ceil;

public class practise {
    static final int N = 31;
    static Scanner sc = new Scanner(System.in);
    static PrintWriter out = new PrintWriter(System.out,true);
    static long c[] = new long[N];
    static int w[] = new int[N];
    public static void main(String[] args) {
        w[0] = 1;
        for(int i=1;i<N;i++) w[i] = w[i-1]*2;
        int n = sc.nextInt(); int l = sc.nextInt();
        for(int i=0;i<N;i++) c[i] = Long.MAX_VALUE;
        for(int i=0;i<n;i++) c[i] = sc.nextInt();
        for(int i=1;i<N;i++) {
            c[i] = min(c[i-1]*2,c[i]);
        }
        long ans = 0;
        for(int i=0;i<N;i++) {
            if( (l&w[i])!=0) {
                ans += c[i];
            }
        }
        long m = 0;
        for(int i=N - 1;i>=0;i--) {
            if((l&w[i])!=0) {
                m += c[i];
            } else {
                ans = min(ans,m+c[i]);
            }
        }
        out.println(ans);
    }

    static long min(long a,long b) {
        return a<b?a:b;
    }
}
",CorCod,330,330,linear
"/*
 * Created on 17.05.2019
 */
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * @author Wolfgang Weck
 */
public class C01Easy {
	public static void main(String[] args) {
		try (BufferedReader r = new BufferedReader(new InputStreamReader(System.in))) {
			final String[] line = r.readLine().split("" "");
			final int N = Integer.parseInt(line[0]), P = Integer.parseInt(line[1]);
			final String[] numS = r.readLine().split("" "");
			if (numS.length != N) throw new IllegalArgumentException();
			final int[] n = new int[N];
			int sum1 = 0, sum2 = 0;
			for (int i = 0; i < N; i++) {
				n[i] = Integer.parseInt(numS[i]) % P;
				sum2 += n[i];
				if (sum2 >= P) sum2 -= P;
			}
			int max = sum2;
			for (int i = 0; i < N; i++) {
				sum1 += n[i];
				if (sum1 >= P) sum1 -= P;
				sum2 -= n[i];
				if (sum2 < 0) sum2 += P;
				final int s = sum1 + sum2;
				if (s > max) max = s;
			}
			System.out.println(max);
		}
		catch (IOException e) {
			e.printStackTrace();
		}
	}
}
",CorCod,292,292,linear
"import java.util.*;
import java.io.*;
import java.util.Map.Entry;

public class Codeforces {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        int n = Integer.parseInt(br.readLine());
        int[] arr = new int[n];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0; i < n; i++){
            arr[i] = Integer.parseInt(st.nextToken());
        }
        for(int i = 0; i < n; i++){
            if(arr[i] % 2 == 0){
                arr[i]--;
            }
        }
        for(int i = 0; i < n; i++){
            pw.print(arr[i] + "" "");
        }
        pw.flush();
        pw.close();
    }
}",CorCod,127,127,linear
"
// Java program to print 
// equal sum sets of array. 
import
java.io.*; 
import
java.util.*; 

class
GFG 
{ 

// Function to print equal 

// sum sets of array. 

static
void
printEqualSumSets(
int
[]arr, 

int
n) 

{ 

int
i, currSum, sum = 
0
; 


// Finding sum of array elements 

for
(i = 
0
; i < arr.length; i++) 

sum += arr[i]; 


// Check sum is even or odd. 

// If odd then array cannot 

// be partitioned. Print -1 

// and return. 

if
((sum & 
1
) == 
1
) 

{ 

System.out.print(
""-1""
); 

return
; 

} 


// Divide sum by 2 to find 

// sum of two possible subsets. 

int
k = sum >> 
1
; 


// Boolean DP table to store 

// result of states. 

// dp[i,j] = true if there is a 

// subset of elements in first i 

// elements of array that has sum 

// equal to j. 

boolean
[][]dp = 
new
boolean
[n + 
1
][k + 
1
]; 


// If number of elements are zero, 

// then no sum can be obtained. 

for
(i = 
1
; i <= k; i++) 

dp[
0
][i] = 
false
; 


// Sum 0 can be obtained by 

// not selecting any element. 

for
(i = 
0
; i <= n; i++) 

dp[i][
0
] = 
true
; 


// Fill the DP table 

// in bottom up manner. 

for
(i = 
1
; i <= n; i++) 

{ 

for
(currSum = 
1
; 

currSum <= k; 

currSum++) 

{ 


// Excluding current element. 

dp[i][currSum] = dp[i - 
1
][currSum]; 


// Including current element 

if
(arr[i - 
1
] <= currSum) 

dp[i][currSum] = dp[i][currSum] | 

dp[i - 
1
][currSum - arr[i - 
1
]]; 

} 

} 


// Required sets set1 and set2. 

List<Integer> set1 = 
new
ArrayList<Integer>(); 

List<Integer> set2 = 
new
ArrayList<Integer>(); 


// If partition is not possible 

// print -1 and return. 

if
(!dp[n][k]) 

{ 

System.out.print(
""-1\n""
); 

return
; 

} 


// Start from last 

// element in dp table. 

i = n; 

currSum = k; 


while
(i > 
0
&& currSum >= 
0
) 

{ 


// If current element does 

// not contribute to k, then 

// it belongs to set 2. 

if
(dp[i - 
1
][currSum]) 

{ 

i--; 

set2.add(arr[i]); 

} 


// If current element contribute 

// to k then it belongs to set 1. 

else
if
(dp[i - 
1
][currSum - arr[i - 
1
]]) 

{ 

i--; 

currSum -= arr[i]; 

set1.add(arr[i]); 

} 

} 


// Print elements of both the sets. 

System.out.print(
""Set 1 elements: ""
); 

for
(i = 
0
; i < set1.size(); i++) 

System.out.print(set1.get(i) + 
"" ""
); 


System.out.print(
""\nSet 2 elements: ""
); 


for
(i = 
0
; i < set2.size(); i++) 

System.out.print(set2.get(i) + 
"" ""
); 

} 


// Driver Code 

public
static
void
main(String args[]) 

{ 

int
[]arr = 
new
int
[]{ 
5
, 
5
, 
1
, 
11
}; 

int
n = arr.length; 

printEqualSumSets(arr, n); 

} 
} 

// This code is contributed by 
// Manish Shaw(manishshaw1) ",CorCod,563,563,quadratic
"import java.io.*;
import java.util.StringTokenizer;

import static java.lang.Math.max;
import static java.lang.Math.min;

public class Main {
    FastScanner in;
    PrintWriter out;

    void run() {
        in = new FastScanner();
        out = new PrintWriter(System.out);
        solve();
        out.close();
    }

    class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        public FastScanner(String s) {
            try {
                br = new BufferedReader(new FileReader(s));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        public String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(nextToken());
        }

        public long nextLong() {
            return Long.parseLong(nextToken());
        }

        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }

    public static void main(String[] args) {
        new Main().run();
    }

    void solve() {
        int t = in.nextInt();

        for (int sdfsdf = 0; sdfsdf < t; sdfsdf++) {
            long n = in.nextLong();
            long k = in.nextLong();

            if (n == 1) {
                if (k == 1)  {
                    out.println(""YES 0"");
                } else {
                    out.println(""NO"");
                }
                continue;
            }

            if (k == 3) {
                if (n == 2) {
                    out.println(""NO"");
                } else {
                    out.println(""YES "" + (n - 1));
                }
                continue;
            }

            long cuts = 1;
            long squares = 4;
            int zoom = 1;

            while (k > cuts + squares) {
                cuts += squares;
                squares *= 4;
                zoom++;
            }

            if (zoom > n) {
                out.println(""NO"");
                continue;
            }

            if (zoom == n && k > cuts) {
                out.println(""NO"");
                continue;
            }

            long current_cuts = k - cuts;

            if (current_cuts > squares - (2L * Math.sqrt(squares) - 1L)) {
                out.println(""YES "" + (n - zoom - 1L));
            } else {
                out.println(""YES "" + (n - zoom));
            }
        }
    }
}
",CorCod,885,885,logn
"
// A O(n) solution that uses 
// table fact[] to calculate 
// the Permutation Coefficient 
import
java .io.*; 

public
class
GFG { 


// Returns value of Permutation 

// Coefficient P(n, k) 

static
int
permutationCoeff(
int
n, 

int
k) 

{ 

int
[]fact = 
new
int
[n+
1
]; 


// base case 

fact[
0
] = 
1
; 


// Caculate value 

// factorials up to n 

for
(
int
i = 
1
; i <= n; i++) 

fact[i] = i * fact[i - 
1
]; 


// P(n,k) = n! / (n - k)! 

return
fact[n] / fact[n - k]; 

} 


// Driver Code 

static
public
void
main (String[] args) 

{ 

int
n = 
10
, k = 
2
; 

System.out.println(
""Value of""

+ 
"" P( ""
+ n + 
"", ""
+ k + 
"") is ""

+ permutationCoeff(n, k) ); 

} 
} 

// This code is contributed by anuj_67. ",CorCod,161,161,linear
"import java.util.*;
import java.io.*;
public class Piles {
	static int summation(int arr[]) {
		int k, sum=0;
		for(k=0;k<arr.length;k++) {
			sum = sum + arr[k];
		}
		return sum;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		if(n>=1 && n<=50) {
			int x[] = new int[n];
			int y[] = new int[n];
			
			for(int i=0;i<n;i++) {
				x[i] = sc.nextInt();
			}
			for(int j=0;j<n;j++) {
				y[j] = sc.nextInt();
			}
			int xsum = summation(x);
			int ysum = summation(y);
			if(xsum>=ysum) {
				System.out.println(""Yes"");
			}
			else {
				System.out.println(""No"");
			}
		}
		

	}

}
",CorCod,296,296,linear
"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Random;
import java.util.Scanner;
import java.util.Set;
import java.util.StringJoiner;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Test {

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] line = reader.readLine().split("" "");
        int w = Integer.valueOf(line[0]);
        int h = Integer.valueOf(line[1]);
        int n = Integer.valueOf(line[2]);

        Request[] requests = new Request[n];

        for (int i = 0; i < n; i++) {
            line = reader.readLine().split("" "");
            requests[i] = new Request(line[0], Integer.valueOf(line[1]));
        }

        for (long e : solve(h, w, requests))
            System.out.println(e);

//        int w = 200000, h = 200000, n = 400000;
//        Request[] requests = generate(w, h, n);
//
//        long start = System.currentTimeMillis();
//        solve(h, w, requests);
//        long end = System.currentTimeMillis();
//
//        System.out.println(""Time: "" + (end - start) + "" ms"");
    }

    private static Request[] generate(int w, int h, int n) {
        Request[] requests = new Request[n];
        Random rnd = new Random();

        for (int i = 0; i < n; i++) {
            requests[i] = rnd.nextBoolean() ? new Request(""V"", rnd.nextInt(w)) : new Request(""H"", rnd.nextInt(h));
        }

        return requests;
    }

    private static long[] solve(int h, int w, Request[] requests) {
        TreeSet<Integer> hTree = new TreeSet<>();
        TreeSet<Integer> wTree = new TreeSet<>();

        Queue<CoordinateWithSize> hHeap = new PriorityQueue<>();
        Queue<CoordinateWithSize> wHeap = new PriorityQueue<>();

        hTree.add(0);
        hTree.add(h);
        wTree.add(0);
        wTree.add(w);

        hHeap.add(new CoordinateWithSize(0, h));
        wHeap.add(new CoordinateWithSize(0, w));

        long[] res = new long[requests.length];
        for (int i = 0; i < requests.length; i++) {
            Request request = requests[i];

            switch (request.type) {
                case ""H"": {
                    if (!hTree.contains(request.coordinate)) {
                        int higher = hTree.higher(request.coordinate);
                        int lower = hTree.lower(request.coordinate);

                        hHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));
                        hHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));

                        hTree.add(request.coordinate);
                    }

                    break;
                }
                case ""V"": {
                    if (!wTree.contains(request.coordinate)) {
                        int higher = wTree.higher(request.coordinate);
                        int lower = wTree.lower(request.coordinate);

                        wHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));
                        wHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));

                        wTree.add(request.coordinate);
                    }

                    break;
                }
                default:
                    throw new IllegalStateException(""Unknown type [type="" + request.type + ""]"");
            }

            while (true) {
                CoordinateWithSize c = hHeap.peek();
                if (hTree.higher(c.coordinate) - c.coordinate == c.size)
                    break;
                hHeap.remove();
            }

            while (true) {
                CoordinateWithSize c = wHeap.peek();
                if (wTree.higher(c.coordinate) - c.coordinate == c.size)
                    break;
                wHeap.remove();
            }

            res[i] = 1L * hHeap.peek().size * wHeap.peek().size;
        }

        return res;
    }

    private static class CoordinateWithSize implements Comparable<CoordinateWithSize> {

        private final int coordinate;

        private final int size;

        public CoordinateWithSize(int coordinate, int size) {
            this.coordinate = coordinate;
            this.size = size;
        }

        @Override public int compareTo(CoordinateWithSize o) {
            return Integer.compare(o.size, size);
        }
    }

    private static class Request {

        private final String type;

        private final int coordinate;

        public Request(String type, int coordinate) {
            this.type = type;
            this.coordinate = coordinate;
        }
    }
}
",CorCod,688,688,nlogn
"
// Java program to find maximum number of 
// thieves caught 
import
java.util.*; 
import
java.io.*; 

class
GFG 
{ 

// Returns maximum number of thieves 

// that can be caught. 

static
int
policeThief(
char
arr[], 
int
n, 
int
k) 

{ 

int
res = 
0
; 

ArrayList<Integer> thi = 
new
ArrayList<Integer>(); 

ArrayList<Integer> pol = 
new
ArrayList<Integer>(); 


// store indices in the ArrayList 

for
(
int
i = 
0
; i < n; i++) { 

if
(arr[i] == 
'P'
) 

pol.add(i); 

else
if
(arr[i] == 
'T'
) 

thi.add(i); 

} 


// track lowest current indices of 

// thief: thi[l], police: pol[r] 

int
l = 
0
, r = 
0
; 

while
(l < thi.size() && r < pol.size()) { 


// can be caught 

if
(Math.abs(thi.get(l) - pol.get(r)) <= k) { 

res++; 

l++; 

r++; 

} 


// increment the minimum index 

else
if
(thi.get(l) < pol.get(r)) 

l++; 

else

r++; 

} 

return
res; 

} 


// Driver program 

public
static
void
main(String args[]) 

{ 

int
k, n; 

char
arr1[] =
new
char
[] { 
'P'
, 
'T'
, 
'T'
, 

'P'
, 
'T'
}; 

k = 
2
; 

n = arr1.length; 

System.out.println(
""Maximum thieves caught: ""

+policeThief(arr1, n, k)); 


char
arr2[] =
new
char
[] { 
'T'
, 
'T'
, 
'P'
, 
'P'
, 

'T'
, 
'P'
}; 

k = 
2
; 

n = arr2.length; 

System.out.println(
""Maximum thieves caught: ""

+policeThief(arr2, n, k)); 


char
arr3[] = 
new
char
[]{ 
'P'
, 
'T'
, 
'P'
, 
'T'
, 

'T'
, 
'P'
}; 

k = 
3
; 

n = arr3.length; 

System.out.println(
""Maximum thieves caught: ""

+policeThief(arr3, n, k)); 

} 
} 

/* This code is contributed by Danish kaleem */",CorCod,53,53,linear
"
// Java implementation of recursive Binary Search 
class
BinarySearch { 

// Returns index of x if it is present in arr[l.. 

// r], else return -1 

int
binarySearch(
int
arr[], 
int
l, 
int
r, 
int
x) 

{ 

if
(r >= l) { 

int
mid = l + (r - l) / 
2
; 


// If the element is present at the 

// middle itself 

if
(arr[mid] == x) 

return
mid; 


// If element is smaller than mid, then 

// it can only be present in left subarray 

if
(arr[mid] > x) 

return
binarySearch(arr, l, mid - 
1
, x); 


// Else the element can only be present 

// in right subarray 

return
binarySearch(arr, mid + 
1
, r, x); 

} 


// We reach here when element is not present 

// in array 

return
-
1
; 

} 


// Driver method to test above 

public
static
void
main(String args[]) 

{ 

BinarySearch ob = 
new
BinarySearch(); 

int
arr[] = { 
2
, 
3
, 
4
, 
10
, 
40
}; 

int
n = arr.length; 

int
x = 
10
; 

int
result = ob.binarySearch(arr, 
0
, n - 
1
, x); 

if
(result == -
1
) 

System.out.println(
""Element not present""
); 

else

System.out.println(
""Element found at index ""
+ result); 

} 
} 
/* This code is contributed by Rajat Mishra */",CorCod,932,932,logn
"import java.awt.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;
import java.util.List;


public class Main {


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt(), m = scanner.nextInt();
        int[] vertical = new int[n];

        for (int i = 0; i < n; i++) {
            vertical[i] = scanner.nextInt();
        }

        Arrays.sort(vertical);


        ArrayList<Integer> horisontal = new ArrayList<>();
        int amount = 0;
        for (int i = 0; i < m; i++) {
            int x1 = scanner.nextInt(), x2 = scanner.nextInt(), y = scanner.nextInt();
            if (x1 == 1) {
                amount++;
                horisontal.add(x2);
            }
        }

        Collections.sort(horisontal);


        if (amount == 0) {
            System.out.println(0);
            return;
        }


        int minVal = amount, horSize = horisontal.size(), verLen = vertical.length;
        int h = 0, v = 0;

        for (; v < verLen && h < horSize; ) {

           while (h < horSize && horisontal.get(h) < vertical[v]){
               h++;
               amount--;
           }
           minVal = Math.min(minVal, amount + v);

            while (h < horSize && v < verLen && horisontal.get(h) >= vertical[v]){
                minVal = Math.min(minVal, amount + v);
                v++;
            }

        }

        if(horisontal.get(horSize - 1) < 1E9){
            minVal = Math.min(minVal, v);
        }



        System.out.println(minVal);

    }
}
",CorCod,656,656,nlogn
"
// Java implementation to find the uncommon 
// characters of the two strings 
class
GFG 
{ 


// size of the hash table 

static
int
MAX_CHAR = 
26
; 


// function to find the uncommon 

// characters of the two strings 

static
void
findAndPrintUncommonChars(String str1, 

String str2) 

{ 

// mark presence of each character as 0 

// in the hash table 'present[]' 

int
present[] = 
new
int
[MAX_CHAR]; 

for
(
int
i = 
0
; i < MAX_CHAR; i++) 

{ 

present[i] = 
0
; 

} 


int
l1 = str1.length(); 

int
l2 = str2.length(); 


// for each character of str1, mark its 

// presence as 1 in 'present[]' 

for
(
int
i = 
0
; i < l1; i++) 

{ 

present[str1.charAt(i) - 
'a'
] = 
1
; 

} 


// for each character of str2 

for
(
int
i = 
0
; i < l2; i++) 

{ 


// if a character of str2 is also present 

// in str1, then mark its presence as -1 

if
(present[str2.charAt(i) - 
'a'
] == 
1

|| present[str2.charAt(i) - 
'a'
] == -
1
) 

{ 

present[str2.charAt(i) - 
'a'
] = -
1
; 

} 


// else mark its presence as 2 

else

{ 

present[str2.charAt(i) - 
'a'
] = 
2
; 

} 

} 


// print all the uncommon characters 

for
(
int
i = 
0
; i < MAX_CHAR; i++) 

{ 

if
(present[i] == 
1
|| present[i] == 
2
) 

{ 

System.out.print((
char
) (i + 
'a'
) + 
"" ""
); 

} 

} 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

String str1 = 
""characters""
; 

String str2 = 
""alphabets""
; 

findAndPrintUncommonChars(str1, str2); 

} 
} 

// This code is contributed by Rajput-JI ",CorCod,9,9,linear
"
// Java Program to find all the common characters 
// in n strings 
import
java.util.*; 
import
java.lang.*; 

class
GFG { 


static
int
MAX_CHAR = 
26
; 


public
static
void
commonCharacters(String str[], 

int
n) 

{ 


// primary array for common characters 

// we assume all characters are seen before. 

Boolean[] prim = 
new
Boolean[MAX_CHAR]; 

Arrays.fill(prim, 
new
Boolean(
true
)); 


// for each string 

for
(
int
i = 
0
; i < n; i++) { 


// secondary array for common characters 

// Initially marked false 

Boolean[] sec = 
new
Boolean[MAX_CHAR]; 

Arrays.fill(sec, 
new
Boolean(
false
)); 


// for every character of ith string 

for
(
int
j = 
0
; j < str[i].length(); j++) 

{ 


// if character is present in all 

// strings before, mark it. 

if
(prim[str[i].charAt(j) - 
'a'
]) 

sec[str[i].charAt(j) - 
'a'
] = 
true
; 

} 


// copy whole secondary array into primary 

System.arraycopy(sec, 
0
, prim, 
0
, MAX_CHAR); 

} 


// displaying common characters 

for
(
int
i = 
0
; i < 
26
; i++) 

if
(prim[i]){ 

System.out.print(Character.toChars(i 

+ 
97
)); 

System.out.print(
"" ""
); 

} 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

String str[] = { 
""geeksforgeeks""
, 

""gemkstones""
, 

""acknowledges""
, 

""aguelikes""
}; 


int
n = str.length; 

commonCharacters(str, n); 

} 
} 

// This code is contributed by Prasad Kshirsagar ",CorCod,68,68,linear
"
// Java program to check if binay tree is full or not 

/* Tree node structure */
class
Node 
{ 

int
data; 

Node left, right; 


Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root; 


/* this function checks if a binary tree is full or not */

boolean
isFullTree(Node node) 

{ 

// if empty tree 

if
(node == 
null
) 

return
true
; 


// if leaf node 

if
(node.left == 
null
&& node.right == 
null
) 

return
true
; 


// if both left and right subtrees are not null 

// the are full 

if
((node.left!=
null
) && (node.right!=
null
)) 

return
(isFullTree(node.left) && isFullTree(node.right)); 


// if none work 

return
false
; 

} 



// Driver program 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
10
); 

tree.root.left = 
new
Node(
20
); 

tree.root.right = 
new
Node(
30
); 

tree.root.left.right = 
new
Node(
40
); 

tree.root.left.left = 
new
Node(
50
); 

tree.root.right.left = 
new
Node(
60
); 

tree.root.left.left.left = 
new
Node(
80
); 

tree.root.right.right = 
new
Node(
70
); 

tree.root.left.left.right = 
new
Node(
90
); 

tree.root.left.right.left = 
new
Node(
80
); 

tree.root.left.right.right = 
new
Node(
90
); 

tree.root.right.left.left = 
new
Node(
80
); 

tree.root.right.left.right = 
new
Node(
90
); 

tree.root.right.right.left = 
new
Node(
80
); 

tree.root.right.right.right = 
new
Node(
90
); 


if
(tree.isFullTree(tree.root)) 

System.out.print(
""The binary tree is full""
); 

else

System.out.print(
""The binary tree is not full""
); 

} 
} 

// This code is contributed by Mayank Jaiswal ",CorCod,114,114,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

import static java.lang.Math.*;

public class Main2 {

    private FastScanner scanner = new FastScanner();

    public static void main(String[] args) {
        new Main2().solve();
    }

    private void solve() {

        int n = scanner.nextInt();


        int a[][] = new int[n][3];

        for (int i = 0; i < n; i++) {
            a[i][0] = scanner.nextInt();
            a[i][1] = scanner.nextInt();
            a[i][2] = i;
        }

        int l = -1, r = -1;

        Arrays.sort(a, (o1, o2) -> {
            if (o1[0] != o2[0]) {
                return o1[0] - o2[0];
            } else {
                return o2[1] - o1[1];
            }
        });

        int maxr = -1, maxi = -1;
        for (int i = 0; i < n; i++) {
            if (a[i][1] <= maxr) {
                l = a[i][2] + 1;
                r = maxi + 1;
                break;
            }
            if (a[i][1] > maxr) {
                maxi = a[i][2];
                maxr = a[i][1];
            }
        }

        System.out.println(l + "" "" + r);


    }

    boolean check(int cnt[][], int[] tcnt, int mid) {
        boolean ok = true;

        for (int j = 0; j < 27; j++) {
            if (cnt[mid][j] < tcnt[j]) {
                ok = false;
            }
        }
        return ok;
    }

    class Pair {
        int c, f;
    }

    class FastScanner {
        BufferedReader reader;
        StringTokenizer tokenizer;

        FastScanner() {
            reader = new BufferedReader(new InputStreamReader(System.in), 32768);
            tokenizer = null;
        }

        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();

        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        Integer[] nextA(int n) {
            Integer a[] = new Integer[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextInt();
            }
            return a;
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}",CorCod,722,722,nlogn
"
// Java program to count all substrings with same 
// first and last characters. 
public
class
GFG { 


// Returns true if first and last characters 

// of s are same. 

static
boolean
checkEquality(String s) 

{ 

return
(s.charAt(
0
) == s.charAt(s.length() - 
1
)); 

} 


static
int
countSubstringWithEqualEnds(String s) 

{ 

int
result = 
0
; 

int
n = s.length(); 


// Starting point of substring 

for
(
int
i = 
0
; i < n; i++) 


// Length of substring 

for
(
int
len = 
1
; len <= n-i; len++) 


// Check if current substring has same 

// starting and ending characters. 

if
(checkEquality(s.substring(i, i + len))) 

result++; 


return
result; 

} 


// Driver function 

public
static
void
main(String args[]) 

{ 

String s = 
""abcab""
; 

System.out.println(countSubstringWithEqualEnds(s)); 

} 
} 
// This code is contributed by Sumit Ghosh ",CorCod,509,509,quadratic
"
// O(n) solution for finding smallest subarray with sum 
// greater than x 

class
SmallestSubArraySum 
{ 

// Returns length of smallest subarray with sum greater than x. 

// If there is no subarray with given sum, then returns n+1 

static
int
smallestSubWithSum(
int
arr[], 
int
n, 
int
x) 

{ 

// Initialize current sum and minimum length 

int
curr_sum = 
0
, min_len = n + 
1
; 


// Initialize starting and ending indexes 

int
start = 
0
, end = 
0
; 

while
(end < n) 

{ 

// Keep adding array elements while current sum 

// is smaller than x 

while
(curr_sum <= x && end < n) 

curr_sum += arr[end++]; 


// If current sum becomes greater than x. 

while
(curr_sum > x && start < n) 

{ 

// Update minimum length if needed 

if
(end - start < min_len) 

min_len = end - start; 


// remove starting elements 

curr_sum -= arr[start++]; 

} 

} 

return
min_len; 

} 

// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

int
arr1[] = {
1
, 
4
, 
45
, 
6
, 
10
, 
19
}; 

int
x = 
51
; 

int
n1 = arr1.length; 

int
res1 = smallestSubWithSum(arr1, n1, x); 

if
(res1 == n1+
1
) 

System.out.println(
""Not Possible""
); 

else

System.out.println(res1); 


int
arr2[] = {
1
, 
10
, 
5
, 
2
, 
7
}; 

int
n2 = arr2.length; 

x = 
9
; 

int
res2 = smallestSubWithSum(arr2, n2, x); 

if
(res2 == n2+
1
) 

System.out.println(
""Not Possible""
); 

else

System.out.println(res2); 


int
arr3[] = {
1
, 
11
, 
100
, 
1
, 
0
, 
200
, 
3
, 
2
, 
1
, 
250
}; 

int
n3 = arr3.length; 

x = 
280
; 

int
res3 = smallestSubWithSum(arr3, n3, x); 

if
(res3 == n3+
1
) 

System.out.println(
""Not Possible""
); 

else

System.out.println(res3); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,308,308,linear
"
// Java program to find the sum 
// in a given range in an array 
// using sparse table. 
class
GFG 
{ 

// Because 2^17 is larger than 10^5 
static
int
k = 
16
; 

// Maximum value of array 
static
int
N = 
100000
; 

// k + 1 because we need 
// to access table[r][k] 
static
long
table[][] = 
new
long
[N][k + 
1
]; 

// it builds sparse table. 
static
void
buildSparseTable(
int
arr[], 

int
n) 
{ 

for
(
int
i = 
0
; i < n; i++) 

table[i][
0
] = arr[i]; 


for
(
int
j = 
1
; j <= k; j++) 

for
(
int
i = 
0
; i <= n - (
1
<< j); i++) 

table[i][j] = table[i][j - 
1
] + 

table[i + (
1
<< (j - 
1
))][j - 
1
]; 
} 

// Returns the sum of the 
// elements in the range L and R. 
static
long
query(
int
L, 
int
R) 
{ 

// boundaries of next query, 

// 0-indexed 

long
answer = 
0
; 

for
(
int
j = k; j >= 
0
; j--) 

{ 

if
(L + (
1
<< j) - 
1
<= R) 

{ 

answer = answer + table[L][j]; 


// instead of having L', we 

// increment L directly 

L += 
1
<< j; 

} 

} 

return
answer; 
} 

// Driver Code 
public
static
void
main(String args[]) 
{ 

int
arr[] = { 
3
, 
7
, 
2
, 
5
, 
8
, 
9
}; 

int
n = arr.length; 


buildSparseTable(arr, n); 


System.out.println(query(
0
, 
5
)); 

System.out.println(query(
3
, 
5
)); 

System.out.println(query(
2
, 
4
)); 
} 
} 

// This code is contributed 
// by Kirti_Mangal ",CorCod,612,612,nlogn
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 * @author Ahmed
 */




public class Watermelon {

   static class Passengers {
  
     public int floor ;
     public int time;
     
     
     public Passengers( int floor  , int time){
         this.floor =floor;
         this.time =time;
     }
     
}

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        
        Scanner in = new Scanner(System.in);
        
        int x = in.nextInt() , y = in.nextInt();
        
        ArrayList<Passengers> list = new ArrayList<>();
        
        for(int i = 1 ; i <= x ; ++i){
            list.add(new Passengers(in.nextInt(), in.nextInt()));
        }
        
        int sum = 0 ;
       for(int i = list.size() - 1 ; i >= 0 ; --i)
       {
          int s = y -  list.get(i).floor;
          sum = sum + s ; 
          
          if(sum < list.get(i).time)
          {
              sum = sum + ( list.get(i).time - sum);
          }
          
          y = list.get(i).floor;
       } 
        
        
       if( list.get(list.size() - 1).floor != 0){
           sum = sum  + (list.get(0).floor);
       }
        System.out.println(sum);
    }
    
}
",CorCod,274,274,linear
"
// Java implementation to count pairs from two 
// BSTs whose sum is equal to a given value x 
import
java.util.Stack; 
public
class
GFG { 


// structure of a node of BST 

static
class
Node { 

int
data; 

Node left, right; 


// constructor 

public
Node(
int
data) { 

this
.data = data; 

left = 
null
; 

right = 
null
; 

} 

} 


static
Node root1; 

static
Node root2; 

// function to count pairs from two BSTs 

// whose sum is equal to a given value x 

static
int
countPairs(Node root1, Node root2, 

int
x) 

{ 

// if either of the tree is empty 

if
(root1 == 
null
|| root2 == 
null
) 

return
0
; 


// stack 'st1' used for the inorder 

// traversal of BST 1 

// stack 'st2' used for the reverse 

// inorder traversal of BST 2 

//stack<Node*> st1, st2; 

Stack<Node> st1 = 
new
Stack<>(); 

Stack<Node> st2 = 
new
Stack<>(); 

Node top1, top2; 


int
count = 
0
; 


// the loop will break when either of two 

// traversals gets completed 

while
(
true
) { 


// to find next node in inorder 

// traversal of BST 1 

while
(root1 != 
null
) { 

st1.push(root1); 

root1 = root1.left; 

} 


// to find next node in reverse 

// inorder traversal of BST 2 

while
(root2 != 
null
) { 

st2.push(root2); 

root2 = root2.right; 

} 


// if either gets empty then corresponding 

// tree traversal is completed 

if
(st1.empty() || st2.empty()) 

break
; 


top1 = st1.peek(); 

top2 = st2.peek(); 


// if the sum of the node's is equal to 'x' 

if
((top1.data + top2.data) == x) { 

// increment count 

count++; 


// pop nodes from the respective stacks 

st1.pop(); 

st2.pop(); 


// insert next possible node in the 

// respective stacks 

root1 = top1.right; 

root2 = top2.left; 

} 


// move to next possible node in the 

// inoder traversal of BST 1 

else
if
((top1.data + top2.data) < x) { 

st1.pop(); 

root1 = top1.right; 

} 


// move to next possible node in the 

// reverse inoder traversal of BST 2 

else
{ 

st2.pop(); 

root2 = top2.left; 

} 

} 


// required count of pairs 

return
count; 

} 


// Driver program to test above 

public
static
void
main(String args[]) 

{ 

// formation of BST 1 

root1 = 
new
Node(
5
); 
/* 5 */

root1.left = 
new
Node(
3
); 
/* / \ */

root1.right = 
new
Node(
7
); 
/* 3 7 */

root1.left.left = 
new
Node(
2
); 
/* / \ / \ */

root1.left.right = 
new
Node(
4
); 
/* 2 4 6 8 */

root1.right.left = 
new
Node(
6
); 

root1.right.right = 
new
Node(
8
); 


// formation of BST 2 

root2 = 
new
Node(
10
); 
/* 10 */

root2.left = 
new
Node(
6
); 
/* / \ */

root2.right = 
new
Node(
15
); 
/* 6 15 */

root2.left.left = 
new
Node(
3
); 
/* / \ / \ */

root2.left.right = 
new
Node(
8
); 
/* 3 8 11 18 */

root2.right.left = 
new
Node(
11
); 

root2.right.right = 
new
Node(
18
); 


int
x = 
16
; 

System.out.println(
""Pairs = ""

+ countPairs(root1, root2, x)); 

} 
} 
// This code is contributed by Sumit Ghosh ",CorCod,262,262,linear
"
// Java program to count 
// the number of indexes 
// in range L R such that 
// Ai=Ai+1 

class
GFG { 

public
static
int
N = 
1000
; 

// Array to store count 
// of index from 0 to 
// i that obey condition 
static
int
prefixans[] = 
new
int
[
1000
]; 

// precomputing prefixans[] array 
public
static
void
countIndex(
int
a[], 
int
n) 
{ 


// traverse to compute 

// the prefixans[] array 

for
(
int
i = 
0
; i < n; i++) { 

if
(i + 
1
< n && a[i] == a[i + 
1
]) 

prefixans[i] = 
1
; 


if
(i != 
0
) 

prefixans[i] += prefixans[i - 
1
]; 

} 
} 

// function that answers 
// every query in O(1) 
public
static
int
answer_query(
int
l, 
int
r) 
{ 

if
(l == 
0
) 

return
prefixans[r - 
1
]; 

else

return
prefixans[r - 
1
] - 

prefixans[l - 
1
]; 
} 

// Driver Code 
public
static
void
main(String args[]) 
{ 

int
a[] = {
1
, 
2
, 
2
, 
2
, 
3
, 
3
, 
4
, 
4
, 
4
}; 

int
n = 
9
; 


// pre-computation 

countIndex(a, n); 


int
L, R; 


// 1-st query 

L = 
1
; 

R = 
8
; 


System.out.println(answer_query(L, R)); 


// 2nd query 

L = 
0
; 

R = 
4
; 

System.out.println(answer_query(L, R)); 
} 
} 

// This code is contributed by Jaideep Pyne ",CorCod,771,771,constant
"/*
 * Created on 17.05.2019
 */
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * @author Wolfgang Weck
 */
public class A01Easy {
	private static interface Matrix {
		boolean get(int i, int j);

		int size();
	}

	private static class MData implements Matrix {
		private final boolean[][] m;

		MData(boolean[][] m) {
			this.m = m;
		}

		@Override
		public boolean get(int i, int j) {
			return m[i][j];
		}

		@Override
		public int size() {
			return m.length;
		}
	}

	private static abstract class MDecorator implements Matrix {
		protected final Matrix inner;

		MDecorator(Matrix inner) {
			this.inner = inner;
		}

		@Override
		public int size() {
			return inner.size();
		}
	}

	private static class MHFlip extends MDecorator {
		MHFlip(Matrix inner) {
			super(inner);
		}

		@Override
		public boolean get(int i, int j) {
			return inner.get(size() - 1 - i, j);
		}
	}

	private static class MVFlip extends MDecorator {
		MVFlip(Matrix inner) {
			super(inner);
		}

		@Override
		public boolean get(int i, int j) {
			return inner.get(i, size() - 1 - j);
		}
	}

	private static class MRot extends MDecorator {
		MRot(Matrix inner) {
			super(inner);
		}

		@Override
		public boolean get(int i, int j) {
			return inner.get(j, size() - 1 - i);
		}
	}

	public static void main(String[] args) {
		try (BufferedReader r = new BufferedReader(new InputStreamReader(System.in))) {
			final int N = Integer.parseInt(r.readLine());
			Matrix m1 = readMatrix(r, N), m2 = readMatrix(r, N);
			boolean matched = matchesFlipped(m1, m2);
			int i = 0;
			while (i < 3 && !matched) {
				m1 = new MRot(m1);
				matched = matchesFlipped(m1, m2);
				i++;
			}
			System.out.println(matched ? ""Yes"" : ""No"");
		}
		catch (IOException e) {
			e.printStackTrace();
		}
	}

	private static Matrix readMatrix(BufferedReader r, int n) throws IOException {
		boolean[][] m = new boolean[n][n];
		for (int i = 0; i < n; i++) {
			String line = r.readLine();
			for (int j = 0; j < n; j++) {
				m[i][j] = line.charAt(j) == 'X';
			}
		}
		return new MData(m);
	}

	private static boolean matches(Matrix m1, Matrix m2) {
		int i = 0, j = 0, n = m1.size();
		while (i < n && m1.get(i, j) == m2.get(i, j)) {
			j++;
			if (j == n) {
				j = 0;
				i++;
			}
		}
		return i == n;
	}

	private static boolean matchesFlipped(Matrix m1, Matrix m2) {
		return matches(m1, m2) || matches(new MHFlip(m1), m2) || matches(new MVFlip(m1), m2);
	}
}
",CorCod,454,454,quadratic
"import java.util.*;
import java.io.*;

public class programA {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		if(n%2 == 0)System.out.println(n/2 +1);
		else System.out.println((int)Math.ceil((double)n/2));
	}
}




",CorCod,849,849,constant
"import java.util.*;
 
public class Main{
    private static final int MAX_SIZE = 100005;
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int a = sc.nextInt();
        int b = sc.nextInt();
        if(((m + 1) / 60 < a) || ((m + 1) / 60 == a && (m + 1) % 60 <= b)) {
            out(0, 0);
            System.exit(0);
        }
        for(int i = 2; i <= n; i++) {
            int x = sc.nextInt();
            int y = sc.nextInt();

            int bb = b + 2 * m + 2;
            int aa = a + bb / 60;
            bb %= 60;

            if((aa < x) || (aa == x && bb <= y)) {
                b = b + m + 1;
                a = a + b / 60;
                b %= 60;
                out(a, b);
                System.exit(0);
            }
            a = x;
            b = y;
        }
        b = b + m + 1;
        a = a + b / 60;
        b = b % 60;        
        out(a, b);
    }

    private static void out(int a, int b) {
        cout(a);
        cout("" "");
        cout(b);
    }

    private static void cout(Object a) {
        System.out.print(a);
    }
}",CorCod,17,17,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class SFly {

	public static void main(String[] args) throws IOException {
		
		BufferedReader lector = new BufferedReader(new InputStreamReader(System.in));
		int planet = Integer.parseInt(lector.readLine());
		int ini = Integer.parseInt(lector.readLine());
		double peso = ini;
		int[] desp = new int[planet];
		int[] ater = new int[planet];
		String[] temp = lector.readLine().split("" "");		
		for(int i=0; i<planet; i++) {
			desp[i] = Integer.parseInt(temp[i]);
			if(desp[i] == 1) {
				System.out.println(-1);
				lector.close();
				return;
			}
		}
		temp = lector.readLine().split("" "");		
		for(int i=0; i<planet; i++) {
			ater[i] = Integer.parseInt(temp[i]);
			if(ater[i] == 1) {
				System.out.println(-1);
				lector.close();
				return;
			}
		}
		temp = null;
		int i=planet-1;
		peso = (peso*ater[0])/(ater[0]-1);
		while(i>0) {
			peso = (peso*desp[i])/(desp[i]-1);
			peso = (peso*ater[i])/(ater[i]-1);
			i--;
		}
		peso = (peso*desp[0])/(desp[0]-1);
		peso = peso - ini;
		System.out.println(peso);
		lector.close();
	}
}",CorCod,350,350,linear
"import java.io.*;
import java.util.*;

public class C
{

	static StringBuilder st = new StringBuilder();
	
	public static void main(String[] args) throws Exception 
	{

		Scanner sc = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		
		int [] freq = new int [5] ; 
		
		int k = 3;  
		while(k -- >0)
		{
			int x = sc.nextInt();
			
			if(x <= 4) freq[x]++;
			
		}
		freq[2] += freq[4]/ 2 ;
		
		if(freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)
			out.println(""YES"");
		else
			out.println(""NO"");
		
		
		out.flush();
		out.close();

	}
	
	static class Scanner 
	{
		BufferedReader br;
		StringTokenizer st;

		Scanner(InputStream in) 
		{
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() throws Exception {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		int nextInt() throws Exception {
			return Integer.parseInt(next());
		}

		long nextLong() throws Exception {
			return Long.parseLong(next());
		}

		double nextDouble() throws Exception {
			return Double.parseDouble(next());
		}

	}

	static void shuffle(int[] a) {
		int n = a.length;
		for (int i = 0; i < n; i++) {
			int r = i + (int) (Math.random() * (n - i));
			int tmp = a[i];
			a[i] = a[r];
			a[r] = tmp;
		}
	}

}",CorCod,774,774,constant
"
/* Java program to find first repeating element in arr[] */
import
java.util.*; 

class
Main 
{ 

// This function prints the first repeating element in arr[] 

static
void
printFirstRepeating(
int
arr[]) 

{ 

// Initialize index of first repeating element 

int
min = -
1
; 


// Creates an empty hashset 

HashSet<Integer> set = 
new
HashSet<>(); 


// Traverse the input array from right to left 

for
(
int
i=arr.length-
1
; i>=
0
; i--) 

{ 

// If element is already in hash set, update min 

if
(set.contains(arr[i])) 

min = i; 


else
// Else add element to hash set 

set.add(arr[i]); 

} 


// Print the result 

if
(min != -
1
) 

System.out.println(
""The first repeating element is ""
+ arr[min]); 

else

System.out.println(
""There are no repeating elements""
); 

} 


// Driver method to test above method 

public
static
void
main (String[] args) 
throws
java.lang.Exception 

{ 

int
arr[] = {
10
, 
5
, 
3
, 
4
, 
3
, 
5
, 
6
}; 

printFirstRepeating(arr); 

} 
} ",CorCod,154,154,linear
"import java.awt.Point;
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class C {

	static StringBuilder st = new StringBuilder();

		public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);

		Point [] square = new Point [4] ; 
		Point [] rotSquare = new Point[4] ; 
		
		for(int i = 0 ; i < 4 ;i++)
			square[i] = new Point(sc.nextInt() , sc.nextInt());
		
		for(int i = 0 ; i < 4 ;i++)
			rotSquare[i] = new Point(sc.nextInt() , sc.nextInt());
		
		boolean can = false ; 
		
		for(int x = -100 ; x <= 100 ; x++)
			for(int y = -100 ; y <= 100 ; y++)
				can |= inside(new Point(x , y), square) & inside(new Point (x , y), rotSquare);
				
			
		
		
		out.println(can ? ""YES"" : ""NO"");
		
		out.flush();
		out.close();

	}
	static int crossProduct(Point a , Point b)
	{
		int ans = a.x * b.y - a.y * b.x ; 
		
		if(ans < 0)return -1 ;
		if(ans == 0) return 0 ;
		return 1 ; 
	}
	
	static boolean inside(Point a , Point [] points)
	{
		boolean allPos = true ; 
		boolean allNeg = true ; 
		
		for(int i = 0 ; i < 4 ; i++)
		{
			Point v1 = new Point (points[i].x - a.x , points[i].y - a.y) ; 
			Point v2 = new Point (points[(i + 1) % 4].x - a.x , points[(i + 1) % 4].y - a.y) ; 
			
			allPos &= crossProduct(v1, v2) >= 0;
			allNeg &= crossProduct(v1, v2) <= 0;
		}
		return allPos | allNeg ; 
		
	}

	static class Scanner {
		BufferedReader br;
		StringTokenizer st;

		Scanner(InputStream in) {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() throws Exception {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());

			return st.nextToken();
		}

		int nextInt() throws Exception {
			return Integer.parseInt(next());
		}

		long nextLong() throws Exception {
			return Long.parseLong(next());
		}

		double nextDouble() throws Exception {
			return Double.parseDouble(next());
		}

	}

	static void shuffle(int[] a) {
		int n = a.length;
		for (int i = 0; i < n; i++) {
			int r = i + (int) (Math.random() * (n - i));
			int tmp = a[i];
			a[i] = a[r];
			a[r] = tmp;
		}
	}

}",CorCod,803,803,constant
"
// Java program for nth Catalan Number 

class
GFG { 

// Returns value of Binomial Coefficient C(n, k) 

static
long
binomialCoeff(
int
n, 
int
k) { 

long
res = 
1
; 


// Since C(n, k) = C(n, n-k) 

if
(k > n - k) { 

k = n - k; 

} 


// Calculate value of [n*(n-1)*---*(n-k+1)] / [k*(k-1)*---*1] 

for
(
int
i = 
0
; i < k; ++i) { 

res *= (n - i); 

res /= (i + 
1
); 

} 


return
res; 

} 

// A Binomial coefficient based function to find nth catalan 
// number in O(n) time 

static
long
catalan(
int
n) { 

// Calculate value of 2nCn 

long
c = binomialCoeff(
2
* n, n); 


// return 2nCn/(n+1) 

return
c / (n + 
1
); 

} 

// Driver program to test above function 

public
static
void
main(String[] args) { 

for
(
int
i = 
0
; i < 
10
; i++) { 

System.out.print(catalan(i) + 
"" ""
); 

} 


} 
} ",CorCod,65,65,linear
"package com.interview.binarysearch;

/**
 * http://www.geeksforgeeks.org/search-floor-and-ceil-in-a-sorted-array/
 */
public class FloorAndCeilingSortedArray {

    public int floor(int input[], int x){
        int low = 0;
        int high = input.length-1;
        while(low <= high){
            int middle = (low + high)/2;
            if(input[middle] == x || (input[middle] < x && (middle == input.length-1 || input[middle+1] > x))){
                return middle;
            }else if(input[middle] < x){
                low = middle+1;
            }else{
                high = middle-1;
            }
        }
        return -1;
    }

    public int ceiling(int input[], int x){
        int low = 0;
        int high = input.length-1;
        while(low <= high){
            int middle = (low + high)/2;
            if(input[middle] == x || (input[middle] > x && (middle == 0 || input[middle-1] < x))){
                return middle;
            }else if(input[middle] < x){
                low = middle+1;
            }else{
                high = middle-1;
            }
        }
        return -1;
    }
    
    public static void main(String args[]){
        int input[] = {1,2,5,6,11,15};
        FloorAndCeilingSortedArray foc = new FloorAndCeilingSortedArray();
        System.out.println(foc.floor(input, 15));
        System.out.println(foc.ceiling(input, 2));
    }
}",CorCod,908,908,logn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.FileNotFoundException;
import java.util.StringTokenizer;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author \/
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            int n = in.nextInt();
            int m = in.nextInt();

            TaskC.pair[] songs = new TaskC.pair[n];
            long sum = 0;
            for (int i = 0; i < n; i++) {
                songs[i] = new TaskC.pair(in.nextInt(), in.nextInt());
                sum += songs[i].a;
            }
            Arrays.sort(songs);

            int res = 0;
            int idx = n - 1;
            while (sum > m) {
                if (idx < 0) {
                    break;
                }
                sum -= (songs[idx].a - songs[idx].b);

                res++;
                idx--;
            }

            if (sum > m) {
                out.println(-1);
            } else {
                out.println(res);
            }
        }

        static class pair implements Comparable<TaskC.pair> {
            int a;
            int b;

            pair(int a, int b) {
                this.a = a;
                this.b = b;
            }

            public int compareTo(TaskC.pair p) {
                return (this.a - this.b) - (p.a - p.b);
            }

        }

    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(String s) {
            try {
                br = new BufferedReader(new FileReader(s));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",CorCod,615,615,nlogn
"import java.util.ArrayList;
import java.util.Scanner;

public class Main {


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
         int hp = scanner.nextInt();
        if (hp%4 == 1){
            System.out.println(""0 A"");
        }
        else if (hp%4 == 2){
            System.out.println(""1 B"");
        }
        else if (hp%4 == 3){
            System.out.println(""2 A"");
        }
        else {
            System.out.println(""1 A"");
        }

    }
    }
",CorCod,763,763,constant
"import java.io.*; 
import java.util.*; 


public class p7{
	
	static class FastReader{ 
		BufferedReader br; 
		StringTokenizer st; 

		public FastReader() 
		{ 
			br = new BufferedReader(new
					InputStreamReader(System.in)); 
		} 

		String next() 
		{ 
			while (st == null || !st.hasMoreElements()) 
			{ 
				try
				{ 
					st = new StringTokenizer(br.readLine()); 
				} 
				catch (IOException e) 
				{ 
					e.printStackTrace(); 
				} 
			} 
			return st.nextToken(); 
		} 

		int nextInt() 
		{ 
			return Integer.parseInt(next()); 
		} 

		long nextLong() 
		{ 
			return Long.parseLong(next()); 
		} 

		double nextDouble() 
		{ 
			return Double.parseDouble(next()); 
		} 

		String nextLine() 
		{ 
			String str = """"; 
			try
			{ 
				str = br.readLine(); 
			} 
			catch (IOException e) 
			{ 
				e.printStackTrace(); 
			} 
			return str; 
		} 
	}

	public static void main(String[] args) 
	{ 
        FastReader sc = new FastReader(); 
        //PrintWriter out = new PrintWriter(System.out); 
        int n = sc.nextInt();
		int k = sc.nextInt();
		long one = (long)Math.pow(2, k) - 1;
		
		long[] arr = new long[n+1];
		
		arr[0] = 0;
		for(int i=1;i<=n;i++){
			arr[i] = sc.nextLong();
			arr[i] ^= arr[i-1];
		}

		Map<Long, Long> count = new HashMap<>();

		for(int i=0;i<=n;i++){
			Long key = Math.min(arr[i], (arr[i]^one));
			Long val = count.get(key);
			if(val==null) val = 0L;
			count.put(key, val+1);
		}

		long num = n;
		long ans = num*(num+1)/2;
		
		for(Map.Entry<Long, Long> ent: count.entrySet()){
			
			Long cnt = ent.getValue();
			
			long num1 = cnt/2;
			long num2 = (cnt+1)/2;
			
			ans -= ( (num1*(num1-1))/2 );
			ans -= ( (num2*(num2-1))/2 );
		}

		System.out.println(ans);
	}
}
",CorCod,645,645,nlogn
"
// A Java program for Prim's Minimum Spanning Tree (MST) algorithm. 
// The program is for adjacency matrix representation of the graph 

import
java.util.*; 
import
java.lang.*; 
import
java.io.*; 

class
MST { 

// Number of vertices in the graph 

private
static
final
int
V = 
5
; 


// A utility function to find the vertex with minimum key 

// value, from the set of vertices not yet included in MST 

int
minKey(
int
key[], Boolean mstSet[]) 

{ 

// Initialize min value 

int
min = Integer.MAX_VALUE, min_index = -
1
; 


for
(
int
v = 
0
; v < V; v++) 

if
(mstSet[v] == 
false
&& key[v] < min) { 

min = key[v]; 

min_index = v; 

} 


return
min_index; 

} 


// A utility function to print the constructed MST stored in 

// parent[] 

void
printMST(
int
parent[], 
int
graph[][]) 

{ 

System.out.println(
""Edge \tWeight""
); 

for
(
int
i = 
1
; i < V; i++) 

System.out.println(parent[i] + 
"" - ""
+ i + 
""\t""
+ graph[i][parent[i]]); 

} 


// Function to construct and print MST for a graph represented 

// using adjacency matrix representation 

void
primMST(
int
graph[][]) 

{ 

// Array to store constructed MST 

int
parent[] = 
new
int
[V]; 


// Key values used to pick minimum weight edge in cut 

int
key[] = 
new
int
[V]; 


// To represent set of vertices not yet included in MST 

Boolean mstSet[] = 
new
Boolean[V]; 


// Initialize all keys as INFINITE 

for
(
int
i = 
0
; i < V; i++) { 

key[i] = Integer.MAX_VALUE; 

mstSet[i] = 
false
; 

} 


// Always include first 1st vertex in MST. 

key[
0
] = 
0
; 
// Make key 0 so that this vertex is 

// picked as first vertex 

parent[
0
] = -
1
; 
// First node is always root of MST 


// The MST will have V vertices 

for
(
int
count = 
0
; count < V - 
1
; count++) { 

// Pick thd minimum key vertex from the set of vertices 

// not yet included in MST 

int
u = minKey(key, mstSet); 


// Add the picked vertex to the MST Set 

mstSet[u] = 
true
; 


// Update key value and parent index of the adjacent 

// vertices of the picked vertex. Consider only those 

// vertices which are not yet included in MST 

for
(
int
v = 
0
; v < V; v++) 


// graph[u][v] is non zero only for adjacent vertices of m 

// mstSet[v] is false for vertices not yet included in MST 

// Update the key only if graph[u][v] is smaller than key[v] 

if
(graph[u][v] != 
0
&& mstSet[v] == 
false
&& graph[u][v] < key[v]) { 

parent[v] = u; 

key[v] = graph[u][v]; 

} 

} 


// print the constructed MST 

printMST(parent, graph); 

} 


public
static
void
main(String[] args) 

{ 

/* Let us create the following graph 

2 3 

(0)--(1)--(2) 

| / \ | 

6| 8/ \5 |7 

| / \ | 

(3)-------(4) 

9 */

MST t = 
new
MST(); 

int
graph[][] = 
new
int
[][] { { 
0
, 
2
, 
0
, 
6
, 
0
}, 

{ 
2
, 
0
, 
3
, 
8
, 
5
}, 

{ 
0
, 
3
, 
0
, 
0
, 
7
}, 

{ 
6
, 
8
, 
0
, 
0
, 
9
}, 

{ 
0
, 
5
, 
7
, 
9
, 
0
} }; 


// Print the solution 

t.primMST(graph); 

} 
} 
// This code is contributed by Aakash Hasija ",CorCod,470,470,quadratic
"package com.rampatra.searching;

/**
 * Created by IntelliJ IDEA.
 *
 * @author rampatra
 * @version 9/1/15
 */
public class BinarySearch {

    /**
     * Searches an element {@param n} in a sorted array {@param a}
     * and returns its index in O(log n) time. The Index may not
     * correspond to the first occurrence of the element.
     *
     * @param a sorted array to be searched
     * @param n number to be searched in the array
     * @return index of {@param n} or {@code -1} if not present
     */
    private static int binarySearch(int[] a, int n) {
        return binarySearch(a, n, 0, a.length - 1);
    }

    public static int binarySearch(int[] a, int n, int low, int high) {

        if (low <= high) {
            int mid = (low + high) / 2; // to prevent overflow you can instead do: mid = low + (high - low) / 2

            if (n == a[mid]) {
                return mid;
            } else if (n < a[mid]) {
                return binarySearch(a, n, 0, mid - 1);
            } else {
                return binarySearch(a, n, mid + 1, high);
            }
        } else {
            return -1;
        }
    }

    /**
     * Non-recursive version of binary search.
     *
     * @param a sorted array to be searched
     * @param n number to be searched in the array
     * @return index of {@param n} or {@code -1} if not present
     */
    private static int binarySearchNonRecursive(int[] a, int n) {
        int low = 0, high = a.length, mid;
        while (low <= high) {
            mid = (low + high) / 2; // to prevent overflow you can instead do: mid = low + (high - low) / 2
            if (n == a[mid]) {
                return mid;
            } else if (n < a[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }

    /**
     * Driver for testing.
     *
     * @param a
     */
    public static void main(String[] args) {
        System.out.println(binarySearch(new int[]{0, 2}, 2));
        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 2));
        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 3));
        System.out.println(binarySearch(new int[]{0, 2}, 0));
        System.out.println(binarySearch(new int[]{0, 1, 2, 2, 2, 3, 3}, 2)); // doesn't return index of first occurrence
        System.out.println(""---------"");
        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 2));
        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 2));
        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 3));
        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 0));
        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));
    }
}",CorCod,910,910,logn
"
/* Program to check for majority element in a sorted array */
import
java.io.*; 

class
Majority { 


/* If x is present in arr[low...high] then returns the index of 

first occurrence of x, otherwise returns -1 */

static
int
_binarySearch(
int
arr[], 
int
low, 
int
high, 
int
x) 

{ 

if
(high >= low) 

{ 

int
mid = (low + high)/
2
; 
/*low + (high - low)/2;*/


/* Check if arr[mid] is the first occurrence of x. 

arr[mid] is first occurrence if x is one of the following 

is true: 

(i) mid == 0 and arr[mid] == x 

(ii) arr[mid-1] < x and arr[mid] == x 

*/

if
( (mid == 
0
|| x > arr[mid-
1
]) && (arr[mid] == x) ) 

return
mid; 

else
if
(x > arr[mid]) 

return
_binarySearch(arr, (mid + 
1
), high, x); 

else

return
_binarySearch(arr, low, (mid -
1
), x); 

} 


return
-
1
; 

} 



/* This function returns true if the x is present more than n/2 

times in arr[] of size n */

static
boolean
isMajority(
int
arr[], 
int
n, 
int
x) 

{ 

/* Find the index of first occurrence of x in arr[] */

int
i = _binarySearch(arr, 
0
, n-
1
, x); 


/* If element is not present at all, return false*/

if
(i == -
1
) 

return
false
; 


/* check if the element is present more than n/2 times */

if
(((i + n/
2
) <= (n -
1
)) && arr[i + n/
2
] == x) 

return
true
; 

else

return
false
; 

} 


/*Driver function to check for above functions*/

public
static
void
main (String[] args) { 


int
arr[] = {
1
, 
2
, 
3
, 
3
, 
3
, 
3
, 
10
}; 

int
n = arr.length; 

int
x = 
3
; 

if
(isMajority(arr, n, x)==
true
) 

System.out.println(x + 
"" appears more than ""
+ 

n/
2
+ 
"" times in arr[]""
); 

else

System.out.println(x + 
"" does not appear more than ""
+ 

n/
2
+ 
"" times in arr[]""
); 

} 
} 
/*This code is contributed by Devesh Agrawal*/",CorCod,905,905,logn
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

    public static void main (String[] args) {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        try {
            String parameterStringList[] = reader.readLine().split("" "");
            int x = Integer.parseInt(parameterStringList[0]);
            int y = Integer.parseInt(parameterStringList[1]);
            int z = Integer.parseInt(parameterStringList[2]);
            int t1 = Integer.parseInt(parameterStringList[3]);
            int t2 = Integer.parseInt(parameterStringList[4]);
            int t3 = Integer.parseInt(parameterStringList[5]);

            int T1 = Math.abs(x-y) * t1;
            int T2 = Math.abs(x-z) * t2 + 3*t3 + Math.abs(x-y) * t2;

            if(T2 <= T1) System.out.println(""YES"");
            else System.out.println(""NO"");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",CorCod,739,739,constant
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Collection;
import java.util.AbstractList;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.Deque;
import java.util.ArrayDeque;
import java.util.NoSuchElementException;
import java.util.ConcurrentModificationException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author cunbidun
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        DPairOfLines solver = new DPairOfLines();
        solver.solve(1, in, out);
        out.close();
    }

    static class DPairOfLines {
        private static final int INF = (int) 2e9 + 7;
        private InputReader in;
        private PrintWriter out;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            this.in = in;
            this.out = out;
            int n = in.nextInt();
            if (n <= 4) {
                out.println(""YES"");
                return;
            }
            TreeList<PairII> list = new TreeList<>();
            PairII[] a = new PairII[n + 1];
            for (int i = 1; i <= n; i++) {
                a[i] = (new PairII(in.nextInt(), in.nextInt()));
                list.add(a[i]);
            }
            PairII pos1 = new PairII(INF, INF);
            PairII pos2 = new PairII(INF, INF);
            for (int i = 1; i <= 5; i++) {
                for (int j = i + 1; j <= 5; j++) {
                    for (int k = j + 1; k <= 5; k++) {
                        int x1 = a[i].first;
                        int y1 = a[i].second;
                        int x2 = a[j].first;
                        int y2 = a[j].second;
                        int x = a[k].first;
                        int y = a[k].second;
                        long s = (long) (y2 - y1) * x + (long) (x1 - x2) * y + ((long) x2 * y1 - (long) x1 * y2);
                        if (s == 0) {
                            pos1 = a[i];
                            pos2 = a[j];
                        }
                    }
                }
            }

            if (pos1.equals(new PairII(INF, INF))) {
                out.println(""NO"");
                return;
            }
            int x1 = pos1.first;
            int y1 = pos1.second;
            int x2 = pos2.first;
            int y2 = pos2.second;
            for (int i = 0; i < list.size(); i++) {
                int x = list.get(i).first;
                int y = list.get(i).second;
                long s = (long) (y2 - y1) * x + (long) (x1 - x2) * y + ((long) x2 * y1 - (long) x1 * y2);
                if (s == 0) {
                    list.remove(i);
                    i--;
                }
            }
            if (list.size() <= 2) {
                out.println(""YES"");
                return;
            }
            x1 = list.get(0).first;
            y1 = list.get(0).second;
            x2 = list.get(1).first;
            y2 = list.get(1).second;
            for (int i = 0; i < list.size(); i++) {
                int x = list.get(i).first;
                int y = list.get(i).second;
                long s = (long) (y2 - y1) * x + (long) (x1 - x2) * y + ((long) x2 * y1 - (long) x1 * y2);
                if (s == 0) {
                    list.remove(i);
                    i--;
                }
            }
            if (list.size() == 0) {
                out.println(""YES"");
            } else out.println(""NO"");
        }

    }

    static interface OrderedIterator<E> extends Iterator<E> {
    }

    static class PairII implements Comparable<PairII> {
        public int first;
        public int second;

        public PairII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            PairII pair = (PairII) o;

            return first == pair.first && second == pair.second;
        }

        public String toString() {
            return ""("" + first + "","" + second + "")"";
        }

        public int compareTo(PairII o) {
            int value = Integer.compare(first, o.first);
            if (value != 0) {
                return value;
            }
            return Integer.compare(second, o.second);
        }

    }

    static class TreeList<E> extends AbstractList<E> {
        private TreeList.AVLNode<E> root;
        private int size;

        public TreeList() {
            super();
        }

        public TreeList(final Collection<? extends E> coll) {
            super();
            if (!coll.isEmpty()) {
                root = new TreeList.AVLNode<>(coll);
                size = coll.size();
            }
        }

        public E get(final int index) {
            return root.get(index).getValue();
        }

        public int size() {
            return size;
        }

        public Iterator<E> iterator() {
            // override to go 75% faster
            return listIterator(0);
        }

        public ListIterator<E> listIterator() {
            // override to go 75% faster
            return listIterator(0);
        }

        public ListIterator<E> listIterator(final int fromIndex) {
            return new TreeList.TreeListIterator<>(this, fromIndex);
        }

        public int indexOf(final Object object) {
            // override to go 75% faster
            if (root == null) {
                return -1;
            }
            return root.indexOf(object, root.relativePosition);
        }

        public boolean contains(final Object object) {
            return indexOf(object) >= 0;
        }

        public Object[] toArray() {
            final Object[] array = new Object[size()];
            if (root != null) {
                root.toArray(array, root.relativePosition);
            }
            return array;
        }

        public void add(final int index, final E obj) {
            modCount++;
            if (root == null) {
                root = new TreeList.AVLNode<>(index, obj, null, null);
            } else {
                root = root.insert(index, obj);
            }
            size++;
        }

        public boolean addAll(final Collection<? extends E> c) {
            if (c.isEmpty()) {
                return false;
            }
            modCount += c.size();
            final TreeList.AVLNode<E> cTree = new TreeList.AVLNode<>(c);
            root = root == null ? cTree : root.addAll(cTree, size);
            size += c.size();
            return true;
        }

        public E set(final int index, final E obj) {
            final TreeList.AVLNode<E> node = root.get(index);
            final E result = node.value;
            node.setValue(obj);
            return result;
        }

        public E remove(final int index) {
            modCount++;
            final E result = get(index);
            root = root.remove(index);
            size--;
            return result;
        }

        public void clear() {
            modCount++;
            root = null;
            size = 0;
        }

        static class AVLNode<E> {
            private TreeList.AVLNode<E> left;
            private boolean leftIsPrevious;
            private TreeList.AVLNode<E> right;
            private boolean rightIsNext;
            private int height;
            private int relativePosition;
            private E value;

            private AVLNode(final int relativePosition, final E obj,
                            final TreeList.AVLNode<E> rightFollower, final TreeList.AVLNode<E> leftFollower) {
                this.relativePosition = relativePosition;
                value = obj;
                rightIsNext = true;
                leftIsPrevious = true;
                right = rightFollower;
                left = leftFollower;
            }

            private AVLNode(final Collection<? extends E> coll) {
                this(coll.iterator(), 0, coll.size() - 1, 0, null, null);
            }

            private AVLNode(final Iterator<? extends E> iterator, final int start, final int end,
                            final int absolutePositionOfParent, final TreeList.AVLNode<E> prev, final TreeList.AVLNode<E> next) {
                final int mid = start + (end - start) / 2;
                if (start < mid) {
                    left = new TreeList.AVLNode<>(iterator, start, mid - 1, mid, prev, this);
                } else {
                    leftIsPrevious = true;
                    left = prev;
                }
                value = iterator.next();
                relativePosition = mid - absolutePositionOfParent;
                if (mid < end) {
                    right = new TreeList.AVLNode<>(iterator, mid + 1, end, mid, this, next);
                } else {
                    rightIsNext = true;
                    right = next;
                }
                recalcHeight();
            }

            E getValue() {
                return value;
            }

            void setValue(final E obj) {
                this.value = obj;
            }

            TreeList.AVLNode<E> get(final int index) {
                final int indexRelativeToMe = index - relativePosition;

                if (indexRelativeToMe == 0) {
                    return this;
                }

                final TreeList.AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();
                if (nextNode == null) {
                    return null;
                }
                return nextNode.get(indexRelativeToMe);
            }

            int indexOf(final Object object, final int index) {
                if (getLeftSubTree() != null) {
                    final int result = left.indexOf(object, index + left.relativePosition);
                    if (result != -1) {
                        return result;
                    }
                }
                if (value == null ? value == object : value.equals(object)) {
                    return index;
                }
                if (getRightSubTree() != null) {
                    return right.indexOf(object, index + right.relativePosition);
                }
                return -1;
            }

            void toArray(final Object[] array, final int index) {
                array[index] = value;
                if (getLeftSubTree() != null) {
                    left.toArray(array, index + left.relativePosition);
                }
                if (getRightSubTree() != null) {
                    right.toArray(array, index + right.relativePosition);
                }
            }

            TreeList.AVLNode<E> next() {
                if (rightIsNext || right == null) {
                    return right;
                }
                return right.min();
            }

            TreeList.AVLNode<E> previous() {
                if (leftIsPrevious || left == null) {
                    return left;
                }
                return left.max();
            }

            TreeList.AVLNode<E> insert(final int index, final E obj) {
                final int indexRelativeToMe = index - relativePosition;

                if (indexRelativeToMe <= 0) {
                    return insertOnLeft(indexRelativeToMe, obj);
                }
                return insertOnRight(indexRelativeToMe, obj);
            }

            private TreeList.AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {
                if (getLeftSubTree() == null) {
                    setLeft(new TreeList.AVLNode<>(-1, obj, this, left), null);
                } else {
                    setLeft(left.insert(indexRelativeToMe, obj), null);
                }

                if (relativePosition >= 0) {
                    relativePosition++;
                }
                final TreeList.AVLNode<E> ret = balance();
                recalcHeight();
                return ret;
            }

            private TreeList.AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {
                if (getRightSubTree() == null) {
                    setRight(new TreeList.AVLNode<>(+1, obj, right, this), null);
                } else {
                    setRight(right.insert(indexRelativeToMe, obj), null);
                }
                if (relativePosition < 0) {
                    relativePosition--;
                }
                final TreeList.AVLNode<E> ret = balance();
                recalcHeight();
                return ret;
            }

            private TreeList.AVLNode<E> getLeftSubTree() {
                return leftIsPrevious ? null : left;
            }

            private TreeList.AVLNode<E> getRightSubTree() {
                return rightIsNext ? null : right;
            }

            private TreeList.AVLNode<E> max() {
                return getRightSubTree() == null ? this : right.max();
            }

            private TreeList.AVLNode<E> min() {
                return getLeftSubTree() == null ? this : left.min();
            }

            TreeList.AVLNode<E> remove(final int index) {
                final int indexRelativeToMe = index - relativePosition;

                if (indexRelativeToMe == 0) {
                    return removeSelf();
                }
                if (indexRelativeToMe > 0) {
                    setRight(right.remove(indexRelativeToMe), right.right);
                    if (relativePosition < 0) {
                        relativePosition++;
                    }
                } else {
                    setLeft(left.remove(indexRelativeToMe), left.left);
                    if (relativePosition > 0) {
                        relativePosition--;
                    }
                }
                recalcHeight();
                return balance();
            }

            private TreeList.AVLNode<E> removeMax() {
                if (getRightSubTree() == null) {
                    return removeSelf();
                }
                setRight(right.removeMax(), right.right);
                if (relativePosition < 0) {
                    relativePosition++;
                }
                recalcHeight();
                return balance();
            }

            private TreeList.AVLNode<E> removeMin() {
                if (getLeftSubTree() == null) {
                    return removeSelf();
                }
                setLeft(left.removeMin(), left.left);
                if (relativePosition > 0) {
                    relativePosition--;
                }
                recalcHeight();
                return balance();
            }

            private TreeList.AVLNode<E> removeSelf() {
                if (getRightSubTree() == null && getLeftSubTree() == null) {
                    return null;
                }
                if (getRightSubTree() == null) {
                    if (relativePosition > 0) {
                        left.relativePosition += relativePosition;
                    }
                    left.max().setRight(null, right);
                    return left;
                }
                if (getLeftSubTree() == null) {
                    right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);
                    right.min().setLeft(null, left);
                    return right;
                }

                if (heightRightMinusLeft() > 0) {
                    // more on the right, so delete from the right
                    final TreeList.AVLNode<E> rightMin = right.min();
                    value = rightMin.value;
                    if (leftIsPrevious) {
                        left = rightMin.left;
                    }
                    right = right.removeMin();
                    if (relativePosition < 0) {
                        relativePosition++;
                    }
                } else {
                    // more on the left or equal, so delete from the left
                    final TreeList.AVLNode<E> leftMax = left.max();
                    value = leftMax.value;
                    if (rightIsNext) {
                        right = leftMax.right;
                    }
                    final TreeList.AVLNode<E> leftPrevious = left.left;
                    left = left.removeMax();
                    if (left == null) {
                        // special case where left that was deleted was a double link
                        // only occurs when height difference is equal
                        left = leftPrevious;
                        leftIsPrevious = true;
                    }
                    if (relativePosition > 0) {
                        relativePosition--;
                    }
                }
                recalcHeight();
                return this;
            }

            private TreeList.AVLNode<E> balance() {
                switch (heightRightMinusLeft()) {
                    case 1:
                    case 0:
                    case -1:
                        return this;
                    case -2:
                        if (left.heightRightMinusLeft() > 0) {
                            setLeft(left.rotateLeft(), null);
                        }
                        return rotateRight();
                    case 2:
                        if (right.heightRightMinusLeft() < 0) {
                            setRight(right.rotateRight(), null);
                        }
                        return rotateLeft();
                    default:
                        throw new RuntimeException(""tree inconsistent!"");
                }
            }

            private int getOffset(final TreeList.AVLNode<E> node) {
                if (node == null) {
                    return 0;
                }
                return node.relativePosition;
            }

            private int setOffset(final TreeList.AVLNode<E> node, final int newOffest) {
                if (node == null) {
                    return 0;
                }
                final int oldOffset = getOffset(node);
                node.relativePosition = newOffest;
                return oldOffset;
            }

            private void recalcHeight() {
                height = Math.max(
                        getLeftSubTree() == null ? -1 : getLeftSubTree().height,
                        getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;
            }

            private int getHeight(final TreeList.AVLNode<E> node) {
                return node == null ? -1 : node.height;
            }

            private int heightRightMinusLeft() {
                return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());
            }

            private TreeList.AVLNode<E> rotateLeft() {
                final TreeList.AVLNode<E> newTop = right; // can't be faedelung!
                final TreeList.AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();

                final int newTopPosition = relativePosition + getOffset(newTop);
                final int myNewPosition = -newTop.relativePosition;
                final int movedPosition = getOffset(newTop) + getOffset(movedNode);

                setRight(movedNode, newTop);
                newTop.setLeft(this, null);

                setOffset(newTop, newTopPosition);
                setOffset(this, myNewPosition);
                setOffset(movedNode, movedPosition);
                return newTop;
            }

            private TreeList.AVLNode<E> rotateRight() {
                final TreeList.AVLNode<E> newTop = left;
                final TreeList.AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();

                final int newTopPosition = relativePosition + getOffset(newTop);
                final int myNewPosition = -newTop.relativePosition;
                final int movedPosition = getOffset(newTop) + getOffset(movedNode);

                setLeft(movedNode, newTop);
                newTop.setRight(this, null);

                setOffset(newTop, newTopPosition);
                setOffset(this, myNewPosition);
                setOffset(movedNode, movedPosition);
                return newTop;
            }

            private void setLeft(final TreeList.AVLNode<E> node, final TreeList.AVLNode<E> previous) {
                leftIsPrevious = node == null;
                left = leftIsPrevious ? previous : node;
                recalcHeight();
            }

            private void setRight(final TreeList.AVLNode<E> node, final TreeList.AVLNode<E> next) {
                rightIsNext = node == null;
                right = rightIsNext ? next : node;
                recalcHeight();
            }

            private TreeList.AVLNode<E> addAll(TreeList.AVLNode<E> otherTree, final int currentSize) {
                final TreeList.AVLNode<E> maxNode = max();
                final TreeList.AVLNode<E> otherTreeMin = otherTree.min();

                // We need to efficiently merge the two AVL trees while keeping them
                // balanced (or nearly balanced). To do this, we take the shorter
                // tree and combine it with a similar-height subtree of the taller
                // tree. There are two symmetric cases:
                //   * this tree is taller, or
                //   * otherTree is taller.
                if (otherTree.height > height) {
                    // CASE 1: The other tree is taller than this one. We will thus
                    // merge this tree into otherTree.

                    // STEP 1: Remove the maximum element from this tree.
                    final TreeList.AVLNode<E> leftSubTree = removeMax();

                    // STEP 2: Navigate left from the root of otherTree until we
                    // contains a subtree, s, that is no taller than me. (While we are
                    // navigating left, we store the nodes we encounter in a stack
                    // so that we can re-balance them in step 4.)
                    final Deque<TreeList.AVLNode<E>> sAncestors = new ArrayDeque<>();
                    TreeList.AVLNode<E> s = otherTree;
                    int sAbsolutePosition = s.relativePosition + currentSize;
                    int sParentAbsolutePosition = 0;
                    while (s != null && s.height > getHeight(leftSubTree)) {
                        sParentAbsolutePosition = sAbsolutePosition;
                        sAncestors.push(s);
                        s = s.left;
                        if (s != null) {
                            sAbsolutePosition += s.relativePosition;
                        }
                    }

                    // STEP 3: Replace s with a newly constructed subtree whose root
                    // is maxNode, whose left subtree is leftSubTree, and whose right
                    // subtree is s.
                    maxNode.setLeft(leftSubTree, null);
                    maxNode.setRight(s, otherTreeMin);
                    if (leftSubTree != null) {
                        leftSubTree.max().setRight(null, maxNode);
                        leftSubTree.relativePosition -= currentSize - 1;
                    }
                    if (s != null) {
                        s.min().setLeft(null, maxNode);
                        s.relativePosition = sAbsolutePosition - currentSize + 1;
                    }
                    maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;
                    otherTree.relativePosition += currentSize;

                    // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.
                    s = maxNode;
                    while (!sAncestors.isEmpty()) {
                        final TreeList.AVLNode<E> sAncestor = sAncestors.pop();
                        sAncestor.setLeft(s, null);
                        s = sAncestor.balance();
                    }
                    return s;
                }
                otherTree = otherTree.removeMin();

                final Deque<TreeList.AVLNode<E>> sAncestors = new ArrayDeque<>();
                TreeList.AVLNode<E> s = this;
                int sAbsolutePosition = s.relativePosition;
                int sParentAbsolutePosition = 0;
                while (s != null && s.height > getHeight(otherTree)) {
                    sParentAbsolutePosition = sAbsolutePosition;
                    sAncestors.push(s);
                    s = s.right;
                    if (s != null) {
                        sAbsolutePosition += s.relativePosition;
                    }
                }

                otherTreeMin.setRight(otherTree, null);
                otherTreeMin.setLeft(s, maxNode);
                if (otherTree != null) {
                    otherTree.min().setLeft(null, otherTreeMin);
                    otherTree.relativePosition++;
                }
                if (s != null) {
                    s.max().setRight(null, otherTreeMin);
                    s.relativePosition = sAbsolutePosition - currentSize;
                }
                otherTreeMin.relativePosition = currentSize - sParentAbsolutePosition;

                s = otherTreeMin;
                while (!sAncestors.isEmpty()) {
                    final TreeList.AVLNode<E> sAncestor = sAncestors.pop();
                    sAncestor.setRight(s, null);
                    s = sAncestor.balance();
                }
                return s;
            }

        }

        static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> {
            private final TreeList<E> parent;
            private TreeList.AVLNode<E> next;
            private int nextIndex;
            private TreeList.AVLNode<E> current;
            private int currentIndex;
            private int expectedModCount;

            private TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException {
                super();
                this.parent = parent;
                this.expectedModCount = parent.modCount;
                this.next = parent.root == null ? null : parent.root.get(fromIndex);
                this.nextIndex = fromIndex;
                this.currentIndex = -1;
            }

            private void checkModCount() {
                if (parent.modCount != expectedModCount) {
                    throw new ConcurrentModificationException();
                }
            }

            public boolean hasNext() {
                return nextIndex < parent.size();
            }

            public E next() {
                checkModCount();
                if (!hasNext()) {
                    throw new NoSuchElementException(""No element at index "" + nextIndex + ""."");
                }
                if (next == null) {
                    next = parent.root.get(nextIndex);
                }
                final E value = next.getValue();
                current = next;
                currentIndex = nextIndex++;
                next = next.next();
                return value;
            }

            public boolean hasPrevious() {
                return nextIndex > 0;
            }

            public E previous() {
                checkModCount();
                if (!hasPrevious()) {
                    throw new NoSuchElementException(""Already at start of list."");
                }
                if (next == null) {
                    next = parent.root.get(nextIndex - 1);
                } else {
                    next = next.previous();
                }
                final E value = next.getValue();
                current = next;
                currentIndex = --nextIndex;
                return value;
            }

            public int nextIndex() {
                return nextIndex;
            }

            public int previousIndex() {
                return nextIndex() - 1;
            }

            public void remove() {
                checkModCount();
                if (currentIndex == -1) {
                    throw new IllegalStateException();
                }
                parent.remove(currentIndex);
                if (nextIndex != currentIndex) {
                    // remove() following next()
                    nextIndex--;
                }
                // the AVL node referenced by next may have become stale after a remove
                // reset it now: will be retrieved by next call to next()/previous() via nextIndex
                next = null;
                current = null;
                currentIndex = -1;
                expectedModCount++;
            }

            public void set(final E obj) {
                checkModCount();
                if (current == null) {
                    throw new IllegalStateException();
                }
                current.setValue(obj);
            }

            public void add(final E obj) {
                checkModCount();
                parent.add(nextIndex, obj);
                current = null;
                currentIndex = -1;
                nextIndex++;
                expectedModCount++;
            }

        }

    }

    static class InputReader extends InputStream {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private static boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",CorCod,662,662,nlogn
"
// Java program to count the number of 
// indexes in range L R such that 
// Ai = Ai+1 
class
GFG { 


// function that answers every query 

// in O(r-l) 

static
int
answer_query(
int
a[], 
int
n, 

int
l, 
int
r) 

{ 


// traverse from l to r and count 

// the required indexes 

int
count = 
0
; 

for
(
int
i = l; i < r; i++) 

if
(a[i] == a[i + 
1
]) 

count += 
1
; 


return
count; 

} 


// Driver Code 

public
static
void
main(String[] args) 

{ 

int
a[] = {
1
, 
2
, 
2
, 
2
, 
3
, 
3
, 
4
, 
4
, 
4
}; 

int
n = a.length; 


// 1-st query 

int
L, R; 

L = 
1
; 

R = 
8
; 


System.out.println( 

answer_query(a, n, L, R)); 


// 2nd query 

L = 
0
; 

R = 
4
; 

System.out.println( 

answer_query(a, n, L, R)); 

} 
} 

// This code is contribute by 
// Smitha Dinesh Semwal ",CorCod,74,74,linear
"import java.io.*;

public class VJudgeProblem2{
    public static void main(String[] args) throws IOException{

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int x = Integer.parseInt(reader.readLine());

        if (x == 1)
            System.out.println(-1);
        else
            System.out.println(x + "" "" + x);    
    }
        
}",CorCod,874,874,constant
"
// Java code to find maximum triplet sum 
import
java.io.*; 
import
java.util.*; 


class
GFG { 


// This function assumes that there 

// are at least three elements in arr[]. 

static
int
maxTripletSum(
int
arr[], 
int
n) 

{ 

// Initialize Maximum, second maximum and third 

// maximum element 

int
maxA = -
100000000
, maxB = -
100000000
; 

int
maxC = -
100000000
; 


for
(
int
i = 
0
; i < n; i++) { 


// Update Maximum, second maximum 

// and third maximum element 

if
(arr[i] > maxA) 

{ 

maxC = maxB; 

maxB = maxA; 

maxA = arr[i]; 

} 


// Update second maximum and third maximum 

// element 

else
if
(arr[i] > maxB) 

{ 

maxC = maxB; 

maxB = arr[i]; 

} 


// Update third maximum element 

else
if
(arr[i] > maxC) 

maxC = arr[i]; 

} 


return
(maxA + maxB + maxC); 

} 


// Driven code 

public
static
void
main(String args[]) 

{ 

int
arr[] = { 
1
, 
0
, 
8
, 
6
, 
4
, 
2
}; 

int
n = arr.length; 

System.out.println(maxTripletSum(arr, n)); 

} 
} 


// This code is contributed by Nikita Tiwari. ",CorCod,24,24,linear
"
import java.io.PrintWriter;

import java.util.*;
import java.util.Arrays ; 
import java .lang.String.* ;
import java .lang.StringBuilder ;


public class Test{
    static int pos = 0 ; 
    static int  arr[] ; 
  static LinkedList l1 = new  LinkedList() ; 
static void find(int p ,char[]x,int put[],String s){
    int c= 0 ; 
    for (int i = 0; i < s.length(); i++) {
        if(x[p]==s.charAt(i)){
        c++ ; }
    }
    put[p] = c ;  
}
static int mode(int m ,int[]x ){
    int temp = 0 ; 
    for (int i = x.length-1; i >=0; i--) {
        if(x[i]<=m){
            temp= x[i] ; 
           /// break ; 
             return m-temp ; 
             
        }
    }
     return m-temp ; 
}
static int mode2(int m ,int[]x ){
    int temp = 0 ; 
    
    for (int i = x.length-1; i >=0; i--) {
        if(x[i]<=m){
            temp= x[i] ; 
           /// break ; 
             return x[i] ; 
             
        }
    }
     return 0 ; 
}
static int find(int x[],int temp){
    int j = 0 ; 
    for (int i = x.length-1; i >=0; i--) {
        if(x[i]==temp) return j+1 ; 
        j++ ; 
    }
    return -1 ; 
}
static String ch(long[]x,long b){
    for (int i = 0; i < x.length; i++) {
        if(x[i]==b)return ""YES"" ;
    }
    return ""NO"" ; 
}

    public static void main(String[] args)  {

        Scanner in = new Scanner(System.in) ;
        PrintWriter pw = new PrintWriter(System.out);   
        long n = in.nextLong() ; 
        long count =1 ; 
        long temp =n/2;
     temp+=count ;
      
       
        System.out.println(temp);
 }               
}

",CorCod,873,873,constant
"import java.io.*;
import java.util.*;
import java.text.*;
import java.lang.*;
import java.math.*;
 
public class Main{
	
	static ArrayList a[]=new ArrayList[200001];
	static int Count(int a[][],int n) {
		dsu d=new dsu(n);
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
				if(a[i][j]==0) {
					d.union(i, j);
				}
			}
		}
		int cnt=0;
		boolean chk[]=new boolean [n];
		for(int i=0;i<n;i++) {
			int p=d.root(i);
			if(!chk[p]) {
				chk[p]=true;
				cnt++;
			}
		}
	    return cnt;
	}
	public void solve () {
		InputReader in = new InputReader(System.in);
	    PrintWriter pw = new PrintWriter(System.out); 
	    int n=in.nextInt();
	    int a=in.nextInt();
	    int b=in.nextInt();
	    if(a==1 || b==1) {
	    	int ans[][]=new int [n][n];
	    	int temp=(a==1)?b:a;
	    	for(int i=1;i<=n-temp;i++) {
	    		ans[i][i-1]=1;
	    		ans[i-1][i]=1;
	    	}
	    	int freq=Count(ans,n);
	    	if(freq!=1) {
	    		pw.println(""NO"");
	    	}
	    	else {
	    		pw.println(""YES"");
	    		for(int i=0;i<n;i++) {
	    			for(int j=0;j<n;j++) {
	    				if(i==j) {
	    					pw.print(0);
	    				}
	    				else
	    					pw.print((ans[i][j]+((temp==b)?1:0))%2);
	    			}
	    			pw.println();
	    		}
	    	}
	    }
	    else {
	    	pw.print(""NO"");
	    }
		pw.flush();
		pw.close();
	}
	public static void main(String[] args) throws Exception {
        
        
        new Thread(null,new Runnable() {
        	public void run() {
        		new Main().solve();
        	}
        },""1"",1<<26).start();
        
        
    }
    static void debug(Object... o) {
    	System.out.println(Arrays.deepToString(o));
        }
        
        static class InputReader 
        {
        private final InputStream stream;
        private final byte[] buf = new byte[8192];
        private int curChar, snumChars;
        private SpaceCharFilter filter;
 
        public InputReader(InputStream stream) 
        {
            this.stream = stream;
        }
        public int snext() 
        {
            if (snumChars == -1)
                throw new InputMismatchException();
            if (curChar >= snumChars) 
            {
                curChar = 0;
                try 
                {
                    snumChars = stream.read(buf);
                } 
                catch (IOException e) 
                {
                    throw new InputMismatchException();
                }
                if (snumChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }
 
        public int nextInt() 
        {
            int c = snext();
            while (isSpaceChar(c)) 
            {
                c = snext();
            }
            int sgn = 1;
            if (c == '-')
            {
                sgn = -1;
                c = snext();
            }
            int res = 0;
            do 
            {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = snext();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
 
        public long nextLong()
        {
            int c = snext();
            while (isSpaceChar(c)) 
            {
                c = snext();
            }
            int sgn = 1;
            if (c == '-') 
            {
                sgn = -1;
                c = snext();
            }
            long res = 0;
            do 
            {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = snext();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
 
        public int[] nextIntArray(int n) 
        {
            int a[] = new int[n];
            for (int i = 0; i < n; i++) 
            {
                a[i] = nextInt();
            }
            return a;
        }
 
        public String readString()
        {
            int c = snext();
            while (isSpaceChar(c)) 
            {
                c = snext();
            }
            StringBuilder res = new StringBuilder();
            do 
            {
                res.appendCodePoint(c);
                c = snext();
            } while (!isSpaceChar(c));
            return res.toString();
        }
 
        public String nextLine() 
        {
            int c = snext();
            while (isSpaceChar(c))
                c = snext();
            StringBuilder res = new StringBuilder();
            do 
            {
                res.appendCodePoint(c);
                c = snext();
            } while (!isEndOfLine(c));
            return res.toString();
        }
 
        public boolean isSpaceChar(int c) 
        {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
 
        private boolean isEndOfLine(int c) 
        {
            return c == '\n' || c == '\r' || c == -1;
        }
 
        public interface SpaceCharFilter
        {
            public boolean isSpaceChar(int ch);
        }
    }
        public static long mod = 1000000007;
        public static int d;
        public static int p;
        public static int q;
        public void extended(int a,int b) {
        	if(b==0) {
        		d=a;
        		p=1;
        		q=0;
        	}
        	else
        	{
        		extended(b,a%b);
        		int temp=p;
        		p=q;
        		q=temp-(a/b)*q;
        	}
        }
        public static long[] shuffle(long[] a,Random gen)
        {
            int n = a.length;
            for(int i=0;i<n;i++)
            {
                int ind = gen.nextInt(n-i)+i;
                long temp = a[ind];
                a[ind] = a[i];
                a[i] = temp;
            }
            return a;
        }
        
        public static void swap(int a, int b){
            int temp = a;
            a = b;
            b = temp;
        }
        
        public static HashSet<Integer> primeFactorization(int n)
        {
            HashSet<Integer> a =new HashSet<Integer>();
            for(int i=2;i*i<=n;i++)
            {
                while(n%i==0)
                {
                    a.add(i);
                    n/=i;
                }
            }
            if(n!=1)
                a.add(n);
            return a;
        }
        
        public static void sieve(boolean[] isPrime,int n)
        {
            for(int i=1;i<n;i++)
                isPrime[i] = true;
            
            isPrime[0] = false;
            isPrime[1] = false;
            
            for(int i=2;i*i<n;i++)
            {
                if(isPrime[i] == true)
                {
                    for(int j=(2*i);j<n;j+=i)
                        isPrime[j] = false;
                }
            }
        }
        
        public static int GCD(int a,int b)
        {
            if(b==0)
                return a;
            else
                return GCD(b,a%b);
        }
        
        static class pair implements Comparable<pair>
        {
            Integer x;
            Long y;
            pair(int x,long y)
            {
                this.x=x;
                this.y=y;
                
            }
            
           
            public int compareTo(pair o) {
                int result = x.compareTo(o.x);
                if(result==0)
                    result = y.compareTo(o.y);
                
                return result;
            }  
            
            public String toString()
            {
                return x+"" ""+y;
            }
            
            public boolean equals(Object o)
            {
                if (o instanceof pair)
                {
                    pair p = (pair)o;
                    return p.x == x && p.y == y ;
                }
                return false;
            }
            
            public int hashCode()
            {
                return new Long(x).hashCode()*31 + new Long(y).hashCode();
            }
        }
        
    
}
class pair implements Comparable<pair>
{
    Integer x;
    Long y;
    pair(int x,long y)
    {
        this.x=x;
        this.y=y;
        
    }
    
   
    public int compareTo(pair o) {
        int result = x.compareTo(o.x);
        if(result==0)
            result = y.compareTo(o.y);
        
        return result;
    }  
    
    public String toString()
    {
        return x+"" ""+y;
    }
    
    public boolean equals(Object o)
    {
        if (o instanceof pair)
        {
            pair p = (pair)o;
            return p.x == x && p.y == y ;
        }
        return false;
    }
    
    public int hashCode()
    {
        return new Long(x).hashCode()*31 + new Long(y).hashCode();
    }
}
class dsu{
	int parent[];
	dsu(int n){
		parent=new int[n+1];
		for(int i=0;i<=n;i++)
		{
			parent[i]=i;
		}
	}
	int root(int n) {
		while(parent[n]!=n)
		{ 
			parent[n]=parent[parent[n]];
			n=parent[n];
		}
		return n;
	}
	void union(int _a,int _b) {
		int p_a=root(_a);
		int p_b=root(_b);
		
			parent[p_a]=p_b;
		
			
	}
	boolean find(int a,int b) {
		if(root(a)==root(b))
			return true;
		else
			return  false;
	}
	
	
}
",CorCod,515,515,quadratic
"
// Java program to print all words that have 
// the same unique character set 
import
java.util.ArrayList; 
import
java.util.Arrays; 
import
java.util.HashMap; 
import
java.util.Map.Entry; 
public
class
GFG { 


static
final
int
MAX_CHAR = 
26
; 


// Generates a key from given string. The key 

// contains all unique characters of given string 

// in sorted order consisting of only distinct elements. 

static
String getKey(String str) 

{ 

boolean
[] visited = 
new
boolean
[MAX_CHAR]; 

Arrays.fill(visited, 
false
); 


// store all unique characters of current 

// word in key 

for
(
int
j = 
0
; j < str.length(); j++) 

visited[str.charAt(j) - 
'a'
] = 
true
; 

String key = 
""""
; 

for
(
int
j=
0
; j < MAX_CHAR; j++) 

if
(visited[j]) 

key = key + (
char
)(
'a'
+j); 

return
key; 

} 


// Print all words together with same character sets. 

static
void
wordsWithSameCharSet(String words[], 
int
n) 

{ 

// Stores indexes of all words that have same 

// set of unique characters. 

//unordered_map <string, vector <int> > Hash; 

HashMap<String, ArrayList<Integer>> Hash = 
new
HashMap<>(); 


// Traverse all words 

for
(
int
i=
0
; i<n; i++) 

{ 

String key = getKey(words[i]); 


// if the key is already in the map 

// then get its corresponding value 

// and update the list and put it in the map 

if
(Hash.containsKey(key)) 

{ 

ArrayList<Integer> get_al = Hash.get(key); 

get_al.add(i); 

Hash.put(key, get_al); 

} 


// if key is not present in the map 

// then create a new list and add 

// both key and the list 

else

{ 

ArrayList<Integer> new_al = 
new
ArrayList<>(); 

new_al.add(i); 

Hash.put(key, new_al); 

} 

} 


// print all words that have the same unique character set 

for
(Entry<String, ArrayList<Integer>> it : Hash.entrySet()) 

{ 

ArrayList<Integer> get =it.getValue(); 

for
(Integer v:get) 

System.out.print( words[v] + 
"", ""
); 

System.out.println(); 

} 

} 


// Driver program to test above function 

public
static
void
main(String args[]) 

{ 

String words[] = { 
""may""
, 
""student""
, 
""students""
, 
""dog""
, 

""studentssess""
, 
""god""
, 
""cat""
, 
""act""
, 
""tab""
, 

""bat""
, 
""flow""
, 
""wolf""
, 
""lambs""
, 
""amy""
, 
""yam""
, 

""balms""
, 
""looped""
, 
""poodle""
}; 

int
n = words.length; 

wordsWithSameCharSet(words, n); 

} 
} 
// This code is contributed by Sumit Ghosh ",CorCod,400,400,quadratic
"import java.io.*;
public class coins
{
 public static void main(String args[])throws IOException
 {
  InputStreamReader read=new InputStreamReader(System.in);
  BufferedReader in=new BufferedReader(read);
  int i,k,n,v;
  String a;
  a=in.readLine();
  for(i=0;i<a.length();i++)
  {
   if(a.charAt(i)==' ')
   break;
  }
  n=Integer.parseInt(a.substring(0,i));
  v=Integer.parseInt(a.substring(i+1));
  k=v%n;
  v=v/n;
  if(k>0)
  v++;
  System.out.println(v);
 }
}
",CorCod,759,759,constant
"import java.io.*;
import java.util.*;

public class Solution {

	static boolean canWinFromOneMove(char []s,int k) {
		int prefix=0;
		int n=s.length;
		for(int i=0;i<n && s[i]==s[0];i++)
			prefix++;
		int suffix=0;
		for(int i=n-1;i>=0 && s[i]==s[n-1];i--)
			suffix++;
		
		return s[0]==s[n-1] && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;
			
	}
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner();
		PrintWriter out = new PrintWriter(System.out);
		int n=sc.nextInt(),k=sc.nextInt();
		char []s=sc.next().toCharArray();
		if(canWinFromOneMove(s, k)) {
			System.out.println(""tokitsukaze"");
			return;
		}
		int []suff=new int [n+1];
		suff[n-1]=1;
		for(int i=n-2;i>=0;i--) {
			suff[i]=1+(s[i+1]==s[i]?suff[i+1]:0);
		}
		for(int i=n-2;i>=0;i--)
			suff[i]=Math.max(suff[i], suff[i+1]);
		int max=0,curr=0;
		boolean draw=false;
		int ones=0;
		for(int i=0;i+k<=n;i++) {
			
			// one
			int prefix=ones==i?k+ones:max;
			int suffix=i+k==n?k:s[i+k]=='1' && suff[i+k]==n-(i+k)?k+suff[i+k]:suff[i+k];
			char first=i==0?'1':s[0],last=i+k==n?'1':s[n-1];
			boolean zero=first==last && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;
			// zero
			 prefix=ones==0?k+ones:max;
			 suffix=i+k==n?k:s[i+k]=='0' && suff[i+k]==n-(i+k)?k+suff[i+k]:suff[i+k];
			 first=i==0?'0':s[0];
			 last=i+k==n?'0':s[n-1];
			boolean one=first==last && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;
			if(!zero || !one) {
//				System.err.println(i+1);
				draw=true;
			}
			if(s[i]=='1')
				ones++;
			if(i>0 && s[i]==s[i-1] )
				curr++;
			else
				curr=1;
			max=Math.max(max, curr);
		}
		out.println(draw?""once again"":""quailty"");
		out.close();

	}

	static class Scanner {
		BufferedReader br;
		StringTokenizer st;

		Scanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		Scanner(String fileName) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(fileName));
		}

		String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		String nextLine() throws IOException {
			return br.readLine();
		}

		int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		long nextLong() throws NumberFormatException, IOException {
			return Long.parseLong(next());
		}

		double nextDouble() throws NumberFormatException, IOException {
			return Double.parseDouble(next());
		}

		boolean ready() throws IOException {
			return br.ready();
		}

	}

}",CorCod,309,309,linear
"
// A dynamic programming based Java program for partition problem 
import
java.io.*; 

class
Partition { 


// Returns true if arr[] can be partitioned in two subsets of 

// equal sum, otherwise false 

static
boolean
findPartition (
int
arr[], 
int
n) 

{ 

int
sum = 
0
; 

int
i, j; 


// Caculcate sun of all elements 

for
(i = 
0
; i < n; i++) 

sum += arr[i]; 


if
(sum%
2
!= 
0
) 

return
false
; 


boolean
part[][]=
new
boolean
[sum/
2
+
1
][n+
1
]; 


// initialize top row as true 

for
(i = 
0
; i <= n; i++) 

part[
0
][i] = 
true
; 


// initialize leftmost column, except part[0][0], as 0 

for
(i = 
1
; i <= sum/
2
; i++) 

part[i][
0
] = 
false
; 


// Fill the partition table in botton up manner 

for
(i = 
1
; i <= sum/
2
; i++) 

{ 

for
(j = 
1
; j <= n; j++) 

{ 

part[i][j] = part[i][j-
1
]; 

if
(i >= arr[j-
1
]) 

part[i][j] = part[i][j] || 

part[i - arr[j-
1
]][j-
1
]; 

} 

} 


/* // uncomment this part to print table 

for (i = 0; i <= sum/2; i++) 

{ 

for (j = 0; j <= n; j++) 

printf (""%4d"", part[i][j]); 

printf(""\n""); 

} */


return
part[sum/
2
][n]; 

} 


/*Driver function to check for above function*/

public
static
void
main (String[] args) 

{ 

int
arr[] = {
3
, 
1
, 
1
, 
2
, 
2
,
1
}; 

int
n = arr.length; 

if
(findPartition(arr, n) == 
true
) 

System.out.println(
""Can be divided into two ""

""subsets of equal sum""
); 

else

System.out.println(
""Can not be divided into""

"" two subsets of equal sum""
); 


} 
} 
/* This code is contributed by Devesh Agrawal */",CorCod,326,326,linear
"import java.util.Scanner;

public class AlexAndARhombus {
	public static void main(String args[])
	{
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		System.out.println(n*n+(n-1)*(n-1));
		sc.close();
	}

}
",CorCod,777,777,constant
"import java.util.*;
import java.io.*;
import java.util.Map.Entry;

public class Codeforces {

    static int n;
    static double max;
    static int[] pre;

    public static void findIntensity(int l){
        for(int i = 0, j = i + l; j < n + 1; i++, j++){
            double res = (pre[j] - pre[i]) / (double) l;
            max = Math.max(max, res);
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int[] heat = new int[n];
        st = new StringTokenizer(br.readLine());
        for(int i = 0; i < n; i++){
            heat[i] = Integer.parseInt(st.nextToken());
        }
        max = 0;
        pre = new int[n + 1];
        pre[0] = 0;
        for(int i = 0; i < n; i++){
            pre[i + 1] = pre[i] + heat[i];
        }
        for(int i = k; i <= n; i++){
            findIntensity(i);
        }
        System.out.println(max);
    }
}",CorCod,420,420,quadratic
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class MicroWorld {

	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		int n = Integer.parseInt(st.nextToken());
		int k = Integer.parseInt(st.nextToken());
		
		int[] temp = new int[1000001];
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());
		
		for (int i = 0; i < n; i++){
			
			temp[Integer.parseInt(st1.nextToken())]++;
		}
		
		int b = k + 1;
		
		for (int i = 1000000; i > 0; i--){
			
			if (temp[i] > 0){
				if (b <= k){
					n -= temp[i];
				}
				b = 1;
			}else{
				b++;
			}
		}
		
		System.out.println(n);
		
	}

}
",CorCod,652,652,nlogn
"
// LM10: The next Ballon d'or
import java.util.*;
import java.io.*;
import java.math.*;
import javafx.util.Pair;
public class Main
{
    static class FastReader
    {
        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public FastReader() { this(System.in); }public FastReader(InputStream is) { mIs = is;}
        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];}
        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;}
        public String next(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();}
        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;}
        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;}
        public double d() throws IOException {return Double.parseDouble(next()) ;}
        public boolean isSpaceChar(int c) { return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; }
        public boolean isEndOfLine(int c) { return c == '\n' || c == '\r' || c == -1; }
        public void scanIntArr(int [] arr){ for(int li=0;li<arr.length;++li){ arr[li]=i();}}
        public void scanLongArr(long [] arr){for (int i=0;i<arr.length;++i){arr[i]=l();}}
        public void shuffle(int [] arr){ for(int i=arr.length;i>0;--i) { int r=(int)(Math.random()*i); int temp=arr[i-1]; arr[i-1]=arr[r]; arr[r]=temp; } }
    }
    public static void main(String[] args)throws IOException {
        /*
inputCopy
4
2 1 2 1
outputCopy
4
inputCopy
5
0 -1 -1 -1 -1
outputCopy
4
*/
        PrintWriter pw = new PrintWriter(System.out);
        FastReader fr = new FastReader();
        int n=fr.i();
        int [] arr=new int[n];
        fr.scanIntArr(arr);
        int min=Integer.MAX_VALUE;
        int max=Integer.MIN_VALUE;
        long sum=0;
        if(n==1)
        {
            pw.println(arr[0]);
            pw.flush();
            pw.close();
            return;
        }
        for(int i=0;i<n;++i)
        {
            if(arr[i]<min)
                min=arr[i];
            if(arr[i]>max)
                max=arr[i];
            sum+=Math.abs(arr[i]);
        }
        if(min>0)
        {
            sum-=2*min;
        }
        if(max<0)
        {
            sum+=2*max;
        }
        pw.println(sum);
        pw.flush();
        pw.close();
    }
}",CorCod,178,178,linear
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class CF_1029E_Tree_with_Small_Distances {
	static ArrayList<Integer> adj[];
	static int dist[];
	static boolean visitParent[];
	static int ans=0;
 public static void main(String[] args) throws IOException {
	Scanner sc = new Scanner(System.in);
	int n  =sc.nextInt();
	adj=new ArrayList[n+1];
	dist = new int[n+1];
	visitParent = new boolean[n+1];
	for(int i=0;i<=n;i++) adj[i]=new ArrayList<Integer>();
	int max=0;
	//first contribution
	for(int i=1;i<n;i++){
		int u = sc.nextInt(),v=sc.nextInt();
		adj[u].add(v);
		adj[v].add(u);
	}
	dist[1]=0;
	dfs(1,1);
 System.out.println(ans);
 
 
 }
private static void dfs(int i , int j) {
	// TODO Auto-generated method stub
	boolean f = false;
	for(int k=0;k<adj[i].size();k++){
		int x = adj[i].get(k);
		if(x!=j){
			dist[x]=dist[i]+1;
			dfs(x,i);
			if(visitParent[x])
				f=true;
		}
	}
	//System.out.println(Arrays.toString(dist));
	if(dist[i]>2&&!visitParent[j]&&!f&&!visitParent[i]){
		visitParent[j]=true;
		ans++;
		for(int v=0;v<adj[i].size();v++){
			
		}
	}
	
}
static class Scanner 
{
    StringTokenizer st;
    BufferedReader br;

    public Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}

    public String next() throws IOException 
    {
        while (st == null || !st.hasMoreTokens()) 
            st = new StringTokenizer(br.readLine());
        return st.nextToken();
    }
    
    public double nextDouble() throws IOException
    {
        String x = next();
        StringBuilder sb = new StringBuilder(""0"");
        double res = 0, f = 1;
        boolean dec = false, neg = false;
        int start = 0;
        if(x.charAt(0) == '-')
        {
            neg = true;
            start++;
        }
        for(int i = start; i < x.length(); i++)
            if(x.charAt(i) == '.')
            {
                res = Long.parseLong(sb.toString());
                sb = new StringBuilder(""0"");
                dec = true;
            }
            else
            {
                sb.append(x.charAt(i));
                if(dec)
                    f *= 10;
            }
        res += Long.parseLong(sb.toString()) / f;
        return res * (neg?-1:1);
    }


    public int nextInt() throws IOException {return Integer.parseInt(next());}

    public long nextLong() throws IOException {return Long.parseLong(next());}

    public String nextLine() throws IOException {return br.readLine();}

    public boolean ready() throws IOException {return br.ready(); }


}
	
}

",CorCod,228,228,linear
"import java.util.Scanner;

public class ChainReaction {
	
	public static void main(String [] args) {
		Scanner kb = new Scanner(System.in);
		int num = kb.nextInt();
		
		int[] beacons = new int[1000002];
		for (int i=0; i<num; i++) {
			beacons[kb.nextInt()] = kb.nextInt();
		}
		
		int [] dp = new int[1000002];
		int max = 0;
		if (beacons[0] != 0)
			dp[0] = 1;
		
		for (int i=1; i<dp.length; i++) {
			if (beacons[i] == 0) {
				dp[i] = dp[i-1];
			} else {
				int index = i-1-beacons[i];
				if (index<0)
					dp[i] = 1;
				else
					dp[i] = 1 + dp[index];
			}
			max = Math.max(max, dp[i]);
			//if (i<11)
				//System.out.println(i +"" is ""+dp[i]);
		}
		
		System.out.println(num-max);
	}

}
",CorCod,235,235,linear
"import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class A {
    static MyScanner sc;
    static PrintWriter pw;

    public static void main(String[] args) throws Throwable {
        sc = new MyScanner();
        pw = new PrintWriter(System.out);

        n = sc.nextInt();
        T = sc.nextLong();
        p = new int[n];
        l = new int[n];
        x = new int[n];
        t = new int[n];
        adj = new ArrayList[n];

        for (int i = 0; i < n; i++)
            x[i] = sc.nextInt();
        for (int i = 0; i < n; i++)
            t[i] = sc.nextInt();
        adj[0] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            adj[i] = new ArrayList<>();
            p[i] = sc.nextInt() - 1;
            l[i] = sc.nextInt();
            adj[p[i]].add(i);
        }

        ftCnt = new long[N];
        ftSum = new long[N];
        ans = new long[n];

        dfs(0);
        pw.println(ans[0]);

        pw.flush();
        pw.close();
    }

    static int n;
    static long T;
    static int[] p, l, x, t;
    static ArrayList<Integer>[] adj;

    static long[] ans;

    static void dfs(int u) {
        update(t[u], x[u], 1L * x[u] * t[u]);
        ans[u] = getMaxCnt();
        long[] vals = {-1, -1, -1};
        for (int v : adj[u]) {
            T -= 2 * l[v];
            dfs(v);
            vals[0] = ans[v];
            Arrays.sort(vals);
            T += 2 * l[v];
        }
        if (u != 0) {
            if (vals[1] != -1)
                ans[u] = Math.max(ans[u], vals[1]);
        } else {
            if (vals[2] != -1)
                ans[u] = Math.max(ans[u], vals[2]);
        }
        update(t[u], -x[u], -1L * x[u] * t[u]);
    }

    static int N = (int) 1e6 + 2;
    static long[] ftCnt, ftSum;

    static void update(int idx, long cnt, long val) {
        while (idx < N) {
            ftCnt[idx] += cnt;
            ftSum[idx] += val;
            idx += (idx & -idx);
        }
    }

    static long getSum(int idx) {
        long ret = 0;
        while (idx > 0) {
            ret += ftSum[idx];
            idx -= (idx & -idx);
        }
        return ret;
    }

    static long getCnt(int idx) {
        long ret = 0;
        while (idx > 0) {
            ret += ftCnt[idx];
            idx -= (idx & -idx);
        }
        return ret;
    }

    static long getMaxCnt() {
        int start = 1, end = N - 1, ans = N - 1;
        while (start <= end) {
            int mid = (start + end) / 2;
            if (getSum(mid) >= T) {
                ans = mid;
                end = mid - 1;
            } else
                start = mid + 1;
        }
        long remT = T - (ans > 1 ? getSum(ans - 1) : 0);
        long cnt = (ans > 1 ? getCnt(ans - 1) : 0);
        long cntOfVal = getCnt(ans) - cnt;
        cnt += Math.min(cntOfVal, remT / ans);
        return cnt;
    }


    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}",CorCod,687,687,nlogn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author sumit
 */
public class Main {
      public static void main(String[] args) {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            InputReader in = new InputReader(inputStream);
            OutputWriter out = new OutputWriter(outputStream);
            CChessboard solver = new CChessboard();
            solver.solve(1, in, out);
            out.close();
      }

      static class CChessboard {
            int[] nextPermutation(int[] array) {
                  int i = array.length - 1;
                  while (i > 0 && array[i - 1] >= array[i]) {
                        i--;
                  }

                  if (i <= 0) {
                        return null;
                  }

                  int j = array.length - 1;

                  while (array[j] <= array[i - 1]) {
                        j--;
                  }

                  int temp = array[i - 1];
                  array[i - 1] = array[j];
                  array[j] = temp;

                  j = array.length - 1;

                  while (i < j) {
                        temp = array[i];
                        array[i] = array[j];
                        array[j] = temp;
                        i++;
                        j--;
                  }

                  return array;
            }

            public void solve(int testNumber, InputReader in, OutputWriter out) {
                  int n = in.nextInt();
                  int arr[][][] = new int[4][n][n];
                  int sum[] = new int[4];

                  for (int k = 0; k < 4; k++) {
                        for (int i = 0; i < n; i++) {
                              String str = in.next();
                              for (int j = 0; j < n; j++) {
                                    arr[k][i][j] = (str.charAt(j) - '0');
                              }
                        }
                  }

                  for (int k = 0; k < 4; k++) {
                        for (int i = 0; i < n; i++) {
                              for (int j = 0; j < n; j++) {
                                    if ((i + j) % 2 == arr[k][i][j])
                                          sum[k]++;
                              }
                        }
                  }

                  int perm[] = new int[4];
                  for (int i = 0; i < 4; i++)
                        perm[i] = i;


                  int min = Integer.MAX_VALUE;
                  while (true) {
                        perm = nextPermutation(perm);

                        if (perm == null)
                              break;

                        int sm = 0;
                        for (int j = 0; j < 4; j++) {
                              if (j % 2 == 0) {
                                    sm += (sum[perm[j]]);
                              } else {
                                    sm += (n * n - sum[perm[j]]);
                              }
                        }
                        min = Math.min(min, sm);

                        sm = 0;
                        for (int j = 0; j < 4; j++) {
                              if (j % 2 == 0) {
                                    sm += (n * n - sum[perm[j]]);
                              } else {
                                    sm += (sum[perm[j]]);
                              }
                        }
                        min = Math.min(sm, min);


                  }
                  out.printLine(min);


            }

      }

      static class OutputWriter {
            private final PrintWriter writer;

            public OutputWriter(OutputStream outputStream) {
                  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
            }

            public OutputWriter(Writer writer) {
                  this.writer = new PrintWriter(writer);
            }

            public void close() {
                  writer.close();
            }

            public void printLine(int i) {
                  writer.println(i);
            }

      }

      static class InputReader {
            private InputStream stream;
            private byte[] buf = new byte[1024];
            private int curChar;
            private int numChars;

            public InputReader(InputStream stream) {
                  this.stream = stream;
            }

            public int read() {
                  if (numChars == -1)
                        throw new InputMismatchException();

                  if (curChar >= numChars) {
                        curChar = 0;
                        try {
                              numChars = stream.read(buf);
                        } catch (IOException e) {
                              throw new InputMismatchException();
                        }
                        if (numChars <= 0)
                              return -1;
                  }

                  return buf[curChar++];
            }

            public int nextInt() {
                  int c = read();

                  while (isSpaceChar(c))
                        c = read();

                  int sgn = 1;

                  if (c == '-') {
                        sgn = -1;
                        c = read();
                  }

                  int res = 0;

                  do {
                        if (c < '0' || c > '9')
                              throw new InputMismatchException();

                        res *= 10;
                        res += c & 15;

                        c = read();
                  } while (!isSpaceChar(c));

                  return res * sgn;
            }

            public String next() {
                  int c = read();

                  while (isSpaceChar(c))
                        c = read();

                  StringBuilder res = new StringBuilder();

                  do {
                        res.appendCodePoint(c);

                        c = read();
                  } while (!isSpaceChar(c));

                  return res.toString();
            }

            public boolean isSpaceChar(int c) {
                  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
            }

      }
}

",CorCod,473,473,quadratic
"
import java.util.*;
import java.io.*;
import java.math.*;
public class loser
{
    static class InputReader {
        public BufferedReader br;
        public StringTokenizer token;
        public InputReader(InputStream stream)
        {
            br=new BufferedReader(new InputStreamReader(stream),32768);
            token=null;
        }

        public String next()
        {
            while(token==null || !token.hasMoreTokens())
            {
                try
                {
                    token=new StringTokenizer(br.readLine());
                }
                catch(IOException e)
                {
                    throw new RuntimeException(e);
                }
            }
            return token.nextToken();
        }

        public int nextInt()
        {
            return Integer.parseInt(next());
        }

        public long nextLong()
        {
            return Long.parseLong(next());
        }
    }
    static class card{
        long a;
        int i;
        public card(long a,int i)
        {
            this.a=a;
            this.i=i;
        }
    }
    static class sort implements Comparator<pair>
    {
        public int compare(pair o1,pair o2)
        {
            if(o1.a!=o2.a)
                return (int)(o1.a-o2.a);
            else
                return (int)(o1.b-o2.b);
        }
    }
    static void shuffle(long a[])
    {
        List<Long> l=new ArrayList<>();
        for(int i=0;i<a.length;i++)
            l.add(a[i]);
        Collections.shuffle(l);
        for(int i=0;i<a.length;i++)
            a[i]=l.get(i);
    }

    /*static long gcd(long a,long b)
    {
    if(b==0)
    return a;
    else
    return gcd(b,a%b);
    }*/
    /*static boolean valid(int i,int j)
    {
    if(i<4 && i>=0 && j<4 && j>=0)
    return true;
    else
    return false;
    }*/
    static class pair{
        int a,b;
        public pair(int a,int b)
        {
            this.a=a;
            this.b=b;
        }
    }
    public  static void main(String[] args) 
    {
        InputReader sc=new InputReader(System.in);
        char c[]=sc.next().toCharArray();
        int l=c.length;
        int a[]=new int[3];
        for(int i=0;i<l;i++)
        {
            a[c[i]-'a']++;
           if(i>0 && c[i]<c[i-1])
           {
               System.out.println(""NO"");
               System.exit(0);
           }
        }
        if(a[0]>0 && a[1]>0 && (a[2]==a[1] || a[2]==a[0]))
        System.out.println(""YES"");
        else
        System.out.println(""NO"");
    }
}",CorCod,336,336,linear
"import java.util.*;

public class Main{
    public static void main(String [] args)
    {
        Scanner scan=new Scanner(System.in);
        int q=scan.nextInt();
        int i;
        for(i=1;i<=q;i++)
        {
            int a=scan.nextInt();
            int ans=a/7+1;
            System.out.println(ans);
        }
    }
}",CorCod,769,769,constant
"
// A java program for iterative postorder traversal using stack 

import
java.util.ArrayList; 
import
java.util.Stack; 

// A binary tree node 
class
Node 
{ 

int
data; 

Node left, right; 


Node(
int
item) 

{ 

data = item; 

left = right; 

} 
} 

class
BinaryTree 
{ 

Node root; 

ArrayList<Integer> list = 
new
ArrayList<Integer>(); 


// An iterative function to do postorder traversal 

// of a given binary tree 

ArrayList<Integer> postOrderIterative(Node node) 

{ 

Stack<Node> S = 
new
Stack<Node>(); 


// Check for empty tree 

if
(node == 
null
) 

return
list; 

S.push(node); 

Node prev = 
null
; 

while
(!S.isEmpty()) 

{ 

Node current = S.peek(); 


/* go down the tree in search of a leaf an if so process it 

and pop stack otherwise move down */

if
(prev == 
null
|| prev.left == current || 

prev.right == current) 

{ 

if
(current.left != 
null
) 

S.push(current.left); 

else
if
(current.right != 
null
) 

S.push(current.right); 

else

{ 

S.pop(); 

list.add(current.data); 

} 


/* go up the tree from left node, if the child is right 

push it onto stack otherwise process parent and pop 

stack */

} 

else
if
(current.left == prev) 

{ 

if
(current.right != 
null
) 

S.push(current.right); 

else

{ 

S.pop(); 

list.add(current.data); 

} 


/* go up the tree from right node and after coming back 

from right node process parent and pop stack */

} 

else
if
(current.right == prev) 

{ 

S.pop(); 

list.add(current.data); 

} 


prev = current; 

} 


return
list; 

} 


// Driver program to test above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 


// Let us create trees shown in above diagram 

tree.root = 
new
Node(
1
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
3
); 

tree.root.left.left = 
new
Node(
4
); 

tree.root.left.right = 
new
Node(
5
); 

tree.root.right.left = 
new
Node(
6
); 

tree.root.right.right = 
new
Node(
7
); 


ArrayList<Integer> mylist = tree.postOrderIterative(tree.root); 


System.out.println(
""Post order traversal of binary tree is :""
); 

System.out.println(mylist); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,149,149,linear
"// discussed with rainboy
import java.io.*;
import java.util.*;

public class CF915D {
	static ArrayList[] aa;
	static boolean[] visited, instack;
	static int[] stack;
	static int cnt, h_, i_, j_;
	static boolean dfs1(int i) {
		if (visited[i]) {
			if (instack[i]) {
				h_ = i;
				return true;
			}
			return false;
		}
		visited[i] = instack[i] = true;
		stack[cnt++] = i;
		ArrayList<Integer> adj = aa[i];
		for (int j : adj)
			if (dfs1(j))
				return true;
		instack[i] = false;
		cnt--;
		return false;
	}
	static boolean dfs2(int i) {
		if (visited[i])
			return instack[i];
		visited[i] = instack[i] = true;
		ArrayList<Integer> adj = aa[i];
		for (int j : adj)
			if (!(i == i_ && j == j_) && dfs2(j))
				return true;
		instack[i] = false;
		return false;
	}
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		aa = new ArrayList[n];
		for (int i = 0; i < n; i++)
			aa[i] = new ArrayList<Integer>();
		while (m-- > 0) {
			st = new StringTokenizer(br.readLine());
			int i = Integer.parseInt(st.nextToken()) - 1;
			int j = Integer.parseInt(st.nextToken()) - 1;
			aa[i].add(j);
		}
		visited = new boolean[n];
		instack = new boolean[n];
		stack = new int[n];
		for (int i = 0; i < n; i++)
			if (dfs1(i))
				break;
		if (cnt == 0) {
			System.out.println(""YES"");
			return;
		}
		for (j_ = h_, i_ = stack[--cnt]; ; j_ = i_, i_ = stack[--cnt]) {
			Arrays.fill(visited, false);
			Arrays.fill(instack, false);
			boolean cycle = false;
			for (int i = 0; i < n; i++)
				if (dfs2(i)) {
					cycle = true;
					break;
				}
			if (!cycle) {
				System.out.println(""YES"");
				return;
			}
			if (i_ == h_)
				break;
		}
		System.out.println(""NO"");
	}
}
",CorCod,392,392,quadratic
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.util.Map;
import java.util.HashMap;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        ReaderFastIO in = new ReaderFastIO(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        DConcatenatedMultiples solver = new DConcatenatedMultiples();
        solver.solve(1, in, out);
        out.close();
    }

    static class DConcatenatedMultiples {
        public void solve(int testNumber, ReaderFastIO in, PrintWriter out) {

            Map<Integer, Integer>[] mapMods = new HashMap[11];

            int n = in.nextInt();
            int k = in.nextInt();
            int[] a = in.readArrayInt(n);

            for (int i = 0; i < 11; i++) {
                mapMods[i] = new HashMap<>();
            }

            for (int i = 0; i < n; i++) {
                int pot = getPot(a[i]);
                mapMods[pot].put(a[i] % k, mapMods[pot].getOrDefault(a[i] % k, 0) + 1);
            }

            long ct = 0;

            for (int i = 0; i < n; i++) {

                int ownPot = getPot(a[i]);
                long suffix = a[i] * 10L;
                for (int j = 1; j <= 10; j++) {

                    int mod = (int) (suffix % k);
                    int comMod = (k - mod) % k;
                    int qt = mapMods[j].getOrDefault(comMod, 0);

                    if (j == ownPot && (a[i] % k) == comMod) {
                        qt--;
                    }

                    ct += qt;

                    suffix = (suffix * 10L) % k;
                }

            }

            out.println(ct);
        }

        public int getPot(int x) {

            int ct = 0;

            while (x != 0) {
                x /= 10;
                ct++;
            }

            return ct;
        }

    }

    static class ReaderFastIO {
        BufferedReader br;
        StringTokenizer st;

        public ReaderFastIO() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        public ReaderFastIO(InputStream input) {
            br = new BufferedReader(new InputStreamReader(input));
        }

        public String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public int[] readArrayInt(int n) {

            int[] array = new int[n];

            for (int i = 0; i < n; i++) {
                array[i] = nextInt();
            }

            return array;
        }

    }
}

",CorCod,647,647,nlogn
"import java.util.*;
import java.io.*;
import java.math.*;
public class Solution{
    public static void main(String[] args)throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] a = new int[n];
        for(int i=0;i<n;i++) a[i] = Integer.parseInt(st.nextToken());
        int ind = 0;
        for(int i=0;i<n;i++){
            if(a[i]==n){
                ind = i;
                break;
            }
        }
        boolean ok = true;
        for(int i=ind+1;i<n;i++) if(a[i]>a[i-1]) ok = false;
        for(int i=ind-1;i>=0;i--) if(a[i]>a[i+1]) ok = false;
        if(ok) System.out.println(""YES"");
        else System.out.println(""NO"");
        
    }
}

",CorCod,88,88,linear
"import java.util.*;
import java.io.*;
import java.math.*;
public class Solution{
    public static void main(String[] args)throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        long[] a = new long[n];
        for(int i=0;i<n;i++) a[i] = Long.parseLong(st.nextToken());
        Queue<Long> ts = new PriorityQueue<Long>();
        for(int i=1;i<n;i++) ts.add(a[i]-a[i-1]);
        long sum = 0;
        for(int i=0;i<n-k;i++){
            sum += ts.poll();
        }
        System.out.println(sum);
    }
}

",CorCod,731,731,nlogn
"import java.util.*;
import java.math.*;
import java.io.*;

public class programA {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int k = Integer.parseInt(st.nextToken());
		int t1 = (int)Math.ceil((double)n*2/k);
		int t2 = (int)Math.ceil((double)n*5/k);
		int t3 = (int)Math.ceil((double)n*8/k);
		System.out.println(t1+t2+t3);
	}
}",CorCod,840,840,constant
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class DeathNote {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		int n = nextInt();
		int m = nextInt();
		int[] a = intArray(n);
		
		StringBuffer sb = new StringBuffer();
		int x = 0;
		for (int i = 0; i < n; i++) {
			x += a[i];
			sb.append("" "" + (x/m));
			x %= m;
		}
		
		System.out.println(sb.toString().substring(1));
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",CorCod,304,304,linear
"
// Java program to find maximum product of 
// a subset. 

class
GFG { 


static
int
maxProductSubset(
int
a[], 
int
n) { 

if
(n == 
1
) { 

return
a[
0
]; 

} 


// Find count of negative numbers, count 

// of zeros, maximum valued negative number 

// and product of non-zero numbers 

int
max_neg = Integer.MIN_VALUE; 

int
count_neg = 
0
, count_zero = 
0
; 

int
prod = 
1
; 

for
(
int
i = 
0
; i < n; i++) { 


// If number is 0, we don't 

// multiply it with product. 

if
(a[i] == 
0
) { 

count_zero++; 

continue
; 

} 


// Count negatives and keep 

// track of maximum valued negative. 

if
(a[i] < 
0
) { 

count_neg++; 

max_neg = Math.max(max_neg, a[i]); 

} 


prod = prod * a[i]; 

} 


// If there are all zeros 

if
(count_zero == n) { 

return
0
; 

} 


// If there are odd number of 

// negative numbers 

if
(count_neg % 
2
== 
1
) { 


// Exceptional case: There is only 

// negative and all other are zeros 

if
(count_neg == 
1

&& count_zero > 
0

&& count_zero + count_neg == n) { 

return
0
; 

} 


// Otherwise result is product of 

// all non-zeros divided by maximum 

// valued negative. 

prod = prod / max_neg; 

} 


return
prod; 

} 

// Driver code 

public
static
void
main(String[] args) { 

int
a[] = {-
1
, -
1
, -
2
, 
4
, 
3
}; 

int
n = a.length; 

System.out.println(maxProductSubset(a, n)); 


} 
} 
/* This JAVA code is contributed by Rajput-Ji*/",CorCod,216,216,linear
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;
import java.util.TreeMap;

public class CodeForces {

	public static int difference(String s, String b, int n, int k) {
		int min = Integer.MAX_VALUE;
		int[] pre = new int[n];
		for (int i = 1; i < n; i++) {
			if (i == 1) {
				pre[i - 1] = (s.charAt(i-1) == b.charAt(i-1) ? 0 : 1);
			}
			pre[i] = pre[i - 1] + (s.charAt(i) == b.charAt(i) ? 0 : 1);
		}
		int v = -1;
		for (int i = k - 1; i < n; i++) {
			min = Math.min(min, pre[i] - (v == -1 ? 0 : pre[v]));
			v++;
		}
		return min;
	}

	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		int t = sc.nextInt();
		O: while (t-- > 0) {
			int n = sc.nextInt();
			int k = sc.nextInt();
			String s = sc.nextLine();
			int c = 1;
			StringBuilder R = new StringBuilder();
			StringBuilder G = new StringBuilder();
			StringBuilder B = new StringBuilder();

			for (int i = 0; i < n; i++) {
				if (c % 3 == 1) {
					R.append(""R"") ;
					G.append(""G"");
					B.append(""B"");
				} else if (c % 3 == 2) {
					R.append(""G"");
					G.append(""B"");
					B.append(""R"");
				} else {
					R.append(""B"");
					G.append(""R"");
					B.append(""G"");
				}
				c++;
			}
			String RR = R.toString(),BB = B.toString() , GG = G.toString();
			String[] arr = new String[] { RR, BB, GG };
			int i = 0;
			int j = k;
			int min = Integer.MAX_VALUE;
			while (i < 3) {
				min = Math.min(min, difference(s, arr[i], n, k));
				i++;
			}
			pw.println(min);
		}
		pw.close();
	}

	static class SegmentTree {
		static int[] S, in;
		static int N;

		public SegmentTree(int[] arr) {
			in = arr;
			N = in.length - 1;
			S = new int[N << 1];
			build(1, 1, N);
		}

		static int stat;

		void build(int node, int b, int e) {
			if (b == e) {
				S[node] = in[b];
				stat = 1;
			} else {
				int mid = (b + e) / 2;
				build(node << 1, b, mid);
				build(node << 1 | 1, mid + 1, e);
				if (stat == 1) {
					S[node] = S[node << 1] | S[node << 1 | 1];

				} else {
					S[node] = S[node << 1] ^ S[node << 1 | 1];
				}
				stat = 1 - stat;
			}
		}

		int update(int idx, int val) {
			idx += (N - 1);

			S[idx] = val;
			int stat = 1;
			while (idx > 1) {
				idx >>= 1;
				if (stat == 1) {
					S[idx] = S[idx << 1] | S[idx << 1 | 1];
					stat = 0;
				} else {
					S[idx] = S[idx << 1] ^ S[idx << 1 | 1];
					stat = 1;
				}
			}
			return S[1];
		}

	}

	public static class Pair implements Comparable<Pair> {
		int a, b;

		public Pair(int a, int b) {
			this.a = a;
			this.b = b;
		}

		public int compareTo(Pair A) {
			if (a != A.a)
				return A.a - a;
			return A.b - b;
		}

		public String toString() {
			return a + "" "" + b;
		}
	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public Scanner(FileReader r) {
			br = new BufferedReader(r);
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public double nextDouble() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder(""0"");
			double res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder(""0"");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

	}

}",CorCod,429,429,quadratic
"
// Java program to see if two trees are identical 

// A binary tree node 
class
Node 
{ 

int
data; 

Node left, right; 


Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root1, root2; 


/* Given two trees, return true if they are 

structurally identical */

boolean
identicalTrees(Node a, Node b) 

{ 

/*1. both empty */

if
(a == 
null
&& b == 
null
) 

return
true
; 


/* 2. both non-empty -> compare them */

if
(a != 
null
&& b != 
null
) 

return
(a.data == b.data 

&& identicalTrees(a.left, b.left) 

&& identicalTrees(a.right, b.right)); 


/* 3. one empty, one not -> false */

return
false
; 

} 


/* Driver program to test identicalTrees() function */

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 


tree.root1 = 
new
Node(
1
); 

tree.root1.left = 
new
Node(
2
); 

tree.root1.right = 
new
Node(
3
); 

tree.root1.left.left = 
new
Node(
4
); 

tree.root1.left.right = 
new
Node(
5
); 


tree.root2 = 
new
Node(
1
); 

tree.root2.left = 
new
Node(
2
); 

tree.root2.right = 
new
Node(
3
); 

tree.root2.left.left = 
new
Node(
4
); 

tree.root2.left.right = 
new
Node(
5
); 


if
(tree.identicalTrees(tree.root1, tree.root2)) 

System.out.println(
""Both trees are identical""
); 

else

System.out.println(
""Trees are not identical""
); 


} 
} ",CorCod,211,211,linear
"
// Java program to find the smallest number that can be 
// formed from given sum of digits and number of digits 

class
GFG 
{ 

// Function to print the smallest possible number with digit sum 's' 

// and 'm' number of digits 

static
void
findSmallest(
int
m, 
int
s) 

{ 

// If sum of digits is 0, then a number is possible 

// only if number of digits is 1 

if
(s == 
0
) 

{ 

System.out.print(m == 
1
? 
""Smallest number is 0""
: 
""Not possible""
); 


return
; 

} 


// Sum greater than the maximum possible sum 

if
(s > 
9
*m) 

{ 

System.out.println(
""Not possible""
); 

return
; 

} 


// Create an array to store digits of result 

int
[] res = 
new
int
[m]; 


// deduct sum by one to account for cases later 

// (There must be 1 left for the most significant 

// digit) 

s -= 
1
; 


// Fill last m-1 digits (from right to left) 

for
(
int
i=m-
1
; i>
0
; i--) 

{ 

// If sum is still greater than 9, 

// digit must be 9 

if
(s > 
9
) 

{ 

res[i] = 
9
; 

s -= 
9
; 

} 

else

{ 

res[i] = s; 

s = 
0
; 

} 

} 


// Whatever is left should be the most significant 

// digit 

res[
0
] = s + 
1
; 
// The initially subtracted 1 is 

// incorporated here 


System.out.print(
""Smallest number is ""
); 

for
(
int
i=
0
; i<m; i++) 

System.out.print(res[i]); 

} 


// driver program 

public
static
void
main (String[] args) 

{ 

int
s = 
9
, m = 
2
; 

findSmallest(m, s); 

} 
} 

// Contributed by Pramod Kumar ",CorCod,64,64,linear
"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Main
{
	public static void main (String[] args) throws java.lang.Exception
	{
		Scanner s = new Scanner(System.in);
		int n = Integer.parseInt(s.nextLine());
		int ans = Integer.MAX_VALUE;
		int arr[] = new int[n];
		for(int i=0;i<n;i++) {
			arr[i] = s.nextInt();
		}
		for (int i=1;i<n;i++) {
			ans = Math.min(ans, Math.min(arr[i],arr[0])/i);
		}
		for (int i=n-2;i>=0;i--){
			ans = Math.min(ans, Math.min(arr[n-1],arr[i])/(n-i-1));
		}
		System.out.println(ans);
	}
}",CorCod,253,253,linear
"    import java.util.*;
    import java.io.*;
    import java.lang.*;
    import java.math.*;
    public class B {
        public static void main(String[] args) throws Exception {
            BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
            PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
            int n = Integer.parseInt(bf.readLine());
            StringTokenizer st = new StringTokenizer(bf.readLine());
            Integer[] a = new Integer[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());
            Arrays.sort(a);
            int[] b = new int[n];
            for(int i=0; i<n; i++) b[i] = a[i].intValue();
            boolean diff = false;
            boolean diff2 = false;
            Set<Integer> vals = new HashSet<Integer>();
            vals.add(b[0]);
            int valval = 0;
            for(int i=1; i<n; i++) {
                vals.add(b[i]);
                if(b[i] == b[i-1]) {
                    if(!diff) {
                        diff = true;
                        valval = b[i];
                    }
                    else diff2 = true;
                }
            } 
            long sum = 0;
            for(int i : b) sum += i;
            sum -= 1L*n*(n-1)/2;

            if(diff && !diff2) {
                if(!vals.contains((valval-1)) && (valval > 0)) {
                    if(sum%2 == 0) out.println(""cslnb""); else out.println(""sjfnb"");
                }
                else out.println(""cslnb"");
            }
            else if(diff2) out.println(""cslnb"");
            else if(sum%2 == 0) out.println(""cslnb""); else out.println(""sjfnb"");
            // int n = Integer.parseInt(st.nextToken());
     
            
            out.close(); System.exit(0);
        }
    }",CorCod,7,7,linear
"
// Java program to find a triplet 
class
FindTriplet { 


// returns true if there is triplet with sum equal 

// to 'sum' present in A[]. Also, prints the triplet 

boolean
find3Numbers(
int
A[], 
int
arr_size, 
int
sum) 

{ 

int
l, r; 


/* Sort the elements */

quickSort(A, 
0
, arr_size - 
1
); 


/* Now fix the first element one by one and find the 

other two elements */

for
(
int
i = 
0
; i < arr_size - 
2
; i++) { 


// To find the other two elements, start two index variables 

// from two corners of the array and move them toward each 

// other 

l = i + 
1
; 
// index of the first element in the remaining elements 

r = arr_size - 
1
; 
// index of the last element 

while
(l < r) { 

if
(A[i] + A[l] + A[r] == sum) { 

System.out.print(
""Triplet is ""
+ A[i] + 
"", ""
+ A[l] + 
"", ""
+ A[r]); 

return
true
; 

} 

else
if
(A[i] + A[l] + A[r] < sum) 

l++; 


else
// A[i] + A[l] + A[r] > sum 

r--; 

} 

} 


// If we reach here, then no triplet was found 

return
false
; 

} 


int
partition(
int
A[], 
int
si, 
int
ei) 

{ 

int
x = A[ei]; 

int
i = (si - 
1
); 

int
j; 


for
(j = si; j <= ei - 
1
; j++) { 

if
(A[j] <= x) { 

i++; 

int
temp = A[i]; 

A[i] = A[j]; 

A[j] = temp; 

} 

} 

int
temp = A[i + 
1
]; 

A[i + 
1
] = A[ei]; 

A[ei] = temp; 

return
(i + 
1
); 

} 


/* Implementation of Quick Sort 

A[] --> Array to be sorted 

si --> Starting index 

ei --> Ending index 

*/

void
quickSort(
int
A[], 
int
si, 
int
ei) 

{ 

int
pi; 


/* Partitioning index */

if
(si < ei) { 

pi = partition(A, si, ei); 

quickSort(A, si, pi - 
1
); 

quickSort(A, pi + 
1
, ei); 

} 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

FindTriplet triplet = 
new
FindTriplet(); 

int
A[] = { 
1
, 
4
, 
45
, 
6
, 
10
, 
8
}; 

int
sum = 
22
; 

int
arr_size = A.length; 


triplet.find3Numbers(A, arr_size, sum); 

} 
} ",CorCod,391,391,quadratic
"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		int[] arr = new int [n];
		int maxindex=0;
		int minindex=0;
		int max;
		int min;
		for(int i=0;i<arr.length;i++) {
			arr[i]=sc.nextInt();
		}
		int k=Integer.MAX_VALUE;
		for(int i=0;i<arr.length;i++) {
			for(int j=i;j<arr.length;j++) {
				if(i!=j) {
					int k1=Math.min(arr[i], arr[j])/Math.abs(i-j);
					if(k1<k) {
						k = k1;
					}
				}
			}
		}
		System.out.println(k);
	}

}",CorCod,452,452,quadratic
"class findMedianTwoArrays
{
  public static double main(
    int[] arr1, int start1, int end1, int[] arr2, int start2, int end2) {
    if ( end1 - start1 == 1 && end2 - start2 == 1 ) {
        return ( Math.max(arr1[start1], arr2[start2]) + Math.min(arr1[end1], arr2[end2]) ) / 2;
    }    
  
  int median1Index = Math.floor((start1 + end1 ) / 2);
  int median2Index = Math.floor((start2 + end2 ) / 2);
  int median1 = arr1[median1Index];
  int median2 = arr2[median2Index];

  if ( median1 == median2 ) {
    return median1;
  }    

  if ( median1 < median2 ) {
    start1 = median1Index;
    if ( end2 - start2 > 1 ) { 
        end2 = median2Index;
    }        
  } else {
    start2 = median2Index;
    if ( end1 - start1 > 1 ) { 
        end1 = median1Index;
    }    
  }            

  return main(arr1, start1, end1, arr2, start2, end2);
  }
}

class test {
  public static void main(String[] args) {
    int[] A = { 1, 2, 3, 4, 4 };
    int[] B = { 6, 9, 10, 11, 15};
    findMedianTwoArrays findMedian = new findMedianTwoArrays();
    System.out.println(""Hello Java"");
    System.out.println(findMedian.main(A, 0, 4, B, 0, 4));
  }    
} ",CorCod,920,920,logn
"import javax.print.attribute.standard.RequestingUserName;
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws NumberFormatException, IOException
    {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        Task solver = new Task();
        int tc = in.nextInt();
        for(int i = 0; i < tc; i++)
            solver.solve(i, in, out);
        out.close();
    }

    static class Task {

        public void solve(int testNumber, InputReader in, PrintWriter out) {

            int k = in.nextInt();
            int[] s = getArray(in.nextToken());
            int[] a = getArray(in.nextToken());
            int[] b = getArray(in.nextToken());

            int[] per = new int[k];
            boolean[] used = new boolean[k];
            Arrays.fill(per , -1);

            if(!check(s , a, per.clone(), k, used)){
                out.println(""NO"");
                return;
            }

            for(int i = 0; i < s.length; i++){
                if(per[s[i]] != -1){
                    continue;
                }
                for(int j = 0; j < k; j++){
                    if(used[j]){
                        continue;
                    }
                    per[s[i]] = j;
                    used[j] = true;
                    if(check(s , a , per.clone() , k, used)){
                        break;
                    }
                    per[s[i]] = -1;
                    used[j] = false;
                }
            }

            for(int i = 0; i < s.length; i++){
                if(per[s[i]] == -1){
                    out.println(""NO"");
                    return;
                }
                s[i] = per[s[i]];
            }

            if(cmp(s , b) > 0){
                out.println(""NO"");
                return;
            }


            int last = 0;
            for(int i = 0; i < k; i++){
                if(per[i] == -1) {
                    while(used[last])last++;
                    per[i] = last;
                    used[last] = true;
                }
            }

            char[] result = new char[k];

            for(int i = 0; i < k; i++){
                result[i] = (char)('a' + per[i]);
            }
            out.println(""YES"");
            out.println(new String(result));
        }

        private int cmp(int[] a, int[] b){
            for(int i = 0; i < a.length; i++){
                if(a[i] != b[i]){
                    return a[i] < b[i] ? -1 : 1;
                }
            }
            return 0;
        }


        private boolean check(int[] s, int[] a, int[] per, int k, boolean[] used) {
            int res[] = new int[s.length];
            int last = k - 1;
            for(int i = 0; i < res.length; ++i){

                if(per[s[i]] == -1){

                    while(last >= 0 && used[last]){
                        last--;
                    }

                    if(last < 0){
                        return false;
                    }

                    per[s[i]] = last;
                    last--;
                }
                res[i] = per[s[i]];
            }
            return cmp(a , res) <= 0;
        }

        private int[] getArray(String nextToken) {
            int result[] = new int[nextToken.length()];
            for(int i = 0; i < nextToken.length(); i++){
                result[i] = nextToken.charAt(i) - 'a';
            }
            return result;
        }
    }

    static class InputReader {

        BufferedReader in;
        StringTokenizer tok;

        public InputReader(InputStream stream){
            in = new BufferedReader(new InputStreamReader(stream), 32768);
            tok = null;
        }

        String nextToken()
        {
            String line = """";
            while(tok == null || !tok.hasMoreTokens()) {
                try {
                    if((line = in.readLine()) != null)
                        tok = new StringTokenizer(line);
                    else
                        return null;
                } catch (IOException e) {
                    e.printStackTrace();
                    return null;
                }
            }
            return tok.nextToken();
        }
        int nextInt(){
            return Integer.parseInt(nextToken());
        }
        long nextLong()	{
            return Long.parseLong(nextToken());
        }
        double nextDouble()	{
            return Double.parseDouble(nextToken());
        }

    }

}",CorCod,534,534,quadratic
"
// A Simple Java program to find 
// minimum average subarray 

class
Test { 


static
int
arr[] = 
new
int
[] { 
3
, 
7
, 
90
, 
20
, 
10
, 
50
, 
40
}; 


// Prints beginning and ending indexes of subarray 

// of size k with minimum average 

static
void
findMinAvgSubarray(
int
n, 
int
k) 

{ 

// k must be smaller than or equal to n 

if
(n < k) 

return
; 


// Initialize beginning index of result 

int
res_index = 
0
; 


// Compute sum of first subarray of size k 

int
curr_sum = 
0
; 

for
(
int
i = 
0
; i < k; i++) 

curr_sum += arr[i]; 


// Initialize minimum sum as current sum 

int
min_sum = curr_sum; 


// Traverse from (k+1)'th element to n'th element 

for
(
int
i = k; i < n; i++) 

{ 

// Add current item and remove first 

// item of previous subarray 

curr_sum += arr[i] - arr[i - k]; 


// Update result if needed 

if
(curr_sum < min_sum) { 

min_sum = curr_sum; 

res_index = (i - k + 
1
); 

} 

} 


System.out.println(
""Subarray between [""
+ 

res_index + 
"", ""
+ (res_index + k - 
1
) + 

""] has minimum average""
); 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

int
k = 
3
; 
// Subarray size 

findMinAvgSubarray(arr.length, k); 

} 
} ",CorCod,245,245,linear
"
// Java program to check fixed point 
// in an array using linear search 

class
Main 
{ 

static
int
linearSearch(
int
arr[], 
int
n) 

{ 

int
i; 

for
(i = 
0
; i < n; i++) 

{ 

if
(arr[i] == i) 

return
i; 

} 


/* If no fixed point present 

then return -1 */

return
-
1
; 

} 

//main function 

public
static
void
main(String args[]) 

{ 

int
arr[] = {-
10
, -
1
, 
0
, 
3
, 
10
, 
11
, 
30
, 
50
, 
100
}; 

int
n = arr.length; 

System.out.println(
""Fixed Point is ""

+ linearSearch(arr, n)); 

} 
} ",CorCod,334,334,linear
"
// Java code for Dynamic Programming based 
// solution that uses table P[][] to 
// calculate the Permutation Coefficient 
import
java.io.*; 
import
java.math.*; 

class
GFG 
{ 


// Returns value of Permutation 

// Coefficient P(n, k) 

static
int
permutationCoeff(
int
n, 

int
k) 

{ 

int
P[][] = 
new
int
[n + 
2
][k + 
2
]; 


// Caculate value of Permutation 

// Coefficient in bottom up manner 

for
(
int
i = 
0
; i <= n; i++) 

{ 

for
(
int
j = 
0
; 

j <= Math.min(i, k); 

j++) 

{ 

// Base Cases 

if
(j == 
0
) 

P[i][j] = 
1
; 


// Calculate value using previosly 

// stored values 

else

P[i][j] = P[i - 
1
][j] + 

(j * P[i - 
1
][j - 
1
]); 


// This step is important 

// as P(i,j)=0 for j>i 

P[i][j + 
1
] = 
0
; 

} 

} 

return
P[n][k]; 

} 


// Driver Code 

public
static
void
main(String args[]) 

{ 

int
n = 
10
, k = 
2
; 

System.out.println(
""Value of P( ""
+ n + 
"",""
+ k +
"")""
+ 

"" is ""
+ permutationCoeff(n, k) ); 

} 
} 

// This code is contributed by Nikita Tiwari. ",CorCod,491,491,quadratic
"
// Java program to remove duplicates, the order of 
// characters is not maintained in this program 

public
class
GFG 
{ 

static
final
int
NO_OF_CHARS = 
256
; 


/* Returns an array of size 256 containg count 

of characters in the passed char array */

static
int
[] getCharCountArray(String str) 

{ 

int
count[] = 
new
int
[NO_OF_CHARS]; 

for
(
int
i = 
0
; i<str.length(); i++) 

count[str.charAt(i)]++; 


return
count; 

} 


/* removeDirtyChars takes two string as arguments: First 

string (str) is the one from where function removes dirty 

characters. Second string is the string which contain all 

dirty characters which need to be removed from first string */

static
String removeDirtyChars(String str, String mask_str) 

{ 

int
count[] = getCharCountArray(mask_str); 

int
ip_ind = 
0
, res_ind = 
0
; 


char
arr[] = str.toCharArray(); 


while
(ip_ind != arr.length) 

{ 

char
temp = arr[ip_ind]; 

if
(count[temp] == 
0
) 

{ 

arr[res_ind] = arr[ip_ind]; 

res_ind ++; 

} 

ip_ind++; 


} 


str = 
new
String(arr); 


/* After above step string is ngring. 

Removing extra ""iittg"" after string*/


return
str.substring(
0
, res_ind); 


} 


// Driver Method 

public
static
void
main(String[] args) 

{ 

String str = 
""geeksforgeeks""
; 

String mask_str = 
""mask""
; 

System.out.println(removeDirtyChars(str, mask_str)); 

} 
} ",CorCod,206,206,linear
"
// java program to find maximum 
// element 

class
Main 
{ 

// function to find the 

// maximum element 

static
int
findMaximum(
int
arr[], 
int
low, 
int
high) 

{ 

int
max = arr[low]; 

int
i; 

for
(i = low; i <= high; i++) 

{ 

if
(arr[i] > max) 

max = arr[i]; 

} 

return
max; 

} 


// main function 

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
30
, 
40
, 
50
, 
60
, 
70
, 
23
, 
20
}; 

int
n = arr.length; 

System.out.println(
""The maximum element is ""
+ 

findMaximum(arr, 
0
, n-
1
)); 

} 
} ",CorCod,217,217,linear
"
class
Main 
{ 

/* Function to get index of 

ceiling of x in arr[low..high]*/

static
int
ceilSearch(
int
arr[], 
int
low, 
int
high, 
int
x) 

{ 

int
mid; 


/* If x is smaller than or equal to the 

first element, then return the first element */

if
(x <= arr[low]) 

return
low; 


/* If x is greater than the last 

element, then return -1 */

if
(x > arr[high]) 

return
-
1
; 


/* get the index of middle element 

of arr[low..high]*/

mid = (low + high)/
2
; 
/* low + (high - low)/2 */


/* If x is same as middle element, 

then return mid */

if
(arr[mid] == x) 

return
mid; 


/* If x is greater than arr[mid], then 

either arr[mid + 1] is ceiling of x or 

ceiling lies in arr[mid+1...high] */

else
if
(arr[mid] < x) 

{ 

if
(mid + 
1
<= high && x <= arr[mid+
1
]) 

return
mid + 
1
; 

else

return
ceilSearch(arr, mid+
1
, high, x); 

} 


/* If x is smaller than arr[mid], 

then either arr[mid] is ceiling of x 

or ceiling lies in arr[mid-1...high] */

else

{ 

if
(mid - 
1
>= low && x > arr[mid-
1
]) 

return
mid; 

else

return
ceilSearch(arr, low, mid - 
1
, x); 

} 

} 



/* Driver program to check above functions */

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
2
, 
8
, 
10
, 
10
, 
12
, 
19
}; 

int
n = arr.length; 

int
x = 
8
; 

int
index = ceilSearch(arr, 
0
, n-
1
, x); 

if
(index == -
1
) 

System.out.println(
""Ceiling of ""
+x+
"" doesn't exist in array""
); 

else

System.out.println(
""ceiling of ""
+x+
"" is ""
+arr[index]); 

} 
} ",CorCod,921,921,logn
"//Author: Patel Rag
//Java version ""1.8.0_211""
import java.util.*;
import java.io.*;

public class Main
{
  static class FastReader
  {
    BufferedReader br;
    StringTokenizer st;

    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }

    String next()
    {
      while (st == null || !st.hasMoreElements())
      {
        try
        {
          st = new StringTokenizer(br.readLine());
        }
        catch (IOException  e)
        {
          e.printStackTrace();
        }
      }
      return st.nextToken();
    }

    int nextInt() { return Integer.parseInt(next()); }

    long nextLong(){ return Long.parseLong(next()); }

    double nextDouble(){ return Double.parseDouble(next()); }

    float nextFloat() { return Float.parseFloat(next()); }

    boolean nextBoolean() { return Boolean.parseBoolean(next()); }

    String nextLine()
    {
      String str = """";
      try
      {
        str = br.readLine();
      }
      catch (IOException e)
      {
        e.printStackTrace();
      }
      return str;
    }
  }
  static long modExp(long x, long n, long mod)    //binary Modular exponentiation
  {
    long result = 1;
    while(n > 0)
    {
        if(n % 2 == 1)
            result = (result%mod * x%mod)%mod;
        x = (x%mod * x%mod)%mod;
        n=n/2;
    }
    return result;
  }
  static long gcd(long a, long b)
  {
    if(a==0) return b;
    return gcd(b%a,a);
  }
  public static void main(String[] args)
  throws IOException
  {
    FastReader fr = new FastReader();
    System.out.println((int)(fr.nextInt()/2) + 1);

  }
}
class pair
{
  public int first;
  public int second;
  public pair(int first,int second)
  {
    this.first = first;
    this.second = second;
  }
  public int first() { return first; }
  public int second() { return second; }
  public void setFirst(int first) { this.first = first; }
  public void setSecond(int second) { this.second = second; }
}
class myComp implements Comparator<pair>
{
  public int compare(pair a,pair b)
  {
    return (a.first - b.first);
  }
}
class BIT       //Binary Indexed Tree aka Fenwick Tree
{
  public long[] m_array;

  public BIT(long[] dat)
  {
    m_array = new long[dat.length + 1];
    Arrays.fill(m_array,0);
    for(int i = 0; i < dat.length; i++)
    {
      m_array[i + 1] = dat[i];
    }
    for(int i = 1; i < m_array.length; i++)
    {
      int j = i + (i & -i);
      if(j < m_array.length)
      {
        m_array[j] = m_array[j] + m_array[i];
      }
    }
  }

  public final long prefix_query(int i)
  {
    long result = 0;
    for(++i; i > 0; i = i - (i & -i))
    {
      result = result + m_array[i];
    }
    return result;
  }

  public final long range_query(int fro, int to)
  {
    if(fro == 0)
    {
      return prefix_query(to);
    }
    else
    {
      return (prefix_query(to) - prefix_query(fro - 1));
    }
  }

  public void update(int i, long add)
  {
    for(++i; i < m_array.length; i = i + (i & -i))
    {
      m_array[i] = m_array[i] + add;
    }
  }
}
",CorCod,737,737,constant
"
// Java program for Binary Search 
import
java.util.*; 

class
Binary 
{ 

public
static
int
f(
int
x) 

{ 
return
(x*x - 
10
*x - 
20
); } 


// Returns the value x where above 

// function f() becomes positive 

// first time. 

public
static
int
findFirstPositive() 

{ 

// When first value itself is positive 

if
(f(
0
) > 
0
) 

return
0
; 


// Find 'high' for binary search 

// by repeated doubling 

int
i = 
1
; 

while
(f(i) <= 
0
) 

i = i * 
2
; 


// Call binary search 

return
binarySearch(i / 
2
, i); 

} 


// Searches first positive value of 

// f(i) where low <= i <= high 

public
static
int
binarySearch(
int
low, 
int
high) 

{ 

if
(high >= low) 

{ 

/* mid = (low + high)/2 */

int
mid = low + (high - low)/
2
; 


// If f(mid) is greater than 0 and 

// one of the following two 

// conditions is true: 

// a) mid is equal to low 

// b) f(mid-1) is negative 

if
(f(mid) > 
0
&& (mid == low || f(mid-
1
) <= 
0
)) 

return
mid; 


// If f(mid) is smaller than or equal to 0 

if
(f(mid) <= 
0
) 

return
binarySearch((mid + 
1
), high); 

else
// f(mid) > 0 

return
binarySearch(low, (mid -
1
)); 

} 


/* Return -1 if there is no positive 

value in given range */

return
-
1
; 

} 


// driver code 

public
static
void
main(String[] args) 

{ 

System.out.print (
""The value n where f() ""
+ 

""becomes positive first is ""
+ 

findFirstPositive()); 

} 
} 

// This code is contributed by rishabh_jain ",CorCod,900,900,logn
"
// JAVA Code for Find Second largest 
// element in an array 
class
GFG { 


/* Function to print the second largest 

elements */

public
static
void
print2largest(
int
arr[], 

int
arr_size) 

{ 

int
i, first, second; 


/* There should be atleast two elements */

if
(arr_size < 
2
) 

{ 

System.out.print(
"" Invalid Input ""
); 

return
; 

} 


first = second = Integer.MIN_VALUE; 

for
(i = 
0
; i < arr_size ; i++) 

{ 

/* If current element is smaller than 

first then update both first and second */

if
(arr[i] > first) 

{ 

second = first; 

first = arr[i]; 

} 


/* If arr[i] is in between first and 

second then update second */

else
if
(arr[i] > second && arr[i] != first) 

second = arr[i]; 

} 


if
(second == Integer.MIN_VALUE) 

System.out.print(
""There is no second largest""
+ 

"" element\n""
); 

else

System.out.print(
""The second largest element""
+ 

"" is ""
+ second); 

} 


/* Driver program to test above function */

public
static
void
main(String[] args) 

{ 

int
arr[] = {
12
, 
35
, 
1
, 
10
, 
34
, 
1
}; 

int
n = arr.length; 

print2largest(arr, n); 

} 
} 
// This code is contributed by Arnav Kr. Mandal. ",CorCod,58,58,linear
"import java.io.*;
import java.util.*;

public class Main{
    public static void main(String[] args){
        try {
            new Main().solve();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    ArrayList<Edge>[]edge;
    int n,m,cnt=0;
    int ord;
    int[]order;int[]vis;
    Edge[] e;
    private void solve() throws Exception{
        InputReader in = new InputReader(System.in);
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        n=in.nextInt();m=in.nextInt();
        edge=new ArrayList[n+1];
        e=new Edge[m];
        vis=new int[n+1];
        order=new int[n+1];
        for(int i=1;i<=n;i++){
            edge[i]=new ArrayList<>();
        }
        for(int i=1;i<=m;i++){
            int s=in.nextInt(),t=in.nextInt(),c=in.nextInt();
            edge[s].add(new Edge(s,t,c,i));
        }
        int l=0,r=1000000000;
        while (l<r){
            int mid=(l+r)>>>1;
            if(judge(mid,false))r=mid;
            else l=mid+1;
        }
        out.print(l+"" "");
        judge(l,true);
        Arrays.sort(e,0,cnt,Comparator.comparingInt(x->x.id));
        int ans=0;
        int[]a=new int[m];
        for(int i=0;i<cnt;i++){
            if(order[e[i].s]<order[e[i].t])a[ans++]=e[i].id;
        }
        out.println(ans);
        for(int i=0;i<ans;i++){
            out.print(a[i]+"" "");
        }
        out.println();
        out.flush();
    }
    boolean judge(int min,boolean mod){
        Arrays.fill(vis,0);
        cycle=false;
        for(int i=1;i<=n;i++){
            if(vis[i]==0){
                dfs(i,min,mod);
                if(cycle)return false;
            }
        }
        return true;
    }
    boolean cycle=false;
    void dfs(int cur,int min,boolean mod){
        if(cycle)return;
        vis[cur]=1;
        for(Edge e:edge[cur]){
            if(e.c<=min){
                if(mod)this.e[cnt++]=e;
                continue;
            }
            if(vis[e.t]==1){
                cycle=true;return;
            }
            else if(vis[e.t]==0)dfs(e.t,min,mod);
        }
        vis[cur]=2;
        if(mod)order[cur]=ord++;
    }
}
class Edge{
    int s,t,c,id;
    Edge(int a,int b,int c,int d){
        s=a;t=b;this.c=c;id=d;
    }
}
class InputReader{
    StreamTokenizer tokenizer;
    public InputReader(InputStream stream){
        tokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));
        tokenizer.ordinaryChars(33,126);
        tokenizer.wordChars(33,126);
    }
    public String next() throws IOException {
        tokenizer.nextToken();
        return tokenizer.sval;
    }
    public int nextInt() throws IOException {
        return Integer.parseInt(next());
    }
    public boolean hasNext() throws IOException {
        int res=tokenizer.nextToken();
        tokenizer.pushBack();
        return res!=tokenizer.TT_EOF;
    }
}",CorCod,634,634,nlogn
"
// A memoization based Java program to 
// count even length binary sequences 
// such that the sum of first and 
// second half bits is same 
import
java.io.*; 

class
GFG { 

// A lookup table to store the results of 
// subproblems 
static
int
lookup[][] = 
new
int
[
1000
][
1000
]; 

// dif is diference between sums of first 
// n bits and last n bits i.e., 
// dif = (Sum of first n bits) - (Sum of last n bits) 
static
int
countSeqUtil(
int
n, 
int
dif) 
{ 

// We can't cover diference of 

// more than n with 2n bits 

if
(Math.abs(dif) > n) 

return
0
; 


// n == 1, i.e., 2 bit long sequences 

if
(n == 
1
&& dif == 
0
) 

return
2
; 

if
(n == 
1
&& Math.abs(dif) == 
1
) 

return
1
; 


// Check if this subbproblem is already 

// solved n is added to dif to make 

// sure index becomes positive 

if
(lookup[n][n+dif] != -
1
) 

return
lookup[n][n+dif]; 


int
res = 
// First bit is 0 & last bit is 1 

countSeqUtil(n-
1
, dif+
1
) + 


// First and last bits are same 

2
*countSeqUtil(n-
1
, dif) + 


// First bit is 1 & last bit is 0 

countSeqUtil(n-
1
, dif-
1
); 


// Store result in lookup table 

// and return the result 

return
lookup[n][n+dif] = res; 
} 

// A Wrapper over countSeqUtil(). It mainly 
// initializes lookup table, then calls 
// countSeqUtil() 
static
int
countSeq(
int
n) 
{ 

// Initialize all entries of lookup 

// table as not filled 

// memset(lookup, -1, sizeof(lookup)); 

for
(
int
k = 
0
; k < lookup.length; k++) 

{ 

for
(
int
j = 
0
; j < lookup.length; j++) 

{ 

lookup[k][j] = -
1
; 

} 

} 


// call countSeqUtil() 

return
countSeqUtil(n, 
0
); 
} 

// Driver program 
public
static
void
main(String[] args) 
{ 

int
n = 
2
; 

System.out.println(
""Count of sequences is ""

+ countSeq(
2
)); 
} 
} 

// This code is contributed by Prerna Saini ",CorCod,450,450,quadratic
"import java.util.*;

public class HelloWorld{

     public static void main(String []args){
        final long MOD = 1000000007;
        Scanner scan = new Scanner(System.in);
        int now = 1;
        int maxStatements = scan.nextInt();
        long[] dp = new long[maxStatements + 1];
        dp[now] = 1;
        while(maxStatements > 0)
        {
            String add = scan.next();
            if (add.equals(""f""))
            {
                now++;
            }
            else
            {
                for (int k = 1; k <= now; k++)
                {
                    dp[k] = ((dp[k] + dp[k-1]) % MOD);
                }
            }
            maxStatements--;
        }
        System.out.println(dp[now]);
     }
}",CorCod,521,521,quadratic
"//Atcoder
import java.io.*;
import java.util.*;

public class Main {

	static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner() {
            try {
                br = new BufferedReader(new InputStreamReader(System.in));
                st = new StringTokenizer(br.readLine());
            } catch (Exception e){e.printStackTrace();}
        }

        public String next() {
            if (st.hasMoreTokens()) return st.nextToken();
            try {st = new StringTokenizer(br.readLine());}
            catch (Exception e) {e.printStackTrace();}
            return st.nextToken();
        }

        public int nextInt() {return Integer.parseInt(next());}

        public long nextLong() {return Long.parseLong(next());}

        public double nextDouble() {return Double.parseDouble(next());}

        public String nextLine() {
            String line = """";
            if(st.hasMoreTokens()) line = st.nextToken();
            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}
            while(st.hasMoreTokens()) line += "" ""+st.nextToken();
            return line;
        }
    }

	public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        PrintWriter pw = new PrintWriter(System.out);

        int n = sc.nextInt();
        int m = sc.nextInt();
        int ans = 0;

        int[] a = new int[101];
        for(int i=0;i<m;i++) a[sc.nextInt()]++;

        for(int i=1;i<=100;i++) {
            int y = 0;
            for(int x : a) {
                y += x / i;
            }
            if(y >= n) {
                ans = i;
            }
        }

        pw.println(ans);
        pw.close();
    }
}
",CorCod,475,475,quadratic
"import java.util.*;

public class ehab3 {
    public static void main( String[] args ) {
        Scanner in = new Scanner( System.in );
	int n = in.nextInt();
	int[] a = new int[n];
	for ( int i = 0; i < n; i++ )
	    a[i] = in.nextInt();
	System.out.println( ( n + 1 ) );
	int c = 0;
	for ( int i = n - 1; i >= 0; i-- ) {
	    int cd = n + i - ( ( a[i] + c ) % n );
	    System.out.println( ""1 "" + ( i + 1 ) + "" "" + cd );
	    c += cd;
	}
	System.out.println( ""2 "" + n + "" "" + n );
    }
}
",CorCod,8,8,linear
"
// Java program to count of ways to place 1 x 4 tiles 
// on n x 4 grid 
import
java.io.*; 

class
Grid 
{ 

// Function that count the number of ways to place 1 x 4 tiles 

// on n x 4 grid. 

static
int
count(
int
n) 

{ 

// Create a table to store results of sub-problems 

// dp[i] stores count of ways for i x 4 grid. 

int
[] dp = 
new
int
[n+
1
]; 

dp[
0
] = 
0
; 

// Fill the table from d[1] to dp[n] 

for
(
int
i=
1
;i<=n;i++) 

{ 

// Base cases 

if
(i >= 
1
&& i <= 
3
) 

dp[i] = 
1
; 

else
if
(i==
4
) 

dp[i] = 
2
; 


else

{ 

// dp(i-1) : Place first tile horizontally 

// dp(i-4) : Place first tile vertically 

// which means 3 more tiles have 

// to be placed vertically. 

dp[i] = dp[i-
1
] + dp[i-
4
]; 

} 

} 

return
dp[n]; 

} 


// Driver program 

public
static
void
main (String[] args) 

{ 

int
n = 
5
; 

System.out.println(
""Count of ways is: ""
+ count(n)); 

} 
} 

// Contributed by Pramod Kumar ",CorCod,366,366,linear
"
// Java program to find the only repeating 
// element in an array where elements are 
// from 1 to n-1. 
class
GFG 
{ 


static
int
findRepeating(
int
arr[], 
int
n) 

{ 


// res is going to store value of 

// 1 ^ 2 ^ 3 .. ^ (n-1) ^ arr[0] ^ 

// arr[1] ^ .... arr[n-1] 

int
res = 
0
; 

for
(
int
i = 
0
; i < n - 
1
; i++) 

res = res ^ (i + 
1
) ^ arr[i]; 

res = res ^ arr[n - 
1
]; 


return
res; 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
9
, 
8
, 
2
, 
6
, 
1
, 
8
, 
5
, 
3
, 
4
, 
7
}; 

int
n = arr.length; 

System.out.println(findRepeating(arr, n)); 

} 
} 

// This code is contributed by 
// Smitha Dinesh Semwal. ",CorCod,288,288,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
 
/**
 *
 * @author Antonio ""Teo"" Alurralde
 */
public class Main {
  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    StringTokenizer tok = new StringTokenizer(br.readLine());
    int ax = Integer.parseInt(tok.nextToken());
    int ay = Integer.parseInt(tok.nextToken());
    tok = new StringTokenizer(br.readLine());
    int bx = Integer.parseInt(tok.nextToken());
    int by = Integer.parseInt(tok.nextToken());
    tok = new StringTokenizer(br.readLine());
    int cx = Integer.parseInt(tok.nextToken());
    int cy = Integer.parseInt(tok.nextToken());
    boolean ans = (bx < ax && cx < ax && by < ay && cy < ay) ||
    (bx < ax && cx < ax && by > ay && cy > ay) ||
    (bx > ax && cx > ax && by < ay && cy < ay) ||
    (bx > ax && cx > ax && by > ay && cy > ay);
    System.out.print(ans?""YES"":""NO"");
  }
}
",CorCod,875,875,constant
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class PizzaPizzaPizza {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		long n = nextLong();
		if (n == 0)
			System.out.println(0);
		else if (n % 2 == 0)
			System.out.println(n+1);
		else
			System.out.println((n+1)/2);
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",CorCod,820,820,constant
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author fintech
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        KingEscape solver = new KingEscape();
        solver.solve(1, in, out);
        out.close();
    }

    static class KingEscape {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.nextInt();
            int qx = in.nextInt();
            int qy = in.nextInt();
            int kx = in.nextInt();
            int ky = in.nextInt();
            int safex = in.nextInt();
            int safey = in.nextInt();
            boolean possible = false;
            if (qx > Math.max(kx, safex) || qx < Math.min(kx, safex)) {
                if (qy > Math.max(ky, safey) || qy < Math.min(ky, safey)) {
                    possible = true;
                }
            }
            if (possible) out.println(""YES"");
            else out.println(""NO"");
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void println(Object... objects) {
            print(objects);
            writer.println();
        }

        public void close() {
            writer.close();
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",CorCod,826,826,constant
"

import java.util.*;
import java.lang.*;
public class CodeForce {
    
    
        public static void main(String[] args) {
            Scanner sc=new Scanner(System.in);
            String s=sc.next();
            String t=sc.next();
            int count=s.length()+t.length();
            for(int i=0;i<Math.min(s.length(), t.length());i++){
                if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;
                else break;
            }
            System.out.println(count);
            
            
            
            
           
            
                
        }    
    }


",CorCod,358,358,linear
"
// Java program to find number of pairs 
// and minimal possible value 
import
java.util.*; 

class
GFG { 


// function for finding pairs and min value 

static
void
pairs(
int
arr[], 
int
n, 
int
k) 

{ 

// initialize smallest and count 

int
smallest = Integer.MAX_VALUE; 

int
count=
0
; 


// iterate over all pairs 

for
(
int
i=
0
; i<n; i++) 

for
(
int
j=i+
1
; j<n; j++) 

{ 

// is abs value is smaller than 

// smallest update smallest and 

// reset count to 1 

if
( Math.abs(arr[i] + arr[j] - k) < 

smallest ) 

{ 

smallest = Math.abs(arr[i] + arr[j] 

- k); 

count = 
1
; 

} 


// if abs value is equal to smallest 

// increment count value 

else
if
(Math.abs(arr[i] + arr[j] - k) 

== smallest) 

count++; 

} 


// print result 

System.out.println(
""Minimal Value = ""
+ 

smallest); 

System.out.println(
""Total Pairs = ""
+ 

count); 

} 


/* Driver program to test above function */

public
static
void
main(String[] args) 

{ 

int
arr[] = {
3
, 
5
, 
7
, 
5
, 
1
, 
9
, 
9
}; 

int
k = 
12
; 

int
n = arr.length; 

pairs(arr, n, k); 

} 
} 
// This code is contributed by Arnav Kr. Mandal. ",CorCod,732,732,nlogn
"
// Java program to count number of substrings 
// of a string 
import
java.io.*; 

public
class
GFG { 


static
int
countNonEmptySubstr(String str) 

{ 

int
n = str.length(); 

return
n * (n + 
1
) / 
2
; 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

String s = 
""abcde""
; 

System.out.println( 

countNonEmptySubstr(s)); 

} 
} 

// This code is contributed 
// by Manish Shaw (manishshaw1) ",CorCod,451,451,quadratic
"
// Java program to count number of substrings 
// with counts of distinct characters as k. 
class
GFG 
{ 

static
int
MAX_CHAR = 
26
; 

// Returns true if all values 
// in freq[] are either 0 or k. 
static
boolean
check(
int
freq[], 
int
k) 
{ 

for
(
int
i = 
0
; i < MAX_CHAR; i++) 

if
(freq[i] !=
0
&& freq[i] != k) 

return
false
; 

return
true
; 
} 

// Returns count of substrings where frequency 
// of every present character is k 
static
int
substrings(String s, 
int
k) 
{ 

int
res = 
0
; 
// Initialize result 


// Pick a starting point 

for
(
int
i = 
0
; i< s.length(); i++) 

{ 


// Initialize all frequencies as 0 

// for this starting point 

int
freq[] = 
new
int
[MAX_CHAR]; 


// One by one pick ending points 

for
(
int
j = i; j<s.length(); j++) 

{ 


// Increment frequency of current char 

int
index = s.charAt(j) - 
'a'
; 

freq[index]++; 


// If frequency becomes more than 

// k, we can't have more substrings 

// starting with i 

if
(freq[index] > k) 

break
; 


// If frequency becomes k, then check 

// other frequencies as well. 

else
if
(freq[index] == k && 

check(freq, k) == 
true
) 

res++; 

} 

} 

return
res; 
} 

// Driver code 
public
static
void
main(String[] args) 
{ 

String s = 
""aabbcc""
; 

int
k = 
2
; 

System.out.println(substrings(s, k)); 


s = 
""aabbc""
; 

k = 
2
; 

System.out.println(substrings(s, k)); 
} 
} 

// This code has been contributed by 29AjayKumar ",CorCod,422,422,quadratic
"//package ContestEd69;

import java.io.*;
import java.util.StringTokenizer;

public class mainD {
    public static PrintWriter out = new PrintWriter(System.out);
    public static FastScanner enter = new FastScanner(System.in);
    public static long[] arr;
    public static void main(String[] args) throws IOException {
        int n=enter.nextInt();
        int m=enter.nextInt();
        long k=enter.nextLong();
        arr=new long[n+1];
        for (int i = 1; i <n+1 ; i++) {
            arr[i]=enter.nextLong();
        }
        long[] summ=new long[n+1];
        for (int i = 1; i <n+1 ; i++) {
            summ[i]+=arr[i]+summ[i-1];
        }

        long[] best=new long[n+1];

        for (int i = 1; i <n+1 ; i++) {
            best[i]=Math.max(0, ((i-m>=0) ? best[i-m]+summ[i]-summ[i-m]-k:0));
        }
        long ans=best[1];

        for (int i = 1; i <n+1 ; i++) {
            ans=Math.max(ans,best[i]);
            for (int j = 1; j <m ; j++) {
                ans=Math.max(ans, ((i-j>=0) ? best[i-j] -k +summ[i]-summ[i-j]:0));
            }
        }
        System.out.println(ans);
    }

    static class FastScanner {
        BufferedReader br;
        StringTokenizer stok;

        FastScanner(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
        }

        String next() throws IOException {
            while (stok == null || !stok.hasMoreTokens()) {
                String s = br.readLine();
                if (s == null) {
                    return null;
                }
                stok = new StringTokenizer(s);
            }
            return stok.nextToken();
        }

        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        char nextChar() throws IOException {
            return (char) (br.read());
        }

        String nextLine() throws IOException {
            return br.readLine();
        }
    }
}
",CorCod,457,457,quadratic
"import java.io.*;
import java.util.*;
import java.math.*;

public class bhaa {

    InputStream is;
    PrintWriter o;
    /////////////////// CODED++ BY++ ++ ++ ++ BHAVYA++ ARORA++ ++ ++ ++ FROM++ JAYPEE++ INSTITUTE++ OF++ INFORMATION++ TECHNOLOGY++ ////////////////

///////////////////////// Make it work, make it right, make it fast. Make it work, make it right, make it fast. Make it work, make it right, make it fast. Make it work, make it right, make it fast. /////////////////

    boolean chpr(int n)
    {
    	if(n==1)
    	{
    		return true;
    	}if(n==2)
    	{
    		return true;
    	}
    	if(n==3)
    	{
    		return true;
    	}
    	if(n%2==0)
    	{
    		return false;

    	}
    	if(n%3==0)
    	{
    		return false;
    	}
    	
    	int w=2;
 		int i=5;
    	while(i*i<=n)
    	{
    		if(n%i==0)
    		{
    			return false;
    		}
    		i+=w;
    		w=6-w;
    	}
    	return true;

    }
    
    void solve() {


        int n=ni();
        int k=ni();
        int rr=2*n;
        int gr=5*n;
        int br=8*n;
        o.println((long)(Math.ceil(rr*1.0/k)+Math.ceil(gr*1.0/k)+Math.ceil(br*1.0/k)));



    	

    }





   


    












    








































    //---------- I/O Template ----------
    
    public static void main(String[] args) { new bhaa().run(); }
    void run() { 
        is = System.in; 
        o = new PrintWriter(System.out);
        solve();
        o.flush();
    }
    
    byte input[] = new byte[1024];
    int len = 0, ptr = 0;
    
    int readByte() { 
        if(ptr >= len) { ptr = 0; 
            try { len = is.read(input); } 
            catch(IOException e) { throw new InputMismatchException(); } 
            if(len <= 0) { return -1; } 
        } return input[ptr++];
    }
    boolean isSpaceChar(int c) { return !( c >= 33 && c <= 126 ); }
    int skip() { 
        int b = readByte(); 
        while(b != -1 && isSpaceChar(b)) { b = readByte(); } 
        return b;
    }
    
    char nc() { return (char)skip(); }
    String ns() { 
        int b = skip(); 
        StringBuilder sb = new StringBuilder(); 
        while(!isSpaceChar(b)) { sb.appendCodePoint(b); b = readByte(); } 
        return sb.toString();
    }
    String nLine() { 
        int b = skip(); 
        StringBuilder sb = new StringBuilder(); 
        while( !(isSpaceChar(b) && b != ' ') ) { sb.appendCodePoint(b); b = readByte(); } 
        return sb.toString();
    }
    int ni() { 
        int n = 0, b = readByte(); 
        boolean minus = false; 
        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } 
        if(b == '-') { minus = true; b = readByte(); } 
        if(b == -1) { return -1; }  //no input 
        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } 
        return minus ? -n : n;
    }
    long nl() { 
        long n = 0L;    int b = readByte(); 
        boolean minus = false; 
        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } 
        if(b == '-') { minus = true; b = readByte(); } 
        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } 
        return minus ? -n : n;
    }

    double nd() { return Double.parseDouble(ns()); }
    float nf() { return Float.parseFloat(ns()); }
    int[] nia(int n) { 
        int a[] = new int[n]; 
        for(int i = 0; i < n; i++) { a[i] = ni(); } 
        return a;
    }
    long[] nla(int n) { 
        long a[] = new long[n]; 
        for(int i = 0; i < n; i++) { a[i] = nl(); } 
        return a;
    }
    int [][] nim(int n)
    {
        int mat[][]=new int[n][n];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                mat[i][j]=ni();
            }
        }
        return mat;
    }
    long [][] nlm(int n)
    {
        long mat[][]=new long[n][n];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                mat[i][j]=nl();
            }
        }
        return mat;
    }
    




    
    char[] ns(int n) { 
        char c[] = new char[n]; 
        int i, b = skip(); 
        for(i = 0; i < n; i++) { 
            if(isSpaceChar(b)) { break; } 
            c[i] = (char)b; b = readByte(); 
        } return i == n ? c : Arrays.copyOf(c,i);
    }
    void piarr(int arr[])
    {
        for(int i=0;i<arr.length;i++)
        {
            o.print(arr[i]+"" "");

        }
        o.println();
    }
    void plarr(long arr[])
    {
        for(int i=0;i<arr.length;i++)
        {
            o.print(arr[i]+"" "");

        }
        o.println();
    }
    
    void pimat(int mat[][])
    {
        for(int i=0;i<mat.length;i++)
        {
            for(int j=0;j<mat[0].length;j++)
            {
                o.print(mat[i][j]);
            }
            o.println();
        }
    }
    void plmat(long mat[][])
    {
        for(int i=0;i<mat.length;i++)
        {
            for(int j=0;j<mat[0].length;j++)
            {
                o.print(mat[i][j]);
            }
            o.println();
        }

    }




    //////////////////////////////////// template finished //////////////////////////////////////



}",CorCod,788,788,constant
"
// Java program to check if there exist an edge whose 
// removal creates two trees of same size 

class
Node 
{ 

int
key; 

Node left, right; 


public
Node(
int
key) 

{ 

this
.key = key; 

left = right = 
null
; 

} 
} 

class
Res 
{ 

boolean
res = 
false
; 
} 

class
BinaryTree 
{ 

Node root; 


// To calculate size of tree with given root 

int
count(Node node) 

{ 

if
(node == 
null
) 

return
0
; 


return
count(node.left) + count(node.right) + 
1
; 

} 


// This function returns size of tree rooted with given 

// root. It also set ""res"" as true if there is an edge 

// whose removal divides tree in two halves. 

// n is size of tree 

int
checkRec(Node root, 
int
n, Res res) 

{ 

// Base case 

if
(root == 
null
) 

return
0
; 


// Compute sizes of left and right children 

int
c = checkRec(root.left, n, res) + 
1

+ checkRec(root.right, n, res); 


// If required property is true for current node 

// set ""res"" as true 

if
(c == n - c) 

res.res = 
true
; 


// Return size 

return
c; 

} 


// This function mainly uses checkRec() 

boolean
check(Node root) 

{ 

// Count total nodes in given tree 

int
n = count(root); 


// Initialize result and recursively check all nodes 

Res res = 
new
Res(); 

checkRec(root, n, res); 


return
res.res; 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
5
); 

tree.root.left = 
new
Node(
1
); 

tree.root.right = 
new
Node(
6
); 

tree.root.left.left = 
new
Node(
3
); 

tree.root.right.left = 
new
Node(
7
); 

tree.root.right.right = 
new
Node(
4
); 

if
(tree.check(tree.root) == 
true
) 

System.out.println(
""YES""
); 

else

System.out.println(
""NO""
); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,25,25,linear
"import java.util.*;
public class bOX {

    public static void main(String ars[]){

        Scanner  s = new Scanner(System.in);
        int n = s.nextInt();
        int max = 0;

        Map<Integer,Integer> map = new HashMap<>();

        for(int i=0;i<n;i++){
            int x = s.nextInt();
            if(!map.containsKey(x)){
                map.put(x,1);
                max = Math.max(max,1);
            }
            else{
                map.put(x,map.get(x)+1);
                max = Math.max(max,map.get(x));
            }
        }

        System.out.println(max);
    }

}
",CorCod,595,595,nlogn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
 
 
public class HelloWorld {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        Palindrome solver = new Palindrome();
        solver.solve(1, in, out);
        out.close();
    }
    
    static class Palindrome {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            long l = in.nextLong();
            
            if(l%4 == 0 || l%4 == 3)
            {
                out.print(""0"");
            }
            else
            {
                out.print(""1"");
            }
        }
 
    }
    
    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;
 
        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
 
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        
        public long nextLong(){
            return Long.parseLong(next());
        }
 
    }
}",CorCod,802,802,constant
"package com.interview.binarysearch;

/**
 * http://www.geeksforgeeks.org/check-for-majority-element-in-a-sorted-array/
 */
public class FirstOccurrenceOfNumberInSortedArray {

    public int firstOccurrence(int input[], int x){
        int low = 0;
        int high = input.length-1;
        
        while(low <= high){
            int middle = (low + high)/2;
            if(input[middle] == x && (middle == 0 || input[middle-1] < x)){
                return middle;
            }else if(input[middle] < x){
                low = middle+1;
            }else{
                high = middle-1;
            }
        }
        return -1;
    }
    
    public static void main(String args[]){
        FirstOccurrenceOfNumberInSortedArray fos = new FirstOccurrenceOfNumberInSortedArray();
        int input[] = {1,2,2,2,2,2,5,7,7};
        System.out.println(fos.firstOccurrence(input, 6));
    }
    
}",CorCod,883,883,logn
"import java.io.PrintWriter;
import java.util.Scanner;

public class pr1023B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);

        long n = sc.nextLong();
        long k = sc.nextLong();

        out.println(solve(n, k));
        out.flush();
        out.close();
    }


    static long solve(long n, long k) {
        if(k <= n) return (long)Math.floor((double)(k-1)/2);
        else{
            long mx = n;
            long mn = k-n;
            return Math.max(0, (long)Math.floor((double)(mx-mn+1)/2));
        }
    }
}
",CorCod,770,770,constant
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

import static java.lang.Math.*;

public class Main2 {

    private FastScanner scanner = new FastScanner();

    public static void main(String[] args) {
        new Main2().solve();
    }

    private void solve() {

        String a = scanner.nextLine(), b = scanner.nextLine();

        int n = b.length(), m = a.length();

        int p[] = new int[n];

        p[0] = b.charAt(0) - '0';

        for (int i = 1; i < n; i++) {
            p[i] = p[i - 1] + (b.charAt(i) - '0');
        }

        long ans = 0;
        for (int i = 0; i < m; i++) {
            int cur = a.charAt(i) - '0';

            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);

            if (cur == 0) {
                ans += cnt;
            } else {
                ans += n - m + 1  - cnt;
            }
        }

        System.out.println(ans);

    }


    class Pair {
        int c, f;
    }

    class FastScanner {
        BufferedReader reader;
        StringTokenizer tokenizer;

        FastScanner() {
            reader = new BufferedReader(new InputStreamReader(System.in), 32768);
            tokenizer = null;
        }

        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();

        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        Integer[] nextA(int n) {
            Integer a[] = new Integer[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextInt();
            }
            return a;
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}",CorCod,329,329,linear
"import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

public class PlayingPiano {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		 int n = scanner.nextInt();
		 
		 List<Integer> as = new LinkedList<>();
		 int[] as2 = new int[n];
		 
		 for (int i = 0; i < n; i++) {
			 int a = scanner.nextInt();
			 as.add(a);
			 as2[i] = a;
		 }
		 
		 //System.out.println(solve(as));
		 System.out.println(solve2(as2));
		
		scanner.close();
	}

	public static String solve(List<Integer> as) {
		List<Integer> fingers = new LinkedList<>();
		 fingers.add(1);
		 fingers.add(2);
		 fingers.add(3);
		 fingers.add(4);
		 fingers.add(5);
		 
		 List<Integer> solution = assign(as, fingers, fingers);
		 if (solution == null) {
			 return ""-1"";
		 } else {
			 StringBuilder sb = new StringBuilder();
			 for (int b : solution) {
				 sb.append(b);
				 sb.append("" "");
			 }
			 sb.deleteCharAt(sb.length() - 1);
			 return sb.toString();
		 }
	}

	private static List<Integer> assign(List<Integer> as, List<Integer> fingers, List<Integer> allFingers) {
		// if fingers is empty return null
		if (fingers.isEmpty()) {
			return null;
		}
		
		// if as size is one then return first element in fingers
		if (as.size() == 1) {
			List<Integer> ret = new LinkedList<>();
			ret.add(fingers.get(0));
			return ret;
		}
		
		// get sublist
		List<Integer> subList = as.subList(1, as.size());
		
		for (int i = 0; i < fingers.size(); i++) {
			// recursively call with sublist and limited list of fingers
			List<Integer> subFingers = new LinkedList<>();
			final int j = i;
			if (as.get(0) < as.get(1)) {
				 subFingers = allFingers.stream()
					    .filter(p -> p > fingers.get(j)).collect(Collectors.toList());
			} else if (as.get(0) > as.get(1)) {
				subFingers = allFingers.stream()
					    .filter(p -> p < fingers.get(j)).collect(Collectors.toList());
			} else {
				subFingers = allFingers.stream()
					    .filter(p -> p != fingers.get(j)).collect(Collectors.toList());
			}
			
			List<Integer> ret = assign(subList, subFingers, allFingers);
			if (ret != null) {
				List<Integer> solution = new LinkedList<>();
				solution.add(fingers.get(i));
				solution.addAll(ret);
				return solution;
			}
			
			// if return is null, then return null, else return an array
		}
		return null;
		
	}
	
	public static String solve2(int[] as) {
		int[] ret = new int[as.length];
		
		if (as.length == 1) return ""1"";
		
		if (as[0] < as[1]) ret[0] = 1;
		else if (as[0] == as[1])	ret[0] = 3;
		else ret[0] = 5;
		
		for (int i = 1; i < as.length - 1; i++) {
			if (as[i-1] < as[i] && ret[i-1] == 5) return ""-1"";
			if (as[i-1] > as[i] && ret[i-1] == 1) return ""-1"";
			
			if (as[i-1] < as[i] && as[i] < as[i+1]) {
				ret[i] = ret[i-1] + 1;
			} else if (as[i-1] == as[i] && as[i] < as[i+1]) {
				ret[i] = ret[i-1] == 1 ? 2 : 1;
			} else if (as[i-1] > as[i] && as[i] < as[i+1]) {
				ret[i] = 1;
			} else if (as[i-1] < as[i] && as[i] == as[i+1]) {
				ret[i] = ret[i-1] + 1;
			} else if (as[i-1] == as[i] && as[i] == as[i+1]) {
				ret[i] = ret[i-1] == 4 ? 2 : 4;
			} else if (as[i-1] > as[i] && as[i] == as[i+1]) {
				ret[i] = ret[i-1] == 2 ? 1 : 2;
			} else if (as[i-1] < as[i] && as[i] > as[i+1]) {
				ret[i] = 5;
			} else if (as[i-1] == as[i] && as[i] > as[i+1]) {
				ret[i] = ret[i-1] == 5 ? 4 : 5;
			} else if (as[i-1] > as[i] && as[i] > as[i+1]) {
				ret[i] = ret[i-1] - 1;
			}
		}
		
		if (as.length > 1) {
			if (as[as.length - 1] > as[as.length - 2]) {
				if (ret[as.length - 2] == 5)
					return ""-1"";
				ret[as.length - 1] = 5;
			} else if (as[as.length - 1] == as[as.length - 2]) {
				ret[as.length - 1] = ret[as.length - 2] == 5 ? 4 : 5;
			} else {
				if (ret[as.length - 2] == 1)
					return ""-1"";
				ret[as.length - 1] = 1;
			} 
		}
		StringBuilder sb = new StringBuilder();
		 for (int b : ret) {
			 sb.append(b);
			 sb.append("" "");
		 }
		 sb.deleteCharAt(sb.length() - 1);
		 return sb.toString();
	}

}
",CorCod,251,251,linear
"import javax.print.DocFlavor;
import javax.swing.plaf.basic.BasicInternalFrameTitlePane;
import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.net.CookieHandler;
import java.nio.Buffer;
import java.nio.charset.IllegalCharsetNameException;
import java.sql.BatchUpdateException;
import java.util.*;
import java.util.stream.Stream;
import java.util.Vector;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import static java.lang.Math.*;
import java.util.*;
import java.nio.file.StandardOpenOption;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Iterator;
import java.util.PriorityQueue;

public class icpc
{
    public static void main(String[] args)throws IOException
    {
//        Reader in = new Reader();
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

        String s1[] = in.readLine().split("" "");
        int  n = Integer.parseInt(s1[0]);
        int p = Integer.parseInt(s1[1]);
        String s = in.readLine();
        StringBuilder stringBuilder = new StringBuilder(s);
        boolean flag = false;
        for(int i=0;i<n;i++)
        {
            if(i + p < n)
            {
                if(s.charAt(i) != '.' && s.charAt(i + p) != '.' && s.charAt(i) != s.charAt(i + p))
                {
                    flag = true;
                    break;
                }
                else if(s.charAt(i) == '.' && s.charAt(i + p) != '.')
                {
                    int x = s.charAt(i + p) - '0';
                    char ch = (char)((x + 1) % 2 + 48);
                    stringBuilder.setCharAt(i, ch);
                    flag = true;
                    break;
                }
                else if(s.charAt(i) != '.' && s.charAt(i + p) == '.')
                {
                    int x = s.charAt(i) - '0';
                    char ch = (char)((x + 1) % 2 + 48);
                    stringBuilder.setCharAt(i + p, ch);
                    flag = true;
                    break;
                }
                else if(s.charAt(i) == '.' && s.charAt(i + p) == '.')
                {
                    stringBuilder.setCharAt(i, '1');
                    stringBuilder.setCharAt(i + p, '0');
                    flag = true;
                    break;
                }
            }
        }
        if(flag)
        {
            for(int i=0;i<stringBuilder.length();i++)
            {
                if(stringBuilder.charAt(i) == '.')
                {
                    stringBuilder.setCharAt(i, '0');
                }
            }
            System.out.println(stringBuilder);
        }
        else
            System.out.println(""No"");


    }
}
class StringAlgorithms
{
    public int[] calculateZ(char input[]) {
        int Z[] = new int[input.length];
        int left = 0;
        int right = 0;
        for(int k = 1; k < input.length; k++) {
            if(k > right) {
                left = right = k;
                while(right < input.length && input[right] == input[right - left]) {
                    right++;
                }
                Z[k] = right - left;
                right--;
            } else {
                //we are operating inside box
                int k1 = k - left;
                //if value does not stretches till right bound then just copy it.
                if(Z[k1] < right - k + 1) {
                    Z[k] = Z[k1];
                } else { //otherwise try to see if there are more matches.
                    left = k;
                    while(right < input.length && input[right] == input[right - left]) {
                        right++;
                    }
                    Z[k] = right - left;
                    right--;
                }
            }
        }
        return Z;
    }
    public ArrayList<Integer> matchPattern(char text[], char pattern[]) {
        char newString[] = new char[text.length + pattern.length + 1];
        int i = 0;
        for(char ch : pattern) {
            newString[i] = ch;
            i++;
        }
        newString[i] = '$';
        i++;
        for(char ch : text) {
            newString[i] = ch;
            i++;
        }
        ArrayList<Integer> result = new ArrayList<>();
        int Z[] = calculateZ(newString);

        for(i = 0; i < Z.length ; i++) {
            if(Z[i] == pattern.length) {
                result.add(i - pattern.length - 1);
            }
        }
        return result;
    }
}
class BasicFunctions
{
    public long min(long[] A)
    {
        long min = Long.MAX_VALUE;
        for(int i=0;i<A.length;i++)
        {
            min = Math.min(min, A[i]);
        }
        return min;
    }
    public long max(long[] A)
    {
        long max = Long.MAX_VALUE;
        for(int i=0;i<A.length;i++)
        {
            max = Math.max(max, A[i]);
        }
        return max;
    }
}
class Name implements Comparable<Name>
{
    int x;
    int y;

    public Name(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
    @Override
    public int compareTo(Name ob)
    {
        if(this.x < ob.x)
            return -1;
        else if(this.x > ob.x)
            return 1;
        return 0;
    }
}
class Matrix
{
    long a;
    long b;
    long c;
    long d;

    public Matrix(long a, long b, long c, long d)
    {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }
}
class Game implements Comparable<Game>
{
    long x;
    long y;

    public Game(long x, long y)
    {
        this.x = x;
        this.y = y;
    }

    @Override
    public int compareTo(Game ob)
    {
        if(this.x < ob.x)
            return -1;
        else if(this.x > ob.x)
            return 1;
        else
        {
            if(this.y < ob.y)
                return -1;
            else if(this.y > ob.y)
                return 1;
            else
                return 0;
        }
    }
}
class MergeSortInt
{
    // Merges two subarrays of arr[].
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    void merge(int arr[], int l, int m, int r) {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        /* Create temp arrays */
        int L[] = new int[n1];
        int R[] = new int[n2];

        /*Copy data to temp arrays*/
        for (int i = 0; i < n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];


        /* Merge the temp arrays */

        // Initial indexes of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        /* Copy remaining elements of L[] if any */
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        /* Copy remaining elements of R[] if any */
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that sorts arr[l..r] using
    // merge()
    void sort(int arr[], int l, int r) {
        if (l < r) {
            // Find the middle point
            int m = (l + r) / 2;

            // Sort first and second halves
            sort(arr, l, m);
            sort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

}
class MergeSortLong
{
    // Merges two subarrays of arr[].
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    void merge(long arr[], int l, int m, int r) {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        /* Create temp arrays */
        long L[] = new long[n1];
        long R[] = new long[n2];

        /*Copy data to temp arrays*/
        for (int i = 0; i < n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];


        /* Merge the temp arrays */

        // Initial indexes of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        /* Copy remaining elements of L[] if any */
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        /* Copy remaining elements of R[] if any */
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that sorts arr[l..r] using
    // merge()
    void sort(long arr[], int l, int r) {
        if (l < r) {
            // Find the middle point
            int m = (l + r) / 2;

            // Sort first and second halves
            sort(arr, l, m);
            sort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }
}
class Node
{
    String a;
    String b;
    Node(String s1,String s2)
    {
        this.a = s1;
        this.b = s2;
    }
    @Override
    public boolean equals(Object ob)
    {
        if(ob == null)
            return false;
        if(!(ob instanceof Node))
            return false;
        if(ob == this)
            return true;
        Node obj = (Node)ob;
        if(this.a.equals(obj.a) && this.b.equals(obj.b))
            return true;
        return false;
    }

    @Override
    public int hashCode()
    {
        return (int)this.a.length();
    }
}
class Reader
{
    final private int BUFFER_SIZE = 1 << 16;
    private DataInputStream din;
    private byte[] buffer;
    private int bufferPointer, bytesRead;

    public Reader()
    {
        din = new DataInputStream(System.in);
        buffer = new byte[BUFFER_SIZE];
        bufferPointer = bytesRead = 0;
    }

    public Reader(String file_name) throws IOException
    {
        din = new DataInputStream(new FileInputStream(file_name));
        buffer = new byte[BUFFER_SIZE];
        bufferPointer = bytesRead = 0;
    }

    public String readLine() throws IOException
    {
        byte[] buf = new byte[64]; // line length
        int cnt = 0, c;
        while ((c = read()) != -1)
        {
            if (c == '\n')
                break;
            buf[cnt++] = (byte) c;
        }
        return new String(buf, 0, cnt);
    }

    public int nextInt() throws IOException
    {
        int ret = 0;
        byte c = read();
        while (c <= ' ')
            c = read();
        boolean neg = (c == '-');
        if (neg)
            c = read();
        do
        {
            ret = ret * 10 + c - '0';
        }  while ((c = read()) >= '0' && c <= '9');

        if (neg)
            return -ret;
        return ret;
    }

    public long nextLong() throws IOException
    {
        long ret = 0;
        byte c = read();
        while (c <= ' ')
            c = read();
        boolean neg = (c == '-');
        if (neg)
            c = read();
        do {
            ret = ret * 10 + c - '0';
        }
        while ((c = read()) >= '0' && c <= '9');
        if (neg)
            return -ret;
        return ret;
    }

    public double nextDouble() throws IOException
    {
        double ret = 0, div = 1;
        byte c = read();
        while (c <= ' ')
            c = read();
        boolean neg = (c == '-');
        if (neg)
            c = read();

        do {
            ret = ret * 10 + c - '0';
        }
        while ((c = read()) >= '0' && c <= '9');

        if (c == '.')
        {
            while ((c = read()) >= '0' && c <= '9')
            {
                ret += (c - '0') / (div *= 10);
            }
        }

        if (neg)
            return -ret;
        return ret;
    }

    private void fillBuffer() throws IOException
    {
        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
        if (bytesRead == -1)
            buffer[0] = -1;
    }

    private byte read() throws IOException
    {
        if (bufferPointer == bytesRead)
            fillBuffer();
        return buffer[bufferPointer++];
    }

    public void close() throws IOException
    {
        if (din == null)
            return;
        din.close();
    }
}
class FenwickTree
{
    public void update(long[] fenwickTree,long delta,int index)
    {
        index += 1;
        while(index < fenwickTree.length)
        {
            fenwickTree[index] += delta;
            index = index + (index & (-index));
        }
    }
    public long prefixSum(long[] fenwickTree,int index)
    {
        long sum = 0L;
        index += 1;
        while(index > 0)
        {
            sum += fenwickTree[index];
            index -= (index & (-index));
        }
        return sum;
    }
}
class SegmentTree
{
    public int nextPowerOfTwo(int num)
    {
        if(num == 0)
            return 1;
        if(num > 0 && (num & (num - 1)) == 0)
            return num;
        while((num &(num - 1)) > 0)
        {
            num = num & (num - 1);
        }
        return num << 1;
    }
    public int[] createSegmentTree(int[] input)
    {
        int np2 = nextPowerOfTwo(input.length);
        int[] segmentTree = new int[np2 * 2 - 1];

        for(int i=0;i<segmentTree.length;i++)
            segmentTree[i] = Integer.MIN_VALUE;

        constructSegmentTree(segmentTree,input,0,input.length-1,0);
        return segmentTree;

    }
    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)
    {
        if(low == high)
        {
            segmentTree[pos] = input[low];
            return;
        }
        int mid = (low + high)/ 2;
        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);
        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);
        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);
    }
    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)
    {
        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);
    }
    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)
    {
        if(qlow <= low && qhigh >= high){
            return segmentTree[pos];
        }
        if(qlow > high || qhigh < low){
            return Integer.MIN_VALUE;
        }
        int mid = (low+high)/2;
        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),
                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));
    }
}",CorCod,142,142,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 * @author Don Li
 */
public class SequenceTransformation {
    void solve() {
        int p = 1, n = in.nextInt();
        while (n > 0) {
            if (n == 1) {
                out.print(p + "" "");
                break;
            }
            if (n == 2) {
                out.print(p + "" "");
                out.print(2 * p + "" "");
                break;
            }
            if (n == 3) {
                out.print(p + "" "");
                out.print(p + "" "");
                out.print(3 * p + "" "");
                break;
            }
            for (int i = 0; i < (n + 1) / 2; i++) {
                out.print(p + "" "");
            }
            p *= 2;
            n /= 2;
        }
    }
    
    public static void main(String[] args) {
        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(System.out);
        new SequenceTransformation().solve();
        out.close();
    }
    
    static FastScanner in;
    static PrintWriter out;
    
    static class FastScanner {
        BufferedReader in;
        StringTokenizer st;
        
        public FastScanner(BufferedReader in) {
            this.in = in;
        }
        
        public String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        
        public int nextInt() {
            return Integer.parseInt(nextToken());
        }
        
        public long nextLong() {
            return Long.parseLong(nextToken());
        }
        
        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }
}
",CorCod,322,322,linear
"import java.util.*;
public class test{
public static void main(String args[])
{
Scanner s=new Scanner(System.in);
int n=s.nextInt();
int m=s.nextInt();
int arr[]=new int[n];
int max = Integer.MIN_VALUE;
        long sum = 0;
        for(int i=0;i<n;i++)
        {
            arr[i] = s.nextInt();
            sum = sum + arr[i];
            max = Math.max(max,arr[i]);
        }
        Arrays.sort(arr);
        int i = 0;
        int count = 0;
        int d = 0;
        for(i=0; i<n; i++)
        {
            if(arr[i] > d)
            {
                count++;
                d++;
            }
            else if(arr[i] == d && arr[i] > 0)
            {
                count++;
            }
        }
        //System.out.println(count + "" "" + max);
        if(max - d > 0)
        {
            count = count + max - d;
        }
        System.out.println(sum - count);}}",CorCod,682,682,nlogn
"import java.util.Scanner;

/**
 *
 * @author User
 */
public class Code {

   static int [] reverse(int a[]) 
    { 
        int[] b = new int[a.length]; 
       int j = 0  ;
        for (int i = a.length-1; i >= 0; i--) {
            b[i] = a[j] ; 
            j++;
        }
        return b ;
    }
    public static void main(String[] args) {
        int pas ; 
        int top ; 
        Scanner in = new Scanner(System.in) ; 
        pas= in.nextInt(); 
        top=in.nextInt() ; 
        int a [] = new int[pas] ; 
        int b [] = new int[pas] ; 
        
        for (int i = 0; i < pas; i++) {
            a[i] = in.nextInt() ; 
            b[i] = in.nextInt() ; 
           
         }
       a =  reverse(a) ;
        b = reverse(b) ;
        int ftime =0 ; 
        int t;
        int po = top ; 
        for (int i = 0; i < pas; i++) {
             ftime+=(po-a[i]) ; 
            t = Math.max(b[i]-ftime, 0) ; 
            ftime+=t ; 
            po = a[i] ; 
           
        }
        if(po!=0) ftime+=po ;
        System.out.println(ftime);
        
    }
    
}
",CorCod,306,306,linear
"import java.io.*;
import java.util.*;
 
 
 
public class Main {
	
	static InputReader in = new InputReader(System.in);
	static PrintWriter out = new PrintWriter(System.out);

	static long oo = 1000000000000L;
	static int[][] memo;
	
	public static void main(String[] args) throws IOException {
 
		int n = in.nextInt();
		int[] a = in.nextIntArray(n);
		if(n % 2 == 0) {
			for(int i = 0; i < n; ++i) {
				if(a[i] >= 0)
					a[i] = -a[i] - 1;
			}
		}
		else {
			int maxi = -1, max = -1;
			for(int i = 0; i < n; ++i) {
				int x = a[i] >= 0 ? -a[i] - 1 : a[i];
				x = -x;
				if(x > max) {
					max = x; maxi = i;
				}
			}
			if(max == 1) {
				a[0] = 0;
			}
			else {
				for(int i = 0; i < n; ++i) {
					if(i == maxi) {
						if(a[i] < 0)
							a[i] = -a[i] - 1;
					}
					else {
						if(a[i] >= 0)
							a[i] = -a[i] - 1;
					}
				}
			}
		}
		for(int x : a)
			System.out.print(x + "" "");
		
		out.close();
	}
	
	
	
	static long lcm(long a, long b) {
		return a * b / gcd(a, b);
	}
	
	static boolean nextPermutation(int[] a) {
		for(int i = a.length - 2; i >= 0; --i) {
			if(a[i] < a[i+1]) {
				for(int j = a.length - 1; ; --j) {
					if(a[i] < a[j]) {
						int t = a[i];
						a[i] = a[j];
						a[j] = t;
						for(i++, j = a.length - 1; i < j; ++i, --j) {
							t = a[i];
							a[i] = a[j];
							a[j] = t;
						}
						return true;
					}
				}
			}
		}
		return false;
	}
	
	
	static void shuffle(int[] a) {
		Random r = new Random();
		for(int i = a.length - 1; i > 0; --i) {
			int si = r.nextInt(i);
			int t = a[si];
			a[si] = a[i];
			a[i] = t;
		}
	}
	
	static void shuffle(long[] a) {
		Random r = new Random();
		for(int i = a.length - 1; i > 0; --i) {
			int si = r.nextInt(i);
			long t = a[si];
			a[si] = a[i];
			a[i] = t;
		}
	}
	
	static int lower_bound(int[] a, int n, int k) {
		int s = 0;
		int e = n;
		int m;
		while (e - s > 0) {
			m = (s + e) / 2;
			if (a[m] < k)
				s = m + 1;
			else
				e = m;
		}
		return e;
	}
	static int lower_bound(long[] a, int n, long k) {
		int s = 0;
		int e = n;
		int m;
		while (e - s > 0) {
			m = (s + e) / 2;
			if (a[m] < k)
				s = m + 1;
			else
				e = m;
		}
		return e;
	}
	
	static int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}
	static long gcd(long a, long b) {
		return b == 0 ? a : gcd(b, a % b);
	}
	
	static class Pair implements Comparable<Pair> {
		int first, second;
 
		public Pair(int first, int second) {
			super();
			this.first = first;
			this.second = second;
		}
 
		@Override
		public int compareTo(Pair o) {
			return this.first != o.first ? this.first - o.first : this.second - o.second;
		}
 
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + first;
			result = prime * result + second;
			return result;
		}
 
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Pair other = (Pair) obj;
			if (first != other.first)
				return false;
			if (second != other.second)
				return false;
			return true;
		}
	}
	
	
}
 
 
 
class InputReader {
 
	private final InputStream stream;
	private final byte[] buf = new byte[8192];
	private int curChar, snumChars;
 
	public InputReader(InputStream st) {
		this.stream = st;
	}
 
	public int read() {
		if (snumChars == -1)
			throw new InputMismatchException();
		if (curChar >= snumChars) {
			curChar = 0;
			try {
				snumChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (snumChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}
 
	public int nextInt() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}
 
	public long nextLong() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}
 
	public int[] nextIntArray(int n) {
		int a[] = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = nextInt();
		}
		return a;
	}
 
	public String readString() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		StringBuilder res = new StringBuilder();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}
 
	public String nextLine() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isEndOfLine(c));
		return res.toString();
	}
 
	public boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
 
	private boolean isEndOfLine(int c) {
		return c == '\n' || c == '\r' || c == -1;
	}
 
}",CorCod,209,209,linear
"
/* Dynamic Programming Java 

implementation of Maximum Sum 

Increasing Subsequence (MSIS) 

problem */
class
GFG 
{ 

/* maxSumIS() returns the 

maximum sum of increasing 

subsequence in arr[] of size n */

static
int
maxSumIS(
int
arr[], 
int
n) 

{ 

int
i, j, max = 
0
; 

int
msis[] = 
new
int
[n]; 


/* Initialize msis values 

for all indexes */

for
(i = 
0
; i < n; i++) 

msis[i] = arr[i]; 


/* Compute maximum sum values 

in bottom up manner */

for
(i = 
1
; i < n; i++) 

for
(j = 
0
; j < i; j++) 

if
(arr[i] > arr[j] && 

msis[i] < msis[j] + arr[i]) 

msis[i] = msis[j] + arr[i]; 


/* Pick maximum of all 

msis values */

for
(i = 
0
; i < n; i++) 

if
(max < msis[i]) 

max = msis[i]; 


return
max; 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
arr[] = 
new
int
[]{
1
, 
101
, 
2
, 
3
, 
100
, 
4
, 
5
}; 

int
n = arr.length; 

System.out.println(
""Sum of maximum sum ""
+ 

""increasing subsequence is ""
+ 

maxSumIS(arr, n)); 

} 
} 

// This code is contributed 
// by Rajat Mishra ",CorCod,417,417,quadratic
"
import java.io.BufferedOutputStream;
import java.io.PrintWriter;
import java.util.*;

public class E1180D {

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));
        int n = sc.nextInt();
        int m = sc.nextInt();

        // Move from both ends, Time limit exceeded on test 6
        for (int i= 1; i<= m/2; i++) {
            // String s = """";
            int i2 = m -i + 1; // the other end of i
            // i is left row, i2 is right row
            for (int j = 1; j <= n ; j++) {
                int j2 = n - j + 1;
                // start with (i,j), then go thru all the cell with (,i) and (,i2)
                pw.println(j + "" "" + i);
                pw.println(j2+ "" "" + i2);
                // s += j + "" "" + i + ""\n"" + j2+ "" "" + i2 + ""\n"";
            }
            // out.print(s);
        }
        
        // if n is odd, there is one line in the middle
        if (m % 2 == 1) {
            int i2 = m /2 + 1; // this is the middle column
            for (int j = 1; j <= n/2 ; j++) {
                int j2 = n - j + 1;
                // start with (i,j), then go thru all the cell with (,i) and (,i2)
                pw.println(j + "" "" + i2);
                pw.println(j2+ "" "" + i2);
            }
            if (n %2 == 1) {
                int j = n /2 + 1;
                pw.println(j + "" "" + i2);
            }
        }
        pw.flush();
        pw.close();
    }    
}
",CorCod,474,474,quadratic
"
// Java program to solve Gold Mine problem 
import
java.util.Arrays; 

class
GFG { 


static
final
int
MAX = 
100
; 


// Returns maximum amount of gold that 

// can be collected when journey started 

// from first column and moves allowed 

// are right, right-up and right-down 

static
int
getMaxGold(
int
gold[][], 

int
m, 
int
n) 

{ 


// Create a table for storing 

// intermediate results and initialize 

// all cells to 0. The first row of 

// goldMineTable gives the maximum 

// gold that the miner can collect 

// when starts that row 

int
goldTable[][] = 
new
int
[m][n]; 


for
(
int
[] rows:goldTable) 

Arrays.fill(rows, 
0
); 


for
(
int
col = n-
1
; col >= 
0
; col--) 

{ 

for
(
int
row = 
0
; row < m; row++) 

{ 


// Gold collected on going to 

// the cell on the right(->) 

int
right = (col == n-
1
) ? 
0

: goldTable[row][col+
1
]; 


// Gold collected on going to 

// the cell to right up (/) 

int
right_up = (row == 
0
|| 

col == n-
1
) ? 
0
: 

goldTable[row-
1
][col+
1
]; 


// Gold collected on going to 

// the cell to right down (\) 

int
right_down = (row == m-
1

|| col == n-
1
) ? 
0
: 

goldTable[row+
1
][col+
1
]; 


// Max gold collected from taking 

// either of the above 3 paths 

goldTable[row][col] = gold[row][col] 

+ Math.max(right, Math.max(right_up, 

right_down)); 

; 

} 

} 


// The max amount of gold collected will be 

// the max value in first column of all rows 

int
res = goldTable[
0
][
0
]; 


for
(
int
i = 
1
; i < m; i++) 

res = Math.max(res, goldTable[i][
0
]); 


return
res; 

} 


//driver code 

public
static
void
main(String arg[]) 

{ 

int
gold[][]= { {
1
, 
3
, 
1
, 
5
}, 

{
2
, 
2
, 
4
, 
1
}, 

{
5
, 
0
, 
2
, 
3
}, 

{
0
, 
6
, 
1
, 
2
} }; 


int
m = 
4
, n = 
4
; 


System.out.print(getMaxGold(gold, m, n)); 

} 
} 

// This code is contributed by Anant Agarwal. ",CorCod,525,525,quadratic
"import java.io.*;
import java.util.*;
public class Codechef{
      

    public static void main(String []args){
       Scanner sc = new Scanner(System.in);
        int n=sc.nextInt();
		Set<HashSet> s3 = new HashSet<>();

      
         for(int j=0;j<n;j++){
         	String a=sc.next();
         HashSet<Character> t = new HashSet<Character>();
			for(char c:a.toCharArray()){
			t.add(c);
			}

        s3.add(t);
    
          

         }
         System.out.println(s3.size());
    }
}",CorCod,562,562,quadratic
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Liavontsi Brechka
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        DEhabIEsheOdnaOcherednayaZadachaNaXor solver = new DEhabIEsheOdnaOcherednayaZadachaNaXor();
        solver.solve(1, in, out);
        out.close();
    }

    static class DEhabIEsheOdnaOcherednayaZadachaNaXor {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int c = 0;
            int d = 0;

            int prevSign = 0;
            int nextSign;
            boolean zeroOut = true;
            for (int i = 29; i >= 0; i--) {
                if (zeroOut) {
                    print(c, d, out);
                    prevSign = read(in);
                }

                print((1 << i) | c, (1 << i) | d, out);
                nextSign = read(in);

                if (prevSign == nextSign) {
                    zeroOut = false;

                    print((1 << i) | c, d, out);
                    nextSign = read(in);

                    if (nextSign < 0) {
                        c = (1 << i) | c;
                        d = (1 << i) | d;
                    }
                } else {
                    zeroOut = true;

                    if (nextSign < 0) c = (1 << i) | c;
                    else d = (1 << i) | d;
                }
            }

            out.printf(""! %d %d"", c, d);
            out.flush();
        }

        private void print(int c, int d, PrintWriter out) {
            out.printf(""? %d %d\n"", c, d);
            out.flush();
        }

        private int read(InputReader in) {
            return in.nextInt();
        }

    }

    static class InputReader {
        private final BufferedReader reader;
        private StringTokenizer tokenizer;

        public InputReader(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(readLine());
            }
            return tokenizer.nextToken();
        }

        public String readLine() {
            String line;
            try {
                line = reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            return line;
        }

    }
}

",CorCod,912,912,logn
"
// Java program to print BST in given range 

// A binary tree node 
class
Node { 


int
data; 

Node left, right; 


Node(
int
d) { 

data = d; 

left = right = 
null
; 

} 
} 

class
BinaryTree { 


static
Node root; 


/* A function that constructs Balanced Binary Search Tree 

from a sorted array */

Node sortedArrayToBST(
int
arr[], 
int
start, 
int
end) { 


/* Base Case */

if
(start > end) { 

return
null
; 

} 


/* Get the middle element and make it root */

int
mid = (start + end) / 
2
; 

Node node = 
new
Node(arr[mid]); 


/* Recursively construct the left subtree and make it 

left child of root */

node.left = sortedArrayToBST(arr, start, mid - 
1
); 


/* Recursively construct the right subtree and make it 

right child of root */

node.right = sortedArrayToBST(arr, mid + 
1
, end); 


return
node; 

} 


/* A utility function to print preorder traversal of BST */

void
preOrder(Node node) { 

if
(node == 
null
) { 

return
; 

} 

System.out.print(node.data + 
"" ""
); 

preOrder(node.left); 

preOrder(node.right); 

} 


public
static
void
main(String[] args) { 

BinaryTree tree = 
new
BinaryTree(); 

int
arr[] = 
new
int
[]{
1
, 
2
, 
3
, 
4
, 
5
, 
6
, 
7
}; 

int
n = arr.length; 

root = tree.sortedArrayToBST(arr, 
0
, n - 
1
); 

System.out.println(
""Preorder traversal of constructed BST""
); 

tree.preOrder(root); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,294,294,linear
"/*
Keep solving problems.
*/

import java.util.*;
import java.io.*;

public class CFA {
    BufferedReader br;
    PrintWriter out;
    StringTokenizer st;
    boolean eof;
    private static long MOD = 1000L * 1000L * 1000L + 7;
    private static final int[] dx = {0, -1, 0, 1};
    private static final int[] dy = {1, 0, -1, 0};
    private static final String yes = ""Yes"";
    private static final String no = ""No"";

    int n;
    int m;
    char[][] mat;
    long base = 397;
    void solve() throws IOException {
        n = nextInt();
        m = nextInt();
        mat = new char[n][m];
        for (int i = 0; i < n; i++) {
            mat[i] = nextString().toCharArray();
        }

        int alpha = 26;
        long[] pow = new long[alpha];
        pow[0] = 1;
        for (int i = 1; i < alpha; i++) {
            pow[i] = pow[i - 1] * base % MOD;
        }

        long res = 0;
        for (int l = 0; l < m; l++) {
            //[l, r]
            long[] hash = new long[n];
            long[] mask = new long[n];
            for (int r = l; r < m; r++) {
                for (int i = 0; i < n; i++) {
                    hash[i] += pow[mat[i][r] - 'a'];
                    hash[i] %= MOD;
                    mask[i] = mask[i] ^ (1L << (mat[i][r] - 'a'));
                }

                int start = 0;
                while (start < n) {
                    if ((mask[start] & (mask[start] - 1)) != 0) {
                        start++;
                        continue;
                    }

                    int end = start;
                    List<Long> l1 = new ArrayList<>();
                    while (end < n && (mask[end] & (mask[end] - 1)) == 0) {
                        l1.add(hash[end]);
                        end++;
                    }

                    start = end;
                    res += manacher(l1);
                }
            }
        }

        outln(res);
    }

    long manacher(List<Long> arr) {
        int len = arr.size();
        long[] t = new long[len * 2 + 3];
        t[0] = -1;
        t[len * 2 + 2] = -2;
        for (int i = 0; i < len; i++) {
            t[2 * i + 1] = -3;
            t[2 * i + 2] = arr.get(i);
        }

        t[len * 2 + 1] = -3;
        int[] p = new int[t.length];
        int center = 0, right = 0;
        for (int i = 1; i < t.length - 1; i++) {
            int mirror = 2 * center - i;
            if (right > i) {
                p[i] = Math.min(right - i, p[mirror]);
            }

            // attempt to expand palindrome centered at i
            while (t[i + (1 + p[i])] == t[i - (1 + p[i])]) {
                p[i]++;
            }

            // if palindrome centered at i expands past right,
            // adjust center based on expanded palindrome.
            if (i + p[i] > right) {
                center = i;
                right = i + p[i];
            }
        }

        long res = 0;
        for (int i = 0; i < 2 * len; i++) {
            int parLength = p[i + 2];
            if (i % 2 == 0) {
                res += (parLength + 1) / 2;
            }
            else {
                res += parLength / 2;
            }
        }

        return res;
    }

    void shuffle(int[] a) {
        int n = a.length;
        for(int i = 0; i < n; i++) {
            int r = i + (int) (Math.random() * (n - i));
            int tmp = a[i];
            a[i] = a[r];
            a[r] = tmp;
        }
    }
    long gcd(long a, long b) {
        while(a != 0 && b != 0) {
            long c = b;
            b = a % b;
            a = c;
        }
        return a + b;
    }
    private void outln(Object o) {
        out.println(o);
    }
    private void out(Object o) {
        out.print(o);
    }
    private void formatPrint(double val) {
        outln(String.format(""%.9f%n"", val));
    }
    public CFA() throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);
        solve();
        out.close();
    }
    public static void main(String[] args) throws IOException {
        new CFA();
    }

    public long[] nextLongArr(int n) throws IOException{
        long[] res = new long[n];
        for(int i = 0; i < n; i++)
            res[i] = nextLong();
        return res;
    }
    public int[] nextIntArr(int n) throws IOException {
        int[] res = new int[n];
        for(int i = 0; i < n; i++)
            res[i] = nextInt();
        return res;
    }
    public String nextToken() {
        while (st == null || !st.hasMoreTokens()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (Exception e) {
                eof = true;
                return null;
            }
        }
        return st.nextToken();
    }
    public String nextString() {
        try {
            return br.readLine();
        } catch (IOException e) {
            eof = true;
            return null;
        }
    }
    public int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }
    public long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }
    public double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }
}",CorCod,602,602,nlogn
"

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;

public class C {

    void solve(){
       int n = readInt();
       int q = readInt();
       int max = 0;
       int[] a = new int[n];
       Deque<Integer> deque = new ArrayDeque<>();
       for(int i = 0;i<n;i++){
           a[i] = readInt();
           deque.addLast(a[i]);
           max = Math.max(max, a[i]);
       }
        List<String> ans = new ArrayList<>();
        while(deque.peekFirst() != max){
           int one = deque.pollFirst();
           int two = deque.pollFirst();
           ans.add(one + "" "" + two);
           deque.addFirst(one > two ? one : two);
           deque.addLast(one > two ? two : one);
           if(one == max) break;
       }

       for(int i = 0;i<n;i++){
           a[i] = deque.pollFirst();
       }

       for(int i = 0;i<q;i++){
          long x = readLong();
           if(x <= ans.size()){
               out.println(ans.get((int)x - 1));
               continue;
           }
           x -= ans.size();
           int y =(int) (x%(n - 1) - 1%(n - 1) + (n - 1)) % (n - 1) + 1;
           out.println(max + "" "" + a[y]);
       }
    }

    public static void main(String[] args) {
        new C().run();
    }

    void run(){
        init();
        solve();
        out.close();
    }

    BufferedReader in;
    PrintWriter out;

    StringTokenizer tok = new StringTokenizer("""");

    void init(){
        in = new BufferedReader(new InputStreamReader(System.in));
        out  = new PrintWriter(System.out);
    }

    String readLine(){
        try{
            return in.readLine();
        }catch(Exception ex){
            throw new RuntimeException(ex);
        }
    }
    String readString(){
        while(!tok.hasMoreTokens()){
            String nextLine = readLine();
            if(nextLine == null) return null;
            tok = new StringTokenizer(nextLine);
        }
        return tok.nextToken();
    }

    int readInt(){
        return Integer.parseInt(readString());
    }

    long readLong(){
        return Long.parseLong(readString());
    }

    double readDouble(){
        return Double.parseDouble(readString());
    }
}
",CorCod,335,335,linear
"
/* Java program to convert left-right to 
down-right representation of binary tree */
class
GFG 
{ 

// A Binary Tree Node 
static
class
node 
{ 

int
key; 

node left, right; 

node(
int
key) 

{ 

this
.key = key; 

this
.left = 
null
; 

this
.right = 
null
; 

} 
} 

// An Iterative level order traversal 
// based function to convert left-right 
// to down-right representation. 
static
void
convert(node root) 
{ 

// Base Case 

if
(root == 
null
) 
return
; 


// Recursively convert left 

// an right subtrees 

convert(root.left); 

convert(root.right); 


// If left child is NULL, make right 

// child as left as it is the first child. 

if
(root.left == 
null
) 

root.left = root.right; 


// If left child is NOT NULL, then make 

// right child as right of left child 

else

root.left.right = root.right; 


// Set root's right as NULL 

root.right = 
null
; 
} 

// A utility function to traverse a 
// tree stored in down-right form. 
static
void
downRightTraversal(node root) 
{ 

if
(root != 
null
) 

{ 

System.out.print(root.key + 
"" ""
); 

downRightTraversal(root.right); 

downRightTraversal(root.left); 

} 
} 

// Utility function to create 
// a new tree node 
static
node newNode(
int
key) 
{ 

node temp = 
new
node(
0
); 

temp.key = key; 

temp.left = 
null
; 

temp.right = 
null
; 

return
temp; 
} 

// Driver Code 
public
static
void
main(String[] args) 
{ 

// Let us create binary tree 

// shown in above diagram 

/* 

1 

/ \ 

2 3 

/ \ 

4 5 

/ / \ 

6 7 8 

*/

node root = 
new
node(
1
); 

root.left = newNode(
2
); 

root.right = newNode(
3
); 

root.right.left = newNode(
4
); 

root.right.right = newNode(
5
); 

root.right.left.left = newNode(
6
); 

root.right.right.left = newNode(
7
); 

root.right.right.right = newNode(
8
); 


convert(root); 


System.out.println(
""Traversal of the tree ""
+ 

""converted to down-right form""
); 

downRightTraversal(root); 
} 
} 

// This code is contributed 
// by Prerna Saini ",CorCod,182,182,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 * @author Don Li
 */
public class LogicalExpression {
    
    int N = 256;
    
    void solve() {
        Expression[] E = new Expression[N];
        for (int i = 0; i < N; i++) E[i] = new Expression();
        
        E[Integer.parseInt(""00001111"", 2)].update_f(""x"");
        E[Integer.parseInt(""00110011"", 2)].update_f(""y"");
        E[Integer.parseInt(""01010101"", 2)].update_f(""z"");
        
        for (int l = 2; l < 40; l++) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (E[i].e != null && E[j].t != null && E[i].e.length() + E[j].t.length() + 1 == l) {
                        E[i | j].update_e(E[i].e + '|' + E[j].t);
                    }
                    if (E[i].t != null && E[j].f != null && E[i].t.length() + E[j].f.length() + 1 == l) {
                        E[i & j].update_t(E[i].t + '&' + E[j].f);
                    }
                }
                if (E[i].f != null) E[i ^ (N - 1)].update_f('!' + E[i].f);
            }
        }
        
        String[] res = new String[N];
        for (int i = 0; i < N; i++) res[i] = E[i].calc_best();
        
        int n = in.nextInt();
        for (int i = 0; i < n; i++) {
            int x = Integer.parseInt(in.nextToken(), 2);
            out.println(res[x]);
        }
    }
    
    static class Expression {
        String e, t, f;
        
        Expression() {
        }
        
        public Expression(String e, String t, String f) {
            this.e = e;
            this.t = t;
            this.f = f;
        }
        
        String calc_best() {
            String best = e;
            if (compare(best, t) > 0) best = t;
            if (compare(best, f) > 0) best = f;
            return best;
        }
        
        void update_e(String ne) {
            if (e == null || compare(e, ne) > 0) {
                e = ne;
                update_f('(' + e + ')');
            }
        }
        
        void update_t(String nt) {
            if (t == null || compare(t, nt) > 0) {
                t = nt;
                update_e(t);
            }
        }
        
        void update_f(String nf) {
            if (f == null || compare(f, nf) > 0) {
                f = nf;
                update_t(f);
            }
        }
        
        int compare(String a, String b) {
            if (a.length() != b.length()) return Integer.compare(a.length(), b.length());
            return a.compareTo(b);
        }
    }
    
    public static void main(String[] args) {
        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(System.out);
        new LogicalExpression().solve();
        out.close();
    }
    
    static FastScanner in;
    static PrintWriter out;
    
    static class FastScanner {
        BufferedReader in;
        StringTokenizer st;
        
        public FastScanner(BufferedReader in) {
            this.in = in;
        }
        
        public String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        
        public int nextInt() {
            return Integer.parseInt(nextToken());
        }
        
        public long nextLong() {
            return Long.parseLong(nextToken());
        }
        
        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }
}
",CorCod,410,410,quadratic
"
// A DP based Java program to find maximum tasks. 
class
GFG 
{ 

// Returns the maximum among the 2 numbers 
static
int
max(
int
x, 
int
y) 
{ 

return
(x > y ? x : y); 
} 

// Returns maximum amount of task that can be 
// done till day n 
static
int
maxTasks(
int
[]high, 
int
[]low, 
int
n) 
{ 

// An array task_dp that stores the maximum 

// task done 

int
[] task_dp = 
new
int
[n + 
1
]; 


// If n = 0, no solution exists 

task_dp[
0
] = 
0
; 


// If n = 1, high effort task on that day will 

// be the solution 

task_dp[
1
] = high[
0
]; 


// Fill the entire array determining which 

// task to choose on day i 

for
(
int
i = 
2
; i <= n; i++) 

task_dp[i] = Math.max(high[i - 
1
] + task_dp[i - 
2
], 

low[i - 
1
] + task_dp[i - 
1
]); 

return
task_dp[n]; 
} 

// Driver code 
public
static
void
main(String[] args) 
{ 

int
n = 
5
; 

int
[]high = {
3
, 
6
, 
8
, 
7
, 
6
}; 

int
[]low = {
1
, 
5
, 
4
, 
5
, 
3
}; 

System.out.println(maxTasks(high, low, n)); 
} 
} 

// This code is contributed by Code_Mech. ",CorCod,277,277,linear
"import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class Solution {
	public static void main(String[] args) {
		Solution solution = new Solution();
		System.out.println(solution.solve());
	}

	private int solve() {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int m = in.nextInt();

		int[] a = new int[m];
		for (int i = 0; i < m; ++i) a[i] = in.nextInt();

		if (n > m) return 0;

		Map<Integer, Integer> map = new HashMap<>();
		for (int k: a) map.put(k, map.getOrDefault(k, 0) + 1);

		List<Integer> keySet = new ArrayList<>(map.keySet());
		int end = m / n;

		keySet.sort((u, v) -> -Integer.compare(u, v));
		do {
			int count = 0;
			for (int k: keySet) {
				count += map.get(k) / end;
				if (count >= n) return end;
			}
		} while (--end > 0);

		return 0;
	}
}
",CorCod,638,638,nlogn
"

import java.util.Scanner;

public class Fly {

    static double ERROR = 0.0000001;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n =  scanner.nextInt();
        int m = scanner.nextInt();
        int [] a = new int[n + 1];
        int [] b = new int[n + 1];
        for(int i =0; i< n; i++ ) {
            a[i] = scanner.nextInt();
        }

        for(int i =0; i< n; i++ ) {
            b[i] = scanner.nextInt();
        }
        b[n] = b[0];

        double max =  1000000000;
        double min = 0;
        boolean found = false;
        while (max >= min) {
            double mid = max + min;
             mid /= 2;
             boolean v = isValid(a, b, m, n, mid);
             // System.out.println(""For fuel:"" + mid + "" isValid: "" + v + "", max:"" + max + "", min:"" + min);
             if (v) {
                 max = mid;
             }
             else {
                 min = mid;
             }
             if (max - min <= ERROR && v) {
                 //System.out.println(""max: "" + max + "" , min:"" + min);
                 found = true;
                 break;
             }
             if (max ==  min) {
                 break;
             }
        }
        //System.out.println(found);
        if (found) {
            System.out.println(max);
        }
        else System.out.println(-1);
    }


    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {
        double total =  m + fuel;
        for (int i=0; i<n;i++) {
            double lost = total;
            lost/= a[i];
            total -= lost;

            lost = total;
            lost/=b[i+1];
            total -= lost;
            if ((total-m) < 0) {
                return false;
            }
        }
        if ((total-m) < 0) return false;
        return  true;
    }
}
",CorCod,712,712,nlogn
"
// java program to find maximum 
// sum of bi-tonic sub-sequence 
import
java.io.*; 

class
GFG { 


// Function return maximum sum 

// of Bi-tonic sub-sequence 

static
int
MaxSumBS(
int
arr[], 
int
n) 

{ 

int
max_sum = Integer.MIN_VALUE; 


// MSIBS[i] ==> Maximum sum Increasing Bi-tonic 

// subsequence ending with arr[i] 

// MSDBS[i] ==> Maximum sum Decreasing Bi-tonic 

// subsequence starting with arr[i] 

// Initialize MSDBS and MSIBS values as arr[i] for 

// all indexes 

int
MSIBS[] = 
new
int
[n]; 

int
MSDBS[] = 
new
int
[n]; 

for
(
int
i = 
0
; i < n; i++) { 

MSDBS[i] = arr[i]; 

MSIBS[i] = arr[i]; 

} 


// Compute MSIBS values from left to right */ 

for
(
int
i = 
1
; i < n; i++) 

for
(
int
j = 
0
; j < i; j++) 

if
(arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) 

MSIBS[i] = MSIBS[j] + arr[i]; 


// Compute MSDBS values from right to left 

for
(
int
i = n - 
2
; i >= 
0
; i--) 

for
(
int
j = n - 
1
; j > i; j--) 

if
(arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) 

MSDBS[i] = MSDBS[j] + arr[i]; 


// Find the maximum value of MSIBS[i] + 

// MSDBS[i] - arr[i] 

for
(
int
i = 
0
; i < n; i++) 

max_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); 


// return max sum of bi-tonic 

// sub-sequence 

return
max_sum; 

} 


// Driver program 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
1
, 
15
, 
51
, 
45
, 
33
, 
100
, 
12
, 
18
, 
9
}; 

int
n = arr.length; 

System.out.println(
""Maximum Sum : ""
+ MaxSumBS(arr, n)); 

} 
} 

// This code is contributed by vt_m ",CorCod,421,421,quadratic
"
// Java program to count ways to build street 
// under given constraints 
public
class
GFG { 

// function to count ways of building 
// a street of n rows 

static
long
countWays(
int
n) { 

long
dp[][] = 
new
long
[
2
][n + 
1
]; 


// base case 

dp[
0
][
1
] = 
1
; 

dp[
1
][
1
] = 
2
; 


for
(
int
i = 
2
; i <= n; i++) { 


// ways of building houses in both 

// the spots of ith row 

dp[
0
][i] = dp[
0
][i - 
1
] + dp[
1
][i - 
1
]; 


// ways of building an office in one of 

// the two spots of ith row 

dp[
1
][i] = dp[
0
][i - 
1
] * 
2
+ dp[
1
][i - 
1
]; 

} 


// total ways for n rows 

return
dp[
0
][n] + dp[
1
][n]; 

} 

// driver program for checking above function 

public
static
void
main(String[] args) { 


int
n = 
5
; 

System.out.print(
""Total no of ways with n = ""
+ n 

+ 
"" are: ""
+ countWays(n)); 

} 

} 

/*This code is contributed by PrinciRaj1992*/",CorCod,246,246,linear
"import java.util.*;
import java.math.*;
public class Split {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n= sc.nextInt();
		int k= sc.nextInt();
		int a[] = new int[n];
		int d[] = new int[n-1];
		for(int i=0;i<n;i++) {
			a[i] = sc.nextInt();
			if(i>0)
				d[i-1] = a[i-1] - a[i];
		}
		Arrays.sort(d);
		int t = 0;
		for(int i=0;i<k-1;i++)
			t += d[i];
		System.out.println(a[n-1]-a[0]+t);
	}

}
",CorCod,586,586,nlogn
"import java.util.*;
public class D5 {
public static void main(String[] args)
{
    Scanner input = new Scanner(System.in);
    int a = input.nextInt(), v = input.nextInt();
    int l = input.nextInt(), d = input.nextInt(), w = input.nextInt();
    double lo = 0, hi = v;
    for(int iter = 0; iter < 1000; iter++)
    {
        double mid = (lo+hi)/2;
        if(can(mid, a, d, w)) lo = mid;
        else hi = mid;
    }
    //System.out.println(lo);
    double t1 = lo / a;
    double gone = .5 * t1 * t1 * a;
    if(lo > w)
    {
        gone += -a * .5 * (lo - w) / a * (lo - w) / a + lo * (lo - w) / a;
        t1 += (lo - w) / a;
    }
    t1 += (d - gone) / lo;
    //System.out.println(t1);
    double v0 = Math.min(lo, w);
    double togo = l - d;
    double toAdd = (-v0 + Math.sqrt(v0 * v0 + 4 * togo * .5 * a)) / a;
    if(toAdd * a + v0 > v)
    {
        double tt = (v - v0) / a;
        t1 += tt;
        togo -= .5 * a * tt * tt + v0 * tt;
        t1 += togo / v;
    }
    else t1 += toAdd;
    System.out.println(t1);
}
static boolean can(double v, double a, double d, double max)
{
    double t1 = v / a;
    double distGone = .5 * a * t1 * t1;
    if(v > max)
    {
        t1 = (v - max) / a;
        distGone += -.5 * a * t1 * t1 + v * t1;
    }
    return distGone <= d;
}
}
",CorCod,876,876,constant
"
// A O(n) and O(n) extra space Java program to find 
// longest common subarray of two binary arrays with 
// same sum 

class
Test 
{ 

static
int
arr1[] = 
new
int
[]{
0
, 
1
, 
0
, 
1
, 
1
, 
1
, 
1
}; 

static
int
arr2[] = 
new
int
[]{
1
, 
1
, 
1
, 
1
, 
1
, 
0
, 
1
}; 


// Returns length of the longest common sum in arr1[] 

// and arr2[]. Both are of same size n. 

static
int
longestCommonSum(
int
n) 

{ 

// Initialize result 

int
maxLen = 
0
; 


// Initialize prefix sums of two arrays 

int
preSum1 = 
0
, preSum2 = 
0
; 


// Create an array to store staring and ending 

// indexes of all possible diff values. diff[i] 

// would store starting and ending points for 

// difference ""i-n"" 

int
diff[] = 
new
int
[
2
*n+
1
]; 


// Initialize all starting and ending values as -1. 

for
(
int
i = 
0
; i < diff.length; i++) { 

diff[i] = -
1
; 

} 


// Traverse both arrays 

for
(
int
i=
0
; i<n; i++) 

{ 

// Update prefix sums 

preSum1 += arr1[i]; 

preSum2 += arr2[i]; 


// Comput current diff and index to be used 

// in diff array. Note that diff can be negative 

// and can have minimum value as -1. 

int
curr_diff = preSum1 - preSum2; 

int
diffIndex = n + curr_diff; 


// If current diff is 0, then there are same number 

// of 1's so far in both arrays, i.e., (i+1) is 

// maximum length. 

if
(curr_diff == 
0
) 

maxLen = i+
1
; 


// If current diff is seen first time, then update 

// starting index of diff. 

else
if
( diff[diffIndex] == -
1
) 

diff[diffIndex] = i; 


// Current diff is already seen 

else

{ 

// Find length of this same sum common span 

int
len = i - diff[diffIndex]; 


// Update max len if needed 

if
(len > maxLen) 

maxLen = len; 

} 

} 

return
maxLen; 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

System.out.print(
""Length of the longest common span with same sum is ""
); 

System.out.println(longestCommonSum(arr1.length)); 

} 
} ",CorCod,214,214,linear
"
// Java program to find minimum 
// increment/decrement operations 
// to make array elements same. 
import
java.util.Arrays; 
import
java.io.*; 

class
GFG 
{ 
static
int
MinOperation(
int
a[], 

int
b[], 

int
n) 
{ 

// sorting both arrays 

// in ascending order 

Arrays.sort(a); 

Arrays.sort(b); 



// variable to store 

// the final result 

int
result = 
0
; 


// After sorting both arrays 

// Now each array is in non- 

// decreasing order. Thus, 

// we will now compare each 

// element of the array and 

// do the increment or decrement 

// operation depending upon the 

// value of array b[]. 

for
(
int
i = 
0
; i < n; ++i) 

{ 

if
(a[i] > b[i]) 

result = result + 

Math.abs(a[i] - b[i]); 


else
if
(a[i] < b[i]) 

result = result + 

Math.abs(a[i] - b[i]); 

} 


return
result; 
} 

// Driver code 
public
static
void
main (String[] args) 
{ 

int
a[] = {
3
, 
1
, 
1
}; 

int
b[] = {
1
, 
2
, 
2
}; 

int
n = a.length; 

System.out.println(MinOperation(a, b, n)); 
} 
} 

// This code is contributed 
// by akt_mit ",CorCod,681,681,nlogn
"
// Java program to rearrange characters in a string 
// so that no two adjacent characters are same. 
import
java.io.*; 
import
java.util.*; 

class
KeyComparator 
implements
Comparator<Key> { 


// Overriding compare()method of Comparator 

public
int
compare(Key k1, Key k2) 

{ 

if
(k1.freq < k2.freq) 

return
1
; 

else
if
(k1.freq > k2.freq) 

return
-
1
; 

return
0
; 

} 
} 

class
Key { 

int
freq; 
// store frequency of character 

char
ch; 

Key(
int
val, 
char
c) 

{ 

freq = val; 

ch = c; 

} 
} 

class
GFG { 

static
int
MAX_CHAR = 
26
; 


// Function to rearrange character of a string 

// so that no char repeat twice 

static
void
rearrangeString(String str) 

{ 

int
n = str.length(); 


// Store frequencies of all characters in string 

int
[] count = 
new
int
[MAX_CHAR]; 


for
(
int
i = 
0
; i < n; i++) 

count[str.charAt(i) - 
'a'
]++; 


// Insert all characters with their frequencies 

// into a priority_queue 

PriorityQueue<Key> pq = 
new
PriorityQueue<>(
new

KeyComparator()); 

for
(
char
c = 
'a'
; c <= 
'z'
; c++) { 

int
val = c - 
'a'
; 

if
(count[val] > 
0
) 

pq.add(
new
Key(count[val], c)); 

} 


// 'str' that will store resultant value 

str = 
""""
; 


// work as the previous visited element 

// initial previous element be. ( '#' and 

// it's frequency '-1' ) 

Key prev = 
new
Key(-
1
, 
'#'
); 


// traverse queue 

while
(pq.size() != 
0
) { 


// pop top element from queue and add it 

// to string. 

Key k = pq.peek(); 

pq.poll(); 

str = str + k.ch; 


// If frequency of previous character is less 

// than zero that means it is useless, we 

// need not to push it 

if
(prev.freq > 
0
) 

pq.add(prev); 


// make current character as the previous 'char' 

// decrease frequency by 'one' 

(k.freq)--; 

prev = k; 

} 


// If length of the resultant string and original 

// string is not same then string is not valid 

if
(n != str.length()) 

System.out.println(
"" Not valid String ""
); 

else

System.out.println(str); 

} 


// Driver program to test above function 

public
static
void
main(String args[]) 

{ 

String str = 
""bbbaa""
; 

rearrangeString(str); 

} 
} 

// This code is contributed by rachana soma ",CorCod,354,354,linear
"
// Java program to find the all full nodes in 
// a given binary tree 
public
class
FullNodes { 


// Traverses given tree in Inorder fashion and 

// prints all nodes that have both children as 

// non-empty. 

public
static
void
findFullNode(Node root) 

{ 

if
(root != 
null
) 

{ 

findFullNode(root.left); 

if
(root.left != 
null
&& root.right != 
null
) 

System.out.print(root.data+
"" ""
); 

findFullNode(root.right); 

} 

} 


public
static
void
main(String args[]) { 

Node root = 
new
Node(
1
); 

root.left = 
new
Node(
2
); 

root.right = 
new
Node(
3
); 

root.left.left = 
new
Node(
4
); 

root.right.left = 
new
Node(
5
); 

root.right.right = 
new
Node(
6
); 

root.right.left.right = 
new
Node(
7
); 

root.right.right.right = 
new
Node(
8
); 

root.right.left.right.left = 
new
Node(
9
); 

findFullNode(root); 

} 
} 

/* A binary tree node */
class
Node 
{ 

int
data; 

Node left, right; 

Node(
int
data) 

{ 

left=right=
null
; 

this
.data=data; 

} 
}; 
//This code is contributed by Gaurav Tiwari ",CorCod,328,328,linear
"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Ideone
{
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
			long n,s,p;
			Scanner in=new Scanner(System.in);
			n=in.nextLong();
			s=in.nextLong();
			if(n==1 && s<=1)
			{
			    System.out.print(n-1);
			}
	        else if(s<n)
	        {
	            if(s%2!=0)
		        {System.out.print(s/2);}
		        else
		        {System.out.print(s/2-1);}
	        }
	        else if(s==n)
	{
	    if(s%2==0)
		{System.out.println((n/2)-1);}
		else
		{System.out.println(n/2);}
	}
	else if(s<=(2*n-1))	
	{
		System.out.print((2*n+1-s)/2);
	}
	else
	{
		System.out.print(0);
	}
	}
}",CorCod,817,817,constant
"
// Java program to find minimum sum of two numbers 
// formed from all digits in a given array. 
import
java.util.PriorityQueue; 

class
MinSum 
{ 

// Returns sum of two numbers formed 

// from all digits in a[] 

public
static
long
solve(
int
[] a) 

{ 

// min Heap 

PriorityQueue<Integer> pq = 
new
PriorityQueue<Integer>(); 


// to store the 2 numbers formed by array elements to 

// minimize the required sum 

StringBuilder num1 = 
new
StringBuilder(); 

StringBuilder num2 = 
new
StringBuilder(); 


// Adding elements in Priority Queue 

for
(
int
x : a) 

pq.add(x); 


// checking if the priority queue is non empty 

while
(!pq.isEmpty()) 

{ 

num1.append(pq.poll()+ 
""""
); 

if
(!pq.isEmpty()) 

num2.append(pq.poll()+ 
""""
); 

} 


// the required sum calculated 

long
sum = Long.parseLong(num1.toString()) + 

Long.parseLong(num2.toString()); 


return
sum; 

} 


// Driver code 

public
static
void
main (String[] args) 

{ 

int
arr[] = {
6
, 
8
, 
4
, 
5
, 
2
, 
3
}; 

System.out.println(
""The required sum is ""
+ solve(arr)); 

} 
} ",CorCod,724,724,nlogn
"import java.util.*;
import java.io.*;
import java.math.*;
import java.awt.geom.*;

public class FunctionHeight {
    public static void main(String[] args) {
        MyScanner sc = new MyScanner();
        long n = sc.nl();
        long k = sc.nl();
        long ans = (n+k-1)/n;
        System.out.println(ans);
    }

    /////////// TEMPLATE FROM HERE /////////////////
    private static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int ni() {
            return Integer.parseInt(next());
        }

        float nf() {
            return Float.parseFloat(next());
        }

        long nl() {
            return Long.parseLong(next());
        }

        double nd() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}",CorCod,871,871,constant
"import java.util.Arrays;
import java.util.Scanner;
import java.util.stream.IntStream;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		int[] p = new int[n / 2];
		for (int i = 0; i < p.length; i++) {
			p[i] = sc.nextInt();
		}
		System.out.println(solve(p));

		sc.close();
	}

	static int solve(int[] p) {
		return Math.min(computeMoveNum(p, 1), computeMoveNum(p, 2));
	}

	static int computeMoveNum(int[] p, int offset) {
		Arrays.sort(p);

		return IntStream.range(0, p.length).map(i -> Math.abs(p[i] - (i * 2 + offset))).sum();
	}
}
",CorCod,603,603,nlogn
"
// Java code to calculate maximum unique 
// element of every segment of array 
import
java.io.*; 
import
java.util.*; 
class
GFG { 


static
void
find_max(
int
[] A, 
int
N, 
int
K) 

{ 

// Storing counts of first K-1 elements 

// Also storing distinct elements. 

HashMap<Integer, Integer> Count = 
new
HashMap<>(); 

for
(
int
i = 
0
; i < K - 
1
; i++) 

if
(Count.containsKey(A[i])) 

Count.put(A[i], 
1
+ Count.get(A[i])); 

else

Count.put(A[i], 
1
); 


TreeSet<Integer> Myset = 
new
TreeSet<Integer>(); 

for
(Map.Entry x : Count.entrySet()) { 

if
(Integer.parseInt(String.valueOf(x.getValue())) == 
1
) 

Myset.add(Integer.parseInt(String.valueOf(x.getKey()))); 

} 


// Before every iteration of this loop, 

// we maintain that K-1 elements of current 

// window are processed. 

for
(
int
i = K - 
1
; i < N; i++) { 


// Process K-th element of current window 

if
(Count.containsKey(A[i])) 

Count.put(A[i], 
1
+ Count.get(A[i])); 

else

Count.put(A[i], 
1
); 


if
(Integer.parseInt(String.valueOf(Count.get(A[i]))) == 
1
) 

Myset.add(A[i]); 

else

Myset.remove(A[i]); 


// If there are no distinct 

// elements in current window 

if
(Myset.size() == 
0
) 

System.out.println(
""Nothing""
); 


// Set is ordered and last element 

// of set gives us maximum element. 

else

System.out.println(Myset.last()); 


// Remove first element of current 

// window before next iteration. 

int
x = A[i - K + 
1
]; 

Count.put(x, Count.get(x) - 
1
); 


if
(Integer.parseInt(String.valueOf(Count.get(x))) == 
1
) 

Myset.add(x); 

if
(Integer.parseInt(String.valueOf(Count.get(x))) == 
0
) 

Myset.remove(x); 

} 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
[] a = { 
1
, 
2
, 
2
, 
3
, 
3
}; 

int
n = a.length; 

int
k = 
3
; 

find_max(a, n, k); 

} 
} 

// This code is contributed by rachana soma ",CorCod,665,665,nlogn
"
// Java program to count occurrences 
// of an element 

class
Main 
{ 

/* if x is present in arr[] then returns 

the count of occurrences of x, 

otherwise returns -1. */

static
int
count(
int
arr[], 
int
x, 
int
n) 

{ 

// index of first occurrence of x in arr[0..n-1] 

int
i; 


// index of last occurrence of x in arr[0..n-1] 

int
j; 


/* get the index of first occurrence of x */

i = first(arr, 
0
, n-
1
, x, n); 


/* If x doesn't exist in arr[] then return -1 */

if
(i == -
1
) 

return
i; 


/* Else get the index of last occurrence of x. 

Note that we are only looking in the 

subarray after first occurrence */

j = last(arr, i, n-
1
, x, n); 


/* return count */

return
j-i+
1
; 

} 


/* if x is present in arr[] then returns the 

index of FIRST occurrence of x in arr[0..n-1], 

otherwise returns -1 */

static
int
first(
int
arr[], 
int
low, 
int
high, 
int
x, 
int
n) 

{ 

if
(high >= low) 

{ 

/*low + (high - low)/2;*/

int
mid = (low + high)/
2
; 

if
( ( mid == 
0
|| x > arr[mid-
1
]) && arr[mid] == x) 

return
mid; 

else
if
(x > arr[mid]) 

return
first(arr, (mid + 
1
), high, x, n); 

else

return
first(arr, low, (mid -
1
), x, n); 

} 

return
-
1
; 

} 


/* if x is present in arr[] then returns the 

index of LAST occurrence of x in arr[0..n-1], 

otherwise returns -1 */

static
int
last(
int
arr[], 
int
low, 
int
high, 
int
x, 
int
n) 

{ 

if
(high >= low) 

{ 

/*low + (high - low)/2;*/

int
mid = (low + high)/
2
; 

if
( ( mid == n-
1
|| x < arr[mid+
1
]) && arr[mid] == x ) 

return
mid; 

else
if
(x < arr[mid]) 

return
last(arr, low, (mid -
1
), x, n); 

else

return
last(arr, (mid + 
1
), high, x, n); 

} 

return
-
1
; 

} 


public
static
void
main(String args[]) 

{ 

int
arr[] = {
1
, 
2
, 
2
, 
3
, 
3
, 
3
, 
3
}; 


// Element to be counted in arr[] 

int
x = 
3
; 

int
n = arr.length; 

int
c = count(arr, x, n); 

System.out.println(x+
"" occurs ""
+c+
"" times""
); 

} 
} ",CorCod,880,880,logn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.StringTokenizer;
import java.io.Writer;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author zodiacLeo
 */
public class Main
{
    public static void main(String[] args)
    {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        FastPrinter out = new FastPrinter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }
    
    static class TaskC
    {
        public void solve(int testNumber, FastScanner in, FastPrinter out)
        {
            int n = in.nextInt();
            long[] a = new long[n];
            long[] b = new long[n];
            for (int i = 0; i < n; i++)
            {
                b[i] = a[i] = in.nextInt();
                if (i > 0)
                {
                    a[i] += a[i - 1];
                }
            }
            for (int i = n - 2; i >= 0; i--)
            {
                b[i] += b[i + 1];
            }
            
            long sum1 = 0;
            long sum3 = 0;
            long result = 0;
            for (int i = 0, j = n - 1; i < j; )
            {
                sum1 = a[i];
                sum3 = b[j];
                if (sum1 == sum3)
                {
                    result = Math.max(result, sum1);
                    i++;
                    j--;
                }
                else if (sum1 < sum3)
                {
                    i++;
                }
                else
                {
                    j--;
                }
            }
            out.println(result);
            
            
        }
        
    }
    
    static class FastScanner
    {
        public BufferedReader br;
        public StringTokenizer st;
        
        public FastScanner(InputStream is)
        {
            br = new BufferedReader(new InputStreamReader(is));
        }
        
        public FastScanner(File f)
        {
            try
            {
                br = new BufferedReader(new FileReader(f));
            } catch (FileNotFoundException e)
            {
                e.printStackTrace();
            }
        }
        
        public String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                String s = null;
                try
                {
                    s = br.readLine();
                } catch (IOException e)
                {
                    e.printStackTrace();
                }
                if (s == null)
                {
                    return null;
                }
                st = new StringTokenizer(s);
            }
            return st.nextToken();
        }
        
        public int nextInt()
        {
            return Integer.parseInt(next());
        }
        
    }
    
    static class FastPrinter extends PrintWriter
    {
        public FastPrinter(OutputStream out)
        {
            super(out);
        }
        
        public FastPrinter(Writer out)
        {
            super(out);
        }
        
    }
}

",CorCod,202,202,linear
"
// Java program to find longest 
// alternating subsequence in an array 
import
java.io.*; 

class
GFG { 

// Function to return longest 
// alternating subsequence length 
static
int
zzis(
int
arr[], 
int
n) 
{ 

/*las[i][0] = Length of the longest 

alternating subsequence ending at 

index i and last element is 

greater than its previous element 

las[i][1] = Length of the longest 

alternating subsequence ending at 

index i and last element is 

smaller than its previous 

element */

int
las[][] = 
new
int
[n][
2
]; 


/* Initialize all values from 1 */

for
(
int
i = 
0
; i < n; i++) 

las[i][
0
] = las[i][
1
] = 
1
; 


int
res = 
1
; 
// Initialize result 


/* Compute values in bottom up manner */

for
(
int
i = 
1
; i < n; i++) 

{ 

// Consider all elements as 

// previous of arr[i] 

for
(
int
j = 
0
; j < i; j++) 

{ 

// If arr[i] is greater, then 

// check with las[j][1] 

if
(arr[j] < arr[i] && 

las[i][
0
] < las[j][
1
] + 
1
) 

las[i][
0
] = las[j][
1
] + 
1
; 


// If arr[i] is smaller, then 

// check with las[j][0] 

if
( arr[j] > arr[i] && 

las[i][
1
] < las[j][
0
] + 
1
) 

las[i][
1
] = las[j][
0
] + 
1
; 

} 


/* Pick maximum of both values at 

index i */

if
(res < Math.max(las[i][
0
], las[i][
1
])) 

res = Math.max(las[i][
0
], las[i][
1
]); 

} 


return
res; 
} 

/* Driver program */
public
static
void
main(String[] args) 
{ 

int
arr[] = { 
10
, 
22
, 
9
, 
33
, 
49
, 

50
, 
31
, 
60
}; 

int
n = arr.length; 

System.out.println(
""Length of Longest ""
+ 

""alternating subsequence is ""
+ 

zzis(arr, n)); 
} 
} 
// This code is contributed by Prerna Saini ",CorCod,531,531,quadratic
"
// Java program to find Majority 
// element in an array 

import
java.io.*; 

class
GFG { 

// Function to find Majority element 
// in an array 
static
void
findMajority(
int
arr[], 
int
n) 
{ 

int
maxCount = 
0
; 

int
index = -
1
; 
// sentinels 

for
(
int
i = 
0
; i < n; i++) 

{ 

int
count = 
0
; 

for
(
int
j = 
0
; j < n; j++) 

{ 

if
(arr[i] == arr[j]) 

count++; 

} 


// update maxCount if count of 

// current element is greater 

if
(count > maxCount) 

{ 

maxCount = count; 

index = i; 

} 

} 


// if maxCount is greater than n/2 

// return the corresponding element 

if
(maxCount > n/
2
) 

System.out.println (arr[index]); 


else

System.out.println (
""No Majority Element""
); 
} 

// Driver code 

public
static
void
main (String[] args) { 


int
arr[] = {
1
, 
1
, 
2
, 
1
, 
3
, 
5
, 
1
}; 

int
n = arr.length; 


// Function calling 

findMajority(arr, n); 

} 
//This code is contributed by ajit. 
} ",CorCod,498,498,quadratic
"
//A Java program to check if a given binary tree is complete or not 

import
java.util.LinkedList; 
import
java.util.Queue; 

public
class
CompleteBTree 
{ 

/* A binary tree node has data, a pointer to left child 

and a pointer to right child */

static
class
Node 

{ 

int
data; 

Node left; 

Node right; 


// Constructor 

Node(
int
d) 

{ 

data = d; 

left = 
null
; 

right = 
null
; 

} 

} 


/* Given a binary tree, return true if the tree is complete 

else false */

static
boolean
isCompleteBT(Node root) 

{ 

// Base Case: An empty tree is complete Binary Tree 

if
(root == 
null
) 

return
true
; 


// Create an empty queue 

Queue<Node> queue =
new
LinkedList<>(); 


// Create a flag variable which will be set true 

// when a non full node is seen 

boolean
flag = 
false
; 


// Do level order traversal using queue. 

queue.add(root); 

while
(!queue.isEmpty()) 

{ 

Node temp_node = queue.remove(); 


/* Check if left child is present*/

if
(temp_node.left != 
null
) 

{ 

// If we have seen a non full node, and we see a node 

// with non-empty left child, then the given tree is not 

// a complete Binary Tree 

if
(flag == 
true
) 

return
false
; 


// Enqueue Left Child 

queue.add(temp_node.left); 

} 

// If this a non-full node, set the flag as true 

else

flag = 
true
; 


/* Check if right child is present*/

if
(temp_node.right != 
null
) 

{ 

// If we have seen a non full node, and we see a node 

// with non-empty right child, then the given tree is not 

// a complete Binary Tree 

if
(flag == 
true
) 

return
false
; 


// Enqueue Right Child 

queue.add(temp_node.right); 


} 

// If this a non-full node, set the flag as true 

else

flag = 
true
; 

} 

// If we reach here, then the tree is complete Binary Tree 

return
true
; 

} 


/* Driver program to test above functions*/

public
static
void
main(String[] args) 

{ 


/* Let us construct the following Binary Tree which 

is not a complete Binary Tree 

1 

/ \ 

2 3 

/ \ \ 

4 5 6 

*/


Node root = 
new
Node(
1
); 

root.left = 
new
Node(
2
); 

root.right = 
new
Node(
3
); 

root.left.left = 
new
Node(
4
); 

root.left.right = 
new
Node(
5
); 

root.right.right = 
new
Node(
6
); 


if
(isCompleteBT(root) == 
true
) 

System.out.println(
""Complete Binary Tree""
); 

else

System.out.println(
""NOT Complete Binary Tree""
); 

} 

} 
//This code is contributed by Sumit Ghosh ",CorCod,270,270,linear
"import java.util.*;

public class helloWorld 
{
	public static void main(String[] args) 
	{		
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int cnt = 0;
		String ans = ""Yes"";
		
		for(int i = 0; i < n; i++)
			cnt += in.nextInt();
		for(int i = 0; i < n; i++)
			cnt -= in.nextInt();
		
		if(cnt < 0)
			ans = ""No"";
		
		System.out.println(ans);
				
		in.close();
	}
}
",CorCod,256,256,linear
"
// Java program to divide n integers 
// in two groups such that absolute 
// difference of their sum is minimum 
import
java.io.*; 
import
java.util.*; 

class
GFG 
{ 

// To print vector along size 

static
void
printVector(Vector<Integer> v) 

{ 

// Print vector size 

System.out.println(v.size()); 


// Print vector elements 

for
(
int
i = 
0
; i < v.size(); i++) 

System.out.print(v.get(i) + 
"" ""
); 


System.out.println(); 

} 


// To divide n in two groups such that 

// absolute difference of their sum is 

// minimum 

static
void
findTwoGroup(
int
n) 

{ 

// Find sum of all elements upto n 

int
sum = n * (n + 
1
) / 
2
; 


// Sum of elements of group1 

int
group1Sum = sum / 
2
; 


Vector<Integer> group1 = 
new
Vector<Integer>(); 

Vector<Integer> group2 = 
new
Vector<Integer>(); 


for
(
int
i = n; i > 
0
; i--) { 


// If sum is greater then or equal 

// to 0 include i in group1 

// otherwise include in group2 

if
(group1Sum - i >= 
0
) { 


group1.add(i); 


// Decrease sum of group1 

group1Sum -= i; 

} 

else
{ 

group2.add(i); 

} 

} 


// Print both the groups 

printVector(group1); 

printVector(group2); 

} 


// Driver code 

public
static
void
main (String[] args) 

{ 

int
n = 
5
; 

findTwoGroup(n); 

} 
} 

// This code is contributed by Gitanjali. ",CorCod,104,104,linear
"
// Java program to make GCD 
// of array a mutiple of k. 
import
java.io.*; 

class
GFG 
{ 
static
int
MinOperation(
int
a[], 

int
n, 
int
k) 
{ 


int
result = 
0
; 


for
(
int
i = 
0
; i < n; ++i) 

{ 


// If array value is not 1 

// and it is greater than k 

// then we can increase the 

// or decrease the remainder 

// obtained by dividing k 

// from the ith value of array 

// so that we get the number 

// which is either closer to k 

// or its multiple 

if
(a[i] != 
1
&& a[i] > k) 

{ 

result = result + 

Math.min(a[i] % k, 

k - a[i] % k); 

} 

else

{ 


// Else we only have one 

// choice which is to 

// increment the value 

// to make equal to k 

result = result + k - a[i]; 

} 

} 


return
result; 
} 

// Driver code 
public
static
void
main (String[] args) 
{ 

int
arr[] = {
4
, 
5
, 
6
}; 

int
n = arr.length; 

int
k = 
5
; 

System.out.println(MinOperation(arr, n, k)); 
} 
} 

// This code is contributed 
// by akt_mit ",CorCod,79,79,linear
"import java.io.*;
import java.util.*;
public class Codechef{
	static int max=Integer.MIN_VALUE;
	static int res=0;
	static int[] checkMax(int arr[],int j){
             int sum=0;
             int x=arr[j];
        		while(x!=0){
        		        if(j+1==15){
        		        	j=0;
        		        }else{
        		        	arr[j+1]=arr[j+1]+1;
        		        }
        		        // if(arr[j+1]%2==0){
        		        // 	sum=sum+arr[j+1];
        		        // 	if(sum>=max){
        		        // 	max=sum;
        		        // }
        		        // }

        		        
        		        x--;
        		        j++;
        		}
        		     return arr;

	}
      

    public static void main(String []args){
       Scanner sc = new Scanner (System.in);
    long a [] = new long [14];
    long b [] = new long [14];
    long p,q,r,s,max = 0;
    for(int i = 0; i < 14; i++) a[i] = sc.nextInt();
    for(int i = 0; i < 14; i++){
      p = a[i]%14;
      q = a[i]/14;
      r = 0;
      s = 0;
      for(int j = 0; j < 14; j++) b[j] = a[j];
      b[i] = 0;
      int j = (i+1)%14;
      for(; r < p; r++) {
        b[j]++;
        j=(j+1)%14;
      }
      for( j = 0; j < 14; j++) {
        b[j] += q;
        if(b[j] % 2 == 0) s+= b[j];
      }
      max = Math.max(max,s);
    }
    System.out.println(max);



    }

}",CorCod,765,765,constant
"
// Java program to print a string with 
// no adjacent duplicates by doing 
// minimum changes to original string 
import
java.util.*; 
import
java.lang.*; 

public
class
GfG{ 


// Function to print simple string 

public
static
String noAdjacentDup(String s1) 

{ 

int
n = s1.length(); 

char
[] s = s1.toCharArray(); 

for
(
int
i = 
1
; i < n; i++) 

{ 

// If any two adjacent 

// characters are equal 

if
(s[i] == s[i - 
1
]) 

{ 

// Initialize it to 'a' 

s[i] = 
'a'
; 


// Traverse the loop until it 

// is different from the left 

// and right letter. 

while
(s[i] == s[i - 
1
] || 

(i + 
1
< n && s[i] == s[i + 
1
])) 

s[i]++; 


i++; 

} 

} 

return
(
new
String(s)); 

} 


// Driver function 

public
static
void
main(String argc[]){ 


String s = 
""geeksforgeeks""
; 

System.out.println(noAdjacentDup(s)); 


} 

} 

/* This code is contributed by Sagar Shukla */",CorCod,320,320,linear
"
// Java Program for finding K-th largest Node using O(1) 
// extra memory and reverse Morris traversal. 
class
GfG 
{ 

static
class
Node 
{ 

int
data; 

Node left, right; 
} 

// helper function to create a new Node 
static
Node newNode(
int
data) 
{ 

Node temp = 
new
Node(); 

temp.data = data; 

temp.right = 
null
; 

temp.left = 
null
; 

return
temp; 
} 

static
Node KthLargestUsingMorrisTraversal(Node root, 
int
k) 
{ 

Node curr = root; 

Node Klargest = 
null
; 


// count variable to keep count of visited Nodes 

int
count = 
0
; 


while
(curr != 
null
) 

{ 

// if right child is NULL 

if
(curr.right == 
null
) 

{ 


// first increment count and check if count = k 

if
(++count == k) 

Klargest = curr; 


// otherwise move to the left child 

curr = curr.left; 

} 


else

{ 


// find inorder successor of current Node 

Node succ = curr.right; 


while
(succ.left != 
null
&& succ.left != curr) 

succ = succ.left; 


if
(succ.left == 
null
) 

{ 


// set left child of successor to the 

// current Node 

succ.left = curr; 


// move current to its right 

curr = curr.right; 

} 


// restoring the tree back to original binary 

// search tree removing threaded links 

else

{ 


succ.left = 
null
; 


if
(++count == k) 

Klargest = curr; 


// move current to its left child 

curr = curr.left; 

} 

} 

} 

return
Klargest; 
} 

// Driver code 
public
static
void
main(String[] args) 
{ 

// Your Java Code 

/* Constructed binary tree is 

4 

/ \ 

2 7 

/ \ / \ 

1 3 6 10 */


Node root = newNode(
4
); 

root.left = newNode(
2
); 

root.right = newNode(
7
); 

root.left.left = newNode(
1
); 

root.left.right = newNode(
3
); 

root.right.left = newNode(
6
); 

root.right.right = newNode(
10
); 


System.out.println(
""Finding K-th largest Node in BST : ""
+ 

KthLargestUsingMorrisTraversal(root, 
2
).data); 
} 
} ",CorCod,163,163,linear
"import java.util.Scanner;

public class NickAndArray {
	public static void main(String args[])
	{
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		 int array[]=new int[n];
		 int max=Integer.MAX_VALUE;
		 int index=0;
		 for(int i=0;i<n;i++)
		 {
			 int k=sc.nextInt();
			 array[i]=k;
			 if(array[i]>=0)
			 {
				 array[i]=-array[i]-1;
			 }
			 if(array[i]<max)
			 {
				 max=array[i];
				 index=i;
				 
			 }
		 }
		 if(n%2!=0)
		 {
			 array[index]=-array[index]-1;
		 }
		 for(int i=0;i<n;i++)
		 {
			 System.out.print(array[i]+"" "" );
		 }
	}

}
",CorCod,347,347,linear
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.util.List;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        public void solve(int testNumber, FastReader in, PrintWriter out) {
            Debug debug = new Debug();
            int n = in.nextInt();
            int K = in.nextInt();

            List<Integer>[] g = GraphUtils.nextU(in, n, n - 1, true);
            int[] center = GraphUtils.getCenter(g);
            if (center.length == 2) {
                out.println(""No"");
                return;
            }

            int[][] pars = GraphUtils.parents3(g, center[0]);
            int[] par = pars[0], ord = pars[1], depth = pars[2];
            int[] deg = new int[n];
            for (int i = 0; i < n; ++i) deg[i] = g[i].size();

            if (deg[center[0]] < 3) {
                out.println(""No"");
                return;
            }

            // all leaves depth = K
            for (int i = 0; i < n; ++i) {
                if (deg[i] == 1) {
                    if (depth[i] != K) {
                        out.println(""No"");
                        return;
                    }
                } else if (i != center[0]) {
                    if (deg[i] < 4) {
                        out.println(""No"");
                        return;
                    }
                }
            }
            out.println(""Yes"");
        }

    }

    static class GraphUtils {
        public static List<Integer>[] nextU(FastReader in, int n, int m, boolean oneIndexed) {
            int diff = oneIndexed ? 1 : 0;
            List<Integer>[] g = new List[n];
            for (int i = 0; i < n; ++i) g[i] = new ArrayList<>();
            for (int i = 0; i < m; ++i) {
                int u = in.nextInt() - diff;
                int v = in.nextInt() - diff;
                g[u].add(v);
                g[v].add(u);
            }
            return g;
        }

        public static int[][] parents3(List<Integer>[] g, int root) {
            int n = g.length;
            int[] par = new int[n];
            ArrayUtils.fill(par, -1);

            int[] depth = new int[n];
            depth[0] = 0;

            int[] q = new int[n];
            q[0] = root;
            for (int p = 0, r = 1; p < r; p++) {
                int cur = q[p];
                for (int nex : g[cur]) {
                    if (par[cur] != nex) {
                        q[r++] = nex;
                        par[nex] = cur;
                        depth[nex] = depth[cur] + 1;
                    }
                }
            }
            return new int[][]{par, q, depth};
        }

        public static int[] getCenter(List<Integer>[] g) {
            int n = g.length;
            int[] q = new int[n];
            int[] deg = new int[n];
            int p = 0;
            for (int i = 0; i < n; i++) {
                deg[i] = g[i].size();
                if (g[i].size() <= 1) { // < for n=1
                    q[p++] = i;
                }
            }
            int bound = p == n ? 0 : p;
            for (int z = 0; z < p; z++) {
                if (bound == z && p < n) bound = p;
                int cur = q[z];
                deg[cur]--;
                for (int e : g[cur]) {
                    if (--deg[e] == 1) q[p++] = e;
                }
            }
            assert p == n;
            assert bound >= n - 2 && bound < n;
            if (bound == n - 2) {
                return new int[]{q[n - 2], q[n - 1]};
            } else {
                return new int[]{q[n - 1]};
            }
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int pnumChars;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        private int pread() {
            if (pnumChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= pnumChars) {
                curChar = 0;
                try {
                    pnumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (pnumChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            int res = 0;
            do {
                if (c == ',') {
                    c = pread();
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }

    static class ArrayUtils {
        public static void fill(int[] array, int value) {
            Arrays.fill(array, value);
        }

    }

    static class Debug {
        PrintWriter out;
        boolean oj;
        boolean system;
        long timeBegin;
        Runtime runtime;

        public Debug(PrintWriter out) {
            oj = System.getProperty(""ONLINE_JUDGE"") != null;
            this.out = out;
            this.timeBegin = System.currentTimeMillis();
            this.runtime = Runtime.getRuntime();
        }

        public Debug() {
            system = true;
            oj = System.getProperty(""ONLINE_JUDGE"") != null;
            OutputStream outputStream = System.out;
            this.out = new PrintWriter(outputStream);
            this.timeBegin = System.currentTimeMillis();
            this.runtime = Runtime.getRuntime();
        }

    }
}

",CorCod,356,356,linear
"
// Java program to flip a binary tree 
import
java.util.*; 
class
GFG 
{ 

// A binary tree node 
static
class
Node 
{ 

int
data; 

Node left, right; 
}; 

// Utility function to create 
// a new Binary Tree Node 

static
Node newNode(
int
data) 
{ 

Node temp = 
new
Node(); 

temp.data = data; 

temp.left = temp.right = 
null
; 

return
temp; 
} 

// method to flip the binary tree 
static
Node flipBinaryTree(Node root) 
{ 

// Initialization of pointers 

Node curr = root; 

Node next = 
null
; 

Node temp = 
null
; 

Node prev = 
null
; 


// Iterate through all left nodes 

while
(curr != 
null
) 

{ 

next = curr.left; 


// Swapping nodes now, need 

// temp to keep the previous 

// right child 


// Making prev's right 

// as curr's left child 

curr.left = temp; 


// Storing curr's right child 

temp = curr.right; 


// Making prev as curr's 

// right child 

curr.right = prev; 


prev = curr; 

curr = next; 

} 

return
prev; 
} 

// Iterative method to do 
// level order traversal 
// line by line 
static
void
printLevelOrder(Node root) 
{ 

// Base Case 

if
(root == 
null
) 
return
; 


// Create an empty queue for 

// level order traversal 

Queue<Node> q = 
new
LinkedList<Node>(); 


// Enqueue Root and 

// initialize height 

q.add(root); 


while
(
true
) 

{ 

// nodeCount (queue size) 

// indicates number of nodes 

// at current lelvel. 

int
nodeCount = q.size(); 

if
(nodeCount == 
0
) 

break
; 


// Dequeue all nodes of current 

// level and Enqueue all nodes 

// of next level 

while
(nodeCount > 
0
) 

{ 

Node node = q.peek(); 

System.out.print(node.data + 
"" ""
); 

q.remove(); 


if
(node.left != 
null
) 

q.add(node.left); 


if
(node.right != 
null
) 

q.add(node.right); 

nodeCount--; 

} 

System.out.println(); 

} 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

Node root = newNode(
1
); 

root.left = newNode(
2
); 

root.right = newNode(
3
); 

root.right.left = newNode(
4
); 

root.right.right = newNode(
5
); 


System.out.print(
""Level order traversal ""
+ 

""of given tree\n""
); 

printLevelOrder(root); 


root = flipBinaryTree(root); 


System.out.print(
""\nLevel order traversal ""
+ 

""of the flipped tree\n""
); 

printLevelOrder(root); 
} 
} 

// This code is contributed 
// by Arnab Kundu ",CorCod,90,90,linear
"
// Java code for kth smallest element 
// in an array 
import
java.util.Arrays; 
import
java.util.Collections; 

class
GFG 
{ 

// Function to return k'th smallest 

// element in a given array 

public
static
int
kthSmallest(Integer [] arr, 

int
k) 

{ 

// Sort the given array 

Arrays.sort(arr); 


// Return k'th element in 

// the sorted array 

return
arr[k-
1
]; 

} 


// driver program 

public
static
void
main(String[] args) 

{ 

Integer arr[] = 
new
Integer[]{
12
, 
3
, 
5
, 
7
, 
19
}; 

int
k = 
2
; 

System.out.print( 
""K'th smallest element is ""
+ 

kthSmallest(arr, k) ); 

} 
} 

// This code is contributed by Chhavi ",CorCod,721,721,nlogn
"import java.util.*;
import java.io.*;
public class vasyaarray{
public static void main(String[] args)throws IOException {
    FastReader in=new FastReader(System.in);
        int n=in.nextInt();
        long arr1[]=new long[n];
        long pre1[]=new long[n];
        int i,j;
        arr1[0]=in.nextLong();
        pre1[0]=arr1[0];
        for(i=1;i<n;i++)
        {
            arr1[i]=in.nextLong();
            pre1[i]=pre1[i-1]+arr1[i];
        }
        int m=in.nextInt();
        long arr2[]=new long[m];
        long pre2[]=new long[m];
        arr2[0]=in.nextInt();
        pre2[0]=arr2[0];
        for(i=1;i<m;i++)
        {
            arr2[i]=in.nextInt();
            pre2[i]=pre2[i-1]+arr2[i];
        }
        //System.out.println(Arrays.toString(pre1));
         //System.out.println(Arrays.toString(pre2));
        if(pre1[n-1]!=pre2[m-1])
        System.out.println(""-1"");
        else
        {
            long s1=0,s2=0;
            i=j=0;
            int k=0;
            while(true)
            {
                if(s1==s2)
                {
                    if(s1==0)
                    {
                        s1=arr1[i++];
                        s2=arr2[j++];
                        // System.out.println(s1+"" ""+s2+"" ""+i+"" ""+j);
                    }
                    else
                    {
                        k++;
                        s1=s2=0;
                        //System.out.println(k+"" ""+i+"" ""+j);
                        if(i==n && j==m)
                        break;
                    }
                }
                else if(s1>s2)
                {
                    s2+=arr2[j++];
                    //System.out.println(""1""+"" ""+s1+"" ""+s2+"" ""+i+"" ""+j);
                }
                else
                {
                    s1+=arr1[i++];
                    //System.out.println(""2 ""+s1+"" ""+s2+"" ""+i+"" ""+j);
                }
            }
            System.out.println(k);
        }
    }
}
class FastReader {
 
    byte[] buf = new byte[2048];
    int index, total;
    InputStream in;
 
    FastReader(InputStream is) {
        in = is;
    }
 
    int scan() throws IOException {
        if (index >= total) {
            index = 0;
            total = in.read(buf);
            if (total <= 0) {
                return -1;
            }
        }
        return buf[index++];
    }
 
    String next() throws IOException {
        int c;
        for (c = scan(); c <= 32; c = scan());
        StringBuilder sb = new StringBuilder();
        for (; c > 32; c = scan()) {
            sb.append((char) c);
        }
        return sb.toString();
    }
    String nextLine() throws IOException {
        int c;
        for (c = scan(); c <= 32; c = scan());
        StringBuilder sb = new StringBuilder();
        for (; c !=10; c = scan()) {
            sb.append((char) c);
        }
        return sb.toString();
    }
    char nextChar() throws IOException{
        int c;
         for (c = scan(); c <= 32; c = scan());
         return (char)c;
        }
 
    int nextInt() throws IOException {
        int c, val = 0;
        for (c = scan(); c <= 32; c = scan());
        boolean neg = c == '-';
        if (c == '-' || c == '+') {
            c = scan();
        }
        for (; c >= '0' && c <= '9'; c = scan()) {
            val = (val << 3) + (val << 1) + (c & 15);
        }
        return neg ? -val : val;
    }
 
    long nextLong() throws IOException {
        int c;
        long val = 0;
        for (c = scan(); c <= 32; c = scan());
        boolean neg = c == '-';
        if (c == '-' || c == '+') {
            c = scan();
        }
        for (; c >= '0' && c <= '9'; c = scan()) {
            val = (val << 3) + (val << 1) + (c & 15);
        }
        return neg ? -val : val;
    }
}",CorCod,80,80,linear
"
// Java code to Count Palindromic Subsequence 
// in a given String 
public
class
GFG 
{ 

// Function return the total palindromic 

// subsequence 

static
int
countPS(String str) 

{ 

int
N = str.length(); 


// create a 2D array to store the count 

// of palindromic subsequence 

int
[][] cps = 
new
int
[N+
1
][N+
1
]; 


// palindromic subsequence of length 1 

for
(
int
i = 
0
; i < N; i++) 

cps[i][i] = 
1
; 


// check subsequence of length L is 

// palindrome or not 

for
(
int
L=
2
; L<=N; L++) 

{ 

for
(
int
i = 
0
; i < N; i++) 

{ 

int
k = L + i - 
1
; 

if
(k < N){ 

if
(str.charAt(i) == str.charAt(k)) 

cps[i][k] = cps[i][k-
1
] + 

cps[i+
1
][k] + 
1
; 

else

cps[i][k] = cps[i][k-
1
] + 

cps[i+
1
][k] - 

cps[i+
1
][k-
1
]; 

} 

} 

} 


// return total palindromic subsequence 

return
cps[
0
][N-
1
]; 

} 


// Driver program 

public
static
void
main(String args[]) 

{ 

String str = 
""abcb""
; 

System.out.println(
""Total palindromic ""
+ 

""subsequence are : ""

+ countPS(str)); 

} 
} 
// This code is contributed by Sumit Ghosh ",CorCod,493,493,quadratic
"
// Java program to find all elements 
// in array which have atleast 
// two greater elements itself. 
import
java.util.*; 
import
java.io.*; 

class
GFG 
{ 

static
void
findElements(
int
arr[], 
int
n) 
{ 

int
first = Integer.MIN_VALUE; 

int
second = Integer.MAX_VALUE; 


for
(
int
i = 
0
; i < n; i++) 

{ 

// If current element is smaller 

// than first then update both 

// first and second 

if
(arr[i] > first) 

{ 

second = first; 

first = arr[i]; 

} 


/* If arr[i] is in between 

first and second 

then update second */

else
if
(arr[i] > second) 

second = arr[i]; 

} 


for
(
int
i = 
0
; i < n; i++) 

if
(arr[i] < second) 

System.out.print(arr[i] + 
"" ""
) ; 
} 
// Driver code 
public
static
void
main(String args[]) 
{ 

int
arr[] = { 
2
, -
6
, 
3
, 
5
, 
1
}; 

int
n = arr.length; 

findElements(arr, n); 
} 
} 

// This code is contributed by Sahil_Bansall ",CorCod,155,155,linear
"
// A Dynamic Programming based solution that uses table C[][] to 
// calculate the Binomial Coefficient 

class
BinomialCoefficient 
{ 

// Returns value of Binomial Coefficient C(n, k) 

static
int
binomialCoeff(
int
n, 
int
k) 

{ 

int
C[][] = 
new
int
[n+
1
][k+
1
]; 

int
i, j; 


// Calculate value of Binomial Coefficient in bottom up manner 

for
(i = 
0
; i <= n; i++) 

{ 

for
(j = 
0
; j <= min(i, k); j++) 

{ 

// Base Cases 

if
(j == 
0
|| j == i) 

C[i][j] = 
1
; 


// Calculate value using previously stored values 

else

C[i][j] = C[i-
1
][j-
1
] + C[i-
1
][j]; 

} 

} 


return
C[n][k]; 

} 


// A utility function to return minimum of two integers 

static
int
min(
int
a, 
int
b) 

{ 

return
(a<b)? a: b; 

} 


/* Driver program to test above function*/

public
static
void
main(String args[]) 

{ 

int
n = 
5
, k = 
2
; 

System.out.println(
""Value of C(""
+n+
"",""
+k+
"") is ""
+binomialCoeff(n, k)); 

} 
} 
/*This code is contributed by Rajat Mishra*/",CorCod,539,539,quadratic
"import java.io.*;
import java.util.Arrays;
import java.util.StringJoiner;
import java.util.StringTokenizer;
import java.util.function.Function;

public class Main {

    static String S;

    public static void main(String[] args) {
        FastScanner sc = new FastScanner(System.in);
        S = sc.next();

        System.out.println(solve());
    }

    static int solve() {
        int ans = -1;
        int time = 1;
        int n = S.length();
        for (int i = 1; i < n*2; i++) {
            if( S.charAt((i-1)%n) != S.charAt(i%n) ) {
                time++;
            } else {
                ans = Math.max(time, ans);
                time = 1;
            }
        }
        ans = Math.max(time, ans);

        if( ans == n*2 ) {
            return n;
        } else {
            return ans;
        }
    }

    @SuppressWarnings(""unused"")
    static class FastScanner {
        private BufferedReader reader;
        private StringTokenizer tokenizer;

        FastScanner(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
            tokenizer = null;
        }

        String next() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        String nextLine() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    return reader.readLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken(""\n"");
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        int[] nextIntArray(int n, int delta) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt() + delta;
            return a;
        }

        long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }
    }

    static <A> void writeLines(A[] as, Function<A, String> f) {
        PrintWriter pw = new PrintWriter(System.out);
        for (A a : as) {
            pw.println(f.apply(a));
        }
        pw.flush();
    }

    static void writeLines(int[] as) {
        PrintWriter pw = new PrintWriter(System.out);
        for (int a : as) pw.println(a);
        pw.flush();
    }

    static void writeLines(long[] as) {
        PrintWriter pw = new PrintWriter(System.out);
        for (long a : as) pw.println(a);
        pw.flush();
    }

    static int max(int... as) {
        int max = Integer.MIN_VALUE;
        for (int a : as) max = Math.max(a, max);
        return max;
    }

    static int min(int... as) {
        int min = Integer.MAX_VALUE;
        for (int a : as) min = Math.min(a, min);
        return min;
    }

    static void debug(Object... args) {
        StringJoiner j = new StringJoiner("" "");
        for (Object arg : args) {
            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));
            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));
            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));
            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));
            else j.add(arg.toString());
        }
        System.err.println(j.toString());
    }
}
",CorCod,184,184,linear
"
// Java implementation of alternate vowel and 
// consonant string 
import
java.util.*; 

class
GFG 
{ 

// 'ch' is vowel or not 
static
boolean
isVowel(
char
ch) 
{ 

if
(ch == 
'a'
|| ch == 
'e'
|| ch == 
'i'
|| 

ch == 
'o'
|| ch ==
'u'
) 

return
true
; 

return
false
; 
} 

// create alternate vowel and consonant string 
// str1[0...l1-1] and str2[start...l2-1] 
static
String createAltStr(String str1, String str2, 

int
start, 
int
l) 
{ 

String finalStr = 
""""
; 


// first adding character of vowel/consonant 

// then adding character of consonant/vowel 

for
(
int
i = 
0
, j = start; j < l; i++, j++) 

finalStr = (finalStr + str1.charAt(i)) + 

str2.charAt(j); 

return
finalStr; 
} 

// function to find the required 
// alternate vowel and consonant string 
static
String findAltStr(String str) 
{ 

int
nv = 
0
, nc = 
0
; 

String vstr = 
""""
, cstr = 
""""
; 

int
l = str.length(); 

for
(
int
i = 
0
; i < l; i++) 

{ 

char
ch = str.charAt(i); 


// count vowels and updaye vowel string 

if
(isVowel(ch)) 

{ 

nv++; 

vstr = vstr + ch; 

} 


// count consonants and update consonant 

// string 

else

{ 

nc++; 

cstr = cstr + ch; 

} 

} 


// no such string can be formed 

if
(Math.abs(nv - nc) >= 
2
) 

return
""no such string""
; 


// remove first character of vowel string 

// then create alternate string with 

// cstr[0...nc-1] and vstr[1...nv-1] 

if
(nv > nc) 

return
(vstr.charAt(
0
) + createAltStr(cstr, vstr, 
1
, nv)); 


// remove first character of consonant string 

// then create alternate string with 

// vstr[0...nv-1] and cstr[1...nc-1] 

if
(nc > nv) 

return
(cstr.charAt(
0
) + createAltStr(vstr, cstr, 
1
, nc)); 


// if both vowel and consonant 

// strings are of equal length 

// start creating string with consonant 

if
(cstr.charAt(
0
) < vstr.charAt(
0
)) 

return
createAltStr(cstr, vstr, 
0
, nv); 


// start creating string with vowel 

return
createAltStr(vstr, cstr, 
0
, nc); 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

String str = 
""geeks""
; 

System.out.println(findAltStr(str)); 
} 
} 

// This code is contributed by 
// Shashank_Sharma ",CorCod,323,323,linear
"
// Java program to count number of triangles that can be 
// formed from given array 
import
java.io.*; 
import
java.util.*; 

class
CountTriangles 
{ 

// Function to count all possible triangles with arr[] 

// elements 

static
int
findNumberOfTriangles(
int
arr[]) 

{ 

int
n = arr.length; 

// Sort the array elements in non-decreasing order 

Arrays.sort(arr); 


// Initialize count of triangles 

int
count = 
0
; 


// Fix the first element. We need to run till n-3 as 

// the other two elements are selected from arr[i+1...n-1] 

for
(
int
i = 
0
; i < n-
2
; ++i) 

{ 

// Initialize index of the rightmost third element 

int
k = i + 
2
; 


// Fix the second element 

for
(
int
j = i+
1
; j < n; ++j) 

{ 

/* Find the rightmost element which is smaller 

than the sum of two fixed elements 

The important thing to note here is, we use 

the previous value of k. If value of arr[i] + 

arr[j-1] was greater than arr[k], then arr[i] + 

arr[j] must be greater than k, because the 

array is sorted. */

while
(k < n && arr[i] + arr[j] > arr[k]) 

++k; 


/* Total number of possible triangles that can be 

formed with the two fixed elements is k - j - 1. 

The two fixed elements are arr[i] and arr[j]. All 

elements between arr[j+1] to arr[k-1] can form a 

triangle with arr[i] and arr[j]. One is subtracted 

from k because k is incremented one extra in above 

while loop. k will always be greater than j. If j 

becomes equal to k, then above loop will increment 

k, because arr[k] + arr[i] is always/ greater than 

arr[k] */

if
(k>j) 

count += k - j - 
1
; 

} 

} 

return
count; 

} 


public
static
void
main (String[] args) 

{ 

int
arr[] = {
10
, 
21
, 
22
, 
100
, 
101
, 
200
, 
300
}; 

System.out.println(
""Total number of triangles is ""
+ 

findNumberOfTriangles(arr)); 

} 
} 
/*This code is contributed by Devesh Agrawal*/",CorCod,541,541,quadratic
"import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        InputReader.OutputWriter out = new InputReader.OutputWriter(outputStream);


        int n = in.nextInt();
        int s = in.nextInt();
        Lift [] lifts = new Lift[n];
        for (int i = 0; i < n; i++) {
            lifts[i] = new Lift(in.nextInt(),in.nextInt());
        }
        Arrays.sort(lifts,(x,y)->y.getLevel() - x.getLevel());
        
        int ans = 0;
        for (int i = 0; i < lifts.length; i++) {
            Lift current = lifts[i];
            ans+=s-current.getLevel();
            if(current.getTime()>ans) {
                ans+=current.getTime() - ans;
            }
            s = current.getLevel();
        }
        ans+=s;
        out.println(ans);
        out.flush();
    }
}

class Lift {

    int level;
    int time;

    public int getLevel() {
        return level;
    }

    public int getTime() {
        return time;
    }

    public Lift(int level, int time) {
        this.level = level;
        this.time = time;
    }
}

class InputReader extends BufferedReader {
    StringTokenizer tokenizer;

    public InputReader(InputStream inputStream) {
        super(new InputStreamReader(inputStream), 32768);
    }

    public InputReader(String filename) {
        super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(readLine());
            } catch (IOException e) {
                throw new RuntimeException();
            }
        }
        return tokenizer.nextToken();
    }

    public Integer nextInt() {
        return Integer.valueOf(next());
    }
    public Long nextLong() {return  Long.valueOf(next());}

    static class OutputWriter extends PrintWriter {
        public OutputWriter(OutputStream outputStream) {
            super(outputStream);
        }

        public OutputWriter(Writer writer) {
            super(writer);
        }

        public OutputWriter(String filename) throws FileNotFoundException {
            super(filename);
        }

        public void close() {
            super.close();
        }
    }
}",CorCod,710,710,nlogn
"
// Java program to count 
// occurrences of an element 
class
GFG 
{ 


// A recursive binary search 

// function. It returns location 

// of x in given array arr[l..r] 

// is present, otherwise -1 

static
int
binarySearch(
int
arr[], 
int
l, 

int
r, 
int
x) 

{ 

if
(r < l) 

return
-
1
; 


int
mid = l + (r - l) / 
2
; 


// If the element is present 

// at the middle itself 

if
(arr[mid] == x) 

return
mid; 


// If element is smaller than 

// mid, then it can only be 

// present in left subarray 

if
(arr[mid] > x) 

return
binarySearch(arr, l, 

mid - 
1
, x); 


// Else the element can 

// only be present in 

// right subarray 

return
binarySearch(arr, mid + 
1
, r, x); 

} 


// Returns number of times x 

// occurs in arr[0..n-1] 

static
int
countOccurrences(
int
arr[], 

int
n, 
int
x) 

{ 

int
ind = binarySearch(arr, 
0
, 

n - 
1
, x); 


// If element is not present 

if
(ind == -
1
) 

return
0
; 


// Count elements on left side. 

int
count = 
1
; 

int
left = ind - 
1
; 

while
(left >= 
0
&& 

arr[left] == x) 

{ 

count++; 

left--; 

} 


// Count elements 

// on right side. 

int
right = ind + 
1
; 

while
(right < n && 

arr[right] == x) 

{ 

count++; 

right++; 

} 


return
count; 

} 



// Driver code 

public
static
void
main(String[] args) 

{ 

int
arr[] = {
1
, 
2
, 
2
, 
2
, 
2
, 

3
, 
4
, 
7
, 
8
, 
8
}; 

int
n = arr.length; 

int
x = 
2
; 

System.out.print(countOccurrences(arr, n, x)); 

} 
} 

// This code is contributed 
// by ChitraNayal ",CorCod,924,924,logn
"
// Java code to find maximum triplet sum 
import
java.io.*; 
import
java.util.*; 


class
GFG { 


// This function assumes that there are 

// at least three elements in arr[]. 

static
int
maxTripletSum(
int
arr[], 
int
n) 

{ 

// sort the given array 

Arrays.sort(arr); 


// After sorting the array. 

// Add last three element 

// of the given array 

return
arr[n - 
1
] + arr[n - 
2
] + arr[n - 
3
]; 

} 


// Driven code 

public
static
void
main(String args[]) 

{ 

int
arr[] = { 
1
, 
0
, 
8
, 
6
, 
4
, 
2
}; 

int
n = arr.length; 

System.out.println(maxTripletSum(arr, n)); 

} 
} 


// This code is contributed by Nikita Tiwari. ",CorCod,610,610,nlogn
"import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Practice {
	
	   

		public static void main(String []args)
		{
			Scanner sc=new Scanner(System.in);
			
			
			String s=sc.nextLine();
			int n=0;
			int m=0;
			//System.out.println(5%0);
			
			for(int i=0;i<s.length();i++)
			{
				if(s.charAt(i)=='-')
				{
					n++;
				}
				else
				{
					m++;
				}
			}
			if(m==0)
			{
				System.out.println(""YES"");
			}
			else
			{
			if(n%m==0)
			{
				System.out.println(""YES"");
			}
			else
			{
				System.out.println(""NO"");
			}
			}
			
			
			
			
			
			
			
			
	}

}",CorCod,250,250,linear
"import java.util.*;
import java.io.*;

public class PartySweet {
	static BufferedReader br;
	static StringTokenizer tokenizer;

	public static void main(String[] args) throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
		int n = nextInt(), m = nextInt();
		int[] b = new int[n];
		int[] g = new int[m];
		for(int i = 0; i < n; i++)
			b[i] = nextInt();
		for(int i = 0; i < m; i++)
			g[i] = nextInt();
		int total = 0;
		int max = 0, max2 = 0;
		for(int i = 0; i < n; i++) {
			if(b[i] > b[max]) {
				max2 = max;
				max = i;
			}
			else if(b[max2] < b[i])
				max2 = i;
		}
		total += b[max] - b[max2];
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < m; j++) {
				if(b[i] > g[j]) {
					System.out.println(-1);
					return;
				}
				if(i != max)
					total += b[i];
				else
					total += g[j];
			}
		}
		System.out.println(total);
	}

	public static String next() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens()) {
			String line = br.readLine();
			if (line == null)
				throw new IOException();
			tokenizer = new StringTokenizer(line);
		}
		return tokenizer.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(next());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(next());
	}

	public static double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}
}
",CorCod,559,559,quadratic
"
// Java program to check if binary tree 
// is subtree of another binary tree 
class
Node { 


char
data; 

Node left, right; 


Node(
char
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
Passing { 


int
i; 

int
m = 
0
; 

int
n = 
0
; 
} 

class
BinaryTree { 


static
Node root; 

Passing p = 
new
Passing(); 


String strstr(String haystack, String needle) 

{ 

if
(haystack == 
null
|| needle == 
null
) { 

return
null
; 

} 

int
hLength = haystack.length(); 

int
nLength = needle.length(); 

if
(hLength < nLength) { 

return
null
; 

} 

if
(nLength == 
0
) { 

return
haystack; 

} 

for
(
int
i = 
0
; i <= hLength - nLength; i++) { 

if
(haystack.charAt(i) == needle.charAt(
0
)) { 

int
j = 
0
; 

for
(; j < nLength; j++) { 

if
(haystack.charAt(i + j) != needle.charAt(j)) { 

break
; 

} 

} 

if
(j == nLength) { 

return
haystack.substring(i); 

} 

} 

} 

return
null
; 

} 


// A utility function to store inorder traversal of tree rooted 

// with root in an array arr[]. Note that i is passed as reference 

void
storeInorder(Node node, 
char
arr[], Passing i) 

{ 

if
(node == 
null
) { 

arr[i.i++] = 
'$'
; 

return
; 

} 

storeInorder(node.left, arr, i); 

arr[i.i++] = node.data; 

storeInorder(node.right, arr, i); 

} 


// A utility function to store preorder traversal of tree rooted 

// with root in an array arr[]. Note that i is passed as reference 

void
storePreOrder(Node node, 
char
arr[], Passing i) 

{ 

if
(node == 
null
) { 

arr[i.i++] = 
'$'
; 

return
; 

} 

arr[i.i++] = node.data; 

storePreOrder(node.left, arr, i); 

storePreOrder(node.right, arr, i); 

} 


/* This function returns true if S is a subtree of T, otherwise false */

boolean
isSubtree(Node T, Node S) 

{ 

/* base cases */

if
(S == 
null
) { 

return
true
; 

} 

if
(T == 
null
) { 

return
false
; 

} 


// Store Inorder traversals of T and S in inT[0..m-1] 

// and inS[0..n-1] respectively 

char
inT[] = 
new
char
[
100
]; 

String op1 = String.valueOf(inT); 

char
inS[] = 
new
char
[
100
]; 

String op2 = String.valueOf(inS); 

storeInorder(T, inT, p); 

storeInorder(S, inS, p); 

inT[p.m] = 
'\0'
; 

inS[p.m] = 
'\0'
; 


// If inS[] is not a substring of preS[], return false 

if
(strstr(op1, op2) != 
null
) { 

return
false
; 

} 


// Store Preorder traversals of T and S in inT[0..m-1] 

// and inS[0..n-1] respectively 

p.m = 
0
; 

p.n = 
0
; 

char
preT[] = 
new
char
[
100
]; 

char
preS[] = 
new
char
[
100
]; 

String op3 = String.valueOf(preT); 

String op4 = String.valueOf(preS); 

storePreOrder(T, preT, p); 

storePreOrder(S, preS, p); 

preT[p.m] = 
'\0'
; 

preS[p.n] = 
'\0'
; 


// If inS[] is not a substring of preS[], return false 

// Else return true 

return
(strstr(op3, op4) != 
null
); 

} 


// Driver program to test above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

Node T = 
new
Node(
'a'
); 

T.left = 
new
Node(
'b'
); 

T.right = 
new
Node(
'd'
); 

T.left.left = 
new
Node(
'c'
); 

T.right.right = 
new
Node(
'e'
); 


Node S = 
new
Node(
'a'
); 

S.left = 
new
Node(
'b'
); 

S.right = 
new
Node(
'd'
); 

S.left.left = 
new
Node(
'c'
); 


if
(tree.isSubtree(T, S)) { 

System.out.println(
""Yes, S is a subtree of T""
); 

} 

else
{ 

System.out.println(
""No, S is not a subtree of T""
); 

} 

} 
} 

// This code is contributed by Mayank Jaiswal ",CorCod,177,177,linear
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;
import java.util.StringTokenizer;

public class main {
static	class Interval{
		int start;
		int end;
		public Interval(int start,int end) {
			this.start=start;
			this.end=end;
		}
	}
static class FastReader 
{ 
    BufferedReader br; 
    StringTokenizer st; 

    public FastReader() 
    { 
        br = new BufferedReader(new
                 InputStreamReader(System.in)); 
    } 

    String next() 
    { 
        while (st == null || !st.hasMoreElements()) 
        { 
            try
            { 
                st = new StringTokenizer(br.readLine()); 
            } 
            catch (IOException  e) 
            { 
                e.printStackTrace(); 
            } 
        } 
        return st.nextToken(); 
    } 

    int nextInt() 
    { 
        return Integer.parseInt(next()); 
    } 

    long nextLong() 
    { 
        return Long.parseLong(next()); 
    } 

    double nextDouble() 
    { 
        return Double.parseDouble(next()); 
    } 

    String nextLine() 
    { 
        String str = """"; 
        try
        { 
            str = br.readLine(); 
        } 
        catch (IOException e) 
        { 
            e.printStackTrace(); 
        } 
        return str; 
    } 
} 
	static long mod = 1000000007;
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		FastReader in = new FastReader();
		long intervals = in.nextInt();
		long x = in.nextInt();
		 long y = in.nextInt();
		Interval []ints = new Interval[(int)(int) intervals];
		for(int i = 0;i<intervals;i++) {
			ints[i] = new Interval(in.nextInt(),in.nextInt());
		}
		Arrays.sort(ints, (a,b)->a.start-b.start);
		long count = 0;
		for(int i = 0;i<ints.length;i++) {
			if(i>=0&&ints[i]!=null) {
			Interval cur1 = ints[i];
			for(int j = i+1;j<ints.length;j++) {
			if(ints[j]!=null) {
			Interval cur2 = ints[j];
			if(y*(cur2.start-cur1.end)<x) {
			if(cur1.start!=cur2.start&&cur1.end<cur2.start) {
				cur1.end=cur2.end;
				
				ints[j]=null;
			//	i--;
			}}
			else
				break;
			}
			
			}
			count = (count + x) % mod;
			count += (y*(cur1.end-cur1.start)%mod);
			count%=mod;
			}
			
		}
		
//		for(int i = 0;i<ints.length;i++) {
//			if(ints[i]!=null) {
//			Interval cur = ints[i];
//			count = (count + x) % mod;
//			count += (y*(cur.end-cur.start)%mod);
//			count%=mod;
//			}
//		}
		System.out.println(count);
	}

}",CorCod,465,465,quadratic
"
// Java program to check fixed point 
// in an array using binary search 

class
Main 
{ 

static
int
binarySearch(
int
arr[], 
int
low, 
int
high) 

{ 

if
(high >= low) 

{ 

/* low + (high - low)/2; */

int
mid = (low + high)/
2
; 

if
(mid == arr[mid]) 

return
mid; 

if
(mid > arr[mid]) 

return
binarySearch(arr, (mid + 
1
), high); 

else

return
binarySearch(arr, low, (mid -
1
)); 

} 


/* Return -1 if there is 

no Fixed Point */

return
-
1
; 

} 


//main function 

public
static
void
main(String args[]) 

{ 

int
arr[] = {-
10
, -
1
, 
0
, 
3
, 
10
, 
11
, 
30
, 
50
, 
100
}; 

int
n = arr.length; 

System.out.println(
""Fixed Point is ""

+ binarySearch(arr,
0
, n-
1
)); 

} 
} ",CorCod,919,919,logn
"import java.util.Arrays;
import java.util.Scanner;

public class Solution {

    private static int[] a;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(), m = sc.nextInt();

        a = new int[101];
        for (int i = 0; i < m; i++) {
            int type = sc.nextInt();
            a[type] = a[type] + 1;
        }

        int lo=1, hi=100, max=0;

        while (lo <= hi) {
            int mid = lo + (hi - lo)/2;
            if (check(n, mid)) {
                max = mid;
                lo = mid+1;
            } else {
                hi = mid -1;
            }
        }
        System.out.println(max);
    }

    public static boolean check(int n, int target) {
        int result = 0;
        for (int i=0; i <a.length; i++) {
            result = result + (a[i] / target);
        }
        if (result >= n) {return true;}
        return false;
    }
}",CorCod,617,617,nlogn
"import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int m = sc.nextInt();

        long totalBlocks = 0;
        long a[] = new long[n];
        for(int i = 0; i < n; ++i) {
            a[i] = sc.nextLong();
            totalBlocks += a[i];
        }

        Arrays.sort(a);

        long selected = 0;
        for(int i = 0; i < n; ++i) {
            if(a[i] > selected)
                selected++;
        }

        long leftCols = a[n - 1] - selected;
        long remBlocks = totalBlocks - leftCols - n;

        System.out.print(remBlocks);
    }
}",CorCod,600,600,nlogn
"/* package codechef; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

public final class Codeforces
{	
	public static void main (String[] args) throws java.lang.Exception
	{
	    Scanner sc=new Scanner(System.in);
			int n=sc.nextInt();
			ArrayList<Integer> list=new ArrayList<Integer>();
			for(int i=0;i<n;i++){
				int temp=sc.nextInt();
				list.add(temp);
			}
			Collections.sort(list);
			if(n%2==0)
			System.out.println(list.get((n/2)-1));
			else
			System.out.println(list.get(n/2));
	}
}
",CorCod,733,733,nlogn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in Actual solution is at the top
 *
 * @author MaxHeap
 */
public class Main {

  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    InputReader in = new InputReader(inputStream);
    PrintWriter out = new PrintWriter(outputStream);
    CBanhMi solver = new CBanhMi();
    solver.solve(1, in, out);
    out.close();
  }

  static class CBanhMi {

    long mod = (long) (1e9 + 7);

    public void solve(int testNumber, InputReader in, PrintWriter out) {
      int n = in.nextInt();
      int q = in.nextInt();
      long[] two = new long[n + 1];
      two[0] = 1;
      for (int i = 1; i <= n; ++i) {
        two[i] = (two[i - 1] * 2L);
        two[i] %= mod;
      }

      char[] s = in.nextCharArray();
      int[] acc = new int[n + 1];
      for (int i = 1; i <= n; ++i) {
        acc[i] = s[i - 1] == '0' ? 0 : 1;
        acc[i] += acc[i - 1];
      }
      // 0 0 1 1 | 1: 1 1 2| 2: 2 3| 4: 5| 9
      // 0 1 1 1| 1: 1 2 2| 2: 3 3| 5: 6| 11
      // 0 1 1 wwqwq| 1: 1 2 2| 3: 5 3| 8: 8| 16
      // 0 0 1 1| 1: 1 1 2| 3: 3 3| 6: 6| 12
      // 0 0 0 1| 1: 1 1 1| 2: 2 2| 4: 4| 8
      while (q-- > 0) {
        int f = in.nextInt();
        int t = in.nextInt();
        int ones = acc[t] - acc[f - 1];
        int zeros = (t - f + 1) - ones;
        if (ones == 0) {
          out.println(0);
        } else {
          long ans = two[t - f + 1] - (zeros > 0 ? two[zeros] : 0);
          if (zeros == 0) {
            --ans;
          }
          ans = (ans + mod) % mod;
          out.println(ans);
        }
      }
    }

  }

  static class InputReader implements FastIO {

    private InputStream stream;
    private static final int DEFAULT_BUFFER_SIZE = 1 << 16;
    private static final int EOF = -1;
    private byte[] buf = new byte[DEFAULT_BUFFER_SIZE];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (this.numChars == EOF) {
        throw new UnknownError();
      } else {
        if (this.curChar >= this.numChars) {
          this.curChar = 0;

          try {
            this.numChars = this.stream.read(this.buf);
          } catch (IOException ex) {
            throw new InputMismatchException();
          }

          if (this.numChars <= 0) {
            return EOF;
          }
        }

        return this.buf[this.curChar++];
      }
    }

    public int nextInt() {
      int c;
      for (c = this.read(); isSpaceChar(c); c = this.read()) {
      }

      byte sgn = 1;
      if (c == 45) {
        sgn = -1;
        c = this.read();
      }

      int res = 0;

      while (c >= 48 && c <= 57) {
        res *= 10;
        res += c - 48;
        c = this.read();
        if (isSpaceChar(c)) {
          return res * sgn;
        }
      }

      throw new InputMismatchException();
    }

    public String next() {
      int c;
      while (isSpaceChar(c = this.read())) {
      }

      StringBuilder result = new StringBuilder();
      result.appendCodePoint(c);

      while (!isSpaceChar(c = this.read())) {
        result.appendCodePoint(c);
      }

      return result.toString();
    }

    public static boolean isSpaceChar(int c) {
      return c == 32 || c == 10 || c == 13 || c == 9 || c == EOF;
    }

    public char[] nextCharArray() {
      return next().toCharArray();
    }

  }

  static interface FastIO {

  }
}

",CorCod,40,40,linear
"import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);

        long n = sc.nextLong();
        long s = sc.nextLong();

        long ans = (s - 1) / n + 1;
        System.out.print(ans);
    }
}",CorCod,752,752,constant
"
// Java Program to find maximum in arr[] 
class
Test 
{ 

static
int
arr[] = {
10
, 
324
, 
45
, 
90
, 
9808
}; 


// Method to find maximum in arr[] 

static
int
largest() 

{ 

int
i; 


// Initialize maximum element 

int
max = arr[
0
]; 


// Traverse array elements from second and 

// compare every element with current max 

for
(i = 
1
; i < arr.length; i++) 

if
(arr[i] > max) 

max = arr[i]; 


return
max; 

} 


// Driver method 

public
static
void
main(String[] args) 

{ 

System.out.println(
""Largest in given array is ""
+ largest()); 

} 

} ",CorCod,129,129,linear
"import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		while(sc.hasNext()) {
			int n=sc.nextInt();
			String s=sc.next();
			int sum=0;
			for(int i=0;i<s.length();i++) {
				if(s.charAt(i)=='+') {
					sum++;
				}
				if(s.charAt(i)=='-'&&sum!=0) {
					sum--;
				}
			}
			System.out.println(sum);
		}
	}
}",CorCod,229,229,linear
"import static java.lang.Integer.parseInt;
import static java.lang.Long.parseLong;
import static java.lang.Math.min;
import static java.lang.System.exit;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class F {

	static void solve() throws Exception {
		int n = scanInt();
		long l[] = new long[n];
		for (int i = 0; i < n; i++) {
			l[i] = scanLong();
		}
		long e1 = 0, e2 = 0, ans = 0;
		boolean water = false;
		String types = scanString();
		for (int i = 0; i < n; i++) {
			long li = l[i], cur;
			switch (types.charAt(i)) {
			case 'G':
				cur = min(e1, li);
				e1 -= cur;
				li -= cur;
				e2 += 2 * cur;
				ans += 2 * cur;
				e2 += li;
				ans += 3 * li;
				break;
			case 'W':
				water = true;
				e1 += li;
				ans += 2 * li;
				break;
			case 'L':
				cur = min(e1, li);
				e1 -= cur;
				li -= cur;
				ans += 2 * cur;
				cur = min(e2, li);
				e2 -= cur;
				li -= cur;
				ans += 3 * cur;
				ans += (water ? 4 : 6) * li;
				break;
			default:
				throw new AssertionError();
			}
		}
		out.print(ans);
	}

	static int scanInt() throws IOException {
		return parseInt(scanString());
	}

	static long scanLong() throws IOException {
		return parseLong(scanString());
	}

	static String scanString() throws IOException {
		while (tok == null || !tok.hasMoreTokens()) {
			tok = new StringTokenizer(in.readLine());
		}
		return tok.nextToken();
	}

	static BufferedReader in;
	static PrintWriter out;
	static StringTokenizer tok;

	public static void main(String[] args) {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			solve();
			in.close();
			out.close();
		} catch (Throwable e) {
			e.printStackTrace();
			exit(1);
		}
	}
}",CorCod,123,123,linear
"
// Java program to rotate an array by 
// d elements 

class
RotateArray { 

/*Function to left rotate arr[] of size n by d*/

void
leftRotate(
int
arr[], 
int
d, 
int
n) 

{ 

for
(
int
i = 
0
; i < d; i++) 

leftRotatebyOne(arr, n); 

} 


void
leftRotatebyOne(
int
arr[], 
int
n) 

{ 

int
i, temp; 

temp = arr[
0
]; 

for
(i = 
0
; i < n - 
1
; i++) 

arr[i] = arr[i + 
1
]; 

arr[i] = temp; 

} 


/* utility function to print an array */

void
printArray(
int
arr[], 
int
n) 

{ 

for
(
int
i = 
0
; i < n; i++) 

System.out.print(arr[i] + 
"" ""
); 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

RotateArray rotate = 
new
RotateArray(); 

int
arr[] = { 
1
, 
2
, 
3
, 
4
, 
5
, 
6
, 
7
}; 

rotate.leftRotate(arr, 
2
, 
7
); 

rotate.printArray(arr, 
7
); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,484,484,quadratic
"import java.util.*;
import java.io.*;

public class D {

	static final boolean stdin = true;
	static final String filename = """";
	static FastScanner br;
	static PrintWriter pw;

	public static void main(String[] args) throws IOException {

		if (stdin) {
			br = new FastScanner();
			pw = new PrintWriter(new OutputStreamWriter(System.out));
		} else {
			br = new FastScanner(filename + "".in"");
			pw = new PrintWriter(new FileWriter(filename + "".out""));
		}

		Solver solver = new Solver();
		solver.solve(br, pw);
	}

	static class Solver {
		static long mod = (long) (1e10);

		public void solve(FastScanner br, PrintWriter pw) throws IOException {
			int n = br.ni();
			Integer[] in = br.nIa(n);
			TreeSet<Integer> ts = new TreeSet<Integer>();
			for (int i = 0; i < n; i++) {
				ts.add(in[i]);
			}
			String twoSol = """";
			for (int i = 0; i <= 30; i++) {
				for (int j : in) {
					if (ts.contains(j + (int) Math.pow(2, i))) {
						if (ts.contains(j - (int) Math.pow(2, i))) {
							pw.println(3);
							pw.println(j + "" "" + (j + (int) Math.pow(2, i)) + "" "" + (j - (int) Math.pow(2, i)));
							pw.close();
							System.exit(0);
						}else{
							twoSol = (j + "" "" + (j + (int) Math.pow(2, i)));
						}
					}
				}
			}
			if (twoSol.isEmpty()) {
				pw.println(1);
				pw.println(in[0]);
			} else {
				pw.println(2);
				pw.println(twoSol);
			}
			pw.close();
		}

		static long gcd(long a, long b) {
			if (a > b)
				return gcd(b, a);
			if (a == 0)
				return b;
			return gcd(b % a, a);
		}

		static long lcm(long a, long b) {
			return a * (b / gcd(a, b));
		}

		static long pow(long a, long b) {
			if (b == 0)
				return 1L;
			long val = pow(a, b / 2);
			if (b % 2 == 0)
				return val * val % mod;
			else
				return val * val % mod * a % mod;
		}

	}

	static class Point implements Comparable<Point> {
		int a;
		int b;

		Point(int a, int b) {
			this.a = a;
			this.b = b;
		}

		@Override
		public int compareTo(Point o) {
			return this.a - o.a;
		}

	}

	public static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(String s) {
			try {
				br = new BufferedReader(new FileReader(s));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public FastScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		ArrayList<Integer>[] ng(int n, int e) {
			ArrayList<Integer>[] adj = new ArrayList[n];
			for (int i = 0; i < n; i++) {
				adj[i] = new ArrayList<Integer>();
			}
			for (int i = 0; i < e; i++) {
				int a = ni() - 1;
				int b = ni() - 1;
				adj[a].add(b);
				adj[b].add(a);
			}
			return adj;
		}

		Integer[] nIa(int n) {
			Integer[] arr = new Integer[n];
			for (int i = 0; i < n; i++) {
				arr[i] = ni();
			}
			return arr;
		}

		int[] nia(int n) {
			int[] arr = new int[n];
			for (int i = 0; i < n; i++) {
				arr[i] = ni();
			}
			return arr;
		}

		Long[] nLa(int n) {
			Long[] arr = new Long[n];
			for (int i = 0; i < n; i++) {
				arr[i] = nl();
			}
			return arr;
		}

		long[] nla(int n) {
			long[] arr = new long[n];
			for (int i = 0; i < n; i++) {
				arr[i] = nl();
			}
			return arr;
		}

		String[] nsa(int n) {
			String[] arr = new String[n];
			for (int i = 0; i < n; i++) {
				arr[i] = nt();
			}
			return arr;
		}

		String nt() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int ni() {
			return Integer.parseInt(nt());
		}

		long nl() {
			return Long.parseLong(nt());
		}

		double nd() {
			return Double.parseDouble(nt());
		}

	}
}",CorCod,668,668,nlogn
"
// Java program to fin maximum cash 
// flow among a set of persons 

class
GFG 
{ 

// Number of persons (or vertices in the graph) 

static
final
int
N = 
3
; 


// A utility function that returns 

// index of minimum value in arr[] 

static
int
getMin(
int
arr[]) 

{ 

int
minInd = 
0
; 

for
(
int
i = 
1
; i < N; i++) 

if
(arr[i] < arr[minInd]) 

minInd = i; 

return
minInd; 

} 


// A utility function that returns 

// index of maximum value in arr[] 

static
int
getMax(
int
arr[]) 

{ 

int
maxInd = 
0
; 

for
(
int
i = 
1
; i < N; i++) 

if
(arr[i] > arr[maxInd]) 

maxInd = i; 

return
maxInd; 

} 


// A utility function to return minimum of 2 values 

static
int
minOf2(
int
x, 
int
y) 

{ 

return
(x < y) ? x: y; 

} 


// amount[p] indicates the net amount 

// to be credited/debited to/from person 'p' 

// If amount[p] is positive, then 

// i'th person will amount[i] 

// If amount[p] is negative, then 

// i'th person will give -amount[i] 

static
void
minCashFlowRec(
int
amount[]) 

{ 

// Find the indexes of minimum and 

// maximum values in amount[] 

// amount[mxCredit] indicates the maximum amount 

// to be given (or credited) to any person . 

// And amount[mxDebit] indicates the maximum amount 

// to be taken(or debited) from any person. 

// So if there is a positive value in amount[], 

// then there must be a negative value 

int
mxCredit = getMax(amount), mxDebit = getMin(amount); 


// If both amounts are 0, then 

// all amounts are settled 

if
(amount[mxCredit] == 
0
&& amount[mxDebit] == 
0
) 

return
; 


// Find the minimum of two amounts 

int
min = minOf2(-amount[mxDebit], amount[mxCredit]); 

amount[mxCredit] -= min; 

amount[mxDebit] += min; 


// If minimum is the maximum amount to be 

System.out.println(
""Person ""
+ mxDebit + 
"" pays ""
+ min 

+ 
"" to ""
+ 
""Person ""
+ mxCredit); 


// Recur for the amount array. 

// Note that it is guaranteed that 

// the recursion would terminate 

// as either amount[mxCredit] or 

// amount[mxDebit] becomes 0 

minCashFlowRec(amount); 

} 


// Given a set of persons as graph[] 

// where graph[i][j] indicates 

// the amount that person i needs to 

// pay person j, this function 

// finds and prints the minimum 

// cash flow to settle all debts. 

static
void
minCashFlow(
int
graph[][]) 

{ 

// Create an array amount[], 

// initialize all value in it as 0. 

int
amount[]=
new
int
[N]; 


// Calculate the net amount to 

// be paid to person 'p', and 

// stores it in amount[p]. The 

// value of amount[p] can be 

// calculated by subtracting 

// debts of 'p' from credits of 'p' 

for
(
int
p = 
0
; p < N; p++) 

for
(
int
i = 
0
; i < N; i++) 

amount[p] += (graph[i][p] - graph[p][i]); 


minCashFlowRec(amount); 

} 


// Driver code 

public
static
void
main (String[] args) 

{ 

// graph[i][j] indicates the amount 

// that person i needs to pay person j 

int
graph[][] = { {
0
, 
1000
, 
2000
}, 

{
0
, 
0
, 
5000
}, 

{
0
, 
0
, 
0
},}; 


// Print the solution 

minCashFlow(graph); 

} 
} 

// This code is contributed by Anant Agarwal. ",CorCod,409,409,quadratic
"
// Java program to find maximum product of 
// a subset. 
class
GFG { 


static
int
minProductSubset(
int
a[], 
int
n) 

{ 

if
(n == 
1
) 

return
a[
0
]; 


// Find count of negative numbers, 

// count of zeros, maximum valued 

// negative number, minimum valued 

// positive number and product of 

// non-zero numbers 

int
negmax = Integer.MIN_VALUE; 

int
posmin = Integer.MAX_VALUE; 

int
count_neg = 
0
, count_zero = 
0
; 

int
product = 
1
; 


for
(
int
i = 
0
; i < n; i++) 

{ 


// if number is zero,count it 

// but dont multiply 

if
(a[i] == 
0
){ 

count_zero++; 

continue
; 

} 


// count the negetive numbers 

// and find the max negetive number 

if
(a[i] < 
0
) 

{ 

count_neg++; 

negmax = Math.max(negmax, a[i]); 

} 


// find the minimum positive number 

if
(a[i] > 
0
&& a[i] < posmin) 

posmin = a[i]; 


product *= a[i]; 

} 


// if there are all zeroes 

// or zero is present but no 

// negetive number is present 

if
(count_zero == n || 

(count_neg == 
0
&& count_zero > 
0
)) 

return
0
; 


// If there are all positive 

if
(count_neg == 
0
) 

return
posmin; 


// If there are even number except 

// zero of negative numbers 

if
(count_neg % 
2
== 
0
&& count_neg != 
0
) 

{ 


// Otherwise result is product of 

// all non-zeros divided by maximum 

// valued negative. 

product = product / negmax; 

} 


return
product; 

} 


// main function 

public
static
void
main(String[] args) 

{ 


int
a[] = { -
1
, -
1
, -
2
, 
4
, 
3
}; 

int
n = 
5
; 


System.out.println(minProductSubset(a, n)); 

} 
} 

// This code is contributed by Arnab Kundu. ",CorCod,168,168,linear
"
// Java O(n) solution for 
// finding smallest subarray 
// with sum greater than x 
import
java.io.*; 

class
GFG 
{ 

// Returns length of smallest 
// subarray with sum greater 
// than x. If there is no 
// subarray with given sum, 
// then returns n+1 
static
int
smallestSubWithSum(
int
arr[], 

int
n, 
int
x) 
{ 

// Initialize current 

// sum and minimum length 

int
curr_sum = 
0
, min_len = n + 
1
; 


// Initialize starting 

// and ending indexes 

int
start = 
0
, end = 
0
; 

while
(end < n) 

{ 

// Keep adding array 

// elements while current 

// sum is smaller than x 

while
(curr_sum <= x && end < n) 

{ 

// Ignore subarrays with 

// negative sum if x is 

// positive. 

if
(curr_sum <= 
0
&& x > 
0
) 

{ 

start = end; 

curr_sum = 
0
; 

} 


curr_sum += arr[end++]; 

} 


// If current sum becomes 

// greater than x. 

while
(curr_sum > x && start < n) 

{ 

// Update minimum 

// length if needed 

if
(end - start < min_len) 

min_len = end - start; 


// remove starting elements 

curr_sum -= arr[start++]; 

} 

} 

return
min_len; 
} 


// Driver Code 
public
static
void
main (String[] args) 
{ 

int
arr1[] = {- 
8
, 
1
, 
4
, 
2
, -
6
}; 

int
x = 
6
; 

int
n1 = arr1.length; 

int
res1 = smallestSubWithSum(arr1, 

n1, x); 

if
(res1 == n1 + 
1
) 

System.out.println(
""Not possible""
); 

else

System.out.println (res1); 
} 
} 

// This code is contributed by ajit ",CorCod,370,370,linear
"
/* Java program for Dynamic Programming implementation 

of Min Cost Path problem */
import
java.util.*; 

class
MinimumCostPath 
{ 

/* A utility function that returns minimum of 3 integers */

private
static
int
min(
int
x, 
int
y, 
int
z) 

{ 

if
(x < y) 

return
(x < z)? x : z; 

else

return
(y < z)? y : z; 

} 


private
static
int
minCost(
int
cost[][], 
int
m, 
int
n) 

{ 

int
i, j; 

int
tc[][]=
new
int
[m+
1
][n+
1
]; 


tc[
0
][
0
] = cost[
0
][
0
]; 


/* Initialize first column of total cost(tc) array */

for
(i = 
1
; i <= m; i++) 

tc[i][
0
] = tc[i-
1
][
0
] + cost[i][
0
]; 


/* Initialize first row of tc array */

for
(j = 
1
; j <= n; j++) 

tc[
0
][j] = tc[
0
][j-
1
] + cost[
0
][j]; 


/* Construct rest of the tc array */

for
(i = 
1
; i <= m; i++) 

for
(j = 
1
; j <= n; j++) 

tc[i][j] = min(tc[i-
1
][j-
1
], 

tc[i-
1
][j], 

tc[i][j-
1
]) + cost[i][j]; 


return
tc[m][n]; 

} 


/* Driver program to test above functions */

public
static
void
main(String args[]) 

{ 

int
cost[][]= {{
1
, 
2
, 
3
}, 

{
4
, 
8
, 
2
}, 

{
1
, 
5
, 
3
}}; 

System.out.println(minCost(cost,
2
,
2
)); 

} 
} 
// This code is contributed by Pankaj Kumar ",CorCod,408,408,quadratic
"
// Java implementation to find the character in 
// first string that is present at minimum index 
// in second string 

public
class
GFG 
{ 

// method to find the minimum index character 

static
void
printMinIndexChar(String str, String patt) 

{ 

// to store the index of character having 

// minimum index 

int
minIndex = Integer.MAX_VALUE; 


// lengths of the two strings 

int
m = str.length(); 

int
n = patt.length(); 


// traverse 'patt' 

for
(
int
i = 
0
; i < n; i++) { 


// for each character of 'patt' traverse 'str' 

for
(
int
j = 
0
; j < m; j++) { 


// if patt.charAt(i)is found in 'str', check if 

// it has the minimum index or not. If yes, 

// then update 'minIndex' and break 

if
(patt.charAt(i)== str.charAt(j) && j < minIndex) { 

minIndex = j; 

break
; 

} 

} 

} 


// print the minimum index character 

if
(minIndex != Integer.MAX_VALUE) 

System.out.println(
""Minimum Index Character = ""
+ 

str.charAt(minIndex)); 


// if no character of 'patt' is present in 'str' 

else

System.out.println(
""No character present""
); 

} 


// Driver Method 

public
static
void
main(String[] args) 

{ 

String str = 
""geeksforgeeks""
; 

String patt = 
""set""
; 

printMinIndexChar(str, patt); 

} 
} ",CorCod,439,439,quadratic
"
// Java program to minimize the 
// cost of array minimization 
import
java.util.Arrays; 

public
class
GFG { 

// Returns minimum possible 
// sum in array B[] 

static
int
minSum(
int
[] A, 
int
n) { 

int
min_val = Arrays.stream(A).min().getAsInt(); 

return
(min_val * (n - 
1
)); 

} 


// Driver Code 

static
public
void
main(String[] args) { 

int
[] A = {
3
, 
6
, 
2
, 
8
, 
7
, 
5
}; 

int
n = A.length; 

System.out.println((minSum(A, n))); 


} 
} 
// This code is contributed by Rajput-Ji ",CorCod,105,105,linear
"import java.util.*;
import java.io.*;


public class C994{
	static double area(double x1,double y1,double x2,double y2,double x3,double y3){
		return Math.abs((x1 * (y2 - y3) +  
        x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0); 
	}
	public static void main(String args[])throws IOException{
		Scanner sc=new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		PrintWriter pw=new PrintWriter(System.out);
		int x11=sc.nextInt();
		int y11=sc.nextInt();
		int x12=sc.nextInt();
		int y12=sc.nextInt();
		int x13=sc.nextInt();
		int y13=sc.nextInt();
		int x14=sc.nextInt();
		int y14=sc.nextInt();
		double x1c=(x11+x12+x13+x14)/4.0;
		double y1c=(y11+y12+y13+y14)/4.0;
		int x21=sc.nextInt();
		int y21=sc.nextInt();
		int x22=sc.nextInt();
		int y22=sc.nextInt();
		int x23=sc.nextInt();
		int y23=sc.nextInt();
		int x24=sc.nextInt();
		int y24=sc.nextInt();
		double x2c=(x21+x22+x23+x24)/4.0;
		double y2c=(y21+y22+y23+y24)/4.0;
		double a1=area(x11,y11,x12,y12,x13,y13)+area(x11,y11,x13,y13,x14,y14);
		double a2=area(x21,y21,x22,y22,x23,y23)+area(x21,y21,x23,y23,x24,y24);
		if(a1==area(x11,y11,x12,y12,x21,y21)+area(x11,y11,x21,y21,x14,y14)+area(x21,y21,x12,y12,x13,y13)+area(x21,y21,x14,y14,x13,y13)){
			pw.println(""YES"");
			pw.close();
			return;
		}
		if(a1==area(x11,y11,x12,y12,x22,y22)+area(x11,y11,x22,y22,x14,y14)+area(x22,y22,x12,y12,x13,y13)+area(x22,y22,x14,y14,x13,y13)){
			pw.println(""YES"");
			pw.close();
			return;
		}
		if(a1==area(x11,y11,x12,y12,x23,y23)+area(x11,y11,x23,y23,x14,y14)+area(x23,y23,x12,y12,x13,y13)+area(x23,y23,x14,y14,x13,y13)){
			pw.println(""YES"");
			pw.close();
			return;
		}
		if(a1==area(x11,y11,x12,y12,x24,y24)+area(x11,y11,x24,y24,x14,y14)+area(x24,y24,x12,y12,x13,y13)+area(x24,y24,x14,y14,x13,y13)){
			pw.println(""YES"");
			pw.close();
			return;
		}
		if(a1==area(x11,y11,x12,y12,x2c,y2c)+area(x11,y11,x2c,y2c,x14,y14)+area(x2c,y2c,x12,y12,x13,y13)+area(x2c,y2c,x14,y14,x13,y13)){
			pw.println(""YES"");
			pw.close();
			return;
		}
		if(a2==area(x21,y21,x22,y22,x11,y11)+area(x21,y21,x11,y11,x24,y24)+area(x11,y11,x22,y22,x23,y23)+area(x11,y11,x24,y24,x23,y23)){
			pw.println(""YES"");
			pw.close();
			return;
		}
		if(a2==area(x21,y21,x22,y22,x12,y12)+area(x21,y21,x12,y12,x24,y24)+area(x12,y12,x22,y22,x23,y23)+area(x12,y12,x24,y24,x23,y23)){
			pw.println(""YES"");
			pw.close();
			return;
		}
		if(a2==area(x21,y21,x22,y22,x13,y13)+area(x21,y21,x13,y13,x24,y24)+area(x13,y13,x22,y22,x23,y23)+area(x13,y13,x24,y24,x23,y23)){
			pw.println(""YES"");
			pw.close();
			return;
		}
		if(a2==area(x21,y21,x22,y22,x14,y14)+area(x21,y21,x14,y14,x24,y24)+area(x14,y14,x22,y22,x23,y23)+area(x14,y14,x24,y24,x23,y23)){
			pw.println(""YES"");
			pw.close();
			return;
		}
		if(a2==area(x21,y21,x22,y22,x1c,y1c)+area(x21,y21,x14,y14,x2c,y2c)+area(x1c,y1c,x22,y22,x23,y23)+area(x1c,y1c,x24,y24,x23,y23)){
			pw.println(""YES"");
			pw.close();
			return;
		}
		
		pw.println(""NO"");
		pw.close();
	}
}",CorCod,846,846,constant
"package com.interview.binarysearch;

/**
 * @author Tushar Roy
 * Date 01/22/17
 *
 * Search in sorted and rotated array. In one version duplicate is not allowed and
 * in another version duplicate is allowed.
 *
 * Time complexity with no duplicate - O(logn)
 * Time complexity with duplicates - O(n)
 *
 * https://leetcode.com/problems/search-in-rotated-sorted-array/
 * https://leetcode.com/problems/search-in-rotated-sorted-array-ii/
 */
public class SortedAndRotatedArraySearch {

    /**
     * Duplicates are not allowed in arr.
     */
    public int search(int arr[],int search){
        int low =0;
        int high = arr.length-1;
        while(low <= high){
            int mid = (low + high)/2;
            if(arr[mid] == search){
                return mid;
            }
            
            if(arr[mid] < arr[high]){
                if(arr[mid] < search && search <= arr[high]){
                    low = mid+1;
                }else{
                    high = mid-1;
                }
            }else{
                if(search >= arr[low] && search < arr[mid]){
                    high = mid-1;
                }else{
                    low = mid+1;
                }
            }
        }
        return -1;
    }

    /**
     * Duplicates are allowed in arr.
     */
    public boolean searchWithDuplicates(int[] arr, int search) {
        int low =0;
        int high = arr.length-1;
        while(low <= high){
            int mid = (low + high)/2;
            if(arr[mid] == search) {
                return true;
            }
            //if low is same as mid then increment low.
            if (arr[mid] == arr[low]) {
                low++;
            } else if (arr[mid] == arr[high]) { //if high is same as mid then decrement high.
                high--;
            } else if (arr[mid] < arr[high]) {
                if(arr[mid] < search && search <= arr[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            } else {
                if(search >= arr[low] && search < arr[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
        }
        return false;
    }
    
    public static void main(String args[]){
        SortedAndRotatedArraySearch ras = new SortedAndRotatedArraySearch();
        int arr1[] = {1,2,5,6,7,8,11,21};
        System.out.print(ras.search(arr1, 1));
        System.out.print(ras.search(arr1, 5));
        System.out.print(ras.search(arr1, 22));
        System.out.println();
    
        int arr2[] = {18,21,1,2,5,6,7,8,10,15};
        System.out.print(ras.search(arr2, 1));
        System.out.print(ras.search(arr2, 5));
        System.out.print(ras.search(arr2, 10));
        System.out.print(ras.search(arr2, 14));
        System.out.println();

        int arr3[] = {7,8,15,17,18,21,1,2,5,6};
        System.out.print(ras.search(arr3, 1));
        System.out.print(ras.search(arr3, 5));
        System.out.print(ras.search(arr3, 10));
        System.out.print(ras.search(arr3, 7));
        System.out.print(ras.search(arr3, 6));
        System.out.print(ras.search(arr3, 16));
    }
}",CorCod,890,890,logn
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Cf1003A {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int[] arr = new int[100];
        int max = 0;
        int tmp;
        for (int i = 0; i < n; i++) {
            tmp = Integer.parseInt(stk.nextToken()) - 1;
           max = max < ++arr[tmp] ? arr[tmp] : max;
        }
        System.out.println(max);
    }
}",CorCod,136,136,linear
"
// Java code to find minimum number of elements 
// such that their sum is greater than sum of 
// remaining elements of the array. 
import
java.io.*; 
import
java.util.*; 

class
GFG { 


// Function to find minimum elements needed 

static
int
minElements(
int
arr[], 
int
n) 

{ 

// Calculating HALF of array sum 

int
halfSum = 
0
; 

for
(
int
i = 
0
; i < n; i++) 

halfSum = halfSum + arr[i]; 

halfSum = halfSum / 
2
; 



// Sort the array in ascending order and 

// start traversing array from the ascending 

// sort in descending order. 

Arrays.sort(arr); 


int
res = 
0
, curr_sum = 
0
; 

for
(
int
i = n-
1
; i >= 
0
; i--) { 


curr_sum += arr[i]; 

res++; 


// Current sum greater than sum 

if
(curr_sum > halfSum) 

return
res; 

} 

return
res; 

} 


// Driver Code 

public
static
void
main (String[] args) { 

int
arr[] = {
3
, 
1
, 
7
, 
1
}; 

int
n = arr.length; 

System.out.println(minElements(arr, n)); 

} 

} 

// This code is contributed by Gitanjali ",CorCod,587,587,nlogn
"
// Java implementation of worst 
// case linear time algorithm 
// to find k'th smallest element 
import
java.util.*; 

class
GFG 
{ 

// int partition(int arr[], int l, int r, int k); 

// A simple function to find median of arr[]. This is called 
// only for an array of size 5 in this program. 
static
int
findMedian(
int
arr[], 
int
i,
int
n) 
{ 

if
(i <= n) 

Arrays.sort(arr, i, n); 
// Sort the array 

else

Arrays.sort(arr, n, i); 

return
arr[n/
2
]; 
// Return middle element 
} 

// Returns k'th smallest element 
// in arr[l..r] in worst case 
// linear time. ASSUMPTION: ALL 
// ELEMENTS IN ARR[] ARE DISTINCT 
static
int
kthSmallest(
int
arr[], 
int
l, 
int
r, 
int
k) 
{ 

// If k is smaller than 

// number of elements in array 

if
(k > 
0
&& k <= r - l + 
1
) 

{ 

int
n = r - l + 
1
; 
// Number of elements in arr[l..r] 


// Divide arr[] in groups of size 5, 

// calculate median of every group 

// and store it in median[] array. 

int
i; 


// There will be floor((n+4)/5) groups; 

int
[]median = 
new
int
[(n + 
4
) / 
5
]; 

for
(i = 
0
; i < n/
5
; i++) 

median[i] = findMedian(arr,l + i * 
5
, 
5
); 


// For last group with less than 5 elements 

if
(i*
5
< n) 

{ 

median[i] = findMedian(arr,l + i * 
5
, n % 
5
); 

i++; 

} 


// Find median of all medians using recursive call. 

// If median[] has only one element, then no need 

// of recursive call 

int
medOfMed = (i == 
1
)? median[i - 
1
]: 

kthSmallest(median, 
0
, i - 
1
, i / 
2
); 


// Partition the array around a random element and 

// get position of pivot element in sorted array 

int
pos = partition(arr, l, r, medOfMed); 


// If position is same as k 

if
(pos-l == k - 
1
) 

return
arr[pos]; 

if
(pos-l > k - 
1
) 
// If position is more, recur for left 

return
kthSmallest(arr, l, pos - 
1
, k); 


// Else recur for right subarray 

return
kthSmallest(arr, pos + 
1
, r, k - pos + l - 
1
); 

} 


// If k is more than number of elements in array 

return
Integer.MAX_VALUE; 
} 

static
int
[] swap(
int
[]arr, 
int
i, 
int
j) 
{ 

int
temp = arr[i]; 

arr[i] = arr[j]; 

arr[j] = temp; 

return
arr; 
} 

// It searches for x in arr[l..r], and 
// partitions the array around x. 
static
int
partition(
int
arr[], 
int
l, 

int
r, 
int
x) 
{ 

// Search for x in arr[l..r] and move it to end 

int
i; 

for
(i = l; i < r; i++) 

if
(arr[i] == x) 

break
; 

swap(arr, i, r); 


// Standard partition algorithm 

i = l; 

for
(
int
j = l; j <= r - 
1
; j++) 

{ 

if
(arr[j] <= x) 

{ 

swap(arr, i, j); 

i++; 

} 

} 

swap(arr, i, r); 

return
i; 
} 

// Driver code 
public
static
void
main(String[] args) 
{ 

int
arr[] = {
12
, 
3
, 
5
, 
7
, 
4
, 
19
, 
26
}; 

int
n = arr.length, k = 
3
; 

System.out.println(
""K'th smallest element is ""

+ kthSmallest(arr, 
0
, n - 
1
, k)); 
} 
} 

// This code has been contributed by 29AjayKumar ",CorCod,35,35,linear
"import java.io.*;
import java.util.*;
import java.math.*;
import java.lang.*;
 
import static java.lang.Math.*;

public class Main implements Runnable {
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }
        
        public int read() {
            if (numChars==-1) 
                throw new InputMismatchException();
            
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                }
                catch (IOException e) {
                    throw new InputMismatchException();
                }
                
                if(numChars <= 0)               
                    return -1;
            }
            return buf[curChar++];
        }
     
        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            int c = read();
            
            while(isSpaceChar(c)) 
                c = read();
            
            int sgn = 1;
            
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            
            int res = 0;
            do {
                if(c<'0'||c>'9') 
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c)); 
            
            return res * sgn;
        }
        
        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
                return res * sgn;
        }
        
        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }
        
        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } 
            while (!isSpaceChar(c));
            
            return res.toString();
        }
     
        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
     
        public String next() {
            return readString();
        }
        
        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    public static void main(String args[]) throws Exception {
        new Thread(null, new Main(),""Main"",1<<26).start();
    }
    public void run() {
        InputReader sc = new InputReader(System.in);
        PrintWriter w = new PrintWriter(System.out);
             
            int n=sc.nextInt();
            long s=sc.nextLong();
            long arr[]=new long[n];
            int i=0;
            for(i=0;i<n;i++)
            {
                              arr[i]=sc.nextLong();
            }
            Arrays.sort(arr);
            
            /*for(i=0;i<n;i++)
            {
                              w.println(arr[i]);
            }*/
            long count=0;
            if(arr[n/2]==s)
            {
                              
                              w.print(0);
            }
            else
            {
                              int temp=n/2;
                              
                              if(arr[temp]>s)
                              {
                                                while(arr[temp]>s)
                                                {
                                                                  count=count+(arr[temp]-s);
                                                                  temp--;
                                                                  if(temp<0)
                                                                  {
                                                                                    break;
                                                                  }
                                                }
                              }
                              else
                              {
                                               
                                               while(arr[temp]<s)
                                               {
                                                                 
                                                                 count=count+(s-arr[temp]);
                                                                 temp++;
                                                                 if(temp>=n)
                                                                 {
                                                                                   break;
                                                                 }
                                               }
                              }
                              w.print(count);
            }
            
               
               

        w.close();
    }
}",CorCod,709,709,nlogn
"import java.io.*;
import java.math.BigInteger; 
import java.util.*;



//Mann Shah [ DAIICT ].
//fast io

public class Main {
	static int mod = (int) (1e9+7);
	static InputReader in;
    static PrintWriter out;
    
    		public static int n;
    		public static int m;
    
    		public static boolean valid(int i , int j) {
    			
    			return ( i<n && j<m && i>=0 && j>=0);
    		}
    		
   
		public static void main(String args[] )  {
			
		  in = new InputReader(System.in);
	      out = new PrintWriter(System.out);
	     
	     n = in.nextInt();
	    	 m = in.nextInt();
	    
	    	String[] s = new String[n];
	    	for(int i=0;i<n;i++) {
	    		s[i]= in.readString();
	    	}
	    	int f=0;
	    	for(int i=0;i<n;i++) {
	    		for(int j=0;j<s[i].length();j++) {
	    			int val=-1;
	    			if(s[i].charAt(j)=='.') {
	    				val=0;
	    			}
	    			else if(s[i].charAt(j)=='*') {
	    				continue;
	    			}
	    			else {
	    				val = s[i].charAt(j)-'0';
	    			}
	    			int c=0;
	    			if(valid(i-1,j) && s[i-1].charAt(j)=='*'){
	    				c++;
	    			}
	    			if(valid(i-1,j-1) && s[i-1].charAt(j-1)=='*'){
	    				c++;
	    			}
	    			if(valid(i-1,j+1) && s[i-1].charAt(j+1)=='*'){
	    				c++;
	    			}
	    			if(valid(i,j-1) && s[i].charAt(j-1)=='*'){
	    				c++;
	    			}
	    			if(valid(i,j+1) && s[i].charAt(j+1)=='*'){
	    				c++;
	    			}
	    			if(valid(i+1,j) && s[i+1].charAt(j)=='*'){
	    				c++;
	    			}
	    			if(valid(i+1,j+1) && s[i+1].charAt(j+1)=='*'){
	    				c++;
	    			}
	    			if(valid(i+1,j-1) && s[i+1].charAt(j-1)=='*'){
	    				c++;
	    			}
	    			if(c!=val) {
	    				f=1;
	    				break;
	    			}
	    		}
	    	}
	    	if(f==0) {
	    		out.println(""YES"");
	    	}
	    	else {
	    		out.println(""NO"");
	    	}
	     
	     
	     out.close();
		}
		

		
		static class InputReader
	    {

	        private final InputStream stream;
	        private final byte[] buf = new byte[8192];
	        private int curChar, snumChars;
	        private SpaceCharFilter filter;

	        public InputReader(InputStream stream)
	        {
	                this.stream = stream;
	        }

	        public int snext()
	        {
	                if (snumChars == -1)
	                        throw new InputMismatchException();
	                if (curChar >= snumChars)
	                {
	                        curChar = 0;
	                        try
	                        {
	                                snumChars = stream.read(buf);
	                        } catch (IOException e)
	                        {
	                                throw new InputMismatchException();
	                        }
	                        if (snumChars <= 0)
	                                return -1;
	                }
	                return buf[curChar++];
	        }

	        public int nextInt()
	        {
	                int c = snext();
	                while (isSpaceChar(c))
	                {
	                        c = snext();
	                }
	                int sgn = 1;
	                if (c == '-')
	                {
	                        sgn = -1;
	                        c = snext();
	                }
	                int res = 0;
	                do
	                {
	                        if (c < '0' || c > '9')
	                                throw new InputMismatchException();
	                        res *= 10;
	                        res += c - '0';
	                        c = snext();
	                } while (!isSpaceChar(c));
	                return res * sgn;
	        }

	        public long nextLong()
	        {
	                int c = snext();
	                while (isSpaceChar(c))
	                {
	                        c = snext();
	                }
	                int sgn = 1;
	                if (c == '-')
	                {
	                        sgn = -1;
	                        c = snext();
	                }
	                long res = 0;
	                do
	                {
	                        if (c < '0' || c > '9')
	                                throw new InputMismatchException();
	                        res *= 10;
	                        res += c - '0';
	                        c = snext();
	                } while (!isSpaceChar(c));
	                return res * sgn;
	        }

	        public int[] nextIntArray(int n)
	        {
	                int a[] = new int[n];
	                for (int i = 0; i < n; i++)
	                {
	                        a[i] = nextInt();
	                }
	                return a;
	        }

	        public long[] nextLongArray(int n)
	        {
	                long a[] = new long[n];
	                for (int i = 0; i < n; i++)
	                {
	                        a[i] = nextLong();
	                }
	                return a;
	        }

	        public String readString()
	        {
	                int c = snext();
	                while (isSpaceChar(c))
	                {
	                        c = snext();
	                }
	                StringBuilder res = new StringBuilder();
	                do
	                {
	                        res.appendCodePoint(c);
	                        c = snext();
	                } while (!isSpaceChar(c));
	                return res.toString();
	        }

	        public String nextLine()
	        {
	                int c = snext();
	                while (isSpaceChar(c))
	                        c = snext();
	                StringBuilder res = new StringBuilder();
	                do
	                {
	                        res.appendCodePoint(c);
	                        c = snext();
	                } while (!isEndOfLine(c));
	                return res.toString();
	        }

	        public boolean isSpaceChar(int c)
	        {
	                if (filter != null)
	                        return filter.isSpaceChar(c);
	                return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	        }

	        private boolean isEndOfLine(int c)
	        {
	                return c == '\n' || c == '\r' || c == -1;
	        }

	        public interface SpaceCharFilter
	        {
	                public boolean isSpaceChar(int ch);
	        }

	    }
		
}

//For Pair sorting

//Arrays.sort(arr,new Comparator<Pair>() {
//		@Override public int compare(Pair p1, Pair p2) 
//{ 
//    return p1.x - p2.x; 
//} 
//});



//Pair arr[] = new Pair[n]; 
//arr[0] = new Pair(10, 20); 
class Pair { 
    int x; 
    int y; 
  
    // Constructor 
public Pair(int x, int y) 
    { 
        this.x = x; 
        this.y = y; 
    } 
} 
// class Compare { 
//	  //void return by default.
//     public  Pair[] compare(Pair arr[], int n) 
//    { 
//        // Comparator to sort the pair according to first element.
//        Arrays.sort(arr, new Comparator<Pair>() { 
//            @Override public int compare(Pair p1, Pair p2) 
//            { 
//                return p1.x - p2.x; 
//            } 
//        }); 
//        
//        
//        return arr;
//       /* for (int i = 0; i < n; i++) { 
//            System.out.print(arr[i].x + "" "" + arr[i].y + "" ""); 
//        } 
//        System.out.println(); */
//    } 
//} 
//



class couple implements Comparable<couple>
{ int x,y;
  public couple(int m,int f) {
 	 x=m;
 	 y=f;
  }
	public int compareTo(couple o) {
		
		 
		return x-o.x;
	}  
}
",CorCod,537,537,quadratic
"import java.util.*;
import java.io.*;
public class Solution{
    
    public static long page(long p,long k){
        
        return (p-1)/k;
        
    }
    
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        
        long n = sc.nextLong();
        int m = sc.nextInt();
        long k = sc.nextLong();
        long[] p = new long[m];
        long del = 0;
        long nb = 1;
        int op = 0;
        for(int i=0;i<m;i++) p[i] = sc.nextLong();
        for(int i=1;i<m;i++){
            if(page(p[i]-del,k)!=page(p[i-1]-del,k)){
                
                del += nb;
                nb = 1;
                op++;
                
            }else{
                nb++;
                
            }
        }
        if(nb!=0) op++;
        
        System.out.println(op);
        
    }
    
}",CorCod,124,124,linear
"import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
		int n = sc.nextInt();
		int pos = sc.nextInt();
		int l = sc.nextInt();
		int r = sc.nextInt();
		/*if(l==r) {
			System.out.print(Math.abs(r-pos)+1);
		}*/
		if(l==1&&r==n) {
			System.out.println(0);
		}
		else if(l==1&&r<n) {
			System.out.println(Math.abs(r-pos)+1);
		}
		else if(l>1&&r==n) {
			System.out.println(Math.abs(l-pos)+1);
		}
		else if(l>1&&r<n) {
			int c = Math.min(Math.abs(r-pos), Math.abs(l-pos));//Math.abs(r-pos)>Math.abs(l-pos)?Math.abs(l-pos):Math.abs(r-pos);
			System.out.println(c+2+r-l);
		}
		}
	}	
}





",CorCod,839,839,constant
"
// A Java program to divide and conquer based 
// efficient solution to find 
// median of two sorted arrays 
// of same size. 
import
java.util.*; 
class
GfG { 

/* This function returns median 
of ar1[] and ar2[]. 
Assumptions in this function: 

Both ar1[] and ar2[] are 

sorted arrays 

Both have n elements */
static
int
getMedian(
int
ar1[], 
int
ar2[], 
int
n) 
{ 

/* return -1 for 

invalid input */

if
(n <= 
0
) 

return
-
1
; 

if
(n == 
1
) 

return
(ar1[
0
] + ar2[
0
]) / 
2
; 

if
(n == 
2
) 

return
(Math.max(ar1[
0
], ar2[
0
]) + Math.min(ar1[
1
], ar2[
1
])) / 
2
; 


/* get the median of 

the first array */

int
m1 = median(ar1, n); 


/* get the median of 

the second array */

int
m2 = median(ar2, n); 


/* If medians are equal then 

return either m1 or m2 */

if
(m1 == m2) 

return
m1; 


/* if m1 < m2 then median must 

exist in ar1[m1....] and 

ar2[....m2] */

if
(m1 < m2) 

{ 

if
(n % 
2
== 
0
) 

return
getMedian(ar1 + n / 
2
- 
1
, ar2, n - n / 
2
+ 
1
); 

return
getMedian(ar1 + n / 
2
, ar2, n - n / 
2
); 

} 


/* if m1 > m2 then median must 

exist in ar1[....m1] and 

ar2[m2...] */

if
(n % 
2
== 
0
) 

return
getMedian(ar2 + n / 
2
- 
1
, ar1, n - n / 
2
+ 
1
); 

return
getMedian(ar2 + n / 
2
, ar1, n - n / 
2
); 
} 

/* Function to get median 
of a sorted array */
static
int
median(
int
arr[], 
int
n) 
{ 

if
(n % 
2
== 
0
) 

return
(arr[n / 
2
] + arr[n / 
2
- 
1
]) / 
2
; 

else

return
arr[n / 
2
]; 
} 

// Driver code 
public
static
void
main(String[] args) 
{ 

int
ar1[] = {
1
, 
2
, 
3
, 
6
}; 

int
ar2[] = {
4
, 
6
, 
8
, 
10
}; 

int
n1 = ar1.length; 

int
n2 = ar2.length; 

if
(n1 == n2) 

System.out.println(
""Median is ""
+ getMedian(ar1, ar2, n1)); 

else

System.out.println(
""Doesn't work for arrays ""
+ 
""of unequal size""
); 
} 
} ",CorCod,894,894,logn
"
// Java program to find minimum 
// difference between groups of 
// highest and lowest sums. 
import
java.util.Arrays; 
import
java.util.Collections; 
import
java.util.Vector; 


class
GFG { 

static
long
calculate(
long
a[], 
int
n) 
{ 

// Sorting the whole array. 

Arrays.sort(a); 

int
i,j; 


// Generating sum groups. 

Vector<Long> s = 
new
Vector<>(); 

for
(i = 
0
, j = n - 
1
; i < j; i++, j--) 

s.add((a[i] + a[j])); 


long
mini = Collections.min(s); 

long
maxi = Collections.max(s); 

return
Math.abs(maxi - mini); 
} 

// Driver code 
public
static
void
main(String[] args) 
{ 

long
a[] = { 
2
, 
6
, 
4
, 
3
}; 

int
n = a.length; 

System.out.println(calculate(a, n)); 

} 
} 
// This code is contributed by 29AjayKumar ",CorCod,719,719,nlogn
"
// Java code for k largest elements in an array 
import
java.util.Arrays; 
import
java.util.Collections; 

class
GFG { 

public
static
void
kLargest(Integer[] arr, 
int
k) 

{ 

// Sort the given array arr in reverse order 

// This method doesn't work with primitive data 

// types. So, instead of int, Integer type 

// array will be used 

Arrays.sort(arr, Collections.reverseOrder()); 


// Print the first kth largest elements 

for
(
int
i = 
0
; i < k; i++) 

System.out.print(arr[i] + 
"" ""
); 

} 


public
static
void
main(String[] args) 

{ 

Integer arr[] = 
new
Integer[] { 
1
, 
23
, 
12
, 
9
, 

30
, 
2
, 
50
}; 

int
k = 
3
; 

kLargest(arr, k); 

} 
} 
// This code is contributed by Kamal Rawal ",CorCod,708,708,nlogn
"import java.util.*;

public class helloWorld 
{
	public static void main(String[] args) 
	{		
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int m = in.nextInt();
		int[] ar = new int[200];
		
		String str = in.next();
		for(int i = 0; i < str.length(); i++)
			ar[ str.charAt(i) ]++;
			
		int ans = 100000;
		
		for(int i = 'A'; i < 'A' + m; i++)
			ans = Math.min(ans, ar[i]);
		ans *= m;
		
		System.out.println(ans);
		
		in.close();
	}
}

",CorCod,313,313,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;

public class Main {
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		String[] s = br.readLine().trim().split("" "");
		int n = Integer.parseInt(s[0]);
		int m = Integer.parseInt(s[1]);
		long b[] = new long[n];
		s = br.readLine().trim().split("" "");
		for(int i = 0; i < n; i++) {
			b[i] = Integer.parseInt(s[i]);
		}
		long g[] = new long[m];
		s = br.readLine().trim().split("" "");
		for(int i = 0; i < m; i++) {
			g[i] = Integer.parseInt(s[i]);
		}
		Arrays.sort(b);
		Arrays.sort(g);
		if(g[0] < b[n-1]) {
			System.out.println(""-1"");
		}
		else if(g[0] == b[n-1]){
			long ans = 0;
			for(int i = 0; i < m; i++) {
				ans += g[i];
			}
			for(int i = 0; i < n-1; i++) {
				ans += (m)*b[i];
			}
			System.out.println(ans);

		}
		else {
			long ans = 0;
			for(int i = 0; i < m; i++) {
				ans += g[i];
			}
			for(int i = 0; i < n-1; i++) {
				ans += (m)*b[i];
			}
			ans += b[n-1]-b[n-2];
			System.out.println(ans);

		}
	}
}",CorCod,714,714,nlogn
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

public class Solution {
    private static int[] dx = {
            -1, -1, -1,
            0, 0,
            1, 1, 1};
    private static int[] dy = {
            -1, 0, 1,
            -1, 1,
            -1, 0, 1};

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));


        int r = in.nextInt();
        int c = in.nextInt();
        boolean[][] m = new boolean[r + 1][c + 1];
        boolean[][] inp = new boolean[r + 1][c + 1];
        for (int i = 0; i < r; i++) {
            String s = in.next();
            //System.out.println(m[i]);
            for (int j = 0; j < s.length(); j++) {
                if (s.charAt(j) == '#') {
                    m[i][j] = true;
                    inp[i][j] = true;
                }
            }
        }

        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                if (canPress(i, j, r, c, inp)) {

                    // make press
                    for (int k = 0; k < 8; k++) {
                        int xi = i + dx[k];
                        int yi = j + dy[k];
                        m[xi][yi] = false;
                    }

                }
            }
        }
        boolean isLeftAny = false;
        for (int i = 0; i < r && !isLeftAny; i++) {
            for (int j = 0; j < c && !isLeftAny; j++) {
                if (m[i][j]) {
                    isLeftAny = true;
                    break;
                }
            }
        }
        if(isLeftAny){
            System.out.println(""NO"");
        }else{
            System.out.println(""YES"");
        }
    }

    private static boolean canPress(int x, int y, int r, int c, boolean[][] inp) {
        for (int i = 0; i < 8; i++) {
            int xi = x + dx[i];
            int yi = y + dy[i];
            if (xi < 0 || yi < 0) {
                return false;
            }
            if (xi >= r || yi >= c) {
                return false;
            }
            if(!inp[xi][yi]){
                return false;
            }
        }
        return true;
    }
}

",CorCod,566,566,quadratic
"
// Java program to rearrange an 
// array in minimum maximum form 

public
class
Main { 


// Prints max at first position, min at second 

// position second max at third position, second 

// min at fourth position and so on. 

public
static
void
rearrange(
int
arr[], 
int
n) 

{ 

// initialize index of first minimum and first 

// maximum element 

int
max_ele = arr[n - 
1
]; 

int
min_ele = arr[
0
]; 

// traverse array elements 

for
(
int
i = 
0
; i < n; i++) { 

// at even index : we have to put maximum element 

if
(i % 
2
== 
0
) { 

arr[i] = max_ele; 

max_ele -= 
1
; 

} 


// at odd index : we have to put minimum element 

else
{ 

arr[i] = min_ele; 

min_ele += 
1
; 

} 

} 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
arr[] = { 
1
, 
2
, 
3
, 
4
, 
5
, 
6
, 
7
, 
8
, 
9
}; 

int
n = arr.length; 


System.out.println(
""Original Array""
); 

for
(
int
i = 
0
; i < n; i++) 

System.out.print(arr[i] + 
"" ""
); 


rearrange(arr, n); 


System.out.print(
""\nModified Array\n""
); 

for
(
int
i = 
0
; i < n; i++) 

System.out.print(arr[i] + 
"" ""
); 

} 
} ",CorCod,361,361,linear
"
// Java implementation of finding length of longest 
// Common substring using Dynamic Programming 
public
class
LongestCommonSubSequence 
{ 

/* 

Returns length of longest common substring 

of X[0..m-1] and Y[0..n-1] 

*/

static
int
LCSubStr(
char
X[], 
char
Y[], 
int
m, 
int
n) 

{ 

// Create a table to store lengths of longest common suffixes of 

// substrings. Note that LCSuff[i][j] contains length of longest 

// common suffix of X[0..i-1] and Y[0..j-1]. The first row and 

// first column entries have no logical meaning, they are used only 

// for simplicity of program 

int
LCStuff[][] = 
new
int
[m + 
1
][n + 
1
]; 

int
result = 
0
; 
// To store length of the longest common substring 


// Following steps build LCSuff[m+1][n+1] in bottom up fashion 

for
(
int
i = 
0
; i <= m; i++) 

{ 

for
(
int
j = 
0
; j <= n; j++) 

{ 

if
(i == 
0
|| j == 
0
) 

LCStuff[i][j] = 
0
; 

else
if
(X[i - 
1
] == Y[j - 
1
]) 

{ 

LCStuff[i][j] = LCStuff[i - 
1
][j - 
1
] + 
1
; 

result = Integer.max(result, LCStuff[i][j]); 

} 

else

LCStuff[i][j] = 
0
; 

} 

} 

return
result; 

} 


// Driver Program to test above function 

public
static
void
main(String[] args) 

{ 

String X = 
""OldSite:GeeksforGeeks.org""
; 

String Y = 
""NewSite:GeeksQuiz.com""
; 


int
m = X.length(); 

int
n = Y.length(); 


System.out.println(
""Length of Longest Common Substring is ""

+ LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); 

} 
} 

// This code is contributed by Sumit Ghosh ",CorCod,447,447,quadratic
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.StringTokenizer;

public class RadioStation {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		int n = nextInt();
		int m = nextInt();
		Map<String, String> map = new HashMap<String, String>();
		for (int i = 0; i < n; i++) {
			String s = nextString();
			String t = nextString();
			map.put(t, s);
		}
		for (int i = 0; i < m; i++) {
			String s = nextString();
			String t = nextString();
			System.out.println(s + "" "" + t + "" #"" + map.get(t.substring(0, t.length()-1)));
		}
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",CorCod,685,685,nlogn
" 
 


import java.util.Scanner;
import javafx.geometry.Point2D;

 
public class ChessKing {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
Scanner input = new Scanner(System.in);
long size = input.nextLong();
long a = input.nextLong();
long b = input.nextLong();
  long sum = a+b;
   long d = sum-2;
   long d1 = size*2 - sum;
if(d<d1) System.out.println(""White"");
else if(d>d1) System.out.println(""Black"");
else System.out.println(""White"");


    }
    
}
",CorCod,858,858,constant
"import java.util.HashSet;
import java.util.Scanner;


public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0; i<n; i++){
            int a = sc.nextInt();
            if(a!=0){
                set.add(a);
            }
        }
        System.out.println(set.size());
    }
}",CorCod,1,1,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Test3 {
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int x=Integer.parseInt(br.readLine());
		int y=Integer.parseInt(br.readLine());
		System.out.print((int)(y%(Math.pow(2, x))));
	}
}
",CorCod,799,799,constant
"import java.io.*;
import java.util.*;

public class Solution {
    static class Data{
        int x,i;
        Data(int x,int i){
            this.x = x;
            this.i = i;
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s = br.readLine().split(""\\s"");
        int N = Integer.parseInt(s[0]);
        int K = Integer.parseInt(s[1]);
        s = br.readLine().split(""\\s"");
        int[] arr = new int[N];
        for(int i=0;i<N;++i) arr[i] = Integer.parseInt(s[i]);
        solve(N,K,arr);   
    }
    
    private static void solve(int N,int K,int[] arr){
       PriorityQueue<Data> pq = new PriorityQueue<Data>(2000,(a,b) -> a.x - b.x == 0 ? b.i - a.i : b.x - a.x);
       for(int i=0;i<arr.length;++i){
           pq.offer(new Data(arr[i],i));
       }
       
       int tot_sum = 0;
       List<Integer> ls = new ArrayList<>();
       Set<Integer> set = new HashSet<>();
       
       for(int i=1;i<=K;++i){
           Data t = pq.poll();
           tot_sum += t.x;
           set.add(t.i);
       }
       int last = -1;
       for(int i =0;i<arr.length;++i){
           if(set.contains(i)){
               K--;
               //System.out.println(i);
               if(K == 0) ls.add(arr.length-last-1);
               else ls.add(i-last);
               last = i;
           }
       }
       
       System.out.println(tot_sum);
       int size = ls.size();
       for(int i=0;i<size;++i){
           System.out.print(ls.get(i) + "" "");
       }
    }
}",CorCod,696,696,nlogn
"import java.io.*;
import java.util.*;

public class MainG {
	static StdIn in = new StdIn();
	static PrintWriter out = new PrintWriter(System.out);
	static long M=(long)1e9+7;
	
	public static void main(String[] args) {
		char[] cs = in.next().toCharArray();
		int n=cs.length;
		int[] x = new int[n];
		for(int i=0; i<n; ++i)
			x[i]=cs[i]-'0';
		long[] dp1 = new long[n+1];
		for(int i=0; i<n; ++i) 
			dp1[i+1]=(x[i]+dp1[i]*10)%M;
		long ans=0;
		for(int d1=1; d1<=9; ++d1) {
			long[][] dp2 = new long[2][n+1];
			for(int i=0; i<n; ++i) {
				dp2[0][i+1]=x[i]>=d1?(10*dp2[0][i]+1)%M:dp2[0][i];
				for(int d2=0; d2<x[i]; ++d2)
					dp2[1][i+1]=((d2>=d1?10*(dp2[0][i]+dp2[1][i])+dp1[i]+1:dp2[0][i]+dp2[1][i])+dp2[1][i+1])%M;
				for(int d2=x[i]; d2<=9; ++d2)
					dp2[1][i+1]=((d2>=d1?10*dp2[1][i]+dp1[i]:dp2[1][i])+dp2[1][i+1])%M;
			}
			ans+=dp2[0][n]+dp2[1][n];
		}
		out.println(ans%M);
		out.close();
	}
	
	interface Input {
		public String next();
		public String nextLine();
		public int nextInt();
		public long nextLong();
		public double nextDouble();
	}
	static class StdIn implements Input {
		final private int BUFFER_SIZE = 1 << 16;
		private DataInputStream din;
		private byte[] buffer;
		private int bufferPointer, bytesRead;
		public StdIn() {
			din = new DataInputStream(System.in);
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public StdIn(InputStream in) {
			try{
				din = new DataInputStream(in);
			} catch(Exception e) {
				throw new RuntimeException();
			}
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public String next() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == ' ' || c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c=read();
			}
			return s.toString();
		}
		public String nextLine() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c = read();
			}
			return s.toString();
		}
		public int nextInt() {
			int ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');

			if (neg)
				return -ret;
			return ret;
		}
		public int[] readIntArray(int n) {
			int[] ar = new int[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextInt();
			return ar;
		}
		public long nextLong() {
			long ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (neg)
				return -ret;
			return ret;
		}
		public long[] readLongArray(int n) {
			long[] ar = new long[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextLong();
			return ar;
		}
		public double nextDouble() {
			double ret = 0, div = 1;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (c == '.')
				while ((c = read()) >= '0' && c <= '9')
					ret += (c - '0') / (div *= 10);
			if (neg)
				return -ret;
			return ret;
		}
		private void fillBuffer() throws IOException {
			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
			if (bytesRead == -1)
				buffer[0] = -1;
		}
		private byte read() {
			try{
				if (bufferPointer == bytesRead)
					fillBuffer();
				return buffer[bufferPointer++];
			} catch(IOException e) {
				throw new RuntimeException();
			}
		}
		public void close() throws IOException {
			if (din == null)
				return;
			din.close();
		}
	}
}",CorCod,406,406,quadratic
"
// Java program to implement sorting a 
// queue data structure 
import
java.util.LinkedList; 
import
java.util.Queue; 
class
GFG 
{ 

// Queue elements after sortIndex are 

// already sorted. This function returns 

// index of minimum element from front to 

// sortIndex 

public
static
int
minIndex(Queue<Integer> list, 

int
sortIndex) 

{ 

int
min_index = -
1
; 

int
min_value = Integer.MAX_VALUE; 

int
s = list.size(); 

for
(
int
i = 
0
; i < s; i++) 

{ 

int
current = list.peek(); 


// This is dequeue() in Java STL 

list.poll(); 


// we add the condition i <= sortIndex 

// because we don't want to traverse 

// on the sorted part of the queue, 

// which is the right part. 

if
(current <= min_value && i <= sortIndex) 

{ 

min_index = i; 

min_value = current; 

} 

list.add(current); 

} 

return
min_index; 
} 


// Moves given minimum element 

// to rear of queue 

public
static
void
insertMinToRear(Queue<Integer> list, 

int
min_index) 

{ 

int
min_value = 
0
; 

int
s = list.size(); 

for
(
int
i = 
0
; i < s; i++) 

{ 

int
current = list.peek(); 

list.poll(); 

if
(i != min_index) 

list.add(current); 

else

min_value = current; 

} 

list.add(min_value); 

} 


public
static
void
sortQueue(Queue<Integer> list) 

{ 

for
(
int
i = 
1
; i <= list.size(); i++) 

{ 

int
min_index = minIndex(list,list.size() - i); 

insertMinToRear(list, min_index); 

} 

} 


//Driver function 

public
static
void
main (String[] args) 

{ 

Queue<Integer> list = 
new
LinkedList<Integer>(); 

list.add(
30
); 

list.add(
11
); 

list.add(
15
); 

list.add(
4
); 


//Sort Queue 

sortQueue(list); 


//print sorted Queue 

while
(list.isEmpty()== 
false
) 

{ 

System.out.print(list.peek() + 
"" ""
); 

list.poll(); 

} 

} 
} 

// This code is contributed by akash1295 ",CorCod,564,564,quadratic
"
// Java program to count number of times 
// S appears as a subsequence in T 
import
java.io.*; 

class
GFG { 

static
int
findSubsequenceCount(String S, String T) 

{ 

int
m = T.length(); 

int
n = S.length(); 


// T can't appear as a subsequence in S 

if
(m > n) 

return
0
; 


// mat[i][j] stores the count of 

// occurrences of T(1..i) in S(1..j). 

int
mat[][] = 
new
int
[m + 
1
][n + 
1
]; 


// Initializing first column with 

// all 0s. An emptystring can't have 

// another string as suhsequence 

for
(
int
i = 
1
; i <= m; i++) 

mat[i][
0
] = 
0
; 


// Initializing first row with all 1s. 

// An empty string is subsequence of all. 

for
(
int
j = 
0
; j <= n; j++) 

mat[
0
][j] = 
1
; 


// Fill mat[][] in bottom up manner 

for
(
int
i = 
1
; i <= m; i++) { 

for
(
int
j = 
1
; j <= n; j++) { 

// If last characters don't match, 

// then value is same as the value 

// without last character in S. 

if
(T.charAt(i - 
1
) != S.charAt(j - 
1
)) 

mat[i][j] = mat[i][j - 
1
]; 


// Else value is obtained considering two cases. 

// a) All substrings without last character in S 

// b) All substrings without last characters in 

// both. 

else

mat[i][j] = mat[i][j - 
1
] + mat[i - 
1
][j - 
1
]; 

} 

} 


/* uncomment this to print matrix mat 

for (int i = 1; i <= m; i++, cout << endl) 

for (int j = 1; j <= n; j++) 

System.out.println ( mat[i][j] +"" ""); */

return
mat[m][n]; 

} 


// Driver code to check above method 

public
static
void
main(String[] args) 

{ 

String T = 
""ge""
; 

String S = 
""geeksforgeeks""
; 

System.out.println(findSubsequenceCount(S, T)); 

} 
} 
// This code is contributed by vt_m ",CorCod,533,533,quadratic
"import java.util.Arrays;
import java.util.Scanner;


public class Solution {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		Solution ss = new Solution();
		ss.test(sc);
	}
	
	void test(Scanner sc){
		int LEN = sc.nextInt();
		int[] a = new int[LEN];
		int[] b = new int[LEN];
		for (int i = 0; i < b.length; i++) {
			a[i] = sc.nextInt();
		}
		for (int i = 0; i < b.length; i++) {
			b[i] = sc.nextInt();
		}
		Arrays.sort(a);
		Arrays.sort(b);
		
		int ia=0, ib=0;
		while(ia<LEN && a[ia]==0) ia++;
		while(ib<LEN && b[ib]==0) ib++;
		if(ib==LEN){
			System.out.println(""Yes"");
			return;
		}
		if(ia==LEN){
			System.out.println(""No"");
			return;
		}		
		boolean out = true;
		while(ia<LEN && ib<LEN){
			if(a[ia]==b[ib]){
				ia++;
				ib++;
			}else{
				if(a[ia]>b[ib]){
					while(ib<LEN && b[ib]!=a[ia]){
						ib++;
					}
					if(ib==LEN){
						out=false;
						break;
					}
				}
			}
		}
		
		if(out){
			System.out.println(""Yes"");
		}else{
			System.out.println(""No"");
		}
	}

}
",CorCod,427,427,quadratic
"
import java.io.*;
import java.util.*;
public class D999 {
    public static void main(String args[])throws IOException
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        int req=n/m;
        int arr[]=new int[n+1];
        int size[]=new int[m];
        List<Integer> list[]=new ArrayList[m];
        for(int i=0;i<m;i++)
        {
            list[i]=new ArrayList<>();
        }
        for(int i=1;i<=n;i++)
        {
            arr[i]=sc.nextInt();
            size[arr[i]%m]++;
            list[arr[i]%m].add(i);
        }
        long tot=0;int x=0,y=0;
        List<Integer> idx=new ArrayList<>();
        for(int i=0;i < 2*m;i++)
        {
            //System.out.println(i+"" ""+size[i%m]);
            if(size[i%m]>req)
            {
                for(int j=0;j<size[i%m]-req;j++)
                {
                    idx.add(list[i%m].get(j));
                    y++;
                    
                }
                size[i%m]=req;
                //System.out.println(i+"" ""+x+"" ""+y);
            }
            else if(size[i%m]<req)
            {
                //System.out.println(idx+"" ""+i);
                while(x!=y && size[i%m]<req)
                {
                    int num=arr[idx.get(x)];
                    int gg=i-num%m;
                    tot+=gg;
                    arr[idx.get(x)]+=gg;
                    x++;
                    size[i%m]++;
                }
            }
        }
        System.out.println(tot);
        for(int i=1;i<=n;i++)
        {
            System.out.print(arr[i]+"" "");
        }
    }
}",CorCod,166,166,linear
"
// Java program to construct a tree using inorder 
// and postorder traversals 

/* A binary tree node has data, pointer to left 

child and a pointer to right child */
class
Node { 

int
data; 

Node left, right; 


public
Node(
int
data) 

{ 

this
.data = data; 

left = right = 
null
; 

} 
} 

// Class Index created to implement pass by reference of Index 
class
Index { 

int
index; 
} 

class
BinaryTree { 

/* Recursive function to construct binary of size n 

from Inorder traversal in[] and Postrder traversal 

post[]. Initial values of inStrt and inEnd should 

be 0 and n -1. The function doesn't do any error 

checking for cases where inorder and postorder 

do not form a tree */

Node buildUtil(
int
in[], 
int
post[], 
int
inStrt, 

int
inEnd, Index pIndex) 

{ 

// Base case 

if
(inStrt > inEnd) 

return
null
; 


/* Pick current node from Postrder traversal using 

postIndex and decrement postIndex */

Node node = 
new
Node(post[pIndex.index]); 

(pIndex.index)--; 


/* If this node has no children then return */

if
(inStrt == inEnd) 

return
node; 


/* Else find the index of this node in Inorder 

traversal */

int
iIndex = search(in, inStrt, inEnd, node.data); 


/* Using index in Inorder traversal, construct left and 

right subtress */

node.right = buildUtil(in, post, iIndex + 
1
, inEnd, pIndex); 

node.left = buildUtil(in, post, inStrt, iIndex - 
1
, pIndex); 


return
node; 

} 


// This function mainly initializes index of root 

// and calls buildUtil() 

Node buildTree(
int
in[], 
int
post[], 
int
n) 

{ 

Index pIndex = 
new
Index(); 

pIndex.index = n - 
1
; 

return
buildUtil(in, post, 
0
, n - 
1
, pIndex); 

} 


/* Function to find index of value in arr[start...end] 

The function assumes that value is postsent in in[] */

int
search(
int
arr[], 
int
strt, 
int
end, 
int
value) 

{ 

int
i; 

for
(i = strt; i <= end; i++) { 

if
(arr[i] == value) 

break
; 

} 

return
i; 

} 


/* This funtcion is here just to test */

void
preOrder(Node node) 

{ 

if
(node == 
null
) 

return
; 

System.out.print(node.data + 
"" ""
); 

preOrder(node.left); 

preOrder(node.right); 

} 


public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

int
in[] = 
new
int
[] { 
4
, 
8
, 
2
, 
5
, 
1
, 
6
, 
3
, 
7
}; 

int
post[] = 
new
int
[] { 
8
, 
4
, 
5
, 
2
, 
6
, 
7
, 
3
, 
1
}; 

int
n = in.length; 

Node root = tree.buildTree(in, post, n); 

System.out.println(
""Preorder of the constructed tree : ""
); 

tree.preOrder(root); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,412,412,quadratic
"
// Recursive Java Program to reverse an array 
import
java.io.*; 

class
ReverseArray { 


/* Function to reverse arr[] from start to end*/

static
void
rvereseArray(
int
arr[], 
int
start, 
int
end) 

{ 

int
temp; 

if
(start >= end) 

return
; 

temp = arr[start]; 

arr[start] = arr[end]; 

arr[end] = temp; 

rvereseArray(arr, start+
1
, end-
1
); 

} 


/* Utility that prints out an array on a line */

static
void
printArray(
int
arr[], 
int
size) 

{ 

for
(
int
i=
0
; i < size; i++) 

System.out.print(arr[i] + 
"" ""
); 

System.out.println(
""""
); 

} 


/*Driver function to check for above functions*/

public
static
void
main (String[] args) { 

int
arr[] = {
1
, 
2
, 
3
, 
4
, 
5
, 
6
}; 

printArray(arr, 
6
); 

rvereseArray(arr, 
0
, 
5
); 

System.out.println(
""Reversed array is ""
); 

printArray(arr, 
6
); 

} 
} 
/*This article is contributed by Devesh Agrawal*/",CorCod,192,192,linear
"
// Java implementation to check if the given array 
// can represent Level Order Traversal of Binary 
// Search Tree 
import
java.util.*; 

class
Solution 
{ 

// to store details of a node like 
// node's data, 'min' and 'max' to obtain the 
// range of values where node's left and 
// right child's should lie 
static
class
NodeDetails 
{ 

int
data; 

int
min, max; 
}; 

// function to check if the given array 
// can represent Level Order Traversal 
// of Binary Search Tree 
static
boolean
levelOrderIsOfBST(
int
arr[], 
int
n) 
{ 

// if tree is empty 

if
(n == 
0
) 

return
true
; 


// queue to store NodeDetails 

Queue<NodeDetails> q = 
new
LinkedList<NodeDetails>(); 


// index variable to access array elements 

int
i = 
0
; 


// node details for the 

// root of the BST 

NodeDetails newNode=
new
NodeDetails(); 

newNode.data = arr[i++]; 

newNode.min = Integer.MIN_VALUE; 

newNode.max = Integer.MAX_VALUE; 

q.add(newNode); 


// until there are no more elements 

// in arr[] or queue is not empty 

while
(i != n && q.size() > 
0
) 

{ 

// extracting NodeDetails of a 

// node from the queue 

NodeDetails temp = q.peek(); 

q.remove(); 

newNode = 
new
NodeDetails(); 


// check whether there are more elements 

// in the arr[] and arr[i] can be left child 

// of 'temp.data' or not 

if
(i < n && (arr[i] < (
int
)temp.data && 

arr[i] > (
int
)temp.min)) 

{ 

// Create NodeDetails for newNode 

/// and add it to the queue 

newNode.data = arr[i++]; 

newNode.min = temp.min; 

newNode.max = temp.data; 

q.add(newNode); 

} 


newNode=
new
NodeDetails(); 


// check whether there are more elements 

// in the arr[] and arr[i] can be right child 

// of 'temp.data' or not 

if
(i < n && (arr[i] > (
int
)temp.data && 

arr[i] < (
int
)temp.max)) 

{ 

// Create NodeDetails for newNode 

/// and add it to the queue 

newNode.data = arr[i++]; 

newNode.min = temp.data; 

newNode.max = temp.max; 

q.add(newNode); 

} 

} 


// given array represents level 

// order traversal of BST 

if
(i == n) 

return
true
; 


// given array do not represent 

// level order traversal of BST 

return
false
; 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

int
arr[] = {
7
, 
4
, 
12
, 
3
, 
6
, 
8
, 
1
, 
5
, 
10
}; 

int
n = arr.length; 

if
(levelOrderIsOfBST(arr, n)) 

System.out.print( 
""Yes""
); 

else

System.out.print( 
""No""
); 

} 
} 

// This code is contributed by Arnab Kundu ",CorCod,12,12,linear
"import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {

        new Main().go();
    }

    PrintWriter out;
    Reader in;
    BufferedReader br;

    Main() throws IOException {

        try {

            //br = new BufferedReader( new FileReader(""input.txt"") );
            //in = new Reader(""input.txt"");
            in = new Reader(""input.txt"");
            out = new PrintWriter( new BufferedWriter(new FileWriter(""output.txt"")) );
        }
        catch (Exception e) {

            //br = new BufferedReader( new InputStreamReader( System.in ) );
            in = new Reader();
            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );
        }
    }

    void go() throws Exception {

        //int t = in.nextInt();
        int t = 1;
        while (t > 0) {
            solve();
            t--;
        }

        out.flush();
        out.close();
    }


    int inf = 2000000000;
    int mod = 1000000007;
    double eps = 0.000000001;

    int n;
    int m;

    ArrayList<Pair>[] g;
    String s;
    int[][] a;
    void solve() throws IOException {
        int n = in.nextInt();
        int m = in.nextInt();
        a = new int[n][m];
        for (int i = 0; i < n; i++) {
            String s = in.nextLine();
            for (int j = 0; j < m; j++) {
                a[i][j] = s.charAt(j);
            }
        }

        int[][] f = new int[n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                f[i][j] = inf;

        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 0; j < m; j++) {
                if (a[i][j] == '*') {
                    f[i][j] = Math.min(f[i][j], cnt);
                    cnt++;
                } else {
                    cnt = 0;
                }
            }
        }

        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = m - 1; j >= 0; j--) {
                if (a[i][j] == '*') {
                    f[i][j] = Math.min(f[i][j], cnt);
                    cnt++;
                } else {
                    cnt = 0;
                }
            }
        }

        for (int j = 0; j < m; j++) {
            int cnt = 0;
            for (int i = 0; i < n; i++) {
                if (a[i][j] == '*') {
                    f[i][j] = Math.min(f[i][j], cnt);
                    cnt++;
                } else {
                    cnt = 0;
                }
            }
        }

        for (int j = 0; j < m; j++) {
            int cnt = 0;
            for (int i = n - 1; i >= 0; i--) {
                if (a[i][j] == '*') {
                    f[i][j] = Math.min(f[i][j], cnt);
                    cnt++;
                } else {
                    cnt = 0;
                }
            }
        }

        ArrayList<Item> ans = new ArrayList<>();
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++) {
                if (a[i][j] == '*' && f[i][j] > 0)
                    ans.add(new Item(i + 1, j + 1, f[i][j]));
            }
        boolean[][] used = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 0; j < m; j++) {
                if (a[i][j] == '*' && f[i][j] > 0) {
                    cnt = Math.max(cnt, f[i][j] + 1);
                }
                if (cnt > 0) used[i][j] = true;
                cnt--;
            }
            cnt = 0;
            for (int j = m - 1; j >= 0; j--) {
                if (a[i][j] == '*' && f[i][j] > 0) {
                    cnt = Math.max(cnt, f[i][j] + 1);
                }
                if (cnt > 0) used[i][j] = true;
                cnt--;
            }
        }

        for (int j = 0; j < m; j++) {
            int cnt = 0;
            for (int i = 0; i < n; i++) {
                if (a[i][j] == '*' && f[i][j] > 0) {
                    cnt = Math.max(cnt, f[i][j] + 1);
                }
                if (cnt > 0) used[i][j] = true;
                cnt--;
            }
            cnt = 0;
            for (int i = n - 1; i >= 0; i--) {
                if (a[i][j] == '*' && f[i][j] > 0) {
                    cnt = Math.max(cnt, f[i][j] + 1);
                }
                if (cnt > 0) used[i][j] = true;
                cnt--;
            }
        }

        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (a[i][j] == '*' && !used[i][j]) {
                    out.println(-1);
                    return;
                }

        out.println(ans.size());
        for (Item i : ans)
            out.println(i.a + "" "" + i.b + "" "" + i.c);
    }


    class Pair implements Comparable<Pair>{

        int a;
        int b;

        Pair(int a, int b) {

            this.a = a;
            this.b = b;
        }

        public int compareTo(Pair p) {
            if (a != p.a)
                return Integer.compare(a, p.a);
            else
                return Integer.compare(b, p.b);
        }
    }

    class Item {

        int a;
        int b;
        int c;

        Item(int a, int b, int c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }

    }


    class Reader {

        BufferedReader  br;
        StringTokenizer tok;

        Reader(String file) throws IOException {
            br = new BufferedReader( new FileReader(file) );
        }

        Reader() throws IOException {
            br = new BufferedReader( new InputStreamReader(System.in) );
        }

        String next() throws IOException {

            while (tok == null || !tok.hasMoreElements())
                tok = new StringTokenizer(br.readLine());
            return tok.nextToken();
        }

        int nextInt() throws NumberFormatException, IOException {
            return Integer.valueOf(next());
        }

        long nextLong() throws NumberFormatException, IOException {
            return Long.valueOf(next());
        }

        double nextDouble() throws NumberFormatException, IOException {
            return Double.valueOf(next());
        }


        String nextLine() throws IOException {
            return br.readLine();
        }

    }

    static class InputReader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public InputReader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public InputReader(String file_name) throws IOException
        {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public String readLine() throws IOException
        {
            byte[] buf = new byte[64]; // line length
            int cnt = 0, c;
            while ((c = read()) != -1)
            {
                if (c == '\n')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
            if (neg)
                return -ret;
            return ret;
        }

        public double nextDouble() throws IOException
        {
            double ret = 0, div = 1;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();

            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');

            if (c == '.')
            {
                while ((c = read()) >= '0' && c <= '9')
                {
                    ret += (c - '0') / (div *= 10);
                }
            }

            if (neg)
                return -ret;
            return ret;
        }

        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
    }

}",CorCod,419,419,quadratic
"
// Java program to calculate the 
// product of max element of first 
// array and min element of second array 
import
java.util.*; 
import
java.lang.*; 

class
GfG 
{ 


// Function to calculate the product 

public
static
int
minMaxProduct(
int
arr1[], 

int
arr2[], 

int
n1, 

int
n2) 

{ 


// Initialize max of 

// first array 

int
max = arr1[
0
]; 


// initialize min of 

// second array 

int
min = arr2[
0
]; 


int
i; 

for
(i = 
1
; i < n1 && i < n2; ++i) 

{ 


// To find the maximum 

// element in first array 

if
(arr1[i] > max) 

max = arr1[i]; 


// To find the minimum element 

// in second array 

if
(arr2[i] < min) 

min = arr2[i]; 

} 


// Process remaining elements 

while
(i < n1) 

{ 

if
(arr1[i] > max) 

max = arr1[i]; 

i++; 

} 

while
(i < n2) 

{ 

if
(arr2[i] < min) 

min = arr2[i]; 

i++; 

} 


return
max * min; 

} 


// Driver Code 

public
static
void
main(String argc[]) 

{ 

int
[] arr1= 
new
int
[]{ 
10
, 
2
, 
3
, 

6
, 
4
, 
1
}; 

int
[] arr2 = 
new
int
[]{ 
5
, 
1
, 
4
, 

2
, 
6
, 
9
}; 

int
n1 = 
6
; 

int
n2 = 
6
; 

System.out.println(minMaxProduct(arr1, arr2, 

n1, n2)); 

} 
} 

// This code is contributed by Sagar Shukla ",CorCod,281,281,linear
"
// A Simple Java program to find longest common 
// subarray of two binary arrays with same sum 

class
Test 
{ 

static
int
arr1[] = 
new
int
[]{
0
, 
1
, 
0
, 
1
, 
1
, 
1
, 
1
}; 

static
int
arr2[] = 
new
int
[]{
1
, 
1
, 
1
, 
1
, 
1
, 
0
, 
1
}; 


// Returns length of the longest common sum in arr1[] 

// and arr2[]. Both are of same size n. 

static
int
longestCommonSum(
int
n) 

{ 

// Initialize result 

int
maxLen = 
0
; 


// One by one pick all possible starting points 

// of subarrays 

for
(
int
i=
0
; i<n; i++) 

{ 

// Initialize sums of current subarrays 

int
sum1 = 
0
, sum2 = 
0
; 


// Conider all points for starting with arr[i] 

for
(
int
j=i; j<n; j++) 

{ 

// Update sums 

sum1 += arr1[j]; 

sum2 += arr2[j]; 


// If sums are same and current length is 

// more than maxLen, update maxLen 

if
(sum1 == sum2) 

{ 

int
len = j-i+
1
; 

if
(len > maxLen) 

maxLen = len; 

} 

} 

} 

return
maxLen; 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

System.out.print(
""Length of the longest common span with same sum is ""
); 

System.out.println(longestCommonSum(arr1.length)); 

} 
} ",CorCod,518,518,quadratic
"import java.util.*;
import java.io.*;
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] arr = new int[n];
        HashMap<Integer, Integer> map = new HashMap<>();
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            int x = Integer.parseInt(st.nextToken());
            arr[i] = x;
            if (!map.containsKey(x)) {
                map.put(x, 1);
            } else {
                map.replace(x, map.get(x) + 1);
            }
        }
        int[] power = new int[31];
        for (int i = 0; i < 31; i++) {
            power[i] = 1 << i; // 0 100=4 1000=8 10000=16
        }
        int c = 0;
        for (int i = 0; i < n; i++) {
        boolean f = false;
        for (int j = 0; j <= 30; j++) {
        int check = power[j] - arr[i];
                if ((map.containsKey(check) && check != arr[i])) {
                f = true; break;}
                if((map.containsKey(check) && check == arr[i] && map.get(check) >=2)) {
                    f = true; break;
                }
            }
            if (!f) {
                c++;
            }
        }
        System.out.println(c);
    }
}",CorCod,704,704,nlogn
"package com.interview.algorithms.array;

/**
 * Given a sorted array and a value x, the ceiling of x is the smallest element
 * in array greater than or equal to x, and the floor is the greatest element
 * smaller than or equal to x. Assume than the array is sorted in non-decreasing
 * order. Write efficient functions to find floor and ceiling of x.
 * 
 * For example, let the input array be {1, 2, 8, 10, 10, 12, 19}
 *  For x = 0:floor doesn't exist in array, ceil = 1
 *  For x = 1: floor = 1, ceil = 1 
 *  For x = 5: floor = 2, ceil = 8
 *   For x = 20: floor= 19, ceil doesn't exist in array
 *
 *
 * @author ajitkoti
 */
public class FloorAndCeilingInASortedArray {

	/**
	 * Instead of using linear search, binary search is used here to find out
	 * the index. Binary search reduces time complexity to O(Logn).
	 * 
	 * @param arr
	 * @param low
	 * @param high
	 * @param x
	 * @return
	 */
	private static int ceilSearch(int arr[], int low, int high, int x) {
		int mid;

		/*
		 * If x is smaller than or equal to the first element, then return the
		 * first element
		 */
		if (x <= arr[low])
			return low;

		/* If x is greater than the last element, then return -1 */
		if (x > arr[high])
			return -1;

		/* get the index of middle element of arr[low..high] */
		mid = (low + high) / 2; /* low + (high - low)/2 */

		/* If x is same as middle element, then return mid */
		if (arr[mid] == x)
			return mid;

		/*
		 * If x is greater than arr[mid], then either arr[mid + 1] is ceiling of
		 * x or ceiling lies in arr[mid+1...high]
		 */
		else if (x > arr[mid]) {
			if (mid + 1 <= high && x <= arr[mid + 1])
				return mid + 1;
			else
				return ceilSearch(arr, mid + 1, high, x);
		}

		/*
		 * If x is smaller than arr[mid], then either arr[mid] is ceiling of x
		 * or ceiling lies in arr[mid-1...high]
		 */
		else {
			if (mid - 1 >= low && x > arr[mid - 1])
				return mid;
			else
				return ceilSearch(arr, low, mid - 1, x);
		}
	}

	/* Driver program to check above functions */
	public static void main(String[] args) {
		int arr[] = { 1, 2, 8, 10, 10, 12, 19 };
		int n = arr.length;
		int x = 11;
		int index = ceilSearch(arr, 0, n - 1, x);
		if (index == -1)
			System.out.println(""Ceiling of doesn't exist in array "" + x);
		else
			System.out.println(""ceiling of"" + x + "" is "" + arr[index]);

	}

}",CorCod,887,887,logn
"
// A Naive Java program to find 
// maximum sum rotation 
import
java.util.*; 
import
java.io.*; 

class
GFG { 

// Returns maximum value of i*arr[i] 
static
int
maxSum(
int
arr[], 
int
n) 
{ 
// Initialize result 
int
res = Integer.MIN_VALUE; 

// Consider rotation beginning with i 
// for all possible values of i. 
for
(
int
i = 
0
; i < n; i++) 
{ 


// Initialize sum of current rotation 

int
curr_sum = 
0
; 


// Compute sum of all values. We don't 

// actually rotation the array, but compute 

// sum by finding ndexes when arr[i] is 

// first element 

for
(
int
j = 
0
; j < n; j++) 

{ 

int
index = (i + j) % n; 

curr_sum += j * arr[index]; 

} 


// Update result if required 

res = Math.max(res, curr_sum); 
} 

return
res; 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

int
arr[] = {
8
, 
3
, 
1
, 
2
}; 

int
n = arr.length; 

System.out.println(maxSum(arr, n)); 
} 


} 

// This code is contributed by Sahil_Bansall ",CorCod,555,555,quadratic
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class AAA {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());	
		int n=Integer.parseInt(st.nextToken());
		int m=Integer.parseInt(st.nextToken());
		String a="""";
		String b="""";
		for(int i=0;i<1129;i++) {
			a+=""1"";
			b+=""8"";
		}
		a+=""9"";
		b+=""1"";
		
		System.out.println(a);
		System.out.println(b);
	}
		
}
",CorCod,865,865,constant
"import java.util.*;
import java.io.*;
public class A
{
      public static void main(String ar[]) throws Exception
      {
            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
            String s1[]=br.readLine().split("" "");
            String s2[]=br.readLine().split("" "");
            int n=Integer.parseInt(s1[0]);
            int m=Integer.parseInt(s1[1]);
            int a[]=new int[n];
            int b[]=new int[n];
            int c[]=new int[n];
            int d[]=new int[n];
            HashSet<Integer> hs=new HashSet<Integer>();
            hs.add(0);
            hs.add(m);
            int max=0;
            for(int i=0;i<n;i++)
            {
                  a[i]=Integer.parseInt(s2[i]);
                  if(i%2==0)
                   b[i]=1;
                  hs.add(a[i]);
            }
            
            c[0]=a[0];
            for(int i=1;i<n;i++)
            {
                  if(b[i]==0)
                   c[i]=c[i-1];
                  else
                   c[i]=c[i-1]+a[i]-a[i-1];
            }
            
            if(b[n-1]==0)
             d[n-1]=m-a[n-1];
            for(int i=n-2;i>=0;i--)
            {
                  if(b[i]==1)
                   d[i]=d[i+1];
                  else
                   d[i]=d[i+1]+a[i+1]-a[i];
            }
            
            max=c[n-1];
            if(b[n-1]==0)
             max+=m-a[n-1];
            //System.out.println(max);
            for(int i=n-1;i>=0;i--)
            {
                  int u=a[i]-1;
                  int v=a[i]+1;
                  if(!hs.contains(u))
                  {
                        if(b[i]==0)
                        {
                             int r=1+m-a[i]-d[i]+c[i-1];
                             max=Math.max(max,r);
                        }
                        else
                        {
                              int l=0;
                              if(i>0)
                               l=a[i-1];
                              int r=c[i]-1+m-a[i]-d[i];
                              max=Math.max(max,r);
                        }
                  }
                  
                  if(!hs.contains(v))
                  {
                        if(b[i]==0)
                        {
                           if(i==n-1)
                           {
                              int r=c[i]+1;
                              max=Math.max(max,r);
                           }
                           else
                           {
                               int r=c[i]+1+m-a[i+1]-d[i+1];
                               max=Math.max(max,r);
                           }
                        }
                        else
                        {
                                if(i==n-1)
                                {
                                   int r=c[i]+m-a[i]-1;
                                   max=Math.max(max,r);
                                }
                                else
                                {
                                    int r=c[i]+m-a[i+1]-d[i+1]+a[i+1]-1-a[i];  
                                    max=Math.max(max,r);
                                }
                        }
                  }
            }
            
            System.out.println(max);
      }
}",CorCod,301,301,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Solve4 {

    public static void main(String[] args) throws IOException {
      FastReader sc = new FastReader();
      int x= sc.nextInt();
      int y= sc.nextInt();
      int z= sc.nextInt();
      int t1= sc.nextInt();
      int t2= sc.nextInt();
      int t3= sc.nextInt();
      if(Math.abs(x-y)*t1 < (Math.abs(x-z)+Math.abs(x-y))*t2+3*t3 ) System.out.println(""NO"");
      else System.out.println(""YES"");
    }

    static class FastReader {

        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        public String next() throws IOException {
            if (st == null || !st.hasMoreTokens()) {
                st = new StringTokenizer(br.readLine());
            }
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            String s = """";
            try {
                s = br.readLine();
            } catch (IOException ex) {
            }
            return s;
        }
    }

}
",CorCod,757,757,constant
"import java.util.*;

import java.io.*;
public class Solution
{
    public static void main(String [] args) throws IOException
    {
        PrintWriter pw=new PrintWriter(System.out);//use pw.println() not pw.write();
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=new StringTokenizer(br.readLine());
        /*
        inputCopy
5 3
xyabd
outputCopy
29
inputCopy
7 4
problem
outputCopy
34
inputCopy
2 2
ab
outputCopy
-1
inputCopy
12 1
abaabbaaabbb
outputCopy
1
        */
        int n=Integer.parseInt(st.nextToken());
        int k=Integer.parseInt(st.nextToken());
        st=new StringTokenizer(br.readLine());
        String str=st.nextToken();
        char [] arr=str.toCharArray();
        Arrays.sort(arr);
        int weight=arr[0]-96;
        char a=arr[0];
        int included=1;
        for(int i=1;i<arr.length;++i)
        {
            if(included==k)
                break;
            char c=arr[i];
            if(c-a<2)
                continue;
           
            weight+=arr[i]-96;
            ++included;
            a=arr[i];
            
        }
        if(included==k)
            pw.println(weight);
        else
            pw.println(-1);
        pw.close();//Do not forget to write it after every program return statement !!
    }
}
/*
→Judgement Protocol
Test: #1, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
5 3
xyabd
Output
29
Answer
29
Checker Log
ok 1 number(s): ""29""
Test: #2, time: 78 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
7 4
problem
Output
34
Answer
34
Checker Log
ok 1 number(s): ""34""
Test: #3, time: 139 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
2 2
ab
Output
-1
Answer
-1
Checker Log
ok 1 number(s): ""-1""
Test: #4, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
12 1
abaabbaaabbb
Output
1
Answer
1
Checker Log
ok 1 number(s): ""1""
Test: #5, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
50 13
qwertyuiopasdfghjklzxcvbnmaaaaaaaaaaaaaaaaaaaaaaaa
Output
169
Answer
169
Checker Log
ok 1 number(s): ""169""
Test: #6, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
50 14
qwertyuiopasdfghjklzxcvbnmaaaaaaaaaaaaaaaaaaaaaaaa
Output
-1
Answer
-1
Checker Log
ok 1 number(s): ""-1""
Test: #7, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
1 1
a
Output
1
Answer
1
Checker Log
ok 1 number(s): ""1""
Test: #8, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
50 1
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Output
1
Answer
1
Checker Log
ok 1 number(s): ""1""
Test: #9, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
50 2
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Output
-1
Answer
-1
Checker Log
ok 1 number(s): ""-1""
Test: #10, time: 92 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
13 13
uwgmkyqeiaocs
Output
169
Answer
169
Checker Log
ok 1 number(s): ""169""
Test: #11, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
13 13
hzdxpbfvrltnj
Output
182
Answer
182
Checker Log
ok 1 number(s): ""182""
Test: #12, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
1 1
n
Output
14
Answer
14
Checker Log
ok 1 number(s): ""14""
Test: #13, time: 92 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
10 8
smzeblyjqw
Output
113
Answer
113
Checker Log
ok 1 number(s): ""113""
Test: #14, time: 78 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
20 20
tzmvhskkyugkuuxpvtbh
Output
-1
Answer
-1
Checker Log
ok 1 number(s): ""-1""
Test: #15, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
30 15
wjzolzzkfulwgioksfxmcxmnnjtoav
Output
-1
Answer
-1
Checker Log
ok 1 number(s): ""-1""
Test: #16, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
40 30
xumfrflllrrgswehqtsskefixhcxjrxbjmrpsshv
Output
-1
Answer
-1
Checker Log
ok 1 number(s): ""-1""
Test: #17, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
50 31
ahbyyoxltryqdmvenemaqnbakglgqolxnaifnqtoclnnqiabpz
Output
-1
Answer
-1
Checker Log
ok 1 number(s): ""-1""
Test: #18, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
10 7
iuiukrxcml
Output
99
Answer
99
Checker Log
ok 1 number(s): ""99""
Test: #19, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
38 2
vjzarfykmrsrvwbwfwldsulhxtykmjbnwmdufa
Output
5
Answer
5
Checker Log
ok 1 number(s): ""5""
Test: #20, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
12 6
fwseyrarkwcd
Output
61
Answer
61
Checker Log
ok 1 number(s): ""61""
Test: #21, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
2 2
ac
Output
4
Answer
4
Checker Log
ok 1 number(s): ""4""
Test: #22, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
1 1
c
Output
3
Answer
3
Checker Log
ok 1 number(s): ""3""
Test: #23, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK
Input
2 2
ad
Output
5
Answer
5
Checker Log
ok 1 number(s): ""5""
Test: #24, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER
Input
2 1
ac
Output
-1
Answer
1
Checker Log
wrong answer 1st number
*/",CorCod,176,176,linear
"import java.util.*;

public class helloWorld 
{
	public static void main(String[] args) 
	{		
		Scanner in = new Scanner(System.in);
		int a = in.nextInt();
		int b = in.nextInt();
		int c = in.nextInt();
		int n = in.nextInt();

		int ans = n - (a + b - c);
		if(ans < 1 || a >= n || b >= n || c > a || c > b)
			ans = -1;
		
		System.out.println(ans);
		
		in.close();
	}
}",CorCod,819,819,constant
"import java.io.*;
import java.util.*;

public class A_KingEscape {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader inp = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        Solver solver = new Solver();
        solver.solve(inp, out);
        out.close();
    }

    private static class Solver {
        private void solve(InputReader inp, PrintWriter out) {
            int n = inp.nextInt();
            int Qx = inp.nextInt(), Qy = inp.nextInt();
            int Kx = inp.nextInt(), Ky = inp.nextInt();
            int Tx = inp.nextInt(), Ty = inp.nextInt();
            if (((Kx < Qx && Tx < Qx) || (Kx > Qx && Tx > Qx)) && ((Ky < Qy && Ty < Qy) || (Ky > Qy && Ty > Qy))) out.println(""YES"");
            else out.println(""NO"");
        }
    }

    static class InputReader {
        BufferedReader reader;
        StringTokenizer tokenizer;

        InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }
    }
}",CorCod,789,789,constant
"
// Java program to construct a binary tree from preorder traversal 

// A Binary Tree node 
class
Node 
{ 

int
data; 

Node left, right; 


Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
Index 
{ 

int
index = 
0
; 
} 

class
BinaryTree 
{ 

Node root; 

Index myindex = 
new
Index(); 


/* A recursive function to create a Binary Tree from given pre[] 

preLN[] arrays. The function returns root of tree. index_ptr is used 

to update index values in recursive calls. index must be initially 

passed as 0 */

Node constructTreeUtil(
int
pre[], 
char
preLN[], Index index_ptr, 

int
n, Node temp) 

{ 

// store the current value of index in pre[] 

int
index = index_ptr.index; 


// Base Case: All nodes are constructed 

if
(index == n) 

return
null
; 


// Allocate memory for this node and increment index for 

// subsequent recursive calls 

temp = 
new
Node(pre[index]); 

(index_ptr.index)++; 


// If this is an internal node, construct left and right subtrees 

// and link the subtrees 

if
(preLN[index] == 
'N'
) 

{ 

temp.left = constructTreeUtil(pre, preLN, index_ptr, n, 

temp.left); 

temp.right = constructTreeUtil(pre, preLN, index_ptr, n, 

temp.right); 

} 


return
temp; 

} 


// A wrapper over constructTreeUtil() 

Node constructTree(
int
pre[], 
char
preLN[], 
int
n, Node node) 

{ 

// Initialize index as 0. Value of index is used in recursion to 

// maintain the current index in pre[] and preLN[] arrays. 

int
index = 
0
; 


return
constructTreeUtil(pre, preLN, myindex, n, node); 

} 


/* This function is used only for testing */

void
printInorder(Node node) 

{ 

if
(node == 
null
) 

return
; 


/* first recur on left child */

printInorder(node.left); 


/* then print the data of node */

System.out.print(node.data + 
"" ""
); 


/* now recur on right child */

printInorder(node.right); 

} 


// driver function to test the above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

int
pre[] = 
new
int
[]{
10
, 
30
, 
20
, 
5
, 
15
}; 

char
preLN[] = 
new
char
[]{
'N'
, 
'N'
, 
'L'
, 
'L'
, 
'L'
}; 

int
n = pre.length; 


// construct the above tree 

Node mynode = tree.constructTree(pre, preLN, n, tree.root); 


// Test the constructed tree 

System.out.println(
""Following is Inorder Traversal of the""

+ 
""Constructed Binary Tree: ""
); 

tree.printInorder(mynode); 

} 
} 

// This code has been contributed by Mayank Jaiswal 
",CorCod,383,383,linear
"
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class cf2 {
	static final double EPS = 1e-9;

  public static void main(String[] args) throws IOException {
	 Scanner sc = new Scanner(System.in);
	
	 //rec
	 int xr1=sc.nextInt(), yr1=sc.nextInt(), xr2=sc.nextInt(),yr2=sc.nextInt();
	 int xr3=sc.nextInt(), yr3=sc.nextInt(), xr4=sc.nextInt(),yr4=sc.nextInt();
	
	 Point pr1 = new Point(xr1, yr1);
	 Point pr2 = new Point(xr2, yr2);
	 Point pr3 = new Point(xr3, yr3);
	 Point pr4 = new Point(xr4, yr4);
	 
	 LineSegment lr1 = new LineSegment(pr1, pr2);
	 LineSegment lr2 = new LineSegment(pr2, pr3);
	 LineSegment lr3 = new LineSegment(pr3, pr4);
	 LineSegment lr4 = new LineSegment(pr4, pr1);
	 
	 //diamond
	 int xd1=sc.nextInt(), yd1=sc.nextInt(), xd2=sc.nextInt(),yd2=sc.nextInt();
	 int xd3=sc.nextInt(), yd3=sc.nextInt(), xd4=sc.nextInt(),yd4=sc.nextInt();
	 
	 Point p1 = new Point(xd1, yd1);
	 Point p2 = new Point(xd2, yd2);
	 Point p3 = new Point(xd3, yd3);
	 Point p4 = new Point(xd4, yd4);
	 
	 Point [] pt = new Point [5];
	 pt[0]=p1;  pt[1]=p2;  pt[2]=p3;  pt[3]=p4;  pt[4]=p1;
	 Polygon pg = new Polygon(pt);
	 
	 if(pg.inside(pr1)||pg.inside(pr2)||pg.inside(pr3)||pg.inside(pr4)) {
		 System.out.println(""YES"");
		 return;
	 }
	
	 
	 LineSegment ld1 = new LineSegment(p1, p2);
	 LineSegment ld2 = new LineSegment(p2, p3);
	 LineSegment ld3 = new LineSegment(p3, p4);
	 LineSegment ld4 = new LineSegment(p4, p1);
	 
	 Rectangle rec = new Rectangle(new Point(Math.min(Math.min(xr3,xr4),Math.min(xr1,xr2)), Math.min(Math.min(yr3,yr4),Math.min(yr1,yr2))), 
			 new Point(Math.max(Math.max(xr3,xr4),Math.max(xr1,xr2)), Math.max(Math.max(yr3,yr4),Math.max(yr1,yr2))) );
	 
	 if(rec.contains(p1)||rec.contains(p2)||rec.contains(p3)||rec.contains(p4)) {
		 System.out.println(""YES"");
	     return;
	 }
	 
	 if(ld1.intersect(lr1)||ld1.intersect(lr3)||ld1.intersect(lr3)||ld1.intersect(lr4)) {
		 System.out.println(""YES"");
	     return;
	 }
	 
	 if(ld2.intersect(lr1)||ld2.intersect(lr3)||ld2.intersect(lr3)||ld2.intersect(lr4)) {
		 System.out.println(""YES"");
	     return;
	 }
	 
	 if(ld3.intersect(lr1)||ld3.intersect(lr3)||ld3.intersect(lr3)||ld3.intersect(lr4)) {
		 System.out.println(""YES"");
	     return;
	 }
	 
	 if(ld4.intersect(lr1)||ld4.intersect(lr3)||ld4.intersect(lr3)||ld4.intersect(lr4)) {
		 System.out.println(""YES"");
	     return;
	 }
	 
	 System.out.println(""NO"");
	 
	 
	 
	 
}
  
  public static class Polygon { 
		// Cases to handle: collinear points, polygons with n < 3

		static final double EPS = 1e-9;
		
		Point[] g; 			//first point = last point, counter-clockwise representation
		
		Polygon(Point[] o) { g = o; }

		double perimeter()
		{
			double sum = 0.0;
			for(int i = 0; i < g.length - 1; ++i)
				sum += g[i].dist(g[i+1]);
			return sum;
		}
		
		double area() 		//clockwise/anti-clockwise check, for convex/concave polygons
		{
			double area = 0.0;
			for(int i = 0; i < g.length - 1; ++i)
				area += g[i].x * g[i+1].y - g[i].y * g[i+1].x;
			return Math.abs(area) / 2.0;			//negative value in case of clockwise
		}

	
		
		boolean inside(Point p)	//for convex/concave polygons - winding number algorithm 
		{
			double sum = 0.0;
			for(int i = 0; i < g.length - 1; ++i)
			{
				double angle = Point.angle(g[i], p, g[i+1]);
				if((Math.abs(angle) < EPS || Math.abs(angle - Math.PI) < EPS) && p.between(g[i], g[i+1]))
					return true;
				if(Point.ccw(p, g[i], g[i+1]))
					sum += angle;
				else
					sum -= angle;
			}

			return Math.abs(2 * Math.PI - Math.abs(sum)) < EPS;		//abs makes it work for clockwise
		}
		/*
		 * Another way if the polygon is convex
		 * 1. Triangulate the poylgon through p
		 * 2. Check if sum areas == poygon area
		 * 3. Handle empty polygon
		 */
		
		

	
		Point centroid()		//center of mass
		{
			double cx = 0.0, cy = 0.0;
			for(int i = 0; i < g.length - 1; i++)
			{
				double x1 = g[i].x, y1 = g[i].y;
				double x2 = g[i+1].x, y2 = g[i+1].y;

				double f = x1 * y2 - x2 * y1;
				cx += (x1 + x2) * f;
				cy += (y1 + y2) * f;
			}
			double area = area();		//remove abs
			cx /= 6.0 * area;
			cy /= 6.0 * area;
			return new Point(cx, cy);
		}
	}
  
   static class LineSegment {

		Point p, q;
		
		LineSegment(Point a, Point b) { p = a; q = b; }
		

		boolean intersect(LineSegment ls)
		{
			Line l1 = new Line(p, q), l2 = new Line(ls.p, ls.q);
			if(l1.parallel(l2))
			{
				if(l1.same(l2))
					return p.between(ls.p, ls.q) || q.between(ls.p, ls.q) || ls.p.between(p, q) || ls.q.between(p, q);
				return false;
			}
			Point c = l1.intersect(l2);
			return c.between(p, q) && c.between(ls.p, ls.q);
		}

	}
  
   static class Rectangle {

		static final double EPS = 1e-9;
		
		Point ll, ur;

		Rectangle(Point a, Point b) { ll = a; ur = b; }

		double area() { return (ur.x - ll.x) * (ur.y - ll.y); }

		boolean contains(Point p)
		{
			return p.x <= ur.x + EPS && p.x + EPS >= ll.x && p.y <= ur.y + EPS && p.y + EPS >= ll.y;
		}

		Rectangle intersect(Rectangle r)
		{
			Point ll = new Point(Math.max(this.ll.x, r.ll.x), Math.max(this.ll.y, r.ll.y));
			Point ur = new Point(Math.min(this.ur.x, r.ur.x), Math.min(this.ur.y, r.ur.y));
			if(Math.abs(ur.x - ll.x) > EPS && Math.abs(ur.y - ll.y) > EPS && this.contains(ll) && this.contains(ur) && r.contains(ll) && r.contains(ur))
				return new Rectangle(ll, ur);
			return null;
		}

	}
   static class Line {

		static final double INF = 1e9, EPS = 1e-9;
		
		double a, b, c;
		
		Line(Point p, Point q)
		{
			if(Math.abs(p.x - q.x) < EPS) {	a = 1; b = 0; c = -p.x;	}
			else
			{
				a = (p.y - q.y) / (q.x - p.x);
				b = 1.0;
				c = -(a * p.x + p.y);
			}
						
		}
		
		Line(Point p, double m) { a = -m; b = 1; c =  -(a * p.x + p.y); } 
		
		boolean parallel(Line l) { return Math.abs(a - l.a) < EPS && Math.abs(b - l.b) < EPS; }
		
		boolean same(Line l) { return parallel(l) && Math.abs(c - l.c) < EPS; }
		
		Point intersect(Line l)
		{
			if(parallel(l))
				return null;
			double x = (b * l.c - c * l.b) / (a * l.b - b * l.a);
			double y;
			if(Math.abs(b) < EPS)
				 y = -l.a * x - l.c;
			else
				y = -a * x - c;
			
			return new Point(x, y);
		}
		
		Point closestPoint(Point p)
		{
			if(Math.abs(b) < EPS) return new Point(-c, p.y);
			if(Math.abs(a) < EPS) return new Point(p.x, -c);
			return intersect(new Line(p, 1 / a));
		}
				
	}

   public static class Vector {

		double x, y; 

		Vector(double a, double b) { x = a; y = b; }

		Vector(Point a, Point b) { this(b.x - a.x, b.y - a.y); }

		Vector scale(double s) { return new Vector(x * s, y * s); }              //s is a non-negative value

		double dot(Vector v) { return (x * v.x + y * v.y); }

		double cross(Vector v) { return x * v.y - y * v.x; }

		double norm2() { return x * x + y * y; }

		Vector reverse() { return new Vector(-x, -y); }

		Vector normalize() 
		{ 
			double d = Math.sqrt(norm2());
			return scale(1 / d);
		}		
	}
   
   static class Point implements Comparable<Point>{

		static final double EPS = 1e-9;

		double x, y;                  

		Point(double a, double b) { x = a; y = b; }  
		
		public int compareTo(Point p)
		{
			if(Math.abs(x - p.x) > EPS) return x > p.x ? 1 : -1;
			if(Math.abs(y - p.y) > EPS) return y > p.y ? 1 : -1;
			return 0;
		}
		static double angle(Point a, Point o, Point b)  // angle AOB
		{
			Vector oa = new Vector(o, a), ob = new Vector(o, b);
			return Math.acos(oa.dot(ob) / Math.sqrt(oa.norm2() * ob.norm2()));
		}
		static boolean ccw(Point p, Point q, Point r)
		{
			return new Vector(p, q).cross(new Vector(p, r)) > 0;
		}
		
		public double dist(Point p) { return Math.sqrt(sq(x - p.x) + sq(y - p.y)); }
		
		static double sq(double x) { return x * x; }
		
		Point rotate(double angle)
		{
			double c = Math.cos(angle), s = Math.sin(angle);
			return new Point(x * c - y * s, x * s + y * c);
		}
		// for integer points and rotation by 90 (counterclockwise) : swap x and y, negate x
		
	
		
		boolean between(Point p, Point q)
		{
			return x < Math.max(p.x, q.x) + EPS && x + EPS > Math.min(p.x, q.x)
					&& y < Math.max(p.y, q.y) + EPS && y + EPS > Math.min(p.y, q.y);
		}
		
		//returns true if it is on the line defined by a and b
	
		//returns true if it is on the ray whose start point is a and passes through b
		// Another way: find closest point and calculate the distance between it and p
	}
  
	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public Scanner(String file) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(file));
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public long nextlong() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder(""0"");
			long res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder(""0"");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

	}
}
",CorCod,813,813,constant
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class AlexAndARhombus {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		int n = nextInt();
		System.out.println(n*n+(n-1)*(n-1));
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",CorCod,785,785,constant
"
// Java program to CountKSubStr number of substrings 
// with exactly distinct characters in a given string 
import
java.util.Arrays; 

public
class
CountKSubStr 
{ 

// Function to count number of substrings 

// with exactly k unique characters 

int
countkDist(String str, 
int
k) 

{ 

// Initialize result 

int
res = 
0
; 


int
n = str.length(); 


// To store count of characters from 'a' to 'z' 

int
cnt[] = 
new
int
[
26
]; 


// Consider all substrings beginning with 

// str[i] 

for
(
int
i = 
0
; i < n; i++) 

{ 

int
dist_count = 
0
; 


// Initializing count array with 0 

Arrays.fill(cnt, 
0
); 


// Consider all substrings between str[i..j] 

for
(
int
j=i; j<n; j++) 

{ 

// If this is a new character for this 

// substring, increment dist_count. 

if
(cnt[str.charAt(j) - 
'a'
] == 
0
) 

dist_count++; 


// Increment count of current character 

cnt[str.charAt(j) - 
'a'
]++; 


// If distinct character count becomes k, 

// then increment result. 

if
(dist_count == k) 

res++; 

} 

} 


return
res; 

} 


// Driver Program 

public
static
void
main(String[] args) 

{ 

CountKSubStr ob = 
new
CountKSubStr(); 

String ch = 
""abcbaa""
; 

int
k = 
3
; 

System.out.println(
""Total substrings with exactly ""
+ 

k + 
"" distinct characters : ""

+ ob.countkDist(ch, k)); 

} 
} ",CorCod,579,579,quadratic
"import java.util.*;import java.lang.*;import java.io.*;
public class Codechef
{   static PrintWriter out=new PrintWriter(System.out);
	static FastScanner in = new FastScanner(System.in);
     static class FastScanner {BufferedReader br;StringTokenizer stok;FastScanner(InputStream is) {br = new BufferedReader(new InputStreamReader(is));}
        String next() throws IOException {while (stok == null || !stok.hasMoreTokens()) {String s = br.readLine();if (s == null) {return null;}
                stok = new StringTokenizer(s);}return stok.nextToken();}
        int ni() throws IOException {    return Integer.parseInt(next());}
        long nl() throws IOException {return Long.parseLong(next());}
        double nd() throws IOException {return Double.parseDouble(next());}
        char nc() throws IOException {return (char) (br.read());}
        String ns() throws IOException {return br.readLine();}
        int[] nia(int n) throws IOException{int a[] = new int[n];for (int i = 0; i < n; i++)a[i] = ni();return a;}
        long[] nla(int n) throws IOException {
            long a[] = new long[n];for (int i = 0; i < n; i++)a[i] = nl();return a;}
        double[] nda(int n)throws IOException {double a[] = new double[n];for (int i = 0; i < n; i++)        a[i] = nd();    return a;}
        int [][] imat(int n,int m) throws IOException
        {   int mat[][]=new int[n][m];for(int i=0;i<n;i++){   for(int j=0;j<m;j++)mat[i][j]=ni();}return mat;}
    }
        
    ///MAIN METHOD
    
    
    
    
	static long mod=Long.MAX_VALUE;
	public static void main (String[] args) throws java.lang.Exception
	{   int i,j;
	    HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();
		/*  if(hm.containsKey(z))
		        hm.put(z,hm.get(z)+1);
		    else
		        hm.put(z,1);
		 */       
        ArrayList<Integer> arr=new ArrayList<Integer>();
        HashSet<Integer> set=new HashSet<Integer>();
        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();
        /*  int n = in.ni();
            int m = in.ni();
            String s=in.ns();
            int a[]=in.nia(n);
            int b[][]=in.im(n,m);
            pia(a);
		    pimat(b);
            sort(a,0,a.length-1);
        */
        long n=in.nl();
        long v=in.nl();
        long temp=n-1;
        long ans=0;
          
        ans+=Math.min(v,temp);
        temp-=v;
	    
	    if(temp>0)
            ans+=((temp+1)*(temp+2))/(long)2-1;
        
        
        out.println(ans);
        out.close();
	}
	
	
	
	
	
	static long gcd(long a,long b)
	{   if(b==0)
	        return a;
	    return gcd(b,a%b);    
	}
	static long exponent(long a,long n)
	{   long ans=1;
	    while(n!=0)
	    {   if(n%2==1)
	            ans=(ans*a)%mod;
	       a=(a*a)%mod;
	       n=n>>1;
	    }
	    return ans;
	}
	static int binarySearch(int a[], int item, int low, int high) 
    {   if (high <= low) 
            return (item > a[low])?  (low + 1): low; 
        int mid = (low + high)/2; 
        if(item == a[mid]) 
            return mid+1; 
        if(item > a[mid]) 
            return binarySearch(a, item, mid+1, high); 
        return binarySearch(a, item, low, mid-1); 
    } 
   static void merge(int arr[], int l, int m, int r) 
    {   int n1 = m - l + 1; int n2 = r - m; int L[] = new int [n1]; int R[] = new int [n2]; 
        
        for (int i=0; i<n1; ++i) L[i] = arr[l + i]; for (int j=0; j<n2; ++j) R[j] = arr[m + 1+ j]; int i = 0, j = 0; int k = l; 
        while (i < n1 && j < n2) {   if (L[i] <= R[j]) {   arr[k] = L[i]; i++; } else{   arr[k] = R[j]; j++; } k++; } while (i < n1){   arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j];   j++;     k++; } 
    } 
    static void Sort(int arr[], int l, int r) 
    {    if (l < r) {   int m = (l+r)/2; Sort(arr, l, m); Sort(arr , m+1, r); merge(arr, l, m, r); } } 
    
    static void sort(int a[])
    {Sort(a,0,a.length-1);}

}",CorCod,814,814,constant
"
// Java program to implement merge sort in singly linked list 

// Linked List Class 
class
LinkedList { 


static
Node head; 
// head of list 


/* Node Class */

static
class
Node { 


int
data; 

Node next, prev; 


// Constructor to create a new node 

Node(
int
d) { 

data = d; 

next = prev = 
null
; 

} 

} 


void
print(Node node) { 

Node temp = node; 

System.out.println(
""Forward Traversal using next pointer""
); 

while
(node != 
null
) { 

System.out.print(node.data + 
"" ""
); 

temp = node; 

node = node.next; 

} 

System.out.println(
""\nBackward Traversal using prev pointer""
); 

while
(temp != 
null
) { 

System.out.print(temp.data + 
"" ""
); 

temp = temp.prev; 

} 

} 


// Split a doubly linked list (DLL) into 2 DLLs of 

// half sizes 

Node split(Node head) { 

Node fast = head, slow = head; 

while
(fast.next != 
null
&& fast.next.next != 
null
) { 

fast = fast.next.next; 

slow = slow.next; 

} 

Node temp = slow.next; 

slow.next = 
null
; 

return
temp; 

} 


Node mergeSort(Node node) { 

if
(node == 
null
|| node.next == 
null
) { 

return
node; 

} 

Node second = split(node); 


// Recur for left and right halves 

node = mergeSort(node); 

second = mergeSort(second); 


// Merge the two sorted halves 

return
merge(node, second); 

} 


// Function to merge two linked lists 

Node merge(Node first, Node second) { 

// If first linked list is empty 

if
(first == 
null
) { 

return
second; 

} 


// If second linked list is empty 

if
(second == 
null
) { 

return
first; 

} 


// Pick the smaller value 

if
(first.data < second.data) { 

first.next = merge(first.next, second); 

first.next.prev = first; 

first.prev = 
null
; 

return
first; 

} 
else
{ 

second.next = merge(first, second.next); 

second.next.prev = second; 

second.prev = 
null
; 

return
second; 

} 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) { 


LinkedList list = 
new
LinkedList(); 

list.head = 
new
Node(
10
); 

list.head.next = 
new
Node(
30
); 

list.head.next.next = 
new
Node(
3
); 

list.head.next.next.next = 
new
Node(
4
); 

list.head.next.next.next.next = 
new
Node(
20
); 

list.head.next.next.next.next.next = 
new
Node(
5
); 



Node node = 
null
; 

node = list.mergeSort(head); 

System.out.println(
""Linked list after sorting :""
); 

list.print(node); 


} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,720,720,nlogn
"
// Java program to find maximum height pyramid 
// from the given object width. 
import
java.io.*; 
import
java.util.Arrays; 

class
GFG { 


// Returns maximum number of pyramidcal 

// levels n boxes of given widths. 

static
int
maxLevel(
int
[]boxes, 
int
n) 

{ 


// Sort objects in increasing order 

// of widths 

Arrays.sort(boxes); 


int
ans = 
1
; 
// Initialize result 


// Total width of previous level 

// and total number of objects in 

// previous level 

int
prev_width = boxes[
0
]; 

int
prev_count = 
1
; 


// Number of object in current 

// level. 

int
curr_count = 
0
; 


// Width of current level. 

int
curr_width = 
0
; 

for
(
int
i = 
1
; i < n; i++) 

{ 

// Picking the object. So 

// increase current width 

// and number of object. 

curr_width += boxes[i]; 

curr_count += 
1
; 


// If current width and 

// number of object 

// are greater than previous. 

if
(curr_width > prev_width && 

curr_count > prev_count) 

{ 


// Update previous width, 

// number of object on 

// previous level. 

prev_width = curr_width; 

prev_count = curr_count; 


// Reset width of current 

// level, number of object 

// on current level. 

curr_count = 
0
; 

curr_width = 
0
; 


// Increment number of 

// level. 

ans++; 

} 

} 


return
ans; 

} 


// Driver Program 

static
public
void
main (String[] args) 

{ 

int
[]boxes = {
10
, 
20
, 
30
, 
50
, 
60
, 
70
}; 

int
n = boxes.length; 

System.out.println(maxLevel(boxes, n)); 

} 
} 

// This code is contributed by anuj_67. ",CorCod,715,715,nlogn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Pradyumn
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        FastReader in;
        PrintWriter out;
        int n;

        public void solve(int testNumber, FastReader in, PrintWriter out) {
            this.in = in;
            this.out = out;
            n = in.nextInt();
            if (n % 4 != 0) {
                out.println(""! -1"");
                return;
            }
            int low = 0;
            int high = n >> 1;
            if (BValue(low) == 0) {
                out.println(""! "" + (low + 1));
                return;
            }
            boolean value = BValue(low) > 0;
            while (high - low > 1) {
                int mid = (high + low) >> 1;
                int BVal = BValue(mid);
                if (BVal == 0) {
                    out.println(""! "" + (mid + 1));
                    return;
                }
                if (value) {
                    if (BVal < 0) {
                        high = mid;
                    } else {
                        low = mid;
                    }
                } else {
                    if (BVal > 0) {
                        high = mid;
                    } else {
                        low = mid;
                    }
                }
            }
            out.println(""! -1"");
        }

        public int BValue(int index) {
            out.println(""? "" + (index + 1));
            out.flush();
            int f = in.nextInt();
            out.println(""? "" + (index + 1 + (n >> 1)));
            out.flush();
            int s = in.nextInt();
            return f - s;
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int pnumChars;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        private int pread() {
            if (pnumChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= pnumChars) {
                curChar = 0;
                try {
                    pnumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (pnumChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            int res = 0;
            do {
                if (c == ',') {
                    c = pread();
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",CorCod,886,886,logn
"import java.util.Scanner;;
public class JavaApplication2 {

    public static void main(String[] args) {
        Scanner sc =new Scanner(System.in);
        int n= sc.nextInt();
        int li[]=new int[n];
        for(int i = 0 ;i<n;i++){
            li[i]=sc.nextInt();
        }
        int max=0;
         int c=0;
        for(int i = 0;i<n;i++){
           c=0;
            for(int j=i;j<n;j++){
                if(j!=n-1&&j!=0&&li[j]-li[j-1]==1&&li[j+1]-li[j]==1){
                    c++;
                    i++;
                }
                else if(j!=n-1&&j==0&&li[j+1]-li[j]==1&&li[j]==1){
                    c++;
                    i++;
                }
                else if(j==n-1&&j!=0&&li[j]-li[j-1]==1&&li[j]==1000){
                    c++;
                    i++;
                }
                else{ break;}
            }
            if(c>max){
                max=c;
            }
        }
        if(c>max){
                max=c;
            }
        System.out.println(max);
        
       
    }
    
}
",CorCod,540,540,quadratic
"
/* Java program to check if all three given 
traversals are of the same tree */
import
java.util.*; 
class
GfG { 

static
int
preIndex = 
0
; 

// A Binary Tree Node 
static
class
Node 
{ 

int
data; 

Node left, right; 
} 

// Utility function to create a new tree node 
static
Node newNode(
int
data) 
{ 

Node temp = 
new
Node(); 

temp.data = data; 

temp.left = 
null
; 

temp.right = 
null
; 

return
temp; 
} 

/* Function to find index of value in arr[start...end] 
The function assumes that value is present in in[] */
static
int
search(
int
arr[], 
int
strt, 
int
end, 
int
value) 
{ 

for
(
int
i = strt; i <= end; i++) 

{ 

if
(arr[i] == value) 

return
i; 

} 

return
-
1
; 
} 

/* Recursive function to construct binary tree 
of size len from Inorder traversal in[] and 
Preorder traversal pre[]. Initial values 
of inStrt and inEnd should be 0 and len -1. 
The function doesn't do any error checking for 
cases where inorder and preorder do not form a 
tree */
static
Node buildTree(
int
in[], 
int
pre[], 
int
inStrt, 
int
inEnd) 
{ 


if
(inStrt > inEnd) 

return
null
; 


/* Pick current node from Preorder traversal 

using preIndex and increment preIndex */

Node tNode = newNode(pre[preIndex++]); 


/* If this node has no children then return */

if
(inStrt == inEnd) 

return
tNode; 


/* Else find the index of this node in 

Inorder traversal */

int
inIndex = search(in, inStrt, inEnd, tNode.data); 


/* Using index in Inorder traversal, 

construct left and right subtress */

tNode.left = buildTree(in, pre, inStrt, inIndex-
1
); 

tNode.right = buildTree(in, pre, inIndex+
1
, inEnd); 


return
tNode; 
} 

/* function to compare Postorder traversal 
on constructed tree and given Postorder */
static
int
checkPostorder(Node node, 
int
postOrder[], 
int
index) 
{ 

if
(node == 
null
) 

return
index; 


/* first recur on left child */

index = checkPostorder(node.left,postOrder,index); 


/* now recur on right child */

index = checkPostorder(node.right,postOrder,index); 


/* Compare if data at current index in 

both Postorder traversals are same */

if
(node.data == postOrder[index]) 

index++; 

else

return
-
1
; 


return
index; 
} 

// Driver program to test above functions 
public
static
void
main(String[] args) 
{ 

int
inOrder[] = {
4
, 
2
, 
5
, 
1
, 
3
}; 

int
preOrder[] = {
1
, 
2
, 
4
, 
5
, 
3
}; 

int
postOrder[] = {
4
, 
5
, 
2
, 
3
, 
1
}; 


int
len = inOrder.length; 


// build tree from given 

// Inorder and Preorder traversals 

Node root = buildTree(inOrder, preOrder, 
0
, len - 
1
); 


// compare postorder traversal on constructed 

// tree with given Postorder traversal 

int
index = checkPostorder(root,postOrder,
0
); 


// If both postorder traversals are same 

if
(index == len) 

System.out.println(
""Yes""
); 

else

System.out.println(
""No""
); 

} 
} ",CorCod,414,414,quadratic
"import java.util.*;

//201920181

public class Polycarp{

	public static void main(String args[]){
		Scanner s = new Scanner(System.in);
        int rem[] = new int[3];
		
		Arrays.fill(rem,-1);
		rem[0] = 0;
        char ch[] = s.next().toCharArray();
		int n = ch.length;
 		long dp[] = new long[n];

        int sum = 0;
		
        for(int i=0;i<ch.length;i++){
		   sum = sum + (ch[i]-48);
		   if(rem[sum%3] != -1)
			    if(i>0){
					dp[i] = Math.max(dp[i-1],dp[rem[sum%3]]+1);}
				else
					dp[i] = 1;
	       else
			   if(i>0)
				   dp[i] = dp[i-1];
			   
		   
		   rem[sum%3] = i;
		   sum = sum%3;
		   
		}		
		 

            System.out.println(dp[n-1]);			
		
		
	}
}
",CorCod,37,37,linear
"
// Java program to print Postorder traversal from given Inorder 
// and Preorder traversals. 

public
class
PrintPost { 

static
int
preIndex = 
0
; 

void
printPost(
int
[] in, 
int
[] pre, 
int
inStrt, 
int
inEnd) 

{ 

if
(inStrt > inEnd) 

return
; 


// Find index of next item in preorder traversal in 

// inorder. 

int
inIndex = search(in, inStrt, inEnd, pre[preIndex++]); 


// traverse left tree 

printPost(in, pre, inStrt, inIndex - 
1
); 


// traverse right tree 

printPost(in, pre, inIndex + 
1
, inEnd); 


// print root node at the end of traversal 

System.out.print(in[inIndex] + 
"" ""
); 

} 


int
search(
int
[] in, 
int
startIn, 
int
endIn, 
int
data) 

{ 

int
i = 
0
; 

for
(i = startIn; i < endIn; i++) 

if
(in[i] == data) 

return
i; 

return
i; 

} 


// Driver code 

public
static
void
main(String ars[]) 

{ 

int
in[] = { 
4
, 
2
, 
5
, 
1
, 
3
, 
6
}; 

int
pre[] = { 
1
, 
2
, 
4
, 
5
, 
3
, 
6
}; 

int
len = in.length; 

PrintPost tree = 
new
PrintPost(); 

tree.printPost(in, pre, 
0
, len - 
1
); 

} 
} ",CorCod,402,402,quadratic
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class AAA {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());	
		int n=Integer.parseInt(st.nextToken());
		int m=Integer.parseInt(st.nextToken());
		String a="""";
		String b="""";
		for(int i=0;i<1129;i++) {
			a+=""1"";
			b+=""8"";
		}
		a+=""9"";
		b+=""1"";
		
		System.out.println(a);
		System.out.println(b);
	}
		
}
",CorCod,782,782,constant
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Cf1005A {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int numberOfStairs = 0;
        StringBuilder result = new StringBuilder("""");
        StringTokenizer stk = new StringTokenizer(br.readLine());
        int previousNum = 0;
        int tmp = 0;
        for (int i = 0; i < n; i++) {
            tmp = Integer.parseInt(stk.nextToken());
            if (tmp == 1){
                ++numberOfStairs;
                if (previousNum != 0)
                    result.append(previousNum + "" "");
            }
            previousNum = tmp;
        }
        result.append(previousNum);
        System.out.println(numberOfStairs);
        System.out.println(result);
    }
}
",CorCod,47,47,linear
"
// Java program to write characters in 
// minimum time by inserting, removing 
// and copying operation 

public
class
GFG{ 


// method returns minimum time to write 

// 'N' characters 

static
int
minTimeForWritingChars(
int
N, 
int
insert, 

int
remove, 
int
copy) 

{ 

if
(N == 
0
) 

return
0
; 

if
(N == 
1
) 

return
insert; 


// declare dp array and initialize with zero 

int
dp[] = 
new
int
[N + 
1
]; 



// loop for 'N' number of times 

for
(
int
i = 
1
; i <= N; i++) 

{ 

/* if current char count is even then 

choose minimum from result for (i-1) 

chars and time for insertion and 

result for half of chars and time 

for copy */

if
(i % 
2
== 
0
) 

dp[i] = Math.min(dp[i-
1
] + insert, dp[i/
2
] + copy); 


/* if current char count is odd then 

choose minimum from 

result for (i-1) chars and time for 

insertion and 

result for half of chars and time for 

copy and one extra character deletion*/

else

dp[i] = Math.min(dp[i-
1
] + insert, 

dp[(i+
1
)/
2
] + copy + remove); 

} 

return
dp[N]; 

} 


// Driver code to test above methods 

public
static
void
main(String []args) 

{ 

int
N = 
9
; 

int
insert = 
1
, remove = 
2
, copy = 
1
; 

System.out.println(minTimeForWritingChars(N, insert,remove, copy)); 

} 

// This code is contributed by Ryuga 
} ",CorCod,248,248,linear
"import java.util.Scanner;

public class Solution {

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		String s = sc.next();

		StringBuilder ans = new StringBuilder();
		int count = 0;
		int open = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == '(') {
				ans.append(""("");
				count++;
				open++;
			} else {
				ans.append("")"");
				open--;
			}
			if (count == k / 2) {
				break;
			}
		}

		while (open > 0) {
			ans.append("")"");
			open--;
		}
		System.out.println(ans.toString());
	}
}",CorCod,272,272,linear
"import java.util.Scanner;

public class TreasureHunt {
	
	public static String Solve() {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		sc.nextLine();
		String kuro = sc.nextLine(), shiro = sc.nextLine(), katie = sc.nextLine();
		sc.close();
		String[] output = {""Kuro"", ""Shiro"", ""Katie"", ""Draw""};
		if(n >= kuro.length())
			return output[3];
		int[] maxArr = new int[3];		
		int[][] freq = new int[3][58];
		for(int i = 0; i < kuro.length(); i++) {
			maxArr[0] = ++freq[0][kuro.charAt(i) - 65] > maxArr[0]? freq[0][kuro.charAt(i) - 65] : maxArr[0];
			maxArr[1] = ++freq[1][shiro.charAt(i) - 65] > maxArr[1]? freq[1][shiro.charAt(i) - 65] : maxArr[1];
			maxArr[2] = ++freq[2][katie.charAt(i) - 65] > maxArr[2]? freq[2][katie.charAt(i) - 65] : maxArr[2];
		}
		int winner = 0, max = 0;
		for(int i = 0; i < 3; i++) {
			if(kuro.length() - maxArr[i] >= n)
				maxArr[i] += n;
			else 
				maxArr[i] = n == 1? kuro.length() - 1: kuro.length();
			if(max < maxArr[i]) {
				winner = i;
				max = maxArr[i];
			} else if(max == maxArr[i])
				winner = 3;
		}
		
		return output[winner];
	}
	public static void main(String[] args) {
		System.out.println(Solve());
	}
}
",CorCod,169,169,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

import static java.lang.Math.*;

public class Main {

    private FastScanner scanner = new FastScanner();

    public static void main(String[] args) {
        new Main().solve();
    }


    private void solve() {
        int n = scanner.nextInt();

        Map<Integer, Integer> cnt = new HashMap<>();

        for (int i = 0; i < n; i++) {
            String s = scanner.nextLine();

            LinkedList<Character> st = new LinkedList<>();

            for (char c : s.toCharArray()) {
                if (c == ')' && !st.isEmpty() && st.getLast() == '(') {
                    st.pollLast();
                    continue;
                }
                st.addLast(c);
            }

            int t = st.size();
            Set<Character> set = new HashSet<>(st);
            if (set.size() > 1) {
                continue;
            }
            if (set.isEmpty()) {
                cnt.put(0, cnt.getOrDefault(0, 0) + 1);
                continue;
            }

            if (st.getLast() == '(') {
                cnt.put(t, cnt.getOrDefault(t, 0) + 1);
            } else {
                cnt.put(-t, cnt.getOrDefault(-t, 0) + 1);
            }
        }

        long ans = 0;

        for (int next : cnt.keySet()) {
            if (next == 0) {
                ans += (long) cnt.get(next) * (cnt.get(next) - 1) + cnt.get(next);
            } else if (next > 0) {
                int t = next * -1;
                if (cnt.containsKey(t)) {
                    ans += (long) cnt.get(next) * cnt.get(t);
                }
            }
        }

        System.out.print(ans);

    }

    class FastScanner {
        BufferedReader reader;
        StringTokenizer tokenizer;

        FastScanner() {
            reader = new BufferedReader(new InputStreamReader(System.in), 32768);
            tokenizer = null;
        }

        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        Integer[] nextA(int n) {
            Integer a[] = new Integer[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextInt();
            }
            return a;
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}",CorCod,109,109,linear
"import java.io.*;
import java.util.NoSuchElementException;


public class Main_1100C {

	private static Scanner sc;
	private static Printer pr;

	private static void solve() {
		int n = sc.nextInt();
		int r = sc.nextInt();

		double sin = Math.sin(Math.PI / n);
		double ans = r * sin / (1 - sin);
		
		pr.printf(""%.7f%n"", ans);
	}

	// ---------------------------------------------------
	public static void main(String[] args) {
		sc = new Scanner(System.in);
		pr = new Printer(System.out);
			
		solve();
			
		pr.close();
		sc.close();
	}

	static class Scanner {
		BufferedReader br;

		Scanner (InputStream in) {
			br = new BufferedReader(new InputStreamReader(in));
		}

		private boolean isPrintable(int ch) {
			return ch >= '!' && ch <= '~';
		}

		private boolean isCRLF(int ch) {
			return ch == '\n' || ch == '\r' || ch == -1;
		}

		private int nextPrintable() {
			try {
				int ch;
				while (!isPrintable(ch = br.read())) {
					if (ch == -1) {
						throw new NoSuchElementException();
					}
				}

				return ch;
			} catch (IOException e) {
				throw new NoSuchElementException();
			}
		}

		String next() {
			try {
				int ch = nextPrintable();
				StringBuilder sb = new StringBuilder();
				do {
					sb.appendCodePoint(ch);
				} while (isPrintable(ch = br.read()));

				return sb.toString();
			} catch (IOException e) {
				throw new NoSuchElementException();
			}
		}

		int nextInt() {
			try {
				// parseInt from Integer.parseInt()
				boolean negative = false;
				int res = 0;
				int limit = -Integer.MAX_VALUE;
				int radix = 10;

				int fc = nextPrintable();
				if (fc < '0') {
					if (fc == '-') {
						negative = true;
						limit = Integer.MIN_VALUE;
					} else if (fc != '+') {
						throw new NumberFormatException();
					}
					fc = br.read();
				}
				int multmin = limit / radix;

				int ch = fc;
				do {
					int digit = ch - '0';
					if (digit < 0 || digit >= radix) {
						throw new NumberFormatException();
					}
					if (res < multmin) {
						throw new NumberFormatException();
					}
					res *= radix;
					if (res < limit + digit) {
						throw new NumberFormatException();
					}
					res -= digit;

				} while (isPrintable(ch = br.read()));

				return negative ? res : -res;
			} catch (IOException e) {
				throw new NoSuchElementException();
			}
		}

		long nextLong() {
			try {
				// parseLong from Long.parseLong()
				boolean negative = false;
				long res = 0;
				long limit = -Long.MAX_VALUE;
				int radix = 10;

				int fc = nextPrintable();
				if (fc < '0') {
					if (fc == '-') {
						negative = true;
						limit = Long.MIN_VALUE;
					} else if (fc != '+') {
						throw new NumberFormatException();
					}
					fc = br.read();
				}
				long multmin = limit / radix;

				int ch = fc;
				do {
					int digit = ch - '0';
					if (digit < 0 || digit >= radix) {
						throw new NumberFormatException();
					}
					if (res < multmin) {
						throw new NumberFormatException();
					}
					res *= radix;
					if (res < limit + digit) {
						throw new NumberFormatException();
					}
					res -= digit;

				} while (isPrintable(ch = br.read()));

				return negative ? res : -res;
			} catch (IOException e) {
				throw new NoSuchElementException();
			}
		}

		float nextFloat() {
			return Float.parseFloat(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String nextLine() {
			try {
				int ch;
				while (isCRLF(ch = br.read())) {
					if (ch == -1) {
						throw new NoSuchElementException();
					}
				}
				StringBuilder sb = new StringBuilder();
				do {
					sb.appendCodePoint(ch);
				} while (!isCRLF(ch = br.read()));

				return sb.toString();
			} catch (IOException e) {
				throw new NoSuchElementException();
			}
		}
		
		int[] nextIntArray(int n) {
			int[] ret = new int[n];
			for (int i = 0; i < n; i++) {
				ret[i] = sc.nextInt();
			}
			
			return ret;
		}

		int[][] nextIntArrays(int n, int m) {
			int[][] ret = new int[m][n];
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < m; j++) {
					ret[j][i] = sc.nextInt();
				}
			}
			
			return ret;
		}

		void close() {
			try {
				br.close();
			} catch (IOException e) {
//				throw new NoSuchElementException();
			}
		}
	}

	static class Printer extends PrintWriter {
		Printer(OutputStream out) {
			super(out);
		}
		
		void printInts(int... a) {
			StringBuilder sb = new StringBuilder(32);
			for (int i = 0, size = a.length; i < size; i++) {
				if (i > 0) {
					sb.append(' ');
				}
				sb.append(a[i]);
			}

			println(sb);
		}
		
		void printLongs(long... a) {
			StringBuilder sb = new StringBuilder(64);
			for (int i = 0, size = a.length; i < size; i++) {
				if (i > 0) {
					sb.append(' ');
				}
				sb.append(a[i]);
			}

			println(sb);
		}
		
		void printStrings(String... a) {
			StringBuilder sb = new StringBuilder(32);
			for (int i = 0, size = a.length; i < size; i++) {
				if (i > 0) {
					sb.append(' ');
				}
				sb.append(a[i]);
			}

			println(sb);
		}
	}
}
",CorCod,740,740,constant
"import java.util.*;
import java.io.*;

public class FirstClass {
	
	public static void main(String[] args)throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(System.out);
		
		int n = Integer.parseInt(br.readLine());
		
		int arr[] = new int [n];
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());

		for(int i = 0 ; i < n ; i++)
		{
			arr[i] = Integer.parseInt(st1.nextToken());
		}
		
		int max = -1;
		boolean flag = true;
		
		for(int i = 0 ; i < n ; i++)
		{
			if(arr[i] > max+1)
			{
				flag = false;
				out.println(i+1);
				break;
			}
			else
			{
				max = Math.max(max, arr[i]);
			}
		}
		
		if(flag)
			out.println(-1);
	
		out.flush();
		out.close();
	}

}
",CorCod,267,267,linear
"
// A Java program to find a peak element element using divide and conquer 
import
java.util.*; 
import
java.lang.*; 
import
java.io.*; 

class
PeakElement 
{ 

// A binary search based function that returns index of a peak 

// element 

static
int
findPeakUtil(
int
arr[], 
int
low, 
int
high, 
int
n) 

{ 

// Find index of middle element 

int
mid = low + (high - low)/
2
; 
/* (low + high)/2 */


// Compare middle element with its neighbours (if neighbours 

// exist) 

if
((mid == 
0
|| arr[mid-
1
] <= arr[mid]) && (mid == n-
1
|| 

arr[mid+
1
] <= arr[mid])) 

return
mid; 


// If middle element is not peak and its left neighbor is 

// greater than it,then left half must have a peak element 

else
if
(mid > 
0
&& arr[mid-
1
] > arr[mid]) 

return
findPeakUtil(arr, low, (mid -
1
), n); 


// If middle element is not peak and its right neighbor 

// is greater than it, then right half must have a peak 

// element 

else
return
findPeakUtil(arr, (mid + 
1
), high, n); 

} 


// A wrapper over recursive function findPeakUtil() 

static
int
findPeak(
int
arr[], 
int
n) 

{ 

return
findPeakUtil(arr, 
0
, n-
1
, n); 

} 


// Driver method 

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
3
, 
20
, 
4
, 
1
, 
0
}; 

int
n = arr.length; 

System.out.println(
""Index of a peak point is ""
+ 

findPeak(arr, n)); 

} 
} ",CorCod,914,914,logn
"
// Java program to find minimum removals 
// to make max-min <= K 
import
java.util.Arrays; 

class
GFG 
{ 

static
int
MAX=
100
; 

static
int
dp[][]=
new
int
[MAX][MAX]; 


// function to check all possible combinations 

// of removal and return the minimum one 

static
int
countRemovals(
int
a[], 
int
i, 
int
j, 
int
k) 

{ 

// base case when all elements are removed 

if
(i >= j) 

return
0
; 


// if condition is satisfied, no more 

// removals are required 

else
if
((a[j] - a[i]) <= k) 

return
0
; 


// if the state has already been visited 

else
if
(dp[i][j] != -
1
) 

return
dp[i][j]; 


// when Amax-Amin>d 

else
if
((a[j] - a[i]) > k) { 


// minimum is taken of the removal 

// of minimum element or removal 

// of the maximum element 

dp[i][j] = 
1
+ Math.min(countRemovals(a, i + 
1
, j, k), 

countRemovals(a, i, j - 
1
, k)); 

} 

return
dp[i][j]; 

} 


// To sort the array and return the answer 

static
int
removals(
int
a[], 
int
n, 
int
k) 

{ 

// sort the array 

Arrays.sort(a); 


// fill all stated with -1 

// when only one element 

for
(
int
[] rows:dp) 

Arrays.fill(rows,-
1
); 

if
(n == 
1
) 

return
0
; 

else

return
countRemovals(a, 
0
, n - 
1
, k); 

} 


// Driver code 

public
static
void
main (String[] args) 

{ 

int
a[] = { 
1
, 
3
, 
4
, 
9
, 
10
, 
11
, 
12
, 
17
, 
20
}; 

int
n = a.length; 

int
k = 
4
; 

System.out.print(removals(a, n, k)); 

} 
} 

// This code is contributed by Anant Agarwal. ",CorCod,542,542,quadratic
"import java.io.*;
import java.util.*;


public class Main {

    static StringBuilder data = new StringBuilder();
    final static FastReader in = new FastReader();


    public static void main(String[] args) {
        int n = in.nextInt(), k = in.nextInt(), t;
        int[] a = new int[101];
        int answ = 0;
        for (long i = 0; i < n; i++) {
            t = in.nextInt();
            a[t]++;
            if (a[t] < 2) {
                if (answ < k) {
                    data.append(i + 1).append("" "");
                    answ++;
                }
            }

        }
        if (answ == k) {
            System.out.println(""YES"");
            System.out.println(data);
        } else {
            System.out.println(""NO"");
        }


    }


    static void fileOut(String s) {
        File out = new File(""output.txt"");
        try {
            FileWriter fw = new FileWriter(out);
            fw.write(s);
            fw.flush();
            fw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        public FastReader(String path) {
            try {
                br = new BufferedReader(new
                        InputStreamReader(new FileInputStream(path)));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        float nextFloat() {
            return Float.parseFloat(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }


        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

}",CorCod,293,293,linear
"import java.io.*;
import java.util.*;

public class Main {

    static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner() {
            try {
                br = new BufferedReader(new InputStreamReader(System.in));
                st = new StringTokenizer(br.readLine());
            } catch (Exception e){e.printStackTrace();}
        }

        public String next() {
            if (st.hasMoreTokens()) return st.nextToken();
            try {st = new StringTokenizer(br.readLine());}
            catch (Exception e) {e.printStackTrace();}
            return st.nextToken();
        }

        public int nextInt() {return Integer.parseInt(next());}

        public long nextLong() {return Long.parseLong(next());}

        public double nextDouble() {return Double.parseDouble(next());}

        public String nextLine() {
            String line = """";
            if(st.hasMoreTokens()) line = st.nextToken();
            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}
            while(st.hasMoreTokens()) line += "" ""+st.nextToken();
            return line;
        }
    }

    static class Pair {
        int a;
        int b;
        public Pair(int a, int b) {
            this.a = a;
            this.b = b;
        }
    }

    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        PrintWriter pw = new PrintWriter(System.out);

        int n = sc.nextInt();
        int floor = sc.nextInt();
        int time = 0;

        Pair[] arr = new Pair[n];
        for(int i=0;i<n;i++) arr[i] = new Pair(sc.nextInt(), sc.nextInt());

        Arrays.sort(arr, (Pair cur, Pair other) -> (other.a - cur.a));

        for(int i=0;i<n;i++) {
            time += floor - arr[i].a;
            floor = arr[i].a;
            time = Math.max(time, arr[i].b);
            //pw.println(""time: "" + time);
        }

        time += arr[n-1].a;

        pw.println(time);
        pw.close();
    }
}
",CorCod,598,598,nlogn
"
import java.util.*;

public class Main {

    public static void main(String[] args) {
       Scanner s = new Scanner(System.in);
       int n = s.nextInt();
       int m = s.nextInt();
       m = 0;
       long sum = 0;
       int[] expon = new int[n];
        for (int i = 0; i < n; i++) {
            expon[i] = s.nextInt();
            m = Math.max(expon[i], m);
            sum += expon[i];
        }
        HashSet<Integer> levels = new HashSet<>();


        int amount = 0;
        for (int i = 0; i < n; i++) {
            int currentHigh = expon[i];
            for (int j = currentHigh; j >= 1; j--) {
                if(!levels.contains(j)) {
                    levels.add(j);
                    amount++;
                    break;
                }
                if(j == 1){
                    amount++;
                }
            }
        }
        System.out.println((sum - amount) - (m - levels.size()));
    }
}",CorCod,471,471,quadratic
"package com.interview.binarysearch;

/**
 * @author Tushar Roy
 * Date 01/17/2107
 * A peak element is an element that is greater than its neighbors. Find index of peak element in the array.
 *
 * Space complexity is O(1)
 * Time complexity is O(n)
 *
 * https://leetcode.com/problems/find-peak-element/
 */
public class PeakElement {

    public int findPeakElement(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        int middle = 0;
        while (low <= high) {
            middle = (low + high)/2;
            int before = Integer.MIN_VALUE;
            if (middle > 0) {
                before = nums[middle - 1];
            }
            int after = Integer.MIN_VALUE;
            if (middle < nums.length - 1) {
                after = nums[middle + 1];
            }
            if (nums[middle] > before && nums[middle] > after) {
                return middle;
            } else if (before > after) {
                high = middle - 1;
            } else {
                low = middle + 1;
            }
        }
        return middle;
    }

    public static void main(String args[]){
        int arr[] = {10,5,15,2,23,90,67};
        PeakElement pe = new PeakElement();
        System.out.println(pe.findPeakElement(arr));
        int arr1[] = {10,20,30,40,50};
        System.out.println(pe.findPeakElement(arr1));
        int arr2[] = {100,90,80,70,60};
        System.out.println(pe.findPeakElement(arr2));
                
    }
}
",CorCod,930,930,logn
"    import jdk.nashorn.internal.objects.NativeArray;

    import javax.swing.JOptionPane ;
    import javax.swing.plaf.basic.BasicInternalFrameTitlePane;
    import java.sql.SQLSyntaxErrorException;
    import java.util.Arrays;
    import java.util.Scanner;
    import java.util.Vector;


    import static jdk.nashorn.internal.objects.NativeArray.sort;
    import static jdk.nashorn.internal.runtime.ScriptObject.toPropertyDescriptor;

    public class Dialog1 {
        private static int n ;
        private static String s ;
        private static char[] a;
        public static void main(String[] args) {
            Scanner input = new Scanner(System.in);
            n = input.nextInt() ;
            s = input.next() ;
            a = s.toCharArray();
            for(int i = 0 ; i < 200 ; ++i) {
                int cur = i ;
                boolean fl = true ;
                for(int j = 0 ; j < n ; ++j) {
                    if(a[j] == '+')
                        ++cur ;
                    else
                        --cur ;
                    if(cur < 0)
                        fl = false ;
                }
                if(fl) {
                    System.out.print(cur);
                    return ;
                }
            }
        }
    }",CorCod,92,92,linear
"
// Java program for recursive level order traversal in spiral form 

/* A binary tree node has data, pointer to left child 

and a pointer to right child */
class
Node { 

int
data; 

Node left, right; 


public
Node(
int
d) 

{ 

data = d; 

left = right = 
null
; 

} 
} 

class
BinaryTree { 

Node root; 


// Function to print the spiral traversal of tree 

void
printSpiral(Node node) 

{ 

int
h = height(node); 

int
i; 


/* ltr -> left to right. If this variable is set then the 

given label is traversed from left to right */

boolean
ltr = 
false
; 

for
(i = 
1
; i <= h; i++) { 

printGivenLevel(node, i, ltr); 


/*Revert ltr to traverse next level in opposite order*/

ltr = !ltr; 

} 

} 


/* Compute the ""height"" of a tree -- the number of 

nodes along the longest path from the root node 

down to the farthest leaf node.*/

int
height(Node node) 

{ 

if
(node == 
null
) 

return
0
; 

else
{ 


/* compute the height of each subtree */

int
lheight = height(node.left); 

int
rheight = height(node.right); 


/* use the larger one */

if
(lheight > rheight) 

return
(lheight + 
1
); 

else

return
(rheight + 
1
); 

} 

} 


/* Print nodes at a given level */

void
printGivenLevel(Node node, 
int
level, 
boolean
ltr) 

{ 

if
(node == 
null
) 

return
; 

if
(level == 
1
) 

System.out.print(node.data + 
"" ""
); 

else
if
(level > 
1
) { 

if
(ltr != 
false
) { 

printGivenLevel(node.left, level - 
1
, ltr); 

printGivenLevel(node.right, level - 
1
, ltr); 

} 

else
{ 

printGivenLevel(node.right, level - 
1
, ltr); 

printGivenLevel(node.left, level - 
1
, ltr); 

} 

} 

} 

/* Driver program to test the above functions */

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
1
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
3
); 

tree.root.left.left = 
new
Node(
7
); 

tree.root.left.right = 
new
Node(
6
); 

tree.root.right.left = 
new
Node(
5
); 

tree.root.right.right = 
new
Node(
4
); 

System.out.println(
""Spiral order traversal of Binary Tree is ""
); 

tree.printSpiral(tree.root); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,550,550,quadratic
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;

public class Cheast {

    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] l = new int[n];
        l[0] = sc.nextInt();
        int x=1;
        int c=1;
        for (int i=1;i<n;i++) {
            l[i] = sc.nextInt();
            if (l[i] <= l[i-1]*2) {
                c++;
                x = Math.max(x,c);
            }
            else
                c = 1;
        }
        System.out.println(x);



    }
}
",CorCod,278,278,linear
"
// JAVA Code for Dynamic Programming | 
// Set 9 (Binomial Coefficient) 
import
java.util.*; 

class
GFG { 


static
int
binomialCoeff(
int
n, 
int
k) 

{ 

int
C[] = 
new
int
[k + 
1
]; 


// nC0 is 1 

C[
0
] = 
1
; 


for
(
int
i = 
1
; i <= n; i++) 

{ 

// Compute next row of pascal 

// triangle using the previous row 

for
(
int
j = Math.min(i, k); j > 
0
; j--) 

C[j] = C[j] + C[j-
1
]; 

} 

return
C[k]; 

} 


/* Driver program */

public
static
void
main(String[] args) 

{ 

int
n = 
5
, k = 
2
; 

System.out.printf(
""Value of C(%d, %d) is %d ""

, n, k, binomialCoeff(n, k)); 

} 
} ",CorCod,512,512,quadratic
"//
//                                  _oo8oo_
//                                 o8888888o
//                                 88"" . ""88
//                                 (| -_- |)
//                                 0\  =  /0
//                               ___/'==='\___
//                             .' \\|     |// '.
//                            / \\|||  :  |||// \
//                           / _||||| -:- |||||_ \
//                          |   | \\\  -  /// |   |
//                          | \_|  ''\---/''  |_/ |
//                          \  .-\__  '-'  __/-.  /
//                        ___'. .'  /--.--\  '. .'___
//                     ."""" '<  '.___\_<|>_/___.'  >' """".
//                    | | :  `- \`.:`\ _ /`:.`/ -`  : | |
//                    \  \ `-.   \_ __\ /__ _/   .-` /  /
//                =====`-.____`.___ \_____/ ___.`____.-`=====
//                                  `=---=`
//
//
//               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//                          佛祖保佑         永不宕机/永无bug
//

import java.util.*;

public class G {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n, m;
        n = in.nextInt();
        m = in.nextInt();
        int[] a = new int[m];

        for (int i = 0; i < m; i++) {
            a[i] = in.nextInt();
        }

        Arrays.sort(a);
        HashMap<Integer, Integer> map = new HashMap<>(200);
        for (int i : a) {
            Integer t = map.get(i);
            if (t == null) {
                map.put(i, 1);
            } else {
                map.put(i, t + 1);
            }
        }

        ArrayList<Food> list = new ArrayList<>(100);
        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<Integer, Integer> en = it.next();
            list.add(new Food(en.getKey(), en.getValue()));
        }

        list.sort(Comparator.comparingInt(o -> o.num));
        int min, max;
        min = 1;
        max = list.get(list.size() - 1).num;
        int res = 0;
        for (int i = min; i <= max; i++) {
            int t = 0;
            for (Food food : list) {
                int gaven = food.num / i;
                if (gaven >= 1) {
                    t += gaven;
                    if (t >= n) {
                        res = Math.max(res, i);
                        break;
                    }
                }
            }
        }
        System.out.println(res);
//        System.out.println(Arrays.toString(list.toArray()));
//        if (list.size() < n) {
//            System.out.println(0);
//        } else {
//            System.out.println(list.get(n - 1).num);
//        }
    }
}

class Food {
    int id;
    int num;

    public Food(int id, int num) {
        this.id = id;
        this.num = num;
    }

    @Override
    public String toString() {
        return ""Food{"" +
                ""id="" + id +
                "", num="" + num +
                '}';
    }
}
",CorCod,453,453,quadratic
"import java.io.*;
import java.util.*;

public class Main
	{	
		class node{
		int data;
		node next;
		public node(int val){
			data=val;
			next=null;
		}
	}
	class linkedlist{
		node start;
		node end;
		int size;
		int turn;
		public linkedlist(){
			start=null;
			end=null;
			size=0;
		}
		void add(int val){
			if(size==0){
				node t=new node(val);
				start=t;
				end=t;
				size++;
			}
			else{
				node t=new node(val);
				end.next=t;
				end=end.next;
				size++;
			}
		}
		void myfunc(){
			if(start.data>start.next.data){
				// System.out.println(""me ni hu"");
				node t=new node(start.next.data);
				start.next=start.next.next;
				end.next=t;
				end=end.next;
			}
			else{
				// System.out.println(""me hu"");
				int t=start.data;
				start=start.next;
				add(t);
				size--;
			}
		}
		int findmax(){
			int m=0;
			node temp=start;
			for(int i=0;i<size;i++){
				if(temp.data>m){
					m=temp.data;
				}
				temp=temp.next;
			}
			return m;
		}
		void display(){
			node temp=start;
			for(int i=0;i<size;i++){
				System.out.print(temp.data+"" "");
				temp=temp.next;
			}
			System.out.println("""");
		}
	}
	linkedlist l;
	public Main(){
		l=new linkedlist();
	}
	public static void main(String [] argv) throws IOException
	{
		BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
		Main ma=new Main();
		String[] l1=in.readLine().split("" "");
		int n=Integer.parseInt(l1[0]);
		int q=Integer.parseInt(l1[1]);
		String[] ar=in.readLine().split("" "");
		int a1=Integer.parseInt(ar[0]);
		int b1=Integer.parseInt(ar[1]);
		for(int i=0;i<n;i++){
			ma.l.add(Integer.parseInt(ar[i]));
		}
		int m=ma.l.findmax();
		int[][] pair=new int[n][2];
		int t=0;
		for(int i=0;i<n;i++){
			if(ma.l.start.data==m)
				break;
			ma.l.myfunc();
			pair[t][0]=ma.l.start.data;
			pair[t][1]=ma.l.start.next.data;
			t++;
		}
		int rl[]=new int[n];
		node temp=ma.l.start;
		for(int i=0;i<n;i++){
			rl[i]=temp.data;
			temp=temp.next;
		}
		for(int i=0;i<q;i++){
			long a=Long.parseLong(in.readLine());
			if(a==1){
				System.out.println(a1 + "" "" + b1);
			}
			else{
				if(a<=t+1){
					System.out.println(pair[(int)(a-2)][0]+"" ""+pair[(int)(a-2)][1]);
				}
				else{
					if((a-t)%(n-1)==0){
						System.out.println(rl[0]+"" ""+rl[n-1]);
					}
					else{
						System.out.println(rl[0]+"" ""+rl[(int)((a-t)%(n-1))]);
					}
				}
			}
		}
	}
}",CorCod,73,73,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) {
        SpeedScanner speedScanner = new SpeedScanner();
        PrintWriter out = new PrintWriter(System.out);
        taskSolver(speedScanner, out);
        out.close();
    }


    public static void taskSolver(SpeedScanner speedScanner, PrintWriter out) {
        long n = speedScanner.nextLong();
        long m = speedScanner.nextLong();
        long k = speedScanner.nextLong();
        long l = speedScanner.nextLong();

        long tempM ;

        if ((k+l) < m){
            if (n<m)
                out.print(-1);
            else
                out.print(1);
        }else {
            tempM = (k+l)/m;
            if ((k+l)%m == 0){
                if (tempM*m <= n)
                    out.print(tempM);
                else
                    out.print(-1);
            }else {
                if ((tempM+1)*m <= n)
                    out.print(tempM+1);
                else
                    out.print(-1);
            }
        }
    }


    public static class SpeedScanner {
        BufferedReader br;
        StringTokenizer st;

        public SpeedScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String nextToken() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(nextToken());
        }

        long nextLong() {
            return Long.parseLong(nextToken());
        }

        double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }

}
",CorCod,776,776,constant
"
//Java program to generate binary numbers from 1 to n 

import
java.util.LinkedList; 
import
java.util.Queue; 

public
class
GenerateBNo 
{ 

// This function uses queue data structure to print binary numbers 

static
void
generatePrintBinary(
int
n) 

{ 

// Create an empty queue of strings 

Queue<String> q = 
new
LinkedList<String>(); 


// Enqueue the first binary number 

q.add(
""1""
); 


// This loops is like BFS of a tree with 1 as root 

// 0 as left child and 1 as right child and so on 

while
(n-- > 
0
) 

{ 

// print the front of queue 

String s1 = q.peek(); 

q.remove(); 

System.out.println(s1); 


// Store s1 before changing it 

String s2 = s1; 


// Append ""0"" to s1 and enqueue it 

q.add(s1 + 
""0""
); 


// Append ""1"" to s2 and enqueue it. Note that s2 contains 

// the previous front 

q.add(s2 + 
""1""
); 

} 

} 


// Driver program to test above function 

public
static
void
main(String[] args) 

{ 

int
n=
10
; 

generatePrintBinary(n); 

} 
} 
//This code is contributed by Sumit Ghosh ",CorCod,643,643,nlogn
"
// Java program to count subsequences of the 
// form a^i b^j c^k 
public
class
No_of_subsequence { 


// Returns count of subsequences of the form 

// a^i b^j c^k 

static
int
countSubsequences(String s) 

{ 

// Initialize counts of different subsequences 

// caused by different combination of 'a' 

int
aCount = 
0
; 


// Initialize counts of different subsequences 

// caused by different combination of 'a' and 

// different combination of 'b' 

int
bCount = 
0
; 


// Initialize counts of different subsequences 

// caused by different combination of 'a', 'b' 

// and 'c'. 

int
cCount = 
0
; 


// Traverse all characters of given string 

for
(
int
i=
0
; i< s.length(); i++) 

{ 

/* If current character is 'a', then 

there are following possibilities : 

a) Current character begins a new 

subsequence. 

b) Current character is part of aCount 

subsequences. 

c) Current character is not part of 

aCount subsequences. */

if
(s.charAt(i) == 
'a'
) 

aCount = (
1
+ 
2
* aCount); 


/* If current character is 'b', then 

there are following possibilities : 

a) Current character begins a new 

subsequence of b's with aCount 

subsequences. 

b) Current character is part of bCount 

subsequences. 

c) Current character is not part of 

bCount subsequences. */

else
if
(s.charAt(i) == 
'b'
) 

bCount = (aCount + 
2
* bCount); 


/* If current character is 'c', then 

there are following possibilities : 

a) Current character begins a new 

subsequence of c's with bCount 

subsequences. 

b) Current character is part of cCount 

subsequences. 

c) Current character is not part of 

cCount subsequences. */

else
if
(s.charAt(i) == 
'c'
) 

cCount = (bCount + 
2
* cCount); 

} 


return
cCount; 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

String s = 
""abbc""
; 

System.out.println(countSubsequences(s)); 

} 
} 
// This code is contributed by Sumit Ghosh ",CorCod,147,147,linear
"
import java.math.BigInteger;
import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Andy Phan
 */
public class p1096f {
    static long MOD = 998244353;
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        BIT invert = new BIT(n+5);
        BIT neg = new BIT(n+5);
        long res = 0;
        int[] arr = new int[n];
        boolean[] has = new boolean[n+1];
        long num1 = 0;
        for(int i = 0; i < n; i++) {
            arr[i] = in.nextInt();
            if(arr[i] != -1) {
                res += invert.read(n+5)-invert.read(arr[i]);
                res %= MOD;
                invert.update(arr[i], 1);
                has[arr[i]] = true;
            } else num1++;
        }
        if(num1 == 0) {
            System.out.println(res);
            return;
        }
        for(int i = 1; i <= n; i++) if(!has[i]) neg.update(i, 1);
        long invertNum1 = modInv(num1, MOD);
        res += ((num1*(num1-1))%MOD)*modInv(4, MOD);
        res %= MOD;
        long cnt = 0;
        for(int i = 0; i < n; i++) {
            if(arr[i] == -1) {
                cnt++;
                continue;
            }
            res += (((neg.read(n+5)-neg.read(arr[i]))*cnt)%MOD)*invertNum1;
            res %= MOD;
        }
        cnt = 0;
        for(int i = n-1; i >= 0; i--) {
            if(arr[i] == -1) {
                cnt++;
                continue;
            }
            res += (((neg.read(arr[i]))*cnt)%MOD)*invertNum1;
            res %= MOD;
        }
        System.out.println(res);
    }
    
    //@
    static class BIT {
            int n;
            int[] tree;
            public BIT(int n) {
                    this.n = n;
                    tree = new int[n + 1];
            }

            int read(int i) {
                    int sum = 0;
                    while (i > 0) {
                            sum += tree[i];
                            i -= i & -i;
                    }
                    return sum;
            }

            void update(int i, int val) {
                    while (i <= n) {
                            tree[i] += val;
                            i += i & -i;
                    }
            }
            //$
    }

    
    //@
    // Computes the modular inverse of x
    // Returns 0 if the GCD of x and mod is not 1
    // O(log n)  :  Can be converted to use BigIntegers
    static long modInv(long x, long mod) {
        return (BigInteger.valueOf(x).modInverse(BigInteger.valueOf(mod))).longValue();
    }

    static long modInv(long a, long b, long y0, long y1, long q0, long q1) {
            long y2 = y0 - y1*q0;
            return b == 0 ? y2 : modInv(b, a % b, y1, y2, q1, a / b);
    }
    
    //@
    static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }
    static long lcm(long a, long b) { return a / gcd(a, b) * b; }


}
",CorCod,627,627,nlogn
"import java.util.*;
public class Kello
{
    public static void  main(String args[])
    {
        Scanner sc =new Scanner(System.in);
        int n,q,m,max,inp,k,i;
        long in_q;
        n=sc.nextInt();
        q=sc.nextInt();
        int a[]=new int[n-1];
        int b[]=new int[n-1];
        int c[]=new int[n-1];
        max=sc.nextInt();
        for(i=0;i<n-1;i++)
        {
            inp=sc.nextInt();
            a[i]=max;
            b[i]=inp;
            if(inp>max)
            {
                c[i]=max;
             max=inp;
        }
        else
        c[i]=inp;
    }
   // display(a,b);
        for(i=0;i<q;i++)
        {
            in_q=sc.nextLong();
            if(in_q<n)
            System.out.println(a[(int)in_q-1]+"" ""+b[(int)in_q-1]);
          else   {
          k=(int)(in_q %(n-1))-1;
          if(k==-1)
          k=n-2;
          System.out.println(max+"" ""+c[k]);
            }
        }
    }
    public static void display(int a[],int b[])
    {
        int i;
        for(i=0;i<a.length;i++)
        System.out.println(a[i]+"" ""+b[i]);
}
}

              ",CorCod,302,302,linear
"import java.io.*;
import java.util.*;

public class LectureSleep {

    static class InputReader {
        BufferedReader reader;
        StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public float nextFloat() {
            return Float.parseFloat(next());
        }

    }

    static InputReader r = new InputReader(System.in);
    static PrintWriter pw = new PrintWriter(System.out);


    public static void main(String[] args) {
        int n = r.nextInt(); // duration of lecture
        int k = r.nextInt(); // number of minutes keep mishka awake
        int[] theorems = new int[n+1];
        for(int i = 1; i <= n; i++){
            theorems[i] = r.nextInt();
        }
        int[] mishka = new int[n+1];
        for(int i = 1; i <= n; i++){
            mishka[i] = r.nextInt();
        }
        int[] sums = new int[n+1];
        for(int i = 1; i <= n; i++){
            if(mishka[i] == 0){
                sums[i] = sums[i-1] + theorems[i];
            } else{
                sums[i] = sums[i-1];
            }
        }
        int max = 0;
        for(int i = 1; i <= n-k+1; i++){
            int sum = sums[i+k-1] - sums[i-1];
            max = Math.max(max, sum);
        }
        int totalSum = 0;
        for(int i = 1; i <= n; i++){
            if(mishka[i] == 1){
                totalSum += theorems[i];
            }
        }

        pw.println(totalSum + max);

        pw.close();
    }
}",CorCod,107,107,linear
"
// A Simple Java program to find pairs with distance 
// equal to English alphabet distance 
class
Test { 


// Method to count pairs 

static
int
countPairs(String str) 

{ 

int
result = 
0
; 

int
n = str.length(); 

for
(
int
i = 
0
; i < n; i++) 

for
(
int
j = i + 
1
; j < n; j++) 


// Increment count if characters 

// are at same distance 

if
(Math.abs(str.charAt(i) - str.charAt(j)) == 

Math.abs(i - j)) 

result++; 


return
result; 

} 


// Driver method 

public
static
void
main(String args[]) 

{ 

String str = 
""geeksforgeeks""
; 

System.out.println(countPairs(str)); 

} 
} ",CorCod,455,455,quadratic
"import java.io.*;
import java.util.Arrays;


public class Main {
    public static void main(String[] args) {
        IO io = new IO();
        String s=io.nextLine();
        if (s.length()<3)io.println(""No"");
        else {
            int[]b=new int[200];
            for (int i=2;i<s.length();i++){
                b['.']=b['A']=b['B']=b['C']=0;
                b[s.charAt(i-2)]=1;
                b[s.charAt(i-1)]=1;
                b[s.charAt(i)]=1;
                if (b['A']+b['B']+b['C']==3){io.println(""Yes"");return;}
            }
            io.println(""No"");
        }
    }


    static class IO {

        BufferedInputStream din;
        final int BUFFER_SIZE = 1 << 16;
        byte[] buffer;
        int byteRead, bufferPoint;

        StringBuilder builder;
        PrintWriter pw;

        public IO() {
            din = new BufferedInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPoint = byteRead = 0;

            builder = new StringBuilder();
            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
                    System.out
            )), true);
        }

        int read() {
            if (bufferPoint >= byteRead) {
                try {
                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (byteRead == -1) buffer[0] = -1;
            }
            return buffer[bufferPoint++];
        }

        int peek() {
            if (byteRead == -1) return -1;
            if (bufferPoint >= byteRead) {
                try {
                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);
                } catch (IOException e) {
                    return -1;
                }
                if (byteRead <= 0) return -1;
            }
            return buffer[bufferPoint];
        }

        boolean hasNext() {
            int c = peek();
            while (c != -1 && c <= ' ') {
                read();
                c = peek();
            }
            return c != -1;
        }

        char nextChar() {
            int c = read();
            while (c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1) {
                c = read();
            }
            return (char) c;
        }

        double nextDouble() {
            double ret = 0, div = 1;
            int c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
            if (c == '.') {
                while ((c = read()) >= '0' && c <= '9') {
                    ret += (c - '0') / (div *= 10);
                }
            }
            if (neg)
                return -ret;
            return ret;
        }

        String nextLine() {
            byte[] strBuf = new byte[64];
            int cnt = 0, c;
            while ((c = read()) != -1) {
                if (c == '\n') {
                    if (cnt == 0) {
                        continue;
                    } else {
                        break;
                    }
                }
                if (strBuf.length == cnt) {
                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);
                }
                strBuf[cnt++] = (byte) c;
            }
            return new String(strBuf, 0, cnt);
        }


        String next() {
            byte[] strBuf = new byte[64];
            int cnt = 0, c;
            while ((c = read()) != -1) {
                if (Character.isWhitespace(c)) {
                    if (cnt == 0) {
                        continue;
                    } else {
                        break;
                    }
                }
                if (strBuf.length == cnt) {
                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);
                }
                strBuf[cnt++] = (byte) c;
            }
            return new String(strBuf, 0, cnt);
        }

        int nextInt() {
            int ans = 0;
            int c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do {
                ans = ans * 10 + c - '0';
            } while ('0' <= (c = read()) && c <= '9');
            bufferPoint--;
            return neg ? -ans : ans;
        }

        long nextLong() {
            long ans = 0;
            int c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do {
                ans = ans * 10 + c - '0';
            } while ('0' <= (c = read()) && c <= '9');
            bufferPoint--;
            return neg ? -ans : ans;
        }

        void println(Object o) {
            pw.println(o);
        }

        void print(Object o) {
            pw.print(o);
        }

        void printf(String format, Object... objects) {
            pw.printf(format, objects);
        }

        void close() {
            pw.close();
        }

        void done(Object o) {
            print(o);
            close();
        }

    }
}",CorCod,162,162,linear
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class DoggoRecoloring {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		int n = nextInt();
		String s = nextString();
		boolean b = false;
		
		if (n == 1 || n > 26)
			b = true;
		else 
			for (int i = 0; i < n; i++)
				for (int j = i+1; j < n; j++)
					if (s.charAt(i) == s.charAt(j))
						 b = true;
		
		System.out.println(b ? ""Yes"" : ""No"");
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",CorCod,440,440,quadratic
"
// Java code to rearrange an array such 
// that even index elements are smaller 
// and odd index elements are greater 
// than their next. 

class
GFG { 


static
void
rearrange(
int
arr[], 
int
n) 

{ 


int
temp; 

for
(
int
i = 
0
; i < n - 
1
; i++) { 

if
(i % 
2
== 
0
&& arr[i] > arr[i + 
1
]) { 

temp = arr[i]; 

arr[i] = arr[i + 
1
]; 

arr[i + 
1
] = temp; 

} 

if
(i % 
2
!= 
0
&& arr[i] < arr[i + 
1
]) { 

temp = arr[i]; 

arr[i] = arr[i + 
1
]; 

arr[i + 
1
] = temp; 

} 

} 

} 


/* Utility that prints out an array in 

a line */

static
void
printArray(
int
arr[], 
int
size) 

{ 

for
(
int
i = 
0
; i < size; i++) 

System.out.print(arr[i] + 
"" ""
); 


System.out.println(); 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
6
, 
4
, 
2
, 
1
, 
8
, 
3
}; 

int
n = arr.length; 


System.out.print(
""Before rearranging: \n""
); 

printArray(arr, n); 


rearrange(arr, n); 


System.out.print(
""After rearranging: \n""
); 

printArray(arr, n); 

} 
} 

// This code is contributed by Anant Agarwal. ",CorCod,31,31,linear
"
// Java program to find minimum difference between 
// any pair in an unsorted array 

import
java.util.Arrays; 

class
GFG 
{ 

// Returns minimum difference between any pair 

static
int
findMinDiff(
int
[] arr, 
int
n) 

{ 

// Sort array in non-decreasing order 

Arrays.sort(arr); 


// Initialize difference as infinite 

int
diff = Integer.MAX_VALUE; 


// Find the min diff by comparing adjacent 

// pairs in sorted array 

for
(
int
i=
0
; i<n-
1
; i++) 

if
(arr[i+
1
] - arr[i] < diff) 

diff = arr[i+
1
] - arr[i]; 


// Return min diff 

return
diff; 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

int
arr[] = 
new
int
[]{
1
, 
5
, 
3
, 
19
, 
18
, 
25
}; 

System.out.println(
""Minimum difference is ""
+ 

findMinDiff(arr, arr.length)); 


} 
} ",CorCod,713,713,nlogn
"import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collections;

public class gambling {
    public static void main(String[] args) throws IOException{
        Reader rd = new Reader();
        PrintWriter out = new PrintWriter(System.out);
        int n = rd.nextInt();
        Integer[] a = new Integer[n];
        Integer[] b = new Integer[n];
        for (int i = 0; i < n; i++) {
            a[i] = rd.nextInt();
        }
        for (int i = 0; i < n; i++) {
            b[i] = rd.nextInt();
        }
        solve(n, a, b, out);
        out.flush();
        out.close();
    }

    private static void solve(int n, Integer[] a, Integer[] b, PrintWriter out) {
        Arrays.sort(a, Collections.reverseOrder());
        Arrays.sort(b, Collections.reverseOrder());
        int aP = 0, bP = 0;
        long aScore = 0, bScore = 0;
        for (int i = 0; i < n * 2; i++) {
                if(i % 2 == 0) {
                    if(bP ==  n || (aP < n && a[aP] > b[bP])){
                        aScore += a[aP];
                        aP++;
                    }
                    else bP++;
                }
                else{
                    if(aP == n || (bP < n && b[bP] > a[aP])) {
                        bScore += b[bP];
                        bP++;
                    }
                    else aP++;
                }
        }
        out.println(aScore-bScore);
    }

    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public Reader(String file_name) throws IOException
        {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public String readLine() throws IOException
        {
            byte[] buf = new byte[64]; // line length
            int cnt = 0, c;
            while ((c = read()) != -1)
            {
                if (c == '\n')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
            if (neg)
                return -ret;
            return ret;
        }

        public double nextDouble() throws IOException
        {
            double ret = 0, div = 1;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();

            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');

            if (c == '.')
            {
                while ((c = read()) >= '0' && c <= '9')
                {
                    ret += (c - '0') / (div *= 10);
                }
            }

            if (neg)
                return -ret;
            return ret;
        }

        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
    }
}
",CorCod,674,674,nlogn
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class UniformString {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		int t = nextInt();
		for (int i = 0; i < t; i++) {
			int n = nextInt();
			int k = nextInt();
			String s = """";
			for (int j = 0; j < n; j++) 
				s += (char)('a' + (j%k)); 
			System.out.println(s);
		}
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",CorCod,185,185,linear
"
// A simple recursive JAVA program to find 
// maximum sum by recursively breaking a 
// number in 3 parts. 
import
java.io.*; 

class
GFG { 


final
int
MAX = 
1000000
; 


// Function to find the maximum sum 

static
int
breakSum(
int
n) 

{ 

int
dp[] = 
new
int
[n+
1
]; 


// base conditions 

dp[
0
] = 
0
; dp[
1
] = 
1
; 


// Fill in bottom-up manner using recursive 

// formula. 

for
(
int
i=
2
; i<=n; i++) 

dp[i] = Math.max(dp[i/
2
] + dp[i/
3
] + dp[i/
4
], i); 


return
dp[n]; 

} 


// Driver program to test the above function 

public
static
void
main (String[] args) { 

int
n = 
24
; 

System.out.println(breakSum(n)); 

} 
} 
// This code is contributed by Amit Kumar ",CorCod,122,122,linear
"
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int n,ans=0;
		String sa,sb;
		char[] a,b;
		n=sc.nextInt();
		sa=sc.next();
		sb=sc.next();
		a=sa.toCharArray();
		b=sb.toCharArray();
		ans=0;
		for(int i=0;i<n;i++)
		{
			if(i==n/2)
			{
				if(a[i]!=b[i])
					ans++;
				continue;
			}
			int[] vis=new int[28];
			vis[a[i]-'a']++;
			vis[b[i]-'a']++;
			vis[a[n-1-i]-'a']++;
			vis[b[n-1-i]-'a']++;
			int num=0,ans1=0,ans2=0;
			for(int j=0;j<26;j++)
				if(vis[j]!=0)
				{
					num++;
					if(num==1)
						ans1=vis[j];
					else
						ans2=vis[j];
				}
			if(num==2)
			{
				if(ans1==1||ans2==1)
					ans++;
			}
			else if(num==3)
			{
				if(a[i]==a[n-i-1])
					ans+=2;
				else
					ans++;
			}
			else if(num==4)
				ans+=2;
			a[i]=b[i];
			a[n-1-i]=b[n-1-i];
		}
		System.out.println(ans);
	}
}",CorCod,151,151,linear
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
744444444747477777774
44444447474747777777
 */

/**
 *
 * @author Andy Phan
 */
public class b {
    public static void main(String[] args) {
        FS in = new FS(System.in);
        PrintWriter out = new PrintWriter(System.out);
        
        int n = in.nextInt();
        Integer[] arr = new Integer[n];
        int numZ = 0;
        for(int i = 0; i < n; i++) {
            arr[i] = in.nextInt();
            if(arr[i] == 0) numZ++;
        }
        
        Arrays.sort(arr);
        
        
        if(numZ > 1) {
            System.out.println(""cslnb"");
            return;
        }
        int numDup = 0;
        int[] arr2 = new int[n];
        for(int i = 0; i < n; i++) {
            arr2[i] = arr[i];
            if(i != 0) {
                if(arr2[i] == arr2[i-1]) {
                    arr2[i-1]--;
                    numDup++;
                }
            }
        }
        
        if(numDup > 1) {
            System.out.println(""cslnb"");
            return;
        }
        
        
        for(int i = 0; i < n; i++) {
            if(i != 0) {
                if(arr2[i] == arr2[i-1]) {
                    System.out.println(""cslnb"");
                    return;
                }
            }
        }
        long num = 0;
        if(numDup == 1) num++;
        for(int i = 0; i < n; i++) {
            num += arr2[i]-i;
        }
        
        if(num%2 == 0) {
            System.out.println(""cslnb"");
        } else {
            System.out.println(""sjfnb"");
        }
        

        out.close();
    }
    
    static class FS {

        BufferedReader in;
        StringTokenizer token;
        
        public FS(InputStream str) {
            in = new BufferedReader(new InputStreamReader(str));
        }
        
        public String next() {
            if (token == null || !token.hasMoreElements()) {
                try {
                    token = new StringTokenizer(in.readLine());
                } catch (IOException ex) {
                }
                return next();
            }
            return token.nextToken();
        }
        
        public int nextInt() {
            return Integer.parseInt(next());
        }
    }
}
",CorCod,67,67,linear
"
// Java program to construct a tree using inorder and preorder traversal 

/* A binary tree node has data, pointer to left child 

and a pointer to right child */
class
Node { 

char
data; 

Node left, right; 


Node(
char
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree { 

Node root; 

static
int
preIndex = 
0
; 


/* Recursive function to construct binary of size len from 

Inorder traversal in[] and Preorder traversal pre[]. 

Initial values of inStrt and inEnd should be 0 and len -1. 

The function doesn't do any error checking for cases where 

inorder and preorder do not form a tree */

Node buildTree(
char
in[], 
char
pre[], 
int
inStrt, 
int
inEnd) 

{ 

if
(inStrt > inEnd) 

return
null
; 


/* Pick current node from Preorder traversal using preIndex 

and increment preIndex */

Node tNode = 
new
Node(pre[preIndex++]); 


/* If this node has no children then return */

if
(inStrt == inEnd) 

return
tNode; 


/* Else find the index of this node in Inorder traversal */

int
inIndex = search(in, inStrt, inEnd, tNode.data); 


/* Using index in Inorder traversal, construct left and 

right subtress */

tNode.left = buildTree(in, pre, inStrt, inIndex - 
1
); 

tNode.right = buildTree(in, pre, inIndex + 
1
, inEnd); 


return
tNode; 

} 


/* UTILITY FUNCTIONS */


/* Function to find index of value in arr[start...end] 

The function assumes that value is present in in[] */

int
search(
char
arr[], 
int
strt, 
int
end, 
char
value) 

{ 

int
i; 

for
(i = strt; i <= end; i++) { 

if
(arr[i] == value) 

return
i; 

} 

return
i; 

} 


/* This funtcion is here just to test buildTree() */

void
printInorder(Node node) 

{ 

if
(node == 
null
) 

return
; 


/* first recur on left child */

printInorder(node.left); 


/* then print the data of node */

System.out.print(node.data + 
"" ""
); 


/* now recur on right child */

printInorder(node.right); 

} 


// driver program to test above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

char
in[] = 
new
char
[] { 
'D'
, 
'B'
, 
'E'
, 
'A'
, 
'F'
, 
'C'
}; 

char
pre[] = 
new
char
[] { 
'A'
, 
'B'
, 
'D'
, 
'E'
, 
'C'
, 
'F'
}; 

int
len = in.length; 

Node root = tree.buildTree(in, pre, 
0
, len - 
1
); 


// building the tree by printing inorder traversal 

System.out.println(
""Inorder traversal of constructed tree is : ""
); 

tree.printInorder(root); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,584,584,quadratic
"import java.util.*;
 
public class Main {
 
    public static void main(String[] args) {
	// write your code here
        Scanner scan = new Scanner(System.in);
        int T = scan.nextInt();
        for(; T > 0; T--) {
            int n = scan.nextInt();
            int[] arr = new int[n];
            for(int i = 0; i < n; i++) arr[i] = scan.nextInt();
            int m1 = 1, m2 = 1;
            for(int i = 0; i < n; i++) {
                if(arr[i] >= m1) {
                    m2 = m1;
                    m1 = arr[i];
                } else if (arr[i] >= m2) {
                    m2 = arr[i];
                }
            }
            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));
        }
    }
}",CorCod,260,260,linear
"import java.util.Scanner;

public class Test{
	public static void main(String[] args){
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		int num=1;
		int add;
		for(int i=1;i<n;i++){
			add=4*i;
			num+=add;
		}
		System.out.println(num);
	}
}",CorCod,111,111,linear
"import java.util.Scanner;

public class HammingDistancesSum {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String  a = sc.nextLine(), b = sc.nextLine();
		long sum = 0;
		int frequency[][] = new int[200010][2];
		for (int i = 1; i <= b.length(); i++) {
	        for (int j = 0; j < 2; j++)
	            frequency[i][j] = frequency[i - 1][j];
	        frequency[i][Character.getNumericValue((b.charAt(i - 1)))]++;
	    }
	   
	    for (int i = 0; i < a.length(); i++) {
	        int c = Character.getNumericValue(a.charAt(i));
	        for (int j = 0; j < 2; j++) {
	        	int flippingTerm = Math.abs(c - j);
	        	int endOfWindowValue = frequency[b.length() - a.length() + i + 1][j];
	        	int startOfWindowOffset = frequency[i][j];
	            sum += flippingTerm * (endOfWindowValue - startOfWindowOffset);
	        }
	    }
		System.out.println(sum);
		sc.close();
	}
}
",CorCod,367,367,linear
"
/* Java program to check if linked list is palindrome recursively */

class
LinkedList { 

Node head; 
// head of list 

Node left; 


/* Linked list Node*/

class
Node { 

char
data; 

Node next; 


Node(
char
d) 

{ 

data = d; 

next = 
null
; 

} 

} 


// Initial parameters to this function are &head and head 

boolean
isPalindromeUtil(Node right) 

{ 

left = head; 


/* stop recursion when right becomes NULL */

if
(right == 
null
) 

return
true
; 


/* If sub-list is not palindrome then no need to 

check for current left and right, return false */

boolean
isp = isPalindromeUtil(right.next); 

if
(isp == 
false
) 

return
false
; 


/* Check values at current left and right */

boolean
isp1 = (right.data == (left).data); 


/* Move left to next node */

left = left.next; 


return
isp1; 

} 


// A wrapper over isPalindromeUtil() 

boolean
isPalindrome(Node head) 

{ 

boolean
result = isPalindromeUtil(head); 

return
result; 

} 


/* Push a node to linked list. Note that this function 

changes the head */

public
void
push(
char
new_data) 

{ 

/* Allocate the Node & 

Put in the data */

Node new_node = 
new
Node(new_data); 


/* link the old list off the new one */

new_node.next = head; 


/* Move the head to point to new Node */

head = new_node; 

} 


// A utility function to print a given linked list 

void
printList(Node ptr) 

{ 

while
(ptr != 
null
) { 

System.out.print(ptr.data + 
""->""
); 

ptr = ptr.next; 

} 

System.out.println(
""NULL""
); 

} 


/* Driver program to test the above functions */

public
static
void
main(String[] args) 

{ 

/* Start with the empty list */

LinkedList llist = 
new
LinkedList(); 


char
str[] = { 
'a'
, 
'b'
, 
'a'
, 
'c'
, 
'a'
, 
'b'
, 
'a'
}; 

String string = 
new
String(str); 

for
(
int
i = 
0
; i < 
7
; i++) { 

llist.push(str[i]); 

llist.printList(llist.head); 

if
(llist.isPalindrome(llist.head) != 
false
) { 

System.out.println(
""Is Palindrome""
); 

System.out.println(
""""
); 

} 

else
{ 

System.out.println(
""Not Palindrome""
); 

System.out.println(
""""
); 

} 

} 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,30,30,linear
"
// Java prorgam for finding max path in matrix 

import
static
java.lang.Math.max; 

class
GFG 
{ 

public
static
int
N = 
4
, M = 
6
; 


// Function to calculate max path in matrix 

static
int
findMaxPath(
int
mat[][]) 

{ 

// To find max val in first row 

int
res = -
1
; 

for
(
int
i = 
0
; i < M; i++) 

res = max(res, mat[
0
][i]); 


for
(
int
i = 
1
; i < N; i++) 

{ 

res = -
1
; 

for
(
int
j = 
0
; j < M; j++) 

{ 

// When all paths are possible 

if
(j > 
0
&& j < M - 
1
) 

mat[i][j] += max(mat[i - 
1
][j], 

max(mat[i - 
1
][j - 
1
], 

mat[i - 
1
][j + 
1
])); 


// When diagonal right is not possible 

else
if
(j > 
0
) 

mat[i][j] += max(mat[i - 
1
][j], 

mat[i - 
1
][j - 
1
]); 


// When diagonal left is not possible 

else
if
(j < M - 
1
) 

mat[i][j] += max(mat[i - 
1
][j], 

mat[i - 
1
][j + 
1
]); 


// Store max path sum 

res = max(mat[i][j], res); 

} 

} 

return
res; 

} 


// driver program 

public
static
void
main (String[] args) 

{ 

int
mat[][] = { { 
10
, 
10
, 
2
, 
0
, 
20
, 
4
}, 

{ 
1
, 
0
, 
0
, 
30
, 
2
, 
5
}, 

{ 
0
, 
10
, 
4
, 
0
, 
2
, 
0
}, 

{ 
1
, 
0
, 
2
, 
20
, 
0
, 
4
} 

}; 


System.out.println(findMaxPath(mat)); 

} 
} 

// Contributed by Pramod Kumar ",CorCod,478,478,quadratic
"import java.util.Scanner;

public class SashaAndHisTrip {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        int v = in.nextInt();
        if (v > N) {
            System.out.println(N-1);
        }
        else {
            int price = v + ((N-v-1) * (2+ N - v))/2;
            int counter = 0;
            System.out.println(price);
        }
    }
}
",CorCod,811,811,constant
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.StringTokenizer;

public class A {
	static FastReader scan;
	static PrintWriter out;

	public static void main(String[] args) throws FileNotFoundException {
		Solver solver = new Solver();
		scan = new FastReader();
		out = new PrintWriter(System.out);
		int testCases = 1;
		for(int i = 1; i <= testCases; i++) {
//			out.print(""Case #"" + i + "": "");
			solver.solve();
		}
		out.close();
	}

	static class Solver {
		
		void solve() {
			int a = scan.nextInt(), b = scan.nextInt();
			if(b <= a) out.println(1);
			else out.println(b/a + Math.min(1, b%a));
		}
		
	}

	// Sathvik's Template Stuff BELOW!!!!!!!!!!!!!!!!!!!!!!

	static class DSU {
		int[] root, size;
		int n;

		DSU(int n) {
			this.n = n;
			root = new int[n];
			size = new int[n];
			for (int i = 0; i < n; i++) {
				root[i] = i;
				size[i] = 1;
			}
		}

		int findParent(int idx) {
			while (root[idx] != idx) {
				root[idx] = root[root[idx]];
				idx = root[idx];
			}
			return idx;
		}

		boolean union(int x, int y) {
			int parX = findParent(x);
			int parY = findParent(y);
			if (parX == parY)
				return false;
			if (size[parX] < size[parY]) {
				root[parY] = parX;
				size[parX] += size[parY];
			} else {
				root[parX] = parY;
				size[parY] += size[parX];
			}
			return true;
		}
	}

	static class Extra {
		static void sort(int[] a) {
			Integer[] aa = new Integer[a.length];
			for (int i = 0; i < aa.length; i++)
				aa[i] = a[i];
			Arrays.sort(aa);
			for (int i = 0; i < aa.length; i++)
				a[i] = aa[i];
		}

		static void sort(long[] a) {
			Long[] aa = new Long[a.length];
			for (int i = 0; i < aa.length; i++)
				aa[i] = a[i];
			Arrays.sort(aa);
			for (int i = 0; i < aa.length; i++)
				a[i] = aa[i];
		}

		static void sort(double[] a) {
			Double[] aa = new Double[a.length];
			for (int i = 0; i < aa.length; i++)
				aa[i] = a[i];
			Arrays.sort(aa);
			for (int i = 0; i < aa.length; i++)
				a[i] = aa[i];
		}

		static void sort(char[] a) {
			Character[] aa = new Character[a.length];
			for (int i = 0; i < aa.length; i++)
				aa[i] = a[i];
			Arrays.sort(aa);
			for (int i = 0; i < aa.length; i++)
				a[i] = aa[i];
		}

		static long gcd(long a, long b) {
			while (b > 0) {
				long temp = b;
				b = a % b;
				a = temp;
			}
			return a;
		}

		static long lcm(long a, long b) {
			return a * (b / gcd(a, b));
		}

		static boolean isPrime(long n) {
			if (n <= 1)
				return false;
			if (n <= 3)
				return true;
			if (n % 2 == 0 || n % 3 == 0)
				return false;
			for (long i = 5; i * i <= n; i = i + 6) {
				if (n % i == 0 || n % (i + 2) == 0)
					return false;
			}
			return true;
		}

		static HashSet<Integer> sieve(int n) {
			boolean[] prime = new boolean[n + 1];
			HashSet<Integer> res = new HashSet<>();
			for (int p = 2; p * p <= n; p++) {
				if (!prime[p]) {
					res.add(p);
					for (int i = p * p; i <= n; i += p)
						prime[i] = true;
				}
			}
			return res;
		}

		static HashMap<Long, Integer> primeFactorization(long n) {
			HashMap<Long, Integer> res = new HashMap<>();
			while (n % 2 == 0) {
				res.put(2L, res.getOrDefault(2L, 0) + 1);
				n /= 2;
			}
			for (long i = 3; i * i <= n; i += 2) {
				while (n % i == 0) {
					res.put(i, res.getOrDefault(i, 0) + 1);
					n /= i;
				}
			}
			if (n > 2)
				res.put(n, 1);
			return res;
		}
	}

	static class FastReader {
		BufferedReader br;
		StringTokenizer st;

		public FastReader() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		public FastReader(String s) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(new File(s)));
		}

		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		double[] nextDoubleArray(int n) {
			double[] a = new double[n];
			for (int i = 0; i < n; i++)
				a[i] = nextDouble();
			return a;
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}
	}

}",CorCod,775,775,constant
"import java.util.*;
import java.io.*;
import java.math.*;
import java.util.HashMap;

public class Main
{
    static class Reader 
    { 
        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} 
        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} 
        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} 
        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} 
        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} 
        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} 
        public double d() throws IOException {return Double.parseDouble(s()) ;}
        public boolean isSpaceChar(int c) { return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; } 
        public boolean isEndOfLine(int c) { return c == '\n' || c == '\r' || c == -1; } 
    } 
    
    
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    public static void main(String args[])
    {
        Reader sc=new Reader();
        PrintWriter out=new PrintWriter(System.out);
        int n=sc.i();
        String s1=sc.s();
        String s2=sc.s();
        int pos1=-1;
        int pos2=-1;
        int arr[][][]=new int[100][100][2];
        for(int i=0;i<n;i++)
        {
            if(s1.charAt(i)!=s2.charAt(i))
            {
                if(arr[s2.charAt(i)-97][s1.charAt(i)-97][0]==1)
                {
                    pos2=i;
                    pos1=arr[s2.charAt(i)-97][s1.charAt(i)-97][1];
                    break;
                }
                arr[s1.charAt(i)-97][s2.charAt(i)-97][0]=1;
                arr[s1.charAt(i)-97][s2.charAt(i)-97][1]=i;
            }
        }
        int ham=0;
        for(int i=0;i<n;i++)
        {
            if(s1.charAt(i)!=s2.charAt(i))
            ham++;
        }
        if(pos1!=-1&&pos2!=-1)
        {
            System.out.println(ham-2);
            System.out.println(pos1+1+"" ""+(pos2+1));
            System.exit(0);
        }
        
        int arr1[][]=new int[100][2];
        int arr2[][]=new int[100][2];
        for(int i=0;i<n;i++)
        {
            if(s1.charAt(i)!=s2.charAt(i))
            {
                if(arr1[s1.charAt(i)-97][0]==1)
                {
                    pos2=i;
                    pos1=arr1[s1.charAt(i)-97][1];
                    break;
                }
                if(arr2[s2.charAt(i)-97][0]==1)
                {
                    pos2=i;
                    pos1=arr2[s2.charAt(i)-97][1];
                    break;
                }
                arr1[s2.charAt(i)-97][0]=1;
                arr1[s2.charAt(i)-97][1]=i;
                arr2[s1.charAt(i)-97][0]=1;
                arr2[s1.charAt(i)-97][1]=i;
            }
        }
        if(pos1!=-1&&pos2!=-1)
        {
            System.out.println(ham-1);
            System.out.println(pos1+1+"" ""+(pos2+1));
            System.exit(0);
        }
        System.out.println(ham);
        System.out.println(pos1+"" ""+pos2);
    }
}",CorCod,289,289,linear
"import java.util.*;
import java.io.*;
import java.math.*;

public class round569d2a {

	public static void main(String args[]) {
		FastScanner in = new FastScanner(System.in);
		int n = in.nextInt();
		int sum = 1;
		int tracker = 4;
		while (n > 1) {
			sum += tracker;
			tracker += 4;
			n--;
		}
		System.out.println(sum);

	}

	// ======================================================================================
	// =============================== Reference Code =======================================
	// ======================================================================================

	static int greatestDivisor(int n) {
		int limit = (int) Math.sqrt(n);
		int max = 1;
		for (int i = 2; i <= limit; i++) {
			if (n % i == 0) {
				max = Integer.max(max, i);
				max = Integer.max(max, n / i);
			}
		}
		return max;
	}

	// Method to return all primes smaller than or equal to 
	// n using Sieve of Eratosthenes 
	static boolean[] sieveOfEratosthenes(int n) {
		// Create a boolean array ""prime[0..n]"" and initialize 
		// all entries it as true. A value in prime[i] will 
		// finally be false if i is Not a prime, else true. 
		boolean prime[] = new boolean[n + 1];
		for (int i = 0; i <= n; i++)
			prime[i] = true;

		prime[0] = false;
		prime[1] = false;

		for (int p = 2; p * p <= n; p++) {
			// If prime[p] is not changed, then it is a prime 
			if (prime[p] == true) {
				// Update all multiples of p 
				for (int i = p * p; i <= n; i += p)
					prime[i] = false;
			}
		}

		return prime;
	}

	// Binary search for number greater than or equal to target
	// returns -1 if number not found
	private static int bin_gteq(int[] a, int key) {
		int low = 0;
		int high = a.length;
		int max_limit = high;
		while (low < high) {
			int mid = low + (high - low) / 2;
			if (a[mid] < key) {
				low = mid + 1;
			} else
				high = mid;
		}

		return high == max_limit ? -1 : high;
	}

	public static int gcd(int a, int b) {
		if (a == 0)
			return b;

		return gcd(b % a, a);
	}

	static class Tuple<X, Y> {
		public final X x;
		public final Y y;

		public Tuple(X x, Y y) {
			this.x = x;
			this.y = y;
		}

		public String toString() {
			return ""("" + x + "","" + y + "")"";
		}
	}

	static class Tuple3<X, Y, Z> {
		public final X x;
		public final Y y;
		public final Z z;

		public Tuple3(X x, Y y, Z z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public String toString() {
			return ""("" + x + "","" + y + "","" + z + "")"";
		}
	}

	static Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {
		// Base Case 
		if (a == 0) {
			x = 0;
			y = 1;
			return new Tuple3(0, 1, b);
		}

		int x1 = 1, y1 = 1; // To store results of recursive call 
		Tuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);
		int gcd = tuple.z;
		x1 = tuple.x;
		y1 = tuple.y;

		// Update x and y using results of recursive 
		// call 
		x = y1 - (b / a) * x1;
		y = x1;

		return new Tuple3(x, y, gcd);
	}

	// Returns modulo inverse of a  
	// with respect to m using extended 
	// Euclid Algorithm. Refer below post for details: 
	// https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/ 
	static int inv(int a, int m) {
		int m0 = m, t, q;
		int x0 = 0, x1 = 1;

		if (m == 1)
			return 0;

		// Apply extended Euclid Algorithm 
		while (a > 1) {
			// q is quotient 
			q = a / m;

			t = m;

			// m is remainder now, process 
			// same as euclid's algo 
			m = a % m;
			a = t;

			t = x0;

			x0 = x1 - q * x0;

			x1 = t;
		}

		// Make x1 positive 
		if (x1 < 0)
			x1 += m0;

		return x1;
	}

	// k is size of num[] and rem[]. 
	// Returns the smallest number 
	// x such that: 
	// x % num[0] = rem[0], 
	// x % num[1] = rem[1], 
	// .................. 
	// x % num[k-2] = rem[k-1] 
	// Assumption: Numbers in num[] are pairwise  
	// coprime (gcd for every pair is 1) 
	static int findMinX(int num[], int rem[], int k) {
		// Compute product of all numbers 
		int prod = 1;
		for (int i = 0; i < k; i++)
			prod *= num[i];

		// Initialize result 
		int result = 0;

		// Apply above formula 
		for (int i = 0; i < k; i++) {
			int pp = prod / num[i];
			result += rem[i] * inv(pp, num[i]) * pp;
		}

		return result % prod;
	}

	/**
	 * Source: Matt Fontaine
	 */
	static class FastScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int chars;

		public FastScanner(InputStream stream) {
			this.stream = stream;
		}

		int read() {
			if (chars == -1)
				throw new InputMismatchException();
			if (curChar >= chars) {
				curChar = 0;
				try {
					chars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (chars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}

}",CorCod,175,175,linear
"import java.io.*;
import java.lang.*;
public class CF1003E{
    public static void main(String args[]) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s = br.readLine().split("" "");
        int n = Integer.parseInt(s[0]);
        int d = Integer.parseInt(s[1]);
        int k = Integer.parseInt(s[2]);
        StringBuffer sb = new StringBuffer();
        int[] rem = new int[n];
        int[] deg = new int[n];
        int i = 0;
        if(k == 1){
            if(n <= 2){

            }else{
                System.out.println(""NO"");
                return;
            }
        }
        for(i=0;i<d;i++){
            if(i>=n-1){
                System.out.println(""NO"");
                return;
            }
            sb.append((i+1) +"" "" + (i+2)+""\n"");
            rem[i] = Math.min(i, d-i);
            deg[i]++;
            if(i+1<n)
            deg[i+1]++;
        }
        if(i<n){
            rem[i] = 0;
            deg[i] = 1;
        }
        i++;
        int j  = 0;
        for(;i<n;i++){
            //For all remaining Nodes
            while(true){
                if(j>=n){
                    System.out.println(""NO"");
                    return;
                }
                if(rem[j] > 0 && deg[j]<k){
                    deg[j]++;
                    rem[i] = rem[j] - 1;
                    sb.append((j+1)+"" ""+(i+1)+""\n"");
                    deg[i]++;
                    break;
                }else{
                    j++;
                }
            }
        }
        System.out.println(""YES"");
        System.out.println(sb);
    }
}
",CorCod,577,577,quadratic
"import java.io.*;
import java.util.*;

import static java.lang.System.out;

public class Main {

    private FastScanner scanner = new FastScanner();

    public static void main(String[] args) {
        new Main().solve();
    }

    private List<Integer>[] gr = new ArrayList[1000_000+5];
    private int dp[][] = new int[21][1000_000+5];
    private boolean used[] = new boolean[1000_000+5];

    void init(int v, int p) {
        Stack<Integer> st = new Stack<>();
        st.push(v);
        st.push(p);
        while (!st.isEmpty()) {
            p = st.pop();
            v = st.pop();
            used[v] = true;

            dp[0][v] =  p;
            for (int i = 1; i <= 20; i++) {
                if (dp[i - 1][v] != -1) {
                    dp[i][v] = dp[i - 1][dp[i - 1][v]];
                }
            }

            for (int next : gr[v]) {
                if (!used[next]) {
                    st.push(next);
                    st.push(v);
                }
            }

        }
    }


    private void solve() {
        int n = scanner.nextInt(), k = scanner.nextInt();
        boolean[] ans = new boolean[1000_000 + 5];

        for (int i = 0; i < n; i++) {
            gr[i] = new ArrayList<>();
        }

        for (int i = 0; i < n - 1; i ++) {
            int u = scanner.nextInt() - 1, v = scanner.nextInt() - 1;
            gr[u].add(v);
            gr[v].add(u);
        }

        k = n - k - 1;
        ans[n - 1] = true;

        init(n - 1 , n - 1);

        int t, d, next;
        for (int i = n - 2; i >= 0; i--) {
            t = i;
            d = 1;
            if (ans[i]) {
                continue;
            }
            for (int j = 20; j >= 0; j--){
                next = dp[j][t];
                if (next != -1 && !ans[next]) {
                    t = next;
                    d +=  1 << j;
                }
            }

            if (d <= k) {
                k -=d;
                t = i;

                while (!ans[t]) {
                    ans[t] = true;
                    t = dp[0][t];
                }
            }
            if (k == 0) {
                break;
            }
        }
        StringBuilder sb = new StringBuilder("""");
        for (int i = 0; i < n; i++) {
            if (!ans[i]) {
                sb.append(i + 1).append("" "");
            }
        }
        System.out.println(sb.toString());
    }

    class FastScanner {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public FastScanner() {
            reader = new BufferedReader(new InputStreamReader(System.in), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}",CorCod,701,701,nlogn
"import java.util.Scanner;
import java.util.Vector;

public class Main {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int a[] = new int[n];
        int b[] = new int[n];
        for (int i = 0; i < n; i++) a[i] = sc.nextInt();
        for (int i = 0; i < n; i++) b[i] = sc.nextInt();
        int c[] = new int[2 * n];
        c[0] = a[0];
        for (int i = 1; i < n; i++) {
            c[i * 2] = a[i];
            c[i * 2 - 1] = b[i];
            if (a[i] == 1 || b[i] == 1) {
                System.out.print(-1);
                System.exit(0);
            }
        }
        c[2 * n - 1] = b[0];
        if (a[0] == 1 || b[0] == 1) {
            System.out.print(-1);
            System.exit(0);
        }
        System.out.println(bin_search(c, m));
    }

    private static double bin_search(int[] c, int m) {
        double start = 0;
        double end = Integer.MAX_VALUE;
        double mid;
        while (start + 0.0000001 < end) {
            mid = (start + end) / 2;
            if (test(mid, m, c)) end = mid;
            else start = mid;
        }
        return end;
    }

    private static boolean test(double fuel, int m, int[] c) {
        for (int i = 0; i < c.length; i++) {
            fuel -= (m + fuel) / c[i];
            if (fuel < 0) {
                return false;
            }
        }
        return true;
    }
}
",CorCod,608,608,nlogn
"import java.util.*;
import java.io.*;
public class programA {
   	public static void main(String[] args)throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int d = Integer.parseInt(st.nextToken());
		int arr[] = new int[n];
		st = new StringTokenizer(br.readLine());
		for(int i=0;i<n;i++){
			arr[i] = Integer.parseInt(st.nextToken());
		}
		int s= 2;
		for(int i=0;i<n-1;i++){
			long dis = (long)2*d;
			long dis2 = Math.abs(arr[i]-arr[i+1]);
			if(dis2 == dis)s++;
			else if (dis2 > dis)s+=2;
		}
		System.out.println(s);
   		}
}",CorCod,303,303,linear
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.*;
import java.util.*;
import java.math.*;
import java.lang.*;
import java.util.PriorityQueue;
import static java.lang.Math.*;

public class solution implements Runnable {
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }
        
        public int read() {
            if (numChars==-1) 
                throw new InputMismatchException();
            
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                }
                catch (IOException e) {
                    throw new InputMismatchException();
                }
                
                if(numChars <= 0)               
                    return -1;
            }
            return buf[curChar++];
        }
     
        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            int c = read();
            
            while(isSpaceChar(c)) 
                c = read();
            
            int sgn = 1;
            
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            
            int res = 0;
            do {
                if(c<'0'||c>'9') 
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c)); 
            
            return res * sgn;
        }
        
        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
                return res * sgn;
        }
        
        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }
        
        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } 
            while (!isSpaceChar(c));
            
            return res.toString();
        }
     
        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
     
        public String next() {
            return readString();
        }
        
        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
	static int mod = (int)1e9+7;
	public static long fastexpo(long pow)
	{
		long expo = 2;
		long ans = 1;
		while(pow!=0)
		{
			if((pow&1)==1)
			{
				ans = (ans*expo)%mod;
			}
			expo = (expo*expo)%mod;
			pow = pow>>1;
		}
		return ans;
	}
	public static void main(String args[]) throws Exception {
        new Thread(null, new solution(),""Main"",1<<26).start();
    }
	public void run() {
        InputReader sc  = new InputReader(System.in);
		PrintWriter out = new PrintWriter(System.out);
		long x = sc.nextLong();
		if(x==0)
		{
			out.println(0);
			out.close();
			return;
		}
		long k = sc.nextLong();
		long a = ((fastexpo(k+1)%mod)*(x%mod))%mod;
		long b = (-1*fastexpo(k)%mod+mod)%mod;
		long ans = (a+b+1)%mod;
		out.println(ans);
		out.close();
    }
}",CorCod,923,923,logn
"
// JAVA Code for Minimum number of jumps to reach end 
class
GFG{ 

private
static
int
minJumps(
int
[] arr, 
int
n) { 

int
jumps[] = 
new
int
[n]; 
// jumps[n-1] will hold the 

// result 

int
i, j; 


if
(n == 
0
|| arr[
0
] == 
0
) 

return
Integer.MAX_VALUE; 
// if first element is 0, 

// end cannot be reached 


jumps[
0
] = 
0
; 


// Find the minimum number of jumps to reach arr[i] 

// from arr[0], and assign this value to jumps[i] 

for
(i = 
1
; i < n; i++) 

{ 

jumps[i] = Integer.MAX_VALUE; 

for
(j = 
0
; j < i; j++) 

{ 

if
(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) 

{ 

jumps[i] = Math.min(jumps[i], jumps[j] + 
1
); 

break
; 

} 

} 

} 

return
jumps[n-
1
]; 

} 

// driver program to test above function 
public
static
void
main(String[] args) { 

int
arr[] = {
1
, 
3
, 
6
, 
1
, 
0
, 
9
}; 


System.out.println(
""Minimum number of jumps to reach end is : ""
+ 

minJumps(arr,arr.length)); 

} 
} 

// This code is contributed by Arnav Kr. Mandal. ",CorCod,445,445,quadratic
"
import java.io.*;
import java.util.*;
import java.lang.*;
import static java.lang.Math.*;

// _ h _ r _ t r _
// _ t _ t _ s t _




public class TaskA implements Runnable {
    long m = (int)1e9+7;
    PrintWriter w;
    InputReader c;
    final int MAXN = (int)1e6 + 100;
    public void run() {
        c = new InputReader(System.in);
        w = new PrintWriter(System.out);

        int n = c.nextInt(), hamming_distance = 0;
        char[] s = c.next().toCharArray(), t = c.next().toCharArray();
        HashMap<Character, HashSet<Character>> replace = new HashMap<>();
        HashMap<Character, Integer> map = new HashMap<>();

        for(int i=0;i<n;++i) if(s[i] != t[i]) {
            HashSet<Character> temp;
            if(replace.containsKey(s[i])){
                temp = replace.get(s[i]);
                temp.add(t[i]);
            } else {
                temp = new HashSet<>();
                temp.add(t[i]);
            }
            map.put(s[i],i);
            replace.put(s[i], temp);
            hamming_distance++;
        }

        int l = -1, r = -1;
        boolean global_check = false;
        for(int i=0;i<n;i++) if(s[i] != t[i]) {
            if(replace.containsKey(t[i])) {
                HashSet<Character> indices = replace.get(t[i]);
                int ind = map.get(t[i]);
                l = i + 1;
                r = ind + 1;
                if (indices.contains(s[i])) {
                    hamming_distance -= 2;
                    global_check = true;
                    break;
                }
            }
            if(global_check) break;
        }

        if(!global_check && l!=-1) hamming_distance--;
        else if(global_check){
            for(int i=0;i<n;i++) {
                if(t[i] == s[l-1] && s[i] == t[l-1]){
                    r = i + 1;
                    break;
                }
            }
        }
        w.println(hamming_distance);
        w.println(l+"" ""+r);

        w.close();
    }
    static long gcd(long a, long b) {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }
    public static void sortbyColumn(int arr[][], int col){
        Arrays.sort(arr, new Comparator<int[]>()
        {
            public int compare(int[] o1, int[] o2){
                return(Integer.valueOf(o1[col]).compareTo(o2[col]));
            }
        });

    }
    public static class DJSet {
        public int[] upper;

        public DJSet(int n) {
            upper = new int[n];
            Arrays.fill(upper, -1);
        }

        public int root(int x) {
            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
        }

        public boolean equiv(int x, int y) {
            return root(x) == root(y);
        }

        public boolean union(int x, int y) {
            x = root(x);
            y = root(y);
            if (x != y) {
                if (upper[y] < upper[x]) {
                    int d = x;
                    x = y;
                    y = d;
                }
                upper[x] += upper[y];
                upper[y] = x;
            }
            return x == y;
        }
    }
    public static int[] radixSort(int[] f)    {
        int[] to = new int[f.length];
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        return f;
    }
    public void printArray(int[] a){
        for(int i=0;i<a.length;i++)
            w.print(a[i]+"" "");
        w.println();
    }
    public int[] scanArrayI(int n){
        int a[] = new int[n];
        for(int i=0;i<n;i++)
            a[i] = c.nextInt();
        return a;
    }
    public long[] scanArrayL(int n){
        long a[] = new long[n];
        for(int i=0;i<n;i++)
            a[i] = c.nextLong();
        return a;
    }
    public void printArray(long[] a){
        for(int i=0;i<a.length;i++)
            w.print(a[i]+"" "");
        w.println();
    }
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars==-1)
                throw new InputMismatchException();

            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                }
                catch (IOException e) {
                    throw new InputMismatchException();
                }

                if(numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            int c = read();

            while(isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;
            do {
                if(c<'0'||c>'9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    public static void main(String args[]) throws Exception {
        new Thread(null, new TaskA(),""TaskA"",1<<26).start();
    }
}",CorCod,324,324,linear
"
/* Dynamic programming Java implementation 
of maximum product of an increasing 
subsequence */
import
java.util.Arrays; 
import
java.util.Collections; 

class
GFG { 


// Returns product of maximum product 

// increasing subsequence. 

static
int
lis(
int
[] arr, 
int
n) 

{ 

int
[] mpis = 
new
int
[n]; 

int
max = Integer.MIN_VALUE; 


/* Initialize MPIS values */

for
(
int
i = 
0
; i < n; i++) 

mpis[i] = arr[i]; 


/* Compute optimized MPIS values 

considering every element as ending 

element of sequence */

for
(
int
i = 
1
; i < n; i++) 

for
(
int
j = 
0
; j < i; j++) 

if
(arr[i] > arr[j] && mpis[i] 

< (mpis[j] * arr[i])) 

mpis[i] = mpis[j] * arr[i]; 


/* Pick maximum of all product values 

using for loop*/

for
(
int
k = 
0
; k < mpis.length; k++) 

{ 

if
(mpis[k] > max) { 

max = mpis[k]; 

} 

} 


return
max; 

} 


// Driver program to test above function 

static
public
void
main(String[] args) 

{ 


int
[] arr = { 
3
, 
100
, 
4
, 
5
, 
150
, 
6
}; 

int
n = arr.length; 


System.out.println(lis(arr, n)); 

} 
} 

// This code is contributed by parashar. ",CorCod,552,552,quadratic
"
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class TaskA {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);

		long i = sc.nextInt();
		long goal = sc.nextLong();
//	long goal=sum;
if(i>goal) {
	i=goal;
}
		int count = 0;
		while (goal >= 0) {
			if (goal - i >= 0) {
				goal = goal - i;
				count++;
			} else
				i--;
			if (goal == 0)
				break;
		}
		out.print(count);

		out.flush();

	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}

		public Scanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public char nextChar() throws IOException {
			return next().charAt(0);
		}

		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
}
",CorCod,95,95,linear
"
// Java program to find maximum pair sum whose 
// difference is less than K 

import
java.io.*; 
import
java.util.*; 

class
GFG { 


// method to return maximum sum we can get by 

// finding less than K difference pair 

static
int
maxSumPairWithDifferenceLessThanK(
int
arr[], 

int
N, 
int
K) 

{ 


// Sort input array in ascending order. 

Arrays.sort(arr); 


// dp[i] denotes the maximum disjoint pair sum 

// we can achieve using first i elements 

int
dp[] = 
new
int
[N]; 


// if no element then dp value will be 0 

dp[
0
] = 
0
; 


for
(
int
i = 
1
; i < N; i++) 

{ 

// first give previous value to dp[i] i.e. 

// no pairing with (i-1)th element 

dp[i] = dp[i-
1
]; 


// if current and previous element can form a pair 

if
(arr[i] - arr[i-
1
] < K) 

{ 


// update dp[i] by choosing maximum between 

// pairing and not pairing 

if
(i >= 
2
) 

dp[i] = Math.max(dp[i], dp[i-
2
] + arr[i] + 

arr[i-
1
]); 

else

dp[i] = Math.max(dp[i], arr[i] + arr[i-
1
]); 

} 

} 


// last index will have the result 

return
dp[N - 
1
]; 

} 


// Driver code to test above methods 

public
static
void
main (String[] args) { 


int
arr[] = {
3
, 
5
, 
10
, 
15
, 
17
, 
12
, 
9
}; 

int
N = arr.length; 

int
K = 
4
; 


System.out.println ( maxSumPairWithDifferenceLessThanK( 

arr, N, K)); 


} 
} 

//This code is contributed by vt_m. ",CorCod,644,644,nlogn
"import java.io.*;

public class n5D
{
    public static void main(String[] args)
    {
        double a = 0, v = 0, l = 0, d = 0, w = 0;
        try
        {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String[] str = br.readLine().split("" "");
            a = Double.parseDouble(str[0]);
            v = Double.parseDouble(str[1]);
            str = br.readLine().split("" "");
            l = Double.parseDouble(str[0]);
            d = Double.parseDouble(str[1]);
            w = Double.parseDouble(str[2]);
        }
        catch(Exception e)
        {
            System.out.println(e);
        }

        double t1, t2, t3, t4, t5, t, D = 0;
        
        if (w > v) w = v;
        t2 = d / v - v / a + w * w / 2 / a / v;
        if (t2 >= 0)
        {
            t1 = v / a; 
            t3 = t1 - w / a;
        }
        else
        {
            if (Math.sqrt(2 * d / a) > (w / a))
            {
                t1 = Math.sqrt((2 * a * d + w * w) / (a * a * 2));
                t3 = t1 - w / a;
            }
            else
            {
                t1 = Math.sqrt(2 * d / a);
                t3 = 0;
            }
            t2 = 0;
        }
        t5 = (l - d - v * v / 2 / a + a * (t1 - t3) * (t1 - t3) / 2) / v;
        if (t5 >= 0) t4 = v / a - (t1 - t3);
        else
        {
            t5 = 0;
            t4 = -t1 + t3 + Math.sqrt((t1 - t3) * (t1 - t3) + 2 * (l - d) / a);
        }
        t = t1 + t2 + t3 + t4 + t5;
        System.out.println(t);
        //System.out.println(t1 + "" "" + t2 + "" "" + t3 + "" "" + t4 + "" "" + t5);
    }
}",CorCod,744,744,constant
"
// JAVA Code for Newman-Conway Sequence 
import
java.util.*; 

class
GFG { 


// Function to find the n-th element 

static
int
sequence(
int
n) 

{ 

// Declare array to store sequence 

int
f[] = 
new
int
[n + 
1
]; 

f[
0
] = 
0
; 

f[
1
] = 
1
; 

f[
2
] = 
1
; 


int
i; 


for
(i = 
3
; i <= n; i++) 

f[i] = f[f[i - 
1
]] + 

f[i - f[i - 
1
]]; 


return
f[n]; 

} 


/* Driver program to test above function */

public
static
void
main(String[] args) 

{ 

int
n = 
10
; 

System.out.println(sequence(n)); 


} 
} 

// This code is contributed by Arnav Kr. Mandal. ",CorCod,218,218,linear
"
// Java program to Split the array and 
// add the first part to the end 
class
Geeks 
{ 

/* Function to reverse arr[] from index start to end*/
static
void
rvereseArray(
int
arr[], 
int
start, 
int
end) 
{ 

while
(start < end) { 

int
temp = arr[start]; 

arr[start] = arr[end]; 

arr[end] = temp; 

start++; 

end--; 

} 
} 

// Function to print an array 
static
void
printArray(
int
arr[], 
int
size) 
{ 

for
(
int
i = 
0
; i < size; i++) 

System.out.print(arr[i] +
"" ""
); 
} 

/* Function to left rotate arr[] of size n by k */
static
void
splitArr(
int
arr[], 
int
k, 
int
n) 
{ 

rvereseArray(arr, 
0
, n - 
1
); 

rvereseArray(arr, 
0
, n - k - 
1
); 

rvereseArray(arr, n - k, n - 
1
); 
} 

/* Driver program to test above functions */
public
static
void
main(String args[]) 
{ 

int
arr[] = { 
12
, 
10
, 
5
, 
6
, 
52
, 
36
}; 

int
n = arr.length; 

int
k = 
2
; 


// Function calling 

splitArr(arr, k, n); 

printArray(arr, n); 

} 

} 

// This code is contributed by ankita_saini. ",CorCod,75,75,linear
"import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;
//BigInteger A;
//A= BigInteger.valueOf(54);
//ArrayList<Integer> a=new ArrayList<>();
//TreeSet<Integer> ts=new TreeSet<>();
//HashMap<Integer,Integer> hm=new HashMap<>();
public final class Cf
{
    public static void main(String[]args)
    {
        FastReader ob=new FastReader();
        //int t=ob.nextInt();
        //while(t-->0)
        {
            int n=ob.nextInt();
            int k=ob.nextInt();
            int a[]=new int[n];
            for(int i=0;i<n;i++)
            a[i]=ob.nextInt();
            int x=a[n-1]-a[0];
            ArrayList<Integer> b=new ArrayList<>();
            for(int i=0;i<n-1;i++)
            b.add(-a[i+1]+a[i]);
            Collections.sort(b);
            for(int i=0;i<k-1;i++)
            x+=b.get(i);
            System.out.println(x);
        }
    }
}
class FastReader {
    BufferedReader br;
    StringTokenizer st;
    public FastReader() {
        br = new BufferedReader(new InputStreamReader(System.in));
    }

    public String next() {
        while (st == null || !st.hasMoreElements()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e)  {
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }
    public String nextLine()
    {
        String s="""";
        try {
        s=br.readLine();
        } catch (IOException e)  {
                e.printStackTrace();
            }
        return s;
    }
    public int nextInt() {
        return Integer.parseInt(next());
    }
    public long nextLong() {
        return Long.parseLong(next());
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
}",CorCod,686,686,nlogn
"
import
java.util.*; 
import
java.lang.*; 
class
Main 
{ 

static
void
minAbsSumPair(
int
arr[], 
int
n) 

{ 

// Variables to keep track of current sum and minimum sum 

int
sum, min_sum = 
999999
; 


// left and right index variables 

int
l = 
0
, r = n-
1
; 


// variable to keep track of the left and right pair for min_sum 

int
min_l = l, min_r = n-
1
; 


/* Array should have at least two elements*/

if
(n < 
2
) 

{ 

System.out.println(
""Invalid Input""
); 

return
; 

} 


/* Sort the elements */

sort(arr, l, r); 


while
(l < r) 

{ 

sum = arr[l] + arr[r]; 


/*If abs(sum) is less then update the result items*/

if
(Math.abs(sum) < Math.abs(min_sum)) 

{ 

min_sum = sum; 

min_l = l; 

min_r = r; 

} 

if
(sum < 
0
) 

l++; 

else

r--; 

} 



System.out.println(
"" The two elements whose ""
+ 

""sum is minimum are ""
+ 

arr[min_l]+ 
"" and ""
+arr[min_r]); 

} 


// main function 

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
60
, -
10
, 
70
, -
80
, 
85
}; 

int
n = arr.length; 

minAbsSumPair(arr, n); 

} 


/* Functions for QuickSort */


/* This function takes last element as pivot, 

places the pivot element at its correct 

position in sorted array, and places all 

smaller (smaller than pivot) to left of 

pivot and all greater elements to right 

of pivot */

static
int
partition(
int
arr[], 
int
low, 
int
high) 

{ 

int
pivot = arr[high]; 

int
i = (low-
1
); 
// index of smaller element 

for
(
int
j=low; j<high; j++) 

{ 

// If current element is smaller than or 

// equal to pivot 

if
(arr[j] <= pivot) 

{ 

i++; 


// swap arr[i] and arr[j] 

int
temp = arr[i]; 

arr[i] = arr[j]; 

arr[j] = temp; 

} 

} 


// swap arr[i+1] and arr[high] (or pivot) 

int
temp = arr[i+
1
]; 

arr[i+
1
] = arr[high]; 

arr[high] = temp; 


return
i+
1
; 

} 



/* The main function that implements QuickSort() 

arr[] --> Array to be sorted, 

low --> Starting index, 

high --> Ending index */

static
void
sort(
int
arr[], 
int
low, 
int
high) 

{ 

if
(low < high) 

{ 

/* pi is partitioning index, arr[pi] is 

now at right place */

int
pi = partition(arr, low, high); 


// Recursively sort elements before 

// partition and after partition 

sort(arr, low, pi-
1
); 

sort(arr, pi+
1
, high); 

} 

} 
} ",CorCod,711,711,nlogn
"import com.sun.org.apache.xalan.internal.xslt.Process;

import java.io.*;
import java.util.*;

public class main {
    public static void main(String[] args) throws IOException {
        init();//""prizes.in"", ""prizes.out"");
        int x = nextInt();
        int y = nextInt();
        int z = nextInt();
        int t1 = nextInt();
        int t2 = nextInt();
        int t3 = nextInt();
        int lift = Math.abs(z - x) * t2 + 2 * t3 + Math.abs(x - y) * t2 + t3;
        int stair = Math.abs(x - y) * t1;
        if (lift <= stair) {
            pw.print(""YES"");
        } else {
            pw.print(""NO"");
        }
        pw.close();
    }

    static StringTokenizer st;
    static BufferedReader sc;
    static PrintWriter pw;

    static String next() throws IOException {
        while (st == null || !st.hasMoreElements()) {
            st = new StringTokenizer(sc.readLine());
        }
        return st.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    static long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    static void init(String in, String out) throws IOException {
        sc = new BufferedReader(new FileReader(in));
        pw = new PrintWriter(out);
    }

    static void init() {
        sc = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(System.out);
    }
}

class DSU {
    int parent[];
    public DSU(int n){
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    int get(int i){
        if (i == parent[i]){
            return i;
        }
        int p = get(parent[i]);
        parent[i] = p;
        return p;
    }

    boolean union(int a, int b){
        a = get(a);
        b = get(b);
        if (a == b) return false;
        parent[a] = b;
        return true;
    }
}",CorCod,784,784,constant
"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		int s = sc.nextInt();
		int[] f = new int[n];
		int[] t = new int[n];
		for (int i = 0; i < n; i++) {
			f[i] = sc.nextInt();
			t[i] = sc.nextInt();
		}
		System.out.println(solve(f, t, s));

		sc.close();
	}

	static int solve(int[] f, int[] t, int s) {
		int[] maxTimes = new int[s + 1];
		for (int i = 0; i < f.length; i++) {
			maxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);
		}

		int time = 0;
		for (int i = s; i > 0; i--) {
			time = Math.max(time, maxTimes[i]);

			time++;
		}
		return time;
	}
}
",CorCod,343,343,linear
"import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;
import java.util.stream.IntStream;

public class B {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));

        Solver solver = new Solver();
        solver.solve(in, out);
        out.close();
    }

    static class Solver {
        int n;
        int n2;
        InputReader in;
        PrintWriter out;

        public void solve(InputReader in, PrintWriter out) {
            this.in = in;
            this.out = out;
            n = in.readInt();
            n2 = n/2;

            int res = find();
            out.print(""! "");
            out.println(res);
        }

        public int find() {
            if (n%4 != 0) return -1;
            int c = compare(0);
            if (c == 0) return 1;
            int s = 1;
            int f = n2-1;
            if (c > 0) {
                s = n2+1;
                f = n-1;
            }
            while (s <= f) {
                int m = (s+f)/2;
                int v = compare(m);
                if (v == 0) return m+1;
                else if (v < 0) s = m+1;
                else f = m-1;
            }
            return -1;
        }

        public int compare(int z) {
            out.print(""? "");
            out.println(z+1);
            out.flush();
            int r1 = in.readInt();
            out.print(""? "");
            out.println((z+n2)%n+1);
            out.flush();
            int r2 = in.readInt();
            return r1-r2;
        }

    }

    static class InputReader {
        private BufferedReader reader;
        private StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            this.reader = new BufferedReader(new InputStreamReader(stream));
        }

        public String read() {
            try {
                if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                    tokenizer = new StringTokenizer(reader.readLine());
                }
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
            return tokenizer.nextToken();
        }

        public int readInt() {
            return Integer.parseInt(read());
        }

        public long readLong() {
            return Long.parseLong(read());
        }

        public void readIntArrays(int[]... arrays) {
            for (int i = 0; i < arrays[0].length; i++) {
                for (int j = 0; j < arrays.length; j++) {
                    arrays[j][i] = readInt();
                }
            }
        }
    }

}",CorCod,915,915,logn
"import java.util.*;
import java.util.Scanner;
public class task1{
    public static void main(String args[]){
        Scanner in = new Scanner(System.in);
        int n=in.nextInt();
        int pos=in.nextInt();
        int l=in.nextInt();
        int r=in.nextInt();
        boolean b=false;
        boolean c=true;
        if(l==1&&r==n){
            c=false;
            System.out.println(0);
        }
        if(c){
            if(l==1){
            if(pos<r){
                System.out.println(r-pos+1);
                b=true;}
            else{
                System.out.println(pos-r+1);
                b=true;
            }
        }
        if(r==n){
            if(pos>l){
                System.out.println(pos-l+1);
                b=true;}
            else{
                System.out.println(l-pos+1);
                b=true;
            }
        }
        }
        if(b==false&&c){
            if(pos<l){
            System.out.println(l-pos+1+r-l+1);
        }
        else if(pos>r){
            System.out.println(pos-r+1+r-l+1);
        }
        else{
            if(((pos-l)<(r-pos))){
                System.out.println(pos-l+1+r-l+1);
                
            }
            
            else if((pos-l)>(r-pos)){
                System.out.println(r-pos+1+r-l+1);
                
            }
            else{
                System.out.println((r-pos)*3+2);
                
            }
        }
        }
        
    }
}",CorCod,762,762,constant
"import java.util.*;
import static java.lang.Math.*;
import java.io.*;

public class SolutionB {
       
      public static void main(String args[])throws IOException{
              Scanner sc = new Scanner(System.in);
              long a[] = new long[14];
              for(int i = 0; i < 14; i++)
                     a[i] = sc.nextLong();
              long cpy[] = new long[14];
              long max = 0;
              for(int i = 0; i < 14; i++){
                     if(a[i] == 0)continue;
                     long score = 0;
                     long curr = a[i];
                     for(int j = 0; j < 14; j++)
                            cpy[j] = a[j];
                     cpy[i] = 0;
                     long amnt = curr / 14l;
                     for(int j = 0; j < 14; j++){
                            cpy[j] += amnt;
                     }
                     amnt = curr % 14;
                     for(int j = i + 1; j < i + 1 + amnt; j++){
                            cpy[j % 14]++;
                     }
                     for(int j = 0; j < 14; j++){
                            if(cpy[j] % 2 == 0)
                                   score += cpy[j];
                     }
                     max = Math.max(max, score);
              }
              System.out.println(max);
      }
}",CorCod,751,751,constant
"import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class problem2 {
    static class tile implements Comparable<tile> {
        int number;
        int suit;

        public int compareTo(tile b){

            return number - b.number;
        }

    }
    public static void main(String[] args) {


        Scanner sc = new Scanner(System.in);
        String line = sc.nextLine();
        String[] parts = line.split("" "");

        tile[] tiles = new tile[3];
        for(int i = 0; i < 3; i++){

            tiles[i] = new tile();
            tiles[i].number = parts[i].charAt(0) - '0';
            if(parts[i].substring(1,2).equals(""s""))tiles[i].suit = 1;
            if(parts[i].substring(1,2).equals(""m""))tiles[i].suit = 2;
            if(parts[i].substring(1,2).equals(""p""))tiles[i].suit = 3;
            //System.out.println(tiles[i].number + "" ""+ tiles[i].suit);
        }
        Arrays.sort(tiles);

        int[][] tilesObtained = new int[10][4];
        int[][] stairCases = new int[10][4];
        int[][] stairCases2 = new int[10][4];
        for(int i = 0; i < 3; i++){
            int currNumber = tiles[i].number;
            int currSuit = tiles[i].suit;

            tilesObtained[currNumber][currSuit]++;
            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber-1][currSuit];
            if(currNumber != 1){
                if(stairCases2[currNumber-2][currSuit] != 0){
                    stairCases2[currNumber][currSuit] = 2;
                }
                else{
                    stairCases2[currNumber][currSuit] = 1;
                }
            }
            else{
                stairCases2[currNumber][currSuit]++;
            }


        }
        int best = 3;

        for(int i = 1; i <= 9; i++){

            for(int j = 1; j <= 3; j++){

                best = Math.min(best, 3 - tilesObtained[i][j]);
                best = Math.min(best, 3 - stairCases[i][j]);
                best = Math.min(best, 3- stairCases2[i][j]);
                if(best <0)best = 0;
            }
        }
        System.out.println(best);


    }
}",CorCod,831,831,constant
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.io.OutputStreamWriter;
import java.util.NoSuchElementException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Iterator;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Writer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author aryssoncf
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            try {
                int n = in.readInt();
                int[] x = new int[n], w = new int[n];
                in.readIntArrays(x, w);
                int[] begin = new int[n], end = new int[n];
                Arrays.setAll(begin, i -> x[i] - w[i]);
                Arrays.setAll(end, i -> x[i] + w[i]);
                int m = ArrayUtils.compress(begin, end).length;
                int[] dp = new int[m + 1], order = ArrayUtils.order(end);
                int idx = 0;
                for (int i = 0; i < m; i++) {
                    if (i > 0) {
                        dp[i] = dp[i - 1];
                    }
                    while (idx < n && end[order[idx]] == i) {
                        dp[i] = Math.max(dp[i], dp[begin[order[idx]]] + 1);
                        idx++;
                    }
                }
                int res = dp[m - 1];
                out.printLine(res);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    static class Sorter {
        private static final int INSERTION_THRESHOLD = 16;

        private Sorter() {
        }

        public static void sort(IntList list, IntComparator comparator) {
            quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,
                    comparator);
        }

        private static void quickSort(IntList list, int from, int to, int remaining, IntComparator comparator) {
            if (to - from < INSERTION_THRESHOLD) {
                insertionSort(list, from, to, comparator);
                return;
            }
            if (remaining == 0) {
                heapSort(list, from, to, comparator);
                return;
            }
            remaining--;
            int pivotIndex = (from + to) >> 1;
            int pivot = list.get(pivotIndex);
            list.swap(pivotIndex, to);
            int storeIndex = from;
            int equalIndex = to;
            for (int i = from; i < equalIndex; i++) {
                int value = comparator.compare(list.get(i), pivot);
                if (value < 0) {
                    list.swap(storeIndex++, i);
                } else if (value == 0) {
                    list.swap(--equalIndex, i--);
                }
            }
            quickSort(list, from, storeIndex - 1, remaining, comparator);
            for (int i = equalIndex; i <= to; i++) {
                list.swap(storeIndex++, i);
            }
            quickSort(list, storeIndex, to, remaining, comparator);
        }

        private static void heapSort(IntList list, int from, int to, IntComparator comparator) {
            for (int i = (to + from - 1) >> 1; i >= from; i--) {
                siftDown(list, i, to, comparator, from);
            }
            for (int i = to; i > from; i--) {
                list.swap(from, i);
                siftDown(list, from, i - 1, comparator, from);
            }
        }

        private static void siftDown(IntList list, int start, int end, IntComparator comparator, int delta) {
            int value = list.get(start);
            while (true) {
                int child = ((start - delta) << 1) + 1 + delta;
                if (child > end) {
                    return;
                }
                int childValue = list.get(child);
                if (child + 1 <= end) {
                    int otherValue = list.get(child + 1);
                    if (comparator.compare(otherValue, childValue) > 0) {
                        child++;
                        childValue = otherValue;
                    }
                }
                if (comparator.compare(value, childValue) >= 0) {
                    return;
                }
                list.swap(start, child);
                start = child;
            }
        }

        private static void insertionSort(IntList list, int from, int to, IntComparator comparator) {
            for (int i = from + 1; i <= to; i++) {
                int value = list.get(i);
                for (int j = i - 1; j >= from; j--) {
                    if (comparator.compare(list.get(j), value) <= 0) {
                        break;
                    }
                    list.swap(j, j + 1);
                }
            }
        }

    }

    static interface IntList extends IntReversableCollection {
        public abstract int get(int index);

        public abstract void set(int index, int value);

        public abstract void addAt(int index, int value);

        public abstract void removeAt(int index);

        default public void swap(int first, int second) {
            if (first == second) {
                return;
            }
            int temp = get(first);
            set(first, get(second));
            set(second, temp);
        }

        default public IntIterator intIterator() {
            return new IntIterator() {
                private int at;
                private boolean removed;

                public int value() {
                    if (removed) {
                        throw new IllegalStateException();
                    }
                    return get(at);
                }

                public boolean advance() {
                    at++;
                    removed = false;
                    return isValid();
                }

                public boolean isValid() {
                    return !removed && at < size();
                }

                public void remove() {
                    removeAt(at);
                    at--;
                    removed = true;
                }
            };
        }

        default public void add(int value) {
            addAt(size(), value);
        }

        default public IntList sort(IntComparator comparator) {
            Sorter.sort(this, comparator);
            return this;
        }

        default IntList unique() {
            int last = Integer.MIN_VALUE;
            IntList result = new IntArrayList();
            int size = size();
            for (int i = 0; i < size; i++) {
                int current = get(i);
                if (current != last) {
                    result.add(current);
                    last = current;
                }
            }
            return result;
        }

        default public IntList subList(final int from, final int to) {
            return new IntList() {
                private final int shift;
                private final int size;

                {
                    if (from < 0 || from > to || to > IntList.this.size()) {
                        throw new IndexOutOfBoundsException(""from = "" + from + "", to = "" + to + "", size = "" + size());
                    }
                    shift = from;
                    size = to - from;
                }

                public int size() {
                    return size;
                }

                public int get(int at) {
                    if (at < 0 || at >= size) {
                        throw new IndexOutOfBoundsException(""at = "" + at + "", size = "" + size());
                    }
                    return IntList.this.get(at + shift);
                }

                public void addAt(int index, int value) {
                    throw new UnsupportedOperationException();
                }

                public void removeAt(int index) {
                    throw new UnsupportedOperationException();
                }

                public void set(int at, int value) {
                    if (at < 0 || at >= size) {
                        throw new IndexOutOfBoundsException(""at = "" + at + "", size = "" + size());
                    }
                    IntList.this.set(at + shift, value);
                }

                public IntList compute() {
                    return new IntArrayList(this);
                }
            };
        }

    }

    static interface IntComparator {
        IntComparator DEFAULT = Integer::compare;

        int compare(int first, int second);

    }

    static class Range {
        public static IntList range(int from, int to) {
            int[] result = new int[Math.abs(from - to)];
            int current = from;
            if (from <= to) {
                for (int i = 0; i < result.length; i++) {
                    result[i] = current++;
                }
            } else {
                for (int i = 0; i < result.length; i++) {
                    result[i] = current--;
                }
            }
            return new IntArray(result);
        }

    }

    static interface IntReversableCollection extends IntCollection {
    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void printLine(int i) {
            writer.println(i);
        }

    }

    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {
        IntIterator intIterator();

        default Iterator<Integer> iterator() {
            return new Iterator<Integer>() {
                private IntIterator it = intIterator();

                public boolean hasNext() {
                    return it.isValid();
                }

                public Integer next() {
                    int result = it.value();
                    it.advance();
                    return result;
                }
            };
        }

        default int compareTo(IntStream c) {
            IntIterator it = intIterator();
            IntIterator jt = c.intIterator();
            while (it.isValid() && jt.isValid()) {
                int i = it.value();
                int j = jt.value();
                if (i < j) {
                    return -1;
                } else if (i > j) {
                    return 1;
                }
                it.advance();
                jt.advance();
            }
            if (it.isValid()) {
                return 1;
            }
            if (jt.isValid()) {
                return -1;
            }
            return 0;
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public void readIntArrays(int[]... arrays) {
            for (int i = 0; i < arrays[0].length; i++) {
                for (int j = 0; j < arrays.length; j++) {
                    arrays[j][i] = readInt();
                }
            }
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            boolean isSpaceChar(int ch);

        }

    }

    static interface IntCollection extends IntStream {
        public int size();

        default public void add(int value) {
            throw new UnsupportedOperationException();
        }

        default public int[] toArray() {
            int size = size();
            int[] array = new int[size];
            int i = 0;
            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
                array[i++] = it.value();
            }
            return array;
        }

        default public IntCollection addAll(IntStream values) {
            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {
                add(it.value());
            }
            return this;
        }

    }

    static class IntArray extends IntAbstractStream implements IntList {
        private int[] data;

        public IntArray(int[] arr) {
            data = arr;
        }

        public int size() {
            return data.length;
        }

        public int get(int at) {
            return data[at];
        }

        public void addAt(int index, int value) {
            throw new UnsupportedOperationException();
        }

        public void removeAt(int index) {
            throw new UnsupportedOperationException();
        }

        public void set(int index, int value) {
            data[index] = value;
        }

    }

    static class ArrayUtils {
        public static int[] range(int from, int to) {
            return Range.range(from, to).toArray();
        }

        public static int[] createOrder(int size) {
            return range(0, size);
        }

        public static int[] sort(int[] array, IntComparator comparator) {
            return sort(array, 0, array.length, comparator);
        }

        public static int[] sort(int[] array, int from, int to, IntComparator comparator) {
            if (from == 0 && to == array.length) {
                new IntArray(array).sort(comparator);
            } else {
                new IntArray(array).subList(from, to).sort(comparator);
            }
            return array;
        }

        public static int[] order(final int[] array) {
            return sort(createOrder(array.length), (first, second) -> Integer.compare(array[first], array[second]));
        }

        public static int[] unique(int[] array) {
            return new IntArray(array).unique().toArray();
        }

        public static int[] compress(int[]... arrays) {
            int totalLength = 0;
            for (int[] array : arrays) {
                totalLength += array.length;
            }
            int[] all = new int[totalLength];
            int delta = 0;
            for (int[] array : arrays) {
                System.arraycopy(array, 0, all, delta, array.length);
                delta += array.length;
            }
            sort(all, IntComparator.DEFAULT);
            all = unique(all);
            for (int[] array : arrays) {
                for (int i = 0; i < array.length; i++) {
                    array[i] = Arrays.binarySearch(all, array[i]);
                }
            }
            return all;
        }

    }

    static interface IntIterator {
        public int value() throws NoSuchElementException;

        public boolean advance();

        public boolean isValid();

    }

    static class IntArrayList extends IntAbstractStream implements IntList {
        private int size;
        private int[] data;

        public IntArrayList() {
            this(3);
        }

        public IntArrayList(int capacity) {
            data = new int[capacity];
        }

        public IntArrayList(IntCollection c) {
            this(c.size());
            addAll(c);
        }

        public IntArrayList(IntStream c) {
            this();
            if (c instanceof IntCollection) {
                ensureCapacity(((IntCollection) c).size());
            }
            addAll(c);
        }

        public IntArrayList(IntArrayList c) {
            size = c.size();
            data = c.data.clone();
        }

        public IntArrayList(int[] arr) {
            size = arr.length;
            data = arr.clone();
        }

        public int size() {
            return size;
        }

        public int get(int at) {
            if (at >= size) {
                throw new IndexOutOfBoundsException(""at = "" + at + "", size = "" + size);
            }
            return data[at];
        }

        private void ensureCapacity(int capacity) {
            if (data.length >= capacity) {
                return;
            }
            capacity = Math.max(2 * data.length, capacity);
            data = Arrays.copyOf(data, capacity);
        }

        public void addAt(int index, int value) {
            ensureCapacity(size + 1);
            if (index > size || index < 0) {
                throw new IndexOutOfBoundsException(""at = "" + index + "", size = "" + size);
            }
            if (index != size) {
                System.arraycopy(data, index, data, index + 1, size - index);
            }
            data[index] = value;
            size++;
        }

        public void removeAt(int index) {
            if (index >= size || index < 0) {
                throw new IndexOutOfBoundsException(""at = "" + index + "", size = "" + size);
            }
            if (index != size - 1) {
                System.arraycopy(data, index + 1, data, index, size - index - 1);
            }
            size--;
        }

        public void set(int index, int value) {
            if (index >= size) {
                throw new IndexOutOfBoundsException(""at = "" + index + "", size = "" + size);
            }
            data[index] = value;
        }

        public int[] toArray() {
            return Arrays.copyOf(data, size);
        }

    }

    static abstract class IntAbstractStream implements IntStream {
        public String toString() {
            StringBuilder builder = new StringBuilder();
            boolean first = true;
            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
                if (first) {
                    first = false;
                } else {
                    builder.append(' ');
                }
                builder.append(it.value());
            }
            return builder.toString();
        }

        public boolean equals(Object o) {
            if (!(o instanceof IntStream)) {
                return false;
            }
            IntStream c = (IntStream) o;
            IntIterator it = intIterator();
            IntIterator jt = c.intIterator();
            while (it.isValid() && jt.isValid()) {
                if (it.value() != jt.value()) {
                    return false;
                }
                it.advance();
                jt.advance();
            }
            return !it.isValid() && !jt.isValid();
        }

        public int hashCode() {
            int result = 0;
            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
                result *= 31;
                result += it.value();
            }
            return result;
        }

    }
}

",CorCod,654,654,nlogn
"import java.util.*;
import java.io.*;

public class CodeForces
{
	public static void main(String[] args)throws IOException
	{
		Scanner sc=new Scanner(System.in);
		//Scanner sc=new Scanner(new File(""ip.txt""));
		
		int t,i,j,n,k,x,y,z,min1,min2,min3,arr1[],arr2[],arr3[];
		String s;
		char[] s1,s2,s3;

		t=sc.nextInt();
		
		while(t-->0)
		{
			n=sc.nextInt();
			k=sc.nextInt();
			s=sc.next();
			s1=new char[n];
			s2=new char[n];
			s3=new char[n];
			
			for(i=0;i<n;i++)
			{
				if(i%3==0)
				{
					s1[i]='R';
					s2[i]='G';
					s3[i]='B';
				}
				if(i%3==1)
				{
					s1[i]='G';
					s2[i]='B';
					s3[i]='R';
				}
				if(i%3==2)
				{
					s1[i]='B';
					s2[i]='R';
					s3[i]='G';
				}
			}
			arr1=new int[n];
			arr2=new int[n];
			arr3=new int[n];

			for(i=0;i<n;i++)
			{
				if(s.charAt(i)!=s1[i])
					arr1[i]=1;
				if(s.charAt(i)!=s2[i])
					arr2[i]=1;
				if(s.charAt(i)!=s3[i])
					arr3[i]=1;
			}
			for(i=1;i<n;i++)
			{
				arr1[i]=arr1[i]+arr1[i-1];
				arr2[i]=arr2[i]+arr2[i-1];
				arr3[i]=arr3[i]+arr3[i-1];
			}
			
			min1=arr1[k-1];
			min2=arr2[k-1];
			min3=arr3[k-1];

			for(i=k;i<n;i++)
			{
				if(min1>(arr1[i]-arr1[i-k]))
					min1=(arr1[i]-arr1[i-k]);
				if(min2>(arr2[i]-arr2[i-k]))
					min2=(arr2[i]-arr2[i-k]);
				if(min3>(arr3[i]-arr3[i-k]))
					min3=(arr3[i]-arr3[i-k]);
			}
			System.out.println(Math.min(min1,Math.min(min2,min3)));
		}
	}
}",CorCod,398,398,quadratic
"
// Java implementation to find the character in 
// first string that is present at minimum index 
// in second string 

import
java.util.HashMap; 

public
class
GFG 
{ 

// method to find the minimum index character 

static
void
printMinIndexChar(String str, String patt) 

{ 

// map to store the first index of each character of 'str' 

HashMap<Character, Integer> hm = 
new
HashMap<>(); 


// to store the index of character having 

// minimum index 

int
minIndex = Integer.MAX_VALUE; 


// lengths of the two strings 

int
m = str.length(); 

int
n = patt.length(); 


// store the first index of each character of 'str' 

for
(
int
i = 
0
; i < m; i++) 

if
(!hm.containsKey(str.charAt(i))) 

hm.put(str.charAt(i),i); 


// traverse the string 'patt' 

for
(
int
i = 
0
; i < n; i++) 

// if patt[i] is found in 'um', check if 

// it has the minimum index or not accordingly 

// update 'minIndex' 

if
(hm.containsKey(patt.charAt(i)) && 

hm.get(patt.charAt(i)) < minIndex) 

minIndex = hm.get(patt.charAt(i)); 


// print the minimum index character 

if
(minIndex != Integer.MAX_VALUE) 

System.out.println(
""Minimum Index Character = ""
+ 

str.charAt(minIndex)); 


// if no character of 'patt' is present in 'str' 

else

System.out.println(
""No character present""
); 

} 


// Driver Method 

public
static
void
main(String[] args) 

{ 

String str = 
""geeksforgeeks""
; 

String patt = 
""set""
; 

printMinIndexChar(str, patt); 

} 
} ",CorCod,189,189,linear
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Arrays;

public class Main {
	static StreamTokenizer st=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
	public static void main(String[] args) {
		int n=nextInt();
		int m=nextInt();
		long b[]=new long[n];
		long g[]=new long[m];
		for(int i=0;i<n;i++)
			b[i]=nextInt();
		for(int i=0;i<m;i++)
			g[i]=nextInt();
		Arrays.sort(b);
		Arrays.sort(g);
		if(b[n-1]>g[0])
			System.out.println(""-1"");
		else if(b[n-1]==g[0]){
			long sum=0;
			for(int i=0;i<m;i++)
				sum+=g[i];
			for(int i=0;i<n-1;i++){
				sum+=(m*b[i]);
			}
			System.out.println(sum);
		}else{
			long sum=0;
			for(int i=0;i<m;i++)
				sum+=g[i];
			sum+=b[n-1];
			sum+=(b[n-2]*(m-1));
			for(int i=0;i<n-2;i++){
				sum+=(m*b[i]);
			}
			System.out.println(sum);
		}
	}
	static int nextInt(){
		try {
			st.nextToken();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return (int)st.nval;
	}
}
",CorCod,651,651,nlogn
"
// Java code to demonstrate Difference Array 
class
GFG { 


// Creates a diff array D[] for A[] and returns 

// it after filling initial values. 

static
void
initializeDiffArray(
int
A[], 
int
D[]) 

{ 


int
n = A.length; 


D[
0
] = A[
0
]; 

D[n] = 
0
; 

for
(
int
i = 
1
; i < n; i++) 

D[i] = A[i] - A[i - 
1
]; 

} 


// Does range update 

static
void
update(
int
D[], 
int
l, 
int
r, 
int
x) 

{ 

D[l] += x; 

D[r + 
1
] -= x; 

} 


// Prints updated Array 

static
int
printArray(
int
A[], 
int
D[]) 

{ 

for
(
int
i = 
0
; i < A.length; i++) { 


if
(i == 
0
) 

A[i] = D[i]; 


// Note that A[0] or D[0] decides 

// values of rest of the elements. 

else

A[i] = D[i] + A[i - 
1
]; 


System.out.print(A[i] + 
"" ""
); 

} 


System.out.println(); 


return
0
; 

} 


// Driver Code 

public
static
void
main(String[] args) 

{ 

// Array to be updated 

int
A[] = { 
10
, 
5
, 
20
, 
40
}; 

int
n = A.length; 

// Create and fill difference Array 

// We use one extra space because 

// update(l, r, x) updates D[r+1] 

int
D[] = 
new
int
[n + 
1
]; 

initializeDiffArray(A, D); 


// After below update(l, r, x), the 

// elements should become 20, 15, 20, 40 

update(D, 
0
, 
1
, 
10
); 

printArray(A, D); 


// After below updates, the 

// array should become 30, 35, 70, 60 

update(D, 
1
, 
3
, 
20
); 

update(D, 
2
, 
2
, 
30
); 


printArray(A, D); 

} 
} 

// This code is contributed by Anant Agarwal. ",CorCod,174,174,linear
"
import java.util.Scanner;

public class TaxistsnLyft {
	public static void main (String[] args){
		Scanner scan = new Scanner (System.in);
		int n = scan.nextInt();
		int m = scan.nextInt();
		int k = n+m;
		long[] arr1 = new long[k];
		for(int i = 0; i<k; i++){
			arr1[i]=scan.nextLong();
		}
		long[] tax = new long[k];
		long[] taxcount = new long[k];
		for(int i = 0; i<k; i++){
			tax[i]=scan.nextInt();
		}
		int c;
		int b;
		for(int i = 0; i<k; i++){
			if(tax[i]==0){
				c=i;
				while(tax[c]!=1){
					if(c==0){
						c=-1;
						break;
					}
					c--;
					
				}
				b=i;
				while(tax[b]!=1){
					if(b>=k-1){
						b=-1;
						break;
					} 
					b++;
					
				}
				//System.out.println("">>""+b+"">>""+c);
				if(c==-1&&b>=0){
					taxcount[b]++;
				} else if(b==-1&&c>=0) {
					taxcount[c]++;
				} else if(b>=0&&c>=0) {
					if(arr1[i]-arr1[c]>arr1[b]-arr1[i]){
						taxcount[b]++;
					}
					if(arr1[i]-arr1[c]<arr1[b]-arr1[i]){
						taxcount[c]++;
					}
					if(arr1[i]-arr1[c]==arr1[b]-arr1[i]){
						taxcount[c]++;
					}
					
				}
				
			}
			
			}
		for(int j = 0; j<k; j++){
			if(tax[j]==1){
				System.out.print(taxcount[j]+"" "");
			}
		scan.close();
		}
	}
}
",CorCod,468,468,quadratic
"
// Java implementation of 
// above algorithm 
import
java.io.*; 
import
java.util.*; 

public
class
GFG { 


static
int
MaxSumDifference(Integer []a, 
int
n) 

{ 


// final sequence stored in the vector 

List<Integer> finalSequence = 

new
ArrayList<Integer>(); 


// sort the original array 

// so that we can retrieve 

// the large elements from 

// the end of array elements 

Arrays.sort(a); 


// In this loop first we will insert 

// one smallest element not entered 

// till that time in final sequence 

// and then enter a highest element 

// (not entered till that time) in 

// final sequence so that we 

// have large difference value. This 

// process is repeated till all array 

// has completely entered in sequence. 

// Here, we have loop till n/2 because 

// we are inserting two elements at a 

// time in loop. 

for
(
int
i = 
0
; i < n / 
2
; ++i) { 

finalSequence.add(a[i]); 

finalSequence.add(a[n - i - 
1
]); 

} 


// variable to store the 

// maximum sum of absolute 

// difference 

int
MaximumSum = 
0
; 


// In this loop absolute difference 

// of elements for the final sequence 

// is calculated. 

for
(
int
i = 
0
; i < n - 
1
; ++i) { 

MaximumSum = MaximumSum + 

Math.abs(finalSequence.get(i) 

- finalSequence.get(i + 
1
)); 

} 


// absolute difference of last element 

// and 1st element 

MaximumSum = MaximumSum + 

Math.abs(finalSequence.get(n - 
1
) 

- finalSequence.get(
0
)); 


// return the value 

return
MaximumSum; 

} 


// Driver Code 

public
static
void
main(String args[]) 

{ 

Integer []a = { 
1
, 
2
, 
4
, 
8
}; 

int
n = a.length; 


System.out.print(MaxSumDifference(a, n)); 

} 
} 

// This code is contributed by 
// Manish Shaw (manishshaw1) ",CorCod,609,609,nlogn
"import java.util.*;
import java.io.*;
import java.math.*;

public class round569d2c {

	public static void main(String args[]) {
		FastScanner in = new FastScanner(System.in);
		
		int n = in.nextInt();
		int q = in.nextInt();
		ArrayDeque<Integer> deq = new ArrayDeque<>();
		for (int i = 0; i < n; i++) {
			deq.addLast(in.nextInt());
		}
		long[] queries = new long[q];
		for (int i = 0; i < q; i++) {
			queries[i] = in.nextLong();
		}
		int[] origAs = new int[n-1];
		int[] origBs = new int[n-1];
		for (int i = 0; i < n-1; i++) {
			int a = deq.pollFirst();
			int b = deq.pollFirst();
			origAs[i] = a;
			origBs[i] = b;
			if (a > b) {
				deq.addFirst(a);
				deq.addLast(b);
			}
			else {
				deq.addFirst(b);
				deq.addLast(a);
			}
		}
		int[] repeatAs = new int[n-1];
		int[] repeatBs = new int[n-1];
		for (int i = 0; i < n-1; i++) {
			int a = deq.pollFirst();
			int b = deq.pollFirst();
			repeatAs[i] = a;
			repeatBs[i] = b;
			if (a > b) {
				deq.addFirst(a);
				deq.addLast(b);
			}
			else {
				deq.addFirst(b);
				deq.addLast(a);
			}
		}
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < q; i++) {
			long query = queries[i] - 1;
			if (query < n-1) {
				sb.append(origAs[(int)query] + "" "" + origBs[(int)query] + ""\n"");
			}
			else {
				query %= (n-1);
				sb.append(repeatAs[(int)query] + "" "" + repeatBs[(int)query] + ""\n"");
			}
		}
		System.out.println(sb);

	}

	// ======================================================================================
	// =============================== Reference Code =======================================
	// ======================================================================================

	static int greatestDivisor(int n) {
		int limit = (int) Math.sqrt(n);
		int max = 1;
		for (int i = 2; i <= limit; i++) {
			if (n % i == 0) {
				max = Integer.max(max, i);
				max = Integer.max(max, n / i);
			}
		}
		return max;
	}

	// Method to return all primes smaller than or equal to 
	// n using Sieve of Eratosthenes 
	static boolean[] sieveOfEratosthenes(int n) {
		// Create a boolean array ""prime[0..n]"" and initialize 
		// all entries it as true. A value in prime[i] will 
		// finally be false if i is Not a prime, else true. 
		boolean prime[] = new boolean[n + 1];
		for (int i = 0; i <= n; i++)
			prime[i] = true;

		prime[0] = false;
		prime[1] = false;

		for (int p = 2; p * p <= n; p++) {
			// If prime[p] is not changed, then it is a prime 
			if (prime[p] == true) {
				// Update all multiples of p 
				for (int i = p * p; i <= n; i += p)
					prime[i] = false;
			}
		}

		return prime;
	}

	// Binary search for number greater than or equal to target
	// returns -1 if number not found
	private static int bin_gteq(int[] a, int key) {
		int low = 0;
		int high = a.length;
		int max_limit = high;
		while (low < high) {
			int mid = low + (high - low) / 2;
			if (a[mid] < key) {
				low = mid + 1;
			} else
				high = mid;
		}

		return high == max_limit ? -1 : high;
	}

	public static int gcd(int a, int b) {
		if (a == 0)
			return b;

		return gcd(b % a, a);
	}

	static class Tuple<X, Y> {
		public final X x;
		public final Y y;

		public Tuple(X x, Y y) {
			this.x = x;
			this.y = y;
		}

		public String toString() {
			return ""("" + x + "","" + y + "")"";
		}
	}

	static class Tuple3<X, Y, Z> {
		public final X x;
		public final Y y;
		public final Z z;

		public Tuple3(X x, Y y, Z z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public String toString() {
			return ""("" + x + "","" + y + "","" + z + "")"";
		}
	}

	static Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {
		// Base Case 
		if (a == 0) {
			x = 0;
			y = 1;
			return new Tuple3(0, 1, b);
		}

		int x1 = 1, y1 = 1; // To store results of recursive call 
		Tuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);
		int gcd = tuple.z;
		x1 = tuple.x;
		y1 = tuple.y;

		// Update x and y using results of recursive 
		// call 
		x = y1 - (b / a) * x1;
		y = x1;

		return new Tuple3(x, y, gcd);
	}

	// Returns modulo inverse of a  
	// with respect to m using extended 
	// Euclid Algorithm. Refer below post for details: 
	// https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/ 
	static int inv(int a, int m) {
		int m0 = m, t, q;
		int x0 = 0, x1 = 1;

		if (m == 1)
			return 0;

		// Apply extended Euclid Algorithm 
		while (a > 1) {
			// q is quotient 
			q = a / m;

			t = m;

			// m is remainder now, process 
			// same as euclid's algo 
			m = a % m;
			a = t;

			t = x0;

			x0 = x1 - q * x0;

			x1 = t;
		}

		// Make x1 positive 
		if (x1 < 0)
			x1 += m0;

		return x1;
	}

	// k is size of num[] and rem[]. 
	// Returns the smallest number 
	// x such that: 
	// x % num[0] = rem[0], 
	// x % num[1] = rem[1], 
	// .................. 
	// x % num[k-2] = rem[k-1] 
	// Assumption: Numbers in num[] are pairwise  
	// coprime (gcd for every pair is 1) 
	static int findMinX(int num[], int rem[], int k) {
		// Compute product of all numbers 
		int prod = 1;
		for (int i = 0; i < k; i++)
			prod *= num[i];

		// Initialize result 
		int result = 0;

		// Apply above formula 
		for (int i = 0; i < k; i++) {
			int pp = prod / num[i];
			result += rem[i] * inv(pp, num[i]) * pp;
		}

		return result % prod;
	}

	/**
	 * Source: Matt Fontaine
	 */
	static class FastScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int chars;

		public FastScanner(InputStream stream) {
			this.stream = stream;
		}

		int read() {
			if (chars == -1)
				throw new InputMismatchException();
			if (curChar >= chars) {
				curChar = 0;
				try {
					chars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (chars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}

}",CorCod,54,54,linear
"import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

public class Main {
    public static void main(String[] args)
    {
        Scanner stdin = new Scanner(System.in);
        /*int n = stdin.nextInt();
        for(int i = 0; i < n; i++)
        {
        	test(stdin);
        }*/
        test(stdin);
        stdin.close();
    }
    public static void test(Scanner stdin)
    {
    	int n = stdin.nextInt();
    	int min = Integer.MAX_VALUE;
    	for(int i = 0; i < n; i++)
    	{
    		int a = stdin.nextInt();
    		if((int)((1.0)*a/(Math.max(i, n - i - 1))) < min)
    		{ min = (int)((1.0)*a/(Math.max(i, n - i - 1))); }
    	}
    	System.out.println(min);
    }
}",CorCod,280,280,linear
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.*;
import java.util.*;

/**
 *
 * @author luismiguel
 */
public class FirstApp {
    
    
 
    
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solve = new TaskA();
        solve.solve(1, in, out);
        out.close();
    }
    
    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int number = in.nextInt();

            if(number > 2 && number % 2 == 0) {
                out.println(""YES"");
            } else {
                out.println(""NO"");
            }
        }
    }
    
    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;
 
        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
 
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
 
        public int nextInt() {
            return Integer.parseInt(next());
        }
 
    }
    
}
",CorCod,836,836,constant
"import java.util.*;

public class OrangeJuice{
	public static void main(String[] args) {
		Scanner in=new Scanner(System.in);
		int n=in.nextInt();
		int s=in.nextInt();
		if(n>=1&&n<=100000&&s>=1&&s<=1000000000){
			if(s%n==0){
				System.out.println(s/n);
			}else{
				int o=s%n;
				System.out.println((s-o)/n+1);
			}
		}
	}
}",CorCod,870,870,constant
"import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class ladder {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int problems = sc.nextInt();
        for (int i = 0; i < problems; i++) {
            int numPlanks = sc.nextInt();
            solve(numPlanks, sc);
        }





    }
    public static void solve(int numPlanks, Scanner sc) {
        int answer;
        ArrayList<Integer> planks  = new ArrayList<>();
        for (int i = 0; i < numPlanks; i++) {
            planks.add(sc.nextInt());
        }

        Collections.sort(planks);

        planks.remove(numPlanks - 1);
        planks.add(planks.get(numPlanks - 2));
        int base = planks.get(numPlanks - 1) - 1;
        if ((numPlanks - 2) > base) {
            answer = base;
        }
        else {
            answer = numPlanks - 2;
        }
        if (base == 0) {
            answer = 0;
        }
        System.out.println(answer);
    }
}
",CorCod,675,675,nlogn
"
// Java program to reverse alternate levels of perfect binary tree 
// A binary tree node 
class
Node { 


char
data; 

Node left, right; 


Node(
char
item) { 

data = item; 

left = right = 
null
; 

} 
} 

// class to access index value by reference 
class
Index { 


int
index; 
} 

class
BinaryTree { 


Node root; 

Index index_obj = 
new
Index(); 


// function to store alternate levels in a tree 

void
storeAlternate(Node node, 
char
arr[], Index index, 
int
l) { 

// base case 

if
(node == 
null
) { 

return
; 

} 

// store elements of left subtree 

storeAlternate(node.left, arr, index, l + 
1
); 


// store this node only if level is odd 

if
(l % 
2
!= 
0
) { 

arr[index.index] = node.data; 

index.index++; 

} 


storeAlternate(node.right, arr, index, l + 
1
); 

} 


// Function to modify Binary Tree (All odd level nodes are 

// updated by taking elements from array in inorder fashion) 

void
modifyTree(Node node, 
char
arr[], Index index, 
int
l) { 


// Base case 

if
(node == 
null
) { 

return
; 

} 


// Update nodes in left subtree 

modifyTree(node.left, arr, index, l + 
1
); 


// Update this node only if this is an odd level node 

if
(l % 
2
!= 
0
) { 

node.data = arr[index.index]; 

(index.index)++; 

} 


// Update nodes in right subtree 

modifyTree(node.right, arr, index, l + 
1
); 

} 


// A utility function to reverse an array from index 

// 0 to n-1 

void
reverse(
char
arr[], 
int
n) { 

int
l = 
0
, r = n - 
1
; 

while
(l < r) { 

char
temp = arr[l]; 

arr[l] = arr[r]; 

arr[r] = temp; 

l++; 

r--; 

} 

} 


void
reverseAlternate() { 

reverseAlternate(root); 

} 


// The main function to reverse alternate nodes of a binary tree 

void
reverseAlternate(Node node) { 


// Create an auxiliary array to store nodes of alternate levels 

char
[] arr = 
new
char
[
100
]; 


// First store nodes of alternate levels 

storeAlternate(node, arr, index_obj, 
0
); 


//index_obj.index = 0; 


// Reverse the array 

reverse(arr, index_obj.index); 


// Update tree by taking elements from array 

index_obj.index = 
0
; 

modifyTree(node, arr, index_obj, 
0
); 

} 


void
printInorder() { 

printInorder(root); 

} 


// A utility function to print indorder traversal of a 

// binary tree 

void
printInorder(Node node) { 

if
(node == 
null
) { 

return
; 

} 

printInorder(node.left); 

System.out.print(node.data + 
"" ""
); 

printInorder(node.right); 

} 


// Driver program to test the above functions 

public
static
void
main(String args[]) { 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
'a'
); 

tree.root.left = 
new
Node(
'b'
); 

tree.root.right = 
new
Node(
'c'
); 

tree.root.left.left = 
new
Node(
'd'
); 

tree.root.left.right = 
new
Node(
'e'
); 

tree.root.right.left = 
new
Node(
'f'
); 

tree.root.right.right = 
new
Node(
'g'
); 

tree.root.left.left.left = 
new
Node(
'h'
); 

tree.root.left.left.right = 
new
Node(
'i'
); 

tree.root.left.right.left = 
new
Node(
'j'
); 

tree.root.left.right.right = 
new
Node(
'k'
); 

tree.root.right.left.left = 
new
Node(
'l'
); 

tree.root.right.left.right = 
new
Node(
'm'
); 

tree.root.right.right.left = 
new
Node(
'n'
); 

tree.root.right.right.right = 
new
Node(
'o'
); 

System.out.println(
""Inorder Traversal of given tree""
); 

tree.printInorder(); 


tree.reverseAlternate(); 

System.out.println(
""""
); 

System.out.println(
""""
); 

System.out.println(
""Inorder Traversal of modified tree""
); 

tree.printInorder(); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,266,266,linear
"
// Java program to find n'th Bell number 
import
java.io.*; 

class
GFG 
{ 

// Function to find n'th Bell Number 

static
int
bellNumber(
int
n) 

{ 

int
[][] bell = 
new
int
[n+
1
][n+
1
]; 

bell[
0
][
0
] = 
1
; 


for
(
int
i=
1
; i<=n; i++) 

{ 

// Explicitly fill for j = 0 

bell[i][
0
] = bell[i-
1
][i-
1
]; 


// Fill for remaining values of j 

for
(
int
j=
1
; j<=i; j++) 

bell[i][j] = bell[i-
1
][j-
1
] + bell[i][j-
1
]; 

} 


return
bell[n][
0
]; 

} 


// Driver program 

public
static
void
main (String[] args) 

{ 

for
(
int
n=
0
; n<=
5
; n++) 

System.out.println(
""Bell Number ""
+ n + 

"" is ""
+bellNumber(n)); 

} 
} 

// This code is contributed by Pramod Kumar ",CorCod,569,569,quadratic
"import java.util.*;
public class kingrace {public static void main(String[] args) 
{ 
    Scanner input=new Scanner(System.in);
    long a = input.nextLong();
   input.nextLine();
    String [] coo = input.nextLine().split("" "");
    long xcoin = Long.parseLong(coo[0]);
    long ycoin = Long.parseLong(coo[1]);
    coordinates first = new coordinates(1,1,a);
    coordinates second = new coordinates(a,a,a);
    double x = (double)Math.sqrt(Math.abs((xcoin-1)*(xcoin-1)+(ycoin-1)*(ycoin-1)));
    double y = (double)Math.sqrt(Math.abs((xcoin-a)*(xcoin-a)+(ycoin-a)*(ycoin-a)));
   long c = 0;
   long d = 0;
    if (x>y)
    {
    	System.out.println(""Black"");
    }
    else if(x<y)
    {
    	System.out.println(""White"");
    }
    else {
    c = first.Distance(new coordinates(xcoin,ycoin,a));
    d = second.Distance(new coordinates(xcoin,ycoin,a));
    }
    if(d!=0&&c!=0)
    if (d<c)
    {
    	System.out.println(""Black"");
    	
    }
    else 
    {
    	System.out.println(""White"");
    }
  //System.out.prlongln(c +"" ""+d);
  input.close();
} 

}
class coordinates{
	private long xcoord;
	private long ycoord;
	private long dim; 
	public coordinates(long x, long y, long dimensions)
	{
		xcoord = x;
		ycoord = y;
		dim = dimensions;
		
	}
	public void setCoordinates(long x, long y)
	{
		xcoord = x;
		ycoord = y;
		
	}
	public long Distance(coordinates num)
	{
		long distance = 0; 
		
		
		while ((this.xcoord!=num.xcoord||this.ycoord!=num.ycoord))
		{
		
			if (num.xcoord-this.xcoord==1 &&num.ycoord==this.ycoord)
			{
		
			distance ++; this.setCoordinates(this.xcoord+1, this.ycoord);
			}
			else if (num.xcoord-this.xcoord==-1 &&num.ycoord==this.ycoord)
			{
			
				distance ++; this.setCoordinates(this.xcoord-1, this.ycoord);
			}
			else if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==1)
			{distance ++; this.setCoordinates(this.xcoord, this.ycoord+1);}
			else if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==-1) {
				distance ++; this.setCoordinates(this.xcoord, this.ycoord-1);
			}
			
			else if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord<=0)
			{
			
				distance ++; this.setCoordinates(this.xcoord+1, this.ycoord-1); 
			}
			else if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord>=0)
			{
				distance ++; this.setCoordinates(this.xcoord+1, this.ycoord+1);
			}
			else if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord<=0)
			
			{
				distance ++; this.setCoordinates(this.xcoord-1, this.ycoord-1);
			}
			else if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord>=0)
					{distance ++; this.setCoordinates(this.xcoord-1, this.ycoord+1);
					}
				
		}
		
		return distance;
	}
	
	
}
",CorCod,70,70,linear
"
import java.util.*;
import java.io.*;
import java.math.*;
public class loser
{
    static class InputReader {
        public BufferedReader br;
        public StringTokenizer token;
        public InputReader(InputStream stream)
        {
            br=new BufferedReader(new InputStreamReader(stream),32768);
            token=null;
        }

        public String next()
        {
            while(token==null || !token.hasMoreTokens())
            {
                try
                {
                    token=new StringTokenizer(br.readLine());
                }
                catch(IOException e)
                {
                    throw new RuntimeException(e);
                }
            }
            return token.nextToken();
        }

        public int nextInt()
        {
            return Integer.parseInt(next());
        }

        public long nextLong()
        {
            return Long.parseLong(next());
        }
    }
    static class card{
        String s;
        int l;
        public card(String s,int i)
        {
            this.s=s;
            this.l=i;
        }
    }
    static class sort implements Comparator<card>
    {
        public int compare(card o1,card o2)
        {
            if(o1.l!=o2.l)
                return (o1.l-o2.l);
            else
                return o1.s.compareTo(o2.s);
        }
    }
    static void shuffle(long a[])
    {
        List<Long> l=new ArrayList<>();
        for(int i=0;i<a.length;i++)
            l.add(a[i]);
        Collections.shuffle(l);
        for(int i=0;i<a.length;i++)
            a[i]=l.get(i);
    }

    /*static long gcd(long a,long b)
    {
    if(b==0)
    return a;
    else
    return gcd(b,a%b);
    }
    static boolean valid(int i,int j,int r,int c)
    {
    if(i<r && i>=0 && j<c && j>=0)
    return true;
    else
    return false;
    }*/
    static class Pair
    {
        int a;int b;
        public Pair(int a,int b)
        {
            this.a =a;
            this.b =b;
        }
    }
    public  static void main(String[] args) 
    {
        InputReader sc=new InputReader(System.in);
        int n=sc.nextInt();
        HashMap<String ,Integer> m=new HashMap<>();
        for(int i=0;i<n;i++)
        {
            String t=sc.next();
            if(m.containsKey(t))
            m.put(t,m.get(t)+1);
            else
            m.put(t,1);
        }
        int ans=0;
        for(int i=0;i<n;i++)
        {
            String t=sc.next();
            if(m.containsKey(t) && m.get(t)>0)
            {
                m.put(t,m.get(t)-1);
                ans++;
            }
        }
        System.out.println(n-ans);
    }
}",CorCod,230,230,linear
"
// Java program to Find longest subsequence where 
// every character appears at-least k times 

class
GFG { 


static
final
int
MAX_CHARS = 
26
; 


static
void
longestSubseqWithK(String str, 
int
k) { 

int
n = str.length(); 


// Count frequencies of all characters 

int
freq[] = 
new
int
[MAX_CHARS]; 

for
(
int
i = 
0
; i < n; i++) { 

freq[str.charAt(i) - 
'a'
]++; 

} 


// Traverse given string again and print 

// all those characters whose frequency 

// is more than or equal to k. 

for
(
int
i = 
0
; i < n; i++) { 

if
(freq[str.charAt(i) - 
'a'
] >= k) { 

System.out.print(str.charAt(i)); 

} 

} 

} 

// Driver code 

static
public
void
main(String[] args) { 

String str = 
""geeksforgeeks""
; 

int
k = 
2
; 

longestSubseqWithK(str, k); 


} 
} 

// This code is contributed by Rajput-Ji ",CorCod,157,157,linear
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.ArrayList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author El-Bishoy
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        D2C982_cut_them_all solver = new D2C982_cut_them_all();
        solver.solve(1, in, out);
        out.close();
    }

    static class D2C982_cut_them_all {
        int n;
        ArrayList<Integer>[] adj;
        int[] sizes = new int[n];
        boolean[] visited = new boolean[n];

        public void solve(int testNumber, InputReader in, OutputWriter out) {

            n = in.nextInt();
            if ((n & 1) == 1) {
                out.println(-1);
                return;
            }
            sizes = new int[n];
            visited = new boolean[n];
            adj = new ArrayList[n];
            for (int i = 0; i < n; i++) {
                adj[i] = new ArrayList<>();
            }

            for (int i = 1; i < n; i++) {
                int u = in.nextInt() - 1;
                int v = in.nextInt() - 1;
                adj[u].add(v);
                adj[v].add(u);
            }

            int root = 0;
            for (int i = 1; i < n; i++) {
                if (adj[i].size() > adj[root].size()) {
                    root = i;
                }
            }

            dfs(root);
            int cnt = 0;
            for (int i = 0; i < n; i++) {
                if ((sizes[i] & 1) == 0) cnt++;
            }
            out.println(cnt - 1);

        }

        int dfs(int u) {

            visited[u] = true;
            int cnt = 1;

            for (int w : adj[u])
                if (!visited[w])
                    cnt += dfs(w);

            sizes[u] = cnt;
            return cnt;
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void println(int i) {
            writer.println(i);
        }

    }
}

",CorCod,261,261,linear
"
class
GFG{ 

// A dynamic programming based function to find nth 
// Catalan number 

static
int
catalanDP(
int
n) { 

// Table to store results of subproblems 

int
catalan[] = 
new
int
[n + 
2
]; 


// Initialize first two values in table 

catalan[
0
] = 
1
; 

catalan[
1
] = 
1
; 


// Fill entries in catalan[] using recursive formula 

for
(
int
i = 
2
; i <= n; i++) { 

catalan[i] = 
0
; 

for
(
int
j = 
0
; j < i; j++) { 

catalan[i] += catalan[j] * catalan[i - j - 
1
]; 

} 

} 


// Return last entry 

return
catalan[n]; 

} 

// Driver code 

public
static
void
main(String[] args) { 

for
(
int
i = 
0
; i < 
10
; i++) { 

System.out.print(catalanDP(i) + 
"" ""
); 

} 

} 
} 
// This code contributed by Rajput-Ji ",CorCod,394,394,quadratic
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class D909 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] line = br.readLine().toCharArray();
        int n = line.length;

        int l = 0;
        ArrayList<Node> groups = new ArrayList<>();
        Node node = new Node(line[0], 1);
        groups.add(node);
        for (int i = 1; i < n; i++) {
            if (line[i] == groups.get(l).letter) {
                groups.get(l).count++;
            } else {
                node = new Node(line[i], 1);
                groups.add(node);
                l++;
            }
        }

        int moves = 0;
        ArrayList<Node> temp = new ArrayList<>();
        while (groups.size() > 1) {
            moves++;

            l = groups.size();
            groups.get(0).count--;
            groups.get(l - 1).count--;
            for (int i = 1; i < l - 1; i++) {
                groups.get(i).count -= 2;
            }

            int p;
            for (p = 0; p < l; p++) {
                if (groups.get(p).count > 0) {
                    temp.add(groups.get(p));
                    break;
                }
            }
            int lTemp = temp.size();
            for (p++; p < l; p++) {
                if (groups.get(p).count <= 0) {
                    continue;
                }
                if (groups.get(p).letter == temp.get(lTemp - 1).letter) {
                    temp.get(lTemp - 1).count += groups.get(p).count;
                } else {
                    temp.add(groups.get(p));
                    lTemp++;
                }
            }

            groups.clear();
            groups.addAll(temp);
            temp.clear();
        }

        System.out.println(moves);
    }

    private static class Node {
        char letter;
        int count;

        Node(char letter, int count) {
            this.letter = letter;
            this.count = count;
        }
    }
}
",CorCod,213,213,linear
"import java.util.*;
import java.io.*;
public class C{
    static PrintWriter out;
    static InputReader in;
    public static void main(String args[]){
        out = new PrintWriter(System.out);
        in = new InputReader();
        new C();
        out.flush(); out.close();
    }   
    C(){
       int w = solve();
       out.print(w == 0 ? ""sjfnb"" : ""cslnb"");
    }
    int n;
    long a[];
    int solve(){
        n = in.nextInt(); a = new long[n];
        long sum = 0;
        for(int i = 0; i < n; i++)sum += a[i] = in.nextLong();
        if(sum == 0){
            return 1;
        }
        Arrays.sort(a);
        int c = 0, c0 = 0; long p = -1, max = 0;
        int f = 0;
        long t = -1; int pp = -1;
        for(int i = 0; i < n; i++){
            if(a[i] == p){
                c++;
            }else{
                if(p == 0)c0 = c;
                if(c >= 2){f++; t = p; pp = i - 2;}
                max = Math.max(max, c);
                p = a[i];
                c = 1;
            }
        }
        max = Math.max(max, c);
        sum = 0;
        if(c >= 2){f++; t = p; pp = n - 2;}
        if(max > 2 || c0 > 1 || f > 1)return 1;
        if(f == 1){
            long v = Arrays.binarySearch(a, t - 1);
            if(v >= 0)return 1;
            a[pp]--; sum = 1;
        }

        p = -1;
        for(int i = 0; i < n; i++){
            sum += a[i] - (p + 1);
            a[i] = p + 1;
            p = a[i];
        }

        return 1 - (int)(sum % 2);
    }
    public static class InputReader{
        BufferedReader br;
        StringTokenizer st;
        InputReader(){
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        public int nextInt(){
            return Integer.parseInt(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public String next(){
            while(st == null || !st.hasMoreTokens()){
                try{
                    st = new StringTokenizer(br.readLine());
                }catch(IOException e){}
            }
            return st.nextToken();
        }
    }
}
        ",CorCod,319,319,linear
"
// Java program to find 
// lexicographically 
// maximum value after 
// k swaps. 
import
java.io.*; 

class
GFG 
{ 

static
void
SwapInts(
int
array[], 

int
position1, 

int
position2) 

{ 

// Swaps elements 

// in an array. 


// Copy the first 

// position's element 

int
temp = array[position1]; 


// Assign to the 

// second element 

array[position1] = array[position2]; 


// Assign to the 

// first element 

array[position2] = temp; 

} 


// Function which 

// modifies the array 

static
void
KSwapMaximum(
int
[]arr, 

int
n, 
int
k) 

{ 

for
(
int
i = 
0
; 

i < n - 
1
&& k > 
0
; ++i) 

{ 


// Here, indexPositionition 

// is set where we want to 

// put the current largest 

// integer 

int
indexPosition = i; 

for
(
int
j = i + 
1
; j < n; ++j) 

{ 


// If we exceed the 

// Max swaps then 

// break the loop 

if
(k <= j - i) 

break
; 


// Find the maximum value 

// from i+1 to max k or n 

// which will replace 

// arr[indexPosition] 

if
(arr[j] > arr[indexPosition]) 

indexPosition = j; 

} 


// Swap the elements from 

// Maximum indexPosition 

// we found till now to 

// the ith index 

for
(
int
j = indexPosition; j > i; --j) 

SwapInts(arr, j, j - 
1
); 


// Updates k after swapping 

// indexPosition-i elements 

k -= indexPosition - i; 

} 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
[]arr = { 
3
, 
5
, 
4
, 
1
, 
2
}; 

int
n = arr.length; 

int
k = 
3
; 


KSwapMaximum(arr, n, k); 


// Print the final Array 

for
(
int
i = 
0
; i < n; ++i) 

System.out.print(arr[i] + 
"" ""
); 

} 
} 

// This code is contributed by 
// Manish Shaw(manishshaw1) ",CorCod,482,482,quadratic
"

import java.io.PrintWriter;

import java.util.*;
import java.util.Arrays ; 
import java .lang.String.* ;
import java .lang.StringBuilder ;


public class Test{
    static int pos = 0 ; 
    static int  arr[] ; 
  static LinkedList l1 = new  LinkedList() ; 
static void find(int p ,char[]x,int put[],String s){
    int c= 0 ; 
    for (int i = 0; i < s.length(); i++) {
        if(x[p]==s.charAt(i)){
        c++ ; }
    }
    put[p] = c ;  
}
static int mode(int m ,int[]x ){
    int temp = 0 ; 
    for (int i = x.length-1; i >=0; i--) {
        if(x[i]<=m){
            temp= x[i] ; 
           /// break ; 
             return m-temp ; 
             
        }
    }
     return m-temp ; 
}
static int mode2(int m ,int[]x ){
    int temp = 0 ; 
    
    for (int i = x.length-1; i >=0; i--) {
        if(x[i]<=m){
            temp= x[i] ; 
           /// break ; 
             return x[i] ; 
             
        }
    }
     return 0 ; 
}
static int find(int x[],int temp){
    int j = 0 ; 
    for (int i = x.length-1; i >=0; i--) {
        if(x[i]==temp) return j+1 ; 
        j++ ; 
    }
    return -1 ; 
}
static String ch(long[]x,long b){
    for (int i = 0; i < x.length; i++) {
        if(x[i]==b)return ""YES"" ;
    }
    return ""NO"" ; 
}

    public static void main(String[] args)  {

        Scanner in = new Scanner(System.in) ;
        PrintWriter pw = new PrintWriter(System.out);   
     int k=in.nextInt(), n=in.nextInt(), s=in.nextInt(), p=in.nextInt() ;
     int paper =n/s; 
     if(n%s!=0) paper++ ; 
     paper*=k ; 
     int fin = paper/p ; 
     if(paper%p!=0) fin++ ; 
        System.out.println( fin );
       
       
 }               
}

",CorCod,801,801,constant
"import java.util.*;
public class A
{
    public static void main(String args[])
    {
        Scanner sc=new Scanner(System.in);
        long n=sc.nextLong();
        if(n==0)
        System.out.println(0);
        else if(n%2==1)
        System.out.println((n+1)/2);
        else
        System.out.println(n+1);
    }
}",CorCod,867,867,constant
"
// Java program to demonstrate working of 
// an algorithm that finds an element in an 
// array of infinite size 

class
Test 
{ 

// Simple binary search algorithm 

static
int
binarySearch(
int
arr[], 
int
l, 
int
r, 
int
x) 

{ 

if
(r>=l) 

{ 

int
mid = l + (r - l)/
2
; 

if
(arr[mid] == x) 

return
mid; 

if
(arr[mid] > x) 

return
binarySearch(arr, l, mid-
1
, x); 

return
binarySearch(arr, mid+
1
, r, x); 

} 

return
-
1
; 

} 


// Method takes an infinite size array and a key to be 

// searched and returns its position if found else -1. 

// We don't know size of arr[] and we can assume size to be 

// infinite in this function. 

// NOTE THAT THIS FUNCTION ASSUMES arr[] TO BE OF INFINITE SIZE 

// THEREFORE, THERE IS NO INDEX OUT OF BOUND CHECKING 

static
int
findPos(
int
arr[],
int
key) 

{ 

int
l = 
0
, h = 
1
; 

int
val = arr[
0
]; 


// Find h to do binary search 

while
(val < key) 

{ 

l = h; 
// store previous high 

//check that 2*h doesn't exceeds array 

//length to prevent ArrayOutOfBoundException 

if
(
2
*h < arr.length-
1
) 

h = 
2
*h; 

else

h = arr.length-
1
; 


val = arr[h]; 
// update new val 

} 


// at this point we have updated low 

// and high indices, thus use binary 

// search between them 

return
binarySearch(arr, l, h, key); 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

int
arr[] = 
new
int
[]{
3
, 
5
, 
7
, 
9
, 
10
, 
90
, 

100
, 
130
, 
140
, 
160
, 
170
}; 

int
ans = findPos(arr,
10
); 


if
(ans==-
1
) 

System.out.println(
""Element not found""
); 

else

System.out.println(
""Element found at index ""
+ ans); 

} 
} ",CorCod,899,899,logn
"import java.io.*;


public class First {
    StreamTokenizer in;
    PrintWriter out;

    int nextInt() throws IOException {
        in.nextToken();
        return (int)in.nval;
    }

    long nextLong() throws IOException {
        in.nextToken();
        return (long) in.nval;
    }

    String nextString() throws IOException {
        in.nextToken();
        return in.sval;
    }



    void run() throws IOException {
        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(System.out);
        solve();
        out.flush();
    }

    void solve() throws IOException {
        int n = nextInt(), k = nextInt(), sum = 0, count = 0;
        String str = nextString();
        char[] arr = str.toCharArray();
        boolean[] bool = new boolean[26];
        for(char ch: arr){
            bool[((int)ch)-97] = true;
        }
        for(int i = 0; i < 26; i++){
            if(bool[i]){
                sum += i+1;
                count++;
                i += 1;
            }
            if(count == k) break;
        }
        if(count == k) out.println(sum);
        else out.println(-1);
    }

    public static void main(String[] args) throws IOException {
        new First().run();
    }
}",CorCod,244,244,linear
"
import java.io.*;
import java.util.Scanner;
public class abc{
    public static int check(StringBuilder s)
    {
    	int countRemove=0;
    	if(!s.toString().contains(""xxx"")) return countRemove;
    	else{
    		
    		for(int i=1;i<s.length()-1;i++)
    		{
    			if(s.charAt(i-1)=='x' && s.charAt(i)=='x' && s.charAt(i+1)=='x')
    			{
    			
    				countRemove++;
    			}
    		}
    		return countRemove;
    	}
    }
   
	public static void main (String[] args) {
	
	Scanner sc = new Scanner(System.in);
	int n = sc.nextInt();
	//sc= new Scanner(System.in);
	String s = sc.next();
	StringBuilder sb = new StringBuilder("""");
	sb.append(s);
	
    System.out.println(check(sb));
	
	
	
	}
}",CorCod,131,131,linear
"import java.util.*;

public class MyClass {
    public static void main(String args[]) {
        Scanner sc= new Scanner(System.in);
        int n=sc.nextInt();
        int [] a= new int[n];
        int k=0;
        int m=0;
        for (int i=0;i<n;i++){
            a[i]=sc.nextInt();
            if (a[i]>=0){
                a[i]=-a[i]-1;
            }
            if (a[i]<m){
                m=a[i];
                k=i;
            }
        }
        if (n%2==1){
            a[k]=-a[k]-1;
        }
        for (int i=0;i<n;i++){
            System.out.print(a[i]+"" "");
        }
    }
}
",CorCod,19,19,linear
"import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;

public class A1180 {

    public static void main(String[] args) throws FileNotFoundException 
    { 
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int layers = n-1;
		int counter =0;
		for(int i =1 ;i < layers + 1 ; i ++) {
			counter += i ;
		}
		//System.out.println(counter);
		System.out.println(1 + counter*4);
    } 
}
",CorCod,193,193,linear
"
// Java program for counting n digit numbers with 
// non decreasing digits 
import
java.io.*; 

class
GFG { 


// Function that returns count of non- decreasing numbers 

// with n digits 

static
int
nonDecNums(
int
n) 

{ 

// a[i][j] = count of all possible number 

// with i digits having leading digit as j 

int
[][] a = 
new
int
[n + 
1
][
10
]; 


// Initialization of all 0-digit number 

for
(
int
i = 
0
; i <= 
9
; i++) 

a[
0
][i] = 
1
; 


// Initialization of all i-digit 

// non-decreasing number leading with 9 

for
(
int
i = 
1
; i <= n; i++) 

a[i][
9
] = 
1
; 


// for all digits we should calculate 

// number of ways depending upon leading 

// digits 

for
(
int
i = 
1
; i <= n; i++) 

for
(
int
j = 
8
; j >= 
0
; j--) 

a[i][j] = a[i - 
1
][j] + a[i][j + 
1
]; 


return
a[n][
0
]; 

} 


// driver program 

public
static
void
main(String[] args) 

{ 

int
n = 
2
; 

System.out.println(
""Non-decreasing digits = ""
+ nonDecNums(n)); 

} 
} 

// Contributed by Pramod Kumar ",CorCod,76,76,linear
"
// Java program to acquire 
// all n coins 
import
java.util.Arrays; 

class
GFG 
{ 


// function to calculate min cost 

static
int
minCost(
int
coin[], 

int
n, 
int
k) 

{ 


// sort the coins value 

Arrays.sort(coin); 


// calculate no. of 

// coins needed 

int
coins_needed = (
int
)Math.ceil(
1.0
* 

n / (k + 
1
)); 


// calculate sum of 

// all selected coins 

int
ans = 
0
; 


for
(
int
i = 
0
; i <= coins_needed - 
1
; 

i++) 

ans += coin[i]; 


return
ans; 

} 


// Driver code 

public
static
void
main(String arg[]) 

{ 

int
coin[] = { 
8
, 
5
, 
3
, 
10
, 

2
, 
1
, 
15
, 
25
}; 

int
n = coin.length; 

int
k = 
3
; 


System.out.print(minCost(coin, n, k)); 

} 
} 

// This code is contributed 
// by Anant Agarwal. ",CorCod,628,628,nlogn
"import java.io.*;
import java.util.*;


public class Main {

    static StringBuilder data;
    final static FastReader in = new FastReader();


    public static void main(String[] args) {
        int n = in.nextInt(), k = in.nextInt();
               long answ = 0;
        if (n * 2 > k) {
         if((n*2)%k==0){
             answ+=(n*2)/k;
         }else{
             answ+=((n*2)/k)+1;
         }
        }else{
            answ++;
        }
        if (n * 5 > k) {
            if((n*5)%k==0){
                answ+=(n*5)/k;
            }else{
                answ+=((n*5)/k)+1;
            }
        }else{
            answ++;
        }
        if (n * 8 > k) {
            if((n*8)%k==0){
                answ+=(n*8)/k;
            }else{
                answ+=((n*8)/k)+1;
            }
        }else{
            answ++;
        }

        System.out.println(answ);
    }


    static void fileOut(String s) {
        File out = new File(""output.txt"");
        try {
            FileWriter fw = new FileWriter(out);
            fw.write(s);
            fw.flush();
            fw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        public FastReader(String path) {
            try {
                br = new BufferedReader(new
                        InputStreamReader(new FileInputStream(path)));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        float nextFloat() {
            return Float.parseFloat(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }


        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

}",CorCod,815,815,constant
"
import java.util.*;


public class HelloWorld {
	static long SQR(long a) {
		return a * a;
	}
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		String str = sc.next();
		char s[] = str.toCharArray();
		Arrays.parallelSort(s);
		str = new String(s);
		int d = 0;
		int ans = 0;

		for(int i = 0;i < str.length();i++) {
			int x = str.charAt(i) - 'a';
			if(k == 0)continue;
			if(x >= d) {
				ans = ans + x + 1;
				d = x + 2;
				k = k - 1;
			}
		}
		if(k > 0)ans = -1;
		System.out.println(ans);
	}
}
",CorCod,680,680,nlogn
"
// Java program to check if a given array is sorted 
// or not. 

class
GFG { 

// Function that returns true if array is Inorder 
// traversal of any Binary Search Tree or not. 

static
boolean
isInorder(
int
[] arr, 
int
n) { 

// Array has one or no element 

if
(n == 
0
|| n == 
1
) { 

return
true
; 

} 


for
(
int
i = 
1
; i < n; i++) 
// Unsorted pair found 

{ 

if
(arr[i - 
1
] > arr[i]) { 

return
false
; 

} 

} 


// No unsorted pair found 

return
true
; 

} 
// Drivers code 


public
static
void
main(String[] args) { 

int
arr[] = {
19
, 
23
, 
25
, 
30
, 
45
}; 

int
n = arr.length; 

if
(isInorder(arr, n)) { 

System.out.println(
""Yes""
); 

} 
else
{ 

System.out.println(
""Non""
); 

} 

} 
} 
//This code is contributed by 29AjayKumar ",CorCod,188,188,linear
"
// Java program to maximize the sum of difference 
// between consecutive elements in circular array 
import
java.io.*; 
import
java.util.Arrays; 

class
MaxSum 
{ 

// Return the maximum Sum of difference between 

// consecutive elements. 

static
int
maxSum(
int
arr[], 
int
n) 

{ 

int
sum = 
0
; 


// Sorting the array. 

Arrays.sort(arr); 


// Subtracting a1, a2, a3,....., a(n/2)-1, 

// an/2 twice and adding a(n/2)+1, a(n/2)+2, 

// a(n/2)+3,....., an - 1, an twice. 

for
(
int
i = 
0
; i < n/
2
; i++) 

{ 

sum -= (
2
* arr[i]); 

sum += (
2
* arr[n - i - 
1
]); 

} 


return
sum; 

} 


// Driver Program 

public
static
void
main (String[] args) 

{ 

int
arr[] = { 
4
, 
2
, 
1
, 
8
}; 

int
n = arr.length; 

System.out.println(maxSum(arr, n)); 

} 
} 
/*This code is contributed by Prakriti Gupta*/",CorCod,585,585,nlogn
"import java.util.*;
import java.io.*;



 public class Param
{
                
      public static  void main( String[]args) 
    {
       MyScanner param = new MyScanner();
      out = new PrintWriter(new BufferedOutputStream(System.out));
      int highestcoin=param.nextInt();
      int sum=param.nextInt();
      int remainder=sum%highestcoin;
      if(remainder!=0){
         remainder=1;
      }
      else{
         remainder=0;
      }
      int count=(sum-remainder)/highestcoin;
     
       if (highestcoin>=sum){
         System.out.println(""1"");
      }
      else{
      System.out.println(count+remainder);
      }
      out.close();
}
public static PrintWriter out;
      
   //-----------MyScanner class for faster input----------
   public static class MyScanner {
      BufferedReader br;
      StringTokenizer st;
 
      public MyScanner() {
         br = new BufferedReader(new InputStreamReader(System.in));
      }
 
      String next() {
          while (st == null || !st.hasMoreElements()) {
              try {
                  st = new StringTokenizer(br.readLine());
              } catch (IOException e) {
                  e.printStackTrace();
              }
          }
          return st.nextToken();
      }
 
      int nextInt() {
          return Integer.parseInt(next());
      }
 
      long nextLong() {
          return Long.parseLong(next());
      }
 
      double nextDouble() {
          return Double.parseDouble(next());
      }
 
      String nextLine(){
          String str = """";
	  try {
	     str = br.readLine();
	  } catch (IOException e) {
	     e.printStackTrace();
	  }
	  return str;
      }
}
}
   ",CorCod,742,742,constant
"
class
Main 
{ 

/* Function to get index of ceiling 

of x in arr[low..high] */

static
int
ceilSearch(
int
arr[], 
int
low, 
int
high, 
int
x) 

{ 

int
i; 


/* If x is smaller than or equal to first 

element,then return the first element */

if
(x <= arr[low]) 

return
low; 


/* Otherwise, linearly search for ceil value */

for
(i = low; i < high; i++) 

{ 

if
(arr[i] == x) 

return
i; 


/* if x lies between arr[i] and arr[i+1] 

including arr[i+1], then return arr[i+1] */

if
(arr[i] < x && arr[i+
1
] >= x) 

return
i+
1
; 

} 


/* If we reach here then x is greater than the 

last element of the array, return -1 in this case */

return
-
1
; 

} 



/* Driver program to check above functions */

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
2
, 
8
, 
10
, 
10
, 
12
, 
19
}; 

int
n = arr.length; 

int
x = 
3
; 

int
index = ceilSearch(arr, 
0
, n-
1
, x); 

if
(index == -
1
) 

System.out.println(
""Ceiling of ""
+x+
"" doesn't exist in array""
); 

else

System.out.println(
""ceiling of ""
+x+
"" is ""
+arr[index]); 

} 
} ",CorCod,18,18,linear
"import java.io.*;


public class First {
    StreamTokenizer in;
    PrintWriter out;

    int nextInt() throws IOException {
        in.nextToken();
        return (int)in.nval;
    }

    long nextLong() throws IOException {
        in.nextToken();
        return (long) in.nval;
    }

    String nextString() throws IOException {
        in.nextToken();
        return in.sval;
    }



    void run() throws IOException {
        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(System.out);
        solve();
        out.flush();
    }

    void solve() throws IOException {
        int n = nextInt(), k = nextInt(), sum = 0, count = 0;
        String str = nextString();
        char[] arr = str.toCharArray();
        boolean[] bool = new boolean[26];
        for(char ch: arr){
            bool[((int)ch)-97] = true;
        }
        for(int i = 0; i < 26; i++){
            if(bool[i]){
                sum += i+1;
                count++;
                i += 1;
            }
            if(count == k) break;
        }
        if(count == k) out.println(sum);
        else out.println(-1);
    }

    public static void main(String[] args) throws IOException {
        new First().run();
    }
}",CorCod,265,265,linear
"import java.util.*;
import java.io.*;

public class Three{
    public static void main(String[] args) {
	Scanner in = new Scanner (System.in);
	PrintWriter out = new PrintWriter(System.out);

	pair[] points = new pair [3];
	for (int i = 0; i < 3; ++i) {
	    int x = in.nextInt();
	    int y = in.nextInt();
	    points[i] = new pair (x, y);
	}

	Arrays.sort(points);

	int MaxY = Math.max(Math.max(points[0].y, points[1].y), points[2].y);
	int MinY = Math.min(Math.min(points[0].y, points[1].y), points[2].y);

	out.println(MaxY - MinY + points[2].x - points[0].x + 1);
	for (int i = MinY; i <= MaxY; ++i)
	    out.println(points[1].x + "" "" + i);
	for (int i = points[0].x; i < points[1].x; ++i)
	    out.println(i + "" "" + points[0].y);
	for (int i = points[1].x + 1; i <= points[2].x; ++i)
	    out.println(i + "" "" + points[2].y);
	
	out.close();
    }

    public static class pair implements Comparable<pair> {
	int x, y;
	public pair (int x_, int y_) {
	    x = x_; y = y_;
	}

	@Override
	public int compareTo(pair o) {
	    return x - o.x;
	}
    }
}
",CorCod,599,599,nlogn
"import java.util.*;
import java.io.*;
import java.math.*;
public class Solution{
    public static void main(String[] args)throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        StringTokenizer st;
        for(int z=0;z<t;z++){
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            st = new StringTokenizer(br.readLine());
            int min=1;
            int max=1;
            for(int i=0;i<n;i++){
                int k = Integer.parseInt(st.nextToken());
                if(max<k){
                    min = max;
                    max = k;
                }else if(min<k){
                    min = k;
                }
            }
            int res = Math.min(n-2,min-1);
            System.out.println(res);
        }
    }
}

",CorCod,227,227,linear
"
// A O(1) Java program to 
// find number of strings 
// that can be made under 
// given constraints. 
import
java.io.*; 

class
GFG 
{ 

static
int
countStr(
int
n) 

{ 

return
1
+ (n * 
2
) + 

(n * ((n * n) - 
1
) / 
2
); 

} 

// Driver code 
public
static
void
main (String[] args) 
{ 

int
n = 
3
; 

System.out.println( countStr(n)); 
} 
} 

// This code is contributed by ajit ",CorCod,779,779,constant
"import java.io.*;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
        int n=Integer.parseInt(bf.readLine());
        int[]f=new int[1001];
        int[]a=new int[n];
        StringTokenizer tk=new StringTokenizer(bf.readLine());
        for (int i = 0; i < n; i++) {
            int element=Integer.parseInt(tk.nextToken());
            a[i]=element;
            f[element]++;
        }
        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        ArrayList<Integer> h=new ArrayList<>();
        int counter=0;
        for (int i = 0; i < n; i++) {
            if(f[a[i]]==1){counter++; h.add(a[i]);}
            else{f[a[i]]-=1;}
        }
        pw.write(counter+""\n"");
        for (int i = 0; i < h.size(); i++) {
            pw.write(h.get(i)+"" "");
        }
        pw.flush();
    }
}",CorCod,181,181,linear
"
// Java implementation of program to find 
// the maximum length that can be removed 
import
java.util.ArrayList; 

public
class
GFG 
{ 

// User defined class Pair 

static
class
Pair{ 

char
first; 

int
second; 

Pair(
char
first, 
int
second){ 

this
.first = first; 

this
.second = second; 

} 

} 


/* Function to find the length of longest 

sub-string that can me make removed 

arr --> pair type of array whose first 

field store character in string 

and second field stores 

corresponding index of that character*/

static
int
longestNull(String str) 

{ 

ArrayList<Pair> arr = 
new
ArrayList<>(); 


// store {'@',-1} in arr , here this value 

// will work as base index 

arr.add(
new
Pair(
'@'
, -
1
)); 


int
maxlen = 
0
; 
// Initialize result 


// one by one iterate characters of string 

for
(
int
i = 
0
; i < str.length(); ++i) 

{ 

// make pair of char and index , then 

// store them into arr 

arr.add(
new
Pair(str.charAt(i), i)); 


// now if last three elements of arr[] 

// are making sub-string ""100"" or not 

while
(arr.size() >= 
3
&& 

arr.get(arr.size()-
3
).first==
'1'
&& 

arr.get(arr.size()-
2
).first==
'0'
&& 

arr.get(arr.size()-
1
).first==
'0'
) 

{ 

// if above condition is true then 

// delete sub-string ""100"" from arr[] 

arr.remove(arr.size() - 
3
); 

arr.remove(arr.size() - 
2
); 

arr.remove(arr.size() - 
1
); 

} 


// index of current last element in arr[] 

int
tmp = arr.get(arr.size() - 
1
).second; 


// This is important, here 'i' is the index 

// of current character inserted into arr[] 

// and 'tmp' is the index of last element 

// in arr[] after continuous deletion of 

// sub-string ""100"" from arr[] till we make 

// it null, difference of these to 'i-tmp' 

// gives the length of current sub-string 

// that can be make null by continuous 

// deletion of sub-string ""100"" 

maxlen = Math.max(maxlen, i - tmp); 

} 


return
maxlen; 

} 


// Driver program to run the case 

public
static
void
main(String args[]) 

{ 

System.out.println(longestNull(
""1011100000100""
)); 

} 
} 
// This code is contributed by Sumit Ghosh ",CorCod,282,282,linear
"
// Java program to solve fractional Knapsack Problem 
import
java.util.Arrays; 
import
java.util.Comparator; 

// Greedy approach 
public
class
FractionalKnapSack 
{ 

// Time complexity O(n log n) 

public
static
void
main(String[] args) 

{ 

int
[] wt = {
10
, 
40
, 
20
, 
30
}; 

int
[] val = {
60
, 
40
, 
100
, 
120
}; 

int
capacity = 
50
; 


double
maxValue = getMaxValue(wt, val, capacity); 

System.out.println(
""Maximum value we can obtain = ""
+ 

maxValue); 


} 


// function to get maximum value 

private
static
double
getMaxValue(
int
[] wt, 

int
[] val, 
int
capacity) 

{ 

ItemValue[] iVal = 
new
ItemValue[wt.length]; 


for
(
int
i = 
0
; i < wt.length; i++) 

{ 

iVal[i] = 
new
ItemValue(wt[i], val[i], i); 

} 


//sorting items by value; 

Arrays.sort(iVal, 
new
Comparator<ItemValue>() 

{ 

@Override

public
int
compare(ItemValue o1, ItemValue o2) 

{ 

return
o2.cost.compareTo(o1.cost) ; 

} 

}); 



double
totalValue = 0d; 


for
(ItemValue i: iVal) 

{ 


int
curWt = (
int
) i.wt; 

int
curVal = (
int
) i.val; 


if
(capacity - curWt >= 
0
) 

{ 

// this weight can be picked while 

capacity = capacity-curWt; 

totalValue += curVal; 


} 

else

{ 

// item cant be picked whole 

double
fraction = ((
double
)capacity/(
double
)curWt); 

totalValue += (curVal*fraction); 

capacity = (
int
)(capacity - (curWt*fraction)); 

break
; 

} 



} 


return
totalValue; 

} 


// item value class 

static
class
ItemValue 

{ 

Double cost; 

double
wt, val, ind; 


// item value function 

public
ItemValue(
int
wt, 
int
val, 
int
ind) 

{ 

this
.wt = wt; 

this
.val = val; 

this
.ind = ind; 

cost = 
new
Double(val/wt ); 

} 

} 
} ",CorCod,625,625,nlogn
"
// Java program to check if all leaves are at same level 

// A binary tree node 
class
Node 
{ 

int
data; 

Node left, right; 


Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
Leaf 
{ 

int
leaflevel=
0
; 
} 

class
BinaryTree 
{ 

Node root; 

Leaf mylevel = 
new
Leaf(); 


/* Recursive function which checks whether all leaves are at same 

level */

boolean
checkUtil(Node node, 
int
level, Leaf leafLevel) 

{ 

// Base case 

if
(node == 
null
) 

return
true
; 


// If a leaf node is encountered 

if
(node.left == 
null
&& node.right == 
null
) 

{ 

// When a leaf node is found first time 

if
(leafLevel.leaflevel == 
0
) 

{ 

// Set first found leaf's level 

leafLevel.leaflevel = level; 

return
true
; 

} 


// If this is not first leaf node, compare its level with 

// first leaf's level 

return
(level == leafLevel.leaflevel); 

} 


// If this node is not leaf, recursively check left and right 

// subtrees 

return
checkUtil(node.left, level + 
1
, leafLevel) 

&& checkUtil(node.right, level + 
1
, leafLevel); 

} 


/* The main function to check if all leafs are at same level. 

It mainly uses checkUtil() */

boolean
check(Node node) 

{ 

int
level = 
0
; 

return
checkUtil(node, level, mylevel); 

} 


public
static
void
main(String args[]) 

{ 

// Let us create the tree as shown in the example 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
12
); 

tree.root.left = 
new
Node(
5
); 

tree.root.left.left = 
new
Node(
3
); 

tree.root.left.right = 
new
Node(
9
); 

tree.root.left.left.left = 
new
Node(
1
); 

tree.root.left.right.left = 
new
Node(
1
); 

if
(tree.check(tree.root)) 

System.out.println(
""Leaves are at same level""
); 

else

System.out.println(
""Leaves are not at same level""
); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,57,57,linear
"import java.util.Scanner;

public class codef8 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int num = sc.nextInt();
		int beacon[] = new int[1000001];
		int pos[] = new int[num];
		for (int i = 0; i < num; i++) {
			int position = sc.nextInt();
			beacon[position] = sc.nextInt();
			pos[i] = position;
		}
		int dp[] = new int[1000001];
		int max = 1;
		if (beacon[0] != 0)
			dp[0] = 1;
		
		for (int i = 1; i <= 1000000; i++) {
			if (beacon[i] == 0) {
				dp[i] = dp[i-1];
			} 
			else {
				int j = i - beacon[i] - 1;
				if (j < 0) {
					dp[i] = 1;
				}
				else {
					dp[i] = dp[j] + 1;
				}
			}
			max = Math.max(max, dp[i]);
		}		
		System.out.println(num-max);
	}

}
",CorCod,238,238,linear
"
// Java program to print postorder 
// traversal from preorder and 
// inorder traversals 
import
java.util.Arrays; 

class
GFG 
{ 

// A utility function to search x in arr[] of size n 
static
int
search(
int
arr[], 
int
x, 
int
n) 
{ 

for
(
int
i = 
0
; i < n; i++) 

if
(arr[i] == x) 

return
i; 

return
-
1
; 
} 

// Prints postorder traversal from 
// given inorder and preorder traversals 
static
void
printPostOrder(
int
in1[], 

int
pre[], 
int
n) 
{ 

// The first element in pre[] is 

// always root, search it in in[] 

// to find left and right subtrees 

int
root = search(in1, pre[
0
], n); 


// If left subtree is not empty, 

// print left subtree 

if
(root != 
0
) 

printPostOrder(in1, Arrays.copyOfRange(pre, 
1
, n), root); 


// If right subtree is not empty, 

// print right subtree 

if
(root != n - 
1
) 

printPostOrder(Arrays.copyOfRange(in1, root+
1
, n), 

Arrays.copyOfRange(pre, 
1
+root, n), n - root - 
1
); 


// Print root 

System.out.print( pre[
0
] + 
"" ""
); 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

int
in1[] = { 
4
, 
2
, 
5
, 
1
, 
3
, 
6
}; 

int
pre[] = { 
1
, 
2
, 
4
, 
5
, 
3
, 
6
}; 

int
n = in1.length; 

System.out.println(
""Postorder traversal ""
); 

printPostOrder(in1, pre, n); 
} 
} 
// This code is contributed by Arnab Kundu ",CorCod,571,571,quadratic
"//package codeforces;
import java.util.Scanner;
public class ex5 {
public static void main(String[] args) {
	Scanner scan = new Scanner(System.in);
	String S [] = new String[3];
	
	int m=0,s=0,p=0;
	int temp=0;
	
	for (int i = 0; i < S.length; i++) {
		S[i]=scan.next();
		if(S[i].indexOf('m')!=-1) m++;
		if(S[i].indexOf('s')!=-1) s++;
		if(S[i].indexOf('p')!=-1) p++;
	}
	
	
	int n1 = Integer.parseInt(S[0].substring(0,1));
	int n2 = Integer.parseInt(S[1].substring(0,1));
	int n3 = Integer.parseInt(S[2].substring(0,1));
	
	
	
	    int d3 = Math.abs(n1-n2);
		int d4 = Math.abs(n1-n3);
		int d5 = Math.abs(n2-n3);
		
	
	if(m==3||s==3||p==3) {
		
		    if(d3==1&d5==1&d4==2||d3==1&d4==1&d5==2||d5==1&d4==1&d3==2)
			System.out.println(0);
		else 
		    if(d3==0&d4==0) System.out.println(0);
		else 
			if(d3<d5&d3<d4) {
			    if(d3==1||d3==2||d3==0) System.out.println(1);
		        else                 System.out.println(2);
			    }
			else if (d5<d4&d5<d3){
				 if(d5==1||d5==2||d5==0) System.out.println(1);
					else                 System.out.println(2);
			}
			else if(d4<d5&d4<d3) {
				if(d4==1||d4==2||d4==0) System.out.println(1);
				else                 System.out.println(2);
			}
			else if(d3==2&d5==2||d4==2&d5==2||d3==2&d4==2||d3==1&d5==1||d4==1&d5==1||d3==2&d4==1)
				System.out.println(1);
			else System.out.println(2);
			
			
		
		 
		    
		    
	}
	
	if(m==2||s==2||p==2) {
		
		
		
		char c1 = S[0].charAt(1);
		char c2 = S[1].charAt(1);
		char c3 = S[2].charAt(1);
		
		
		if(c1==c2) {
			if(n1==n2) System.out.println(1);
			else if(d3==1||d3==2) System.out.println(1);
			else System.out.println(2);
		}
		if(c1==c3) {
			if(n1==n3) System.out.println(1);
			else if(d4==1||d4==2) System.out.println(1);
			else System.out.println(2);
		}
		if(c2==c3) {
			if(n2==n3) System.out.println(1);
			else if(d5==1||d5==2) System.out.println(1);
			else System.out.println(2);
		}
	}
	
	if(m==1&s==1&p==1) System.out.println(2);
		
	
	
}
}
",CorCod,808,808,constant
"//
//                                  _oo8oo_
//                                 o8888888o
//                                 88"" . ""88
//                                 (| -_- |)
//                                 0\  =  /0
//                               ___/'==='\___
//                             .' \\|     |// '.
//                            / \\|||  :  |||// \
//                           / _||||| -:- |||||_ \
//                          |   | \\\  -  /// |   |
//                          | \_|  ''\---/''  |_/ |
//                          \  .-\__  '-'  __/-.  /
//                        ___'. .'  /--.--\  '. .'___
//                     ."""" '<  '.___\_<|>_/___.'  >' """".
//                    | | :  `- \`.:`\ _ /`:.`/ -`  : | |
//                    \  \ `-.   \_ __\ /__ _/   .-` /  /
//                =====`-.____`.___ \_____/ ___.`____.-`=====
//                                  `=---=`
//
//
//               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//                          佛祖保佑         永不宕机/永无bug
//

import java.util.*;

public class G {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n, m;
        n = in.nextInt();
        m = in.nextInt();
        int[] a = new int[m];

        for (int i = 0; i < m; i++) {
            a[i] = in.nextInt();
        }

        Arrays.sort(a);
        HashMap<Integer, Integer> map = new HashMap<>(200);
        for (int i : a) {
            Integer t = map.get(i);
            if (t == null) {
                map.put(i, 1);
            } else {
                map.put(i, t + 1);
            }
        }

        ArrayList<Food> list = new ArrayList<>(100);
        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<Integer, Integer> en = it.next();
            list.add(new Food(en.getKey(), en.getValue()));
        }

        list.sort(Comparator.comparingInt(o -> o.num));
        int min, max;
        min = 1;
        max = list.get(list.size() - 1).num;
        int res = 0;
        for (int i = min; i <= max; i++) {
            int t = 0;
            for (Food food : list) {
                int gaven = food.num / i;
                if (gaven >= 1) {
                    t += gaven;
                    if (t >= n) {
                        res = Math.max(res, i);
                        break;
                    }
                }
            }
        }
        System.out.println(res);
//        System.out.println(Arrays.toString(list.toArray()));
//        if (list.size() < n) {
//            System.out.println(0);
//        } else {
//            System.out.println(list.get(n - 1).num);
//        }
    }
}

class Food {
    int id;
    int num;

    public Food(int id, int num) {
        this.id = id;
        this.num = num;
    }

    @Override
    public String toString() {
        return ""Food{"" +
                ""id="" + id +
                "", num="" + num +
                '}';
    }
}
",CorCod,415,415,quadratic
"import java.io.*;
import java.util.*;

public class Main {
    public void solve() {
        int n = ni();
        int a = ni();
        int b = ni();

        long ans = 0;
        HashMap<Long, Long> m = new HashMap<>();
        HashMap<String, Long> s = new HashMap<>();

        for (int i = 0; i < n; i++) {
            ni();
            long vx = ni();
            long vy = ni();
            long v = (long) a * vx - vy;
            String k = vx + ""|"" + vy;
            long cs = s.getOrDefault(k, 0L);
            long c = m.getOrDefault(v, 0L);
            ans += c - cs;
            m.put(v, c + 1);
            s.put(k, cs + 1);
        }
        write (ans * 2 + ""\n"");
    }



    public static void main(String[] args) {
        Main m = new Main();
        m.solve();
        try {
            m.out.close();
        } catch (IOException e) {}
    }

    BufferedReader in;
    BufferedWriter out;
    StringTokenizer tokenizer;
    public Main() {
        in = new BufferedReader(new InputStreamReader(System.in));
        out = new BufferedWriter(new OutputStreamWriter(System.out));
    }
    public String n() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(in.readLine());
            } catch (IOException e) {}
        }
        return tokenizer.nextToken();
    }
    public int ni() {
        return Integer.parseInt(n());
    }
    public long nl() {
        return Long.parseLong(n());
    }
    public void write(String s) {
        try {
            out.write(s);
        } catch (IOException e) {}
    }
}",CorCod,106,106,linear
"
// Iterative Java program to print odd level nodes 
import
java.util.*; 
class
GfG { 

static
class
Node { 

int
data; 

Node left, right; 
} 

// Iterative method to do level order traversal line by line 
static
void
printOddNodes(Node root) 
{ 

// Base Case 

if
(root == 
null
) 
return
; 


// Create an empty queue for level 

// order tarversal 

Queue<Node> q = 
new
LinkedList<Node> (); 


// Enqueue root and initialize level as odd 

q.add(root); 

boolean
isOdd = 
true
; 


while
(
true
) 

{ 

// nodeCount (queue size) indicates 

// number of nodes at current level. 

int
nodeCount = q.size(); 

if
(nodeCount == 
0
) 

break
; 


// Dequeue all nodes of current level 

// and Enqueue all nodes of next level 

while
(nodeCount > 
0
) 

{ 

Node node = q.peek(); 

if
(isOdd == 
true
) 

System.out.print(node.data + 
"" ""
); 

q.remove(); 

if
(node.left != 
null
) 

q.add(node.left); 

if
(node.right != 
null
) 

q.add(node.right); 

nodeCount--; 

} 


isOdd = !isOdd; 

} 
} 

// Utility method to create a node 
static
Node newNode(
int
data) 
{ 

Node node = 
new
Node(); 

node.data = data; 

node.left = 
null
; 

node.right = 
null
; 

return
(node); 
} 

// Driver code 
public
static
void
main(String[] args) 
{ 

Node root = newNode(
1
); 

root.left = newNode(
2
); 

root.right = newNode(
3
); 

root.left.left = newNode(
4
); 

root.left.right = newNode(
5
); 

printOddNodes(root); 
} 
} ",CorCod,342,342,linear
"
// Java code to find sum of 
// all area rectangle possible 
import
java.io.*; 
import
java.util.Arrays; 

class
GFG 
{ 

// Function to find 

// area of rectangles 

static
int
MaxTotalRectangleArea(
int
[]a, 

int
n) 

{ 


// sorting the array in 

// descending order 

Arrays.sort(a); 


// store the final sum of 

// all the rectangles area 

// possible 

int
sum = 
0
; 

boolean
flag = 
false
; 


// temporary variable to 

// store the length of rectangle 

int
len = 
0
; 


for
(
int
i = 
0
; i < n; i++) 

{ 


// Selecting the length of 

// rectangle so that difference 

// between any two number is 1 

// only. Here length is selected 

// so flag is set 

if
((a[i] == a[i + 
1
] || 

a[i] - a[i + 
1
] == 
1
) && 

!flag) 

{ 

// flag is set means 

// we have got length of 

// rectangle 

flag = 
true
; 


// length is set to 

// a[i+1] so that if 

// a[i] a[i+1] is less 

// than by 1 then also 

// we have the correct 

// choice for length 

len = a[i + 
1
]; 


// incrementing the counter 

// one time more as we have 

// considered a[i+1] element 

// also so. 

i++; 

} 


// Selecting the width of rectangle 

// so that difference between any 

// two number is 1 only. Here width 

// is selected so now flag is again 

// unset for next rectangle 

else
if
((a[i] == a[i + 
1
] || 

a[i] - a[i + 
1
] == 
1
) && 

(flag)) 

{ 

// area is calculated for 

// rectangle 

sum = sum + a[i + 
1
] * len; 


// flag is set false 

// for another rectangle 

// which we can get from 

// elements in array 

flag = 
false
; 


// incrementing the counter 

// one time more as we have 

// considered a[i+1] element 

// also so. 

i++; 

} 

} 


return
sum; 

} 


// Driver code 

public
static
void
main (String args[]) 

{ 

int
[]a = { 
10
, 
10
, 
10
, 
10
, 

11
, 
10
, 
11
, 
10
, 

9
, 
9
, 
8
, 
8
}; 

int
n = a.length; 


System.out.print(MaxTotalRectangleArea(a, n)); 

} 
} 
// This code is contributed by 
// Manish Shaw(manishshaw1) ",CorCod,640,640,nlogn
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class C {

	public static int mod = 1000000000 + 7;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		String n = br.readLine();
		int k = Integer.parseInt(br.readLine());
		int l = n.length();
		
		if(k == 0) {
			System.out.println(1);
		}else {
			int max = 1000;
			if (l <= 10) {
				max = Integer.min(1000, Integer.parseInt(n, 2));
			}

			int[] steps = new int[max + 1];
					
			for (int i = 2; i <= max; i++) {
				int ones = numberOfOnes(i);
				steps[i] = 1 + steps[ones];
			}

			if (l <= 10) {
				int ans = 0;
				for (int i = 1; i <= max; i++) {
					if (steps[i] == k) {
						ans++;
					}
				}
				System.out.println(ans);
			} else {
				int[][] C = binomial(max);

				int ans = 0;
				int count = 0;

				for (int i = 0; i < l; i++) {
					if (n.charAt(i) == '1') {
						for (int j = count; j < max; j++) {
							if (steps[j] == k - 1) {
								ans = (ans + C[l - i - 1][j - count]) % mod;
								if (i == 0 && k == 1) {
									ans = (ans + mod - 1) % mod;
								}
							}
						}
						count++;
					}
				}

				int ones = 0;
				for (int i = 0; i < l; i++) {
					if (n.charAt(i) == '1') {
						ones++;
					}
				}
				if (steps[ones] == k-1) {
					ans = (ans + 1) % mod;
				}
				
				System.out.println(ans);
			}
		}
	}

	public static int numberOfOnes(int x) {
		char[] s = Integer.toBinaryString(x).toCharArray();
		int count = 0;
		for (char c : s) {
			if (c == '1') {
				count++;
			}
		}
		return count;
	}

	public static int[][] binomial(int n) {
		int[][] C = new int[n + 1][n + 1];

		for (int i = 0; i <= n; i++) {
			C[i][0] = 1;
			for (int j = 1; j <= i; j++) {
				C[i][j] = ((C[i - 1][j - 1] % mod) + (C[i - 1][j] % mod)) % mod;
			}
		}

		return C;
	}

}
",CorCod,380,380,linear
"
import
java.util.*; 
import
java.lang.*; 
class
Main 
{ 

static
void
minAbsSumPair(
int
arr[], 
int
arr_size) 

{ 

int
inv_count = 
0
; 

int
l, r, min_sum, sum, min_l, min_r; 


/* Array should have at least two elements*/

if
(arr_size < 
2
) 

{ 

System.out.println(
""Invalid Input""
); 

return
; 

} 


/* Initialization of values */

min_l = 
0
; 

min_r = 
1
; 

min_sum = arr[
0
] + arr[
1
]; 


for
(l = 
0
; l < arr_size - 
1
; l++) 

{ 

for
(r = l+
1
; r < arr_size; r++) 

{ 

sum = arr[l] + arr[r]; 

if
(Math.abs(min_sum) > Math.abs(sum)) 

{ 

min_sum = sum; 

min_l = l; 

min_r = r; 

} 

} 

} 


System.out.println(
"" The two elements whose ""
+ 

""sum is minimum are ""
+ 

arr[min_l]+ 
"" and ""
+arr[min_r]); 

} 


// main function 

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
60
, -
10
, 
70
, -
80
, 
85
}; 

minAbsSumPair(arr, 
6
); 

} 

} ",CorCod,523,523,quadratic
"import java.io.*;
import java.util.*;


public class tr {
	static int[][] ad;
    static boolean []vis;
    static int []goods;
    static int[][]sol;
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		int n=sc.nextInt();
		int []a=new int [n];
		int max=0;
		for(int i=0;i<n;i++)
			a[i]=sc.nextInt();
		Stack<Integer> s=new Stack<>();
		boolean f=true;
				for(int i=0;i<n;i++) {
					max=Math.max(max,a[i]);
					if(!s.isEmpty() && a[i]>s.peek())
						f=false;
					s.push(a[i]);
					while(!s.isEmpty()) {
						int high=s.pop();
						if(s.isEmpty() || s.peek()!=high) {
							s.push(high);
							break;
						}
						s.pop();
					}
				//	System.out.println(s+"" ""+max);
				}
				//System.out.println(f+"" ""+max);
				if(f && s.size()==0)
					out.println(""YES"");
				else if(f && s.size()==1 && s.peek()==max)
					out.println(""YES"");
				else
					out.println(""NO"");
		 out.flush();
	}
	static int gcd(int a, int b) {
		if (b == 0) {
			return a;
		}
		return gcd(b, a % b);
	}

	static class pair implements Comparable<pair> {
		int a;
		int b;

		pair(int a, int b) {
			this.a = a;
			this.b = b;
		}

		public String toString() {
			return a + "" "" + b;
		}

		@Override
		public int compareTo(pair o) {
			return  o.a-a ;
		}
	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}

		public Scanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public char nextChar() throws IOException {
			return next().charAt(0);
		}

		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
}",CorCod,298,298,linear
"import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

/* spar5h */

public class cf1 implements Runnable{    
	
	public void run() {

		InputReader s = new InputReader(System.in);
		PrintWriter w = new PrintWriter(System.out);
		
		int t = 1;
		
		while(t-- > 0) {
			
			int n = s.nextInt(), m = s.nextInt();
			
			int[] a = new int[n + 1];
			
			for(int i = 1; i <= n; i++)
				a[i] = s.nextInt();
			
			int[] b = new int[n + 1];
			
			for(int i = 1; i <= n; i++)
				b[i] = s.nextInt();
			
			ArrayList<Integer> list = new ArrayList<Integer>();
			
			list.add(a[1]);
			
			for(int i = 2; i <= n; i++) {
				list.add(b[i]); list.add(a[i]);
			}
			
			list.add(b[1]);
			
			double wt = m;
			boolean check = true;
			
			for(int i = list.size() - 1; i >= 0; i--) {
				
				if(list.get(i) <= 1) {
					check = false; break;
				}
				
				double x = wt / (list.get(i) - 1);
						
				wt += x;
			}
			
			if(check)
				w.println(wt - m);
			else
				w.println(-1);
		}
		
		w.close();
	}
	
	static class InputReader {
		
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;
		private SpaceCharFilter filter;
		
		public InputReader(InputStream stream)
		{
			this.stream = stream;
		}
		
		public int read()
		{
			if (numChars==-1) 
				throw new InputMismatchException();
			
			if (curChar >= numChars)
			{
				curChar = 0;
				try 
				{
					numChars = stream.read(buf);
				}
				catch (IOException e)
				{
					throw new InputMismatchException();
				}
				
				if(numChars <= 0)				
					return -1;
			}
			return buf[curChar++];
		}
	 
		public String nextLine()
		{
			BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
			String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
		}
		public int nextInt()
		{
			int c = read();
			
			while(isSpaceChar(c)) 
				c = read();
			
			int sgn = 1;
			
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			
			int res = 0;
			do 
			{
				if(c<'0'||c>'9') 
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			while (!isSpaceChar(c)); 
			
			return res * sgn;
		}
		
		public long nextLong() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			long res = 0;
			
			do 
			{
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			while (!isSpaceChar(c));
				return res * sgn;
		}
		
		public double nextDouble() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			double res = 0;
			while (!isSpaceChar(c) && c != '.') 
			{
				if (c == 'e' || c == 'E')
					return res * Math.pow(10, nextInt());
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			if (c == '.') 
			{
				c = read();
				double m = 1;
				while (!isSpaceChar(c)) 
				{
					if (c == 'e' || c == 'E')
						return res * Math.pow(10, nextInt());
					if (c < '0' || c > '9')
						throw new InputMismatchException();
					m /= 10;
					res += (c - '0') * m;
					c = read();
				}
			}
			return res * sgn;
		}
		
		public String readString() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do 
			{
				res.appendCodePoint(c);
				c = read();
			} 
			while (!isSpaceChar(c));
			
			return res.toString();
		}
	 
		public boolean isSpaceChar(int c) 
		{
			if (filter != null)
				return filter.isSpaceChar(c);
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}
	 
		public String next() 
		{
			return readString();
		}
		
		public interface SpaceCharFilter 
		{
			public boolean isSpaceChar(int ch);
		}
	}
    
	public static void main(String args[]) throws Exception
	{
		new Thread(null, new cf1(),""cf1"",1<<26).start();
	}
}",CorCod,85,85,linear
"import java.util.*;
import java.io.*;
public class Waw{
    
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long[] a = new long[n];
        for(int i=0;i<n;i++) a[i] = sc.nextLong();
        long[] p = new long[n];
        p[n-1] = a[n-1];
        for(int i=n-2;i>=0;i--){
            if(a[i]<p[i+1]) p[i] = p[i+1]-1;
            else p[i] = a[i];
        }
        long max = p[0];
        long res = p[0] - a[0];
        for(int i=1;i<n;i++){
            if(max < p[i]) max = p[i];
            res += max - a[i];
        }
        System.out.println(res);
    }
}",CorCod,258,258,linear
"import java.io.*;
import java.math.BigInteger;
import java.util.InputMismatchException;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class D {
    static class FastWriter {
        private final BufferedWriter bw;

        public FastWriter() {
            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));
        }

        public void print(Object object) throws IOException {
            bw.append("""" + object);
        }

        public void println(Object object) throws IOException {
            print(object);
            bw.append(""\n"");
        }

        public void close() throws IOException {
            bw.close();
        }
    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        BigInteger nextBigInteger() {
            try {
                return new BigInteger(nextLine());
            } catch (NumberFormatException e) {
                throw new InputMismatchException();
            }
        }
    }

    public static void main(String[] args) throws IOException {
        FastReader fr = new FastReader();
        FastWriter fw = new FastWriter();
        int n = fr.nextInt();
        int m = fr.nextInt();
        for (int r = 0; r < n / 2; r++) {
            for (int c = 0; c < m; c++) {
                fw.println((r + 1) + "" "" + (c + 1));
                fw.println((n - r) + "" "" + (m - c));
            }
        }
        if (n % 2 != 0) {
            int r = n / 2;
            for (int c = 0; c < m / 2; c++) {
                fw.println((r + 1) + "" "" + (c + 1));
                fw.println((r + 1) + "" "" + (m - c));
            }
            if (m % 2 != 0) fw.println((r + 1) + "" "" + (m / 2 + 1));
        }
        fw.close();
    }
}
",CorCod,516,516,quadratic
"import java.util.*;
import java.io.*;



 public class Param
{
                
      public static  void main( String[]args) 
    {
       MyScanner param = new MyScanner();
      out = new PrintWriter(new BufferedOutputStream(System.out));
      int highestcoin=param.nextInt();
      int sum=param.nextInt();
      int remainder=sum%highestcoin;
      if(remainder!=0){
         remainder=1;
      }
      else{
         remainder=0;
      }
      int count=(sum-remainder)/highestcoin;
     
       if (highestcoin>=sum){
         System.out.println(""1"");
      }
      else{
      System.out.println(count+remainder);
      }
      out.close();
}
public static PrintWriter out;
      
   //-----------MyScanner class for faster input----------
   public static class MyScanner {
      BufferedReader br;
      StringTokenizer st;
 
      public MyScanner() {
         br = new BufferedReader(new InputStreamReader(System.in));
      }
 
      String next() {
          while (st == null || !st.hasMoreElements()) {
              try {
                  st = new StringTokenizer(br.readLine());
              } catch (IOException e) {
                  e.printStackTrace();
              }
          }
          return st.nextToken();
      }
 
      int nextInt() {
          return Integer.parseInt(next());
      }
 
      long nextLong() {
          return Long.parseLong(next());
      }
 
      double nextDouble() {
          return Double.parseDouble(next());
      }
 
      String nextLine(){
          String str = """";
	  try {
	     str = br.readLine();
	  } catch (IOException e) {
	     e.printStackTrace();
	  }
	  return str;
      }
}
}
   ",CorCod,754,754,constant
"

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;

public class e {

public static class FastReader {
	BufferedReader br;
	StringTokenizer st;
	//it reads the data about the specified point and divide the data about it ,it is quite fast
	//than using direct 

	public FastReader() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}

	String next() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception r) {
				r.printStackTrace();
			}
		}
		return st.nextToken();
	}

	int nextInt() {
		return Integer.parseInt(next());//converts string to integer
	}

	double nextDouble() {
		return Double.parseDouble(next());
	}

	long nextLong() {
		return Long.parseLong(next());
	}

	String nextLine() {
		String str = """";
		try {
			str = br.readLine();
		} catch (Exception r) {
			r.printStackTrace();
		}
		return str;
	}
}
static ArrayList<String>list1=new ArrayList<String>();
static void combine(String instr, StringBuffer outstr, int index,int k)
{
	if(outstr.length()==k)
	{
		list1.add(outstr.toString());return;
	}
	if(outstr.toString().length()==0)
	outstr.append(instr.charAt(index));
    for (int i = 0; i < instr.length(); i++)
    {
        outstr.append(instr.charAt(i));
       
        combine(instr, outstr, i + 1,k);
        outstr.deleteCharAt(outstr.length() - 1);
    }
   index++;
} 
static ArrayList<ArrayList<Integer>>l=new ArrayList<>();
static void comb(int n,int k,int ind,ArrayList<Integer>list)
{
	if(k==0)
	{
		l.add(new ArrayList<>(list));

		return;
	}
	
	
	for(int i=ind;i<=n;i++)
	{
		list.add(i);
		comb(n,k-1,ind+1,list);
		
		list.remove(list.size()-1);
		
	}
	
	
	
	
	

}


public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	FastReader in=new FastReader();
	HashMap<Integer,Integer>map=new HashMap<Integer,Integer>();

	int n=in.nextInt();
	int r=in.nextInt();
	 
	double theta=(double)360/(double)n;
	 
	double b=1-((double)2/(double)(1-Math.cos((double)2*Math.PI/(double)n)));
	double x=Math.sqrt(1-b)-1;
	double ans=(double)r/(double)x;
	System.out.println(ans);





	}
}
",CorCod,778,778,constant
"//package com.krakn.CF.B1159;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n;
        n = sc.nextInt();
        int[] arr = new int[n];

        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        int min = 1000000000, temp;

        for (int i = 0; i < n; i++) {
            temp = arr[i] / Math.max(i, n - 1 - i);
            if (temp < min)
                min = temp;
//            System.out.println(i + "" "" + temp);
        }

        System.out.println(min);
    }
}
",CorCod,167,167,linear
"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Main
{
	public static void main (String[] args) throws java.lang.Exception
	{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int n=Integer.parseInt(br.readLine());
		int[] A=new int[n];
		String[] s=br.readLine().split("" "");
		for(int i=0;i<n;i++){
			A[i]=Integer.parseInt(s[i]);
		}
		Map memo=new HashMap();
		int[] f=new int[n];
		for(int i=0;i<n;i++){
			if(!memo.containsKey(A[i])){
				memo.put(A[i],1);
			}
			else{
				int ct=(int)memo.get(A[i]);
				memo.put(A[i],ct+1);
			}
			int tot=0;
			if(memo.containsKey(A[i]-1)){
				tot+=(int)memo.get(A[i]-1);
			}
			if(memo.containsKey(A[i]+1)){
				tot+=(int)memo.get(A[i]+1);
			}
			tot+=(int)memo.get(A[i]);
			f[i]=tot;
		}
		BigInteger res=new BigInteger(""0"");
		for(int i=0;i<n;i++){
			int tot1=i+1-f[i];
			int tot2=0;
			if(memo.containsKey(A[i]-1)){
				tot2+=(int)memo.get(A[i]-1);
			}
			if(memo.containsKey(A[i]+1)){
				tot2+=(int)memo.get(A[i]+1);
			}
			tot2+=(int)memo.get(A[i]);
			tot2=n-i-1-(tot2-f[i]);
			//res+=(long)(tot1-tot2)*(long)A[i];
			res=res.add(BigInteger.valueOf((long)(tot1-tot2)*(long)A[i]));
		}
		System.out.println(res);
	}
}",CorCod,594,594,nlogn
"
// Java program to keep track of maximum 
// element in a stack 
import
java.util.*; 
class
GfG { 

static
class
StackWithMax 
{ 

// main stack 

static
Stack<Integer> mainStack = 
new
Stack<Integer> (); 


// tack to keep track of max element 

static
Stack<Integer> trackStack = 
new
Stack<Integer> (); 

static
void
push(
int
x) 

{ 

mainStack.push(x); 

if
(mainStack.size() == 
1
) 

{ 

trackStack.push(x); 

return
; 

} 


// If current element is greater than 

// the top element of track stack, push 

// the current element to track stack 

// otherwise push the element at top of 

// track stack again into it. 

if
(x > trackStack.peek()) 

trackStack.push(x); 

else

trackStack.push(trackStack.peek()); 

} 


static
int
getMax() 

{ 

return
trackStack.peek(); 

} 


static
void
pop() 

{ 

mainStack.pop(); 

trackStack.pop(); 

} 
}; 

// Driver program to test above functions 
public
static
void
main(String[] args) 
{ 

StackWithMax s = 
new
StackWithMax(); 

s.push(
20
); 

System.out.println(s.getMax()); 

s.push(
10
); 

System.out.println(s.getMax()); 

s.push(
50
); 

System.out.println(s.getMax()); 
} 
} ",CorCod,828,828,constant
"
class
Profit 
{ 

// Returns maximum profit with two transactions on a given 

// list of stock prices, price[0..n-1] 

static
int
maxProfit(
int
price[], 
int
n) 

{ 

// Create profit array and initialize it as 0 

int
profit[] = 
new
int
[n]; 

for
(
int
i=
0
; i<n; i++) 

profit[i] = 
0
; 


/* Get the maximum profit with only one transaction 

allowed. After this loop, profit[i] contains maximum 

profit from price[i..n-1] using at most one trans. */

int
max_price = price[n-
1
]; 

for
(
int
i=n-
2
;i>=
0
;i--) 

{ 

// max_price has maximum of price[i..n-1] 

if
(price[i] > max_price) 

max_price = price[i]; 


// we can get profit[i] by taking maximum of: 

// a) previous maximum, i.e., profit[i+1] 

// b) profit by buying at price[i] and selling at 

// max_price 

profit[i] = Math.max(profit[i+
1
], max_price-price[i]); 

} 


/* Get the maximum profit with two transactions allowed 

After this loop, profit[n-1] contains the result */

int
min_price = price[
0
]; 

for
(
int
i=
1
; i<n; i++) 

{ 

// min_price is minimum price in price[0..i] 

if
(price[i] < min_price) 

min_price = price[i]; 


// Maximum profit is maximum of: 

// a) previous maximum, i.e., profit[i-1] 

// b) (Buy, Sell) at (min_price, price[i]) and add 

// profit of other trans. stored in profit[i] 

profit[i] = Math.max(profit[i-
1
], profit[i] + 

(price[i]-min_price) ); 

} 

int
result = profit[n-
1
]; 

return
result; 

} 



public
static
void
main(String args[]) 

{ 

int
price[] = {
2
, 
30
, 
15
, 
10
, 
8
, 
25
, 
80
}; 

int
n = price.length; 

System.out.println(
""Maximum Profit = ""
+ maxProfit(price, n)); 

} 

}
/* This code is contributed by Rajat Mishra */",CorCod,240,240,linear
"
// A O(n) C++ program to count number of substrings 
//starting and ending with 1 

class
CountSubString 
{ 

int
countSubStr(
char
str[], 
int
n) 

{ 

int
m = 
0
; 
// Count of 1's in input string 


// Traverse input string and count of 1's in it 

for
(
int
i = 
0
; i < n; i++) 

{ 

if
(str[i] == 
'1'
) 

m++; 

} 


// Return count of possible pairs among m 1's 

return
m * (m - 
1
) / 
2
; 

} 


// Driver program to test the above function 

public
static
void
main(String[] args) 

{ 

CountSubString count = 
new
CountSubString(); 

String string = 
""00100101""
; 

char
str[] = string.toCharArray(); 

int
n = str.length; 

System.out.println(count.countSubStr(str, n)); 

} 
} ",CorCod,60,60,linear
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Solution {

	static long MOD = 1_000_000_000 + 7;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		long n = Long.parseLong(st.nextToken());
		long m = Long.parseLong(st.nextToken());
		long k = Long.parseLong(st.nextToken());
		long l = Long.parseLong(st.nextToken());

		long p = (l + k) / m;

		if (p * m != l + k) {
			p++;
		}

		if (m * p <= n) {
			System.out.println(p);
		} else {
			System.out.println(-1);
		}

	}
}",CorCod,793,793,constant
"import java.util.*;

public class helloWorld 
{
	static ArrayList<Integer> ar;
	public static void main(String[] args) 
	{		
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		StringBuilder ans = new StringBuilder();
		if(n <= 2)
			ans.append(""No"");
		else if(n == 4) {
			ans.append(""Yes\n"");
			ans.append(""1 2\n"");
			ans.append(""3 1 3 4\n"");
		}
		else  {
			ans.append(""Yes\n"");
			if(n % 2 == 1) {
				int a = (n+1)/2;
				ans.append(""1 "");
				ans.append(a);
				ans.append(""\n"");
				ans.append(n-1);
				for(int i = 1; i < a; i++)
					ans.append("" "" + i);
				for(int i = a+1; i <= n; i++)
					ans.append("" "" + i);
			}
			else {
				int a = n/2;
				ans.append(""2 "");
				ans.append(a + "" "");
				ans.append(a+1 + "" \n"");
				ans.append(n-2);
				for(int i = 1; i < a; i++)
					ans.append("" "" + i);
				for(int i = a+2; i <= n; i++)
					ans.append("" "" + i);
			}
		}
		
		System.out.println(ans);
		
		in.close();
	}
}",CorCod,242,242,linear
"import java.util.*;

public class A912 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		Scanner scan = new Scanner(System.in);
		
		int A = scan.nextInt();
		int B = scan.nextInt();
		long x = scan.nextInt();
		long y = scan.nextInt();
		long z = scan.nextInt();
		
		long requiredA = x * 2 + y;
		long requiredB = y + z * 3;
		
		long neededA = Math.max(0, requiredA - A);
		long neededB = Math.max(0, requiredB - B);
		System.out.print(neededA + neededB);
	}

}
",CorCod,818,818,constant
"
// Java code to add all greater values to 
// every node in a given BST 

// A binary tree node 
class
Node { 


int
data; 

Node left, right; 


Node(
int
d) 

{ 

data = d; 

left = right = 
null
; 

} 
} 

class
BinarySearchTree { 


// Root of BST 

Node root; 


// Constructor 

BinarySearchTree() 

{ 

root = 
null
; 

} 


// Inorder traversal of the tree 

void
inorder() 

{ 

inorderUtil(
this
.root); 

} 


// Utility function for inorder traversal of 

// the tree 

void
inorderUtil(Node node) 

{ 

if
(node == 
null
) 

return
; 


inorderUtil(node.left); 

System.out.print(node.data + 
"" ""
); 

inorderUtil(node.right); 

} 


// adding new node 

public
void
insert(
int
data) 

{ 

this
.root = 
this
.insertRec(
this
.root, data); 

} 


/* A utility function to insert a new node with 

given data in BST */

Node insertRec(Node node, 
int
data) 

{ 

/* If the tree is empty, return a new node */

if
(node == 
null
) { 

this
.root = 
new
Node(data); 

return
this
.root; 

} 


/* Otherwise, recur down the tree */

if
(data <= node.data) { 

node.left = 
this
.insertRec(node.left, data); 

} 
else
{ 

node.right = 
this
.insertRec(node.right, data); 

} 

return
node; 

} 


// This class initialises the value of sum to 0 

public
class
Sum { 

int
sum = 
0
; 

} 


// Recursive function to add all greater values in 

// every node 

void
modifyBSTUtil(Node node, Sum S) 

{ 

// Base Case 

if
(node == 
null
) 

return
; 


// Recur for right subtree 

this
.modifyBSTUtil(node.right, S); 


// Now *sum has sum of nodes in right subtree, add 

// root->data to sum and update root->data 

S.sum = S.sum + node.data; 

node.data = S.sum; 


// Recur for left subtree 

this
.modifyBSTUtil(node.left, S); 

} 


// A wrapper over modifyBSTUtil() 

void
modifyBST(Node node) 

{ 

Sum S = 
new
Sum(); 

this
.modifyBSTUtil(node, S); 

} 


// Driver Function 

public
static
void
main(String[] args) 

{ 

BinarySearchTree tree = 
new
BinarySearchTree(); 


/* Let us create following BST 

50 

/ \ 

30 70 

/ \ / \ 

20 40 60 80 */


tree.insert(
50
); 

tree.insert(
30
); 

tree.insert(
20
); 

tree.insert(
40
); 

tree.insert(
70
); 

tree.insert(
60
); 

tree.insert(
80
); 


tree.modifyBST(tree.root); 


// print inoder tarversal of the modified BST 

tree.inorder(); 

} 
} 

// This code is contributed by Kamal Rawal ",CorCod,290,290,linear
"import java.io.*;
import java.util.*;

public class cf {
    static class FastScanner {
        BufferedReader br;
        StringTokenizer st;
        
        public FastScanner(Reader in) {
            br = new BufferedReader(in);
        }
        
        public FastScanner() {
            this(new InputStreamReader(System.in));
        }
        
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
 
        int nextInt() {
            return Integer.parseInt(next());
        }
        
        long nextLong() {
            return Long.parseLong(next());
        }
        
        double nextDouble() {
            return Double.parseDouble(next());
        }
        
        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        
        int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextInt();
            }
            return a;
        }
    }

    static int mod = 1000000007;
    
	public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        PrintWriter pw = new PrintWriter(System.out); 

        int n=sc.nextInt(), k = sc.nextInt();
        int[] a = new int[n+1];

        for(int i=0;i<n;i++) {
            a[i] = sc.nextInt();
        }
        a[n] = 0;
        Arrays.sort(a);

        for(int i=1;i<=n;i++) {
            if(k == 0) {
                break;
            }
            if(a[i] != a[i-1]) {
                k--;
                pw.println(a[i] - a[i-1]);
            }
        }
        for(int i=0;i<k;i++) pw.println(0);
        pw.close();
    }
}
",CorCod,605,605,nlogn
"import java.util.*;
import java.io.*;
import java.math.*;

public class round569d2b {

	public static void main(String args[]) {
		FastScanner in = new FastScanner(System.in);
		
		int n = in.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = in.nextInt();
		}
		if (n % 2 == 0) {
			for (int i = 0; i < n; i++) {
				if (arr[i] >= 0) {
					arr[i] = -1*arr[i]-1;
				}
			}
		}
		else {
			int max = Integer.MIN_VALUE;
			int maxIndex = 0;
			for (int i = 0; i < n; i++) {
				int elem = arr[i];
				if (elem < 0) {
					elem = -1*elem-1;
				}
				if (elem > max) {
					max = elem;
					maxIndex = i;
				}
			}
			for (int i = 0; i < n; i++) {
				if (i == maxIndex) {
					if (arr[i] < 0) {
						arr[i] = -1*arr[i]-1;
					}
				}
				else {
					if (arr[i] >= 0) {
						arr[i] = -1*arr[i]-1;
					}
				}
			}
		}
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < n ;i++) {
			sb.append(arr[i] + "" "");
			
		}
		System.out.println(sb);

	}

	// ======================================================================================
	// =============================== Reference Code =======================================
	// ======================================================================================

	static int greatestDivisor(int n) {
		int limit = (int) Math.sqrt(n);
		int max = 1;
		for (int i = 2; i <= limit; i++) {
			if (n % i == 0) {
				max = Integer.max(max, i);
				max = Integer.max(max, n / i);
			}
		}
		return max;
	}

	// Method to return all primes smaller than or equal to 
	// n using Sieve of Eratosthenes 
	static boolean[] sieveOfEratosthenes(int n) {
		// Create a boolean array ""prime[0..n]"" and initialize 
		// all entries it as true. A value in prime[i] will 
		// finally be false if i is Not a prime, else true. 
		boolean prime[] = new boolean[n + 1];
		for (int i = 0; i <= n; i++)
			prime[i] = true;

		prime[0] = false;
		prime[1] = false;

		for (int p = 2; p * p <= n; p++) {
			// If prime[p] is not changed, then it is a prime 
			if (prime[p] == true) {
				// Update all multiples of p 
				for (int i = p * p; i <= n; i += p)
					prime[i] = false;
			}
		}

		return prime;
	}

	// Binary search for number greater than or equal to target
	// returns -1 if number not found
	private static int bin_gteq(int[] a, int key) {
		int low = 0;
		int high = a.length;
		int max_limit = high;
		while (low < high) {
			int mid = low + (high - low) / 2;
			if (a[mid] < key) {
				low = mid + 1;
			} else
				high = mid;
		}

		return high == max_limit ? -1 : high;
	}

	public static int gcd(int a, int b) {
		if (a == 0)
			return b;

		return gcd(b % a, a);
	}

	static class Tuple<X, Y> {
		public final X x;
		public final Y y;

		public Tuple(X x, Y y) {
			this.x = x;
			this.y = y;
		}

		public String toString() {
			return ""("" + x + "","" + y + "")"";
		}
	}

	static class Tuple3<X, Y, Z> {
		public final X x;
		public final Y y;
		public final Z z;

		public Tuple3(X x, Y y, Z z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public String toString() {
			return ""("" + x + "","" + y + "","" + z + "")"";
		}
	}

	static Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {
		// Base Case 
		if (a == 0) {
			x = 0;
			y = 1;
			return new Tuple3(0, 1, b);
		}

		int x1 = 1, y1 = 1; // To store results of recursive call 
		Tuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);
		int gcd = tuple.z;
		x1 = tuple.x;
		y1 = tuple.y;

		// Update x and y using results of recursive 
		// call 
		x = y1 - (b / a) * x1;
		y = x1;

		return new Tuple3(x, y, gcd);
	}

	// Returns modulo inverse of a  
	// with respect to m using extended 
	// Euclid Algorithm. Refer below post for details: 
	// https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/ 
	static int inv(int a, int m) {
		int m0 = m, t, q;
		int x0 = 0, x1 = 1;

		if (m == 1)
			return 0;

		// Apply extended Euclid Algorithm 
		while (a > 1) {
			// q is quotient 
			q = a / m;

			t = m;

			// m is remainder now, process 
			// same as euclid's algo 
			m = a % m;
			a = t;

			t = x0;

			x0 = x1 - q * x0;

			x1 = t;
		}

		// Make x1 positive 
		if (x1 < 0)
			x1 += m0;

		return x1;
	}

	// k is size of num[] and rem[]. 
	// Returns the smallest number 
	// x such that: 
	// x % num[0] = rem[0], 
	// x % num[1] = rem[1], 
	// .................. 
	// x % num[k-2] = rem[k-1] 
	// Assumption: Numbers in num[] are pairwise  
	// coprime (gcd for every pair is 1) 
	static int findMinX(int num[], int rem[], int k) {
		// Compute product of all numbers 
		int prod = 1;
		for (int i = 0; i < k; i++)
			prod *= num[i];

		// Initialize result 
		int result = 0;

		// Apply above formula 
		for (int i = 0; i < k; i++) {
			int pp = prod / num[i];
			result += rem[i] * inv(pp, num[i]) * pp;
		}

		return result % prod;
	}

	/**
	 * Source: Matt Fontaine
	 */
	static class FastScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int chars;

		public FastScanner(InputStream stream) {
			this.stream = stream;
		}

		int read() {
			if (chars == -1)
				throw new InputMismatchException();
			if (curChar >= chars) {
				curChar = 0;
				try {
					chars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (chars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}

}",CorCod,276,276,linear
"
 import java.io.*;

import java.util.*;
import java.util.Collections;
import java.util.Arrays;


public class Codechef {
     

  public static void main(String[] args) throws IOException {
	Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int a=sc.nextInt();
    int b=sc.nextInt();
      int res=0;
     for(int i=1;i<n;i++)
     res=Math.max(res, Math.min(a/i, b/(n-i) ) );
     System.out.println(res);
  }

   }
  








",CorCod,135,135,linear
"
import java.io.*;
import java.util.*;

public class IntegerSequenceDividing {
	static PrintWriter pw = new PrintWriter(System.out);
	public static void main(String[] args) throws IOException{
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		if(n%2==0)
		{
			n=n/2;
			if(n%2==0)
				System.out.println(0);
			else
				System.out.println(1);
		}else
		{
			n++;
			n=n/2;
			if(n%2==0)
				System.out.println(0);
			else
				System.out.println(1);
		}
	}
	static class Scanner {
		StringTokenizer st;
		BufferedReader br;
 
		public Scanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}
 
		public Scanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}
 
		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}
 
		public String nextLine() throws IOException {
			return br.readLine();
		}
 
		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}
 
		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}
 
		public char nextChar() throws IOException {
			return next().charAt(0);
		}
 
		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}
 
		public boolean ready() throws IOException {
			return br.ready();
		}
 
		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
}
",CorCod,866,866,constant
"import java.util.*;

public class ehab4 {
    public static void main( String[] args ) {
        Scanner in = new Scanner( System.in );
	int a = 0, b = 0;
	System.out.println( ""? 0 0 "" );
	System.out.flush();
	int c = in.nextInt();
	for ( int i = 29; i >= 0; i-- ) {
	    System.out.println( ""? "" + ( a + ( 1 << i ) ) + "" "" + b );
	    System.out.flush();
	    int q1 = in.nextInt();
	    System.out.println( ""? "" + a + "" "" + ( b + ( 1 << i ) ) );
	    System.out.flush();
	    int q2 = in.nextInt();
	    if ( q1 == q2 ) {
		if ( c == 1 )
		    a += ( 1 << i );
		else if ( c == -1 )
		    b += ( 1 << i );
		c = q1;
	    }
	    else if ( q1 == -1 ) {
		a += ( 1 << i );
		b += ( 1 << i );
	    }
	    else if ( q1 == -2 )
		return;
	}
	System.out.println( ""! "" + a + "" "" + b );
	System.out.flush();
    }
}
",CorCod,891,891,logn
"
// Java Program to find the ""GFG"" subsequence 
// in the given string 

public
class
GFG { 


static
int
max = 
100
; 


// Print the count of ""GFG"" subsequence 

// in the string 

static
void
countSubsequence(String s, 
int
n) 

{ 

int
cntG = 
0
, cntF = 
0
, result = 
0
, C=
0
; 


// Traversing the given string 

for
(
int
i = 
0
; i < n; i++) { 

switch
(s.charAt(i)) { 


// If the character is 'G', 

// increment the count of 'G', 

// increase the result and 

// update the array. 

case
'G'
: 

cntG++; 

result+=C; 

break
; 


// If the character is 'F', 

// increment the count of 'F' 

// and update the array. 

case
'F'
: 

cntF++; 

C+=cntG; 

break
; 


// Ignore other character. 

default
: 

continue
; 

} 

} 


System.out.println(result); 

} 


// Driver code 

public
static
void
main(String args[]) { 

String s= 
""GFGFG""
; 

int
n = s.length(); 

countSubsequence(s, n); 

} 
} 

// This code is contributed by Sam007 ",CorCod,221,221,linear
"
// Java program to find Minimum 
// number of jumps to reach end 
class
GFG 
{ 
// Returns Minimum number 
// of jumps to reach end 
static
int
minJumps(
int
arr[], 

int
n) 
{ 

// jumps[0] will 

// hold the result 

int
[] jumps = 
new
int
[n]; 

int
min; 


// Minimum number of jumps 

// needed to reach last 

// element from last elements 

// itself is always 0 

jumps[n - 
1
] = 
0
; 



// Start from the second 

// element, move from right 

// to left and construct the 

// jumps[] array where jumps[i] 

// represents minimum number of 

// jumps needed to reach arr[m-1] 

// from arr[i] 

for
(
int
i = n - 
2
; i >= 
0
; i--) 

{ 

// If arr[i] is 0 then arr[n-1] 

// can't be reached from here 

if
(arr[i] == 
0
) 

jumps[i] = Integer.MAX_VALUE; 


// If we can direcly reach to 

// the end point from here then 

// jumps[i] is 1 

else
if
(arr[i] >= n - i - 
1
) 

jumps[i] = 
1
; 


// Otherwise, to find out 

// the minimum number of 

// jumps needed to reach 

// arr[n-1], check all the 

// points reachable from 

// here and jumps[] value 

// for those points 

else

{ 

// initialize min value 

min = Integer.MAX_VALUE; 


// following loop checks 

// with all reachable points 

// and takes the minimum 

for
(
int
j = i + 
1
; j < n && 

j <= arr[i] + i; j++) 

{ 

if
(min > jumps[j]) 

min = jumps[j]; 

} 


// Handle overflow 

if
(min != Integer.MAX_VALUE) 

jumps[i] = min + 
1
; 

else

jumps[i] = min; 
// or Integer.MAX_VALUE 

} 

} 


return
jumps[
0
]; 
} 

// Driver Code 
public
static
void
main(String[] args) 
{ 

int
[] arr = {
1
, 
3
, 
6
, 
1
, 
0
, 
9
}; 

int
size = arr.length; 

System.out.println(
""Minimum number of""
+ 

"" jumps to reach end is ""
+ 

minJumps(arr, size)); 

} 
} 

// This code is contributed by mits. ",CorCod,463,463,quadratic
"import java.util.*;
public class Main{
	public static void main(String args[]){
		Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int k=sc.nextInt();
        if(n==k){
            String s=new String();
            for(int i=0;i<k;i++){
                s=s+""1"";
            }
            System.out.println(s);
        }
        else{
            int a=(n-k)/2;
            String s=new String();
                for(int i=0;i<a && s.length()<n;i++){
                    s=s+""1"";
                }
                if(s.length()<n){
                    s=s+""0"";
                }
            while(s.length()<n){
                s=s+s;
            }
            String s1=new String();
            for(int i=0;i<n;i++){
                s1=s1+Character.toString(s.charAt(i));
            }
            System.out.println(s1);
        }
	}
}",CorCod,312,312,linear
"import java.util.*;
import java.io.*;

import static java.lang.Math.*;

public class Main {
    static int n;
     static long TotalTime;
    static Problem[] problems;
    static StringBuilder sb;
    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        sb = new StringBuilder();
        n = sc.nextInt();
        TotalTime = sc.nextLong();
        problems = new Problem[n];
        for (int i = 0; i < n; i++) {
            problems[i] = new Problem (sc.nextInt(), sc.nextLong(), i);
        }
        Arrays.sort(problems);
        long num = -1;
        long high = n;
        long low = 0;
        int iter = 0;
        while (high - low > 1) {
            num = (high + low) / 2;
            if (test(num, false)) {
                low = num;
            }
            else {
                high = num;
            }
        }
        if (test(high, false))
            num = high;
        else
            num = low;
        test(num, true);
        System.out.print(sb);
    }

    public static boolean test (long num, boolean print) {
        int count = 0;
        long sum = 0L;
        if (print) sb.append(num + ""\n"" + num + ""\n"");
        for (int i = 0; i < n && count < num; i++) {
            if (problems[i].a >= num) {
                count++;
                sum += problems[i].t;
                if (print) sb.append((problems[i].index + 1) + "" "");
            }
        }
        return (count == num) && (sum <= TotalTime);
    }

    public static class Problem implements Comparable<Problem>  {
        int a;
        long t;
        int index;
        
        public int compareTo(Problem o) {
          return Long.compare(t, o.t);
        }
        public Problem (int a, long t, int index) {
            this.a = a;
            this.t = t;
            this.index = index;
        }
    }


    public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(Reader in) {
            br = new BufferedReader(in);
        }

        public FastScanner() {
            this(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String readNextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        int[] readIntArray(int n) {
            int[] a = new int[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextInt();
            }
            return a;
        }

        long[] readLongArray(int n) {
            long[] a = new long[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextLong();
            }
            return a;
        }
    }
}",CorCod,616,616,nlogn
"import java.util.Scanner;
public class Codeforces {
    public static Scanner input = new Scanner(System.in);
    public static void main(String[] args){
        int n,k;
        n=input.nextInt();
        k=input.nextInt();
        String s=input.next();
        int[] wtArray=new int[n];
        for(int i=0;i<s.length();i++)
            wtArray[i]=s.charAt(i)-96;
        for(int i=1;i<n;i++)
            for(int j=0;j<n-i;j++)
                if(wtArray[j]>wtArray[j+1]){
                    int temp=wtArray[j+1];
                    wtArray[j+1]=wtArray[j];
                    wtArray[j]=temp;
                }

        int sum=wtArray[0];
        k--;
        int temp=sum;
        for(int i=1;k!=0 &&i <n;i++){
            if((wtArray[i]-temp)>1){
                sum+=wtArray[i];
                k--;
                temp=wtArray[i];
            }
        }
        if(k!=0)
            sum=-1;
        System.out.println(sum);
    }

}",CorCod,459,459,quadratic
"
// Java program to find number of 
// rotations in a sorted and rotated 
// array. 
import
java.util.*; 
import
java.lang.*; 
import
java.io.*; 

class
BinarySearch 
{ 

// Returns count of rotations for an array 

// which is first sorted in ascending order, 

// then rotated 

static
int
countRotations(
int
arr[], 
int
low, 

int
high) 

{ 

// This condition is needed to handle 

// the case when array is not rotated 

// at all 

if
(high < low) 

return
0
; 


// If there is only one element left 

if
(high == low) 

return
low; 


// Find mid 

// /*(low + high)/2;*/ 

int
mid = low + (high - low)/
2
; 


// Check if element (mid+1) is minimum 

// element. Consider the cases like 

// {3, 4, 5, 1, 2} 

if
(mid < high && arr[mid+
1
] < arr[mid]) 

return
(mid + 
1
); 


// Check if mid itself is minimum element 

if
(mid > low && arr[mid] < arr[mid - 
1
]) 

return
mid; 


// Decide whether we need to go to left 

// half or right half 

if
(arr[high] > arr[mid]) 

return
countRotations(arr, low, mid - 
1
); 


return
countRotations(arr, mid + 
1
, high); 

} 


// Driver program to test above functions 

public
static
void
main (String[] args) 

{ 

int
arr[] = {
15
, 
18
, 
2
, 
3
, 
6
, 
12
}; 

int
n = arr.length; 


System.out.println(countRotations(arr, 
0
, n-
1
)); 

} 
} 
// This code is contributed by Chhavi ",CorCod,889,889,logn
"
// Java program to check whether a given 
// Binary Tree is Perfect or not 
class
GfG { 

/* Tree node structure */
static
class
Node 
{ 

int
key; 

Node left, right; 
} 

// Returns depth of leftmost leaf. 
static
int
findADepth(Node node) 
{ 
int
d = 
0
; 
while
(node != 
null
) 
{ 

d++; 

node = node.left; 
} 
return
d; 
} 

/* This function tests if a binary tree is perfect 
or not. It basically checks for two things : 
1) All leaves are at same level 
2) All internal nodes have two children */
static
boolean
isPerfectRec(Node root, 
int
d, 
int
level) 
{ 

// An empty tree is perfect 

if
(root == 
null
) 

return
true
; 


// If leaf node, then its depth must be same as 

// depth of all other leaves. 

if
(root.left == 
null
&& root.right == 
null
) 

return
(d == level+
1
); 


// If internal node and one child is empty 

if
(root.left == 
null
|| root.right == 
null
) 

return
false
; 


// Left and right subtrees must be perfect. 

return
isPerfectRec(root.left, d, level+
1
) && isPerfectRec(root.right, d, level+
1
); 
} 

// Wrapper over isPerfectRec() 
static
boolean
isPerfect(Node root) 
{ 
int
d = findADepth(root); 
return
isPerfectRec(root, d, 
0
); 
} 

/* Helper function that allocates a new node with the 
given key and NULL left and right pointer. */
static
Node newNode(
int
k) 
{ 

Node node = 
new
Node(); 

node.key = k; 

node.right = 
null
; 

node.left = 
null
; 

return
node; 
} 

// Driver Program 
public
static
void
main(String args[]) 
{ 

Node root = 
null
; 

root = newNode(
10
); 

root.left = newNode(
20
); 

root.right = newNode(
30
); 


root.left.left = newNode(
40
); 

root.left.right = newNode(
50
); 

root.right.left = newNode(
60
); 

root.right.right = newNode(
70
); 


if
(isPerfect(root) == 
true
) 

System.out.println(
""Yes""
); 

else

System.out.println(
""No""
); 
} 
} ",CorCod,201,201,linear
"import java.util.*;
import java.lang.*;
import java.io.*;
public class TestClass {
    // function for finding size of set
    public static int set_size(int[] a, int N){
        HashSet <Integer> newset = new HashSet <Integer>();
        int i=0;
        while(i<N){
            newset.add(a[i++]);
        }
        int v = newset.size();
        return v;
    }
    public static void main(String args[] ) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
       StringTokenizer tk = new StringTokenizer(br.readLine());
            int N = Integer.parseInt(tk.nextToken());
            int x = Integer.parseInt(tk.nextToken());
            
            int[] a = new int[N];
            int[] b = new int[N];
            StringTokenizer tb = new StringTokenizer(br.readLine());
            for(int i=0; i<N; i++){
                a[i] = Integer.parseInt(tb.nextToken());
            }
            if(set_size(a, N) < N){
                System.out.print(""0"");
                System.exit(0);
            }
            int num=0;
        while(num++<4){
            for(int i=0; i<N; i++){
                if((a[i]&x) == a[i])
                    continue;
                else{
                    for(int j=0; j<N; j++){
                        if(i==j){
                            b[i] = (a[i]&x);
                        }
                        else{
                            b[j] = a[j];
                        }
                    }
                    int s = set_size(b, N);
                    if(s<N){
                        System.out.print(num);
                        System.exit(0);
                    }
                }
            }
            for(int i=0; i<N; i++)
                a[i] = b[i];
        }
        System.out.print(""-1"");
        System.exit(0);
    }
}",CorCod,444,444,quadratic
"import java.util.*;
import static java.lang.Math.*;
import java.io.*;

public class SolutionB {
       
      public static void main(String args[])throws IOException{
              Scanner sc = new Scanner(System.in);
              int n = sc.nextInt();
              int k = sc.nextInt();
              Set<Integer> set1 = new HashSet<Integer>();
              Set<Integer> set2 = new HashSet<Integer>();
              int a[] = new int[n];
              for(int i = 0; i < n; i++){
                     a[i] = sc.nextInt();
                     if(!set1.contains(a[i])){
                            set1.add(a[i]);
                     }else{
                            System.out.println(0);
                            return;
                     }
              }
              for(int i = 0; i < n; i++){
                     int b = a[i] & k;
                     if(b != a[i] && set1.contains(b)){
                            System.out.println(1);
                            return;
                     }
                     //if(!set2.contains(b)){
                            //set2.add(b);
                     //}else{
                       //     System.out.println(2);
                         //   return;
                     //}
              }
              for(int i = 0; i < n; i++){
                     int b = a[i] & k;
                     if(b != a[i] && set2.contains(b)){
                            System.out.println(2);
                            return;
                     }else{
                            set2.add(b);
                     }
              }
              System.out.println(-1);
      }
}",CorCod,78,78,linear
"//Author: Patel Rag
//Java version ""1.8.0_211""
import java.util.*;
import java.io.*;

public class Main
{
  static class FastReader
  {
    BufferedReader br;
    StringTokenizer st;

    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }

    String next()
    {
      while (st == null || !st.hasMoreElements())
      {
        try
        {
          st = new StringTokenizer(br.readLine());
        }
        catch (IOException  e)
        {
          e.printStackTrace();
        }
      }
      return st.nextToken();
    }

    int nextInt() { return Integer.parseInt(next()); }

    long nextLong(){ return Long.parseLong(next()); }

    double nextDouble(){ return Double.parseDouble(next()); }

    float nextFloat() { return Float.parseFloat(next()); }

    boolean nextBoolean() { return Boolean.parseBoolean(next()); }

    String nextLine()
    {
      String str = """";
      try
      {
        str = br.readLine();
      }
      catch (IOException e)
      {
        e.printStackTrace();
      }
      return str;
    }
  }
  static long modExp(long x, long n, long mod)    //binary Modular exponentiation
  {
    long result = 1;
    while(n > 0)
    {
        if(n % 2 == 1)
            result = (result%mod * x%mod)%mod;
        x = (x%mod * x%mod)%mod;
        n=n/2;
    }
    return result;
  }
  static long gcd(long a, long b)
  {
    if(a==0) return b;
    return gcd(b%a,a);
  }
  public static void main(String[] args)
  throws IOException
  {
    FastReader fr = new FastReader();
    int n = fr.nextInt();
    int q = fr.nextInt();
    long[] a = new long[n];
    long[] k = new long[q];
    for(int i = 0; i < n; i++) a[i] = fr.nextLong();
    for(int i = 0; i < q; i++) k[i] = fr.nextLong();
    long[] pre = new long[n];
    pre[0] = a[0];
    for(int i = 1; i < n; i++) pre[i] = pre[i-1] + a[i];
    long pd = 0;
    for(int i = 0; i < q; i++)
    {
      int l = 0;
      int r = n - 1;
      while(r > l)
      {
        int mid = (l + r) >> 1;

        if(pre[mid] - pd < k[i])
        {
          l = mid + 1;
        }
        else if(pre[mid] - pd > k[i])
        {
          r = mid - 1;
        }
        else
        {
          l = r = mid;
        }
      }
      int ans = 0;
      if(pre[l] - pd <= k[i])
      {
        ans = n - l - 1;
      }
      else
      {
        ans = n - l;
      }
      if(ans == 0) ans  = n;
      pd = pd + k[i];
      if(pd >= pre[n-1]) pd = 0;
      System.out.println(ans);
    }
  }
}
class pair
{
  public int first;
  public int second;
  public pair(int first,int second)
  {
    this.first = first;
    this.second = second;
  }
  public pair(pair p)
  {
    this.first = p.first;
    this.second = p.second;
  }
  public int first() { return first; }
  public int second() { return second; }
  public void setFirst(int first) { this.first = first; }
  public void setSecond(int second) { this.second = second; }
}
class myComp implements Comparator<pair>
{
  public int compare(pair a,pair b)
  {
    if(a.first != b.first) return (a.first - b.first);
    return (b.second - a.second);
  }
}
class BIT       //Binary Indexed Tree aka Fenwick Tree
{
  public long[] m_array;

  public BIT(long[] dat)
  {
    m_array = new long[dat.length + 1];
    Arrays.fill(m_array,0);
    for(int i = 0; i < dat.length; i++)
    {
      m_array[i + 1] = dat[i];
    }
    for(int i = 1; i < m_array.length; i++)
    {
      int j = i + (i & -i);
      if(j < m_array.length)
      {
        m_array[j] = m_array[j] + m_array[i];
      }
    }
  }

  public final long prefix_query(int i)
  {
    long result = 0;
    for(++i; i > 0; i = i - (i & -i))
    {
      result = result + m_array[i];
    }
    return result;
  }

  public final long range_query(int fro, int to)
  {
    if(fro == 0)
    {
      return prefix_query(to);
    }
    else
    {
      return (prefix_query(to) - prefix_query(fro - 1));
    }
  }

  public void update(int i, long add)
  {
    for(++i; i < m_array.length; i = i + (i & -i))
    {
      m_array[i] = m_array[i] + add;
    }
  }
}
",CorCod,614,614,nlogn
"
// Java program to split array and move first 
// part to end. 
import
java.util.*; 
import
java.lang.*; 
class
GFG { 


// Function to spilt array and 

// move first part to end 

public
static
void
SplitAndAdd(
int
[] A,
int
length,
int
rotation){ 


//make a temporary array with double the size 

int
[] tmp = 
new
int
[length*
2
]; 


// copy array element in to new array twice 

System.arraycopy(A, 
0
, tmp, 
0
, length); 

System.arraycopy(A, 
0
, tmp, length, length); 

for
(
int
i=rotation;i<rotation+length;i++) 

A[i-rotation]=tmp[i]; 

} 



// Driver code 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
12
, 
10
, 
5
, 
6
, 
52
, 
36
}; 

int
n = arr.length; 

int
position = 
2
; 


SplitAndAdd(arr, n, position); 


for
(
int
i = 
0
; i < n; ++i) 

System.out.print(arr[i] + 
"" ""
); 

} 
} ",CorCod,508,508,quadratic
"/**
 *   Author: Ridam Nagar
 *   Date: 27 February 2019
 *   Time: 01:17:36
**/
/* 
package codechef; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.BigInteger;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Codechef
{     
  static String reverse(String s){
    String reverse="""";
    for(int i=s.length()-1;i>=0;i--){
        reverse=reverse + s.charAt(i);
    }
    return reverse;
  }

      
    public static void main (String[] args) throws java.lang.Exception
    {
        Scanner sc=new Scanner(System.in);
         int n=sc.nextInt();
         int m=sc.nextInt();
         int x=m%(int)Math.pow(2,n);
         System.out.println(x);



}
}",CorCod,743,743,constant
"    import java.util.Scanner;

    public class Sasha1113A {

        static int solution(int n, int v){
            int count;
            if(v>=n)
                return n-1;
            else{
                count = (v-1) + ((n-v)*(n-v+1))/2;
            }
            return count;
        }

        public static void main(String[] args){
            Scanner scan = new Scanner(System.in);
            int n = scan.nextInt();
            int v = scan.nextInt();

            System.out.print(solution(n, v));
        }
    }
",CorCod,855,855,constant
"
// Java Program to Find the minimum 
// distance between two numbers 
class
MinimumDistance 
{ 

int
minDist(
int
arr[], 
int
n, 
int
x, 
int
y) 

{ 

int
i, j; 

int
min_dist = Integer.MAX_VALUE; 

for
(i = 
0
; i < n; i++) 

{ 

for
(j = i + 
1
; j < n; j++) 

{ 

if
((x == arr[i] && y == arr[j] 

|| y == arr[i] && x == arr[j]) 

&& min_dist > Math.abs(i - j)) 

min_dist = Math.abs(i - j); 

} 

} 

return
min_dist; 

} 


public
static
void
main(String[] args) 

{ 

MinimumDistance min = 
new
MinimumDistance(); 

int
arr[] = {
3
, 
5
, 
4
, 
2
, 
6
, 
5
, 
6
, 
6
, 
5
, 
4
, 
8
, 
3
}; 

int
n = arr.length; 

int
x = 
3
; 

int
y = 
6
; 


System.out.println(
""Minimum distance between ""
+ x + 
"" and ""
+ y 

+ 
"" is ""
+ min.minDist(arr, n, x, y)); 

} 
} ",CorCod,432,432,quadratic
"import java.util.*;
import java.io.*;
import java.math.*;
public class loser
{
    static class InputReader {
        public BufferedReader br;
        public StringTokenizer token;
        public InputReader(InputStream stream)
        {
            br=new BufferedReader(new InputStreamReader(stream),32768);
            token=null;
        }

        public String next()
        {
            while(token==null || !token.hasMoreTokens())
            {
                try
                {
                    token=new StringTokenizer(br.readLine());
                }
                catch(IOException e)
                {
                    throw new RuntimeException(e);
                }
            }
            return token.nextToken();
        }

        public int nextInt()
        {
            return Integer.parseInt(next());
        }

        public long nextLong()
        {
            return Long.parseLong(next());
        }
    }
    static class card{
        int l;
        int r;
        public card(int ch,int i)
        {
            this.l=ch;
            this.r=i;
        }
    }
    static class sort implements Comparator<card>
    {
        public int compare(card o1,card o2)
        {
            if(o1.l!=o2.l)
                return (int)(o1.l-o2.l);
            else
                return (int)(o1.r-o2.r);
        }
    }
    static void shuffle(long a[])
    {
        List<Long> l=new ArrayList<>();
        for(int i=0;i<a.length;i++)
            l.add(a[i]);
        Collections.shuffle(l);
        for(int i=0;i<a.length;i++)
            a[i]=l.get(i);
    }

    /*static long gcd(long a,long b)
    {
    if(b==0)
    return a;
    else
    return gcd(b,a%b);
    }
    static int ans1=Integer.MAX_VALUE,ans2=Integer.MAX_VALUE,ans3=Integer.MAX_VALUE,ans4=Integer.MAX_VALUE;
    static boolean v[]=new boolean[101];
    static void dfs(Integer so,Set<Integer> s[]){
    if(!v[so.intValue()])
    {
    v[so]=true;
    for(Integer h:s[so.intValue()])
    {
    if(!v[h.intValue()])
    dfs(h,s);
    }
    }
    }
    static class Print{
    public PrintWriter out;
    Print(OutputStream o)
    {
    out=new PrintWriter(o);
    }
    }
    static int CeilIndex(int A[], int l, int r, int key) 
    { 
    while (r - l > 1) { 
    int m = l + (r - l) / 2; 
    if (A[m] >= key) 
    r = m; 
    else
    l = m; 
    } 

    return r; 
    } 

    static int LongestIncreasingSubsequenceLength(int A[], int size) 
    { 
    // Add boundary case, when array size is one 
    int[] tailTable = new int[size]; 
    int len; // always points empty slot 
    tailTable[0] = A[0]; 
    len = 1; 
    for (int i = 1; i < size; i++) { 
    if (A[i] < tailTable[0]) 
    // new smallest value 
    tailTable[0] = A[i]; 

    else if (A[i] > tailTable[len - 1]) 
    // A[i] wants to extend largest subsequence 
    tailTable[len++] = A[i]; 

    else
    // A[i] wants to be current end candidate of an existing 
    // subsequence. It will replace ceil value in tailTable 
    tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; 
    } 
    return len; 
    }*/
    /*static int binary(int n)
    {
    int s=1;
    while(n>0)
    {
    s=s<<1;
    n--;
    }
    return s-1;
    }
    static StringBuilder bin(int i,int n)
    {
    StringBuilder s=new StringBuilder();
    while(i>0)
    {
    s.append(i%2);
    i=i/2;
    }
    while(s.length()!=n)
    {
    s.append(0);
    }
    return s.reverse();
    }*/
    static boolean valid(int i,int j,int n,int m)
    {
        if(i<n && i>=0 && j<m && j>=0)
            return true;
        else
            return false;
    }

    public static void main(String[] args) 
    {
        InputReader sc=new InputReader(System.in);
        int n=sc.nextInt();
        int s=sc.nextInt();
        card c[]=new card[n];
        for(int i=0;i<n;i++)
        {
            int x=sc.nextInt();
            int y=sc.nextInt();
            c[i]=new card(x,y);
        }
        Arrays.sort(c,new sort());
        int time=0;
        for(int i=n-1;i>=0;i--)
        {
            time+=s-c[i].l;
            if((c[i].r-time)>0)
            time+=c[i].r-time;
            s=c[i].l;
        }
        if(c[0].l!=0)
        time+=c[0].l;
        System.out.println(time);
    }
}",CorCod,590,590,nlogn
"import java.util.*;
import java.io.*;
 
public class Main {
	public static void main(String args[]) {new Main().run();}
	
	Scanner in = new Scanner(System.in);
	PrintWriter out = new PrintWriter(System.out);
	
	void run(){
	    int q=in.nextInt();
	    for(int i=0;i<q;i++){
	        out.println(work());
	    }
	    out.flush();
	}
	int work() {		
		int n=in.nextInt();
	    int k=in.nextInt();
	    String str=in.next();
	    char[] chs=new char[]{'R','G','B'};
	    int c1=0,c2=0,c3=0;
	    int ret=99999999;
	    for(int i=0,p1=0,p2=1,p3=2;i<n;i++,p1=(p1+1)%3,p2=(p2+1)%3,p3=(p3+1)%3){
	        char ch=str.charAt(i);
	        //c1
	        if(ch!=chs[p1]){
	            c1++;
	        }
	        if(i>=k){
	            char pre1=str.charAt(i-k);
	            char pre2=chs[((p1-(k%3))+3)%3];
	            if(pre1!=pre2){
	                c1--;
	            }
	        }
	        if(i+1>=k){
	            ret=Math.min(ret,c1);
	        }
	        
	        //c2
	        if(ch!=chs[p2]){
	            c2++;
	        }
	        if(i>=k){
	            char pre1=str.charAt(i-k);
	            char pre2=chs[((p2-(k%3))+3)%3];
	            if(pre1!=pre2){
	                c2--;
	            }
	        }
	        if(i+1>=k){
	            ret=Math.min(ret,c2);
	        }
	        
	        //c3
	        if(ch!=chs[p3]){
	            c3++;
	        }
	        if(i>=k){
	            char pre1=str.charAt(i-k);
	            char pre2=chs[((p3-(k%3))+3)%3];
	            if(pre1!=pre2){
	                c3--;
	            }
	        }
	        if(i+1>=k){
	            ret=Math.min(ret,c3);
	        }
	    } 
	    return ret;
	   
	}
}
",CorCod,576,576,quadratic
"import java.util.*;

import java.lang.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.*;
 
public class Main {
        
    public static void main(String[] args) throws Exception{
        FastReader sc=new FastReader(); 
        OutputStream outputStream = System.out;
        PrintWriter out = new PrintWriter(outputStream);
        int n=sc.nextInt();
        HashMap<String,Integer> map=new HashMap<String,Integer>();
        for(int i=0;i<n;i++) {
            map.put(sc.next(), 1);
        }
        ArrayList<String> list=new ArrayList<String>();
        int count=0;
        if(!map.containsKey(""purple"")) {
            count++;
            list.add(""Power"");
        }
if(!map.containsKey(""green"")) {
    count++;
    list.add(""Time"");
        }

if(!map.containsKey(""blue"")) {
    count++;
    list.add(""Space"");
}

if(!map.containsKey(""orange"")) {
    count++;
    list.add(""Soul"");
}

if(!map.containsKey(""red"")) {
    count++;
    list.add(""Reality"");
}

if(!map.containsKey(""yellow"")) {
    count++;
    list.add(""Mind"");
}System.out.println(count);
    for(String s:list) {
        System.out.println(s);
    }
    }
}

class FastReader 
{ 
    BufferedReader br; 
    StringTokenizer st; 
 
    public FastReader() 
    { 
        br = new BufferedReader(new
                 InputStreamReader(System.in)); 
    } 
 
    String next() 
    { 
        while (st == null || !st.hasMoreElements()) 
        { 
            try
            { 
                st = new StringTokenizer(br.readLine()); 
            } 
            catch (IOException  e) 
            { 
                e.printStackTrace(); 
            } 
        } 
        return st.nextToken(); 
    } 
 
    int nextInt() 
    { 
        return Integer.parseInt(next()); 
    } 
 
    long nextLong() 
    { 
        return Long.parseLong(next()); 
    } 
 
    double nextDouble() 
    { 
        return Double.parseDouble(next()); 
    } 
 
    String nextLine() 
    { 
        String str = """"; 
        try
        { 
            str = br.readLine(); 
        } 
        catch (IOException e) 
        { 
            e.printStackTrace(); 
        } 
        return str; 
    } 
} ",CorCod,738,738,constant
"import java.util.Arrays;
import java.util.Scanner;


public class Solution {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		Solution ss = new Solution();
		ss.test(sc);
	}
	
	void test(Scanner sc){
		int LEN = sc.nextInt();
		int[] a = new int[LEN];
		int[] b = new int[LEN];
		for (int i = 0; i < b.length; i++) {
			a[i] = sc.nextInt();
		}
		for (int i = 0; i < b.length; i++) {
			b[i] = sc.nextInt();
		}
		Arrays.sort(a);
		Arrays.sort(b);
		
		int ia=0, ib=0;
		while(ia<LEN && a[ia]==0) ia++;
		while(ib<LEN && b[ib]==0) ib++;
		if(ib==LEN){
			System.out.println(""Yes"");
			return;
		}
		if(ia==LEN){
			System.out.println(""No"");
			return;
		}		
		boolean out = true;
		while(ia<LEN && ib<LEN){
			if(a[ia]==b[ib]){
				ia++;
				ib++;
			}else{
				if(a[ia]>b[ib]){
					while(ib<LEN && b[ib]!=a[ia]){
						ib++;
					}
					if(ib==LEN){
						out=false;
						break;
					}
				}
			}
		}
		
		if(out){
			System.out.println(""Yes"");
		}else{
			System.out.println(""No"");
		}
	}

}
",CorCod,425,425,quadratic
"import java.util.*;
 
import javax.lang.model.util.ElementScanner6;
 
import java.io.*;
 
public class Main {
 
    public static void main(String[] args) {
 
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader inp = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        Solver solver = new Solver();
        solver.solve(inp, out);
        out.close();
 
    }
 
 
 
 
 
    static class Solver {

        class pair implements Comparable<pair>{

            int i;
            long dist;
            public pair(int i,long dist)
            {
                this.i=i;
                this.dist=dist;
            }

            public int compareTo(pair p)
            {
                return Long.compare(this.dist,p.dist);
            }

        }
 
        class Node implements Comparable < Node > {
            int i;
            int cnt;
 
            Node(int i, int cnt) {
                this.i = i;
                this.cnt = cnt;
            }
 
            public int compareTo(Node n) {
                if (this.cnt == n.cnt) {
                    return Integer.compare(this.i, n.i);
                }
                return Integer.compare(this.cnt, n.cnt);
            }
        }
 
        public boolean done(int[] sp, int[] par) {
            int root;
 
            root = findSet(sp[0], par);
 
            for (int i = 1; i < sp.length; i++) {
                if (root != findSet(sp[i], par))
                    return false;
            }
            return true;
        }
        public int findSet(int i, int[] par) {
            int x = i;
            boolean flag = false;
            while (par[i] >= 0) {
                flag = true;
                i = par[i];
            }
            if (flag)
                par[x] = i;
            return i;
        }
 
        public void unionSet(int i, int j, int[] par) {
            int x = findSet(i, par);
            int y = findSet(j, par);
            if (x < y) {
                par[y] = x;
            } else {
                par[x] = y;
            }
        }
 
        public long pow(long a, long b, long MOD) {
            if (b == 0) {
                return 1;
            }
            if (b == 1) {
                return a;
            }
            long val = pow(a, b / 2, MOD);
            if (b % 2 == 0) {
                return val * val % MOD;
            } else {
                return val * (val * a % MOD) % MOD;
 
            }
 
        }

        public boolean isPrime(int n)
        {
            for(int i=2;i<n;i++)
            {
                if(n%i==0)
                {
                    return false;
                }
            }
            return true;
        }
 
 
        public void minPrimeFactor(int n, int[] s) {
            boolean prime[] = new boolean[n + 1];
            Arrays.fill(prime, true);
            s[1] = 1;
            s[2] = 2;
            for (int i = 4; i <= n; i += 2) {
                prime[i] = false;
                s[i] = 2;
            }
 
            for (int i = 3; i <= n; i += 2) {
                if (prime[i]) {
                    s[i] = i;
                    for (int j = 2 * i; j <= n; j += i) {
                        prime[j] = false;
                        s[j] = i;
                    }
                }
            }
 
        }
 
 
        public void findAllPrime(int n, ArrayList < Node > al, int s[]) {
            int curr = s[n];
            int cnt = 1;
            while (n > 1) {
                n /= s[n];
                if (curr == s[n]) {
                    cnt++;
                    continue;
 
                }
                Node n1 = new Node(curr, cnt);
                al.add(n1);
 
                curr = s[n];
                cnt = 1;
            }
        }
 
 
 
        public int binarySearch(int n, int k) {
            int left = 1;
            int right = 100000000 + 5;
            int ans = 0;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (n / mid >= k) {
                    left = mid + 1;
                    ans = mid;
                } else {
                    right = mid - 1;
                }
            }
 
            return ans;
        }
        public boolean checkPallindrom(String s) {
            char ch[] = s.toCharArray();
 
            for (int i = 0; i < s.length() / 2; i++) {
                if (ch[i] != ch[s.length() - 1 - i])
                    return false;
            }
            return true;
        }
 
 
 
 
        public void remove(ArrayList < Integer > [] al, int x) {
            for (int i = 0; i < al.length; i++) {
                for (int j = 0; j < al[i].size(); j++) {
 
                    if (al[i].get(j) == x)
                        al[i].remove(j);
 
                }
            }
        }
 
        public long gcd(long a, long b) {
            if (a == 0)
                return b;
            return gcd(b % a, a);
        }
 
 
        public void printDivisors(long n, ArrayList < Long > al) {
            // Note that this loop runs till square root 
            for (long i = 1; i <= Math.sqrt(n); i++) {
                if (n % i == 0) {
                    // If divisors are equal, print only one 
                    if (n / i == i) {
                        al.add(i);
                    } else // Otherwise print both 
                    {
                        al.add(i);
                        al.add(n / i);
                    }
 
                }
            }
        }
 
        public static long constructSegment(long seg[], long arr[], int low, int high, int pos) {
            if (low == high) {
                seg[pos] = arr[low];
                return seg[pos];
            }
            int mid = (low + high) / 2;
            long t1 = constructSegment(seg, arr, low, mid, (2 * pos) + 1);
            long t2 = constructSegment(seg, arr, mid + 1, high, (2 * pos) + 2);
            seg[pos] = t1 + t2;
            return seg[pos];
 
        }
        public static long querySegment(long seg[], int low, int high, int qlow, int qhigh, int pos) {
 
            if (qlow <= low && qhigh >= high) {
                return seg[pos];
            } else if (qlow > high || qhigh < low) {
                return 0;
            } else {
                long ans = 0;
                int mid = (low + high) / 2;
                ans += querySegment(seg, low, mid, qlow, qhigh, (2 * pos) + 1);
                ans += querySegment(seg, mid + 1, high, qlow, qhigh, (2 * pos) + 2);
                return ans;
            }
 
        }
        public static int lcs(char[] X, char[] Y, int m, int n) {
            if (m == 0 || n == 0)
                return 0;
            if (X[m - 1] == Y[n - 1])
                return 1 + lcs(X, Y, m - 1, n - 1);
            else
                return Integer.max(lcs(X, Y, m, n - 1), lcs(X, Y, m - 1, n));
        }
 
        public static long recursion(long start, long end, long cnt[], int a, int b) {
 
            long min = 0;
            long count = 0;
            int ans1 = -1;
            int ans2 = -1;
            int l = 0;
            int r = cnt.length - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (cnt[mid] >= start) {
                    ans1 = mid;
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
 
            l = 0;
            r = cnt.length - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (cnt[mid] <= end) {
                    ans2 = mid;
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
 
            if (ans1 == -1 || ans2 == -1 || ans2 < ans1) {
                // System.out.println(""min1 ""+min);
                min = a;
                return a;
 
            } else {
                min = b * (end - start + 1) * (ans2 - ans1 + 1);
            }
            if (start == end) {
                // System.out.println(""min ""+min);
                return min;
            }
            long mid = (end + start) / 2;
            min = Long.min(min, recursion(start, mid, cnt, a, b) + recursion(mid + 1, end, cnt, a, b));
            // System.out.println(""min ""+min);
            return min;
        }
 
 
 
 
 
        public int dfs_util(ArrayList < Integer > [] al, boolean vis[], int x, int[] s, int lvl[]) {
 
            vis[x] = true;
            int cnt = 1;
            for (int i = 0; i < al[x].size(); i++) {
 
                if (!vis[al[x].get(i)]) {
                    lvl[al[x].get(i)] = lvl[x] + 1;
                    cnt += dfs_util(al, vis, al[x].get(i), s, lvl);
 
 
                }
 
 
            }
            s[x] = cnt;
            return s[x];
        }
 
        public void dfs(ArrayList[] al, int[] s, int[] lvl) {
 
            boolean vis[] = new boolean[al.length];
            for (int i = 0; i < al.length; i++) {
                if (!vis[i]) {
                    lvl[i] = 1;
                    dfs_util(al, vis, i, s, lvl);
                }
            }
        }
 
        public int[] computeLps(String s)
        {
            int ans[] =new int[s.length()];
            char ch[] = s.toCharArray();
            int n = s.length();
            int i=1;
            int len=0;
            ans[0]=0;
            while(i<n)
            {
                if(ch[i]==ch[len])
                {
                    len++;
                    ans[i]=len;
                    i++;
                }
                else
                {
                    if(len!=0)
                    {
                        len=ans[len-1];
                    }
                    else
                    {
                        ans[i]=len;
                        i++;
                    }
                }
            }

            return ans;

        }
 
 
        private void solve(InputReader inp, PrintWriter out1) {
            int n = inp.nextInt();
            int m = inp.nextInt();
            long k = inp.nextLong();
            long arr[] = new long[n];

            for(int i=0;i<n;i++)
            {
                arr[i] = inp.nextLong();

            }
            long ans=0;
            for(int i=0;i<m;i++)
            {
                long sum=0;
                for(int j=i;j<n;j++)
                {
                    

                    if(j%m==i)
                    {
                        if(sum<0)
                        {
                           sum=0;
                        }
                        sum-=k;
                    }
                    
                    sum+=arr[j];
                    
                    ans=Math.max(ans,sum);
                }

            

            }

            System.out.println(ans);
           

           
            
        }
 
 
}
 
 
    static class InputReader {
        BufferedReader reader;
        StringTokenizer tokenizer;
 
        InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
 
        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
 
        public int nextInt() {
            return Integer.parseInt(next());
        }
 
        public long nextLong() {
            return Long.parseLong(next());
        }
    }
}
class ele implements Comparable < ele > {
    int value;
    int i;
    boolean flag;
    public ele(int value, int i) {
        this.value = value;
        this.i = i;
        this.flag = false;
    }
    public int compareTo(ele e) {
        return Integer.compare(this.value, e.value);
    }
}",CorCod,530,530,quadratic
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.Stack;


import java.util.StringTokenizer;


 public class Test
 {
    
     static PrintWriter pw = new PrintWriter(System.out);

    public static void main(String[] args)throws Exception
    {
        Reader.init(System.in);
        int n = Reader.nextInt();
        int p = Reader.nextInt();
        int L = Reader.nextInt();
        int R = Reader.nextInt();
        int a = 1;
        int b = n;
        int res = 0;
        
        if(a == L && b == R)
        {
            res = 0;
        }
        else if(L != a && R != b && p >= L && p <= R)
        {
            res = Math.min(p-L, R-p);
            res += R- L + 2;
        }
        else if(L != a && R != b && p < L )
        {
            res += L-p + 1;
            res += R - L +1;
        }
        else if(L != a && R != b && p > R)
        {
            res += p-R + 1;
            res += R - L +1;
        }
        else if(a == L && p >=L && p<=R)
        {
            res += R - p + 1;
        }
        else if(R == b && p>=L && p<=R)
        {
            res += p - L + 1;
        }
        else if(a == L && p > R)
        {
            res += p - R + 1;
        }
        else if(R == b && p<L)
        {
            res += L - p + 1;
        }
            
            
        pw.print(res);
        pw.close();
 
    }
        
}

class Reader {

    static BufferedReader reader;
    static StringTokenizer tokenizer;

    public static int pars(String x) {
        int num = 0;
        int i = 0;
        if (x.charAt(0) == '-') {
            i = 1;
        }
        for (; i < x.length(); i++) {
            num = num * 10 + (x.charAt(i) - '0');
        }

        if (x.charAt(0) == '-') {
            return -num;
        }

        return num;
    }

    static void init(InputStream input) {
        reader = new BufferedReader(
                new InputStreamReader(input));
        tokenizer = new StringTokenizer("""");
    }

    static void init(FileReader input) {
        reader = new BufferedReader(input);
        tokenizer = new StringTokenizer("""");
    }

    static String next() throws IOException {
        while (!tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(
                    reader.readLine());
        }
        return tokenizer.nextToken();
    }

    static int nextInt() throws IOException {
        return pars(next());
    }

    static long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    static double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }
}",CorCod,816,816,constant
"
import
java.util.Arrays; 

// Java program to find the largest 
// subset which where each pair 
// is divisible. 
class
GFG { 


// function to find the longest Subsequence 

static
int
largestSubset(
int
[] a, 
int
n) 

{ 

// Sort array in increasing order 

Arrays.sort(a); 


// dp[i] is going to store size of largest 

// divisible subset beginning with a[i]. 

int
[] dp = 
new
int
[n]; 


// Since last element is largest, d[n-1] is 1 

dp[n - 
1
] = 
1
; 


// Fill values for smaller elements. 

for
(
int
i = n - 
2
; i >= 
0
; i--) { 


// Find all multiples of a[i] and consider 

// the multiple that has largest subset 

// beginning with it. 

int
mxm = 
0
; 

for
(
int
j = i + 
1
; j < n; j++) { 

if
(a[j] % a[i] == 
0
) { 

mxm = Math.max(mxm, dp[j]); 

} 

} 


dp[i] = 
1
+ mxm; 

} 


// Return maximum value from dp[] 

return
Arrays.stream(dp).max().getAsInt(); 

} 


// driver code to check the above function 

public
static
void
main(String[] args) 

{ 

int
[] a = { 
1
, 
3
, 
6
, 
13
, 
17
, 
18
}; 

int
n = a.length; 

System.out.println(largestSubset(a, n)); 

} 
} 

/* This JAVA code is contributed by Rajput-Ji*/",CorCod,500,500,quadratic
"
// Java implementation of brute 
// force solution. 
import
java.util.LinkedHashSet; 

class
GFG 
{ 
// Function to check if the given 
// number has repeated digit or not 
static
int
repeated_digit(
int
n) 
{ 

LinkedHashSet<Integer> s = 
new
LinkedHashSet<>(); 


// Traversing through each digit 

while
(n != 
0
) 

{ 

int
d = n % 
10
; 


// if the digit is present 

// more than once in the 

// number 

if
(s.contains(d)) 

{ 

// return 0 if the number 

// has repeated digit 

return
0
; 

} 

s.add(d); 

n = n / 
10
; 

} 


// return 1 if the number has 

// no repeated digit 

return
1
; 
} 

// Function to find total number 
// in the given range which has 
// no repeated digit 
static
int
calculate(
int
L, 
int
R) 
{ 

int
answer = 
0
; 


// Traversing through the range 

for
(
int
i = L; i < R + 
1
; ++i) 

{ 


// Add 1 to the answer if i has 

// no repeated digit else 0 

answer = answer + repeated_digit(i); 

} 


return
answer; 
} 

// Driver Code 
public
static
void
main(String[] args) 
{ 

int
L = 
1
, R = 
100
; 


// Calling the calculate 

System.out.println(calculate(L, R)); 
} 
} 

// This code is contributed by RAJPUT-JI ",CorCod,132,132,linear
"/**
 * Created by Aminul on 3/14/2019.
 */

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

import static java.lang.Math.max;

public class E_2 {
    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int n = in.nextInt(), k = in.nextInt(), N = (int) 5e6 + 1;
        int left = 0, right = 0;
        int a[] = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = in.nextInt();
            if (a[i] == k) left++;
        }
        int f[] = new int[N + 1];
        int ans = 0;
        for (int i = n; i >= 1; i--) {
            if (a[i] == k) left--;
            f[a[i]]++;
            f[a[i]] = max(f[a[i]], 1 + right);
            ans = max(ans, f[a[i]] + left);
            if (a[i] == k) right++;
        }
        pw.println(ans);
        pw.close();
    }

    static void debug(Object... obj) {
        System.err.println(Arrays.deepToString(obj));
    }

    static class FastReader {
        InputStream is;
        private byte[] inbuf = new byte[1024];
        private int lenbuf = 0, ptrbuf = 0;

        public FastReader(InputStream is) {
            this.is = is;
        }

        public int readByte() {
            if (lenbuf == -1) throw new InputMismatchException();
            if (ptrbuf >= lenbuf) {
                ptrbuf = 0;
                try {
                    lenbuf = is.read(inbuf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (lenbuf <= 0) return -1;
            }
            return inbuf[ptrbuf++];
        }

        public int nextInt() {
            int num = 0, b;
            boolean minus = false;
            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            while (true) {
                if (b >= '0' && b <= '9') {
                    num = (num << 3) + (num << 1) + (b - '0');
                } else {
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }
    }
}",CorCod,291,291,linear
"

import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			int n = sc.nextInt();
			if (n % 2 != 0) {
				System.out.println(""Ehab"");
			} else {
				System.out.println(""Mahmoud"");
			}

		}

	}

}

					  	 	     	      		 			",CorCod,750,750,constant
"
// A Java program to remove BST 
// keys outside the given range 
import
java.math.BigDecimal; 
import
java.util.ArrayList; 
import
java.util.Arrays; 
import
java.util.List; 
import
java.util.Scanner; 

class
Node 
{ 

int
key; 

Node left; 

Node right; 
} 

class
GFG 
{ 

// Removes all nodes having value 

// outside the given range and 

// returns the root of modified tree 

private
static
Node removeOutsideRange(Node root, 

int
min, 
int
max) 

{ 

// BASE CASE 

if
(root == 
null
) 

{ 

return
null
; 

} 


// FIRST FIX THE LEFT AND 

// RIGHT SUBTREE OF ROOT 

root.left = removeOutsideRange(root.left, 

min, max); 

root.right = removeOutsideRange(root.right, 

min, max); 


// NOW FIX THE ROOT. THERE ARE 

// TWO POSSIBLE CASES FOR THE ROOT 

// 1. a) Root's key is smaller than 

// min value(root is not in range) 

if
(root.key < min) 

{ 

Node rchild = root.right; 

root = 
null
; 

return
rchild; 

} 


// 1. b) Root's key is greater than 

// max value (Root is not in range) 

if
(root.key > max) 

{ 

Node lchild = root.left; 

root = 
null
; 

return
lchild; 

} 


// 2. Root in range 

return
root; 

} 


public
static
Node newNode(
int
num) 

{ 

Node temp = 
new
Node(); 

temp.key = num; 

temp.left = 
null
; 

temp.right = 
null
; 

return
temp; 

} 


public
static
Node insert(Node root, 

int
key) 

{ 

if
(root == 
null
) 

{ 

return
newNode(key); 

} 

if
(root.key > key) 

{ 

root.left = insert(root.left, key); 

} 

else

{ 

root.right = insert(root.right, key); 

} 

return
root; 

} 


private
static
void
inorderTraversal(Node root) 

{ 

if
(root != 
null
) 

{ 

inorderTraversal(root.left); 

System.out.print(root.key + 
"" ""
); 

inorderTraversal(root.right); 

} 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

Node root = 
null
; 

root = insert(root, 
6
); 

root = insert(root, -
13
); 

root = insert(root, 
14
); 

root = insert(root, -
8
); 

root = insert(root, 
15
); 

root = insert(root, 
13
); 

root = insert(root, 
7
); 


System.out.print(
""Inorder Traversal of ""
+ 

""the given tree is: ""
); 

inorderTraversal(root); 


root = removeOutsideRange(root, -
10
, 
13
); 


System.out.print(
""\nInorder traversal of ""
+ 

""the modified tree: ""
); 

inorderTraversal(root); 

} 
} 

// This code is contributed 
// by Divya ",CorCod,145,145,linear
"//package com.krakn.CF.D1159;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n, k;
        n = sc.nextInt();
        k = sc.nextInt();

        int a = (n - k) / 2;

        StringBuilder s = new StringBuilder();

        int i;
        while (s.length() < n) {
            i = 0;
            while (i < a && s.length() < n) {
                s.append(""0"");
                i++;
            }
            if (s.length() < n) s.append(""1"");
        }

        System.out.println(s);
    }
}
",CorCod,364,364,linear
"public class Search {

    public static boolean find2(int[] array, int begin, int end, int element) {
        if (begin <= end) {
            int medium = begin + (end - begin) / 2;
            if (array[medium] == element)
                return true;
            else if (medium > begin && array[medium - 1] == element) return true;
            else if (medium < end && array[medium + 1] == element) return true;

            if (array[medium] > element) return find2(array, 0, medium - 2, element);
            return find2(array, medium + 2, end, element);
        }
        return false;
    }
    
    public static int find(int[] array, int begin, int end, int element) {
        if (begin < end) {
            int medium = begin + (end - begin) / 2;
            if (array[medium] == element)
                return medium;
            else if (medium > begin && array[medium - 1] == element) return medium - 1;
            else if (medium < end && array[medium + 1] == element) return medium + 1;

            if (array[medium] > element) return find(array, 0, medium - 2, element);
            return find(array, medium + 2, end, element);


        }
        return -1;
    }

    public static void main(String[] args) {
        int[] array = {12,13, 21, 36, 3, 43, 65, 76, 88, 91, 100};
        System.out.println(find2(array, 0, array.length-1, 13));
    }


}",CorCod,904,904,logn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, FastReader in, PrintWriter out) {
            int n = in.nextInt();
            TaskD.Pair[] p = new TaskD.Pair[n];
            for (int i = 0; i < n; ++i) {
                p[i] = new TaskD.Pair(in.nextLong(), in.nextLong());
            }
            Arrays.sort(p);
            int last = 0;
            int ans = 1;
            for (int i = 1; i < n; ++i) {
                if (p[i].x - p[i].w >= p[last].x + p[last].w) {
                    last = i;
                    ++ans;
                }
            }
            out.println(ans);
        }

        static class Pair implements Comparable<TaskD.Pair> {
            long x;
            long w;

            public Pair(long x, long w) {
                this.x = x;
                this.w = w;
            }

            public int compareTo(TaskD.Pair o) {
                return Long.compare(x + w, o.x + o.w);
            }

            public String toString() {
                return x + "" "" + w;
            }

        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int pnumChars;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        private int pread() {
            if (pnumChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= pnumChars) {
                curChar = 0;
                try {
                    pnumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (pnumChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            int res = 0;
            do {
                if (c == ',') {
                    c = pread();
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public long nextLong() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",CorCod,650,650,nlogn
"import org.omg.PortableServer.AdapterActivator;

import java.io.*;
import java.lang.reflect.Array;
import java.net.CookieHandler;
import java.util.*;
import java.math.*;
import java.lang.*;
import java.util.concurrent.LinkedBlockingDeque;

import static java.lang.Math.*;

public class TaskA implements Runnable {
    long m = (int)1e9+7;
    PrintWriter w;
    InputReader c;
    public void run() {
        c = new InputReader(System.in);
        w = new PrintWriter(System.out);
        int n = c.nextInt();
        int a[] = scanArrayI(n);
        int maxtime = Integer.MAX_VALUE,ind = -1;
        for(int i=0;i<n;i++){
            int time = Integer.MAX_VALUE;
            if(a[i]<i+1)
                time = i;
            else{
                time = (int)ceil((a[i] - i)/(double)n) * n + i;
            }
            if(time<maxtime){
                maxtime = time;
                ind = i;
            }
        }
        w.println(ind+1);
        w.close();
    }
    static long gcd(long a, long b) {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }
    public static void sortbyColumn(int arr[][], int col){
        Arrays.sort(arr, new Comparator<int[]>()
        {
            public int compare(int[] o1, int[] o2){
                return(Integer.valueOf(o1[col]).compareTo(o2[col]));
            }
        });

    }
    public static class DJSet {
        public int[] upper;

        public DJSet(int n) {
            upper = new int[n];
            Arrays.fill(upper, -1);
        }

        public int root(int x) {
            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
        }

        public boolean equiv(int x, int y) {
            return root(x) == root(y);
        }

        public boolean union(int x, int y) {
            x = root(x);
            y = root(y);
            if (x != y) {
                if (upper[y] < upper[x]) {
                    int d = x;
                    x = y;
                    y = d;
                }
                upper[x] += upper[y];
                upper[y] = x;
            }
            return x == y;
        }
    }
    public static int[] radixSort(int[] f)    {
        int[] to = new int[f.length];
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        return f;
    }
    public void printArray(int[] a){
        for(int i=0;i<a.length;i++)
            w.print(a[i]+"" "");
        w.println();
    }
    public int[] scanArrayI(int n){
        int a[] = new int[n];
        for(int i=0;i<n;i++)
            a[i] = c.nextInt();
        return a;
    }
    public long[] scanArrayL(int n){
        long a[] = new long[n];
        for(int i=0;i<n;i++)
            a[i] = c.nextLong();
        return a;
    }
    public void printArray(long[] a){
        for(int i=0;i<a.length;i++)
            w.print(a[i]+"" "");
        w.println();
    }
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars==-1)
                throw new InputMismatchException();

            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                }
                catch (IOException e) {
                    throw new InputMismatchException();
                }

                if(numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            int c = read();

            while(isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;
            do {
                if(c<'0'||c>'9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    public static void main(String args[]) throws Exception {
        new Thread(null, new TaskA(),""TaskA"",1<<26).start();
    }
}",CorCod,648,648,nlogn
"
class
MaximumSum 
{ 

/*Function to return max sum such that no two elements 

are adjacent */

int
FindMaxSum(
int
arr[], 
int
n) 

{ 

int
incl = arr[
0
]; 

int
excl = 
0
; 

int
excl_new; 

int
i; 


for
(i = 
1
; i < n; i++) 

{ 

/* current max excluding i */

excl_new = (incl > excl) ? incl : excl; 


/* current max including i */

incl = excl + arr[i]; 

excl = excl_new; 

} 


/* return max of incl and excl */

return
((incl > excl) ? incl : excl); 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

MaximumSum sum = 
new
MaximumSum(); 

int
arr[] = 
new
int
[]{
5
, 
5
, 
10
, 
100
, 
10
, 
5
}; 

System.out.println(sum.FindMaxSum(arr, arr.length)); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,351,351,linear
"
// Java code to find largest three elements 
// in an array 

class
PrintLargest 
{ 

/* Function to print three largest elements */

static
void
print3largest(
int
arr[], 
int
arr_size) 

{ 

int
i, first, second, third; 


/* There should be atleast three elements */

if
(arr_size < 
3
) 

{ 

System.out.print(
"" Invalid Input ""
); 

return
; 

} 


third = first = second = Integer.MIN_VALUE; 

for
(i = 
0
; i < arr_size ; i ++) 

{ 

/* If current element is greater than 

first*/

if
(arr[i] > first) 

{ 

third = second; 

second = first; 

first = arr[i]; 

} 


/* If arr[i] is in between first and 

second then update second */

else
if
(arr[i] > second) 

{ 

third = second; 

second = arr[i]; 

} 


else
if
(arr[i] > third) 

third = arr[i]; 

} 


System.out.println(
""Three largest elements are ""
+ 

first + 
"" ""
+ second + 
"" ""
+ third); 

} 


/* Driver program to test above function*/

public
static
void
main (String[] args) 

{ 

int
arr[] = {
12
, 
13
, 
1
, 
10
, 
34
, 
1
}; 

int
n = arr.length; 

print3largest(arr, n); 

} 
} 
/*This code is contributed by Prakriti Gupta 
and edited by Ayush Singla(@ayusin51)*/",CorCod,183,183,linear
"import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new PrintStream(System.out));
        StringTokenizer st = new StringTokenizer(f.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        long[] arrB = new long[n];
        long[] arrG = new long[m];
        st=new StringTokenizer(f.readLine());
        for(int i=0;i<n;i++){
            arrB[i]=Long.parseLong(st.nextToken());
        }
        st=new StringTokenizer(f.readLine());
        for(int j=0;j<m;j++){
            arrG[j]=Long.parseLong(st.nextToken());
        }
        Arrays.sort(arrB);
        Arrays.sort(arrG);
        long ans = 0;
//        for (int i = 0; i < n; i++) ans += arrB[i] * m;
//        for (int i = 0; i < m - 1; i++) ans += arrG[i] - arrB[0];
//        if (arrB[m - 1] != arrB[0]) {
//            if (arrB.length == 1) {
//                ans=-1;
//            }
//            else ans += arrG[m - 1] - arrB[1];
//        }
//        if (arrG[m-1] < arrB[0]) {
//            ans=-1;
//        }
        for(int i=0;i<n;i++){
            ans+=arrB[i]*(long)m;
        }
        for(int i=1;i<m;i++){
            ans+=arrG[i]-arrB[n-1];
        }
        if(arrB[n-1]!=arrG[0]){
            if(n==1){
                ans=-1;
            }
            else{
                //smallest g goes to second to last
                ans+=arrG[0]-arrB[n-2];
            }
        }
        if(arrB[n-1]>arrG[0]){
            ans=-1;
        }
        System.out.println(ans);
        f.close();
        out.close();
    }
}",CorCod,661,661,nlogn
"
// Java program to find equilibrium 
// index of an array 

class
EquilibriumIndex { 

int
equilibrium(
int
arr[], 
int
n) 

{ 

int
i, j; 

int
leftsum, rightsum; 


/* Check for indexes one by one until 

an equilibrium index is found */

for
(i = 
0
; i < n; ++i) { 


/* get left sum */

leftsum = 
0
; 

for
(j = 
0
; j < i; j++) 

leftsum += arr[j]; 


/* get right sum */

rightsum = 
0
; 

for
(j = i + 
1
; j < n; j++) 

rightsum += arr[j]; 


/* if leftsum and rightsum are same, 

then we are done */

if
(leftsum == rightsum) 

return
i; 

} 


/* return -1 if no equilibrium index is found */

return
-
1
; 

} 

// Driver code 

public
static
void
main(String[] args) 

{ 

EquilibriumIndex equi = 
new
EquilibriumIndex(); 

int
arr[] = { -
7
, 
1
, 
5
, 
2
, -
4
, 
3
, 
0
}; 

int
arr_size = arr.length; 

System.out.println(equi.equilibrium(arr, arr_size)); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,405,405,quadratic
"import java.io.*;
import java.util.*;

public class A1008 {
    public static void main(String [] args) /*throws Exception*/ {
        InputStream inputReader = System.in;
        OutputStream outputReader = System.out;
        InputReader in = new InputReader(inputReader);//new InputReader(new FileInputStream(new File(""input.txt"")));new InputReader(inputReader);
        PrintWriter out = new PrintWriter(outputReader);//new PrintWriter(new FileOutputStream(new File(""output.txt"")));
        Algorithm solver = new Algorithm();
        solver.solve(in, out);
        out.close();
    }
}

class Algorithm {
    void solve(InputReader ir, PrintWriter pw) {

        long n = ir.nextLong(), k = ir.nextLong();
        long l = Math.max(1, k - n), r = (k + 1) / 2;
        l = Math.max(0, r - l);
        pw.print(l);

    }

}

class InputReader {
    private BufferedReader reader;
    private StringTokenizer tokenizer;

    InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream), 32768);
        tokenizer = null;
    }

    String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    String nextLine(){
        String fullLine = null;
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                fullLine = reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            return fullLine;
        }
        return fullLine;
    }

    String [] toArray() {
        return nextLine().split("" "");
    }

    int nextInt() {
        return Integer.parseInt(next());
    }
    double nextDouble() {
        return Double.parseDouble(next());
    }
    long nextLong() {
        return Long.parseLong(next());
    }

}",CorCod,800,800,constant
"
// JAVA Code for Maximum length subsequence 
// with difference between adjacent elements 
// as either 0 or 1 
import
java.util.*; 

class
GFG { 


// function to find maximum length subsequence 

// with difference between adjacent elements as 

// either 0 or 1 

public
static
int
maxLenSub(
int
arr[], 
int
n) 

{ 

int
mls[] = 
new
int
[n], max = 
0
; 


// Initialize mls[] values for all indexes 

for
(
int
i = 
0
; i < n; i++) 

mls[i] = 
1
; 


// Compute optimized maximum length 

// subsequence values in bottom up manner 

for
(
int
i = 
1
; i < n; i++) 

for
(
int
j = 
0
; j < i; j++) 

if
(Math.abs(arr[i] - arr[j]) <= 
1

&& mls[i] < mls[j] + 
1
) 

mls[i] = mls[j] + 
1
; 


// Store maximum of all 'mls' values in 'max' 

for
(
int
i = 
0
; i < n; i++) 

if
(max < mls[i]) 

max = mls[i]; 


// required maximum length subsequence 

return
max; 

} 


/* Driver program to test above function */

public
static
void
main(String[] args) 

{ 

int
arr[] = {
2
, 
5
, 
6
, 
3
, 
7
, 
6
, 
5
, 
8
}; 

int
n = arr.length; 

System.out.println(
""Maximum length subsequence = ""
+ 

maxLenSub(arr, n)); 


} 
} 

// This code is contributed by Arnav Kr. Mandal. ",CorCod,547,547,quadratic
"import java.util.Scanner;

public class A961_Tetris {

	public static void main(String[] args) {
		
		Scanner input = new Scanner(System.in);
		int platforms = input.nextInt();
		int in = input.nextInt();
		int[] cols = new int[platforms];
		int[] squares = new int[in];
		
		for (int i = 0; i < in; i ++) {
			squares[i] = input.nextInt();
		}
		
		boolean hi = false;
		int score = 0;
		
		for (int i = 0; i < in; i ++) {
			cols[squares[i] - 1] ++;
			hi = checkscore(cols);
			if (hi == true) {
				hi = false;
				score ++;
				for (int j = 0; j < cols.length; j ++) {
					cols[j] --;
				}
				
			}
			
		}
		
		System.out.println(score);
		
	}
	
	public static boolean checkscore(int[] cols) {
		for (int i = 0; i < cols.length; i ++) {
			if (cols[i] == 0) {
				return false;
			}
			
		}
		
		return true;
		
	}

}
",CorCod,399,399,quadratic
"
// Java program to update every array element with 
// multiplication of previous and next numbers in array 
import
java.io.*; 
import
java.util.*; 
import
java.lang.Math; 

class
Multipy 
{ 

static
void
modify(
int
arr[], 
int
n) 

{ 

// Nothing to do when array size is 1 

if
(n <= 
1
) 

return
; 


// store current value of arr[0] and update it 

int
prev = arr[
0
]; 

arr[
0
] = arr[
0
] * arr[
1
]; 


// Update rest of the array elements 

for
(
int
i=
1
; i<n-
1
; i++) 

{ 

// Store current value of next interation 

int
curr = arr[i]; 


// Update current value using previos value 

arr[i] = prev * arr[i+
1
]; 


// Update previous value 

prev = curr; 

} 


// Update last array element 

arr[n-
1
] = prev * arr[n-
1
]; 

} 


// Driver program to test above function 

public
static
void
main(String[] args) 

{ 

int
arr[] = {
2
, 
3
, 
4
, 
5
, 
6
}; 

int
n = arr.length; 

modify(arr, n); 

for
(
int
i=
0
; i<n; i++) 

System.out.print(arr[i]+
"" ""
); 

} 
} 
/* This code is contributed by Devesh Agrawal */",CorCod,72,72,linear
"
// Java program to find the minimum possible 
// difference between maximum and minimum 
// elements when we have to add/subtract 
// every number by k 
import
java.util.*; 

class
GFG { 


// Modifies the array by subtracting/adding 

// k to every element such that the difference 

// between maximum and minimum is minimized 

static
int
getMinDiff(
int
arr[], 
int
n, 
int
k) 

{ 

if
(n == 
1
) 

return
0
; 


// Sort all elements 

Arrays.sort(arr); 


// Initialize result 

int
ans = arr[n-
1
] - arr[
0
]; 


// Handle corner elements 

int
small = arr[
0
] + k; 

int
big = arr[n-
1
] - k; 

int
temp = 
0
; 


if
(small > big) 

{ 

temp = small; 

small = big; 

big = temp; 

} 


// Traverse middle elements 

for
(
int
i = 
1
; i < n-
1
; i ++) 

{ 

int
subtract = arr[i] - k; 

int
add = arr[i] + k; 


// If both subtraction and addition 

// do not change diff 

if
(subtract >= small || add <= big) 

continue
; 


// Either subtraction causes a smaller 

// number or addition causes a greater 

// number. Update small or big using 

// greedy approach (If big - subtract 

// causes smaller diff, update small 

// Else update big) 

if
(big - subtract <= add - small) 

small = subtract; 

else

big = add; 

} 


return
Math.min(ans, big - small); 

} 


// Driver function to test the above function 

public
static
void
main(String[] args) 

{ 

int
arr[] = {
4
, 
6
}; 

int
n = arr.length; 

int
k = 
10
; 

System.out.println(
""Maximum difference is ""
+ 

getMinDiff(arr, n, k)); 

} 
} 
// This code is contributed by Prerna Saini ",CorCod,672,672,nlogn
"import java.util.*;
import java.io.*;
import java.math.BigInteger;

public class Problem
{

    static int mod = (int) (1e9+7);
    static InputReader in;
    static PrintWriter out;
    static int[] rt;
    static int[] size;

    static void initialize(int n){
        rt = new int[n + 1];
        size = new int[n + 1];
        for(int i = 0; i < rt.length; i++){
            rt[i] = i;
            size[i] = 1;
        }
    }
    
    static int root(int x){
        while(rt[x] != x){
            rt[x] = rt[rt[x]];
            x = rt[x];
        }
        return x;
    }
    
    static long union(int x,int y){
        int root_x = root(x);
        int root_y = root(y);
        if(root_x == root_y) return 0;
        long val = size[root_x] *1l* size[root_y];
        if(size[root_x]<size[root_y]){
            rt[root_x] = rt[root_y];
            size[root_y] += size[root_x];
        }
        else{
            rt[root_y] = rt[root_x];
            size[root_x] += size[root_y];            
        }
        
        return val;
    }
    
    static void solve()
    {
        in = new InputReader(System.in);
        out = new PrintWriter(System.out);            
        
        int t = 1;
        
        while(t-- > 0){
            int n = in.nextInt();
            int[] arr = in.nextIntArray(n);
            ArrayList<Pair> list = new ArrayList<>();
            
            for(int i = 1; i < n; i++){
                int u = in.nextInt() - 1;
                int v = in.nextInt() - 1;
                list.add(new Pair(u, v, Math.max(arr[u],arr[v])));
            }
            list.sort((p1,p2) -> Integer.compare(p1.i, p2.i));
            initialize(n);
            long s1 = 0;
            for(int i = 0; i < list.size(); i++){
                s1 += union(list.get(i).x, list.get(i).y) * list.get(i).i;
            }
            for(int i = 0; i < list.size(); i++){
                Pair p = list.get(i);
                p.i = Math.min(arr[p.x],arr[p.y]);
            }
            list.sort((p1,p2) -> -Integer.compare(p1.i, p2.i));
            initialize(n);
            long s2 = 0;
            for(int i = 0; i < list.size(); i++){
                s2 += union(list.get(i).x, list.get(i).y) * list.get(i).i;
            }
            
            out.println(s1 - s2);
        }
        
        out.close();
    }
    
    public static void main(String[] args)
    {
        new Thread(null ,new Runnable(){
            public void run(){
                try{
                    solve();
                } catch(Exception e){
                    e.printStackTrace();
                }
            }
        },""1"",1<<26).start();
        
    }

    static class Pair implements Comparable<Pair>
    {

        int x,y;
        int i;


        Pair (int x,int y)
        {
                this.x = x;
                this.y = y;
        }

        Pair (int x,int y, int i)
        {
                this.x = x;
                this.y = y;
                this.i = i;
        }

        public int compareTo(Pair o)
        {
            if(this.x != o.x)
                return -Integer.compare(this.x, o.y);
            return -Integer.compare(this.y,o.y);
                //return 0;
        }

        public boolean equals(Object o)
        {
            if (o instanceof Pair)
            {
                Pair p = (Pair)o;
                return p.x == x && p.y==y;
            }
            return false;
        }

        @Override
        public String toString()
        {
            return x + "" ""+ y + "" ""+i;
        }

        /*public int hashCode()
        {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }*/

    } 

    static long add(long a,long b){
        long x=(a+b);
        while(x>=mod) x-=mod;
        return x;
    }

    static long sub(long a,long b){
        long x=(a-b);
        while(x<0) x+=mod;
        return x;
    }
    
    static long mul(long a,long b){
        long x=(a*b);
        while(x>=mod) x-=mod;
        return x;
    }
    
    static String rev(String s){
        StringBuilder sb=new StringBuilder(s);
        sb.reverse();
        return sb.toString();
    }
    
    static long gcd(long x,long y)
    {
        if(y==0)
                return x;
        else
                return gcd(y,x%y);
    }

    static int gcd(int x,int y)
    {
        if(y==0)
                return x;
        else 
                return gcd(y,x%y);
    }

    static long pow(long n,long p,long m)
    {
         long  result = 1;
          if(p==0){
            return n;
          }
          
        while(p!=0)
        {
            if(p%2==1)
                result *= n;
            if(result >= m)
               result %= m;
            p >>=1;
            n*=n;
            if(n >= m)
                n%=m;
        }
        
        return result;
    }

    static long pow(long n,long p)
    {
        long  result = 1;
          if(p==0)
            return 1;

        while(p!=0)
        {
            if(p%2==1)
                result *= n;	    
            p >>=1;
            n*=n;	    
        }
        return result;
    }

    static void debug(Object... o)
    {
            System.out.println(Arrays.deepToString(o));
    }

    static class InputReader
    {

        private final InputStream stream;
        private final byte[] buf = new byte[8192];
        private int curChar, snumChars;
        private SpaceCharFilter filter;

        public InputReader(InputStream stream)
        {
                this.stream = stream;
        }

        public int snext()
        {
                if (snumChars == -1)
                        throw new InputMismatchException();
                if (curChar >= snumChars)
                {
                        curChar = 0;
                        try
                        {
                                snumChars = stream.read(buf);
                        } catch (IOException e)
                        {
                                throw new InputMismatchException();
                        }
                        if (snumChars <= 0)
                                return -1;
                }
                return buf[curChar++];
        }

        public int nextInt()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                int sgn = 1;
                if (c == '-')
                {
                        sgn = -1;
                        c = snext();
                }
                int res = 0;
                do
                {
                        if (c < '0' || c > '9')
                                throw new InputMismatchException();
                        res *= 10;
                        res += c - '0';
                        c = snext();
                } while (!isSpaceChar(c));
                return res * sgn;
        }

        public long nextLong()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                int sgn = 1;
                if (c == '-')
                {
                        sgn = -1;
                        c = snext();
                }
                long res = 0;
                do
                {
                        if (c < '0' || c > '9')
                                throw new InputMismatchException();
                        res *= 10;
                        res += c - '0';
                        c = snext();
                } while (!isSpaceChar(c));
                return res * sgn;
        }

        public int[] nextIntArray(int n)
        {
                int a[] = new int[n];
                for (int i = 0; i < n; i++)
                {
                        a[i] = nextInt();
                }
                return a;
        }

        public long[] nextLongArray(int n)
        {
                long a[] = new long[n];
                for (int i = 0; i < n; i++)
                {
                        a[i] = nextLong();
                }
                return a;
        }

        public String readString()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                StringBuilder res = new StringBuilder();
                do
                {
                        res.appendCodePoint(c);
                        c = snext();
                } while (!isSpaceChar(c));
                return res.toString();
        }

        public String nextLine()
        {
                int c = snext();
                while (isSpaceChar(c))
                        c = snext();
                StringBuilder res = new StringBuilder();
                do
                {
                        res.appendCodePoint(c);
                        c = snext();
                } while (!isEndOfLine(c));
                return res.toString();
        }

        public boolean isSpaceChar(int c)
        {
                if (filter != null)
                        return filter.isSpaceChar(c);
                return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private boolean isEndOfLine(int c)
        {
                return c == '\n' || c == '\r' || c == -1;
        }

        public interface SpaceCharFilter
        {
                public boolean isSpaceChar(int ch);
        }

    }
}    
",CorCod,635,635,nlogn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.TreeMap;
import java.util.Map;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Ribhav
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        CGlassCarving solver = new CGlassCarving();
        solver.solve(1, in, out);
        out.close();
    }

    static class CGlassCarving {
        public void solve(int testNumber, FastReader s, PrintWriter out) {
            TreeMap<Long, Integer> mapH = new TreeMap<>();
            TreeMap<Long, Integer> mapV = new TreeMap<>();
            TreeMap<Long, Integer> hDiff = new TreeMap<>();
            TreeMap<Long, Integer> vDiff = new TreeMap<>();
            long width = s.nextInt();
            long height = s.nextInt();
            mapH.put(0L, 1);
            mapV.put(0L, 1);
            mapV.put(width, 1);
            mapH.put(height, 1);
            vDiff.put(width, 1);
            hDiff.put(height, 1);
            long maxV = height;
            long maxH = width;
            int n = s.nextInt();
            for (int i = 0; i < n; i++) {
                char ch = s.nextCharacter();
                long cut = s.nextInt();
                if (ch == 'H') {
                    Long next = mapH.higherKey(cut);
                    Long prev = mapH.lowerKey(cut);
                    Long diff = next - prev;
                    int freq = hDiff.get(diff);
                    if (freq == 1) {
                        hDiff.remove(diff);
                    } else {
                        hDiff.put(diff, freq - 1);
                    }
                    hDiff.put(next - cut, hDiff.getOrDefault(next - cut, 0) + 1);
                    hDiff.put(cut - prev, hDiff.getOrDefault(cut - prev, 0) + 1);
                    mapH.put(cut, mapH.getOrDefault(cut, 0) + 1);
                } else {
                    Long next = mapV.higherKey(cut);
                    Long prev = mapV.lowerKey(cut);
                    Long diff = next - prev;
                    int freq = vDiff.get(diff);
                    if (freq == 1) {
                        vDiff.remove(diff);
                    } else {
                        vDiff.put(diff, freq - 1);
                    }
                    vDiff.put(next - cut, vDiff.getOrDefault(next - cut, 0) + 1);
                    vDiff.put(cut - prev, vDiff.getOrDefault(cut - prev, 0) + 1);
                    mapV.put(cut, mapV.getOrDefault(cut, 0) + 1);
                }

                out.println(hDiff.lastKey() * vDiff.lastKey());
            }
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private FastReader.SpaceCharFilter filter;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public char nextCharacter() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            return (char) c;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",CorCod,631,631,nlogn
"import java.io.*;
import java.util.*;

public class A {
    public static void main(String args[]) {
        FastScanner scn = new FastScanner();
        int n = scn.nextInt();
        int s = scn.nextInt();
        if (s <= n) {
            System.out.println(1);
        } else if (s > n) {
            if(s%n == 0){
                System.out.println(s/n);
            } else {
                System.out.println(s/n + 1);
            }
        }

    }

    public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(String s) {
            try {
                br = new BufferedReader(new FileReader(s));
            } catch (FileNotFoundException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        public FastScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String nextToken() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(nextToken());
        }

        long nextLong() {
            return Long.parseLong(nextToken());
        }

        double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }
}
",CorCod,864,864,constant
"
// Java program to sort an array according absolute 
// difference with x. 
import
java.io.*; 
import
java.util.*; 

class
GFG 
{ 


// Function to sort an array according absolute 

// difference with x. 

static
void
rearrange(
int
[] arr, 
int
n, 
int
x) 

{ 

TreeMap<Integer, ArrayList<Integer>> m = 
new
TreeMap<>(); 


// Store values in a map with the difference 

// with X as key 

for
(
int
i = 
0
; i < n; i++) 

{ 

int
diff = Math.abs(x - arr[i]); 

if
(m.containsKey(diff)) 

{ 

ArrayList<Integer> al = m.get(diff); 

al.add(arr[i]); 

m.put(diff, al); 

} 

else

{ 

ArrayList<Integer> al = 
new
ArrayList<>(); 

al.add(arr[i]); 

m.put(diff,al); 

} 

} 


// Update the values of array 

int
index = 
0
; 

for
(Map.Entry entry : m.entrySet()) 

{ 

ArrayList<Integer> al = m.get(entry.getKey()); 

for
(
int
i = 
0
; i < al.size(); i++) 

arr[index++] = al.get(i); 

} 

} 


// Function to print the array 

static
void
printArray(
int
[] arr, 
int
n) 

{ 

for
(
int
i = 
0
; i < n; i++) 

System.out.print(arr[i] + 
"" ""
); 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
[] arr = {
10
, 
5
, 
3
, 
9
,
2
}; 

int
n = arr.length; 

int
x = 
7
; 

rearrange(arr, n, x); 

printArray(arr, n); 

} 
} 

// This code is contributed by rachana soma ",CorCod,678,678,nlogn
"/**
 * Created by Baelish on 7/30/2018.
 */

import java.io.*;
import java.util.*;
import static java.lang.Math.*;

public class B {
    public static void main(String[] args)throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int ans = -1;
        int f[] = new int[(int)2e5+50];
        int g[] = new int[(int)2e5+50];

        int n = in.nextInt(), x = in.nextInt();

        int arr[] = new int[n+1];
        for (int i = 1; i <= n && ans == -1; i++) {
            int a = in.nextInt();
            if(f[a] > 0){
                ans = 0; break;
            }
            f[a]++;
            arr[i] = a;
        }

        for (int i = 1; i <= n && ans == -1; i++) {
            int a = arr[i] & x;
            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){
                ans = 1; break;
            }
            
            g[a]++;
        }

        for (int i = 1; i <= n && ans == -1; i++) {
            int a = arr[i] & x;
            if(g[a] > 1){
                ans = 2; break;
            }
            //g[a]++;
        }

        pw.println(ans);



        pw.close();
    }

    static void debug(Object...obj) {
        System.err.println(Arrays.deepToString(obj));
    }

    static class FastReader {
        InputStream is;
        private byte[] inbuf = new byte[1024];
        private int lenbuf = 0, ptrbuf = 0;
        static final int ints[] = new int[128];

        public FastReader(InputStream is){
            for(int i='0';i<='9';i++) ints[i]=i-'0';
            this.is = is;
        }

        public int readByte(){
            if(lenbuf == -1)throw new InputMismatchException();
            if(ptrbuf >= lenbuf){
                ptrbuf = 0;
                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
                if(lenbuf <= 0)return -1;
            }
            return inbuf[ptrbuf++];
        }

        public boolean isSpaceChar(int c) {
            return !(c >= 33 && c <= 126);
        }
        public int skip() {
            int b;
            while((b = readByte()) != -1 && isSpaceChar(b));
            return b;
        }

        public String next(){
            int b = skip();
            StringBuilder sb = new StringBuilder();
            while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public int nextInt(){
            int num = 0, b;
            boolean minus = false;
            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
            if(b == '-'){
                minus = true;
                b = readByte();
            }

            while(true){
                if(b >= '0' && b <= '9'){
                    num = (num<<3) + (num<<1) + ints[b];
                }else{
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }

        public long nextLong() {
            long num = 0;
            int b;
            boolean minus = false;
            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
            if(b == '-'){
                minus = true;
                b = readByte();
            }

            while(true){
                if(b >= '0' && b <= '9'){
                    num = (num<<3) + (num<<1) + ints[b];
                }else{
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
       /* public char nextChar() {
            return (char)skip();
        }*/

        public char[] next(int n){
            char[] buf = new char[n];
            int b = skip(), p = 0;
            while(p < n && !(isSpaceChar(b))){
                buf[p++] = (char)b;
                b = readByte();
            }
            return n == p ? buf : Arrays.copyOf(buf, p);
        }

        /*private char buff[] = new char[1005];
        public char[] nextCharArray(){
            int b = skip(), p = 0;
            while(!(isSpaceChar(b))){
                buff[p++] = (char)b;
                b = readByte();
            }
            return Arrays.copyOf(buff, p);
        }*/
    }
}",CorCod,310,310,linear
"
class
MergeArrays 
{ 

/* Function to move m elements at the end of array mPlusN[] */

void
moveToEnd(
int
mPlusN[], 
int
size) 

{ 

int
i, j = size - 
1
; 

for
(i = size - 
1
; i >= 
0
; i--) 

{ 

if
(mPlusN[i] != -
1
) 

{ 

mPlusN[j] = mPlusN[i]; 

j--; 

} 

} 

} 


/* Merges array N[] of size n into array mPlusN[] 

of size m+n*/

void
merge(
int
mPlusN[], 
int
N[], 
int
m, 
int
n) 

{ 

int
i = n; 


/* Current index of i/p part of mPlusN[]*/

int
j = 
0
; 


/* Current index of N[]*/

int
k = 
0
; 


/* Current index of output mPlusN[]*/

while
(k < (m + n)) 

{ 

/* Take an element from mPlusN[] if 

a) value of the picked element is smaller and we have 

not reached end of it 

b) We have reached end of N[] */

if
((i < (m + n) && mPlusN[i] <= N[j]) || (j == n)) 

{ 

mPlusN[k] = mPlusN[i]; 

k++; 

i++; 

} 

else
// Otherwise take element from N[] 

{ 

mPlusN[k] = N[j]; 

k++; 

j++; 

} 

} 

} 


/* Utility that prints out an array on a line */

void
printArray(
int
arr[], 
int
size) 

{ 

int
i; 

for
(i = 
0
; i < size; i++) 

System.out.print(arr[i] + 
"" ""
); 


System.out.println(
""""
); 

} 


public
static
void
main(String[] args) 

{ 

MergeArrays mergearray = 
new
MergeArrays(); 


/* Initialize arrays */

int
mPlusN[] = {
2
, 
8
, -
1
, -
1
, -
1
, 
13
, -
1
, 
15
, 
20
}; 

int
N[] = {
5
, 
7
, 
9
, 
25
}; 

int
n = N.length; 

int
m = mPlusN.length - n; 


/*Move the m elements at the end of mPlusN*/

mergearray.moveToEnd(mPlusN, m + n); 


/*Merge N[] into mPlusN[] */

mergearray.merge(mPlusN, N, m, n); 


/* Print the resultant mPlusN */

mergearray.printArray(mPlusN, m + n); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,239,239,linear
"import java.io.DataInputStream; 
import java.io.FileInputStream; 
import java.io.IOException; 
import java.io.InputStreamReader; 
import java.util.Scanner; 
import java.util.StringTokenizer;
import java.io.BufferedReader; 

 import java.util.*;
public class Main 
{ 
static Graph graph[];
	public static void add_edge(int u,int v)
	{
		graph[u].adj.add(graph[v]);
		graph[v].adj.add(graph[u]);
	}
	public static void dfs(int index)
	{
		Graph z=graph[index];
		z.vis=1;Graph v;
		for( int i=0;i<z.adj.size();i++)
		{
			v=z.adj.get(i);
			if(v.vis==0)
			{
				v.dist=z.dist+1;
				v.parent=z.val;
				dfs(v.val);
			}
		}
		
		
	}
    static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader() 
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 
  
    public static void main(String[] args) 
    { 
        FastReader sc=new FastReader();
		int n=sc.nextInt();
		Pair arr[]=new Pair[n];
		Pair pref[]=new Pair[n];
		Pair suff[]=new Pair[n];
		for( int i=0;i<n;i++)
		{
			long u=sc.nextLong();
			long v=sc.nextLong();
			arr[i]=new Pair(u,v);
			pref[i]=new Pair(0,0);
			suff[i]=new Pair(0,0);
		}
		pref[0].x=arr[0].x;
		pref[0].y=arr[0].y;
		for( int i=1;i<n;i++)
		{
			pref[i].x=(long)Math.max(pref[i-1].x,arr[i].x);
			pref[i].y=(long)Math.min(pref[i-1].y,arr[i].y);
		}
		suff[n-1].x=arr[n-1].x;
		suff[n-1].y=arr[n-1].y;
		for( int i=n-2;i>=0;i--)
		{
			suff[i].x=(long)Math.max(suff[i+1].x,arr[i].x);
			suff[i].y=(long)Math.min(suff[i+1].y,arr[i].y);
		}
		long max=Long.MIN_VALUE;
		long ans=0;
		
		for( int i=0;i<n;i++)
		{
			long val=Long.MAX_VALUE;
			long val1=Long.MAX_VALUE;
			
			if(i!=0&&i!=n-1)
			{
				 val=(long)Math.min(pref[i-1].y,suff[i+1].y)-(long)Math.max(pref[i-1].x,suff[i+1].x);
				 
			}
			else if(i!=n-1)
			{
				val=suff[i+1].y-suff[i+1].x;
			}
			else
				val=pref[i-1].y-pref[i-1].x;
			
			ans=val;
			if(ans<0)
				ans=0;
			max=(long)Math.max(ans,max);
		}
		System.out.println(max);
     
       
		
		
		
    } 
}
class mycomparator implements Comparator<Graph>
{
	public int compare(Graph a, Graph b)
	{
		return b.dist-a.dist;
	}
}
class Graph
{
	int vis,col,val;int parent;int deg;int dist;
	ArrayList<Graph> adj;
	Graph(int val)
	{
		vis=0;
		col=-1;
		adj=new ArrayList<>();
		parent=-1;
		this.val=val;
		deg=0;
		dist=-1;
	}
}
class Pair
{
	long x,y;
	Pair( long x, long y)
	{
		this.x=x;
		this.y=y;
	}
}",CorCod,120,120,linear
"
// Sorting based Java program to find 
// all elements in array which have 
// atleast two greater elements itself. 
import
java.util.*; 
import
java.io.*; 

class
GFG 
{ 

static
void
findElements(
int
arr[], 
int
n) 
{ 

Arrays.sort(arr); 


for
(
int
i = 
0
; i < n - 
2
; i++) 

System.out.print(arr[i] + 
"" ""
); 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

int
arr[] = { 
2
, -
6
,
3
, 
5
, 
1
}; 

int
n = arr.length; 

findElements(arr, n); 

} 
} 

// This code is contributed by Sahil_Bansall ",CorCod,632,632,nlogn
"import java.util.*;
public class mad{
    
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int cura = 0,curb = 0;
        int ver;
        System.out.println(""? 0 0"");
        System.out.flush();
        ver = sc.nextInt();
        for(int i=29;i>=0;i--){
            System.out.println(""? ""+(cura+(1<<i))+"" ""+curb);
            System.out.flush();
            int temp1 = sc.nextInt();
            System.out.println(""? ""+cura+"" ""+(curb+(1<<i)));
            System.out.flush();
            int temp2 = sc.nextInt();
            if(temp1!=temp2){
                if(temp2==1){
                    cura += (1<<i);
                    curb += (1<<i);
                }
            }
            else{
                if(ver==1) cura += (1<<i);
                if(ver==-1) curb += (1<<i);
                
                ver = temp1;
            }
        }
        System.out.println(""! ""+cura+"" ""+curb);
    }
    
}",CorCod,895,895,logn
"
// Java code to find second largest element in BST 

// A binary tree node 
class
Node { 


int
data; 

Node left, right; 


Node(
int
d) 

{ 

data = d; 

left = right = 
null
; 

} 
} 

class
BinarySearchTree { 


// Root of BST 

Node root; 


// Constructor 

BinarySearchTree() 

{ 

root = 
null
; 

} 


// function to insert new nodes 

public
void
insert(
int
data) 

{ 

this
.root = 
this
.insertRec(
this
.root, data); 

} 


/* A utility function to insert a new node with given 

key in BST */

Node insertRec(Node node, 
int
data) 

{ 

/* If the tree is empty, return a new node */

if
(node == 
null
) { 

this
.root = 
new
Node(data); 

return
this
.root; 

} 


/* Otherwise, recur down the tree */

if
(data < node.data) { 

node.left = 
this
.insertRec(node.left, data); 

} 
else
{ 

node.right = 
this
.insertRec(node.right, data); 

} 

return
node; 

} 


// class that stores the value of count 

public
class
count { 

int
c = 
0
; 

} 


// Function to find 2nd largest element 

void
secondLargestUtil(Node node, count C) 

{ 

// Base cases, the second condition is important to 

// avoid unnecessary recursive calls 

if
(node == 
null
|| C.c >= 
2
) 

return
; 


// Follow reverse inorder traversal so that the 

// largest element is visited first 

this
.secondLargestUtil(node.right, C); 


// Increment count of visited nodes 

C.c++; 


// If c becomes k now, then this is the 2nd largest 

if
(C.c == 
2
) { 

System.out.print(
""2nd largest element is ""
+ 

node.data); 

return
; 

} 


// Recur for left subtree 

this
.secondLargestUtil(node.left, C); 

} 


// Function to find 2nd largest element 

void
secondLargest(Node node) 

{ 

// object of class count 

count C = 
new
count(); 

this
.secondLargestUtil(
this
.root, C); 

} 


// Driver function 

public
static
void
main(String[] args) 

{ 

BinarySearchTree tree = 
new
BinarySearchTree(); 


/* Let us create following BST 

50 

/ \ 

30 70 

/ \ / \ 

20 40 60 80 */


tree.insert(
50
); 

tree.insert(
30
); 

tree.insert(
20
); 

tree.insert(
40
); 

tree.insert(
70
); 

tree.insert(
60
); 

tree.insert(
80
); 


tree.secondLargest(tree.root); 

} 
} 

// This code is contributed by Kamal Rawal ",CorCod,226,226,linear
"
// Java program to convert BST to binary tree such that sum of 
// all greater keys is added to every key 

class
Node { 


int
data; 

Node left, right; 


Node(
int
d) { 

data = d; 

left = right = 
null
; 

} 
} 

class
Sum { 


int
sum = 
0
; 
} 

class
BinaryTree { 


static
Node root; 

Sum summ = 
new
Sum(); 


// A recursive function that traverses the given BST in reverse inorder and 

// for every key, adds all greater keys to it 

void
addGreaterUtil(Node node, Sum sum_ptr) { 


// Base Case 

if
(node == 
null
) { 

return
; 

} 


// Recur for right subtree first so that sum of all greater 

// nodes is stored at sum_ptr 

addGreaterUtil(node.right, sum_ptr); 


// Update the value at sum_ptr 

sum_ptr.sum = sum_ptr.sum + node.data; 


// Update key of this node 

node.data = sum_ptr.sum; 


// Recur for left subtree so that the updated sum is added 

// to smaller nodes 

addGreaterUtil(node.left, sum_ptr); 

} 


// A wrapper over addGreaterUtil(). It initializes sum and calls 

// addGreaterUtil() to recursivel upodate and use value of sum 

Node addGreater(Node node) { 

addGreaterUtil(node, summ); 

return
node; 

} 


// A utility function to print inorder traversal of Binary Tree 

void
printInorder(Node node) { 

if
(node == 
null
) { 

return
; 

} 

printInorder(node.left); 

System.out.print(node.data + 
"" ""
); 

printInorder(node.right); 

} 


// Driver program to test the above functions 

public
static
void
main(String[] args) { 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
5
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
13
); 


System.out.println(
""Inorder traversal of given tree ""
); 

tree.printInorder(root); 

Node node = tree.addGreater(root); 

System.out.println(
""""
); 

System.out.println(
""Inorder traversal of modified tree ""
); 

tree.printInorder(node); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,379,379,linear
"
// Java program to find smallest 
// number to find smallest number 
// with N as sum of digits and 
// divisible by 10^N. 
import
java.io.*; 

class
GFG 
{ 

static
void
digitsNum(
int
N) 
{ 

// If N = 0 the string will be 0 

if
(N == 
0
) 

System.out.println(
""0""
); 



// If n is not perfectly divisible 

// by 9 output the remainder 

if
(N % 
9
!= 
0
) 

System.out.print((N % 
9
)); 



// Print 9 N/9 times 

for
(
int
i = 
1
; i <= (N / 
9
); ++i) 

System.out.print(
""9""
); 



// Append N zero's to the number so 

// as to make it divisible by 10^N 

for
(
int
i = 
1
; i <= N; ++i) 

System.out.print(
""0""
); 

System.out.print(
""""
); 

} 


// Driver Code 

public
static
void
main (String[] args) 

{ 

int
N = 
5
; 

System.out.print(
""The number is : ""
); 

digitsNum(N); 

} 
} 

// This code is contributed by vt_m ",CorCod,14,14,linear
"
// Java program to find minimum cost 
// to reduce array size to 1, 
import
java.lang.*; 

public
class
GFG { 


// function to calculate the 

// minimum cost 

static
int
cost(
int
[]a, 
int
n) 

{ 

int
min = a[
0
]; 


// find the minimum using 

// for loop 

for
(
int
i = 
1
; i< a.length; i++) 

{ 

if
(a[i] < min) 

min = a[i]; 

} 


// Minimum cost is n-1 multiplied 

// with minimum element. 

return
(n - 
1
) * min; 

} 


// driver program to test the 

// above function. 

static
public
void
main (String[] args) 

{ 


int
[]a = { 
4
, 
3
, 
2
}; 

int
n = a.length; 


System.out.println(cost(a, n)); 

} 
} 

// This code is contributed by parashar. ",CorCod,164,164,linear
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class simple implements Runnable {


    public void run()
    {

        InputReader input = new InputReader(System.in);
        PrintWriter w = new PrintWriter(System.out);
        int n = input.nextInt();

            System.out.println((2*n*n)-(2*n)+1);
    }



    class Graph{
        private final int v;
        private List<List<Integer>> adj;
        Graph(int v){
            this.v = v;
            adj = new ArrayList<>(v);
            for(int i=0;i<v;i++){
                adj.add(new LinkedList<>());
            }
        }
        private void addEdge(int a,int b){
            adj.get(a).add(b);
        }
        private boolean isCyclic()
        {
            boolean[] visited = new boolean[v];
            boolean[] recStack = new boolean[v];
            for (int i = 0; i < v; i++)
                if (isCyclicUtil(i, visited, recStack))
                    return true;

            return false;
        }
        private boolean isCyclicUtil(int i, boolean[] visited, boolean[] recStack)
        {
            if (recStack[i])
                return true;
            if (visited[i])
                return false;
            visited[i] = true;
            recStack[i] = true;
            List<Integer> children = adj.get(i);
            for (Integer c: children)
                if (isCyclicUtil(c, visited, recStack))
                    return true;
            recStack[i] = false;
            return false;
        }
    }
    public static void sortbyColumn(int arr[][], int col)
    {

        Arrays.sort(arr, new Comparator<int[]>()
        {
            public int compare(int[] o1, int[] o2){
                return(Integer.valueOf(o1[col]).compareTo(o2[col]));
            }
        });

    }
    static long gcd(long a, long b)
    {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }
    public static class DJSet {
        public int[] upper;

        public DJSet(int n) {
            upper = new int[n];
            Arrays.fill(upper, -1);
        }

        public int root(int x) {
            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
        }

        public boolean equiv(int x, int y) {
            return root(x) == root(y);
        }

        public boolean union(int x, int y) {
            x = root(x);
            y = root(y);
            if (x != y) {
                if (upper[y] < upper[x]) {
                    int d = x;
                    x = y;
                    y = d;
                }
                upper[x] += upper[y];
                upper[y] = x;
            }
            return x == y;
        }
    }
    public static int[] radixSort(int[] f)
    {
        int[] to = new int[f.length];
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        return f;
    }
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars==-1)
                throw new InputMismatchException();

            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                }
                catch (IOException e) {
                    throw new InputMismatchException();
                }

                if(numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            int c = read();

            while(isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;
            do {
                if(c<'0'||c>'9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    public static void main(String args[]) throws Exception {
        new Thread(null, new simple(),""TaskA"",1<<26).start();
    }
}",CorCod,830,830,constant
"import java.util.*;
import static java.lang.Math.*;
import java.io.*;

public class SolutionB {
       
      public static void main(String args[])throws IOException{
              Scanner sc = new Scanner(System.in);
              int n = sc.nextInt();
              int k = sc.nextInt();
              Set<Integer> set1 = new HashSet<Integer>();
              Set<Integer> set2 = new HashSet<Integer>();
              int a[] = new int[n];
              for(int i = 0; i < n; i++){
                     a[i] = sc.nextInt();
                     if(!set1.contains(a[i])){
                            set1.add(a[i]);
                     }else{
                            System.out.println(0);
                            return;
                     }
              }
              for(int i = 0; i < n; i++){
                     int b = a[i] & k;
                     if(b != a[i] && set1.contains(b)){
                            System.out.println(1);
                            return;
                     }
                     //if(!set2.contains(b)){
                            //set2.add(b);
                     //}else{
                       //     System.out.println(2);
                         //   return;
                     //}
              }
              for(int i = 0; i < n; i++){
                     int b = a[i] & k;
                     if(b != a[i] && set2.contains(b)){
                            System.out.println(2);
                            return;
                     }else{
                            set2.add(b);
                     }
              }
              System.out.println(-1);
      }
}",CorCod,325,325,linear
"
// Java program to check if two binary tree are cousins 
class
Node 
{ 

int
data; 

Node left, right; 


Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root; 


// Recursive function to check if two Nodes are 

// siblings 

boolean
isSibling(Node node, Node a, Node b) 

{ 

// Base case 

if
(node == 
null
) 

return
false
; 


return
((node.left == a && node.right == b) || 

(node.left == b && node.right == a) || 

isSibling(node.left, a, b) || 

isSibling(node.right, a, b)); 

} 


// Recursive function to find level of Node 'ptr' in 

// a binary tree 

int
level(Node node, Node ptr, 
int
lev) 

{ 

// base cases 

if
(node == 
null
) 

return
0
; 


if
(node == ptr) 

return
lev; 


// Return level if Node is present in left subtree 

int
l = level(node.left, ptr, lev + 
1
); 

if
(l != 
0
) 

return
l; 


// Else search in right subtree 

return
level(node.right, ptr, lev + 
1
); 

} 


// Returns 1 if a and b are cousins, otherwise 0 

boolean
isCousin(Node node, Node a, Node b) 

{ 

// 1. The two Nodes should be on the same level 

// in the binary tree. 

// 2. The two Nodes should not be siblings (means 

// that they should not have the same parent 

// Node). 

return
((level(node, a, 
1
) == level(node, b, 
1
)) && 

(!isSibling(node, a, b))); 

} 


//Driver program to test above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
1
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
3
); 

tree.root.left.left = 
new
Node(
4
); 

tree.root.left.right = 
new
Node(
5
); 

tree.root.left.right.right = 
new
Node(
15
); 

tree.root.right.left = 
new
Node(
6
); 

tree.root.right.right = 
new
Node(
7
); 

tree.root.right.left.right = 
new
Node(
8
); 


Node Node1, Node2; 

Node1 = tree.root.left.left; 

Node2 = tree.root.right.right; 

if
(tree.isCousin(tree.root, Node1, Node2)) 

System.out.println(
""Yes""
); 

else

System.out.println(
""No""
); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,43,43,linear
"
// Java code to find number of subsequences of 
// ""ab"" in the string S which is repeated K times. 

import
java.io.*; 

class
GFG { 


static
int
countOccurrences(String s, 
int
K) 

{ 

int
n = s.length(); 

int
C = 
0
, c1 = 
0
, c2 = 
0
; 

for
(
int
i = 
0
; i < n; i++) { 

if
(s.charAt(i) == 
'a'
) 

c1++; 
// Count of 'a's 

if
(s.charAt(i) == 
'b'
) { 

c2++; 
// Count of 'b's 


// occurrence of ""ab""s 

// in string S 

C += c1; 

} 

} 


// Add following two : 

// 1) K * (Occurrences of ""ab"" in single string) 

// 2) a is from one string and b is from other. 

return
C * K + (K * (K - 
1
) / 
2
) * c1 * c2; 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

String S = 
""abcb""
; 

int
k = 
2
; 


System.out.println(countOccurrences(S, k)); 

} 
} 

// This code is contributed by vt_m. ",CorCod,263,263,linear
"import java.util.*;
import java.math.*;
public class Main{
    public static void main(String [] args)
    {
        Scanner scan=new Scanner(System.in);
        int n=scan.nextInt();
        int m=scan.nextInt();
        int a[]=new int[m+1];
        int i,j;
        int c=0;
        for(i=0;i<n;i++)
        {
            int l=scan.nextInt();
            int r=scan.nextInt();
            for(j=l;j<=r;j++)
            {
                if(a[j]!=1)
                {
                    a[j]=1;
                    c++;
                }
            }
        }
        System.out.println(m-c);
        for(i=1;i<=m;i++)
        {
            if(a[i]==0)
            {
                System.out.print(i+"" "");
            }
        }
    }
}",CorCod,575,575,quadratic
"
// java program to find maximum 
// equilibrium sum. 
import
java.io.*; 

class
GFG { 


// Function to find maximum 

// equilibrium sum. 

static
int
findMaxSum(
int
[]arr, 
int
n) 

{ 

int
res = Integer.MIN_VALUE; 


for
(
int
i = 
0
; i < n; i++) 

{ 

int
prefix_sum = arr[i]; 


for
(
int
j = 
0
; j < i; j++) 

prefix_sum += arr[j]; 


int
suffix_sum = arr[i]; 


for
(
int
j = n - 
1
; j > i; j--) 

suffix_sum += arr[j]; 


if
(prefix_sum == suffix_sum) 

res = Math.max(res, prefix_sum); 

} 


return
res; 

} 


// Driver Code 

public
static
void
main (String[] args) 

{ 

int
arr[] = {-
2
, 
5
, 
3
, 
1
, 
2
, 
6
, -
4
, 
2
}; 

int
n = arr.length; 

System.out.println(findMaxSum(arr, n)); 

} 
} 

// This code is contributed by anuj_67. ",CorCod,389,389,quadratic
"
import java.util.*;


public class HelloWorld {
	static long SQR(long a) {
		return a * a;
	}
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		String str = sc.next();
		char s[] = str.toCharArray();
		Arrays.parallelSort(s);
		str = new String(s);
		int d = 0;
		int ans = 0;

		for(int i = 0;i < str.length();i++) {
			int x = str.charAt(i) - 'a';
			if(k == 0)continue;
			if(x >= d) {
				ans = ans + x + 1;
				d = x + 2;
				k = k - 1;
			}
		}
		if(k > 0)ans = -1;
		System.out.println(ans);
	}
}
",CorCod,663,663,nlogn
"

import java.util.Scanner;

public class TaxiDriversAndLyft2 {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		long n = scanner.nextLong();
		long m = scanner.nextLong();
		long[] people = new long[(int) (n+m)];
		int[] taxiDrivers = new int[(int) (n+m)];
		
		for(int i = 0;i< (n+m); i++) {
			people[i] = scanner.nextLong();
		}
		
		for(int i = 0;i< (n+m); i++) {
			taxiDrivers[i] = scanner.nextInt();
		}
		
		int lastTaxiDriverIndex = -1;
		long[] riderCountArray = new long[(int) (m)];
		long[] a1 = new long[(int)n];
		long[] b1 = new long[(int)m];
		
		int j=0, k=0;
		for(int i = 0;i< (n+m); i++) {	
			if(taxiDrivers[i] == 0) {
				a1[j] = people[i];
				j++;
			}
			else  {
				b1[k] = people[i];
				k++;
			}
		}
		
		int l = 0, q=0;
		for(int i=0;i<j;i++) {
			while ((l<m-1 && m>1) && Math.abs(a1[i] - b1[l]) > Math.abs(a1[i] - b1[l+1])) {
				l++; 
			}
			
			riderCountArray[l]++;	
		}
		
		for(int i = 0;i< (m); i++) {
			System.out.print(riderCountArray[i]+"" "");
		}
	} 
}
",CorCod,59,59,linear
"
// A simple JAVA program to rearrange 
// contents of arr[] such that arr[j] 
// becomes j if arr[i] is j 

class
GFG { 


// A simple method to rearrange 

// 'arr[0..n-1]' so that 'arr[j]' 

// becomes 'i' if 'arr[i]' is 'j' 

static
void
rearrange(
int
arr[], 
int
n) 

{ 

for
(
int
i = 
0
; i < n; i++) { 


// retrieving old value and 

// storing with the new one 

arr[arr[i] % n] += i * n; 

} 


for
(
int
i = 
0
; i < n; i++) { 


// retrieving new value 

arr[i] /= n; 

} 

} 


// A utility function to print 

// contents of arr[0..n-1] 

static
void
printArray(
int
arr[], 
int
n) 

{ 

for
(
int
i = 
0
; i < n; i++) { 

System.out.print(arr[i] + 
"" ""
); 

} 


System.out.println(); 

} 


// Drive code 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
2
, 
0
, 
1
, 
4
, 
5
, 
3
}; 

int
n = arr.length; 


System.out.println(
""Given array is : ""
); 

printArray(arr, n); 


rearrange(arr, n); 


System.out.println(
""Modified array is :""
); 

printArray(arr, n); 

} 
} 

// This code has been contributed by 29AjayKumar ",CorCod,103,103,linear
"import java.io.*;
import java.util.*;

public class cf {

	static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner() {
            try {
                br = new BufferedReader(new InputStreamReader(System.in));
                st = new StringTokenizer(br.readLine());
            } catch (Exception e){e.printStackTrace();}
        }

        public String next() {
            if (st.hasMoreTokens()) return st.nextToken();
            try {st = new StringTokenizer(br.readLine());}
            catch (Exception e) {e.printStackTrace();}
            return st.nextToken();
        }

        public int nextInt() {return Integer.parseInt(next());}

        public long nextLong() {return Long.parseLong(next());}

        public double nextDouble() {return Double.parseDouble(next());}

        public String nextLine() {
            String line = """";
            if(st.hasMoreTokens()) line = st.nextToken();
            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}
            while(st.hasMoreTokens()) line += "" ""+st.nextToken();
            return line;
        }
    }
    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        PrintWriter pw = new PrintWriter(System.out);

        int n = sc.nextInt();
        pw.println(n/2+1);
        pw.close();
    }
}",CorCod,783,783,constant
"import java.util.ArrayList;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Cr500 {
    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);
        int n, x, status = -1;
        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();
        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();
        n = scanner.nextInt();
        x = scanner.nextInt();

        for(int i = 0; i < n; i++) {
            int v;
            if(!a.add(v = scanner.nextInt())) {
                System.out.println(0);
                return;
            }

            if(!bitA.add(v & x)) {
                status = 2;
            }
            al.add(v);
            bl.add(v & x);
        }

        if(contains(al, bl)) {
            System.out.println(1);
            return;
        }

        System.out.println(status);
    }

    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {
        for(int i = 0; i < a.size(); i++) {
            int v1 = a.get(i);
            for(int j = 0; j < b.size(); j++) {
                int v2 = b.get(j);
                if(i != j && v1 == v2) {
                    return true;
                }
            }
        }
        return false;
    }
}",CorCod,464,464,quadratic
"
// Java implementation of smallest difference 
// triplet 
import
java.util.Arrays; 

class
GFG { 


// function to find maximum number 

static
int
maximum(
int
a, 
int
b, 
int
c) 

{ 

return
Math.max(Math.max(a, b), c); 

} 


// function to find minimum number 

static
int
minimum(
int
a, 
int
b, 
int
c) 

{ 

return
Math.min(Math.min(a, b), c); 

} 


// Finds and prints the smallest Difference 

// Triplet 

static
void
smallestDifferenceTriplet(
int
arr1[], 

int
arr2[], 
int
arr3[], 
int
n) 

{ 


// sorting all the three arrays 

Arrays.sort(arr1); 

Arrays.sort(arr2); 

Arrays.sort(arr3); 


// To store resultant three numbers 

int
res_min=
0
, res_max=
0
, res_mid=
0
; 


// pointers to arr1, arr2, arr3 

// respectively 

int
i = 
0
, j = 
0
, k = 
0
; 


// Loop until one array reaches to its end 

// Find the smallest difference. 

int
diff = 
2147483647
; 


while
(i < n && j < n && k < n) 

{ 

int
sum = arr1[i] + arr2[j] + arr3[k]; 


// maximum number 

int
max = maximum(arr1[i], arr2[j], arr3[k]); 


// Find minimum and increment its index. 

int
min = minimum(arr1[i], arr2[j], arr3[k]); 

if
(min == arr1[i]) 

i++; 

else
if
(min == arr2[j]) 

j++; 

else

k++; 


// comparing new difference with the 

// previous one and updating accordingly 

if
(diff > (max - min)) 

{ 

diff = max - min; 

res_max = max; 

res_mid = sum - (max + min); 

res_min = min; 

} 

} 


// Print result 

System.out.print(res_max + 
"", ""
+ res_mid 

+ 
"", ""
+ res_min); 

} 


//driver code 

public
static
void
main (String[] args) 

{ 


int
arr1[] = {
5
, 
2
, 
8
}; 

int
arr2[] = {
10
, 
7
, 
12
}; 

int
arr3[] = {
9
, 
14
, 
6
}; 


int
n = arr1.length; 


smallestDifferenceTriplet(arr1, arr2, arr3, n); 

} 
} 

// This code is contributed by Anant Agarwal. ",CorCod,703,703,nlogn
"
import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.StringTokenizer;

public class ChainReaction implements Closeable {

  private InputReader in = new InputReader(System.in);
  private PrintWriter out = new PrintWriter(System.out);
  
  private class Beacon implements Comparable<Beacon> {
    private int position, range, score;

    private Beacon(int position, int range) {
      this.position = position;
      this.range = range;
    }

    public void setScore(int score) {
      this.score = score;
    }

    @Override
    public int compareTo(Beacon o) {
      return Integer.compare(this.position, o.position);
    }
  }

  public void solve() {
    int n = in.ni();
    if (n == 1) {
      out.println(0);
      return;
    }
    beacons = new ArrayList<>();
    for (int i = 0; i < n; i++) {
      beacons.add(new Beacon(in.ni(), in.ni()));
    }
    beacons.sort(Comparator.naturalOrder());
    for (int i = 1; i < n; i++) {
      int left = 0, right = i - 1, position = beacons.get(i).position, range = beacons.get(i).range;
      int leftmost = i;
      while (left <= right) {
        int mid = left + (right - left) / 2;
        if (position - range <= beacons.get(mid).position) {
          leftmost = Math.min(leftmost, mid);
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }
      beacons.get(i).setScore(i - leftmost);
    }
    dp = new Integer[n];
    int ans = Integer.MAX_VALUE;
    for (int i = n - 1; i >= 0; i--) {
      ans = Math.min(n - 1 - i + recurse(i), ans);
    }
    out.println(ans);
  }
  
  private List<Beacon> beacons;
  private Integer[] dp;
  
  private int recurse(int idx) {
    if (idx <= 0) return 0;
    
    if (dp[idx] != null) return dp[idx];
    
    int destroyed = beacons.get(idx).score;
    int ans = destroyed + recurse(idx - destroyed - 1);
    return dp[idx] = ans;
  }
  
  @Override
  public void close() throws IOException {
    in.close();
    out.close();
  }

  static class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
      reader = new BufferedReader(new InputStreamReader(stream), 32768);
      tokenizer = null;
    }

    public String next() {
      while (tokenizer == null || !tokenizer.hasMoreTokens()) {
        try {
          tokenizer = new StringTokenizer(reader.readLine());
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return tokenizer.nextToken();
    }

    public int ni() {
      return Integer.parseInt(next());
    }

    public long nl() {
      return Long.parseLong(next());
    }

    public void close() throws IOException {
      reader.close();
    }
  }

  public static void main(String[] args) throws IOException {
    try (ChainReaction instance = new ChainReaction()) {
      instance.solve();
    }
  }
}
",CorCod,690,690,nlogn
"import java.util.Scanner;
public class Tokitsukaze {


    public static void main(String[] args) {
        Scanner sc =new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        long k =sc.nextLong();
        double[]p=new double[m];
        for(int i = 0;i<m;i++){
            p[i]=sc.nextDouble();
        }
        int c=0;
        int used=0;
        for(int i = 0;i<m;){
            long low=(long)((Math.floor(p[i]/k)*k)-i)+1;
            long high=low+k;
            for(int j=i;j<m;j++){
                if(p[j]>=low&&p[i]<=high){
                    i++;
                }
            }
            c++;
        }
        System.out.println(c);

    }
    
}
",CorCod,401,401,quadratic
"
// Efficient Java program to sort an 
// array of numbers in range from 1 
// to n. 
import
java.io.*; 
import
java.util.*; 

public
class
GFG { 



// function for sort array 

static
void
sortit(
int
[]arr, 
int
n) 

{ 

for
(
int
i = 
0
; i < n; i++) 

{ 

arr[i]=i+
1
; 



} 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
[]arr = {
10
, 
7
, 
9
, 
2
, 
8
, 

3
, 
5
, 
4
, 
6
, 
1
}; 

int
n = arr.length; 


// for sort an array 

sortit(arr, n); 


// for print all the 

// element in sorted way 

for
(
int
i = 
0
; i < n; i++) 

System.out.print(arr[i] + 
"" ""
); 

} 
} 

// This code is contributed by Manish Shaw 
// (manishshaw1) ",CorCod,197,197,linear
"import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner in =new Scanner(System.in);
		int n = in.nextInt();
		int k = in.nextInt();
		int[] arr = new int[n];
		for(int i = 0; i < n; i++)
			arr[i] = in.nextInt();
		for(int i = n-1; i > 0; i--)
			arr[i] -= arr[i-1];
		arr[0] = 0;
		Arrays.sort(arr);
		long sum = 0;
		for(int i = n-k; i >= 0; i--)
			sum += arr[i];
		System.out.println(sum);
	}
}",CorCod,604,604,nlogn
"import java.util.*;
import java.math.*;
import java.io.*;

public class CF1068A {
	public CF1068A() {
		FS scan = new FS();
		long n = scan.nextLong(), m = scan.nextLong(), k = scan.nextLong(), l = scan.nextLong();
		long ceil = (k + l + m - 1) / m;
		if(k + l <= n && ceil * m <= n) System.out.println(ceil);
		else System.out.println(-1);
	}
	class FS {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer("""");
		public String next() {
			while(!st.hasMoreTokens()) {
				try { st = new StringTokenizer(br.readLine()); }
				catch(Exception e) { e.printStackTrace(); }
			}
			return st.nextToken();
		}
		public int nextInt() { return Integer.parseInt(next()); }
		public long nextLong() { return Long.parseLong(next()); }
	}
	public static void main(String[] args) { new CF1068A(); }
}
",CorCod,804,804,constant
"import java.util.*;

public class Main {
	static int mod = 1000000007;
  static int size = 200000;
	static long[] fac = new long[size];
	static long[] finv = new long[size];
	static long[] inv = new long[size];
	static int INF = Integer.MAX_VALUE;

 	public static void main(String[] args){
		Scanner scanner = new Scanner(System.in);
		String[] s = new String[2];
		for(int i = 0; i < 2; i++){
			s[i] = scanner.next();
		}
		int n = s[0].length();
		char[][] c = new char[2][n];
		for(int i = 0; i < 2; i++){
			for(int j = 0; j < n; j++){
				c[i][j] = s[i].charAt(j);
			}
		}
		int count = 0;
		for(int i = 0; i < n-1; i++){
			if(c[0][i] == '0' && c[1][i] == '0' && c[0][i+1] == '0'){
				c[0][i] = 'X';
				c[1][i] = 'X';
				c[0][i+1] = 'X';
				count++;
			}
			if(c[0][i] == '0' && c[1][i] == '0' && c[1][i+1] == '0'){
				c[0][i] = 'X';
				c[1][i] = 'X';
				c[1][i+1] = 'X';
				count++;
			}
			if(c[0][i] == '0' && c[0][i+1] == '0' && c[1][i+1] == '0'){
				c[0][i] = 'X';
				c[0][i+1] = 'X';
				c[1][i+1] = 'X';
				count++;
			}
			if(c[0][i+1] == '0' && c[1][i+1] == '0' && c[1][i] == '0'){
				c[1][i] = 'X';
				c[0][i+1] = 'X';
				c[1][i+1] = 'X';
				count++;
			}
		}
		System.out.println(count);
	}
	public static boolean isPrime(int n){
		if(n == 1) return false;
		if(n == 2 || n == 3) return true;
		for(int i = 2; i <= Math.sqrt(n); i++){
			if(n % i == 0) return false;
		}
		return true;
	}
	// tar の方が数字が大きいかどうか
	static boolean compare(String tar, String src) {
		if (src == null) return true;
		if (src.length() == tar.length()) {
			int len = tar.length();
			for (int i = 0; i < len; i++) {
				if (src.charAt(i) > tar.charAt(i)) {
					return false;
				} else if (src.charAt(i) < tar.charAt(i)) {
					return true;
				}
			}
			return tar.compareTo(src) > 0 ? true : false;
		} else if (src.length() < tar.length()) {
			return true;
		} else if (src.length() > tar.length()) {
			return false;
		}
		return false;
	}
	public static class Edge{
		int to;
		Edge(int to){
			this.to = to;
		}
	}
	public static void swap(long a, long b){
		long tmp = 0;
		if(a > b){
			tmp = a;
			a = b;
			b = tmp;
		}
	}
  static class Pair implements Comparable<Pair>{
    int first, second;
    Pair(int a, int b){
        first = a;
        second = b;
    }
    @Override
    public boolean equals(Object o){
        if (this == o) return true;
        if (!(o instanceof Pair)) return false;
        Pair p = (Pair) o;
        return first == p.first && second == p.second;
    }
    @Override
    public int compareTo(Pair p){
        return first == p.first ? second - p.second : first - p.first; //firstで昇順にソート
        //return (first == p.first ? second - p.second : first - p.first) * -1; //firstで降順にソート
        //return second == p.second ? first - p.first : second - p.second;//secondで昇順にソート
        //return (second == p.second ? first - p.first : second - p.second)*-1;//secondで降順にソート
    }
  }

  //繰り返し二乗法
  public static long pow(long x, long n){
    long ans = 1;
    while(n > 0){
      if((n & 1) == 1){
        ans = ans * x;
        ans %= mod;
      }
      x = x * x % mod;
      n >>= 1;
    }
    return ans;
  }

	public static long div(long x, long y){
		return (x*pow(y, mod-2))%mod;
	}

  //fac, inv, finvテーブルの初期化、これ使う場合はinitComb()で初期化必要
	public static  void initComb(){
		fac[0] = finv[0] = inv[0] = fac[1] = finv[1] = inv[1] = 1;
		for (int i = 2; i < size; ++i) {
			fac[i] = fac[i - 1] * i % mod;
			inv[i] = mod - (mod / i) * inv[(int) (mod % i)] % mod;
			finv[i] = finv[i - 1] * inv[i] % mod;
		}
	}

	//nCk % mod
	public static long comb(int n, int k){
		return fac[n] * finv[k] % mod * finv[n - k] % mod;
	}

	//n! % mod
	public static long fact(int n){
		return fac[n];
	}

	//(n!)^-1 with % mod
	public static long finv(int n){
		return finv[n];
	}

  static class UnionFind {
    int[] parent;
    public UnionFind(int size) {
      parent = new int[size];
      Arrays.fill(parent, -1);
    }
    public boolean unite(int x, int y) {
      x = root(x);
      y = root(y);
      if (x != y) {
        if (parent[y] < parent[x]) {
          int tmp = y;
          y = x;
          x = tmp;
        }
        parent[x] += parent[y];
        parent[y] = x;
        return true;
      }
      return false;
    }
    public boolean same(int x, int y) {
      return root(x) == root(y);
    }
    public int root(int x) {
      return parent[x] < 0 ? x : (parent[x] = root(parent[x]));
    }
    public int size(int x) {
      return -parent[root(x)];
    }
  }
	public static int upperBound(int[] array, int value) {
			 int low = 0;
			 int high = array.length;
			 int mid;
			 while( low < high ) {
					 mid = ((high - low) >>> 1) + low; // (high + low) / 2
					 if( array[mid] <= value ) {
							 low = mid + 1;
					 } else {
							 high = mid;
					 }
			 }
			 return low;
	 }
	 public static final int lowerBound(final int[] arr, final int value) {
    	int low = 0;
    	int high = arr.length;
    	int mid;
    	while (low < high){
        	mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
        	if (arr[mid] < value) {
          	low = mid + 1;
        	} else {
            high = mid;
        	}
    	}
    	return low;
		}
  //n,mの最大公約数
  public static long gcd(long n, long m){
    if(m > n) return gcd(m,n);
    if(m == 0) return n;
    return gcd(m, n%m);
  }
	//3要素のソート
	private class Pair2 implements Comparable<Pair2> {
		String s;
		int p;
		int index;
		public Pair2(String s, int p, int index) {
				this.s = s;
				this.p = p;
				this.index = index;
		}

		public int compareTo(Pair2 other) {
				if (s.equals(other.s)) {
						return other.p - this.p;
				}
				return this.s.compareTo(other.s);
		}
	}
	//c -> intに変換
public static int c2i(char c){
	if('A' <= c && c <= 'Z'){
		return c - 'A';
	}else{
		return c - 'a' + 26;
	}
}
// int -> charに変換
public static char i2c(int i){
	if(0 <= i && i < 26){
			return (char)(i + 'A');
	}else{
			return (char)(i + 'a' - 26);
	}
}

}
",CorCod,860,860,constant
"/**
* Given a binary array sorted in non-increasing order, count the number of 1’s in it. 
**/
/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
class Ideone
{	public static int countOnes(int arr[], int low, int high)
	{
  		if(high >= low)
  		{
    		// get the middle index
    		int mid = low + (high - low)/2;

    		// check if the element at middle index is last 1
    		if ( (mid == high || arr[mid+1] == 0) && (arr[mid] == 1))
      			return mid+1;

    		// If element is not last 1, recur for right side
    		if (arr[mid] == 1)
      			return countOnes(arr, (mid + 1), high);

    		// else recur for left side
    		return countOnes(arr, low, (mid -1));
  		}
  		return 0;
	}

	public static void main (String[] args) throws java.lang.Exception
	{
	    int arr[] = {1, 1, 1, 1, 0, 0, 0};
      int n = arr.length;
      System.out.println(""Count of 1's in given array is "" + countOnes(arr, 0, n-1));
	}
",CorCod,878,878,logn
"import java.io.IOException;
import java.io.InputStream;
import java.util.InputMismatchException;
import java.util.Stack;
public class D527A2 {

	public static void main(String[] args) {
		FastScanner in = new FastScanner(System.in);
		int N = in.nextInt();
		Stack<Integer> stack = new Stack<>();
		for(int i = 0; i < N; i++) {
			int num = in.nextInt() % 2;
			if(stack.size() >= 1 && stack.lastElement() == num)
				stack.pop();
			else
				stack.add(num);
		}
		
		System.out.println(stack.size() <= 1 ? ""YES"" : ""NO"");
	}
	
	/**
	 * Source: Matt Fontaine
	 */
	static class FastScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int chars;

		public FastScanner(InputStream stream) {
			this.stream = stream;
		}

		int read() {
			if (chars == -1)
				throw new InputMismatchException();
			if (curChar >= chars) {
				curChar = 0;
				try {
					chars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (chars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}

}
/*
5
2 1 1 2 5
outputCopy
YES
inputCopy
3
4 5 3
outputCopy
YES
inputCopy
2
10 10
outputCopy
YES
inputCopy
3
1 2 3
outputCopy
NO

5
2 3 2 2 3

YES
*/",CorCod,375,375,linear
"

import java.util.Scanner;
public class Stones {
	public static void main(String[] args)
	{
		Scanner input=new Scanner(System.in);
		int n=input.nextInt();
		int s1=0;
		int s2=0;
		for (int i=0;i<n;++i)
			s1+=input.nextInt();
		for (int i=0;i<n;++i)
			s2+=input.nextInt();
		if (s1 >= s2)
			System.out.println(""Yes"");
		else
			System.out.println(""No"");
	}
}
",CorCod,377,377,linear
"
// C# program to acquire all n coins at 
// minimum cost with multiple values of k. 
import
java .io.*; 
import
java.util.Arrays; 

public
class
GFG { 


// Converts coin[] to prefix sum array 

static
void
preprocess(
int
[]coin, 
int
n) 

{ 


// sort the coins value 

Arrays.sort(coin); 


// Maintain prefix sum array 

for
(
int
i = 
1
; i <= n - 
1
; i++) 

coin[i] += coin[i - 
1
]; 

} 


// Function to calculate min cost when we 

// can get k extra coins after paying 

// cost of one. 

static
int
minCost(
int
[]coin, 
int
n, 
int
k) 

{ 


// calculate no. of coins needed 

int
coins_needed =(
int
) Math.ceil(
1.0

* n / (k + 
1
)); 


// return sum of from prefix array 

return
coin[coins_needed - 
1
]; 

} 


// Driver Code 

static
public
void
main (String[] args) 

{ 

int
[]coin = {
8
, 
5
, 
3
, 
10
, 
2
, 
1
, 
15
, 
25
}; 

int
n = coin.length; 


preprocess(coin, n); 


int
k = 
3
; 

System.out.println(minCost(coin, n, k)); 


k = 
7
; 

System.out.println( minCost(coin, n, k)); 

} 
} 

// This code is contributed by anuj_67. ",CorCod,683,683,nlogn
"package com.interview.binarysearch;

/**
 * There are two sorted arrays nums1 and nums2 of size m and n respectively.
 * Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
 *
 * Solution
 * Take minimum size of two array. Possible number of partitions are from 0 to m in m size array.
 * Try every cut in binary search way. When you cut first array at i then you cut second array at (m + n + 1)/2 - i
 * Now try to find the i where a[i-1] <= b[j] and b[j-1] <= a[i]. So this i is partition around which lies the median.
 *
 * Time complexity is O(log(min(x,y))
 * Space complexity is O(1)
 *
 * https://leetcode.com/problems/median-of-two-sorted-arrays/
 * https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation/4
 */
public class MedianOfTwoSortedArrayOfDifferentLength {

    public double findMedianSortedArrays(int input1[], int input2[]) {
        //if input1 length is greater than switch them so that input1 is smaller than input2.
        if (input1.length > input2.length) {
            return findMedianSortedArrays(input2, input1);
        }
        int x = input1.length;
        int y = input2.length;

        int low = 0;
        int high = x;
        while (low <= high) {
            int partitionX = (low + high)/2;
            int partitionY = (x + y + 1)/2 - partitionX;

            //if partitionX is 0 it means nothing is there on left side. Use -INF for maxLeftX
            //if partitionX is length of input then there is nothing on right side. Use +INF for minRightX
            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : input1[partitionX - 1];
            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : input1[partitionX];

            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : input2[partitionY - 1];
            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : input2[partitionY];

            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {
                //We have partitioned array at correct place
                // Now get max of left elements and min of right elements to get the median in case of even length combined array size
                // or get max of left for odd length combined array size.
                if ((x + y) % 2 == 0) {
                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY))/2;
                } else {
                    return (double)Math.max(maxLeftX, maxLeftY);
                }
            } else if (maxLeftX > minRightY) { //we are too far on right side for partitionX. Go on left side.
                high = partitionX - 1;
            } else { //we are too far on left side for partitionX. Go on right side.
                low = partitionX + 1;
            }
        }

        //Only we we can come here is if input arrays were not sorted. Throw in that scenario.
        throw new IllegalArgumentException();
    }

    public static void main(String[] args) {
        int[] x = {1, 3, 8, 9, 15};
        int[] y = {7, 11, 19, 21, 18, 25};

        MedianOfTwoSortedArrayOfDifferentLength mm = new MedianOfTwoSortedArrayOfDifferentLength();
        mm.findMedianSortedArrays(x, y);
    }
}",CorCod,892,892,logn
"import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Practice {
	
	   

		public static void main(String []args)
		{
			Scanner sc=new Scanner(System.in);
			int n=sc.nextInt();
			sc.nextLine();
			String s=sc.nextLine();
			//System.out.println(s);
			char c[]=s.toCharArray();
			ArrayList a =new ArrayList();
			
			for(int i=0;i<c.length;i++)
			{
				//System.out.println(c[i]);
				a.add(c[i]);
			}
		
			int x=Collections.frequency(a,'0' );
			int y=Collections.frequency(a,'1');
			
			//System.out.println(x+ ""  ""+y );
			if(y==0 || y==1)
			{
				System.out.println(s);
			}
			else
			{
				if(y>=2)
				{
					String s1=""1"";
					for(int i=0;i<x;i++)
					{
						s1=s1+""0"";
					}
					System.out.println(s1);
					
				}
			}
			
			
			
			
			
			
	}

}",CorCod,61,61,linear
"
class
LeadersInArray 
{ 

/*Java Function to print leaders in an array */

void
printLeaders(
int
arr[], 
int
size) 

{ 

for
(
int
i = 
0
; i < size; i++) 

{ 

int
j; 

for
(j = i + 
1
; j < size; j++) 

{ 

if
(arr[i] <= arr[j]) 

break
; 

} 

if
(j == size) 
// the loop didn't break 

System.out.print(arr[i] + 
"" ""
); 

} 

} 


/* Driver program to test above functions */

public
static
void
main(String[] args) 

{ 

LeadersInArray lead = 
new
LeadersInArray(); 

int
arr[] = 
new
int
[]{
16
, 
17
, 
4
, 
3
, 
5
, 
2
}; 

int
n = arr.length; 

lead.printLeaders(arr, n); 

} 
} ",CorCod,554,554,quadratic
"

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;

public class e {

public static class FastReader {
	BufferedReader br;
	StringTokenizer st;
	//it reads the data about the specified point and divide the data about it ,it is quite fast
	//than using direct 

	public FastReader() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}

	String next() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception r) {
				r.printStackTrace();
			}
		}
		return st.nextToken();
	}

	int nextInt() {
		return Integer.parseInt(next());//converts string to integer
	}

	double nextDouble() {
		return Double.parseDouble(next());
	}

	long nextLong() {
		return Long.parseLong(next());
	}

	String nextLine() {
		String str = """";
		try {
			str = br.readLine();
		} catch (Exception r) {
			r.printStackTrace();
		}
		return str;
	}
}
static ArrayList<String>list1=new ArrayList<String>();
static void combine(String instr, StringBuffer outstr, int index,int k)
{
	if(outstr.length()==k)
	{
		list1.add(outstr.toString());return;
	}
	if(outstr.toString().length()==0)
	outstr.append(instr.charAt(index));
    for (int i = 0; i < instr.length(); i++)
    {
        outstr.append(instr.charAt(i));
       
        combine(instr, outstr, i + 1,k);
        outstr.deleteCharAt(outstr.length() - 1);
    }
   index++;
} 
static ArrayList<ArrayList<Integer>>l=new ArrayList<>();
static void comb(int n,int k,int ind,ArrayList<Integer>list)
{
	if(k==0)
	{
		l.add(new ArrayList<>(list));

		return;
	}
	
	
	for(int i=ind;i<=n;i++)
	{
		list.add(i);
		comb(n,k-1,ind+1,list);
		
		list.remove(list.size()-1);
		
	}
	
	
	
	
	

}


public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	FastReader in=new FastReader();
	HashMap<Integer,Integer>map=new HashMap<Integer,Integer>();

	int n=in.nextInt();
	int r=in.nextInt();
	 
	double theta=(double)360/(double)n;
	 
	double b=1-((double)2/(double)(1-Math.cos((double)2*Math.PI/(double)n)));
	double x=Math.sqrt(1-b)-1;
	double ans=(double)r/(double)x;
	System.out.println(ans);





	}
}
",CorCod,833,833,constant
"import java.io.*;
import java.util.*;

public class Main {

    private static void solve(InputReader in, OutputWriter out) {
        int n = in.nextInt();
        int m = in.nextInt();

        String[] sa = new String[n];
        for (int i = 0; i < n; i++) {
            sa[i] = in.next();
        }

        Set<Integer> switches = new HashSet<>();
        for (int i = 0; i < m; i++) {
            int cnt = 0, swtch = -1;
            for (int j = 0; j < n; j++) {
                if (sa[j].charAt(i) == '1') {
                    cnt++;
                    swtch = j;
                    if (cnt > 1)
                        break;
                }
            }

            if (cnt == 1) {
                switches.add(swtch);
            }
        }

        out.print(switches.size() == n ? ""NO"" : ""YES"");
    }

    private static void shuffleArray(int[] array) {
        int index;
        Random random = new Random();
        for (int i = array.length - 1; i > 0; i--) {
            index = random.nextInt(i + 1);
            if (index != i) {
                array[index] ^= array[i];
                array[i] ^= array[index];
                array[index] ^= array[i];
            }
        }
    }

    public static void main(String[] args) {
        InputReader in = new InputReader(System.in);
        OutputWriter out = new OutputWriter(System.out);
        solve(in, out);
        in.close();
        out.close();
    }

    private static class InputReader {
        private BufferedReader br;
        private StringTokenizer st;

        InputReader(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
            st = null;
        }

        String nextLine() {
            String line = null;
            try {
                line = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return line;
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                String line = nextLine();
                if (line == null) return null;
                st = new StringTokenizer(line);
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        void close() {
            try {
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private static class OutputWriter {
        BufferedWriter bw;

        OutputWriter(OutputStream os) {
            bw = new BufferedWriter(new OutputStreamWriter(os));
        }

        void print(int i) {
            print(Integer.toString(i));
        }

        void println(int i) {
            println(Integer.toString(i));
        }

        void print(long l) {
            print(Long.toString(l));
        }

        void println(long l) {
            println(Long.toString(l));
        }

        void print(double d) {
            print(Double.toString(d));
        }

        void println(double d) {
            println(Double.toString(d));
        }

        void print(boolean b) {
            print(Boolean.toString(b));
        }

        void println(boolean b) {
            println(Boolean.toString(b));
        }

        void print(char c) {
            try {
                bw.write(c);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        void println(char c) {
            println(Character.toString(c));
        }

        void print(String s) {
            try {
                bw.write(s);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        void println(String s) {
            print(s);
            print('\n');
        }

        void close() {
            try {
                bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
",CorCod,570,570,quadratic
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author pandusonu
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            // out.print(""Case #"" + testNumber + "": "");
            int n = in.readInt();
            int[] a = in.readIntArray(n);
            int[][] sol = new int[n][n];
            for (int i = 0; i < n; i++) {
                sol[0][i] = a[i];
            }
            for (int i = 1; i < n; i++) {
                for (int j = 0; j < n - i; j++) {
                    sol[i][j] = sol[i - 1][j] ^ sol[i - 1][j + 1];
                }
            }
            for (int i = 1; i < n; i++) {
                for (int j = 0; j < n - i; j++) {
                    sol[i][j] = Math.max(sol[i][j], Math.max(sol[i - 1][j], sol[i - 1][j + 1]));
                }
            }
            int q = in.readInt();
            for (int i = 0; i < q; i++) {
                int l = in.readInt() - 1;
                int r = in.readInt() - 1;
                out.println(sol[r - l][l]);
            }
        }

    }

    static class InputReader {
        private final InputStream stream;
        private final byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        private int read() {
            try {
                if (curChar >= numChars) {
                    curChar = 0;
                    numChars = stream.read(buf);
                    if (numChars <= 0)
                        return -1;
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            return buf[curChar++];
        }

        public int readInt() {
            return (int) readLong();
        }

        public long readLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
                if (c == -1) throw new RuntimeException();
            }
            boolean negative = false;
            if (c == '-') {
                negative = true;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') throw new InputMismatchException();
                res *= 10;
                res += (c - '0');
                c = read();
            } while (!isSpaceChar(c));
            return negative ? (-res) : (res);
        }

        public int[] readIntArray(int size) {
            int[] arr = new int[size];
            for (int i = 0; i < size; i++) arr[i] = readInt();
            return arr;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",CorCod,390,390,quadratic
"import java.io.*;
import java.util.*;

public class CF1009E {
	static final int MD = 998244353;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		int[] aa = new int[1 + n];
		for (int i = 1, a = 0; i <= n; i++)
			aa[i] = a = (a + Integer.parseInt(st.nextToken())) % MD;
		int[] pp = new int[n];
		pp[0] = 1;
		for (int i = 1, p = 1; i < n; i++) {
			pp[i] = p;
			p = p * 2 % MD;
		}
		int d = 0;
		long ans = 0;
		for (int i = n - 1; i >= 0; i--) {	// rest at i
			d = (d * 2 % MD + aa[n - 1 - i]) % MD;	// rest again before n
			ans = (ans + (long) (d + aa[n - i]) * pp[i]) % MD;
		}
		System.out.println(ans);
	}
}
",CorCod,55,55,linear
"import java.io.*;
import java.util.*;
import static java.lang.System.*;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(in));
		
		StringTokenizer st = new StringTokenizer(br.readLine().trim());
		
		int n = Integer.valueOf(st.nextToken());
		int k = Integer.valueOf(st.nextToken());
		
		String str = br.readLine().trim();
		int [] arr = new int[n];
		
		LL[] adjlist = new LL[n];
		
		for(int i =0 ; i < n; i++){
			int x = str.charAt(i) - 'a' + 1;
			arr[i] = x;
			adjlist[i] = new LL();
		}
		
		
		Arrays.sort(arr);
		
		for(int i =0; i < n; i++){
			for(int j = i + 1; j < n; j++){
				int a = arr[i];
				int b = arr[j];
				
				if((b - a) >= 2){
					adjlist[i].add(new Pair(j, arr[j], 1));
				}
			}
		}
		
		LinkedList<Pair> list = new LinkedList<Pair>();
		LinkedList<Pair> tmpList = new LinkedList<Pair>();
		
		int ans = Integer.MAX_VALUE;
		
		for(int i = 0; i < n; i++){
			
			list.clear();
			list.add(new Pair(i,arr[i],0));
			// out.println(""---- ""+arr[i]);
			
			
			for(int j = 0; j < k; j++){
				tmpList.clear();
				while(!list.isEmpty()){
					
					
					Pair cur = list.removeFirst();
					if(j == k-1){
						ans = Math.min(cur.val, ans);
					}
					for(Pair adj : adjlist[cur.idx]){
						
						
						tmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));
					}
				}
				
				
				
				// out.println(list.toString());
				if(tmpList.size() == 0){
					break;
				}
				else{
					list.addAll(tmpList);
				}
				
				// out.println(list.toString());
			}
			
			
		}
		
		if(ans == Integer.MAX_VALUE) out.println(-1);
		else out.println(ans);
		
		
	}
	public static class LL extends LinkedList<Pair>{}
	public static class Pair implements Comparable<Pair>{
		int val;
		int idx;
		int ctr;
		public Pair(int a, int b, int c){
			idx = a;
			val = b;
			ctr = c;
		}
		public int compareTo(Pair p){
			
			if(ctr == p.ctr){
				if(val == p.val) return idx - p.idx;
					
				return val - p.val;
			}
			return p.ctr - ctr;
		}
		public String toString(){
			return val+"", "";
		}
	}
}",CorCod,433,433,quadratic
"
// Java program to check if Binary tree is sum tree or not 


/* A binary tree node has data, left child and right child */
class
Node 
{ 

int
data; 

Node left, right, nextRight; 


Node(
int
item) 

{ 

data = item; 

left = right = nextRight = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root; 


/* Utility function to check if the given node is leaf or not */

int
isLeaf(Node node) 

{ 

if
(node == 
null
) 

return
0
; 

if
(node.left == 
null
&& node.right == 
null
) 

return
1
; 

return
0
; 

} 


/* returns 1 if SumTree property holds for the given 

tree */

int
isSumTree(Node node) 

{ 

int
ls; 
// for sum of nodes in left subtree 

int
rs; 
// for sum of nodes in right subtree 


/* If node is NULL or it's a leaf node then 

return true */

if
(node == 
null
|| isLeaf(node) == 
1
) 

return
1
; 


if
(isSumTree(node.left) != 
0
&& isSumTree(node.right) != 
0
) 

{ 

// Get the sum of nodes in left subtree 

if
(node.left == 
null
) 

ls = 
0
; 

else
if
(isLeaf(node.left) != 
0
) 

ls = node.left.data; 

else

ls = 
2
* (node.left.data); 


// Get the sum of nodes in right subtree 

if
(node.right == 
null
) 

rs = 
0
; 

else
if
(isLeaf(node.right) != 
0
) 

rs = node.right.data; 

else

rs = 
2
* (node.right.data); 


/* If root's data is equal to sum of nodes in left 

and right subtrees then return 1 else return 0*/

if
((node.data == rs + ls)) 

return
1
; 

else

return
0
; 

} 


return
0
; 

} 


/* Driver program to test above functions */

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
26
); 

tree.root.left = 
new
Node(
10
); 

tree.root.right = 
new
Node(
3
); 

tree.root.left.left = 
new
Node(
4
); 

tree.root.left.right = 
new
Node(
6
); 

tree.root.right.right = 
new
Node(
3
); 


if
(tree.isSumTree(tree.root) != 
0
) 

System.out.println(
""The given tree is a sum tree""
); 

else

System.out.println(
""The given tree is not a sum tree""
); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,300,300,linear
"import java.util.Scanner;

public class codef8 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int num = sc.nextInt();
		int beacon[] = new int[1000001];
		for (int i = 0; i < num; i++) {
			beacon[sc.nextInt()] = sc.nextInt();
		}
		int dp[] = new int[1000001];
		int max = 1;
		if (beacon[0] > 0) {
			dp[0] = 1;
		}
		
		for (int i = 1; i <= 1000000; i++) {
			if (beacon[i] == 0) {
				dp[i] = dp[i-1];
			} 
			else {
				int b = beacon[i];
				if (i <= b) {
					dp[i] = 1;
				}
				else {
					dp[i] = dp[i-b-1] + 1;
				}
			}
			max = Math.max(max, dp[i]);
		}		
		System.out.println(num-max);
		sc.close();
	}

}
",CorCod,200,200,linear
"
// Java program to rearrange the array 
// as per the given condition 
import
java.util.*; 
import
java.lang.*; 

public
class
GfG{ 

// function to rearrange the array 

public
static
void
rearrangeArr(
int
arr[], 

int
n) 

{ 

// total even positions 

int
evenPos = n / 
2
; 


// total odd positions 

int
oddPos = n - evenPos; 


int
[] tempArr = 
new
int
[n]; 


// copy original array in an 

// auxiliary array 

for
(
int
i = 
0
; i < n; i++) 

tempArr[i] = arr[i]; 


// sort the auxiliary array 

Arrays.sort(tempArr); 


int
j = oddPos - 
1
; 


// fill up odd position in 

// original array 

for
(
int
i = 
0
; i < n; i += 
2
) { 

arr[i] = tempArr[j]; 

j--; 

} 


j = oddPos; 


// fill up even positions in 

// original array 

for
(
int
i = 
1
; i < n; i += 
2
) { 

arr[i] = tempArr[j]; 

j++; 

} 


// display array 

for
(
int
i = 
0
; i < n; i++) 

System.out.print(arr[i] + 
"" ""
); 

} 


// Driver function 

public
static
void
main(String argc[]){ 

int
[] arr = 
new
int
[]{ 
1
, 
2
, 
3
, 
4
, 
5
, 

6
, 
7
}; 

int
size = 
7
; 

rearrangeArr(arr, size); 


} 
} 

/* This code is contributed by Sagar Shukla */",CorCod,694,694,nlogn
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class CoveredPointsCount {
	
	//UPSOLVE
	
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
	        
		int n = Integer.parseInt(st.nextToken());
	     
		long[] myArray = new long[2 * n];
	        
			for (int i = 0; i < n; i++)  {
	        	StringTokenizer st1 = new StringTokenizer(br.readLine());
	        	myArray[2 * i] = Long.parseLong(st1.nextToken()) * 2;
	        	myArray[2 * i + 1] = Long.parseLong(st1.nextToken()) * 2 + 1;
	        }  
	        
	        Arrays.sort(myArray);
	        long[] ans = new long[n + 1];
	        int cnt = 0;
	       
	        for (int i = 0; i < 2 * n - 1; i++)   {
	            if (myArray[i] % 2 == 0) cnt++; else cnt--;
	            ans[cnt] += (myArray[i + 1] + 1) / 2 - (myArray[i] + 1) / 2;
	        }   
	        
	        StringBuilder answer = new StringBuilder();
	        
	        for (int i = 1; i < n + 1; i++) {
	        	answer.append(ans[i]);
	        	answer.append("" "");
	        }  
	        
	        System.out.println(answer);

	}

}
",CorCod,671,671,nlogn
"
// Java program to do level order 
// traversal line by line 
import
java.util.LinkedList; 
import
java.util.Queue; 

public
class
GFG { 

static
class
Node { 

int
data; 

Node left; 

Node right; 


Node(
int
data) { 

this
.data = data; 

left = 
null
; 

right = 
null
; 

} 

} 


// Prints level order traversal line 

// by line using two queues. 

static
void
levelOrder(Node root) { 

if
(root == 
null
) 

return
; 


Queue<Node> q = 
new
LinkedList<>(); 


// Pushing root node into the queue. 

q.add(root); 


// Pushing delimiter into the queue. 

q.add(
null
); 


// Executing loop till queue becomes 

// empty 

while
(!q.isEmpty()) { 


Node curr = q.poll(); 


// condition to check the 

// occurence of next level 

if
(curr == 
null
) { 

if
(!q.isEmpty()) { 

q.add(
null
); 

System.out.println(); 

} 

} 
else
{ 

// Pushing left child current node 

if
(curr.left != 
null
) 

q.add(curr.left); 


// Pushing right child current node 

if
(curr.right != 
null
) 

q.add(curr.right); 


System.out.print(curr.data + 
"" ""
); 

} 

} 

} 


// Driver function 

public
static
void
main(String[] args) { 


Node root = 
new
Node(
1
); 

root.left = 
new
Node(
2
); 

root.right = 
new
Node(
3
); 

root.left.left = 
new
Node(
4
); 

root.left.right = 
new
Node(
5
); 

root.right.right = 
new
Node(
6
); 


levelOrder(root); 

} 
} 

// This code is Contributed by Rishabh Jindal ",CorCod,257,257,linear
"
// Java implementation to check whether the two 
// binary tress are mirrors of each other or not 
import
java.util.*; 
class
GfG { 

// structure of a node in binary tree 
static
class
Node 
{ 

int
data; 

Node left, right; 
} 

// Utility function to create and return 
// a new node for a binary tree 
static
Node newNode(
int
data) 
{ 

Node temp = 
new
Node(); 

temp.data = data; 

temp.left = 
null
; 

temp.right = 
null
; 

return
temp; 
} 

// function to check whether the two binary trees 
// are mirrors of each other or not 
static
String areMirrors(Node root1, Node root2) 
{ 

Stack<Node> st1 = 
new
Stack<Node> (); 

Stack<Node> st2 = 
new
Stack<Node> (); 

while
(
true
) 

{ 

// iterative inorder traversal of 1st tree and 

// reverse inoder traversal of 2nd tree 

while
(root1 != 
null
&& root2 != 
null
) 

{ 

// if the corresponding nodes in the two traversal 

// have different data values, then they are not 

// mirrors of each other. 

if
(root1.data != root2.data) 

return
""No""
; 


st1.push(root1); 

st2.push(root2); 

root1 = root1.left; 

root2 = root2.right; 

} 


// if at any point one root becomes null and 

// the other root is not null, then they are 

// not mirrors. This condition verifies that 

// structures of tree are mirrors of each other. 

if
(!(root1 == 
null
&& root2 == 
null
)) 

return
""No""
; 


if
(!st1.isEmpty() && !st2.isEmpty()) 

{ 

root1 = st1.peek(); 

root2 = st2.peek(); 

st1.pop(); 

st2.pop(); 


/* we have visited the node and its left subtree. 

Now, it's right subtree's turn */

root1 = root1.right; 


/* we have visited the node and its right subtree. 

Now, it's left subtree's turn */

root2 = root2.left; 

} 


// both the trees have been completely traversed 

else

break
; 

} 


// tress are mirrors of each other 

return
""Yes""
; 
} 

// Driver program to test above 
public
static
void
main(String[] args) 
{ 

// 1st binary tree formation 

Node root1 = newNode(
1
); 
/* 1 */

root1.left = newNode(
3
); 
/* / \ */

root1.right = newNode(
2
); 
/* 3 2 */

root1.right.left = newNode(
5
); 
/* / \ */

root1.right.right = newNode(
4
); 
/* 5 4 */


// 2nd binary tree formation 

Node root2 = newNode(
1
); 
/* 1 */

root2.left = newNode(
2
); 
/* / \ */

root2.right = newNode(
3
); 
/* 2 3 */

root2.left.left = newNode(
4
); 
/* / \ */

root2.left.right = newNode(
5
); 
/* 4 5 */


System.out.println(areMirrors(root1, root2)); 
} 
} ",CorCod,275,275,linear
"
// Java implementation to count number 
// of ways to tile a floor of size 
// n x m using 1 x m tiles 
import
java.io.*; 

class
GFG { 

// function to count the total number of ways 

static
int
countWays(
int
n, 
int
m) 

{ 

// table to store values 

// of subproblems 

int
count[] = 
new
int
[n + 
1
]; 

count[
0
] = 
0
; 


// Fill the table upto value n 

int
i; 

for
(i = 
1
; i <= n; i++) { 

// recurrence relation 

if
(i > m) 

count[i] = count[i - 
1
] + count[i - m]; 


// base cases 

else
if
(i < m) 

count[i] = 
1
; 


// i = = m 

else

count[i] = 
2
; 

} 


// required number of ways 

return
count[n]; 

} 


// Driver program 

public
static
void
main(String[] args) 

{ 

int
n = 
7
; 

int
m = 
4
; 

System.out.println(
""Number of ways = ""

+ countWays(n, m)); 

} 
} 

// This code is contributed by vt_m. ",CorCod,311,311,linear
"import java.io.*;
import java.util.*;

public class C_NNAndTheOpticalIllusion {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader inp = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        Solver solver = new Solver();
        solver.solve(inp, out);
        out.close();
    }

    private static class Solver {
        private void solve(InputReader inp, PrintWriter out) {
            double n = inp.nextInt(), r = inp.nextInt();
            double x = Math.cos((n - 2) * Math.PI / (2 * n));
            out.print((r * x) / (1 - x));
        }
    }

    static class InputReader {
        BufferedReader reader;
        StringTokenizer tokenizer;

        InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
    }
}",CorCod,824,824,constant
"import java.io.*;
import java.util.*;
import java.lang.String;
public class Solution
{
    public static void main(String[] args)
    {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try
        {
            String str = br.readLine();
            int q = Integer.parseInt(str);
            //int q = 7;
            //int q = 1345679;
        if(q%2 == 0 && q!=2)
                System.out.println(""YES"");
            else
                System.out.println(""NO"");
            
        }
        catch(IOException e)
        {
            System.out.println(""Input Error"");
        }
        
        
 
       /* String str = ""hello"";
        String str1 = Character.toUpperCase(str.charAt(0))+str.substring(1);
        System.out.println(str1);
        */
 
    }
}",CorCod,760,760,constant
"
// Java code to find largest 
// three elements in an array 


import
java.io.*; 
import
java.util.Arrays; 

class
GFG { 

void
find3largest(
int
[] arr) 

{ 

Arrays.sort(arr); 
//It uses Tuned Quicksort with 

//avg. case Time complexity = O(nLogn) 

int
n = arr.length; 

int
check = 
0
, count = 
1
; 


for
(
int
i = 
1
; i <= n; i++){ 


if
(count<
4
){ 

if
(check!=arr[n-i]) 

{ 

// to handle duplicate values 

System.out.print(arr[n-i]+
"" ""
); 

check = arr[n-i]; 

count++; 

} 

} 

else

break
; 

} 


} 


// Driver code 

public
static
void
main(String[] args) 

{ 

GFG obj = 
new
GFG(); 

int
[] arr={
12
,
45
,
1
,-
1
,
45
,
54
,
23
,
5
,
0
,-
10
}; 

obj.find3largest(arr); 

} 

} 
//This code is contibuted by Prashant Malik ",CorCod,653,653,nlogn
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class CF1197B {
    public static void main(String[] args) {
        FastReader input = new FastReader();
        int n = input.nextInt();
        int[] arr = new int[n];
        int max = 0;
        int maxIndex = 0;
        for(int i = 0;i < n;i++){
            arr[i] = input.nextInt();
            if(arr[i] > max){
                max = arr[i];
                maxIndex = i;
            }
        }
        int j = maxIndex - 1;
        int k = maxIndex + 1;
        while (j >= 0 && k < n){
            if(arr[j] > arr[k]){
                if(arr[j] < max){
                    max = arr[j];
                    j--;
                }
                else {
                    System.out.println(""NO"");
                    return;
                }
            }
            else{
                if(arr[k] < max){
                    max = arr[k];
                    k++;
                }
                else{
                    System.out.println(""NO"");
                    return;
                }
            }
        }
        if(j >= 0){
            while (j >= 0){
                if(arr[j] < max){
                    max = arr[j];
                    j--;
                }
                else{
                    System.out.println(""NO"");
                    return;
                }
            }
        }
        if(k < n){
            while (k < n){
                if(arr[k] < max){
                    max = arr[k];
                    k++;
                }
                else{
                    System.out.println(""NO"");
                    return;
                }
            }
        }
        if(j == -1 && k == n){
            System.out.println(""YES"");
        }
    }
    static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;

        public FastReader()
        {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt()
        {
            return Integer.parseInt(next());
        }

        long nextLong()
        {
            return Long.parseLong(next());
        }

        double nextDouble()
        {
            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
}",CorCod,355,355,linear
"import java.io.BufferedReader;
import java.io.PrintWriter;

import java.io.InputStreamReader;

import java.io.IOException;

import java.util.StringTokenizer;

import java.util.Arrays;

public class Main {
    
    static Scanner in = new Scanner();
    static PrintWriter out = new PrintWriter(System.out);
    
    public static void main(String[] args) throws IOException {
        long n = in.nextLong(), m = in.nextLong();
        out.print(m / n + (m % n == 0 ? 0 : 1));
        out.close();
    }
    
    static class Scanner {
        BufferedReader br;
        StringTokenizer st;
        
        public Scanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
            st = new StringTokenizer("""");
        }
        
        public String next() throws IOException {
            if(!st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }
        
        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }
        
        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }
    }
}",CorCod,847,847,constant
"import java.util.Arrays;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		int[] a = new int[n];
		for (int i = 0; i < a.length; i++) {
			a[i] = sc.nextInt();
		}
		System.out.println(solve(a));

		sc.close();
	}

	static String solve(int[] a) {
		if (a.length == 1 || (a.length == 2 && a[0] == a[1])) {
			return ""-1"";
		}

		int sum = Arrays.stream(a).sum();
		for (int i = 0;; i++) {
			if (a[i] * 2 != sum) {
				return String.format(""1\n%d"", i + 1);
			}
		}
	}
}
",CorCod,249,249,linear
"
class
LinkedList { 


/* head node of link list */

static
LNode head; 


/* Link list Node */

class
LNode 

{ 

int
data; 

LNode next, prev; 


LNode(
int
d) 

{ 

data = d; 

next = prev = 
null
; 

} 

} 


/* A Binary Tree Node */

class
TNode 

{ 

int
data; 

TNode left, right; 


TNode(
int
d) 

{ 

data = d; 

left = right = 
null
; 

} 

} 


/* This function counts the number of nodes in Linked List 

and then calls sortedListToBSTRecur() to construct BST */

TNode sortedListToBST() 

{ 

/*Count the number of nodes in Linked List */

int
n = countNodes(head); 


/* Construct BST */

return
sortedListToBSTRecur(n); 

} 


/* The main function that constructs balanced BST and 

returns root of it. 

n --> No. of nodes in the Doubly Linked List */

TNode sortedListToBSTRecur(
int
n) 

{ 

/* Base Case */

if
(n <= 
0
) 

return
null
; 


/* Recursively construct the left subtree */

TNode left = sortedListToBSTRecur(n / 
2
); 


/* head_ref now refers to middle node, 

make middle node as root of BST*/

TNode root = 
new
TNode(head.data); 


// Set pointer to left subtree 

root.left = left; 


/* Change head pointer of Linked List for parent 

recursive calls */

head = head.next; 


/* Recursively construct the right subtree and link it 

with root. The number of nodes in right subtree is 

total nodes - nodes in left subtree - 1 (for root) */

root.right = sortedListToBSTRecur(n - n / 
2
- 
1
); 


return
root; 

} 


/* UTILITY FUNCTIONS */

/* A utility function that returns count of nodes in a 

given Linked List */

int
countNodes(LNode head) 

{ 

int
count = 
0
; 

LNode temp = head; 

while
(temp != 
null
) 

{ 

temp = temp.next; 

count++; 

} 

return
count; 

} 


/* Function to insert a node at the beginging of 

the Doubly Linked List */

void
push(
int
new_data) 

{ 

/* allocate node */

LNode new_node = 
new
LNode(new_data); 


/* since we are adding at the begining, 

prev is always NULL */

new_node.prev = 
null
; 


/* link the old list off the new node */

new_node.next = head; 


/* change prev of head node to new node */

if
(head != 
null
) 

head.prev = new_node; 


/* move the head to point to the new node */

head = new_node; 

} 


/* Function to print nodes in a given linked list */

void
printList(LNode node) 

{ 

while
(node != 
null
) 

{ 

System.out.print(node.data + 
"" ""
); 

node = node.next; 

} 

} 


/* A utility function to print preorder traversal of BST */

void
preOrder(TNode node) 

{ 

if
(node == 
null
) 

return
; 

System.out.print(node.data + 
"" ""
); 

preOrder(node.left); 

preOrder(node.right); 

} 


/* Driver program to test above functions */

public
static
void
main(String[] args) { 

LinkedList llist = 
new
LinkedList(); 


/* Let us create a sorted linked list to test the functions 

Created linked list will be 7->6->5->4->3->2->1 */

llist.push(
7
); 

llist.push(
6
); 

llist.push(
5
); 

llist.push(
4
); 

llist.push(
3
); 

llist.push(
2
); 

llist.push(
1
); 


System.out.println(
""Given Linked List ""
); 

llist.printList(head); 


/* Convert List to BST */

TNode root = llist.sortedListToBST(); 

System.out.println(
""""
); 

System.out.println(
""Pre-Order Traversal of constructed BST ""
); 

llist.preOrder(root); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,77,77,linear
"
// Java program to see if two trees 
// are mirror of each other 

// A binary tree node 
class
Node 
{ 

int
data; 

Node left, right; 


public
Node(
int
data) 

{ 

this
.data = data; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node a, b; 


/* Given two trees, return true if they are 

mirror of each other */

boolean
areMirror(Node a, Node b) 

{ 

/* Base case : Both empty */

if
(a == 
null
&& b == 
null
) 

return
true
; 


// If only one is empty 

if
(a == 
null
|| b == 
null
) 

return
false
; 


/* Both non-empty, compare them recursively 

Note that in recursive calls, we pass left 

of one tree and right of other tree */

return
a.data == b.data 

&& areMirror(a.left, b.right) 

&& areMirror(a.right, b.left); 

} 


// Driver code to test above methods 

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

Node a = 
new
Node(
1
); 

Node b = 
new
Node(
1
); 

a.left = 
new
Node(
2
); 

a.right = 
new
Node(
3
); 

a.left.left = 
new
Node(
4
); 

a.left.right = 
new
Node(
5
); 


b.left = 
new
Node(
3
); 

b.right = 
new
Node(
2
); 

b.right.left = 
new
Node(
5
); 

b.right.right = 
new
Node(
4
); 


if
(tree.areMirror(a, b) == 
true
) 

System.out.println(
""Yes""
); 

else

System.out.println(
""No""
); 


} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,133,133,linear
"// discussed with rainboy
import java.io.*;
import java.util.*;

public class CF915E {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter pw = new PrintWriter(System.out);
		int n = Integer.parseInt(br.readLine());
		int q = Integer.parseInt(br.readLine());
		TreeMap<Integer, Integer> mp = new TreeMap<>();
		int ans = 0;
		while (q-- > 0) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int l = Integer.parseInt(st.nextToken()) - 1;
			int r = Integer.parseInt(st.nextToken());
			int t = Integer.parseInt(st.nextToken());
			Map.Entry<Integer, Integer> e;
			int l_, r_;
			if (t == 1) {
				if ((e = mp.floorEntry(l)) != null && (r_ = e.getValue()) >= l) {
					l_ = e.getKey();
					ans -= r_ - l_;
					l = l_;
					r = Math.max(r, r_);
				}
				while ((e = mp.higherEntry(l)) != null && (l_ = e.getKey()) <= r) {
					r_ = e.getValue();
					ans -= r_ - l_;
					r = Math.max(r, r_);
					mp.remove(l_);
				}
				ans += r - l;
				mp.put(l, r);
			} else {
				r_ = l;
				if ((e = mp.floorEntry(l)) != null && (r_ = e.getValue()) > l) {
					l_ = e.getKey();
					if (l_ < l)
						mp.put(l_, l);
					else
						mp.remove(l_);
					ans -= r_ - l;
				}
				while ((e = mp.higherEntry(l)) != null && (l_ = e.getKey()) < r) {
					r_ = e.getValue();
					mp.remove(l_);
					ans -= r_ - l_;
				}
				if (r_ > r) {
					mp.put(r, r_);
					ans += r_ - r;
				}
			}
			pw.println(n - ans);
		}
		pw.close();
	}
}
",CorCod,630,630,nlogn
"import java.util.*;

public class ErrorCorrectSystem
{

	public static void main(String[] args)
	{
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		String a = scan.next();
		String b = scan.next();
		
		int[][] mismatch = new int[26][26];
		for(int i = 0; i < 26; i++) Arrays.fill(mismatch[i], -1);
		int[][] pair = new int[2][26];
		for(int i = 0; i < 2; i++) Arrays.fill(pair[i], -1);
		int hd = 0;
		for(int i = 0; i < n; i++) {
			if(a.charAt(i) != b.charAt(i)) {
				hd++;
				mismatch[a.charAt(i)-'a'][b.charAt(i)-'a'] = i;
				pair[0][a.charAt(i)-'a'] = i;
				pair[1][b.charAt(i)-'a'] = i;
			}
		}
		for(int i = 0; i < 26; i++) {
			for(int j = i+1; j < 26; j++) {
				if(mismatch[i][j] > -1 && mismatch[j][i] > -1) {
					System.out.println(hd-2);
					System.out.println((mismatch[i][j]+1)+"" ""+(mismatch[j][i]+1));
					return;
				}
			}
		}
		for(int i = 0; i < n; i++) {
			if(a.charAt(i) != b.charAt(i)) {
				//try a gets b's letter
				if(pair[0][b.charAt(i)-'a'] > -1) {
					System.out.println(hd-1);
					System.out.println((i+1)+"" ""+(pair[0][b.charAt(i)-'a']+1));
					return;
				}
			}
		}
		
		System.out.println(hd);
		System.out.println(""-1 -1"");
	}

}
",CorCod,89,89,linear
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.TreeMap;


public class Main {

	static class Task {
		
		int NN = 500005;
		int MOD = 1000000007;
		int INF = 2000000000;
		long INFINITY = 2000000000000000000L;
		
		public void solve(InputReader in, PrintWriter out) {
			int t = in.nextInt();
			while(t-->0) {
				long n =in.nextLong();
				long m = in.nextLong();
				long x1 = in.nextLong();
				long y1 = in.nextLong();
				long x2 = in.nextLong();
				long y2 = in.nextLong();
				long x3 = in.nextLong();
				long y3 = in.nextLong();
				long x4 = in.nextLong();
				long y4 = in.nextLong();
				long w = white(1, 1, m, n);
				long b = black(1, 1, m, n);
				long whited = 0;
				if(x3 > x2 || x4 < x1 || y3 > y2 || y4 < y1) {
					whited = black(x1, y1, x2, y2);
				} else {
					whited = black(x1, y1, x2, y2);
					long xm1 = Math.max(x1, x3);
					long ym1 = Math.max(y1, y3);
					long xm2 = Math.min(x2, x4);
					long ym2 = Math.min(y2, y4);
					whited -= black(xm1, ym1, xm2, ym2);
				}
				b -= whited;w += whited;
				long blacked = white(x3, y3, x4, y4);
				w-= blacked;b += blacked;
				out.println(w + "" "" + b);
			}
		}
		
		long black(long x1, long y1, long x2, long y2) {
			long dx = (x2 - x1) + 1;
			long dy = (y2 - y1) + 1;
			if((x1+y1)%2!=0) {
				return ((dy+1)/2)*((dx+1)/2)+(dy/2)*(dx/2);
			}
			return ((dy+1)/2)*((dx)/2)+(dy/2)*((dx+1)/2);
		}
		
		long white(long x1, long y1, long x2, long y2) {
			long dx = (x2 - x1) + 1;
			long dy = (y2 - y1) + 1;
			if((x1+y1)%2==0) {
				return ((dy+1)/2)*((dx+1)/2)+(dy/2)*(dx/2);
			}
			return ((dy+1)/2)*(dx/2)+(dy/2)*((dx+1)/2);
		}
		
	}
	
	static void prepareIO(boolean isFileIO) {
		//long t1 = System.currentTimeMillis();
		Task solver = new Task();
		// Standard IO
		if(!isFileIO) { 
			InputStream inputStream = System.in;
	        OutputStream outputStream = System.out;
	        InputReader in = new InputReader(inputStream);
	        PrintWriter out = new PrintWriter(outputStream);
	        solver.solve(in, out);
	        //out.println(""time(s): "" + (1.0*(System.currentTimeMillis()-t1))/1000.0);
	        out.close();
		}
        // File IO
		else {
			String IPfilePath = System.getProperty(""user.home"") + ""/Downloads/ip.in"";
	        String OPfilePath = System.getProperty(""user.home"") + ""/Downloads/op.out"";
	        InputReader fin = new InputReader(IPfilePath);
	        PrintWriter fout = null;
	        try {
				fout = new PrintWriter(new File(OPfilePath));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
	        solver.solve(fin, fout);
	        //fout.println(""time(s): "" + (1.0*(System.currentTimeMillis()-t1))/1000.0);
	        fout.close();
		}
	}
	
	public static void main(String[] args) {
        prepareIO(false);
	}
	
	static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        
        public InputReader(String filePath) {
        	File file = new File(filePath);
            try {
				reader = new BufferedReader(new FileReader(file));
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
            tokenizer = null;
        }
        
        public String nextLine() {
        	String str = """";
        	try {
				str = reader.readLine();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
        	return str;
        }
        
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
        	return Double.parseDouble(next());
        }
        
    }

}",CorCod,790,790,constant
"
// Java implementation to find the 
// minimum and maximum amount 
import
java.util.*; 

class
GFG { 


// Function to find the minimum 

// amount to buy all candies 

static
int
findMinimum(
int
arr[], 
int
n, 
int
k) 

{ 

int
res = 
0
; 

for
(
int
i = 
0
; i < n; i++) 

{ 

// Buy current candy 

res += arr[i]; 


// And take k candies for free 

// from the last 

n = n - k; 

} 

return
res; 

} 


// Function to find the maximum 

// amount to buy all candies 

static
int
findMaximum(
int
arr[], 
int
n, 
int
k) 

{ 

int
res = 
0
, index = 
0
; 


for
(
int
i = n - 
1
; i >= index; i--) 

{ 

// Buy candy with maximum amount 

res += arr[i]; 


// And get k candies for free from 

// the starting 

index += k; 

} 

return
res; 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
3
, 
2
, 
1
, 
4
}; 

int
n = arr.length; 

int
k = 
2
; 

Arrays.sort(arr); 


System.out.println(findMinimum(arr, n, k) + 

"" ""
+ findMaximum(arr, n, k)); 

} 
} 

// This code is contributed by prerna saini ",CorCod,676,676,nlogn
"
// JAVA Code for Maximum size square 
// sub-matrix with all 1s 
public
class
GFG 
{ 

// method for Maximum size square sub-matrix with all 1s 

static
void
printMaxSubSquare(
int
M[][]) 

{ 

int
i,j; 

int
R = M.length; 
//no of rows in M[][] 

int
C = M[
0
].length; 
//no of columns in M[][] 

int
S[][] = 
new
int
[R][C]; 


int
max_of_s, max_i, max_j; 


/* Set first column of S[][]*/

for
(i = 
0
; i < R; i++) 

S[i][
0
] = M[i][
0
]; 


/* Set first row of S[][]*/

for
(j = 
0
; j < C; j++) 

S[
0
][j] = M[
0
][j]; 


/* Construct other entries of S[][]*/

for
(i = 
1
; i < R; i++) 

{ 

for
(j = 
1
; j < C; j++) 

{ 

if
(M[i][j] == 
1
) 

S[i][j] = Math.min(S[i][j-
1
], 

Math.min(S[i-
1
][j], S[i-
1
][j-
1
])) + 
1
; 

else

S[i][j] = 
0
; 

} 

} 


/* Find the maximum entry, and indexes of maximum entry 

in S[][] */

max_of_s = S[
0
][
0
]; max_i = 
0
; max_j = 
0
; 

for
(i = 
0
; i < R; i++) 

{ 

for
(j = 
0
; j < C; j++) 

{ 

if
(max_of_s < S[i][j]) 

{ 

max_of_s = S[i][j]; 

max_i = i; 

max_j = j; 

} 

} 

} 


System.out.println(
""Maximum size sub-matrix is: ""
); 

for
(i = max_i; i > max_i - max_of_s; i--) 

{ 

for
(j = max_j; j > max_j - max_of_s; j--) 

{ 

System.out.print(M[i][j] + 
"" ""
); 

} 

System.out.println(); 

} 

} 


// Driver program 

public
static
void
main(String[] args) 

{ 

int
M[][] = {{
0
, 
1
, 
1
, 
0
, 
1
}, 

{
1
, 
1
, 
0
, 
1
, 
0
}, 

{
0
, 
1
, 
1
, 
1
, 
0
}, 

{
1
, 
1
, 
1
, 
1
, 
0
}, 

{
1
, 
1
, 
1
, 
1
, 
1
}, 

{
0
, 
0
, 
0
, 
0
, 
0
}}; 


printMaxSubSquare(M); 

} 

} ",CorCod,514,514,quadratic
"
// Java Program to find max subarray 
// sum excluding some elements 
import
java.util.*; 

class
GFG 
{ 


// Utility function for findMaxSubarraySum() 

// with the following parameters 

// A => Array A, 

// B => Array B, 

// n => Number of elements in Array A, 

// m => Number of elements in Array B 

static
int
findMaxSubarraySumUtil(
int
A[], 
int
B[], 

int
n, 
int
m) 

{ 


// set max_so_far to INT_MIN 

int
max_so_far = Integer.MIN_VALUE, curr_max = 
0
; 


for
(
int
i = 
0
; i < n; i++) 

{ 


// if the element is present in B, 

// set current max to 0 and move to 

// the next element 

if
(Arrays.binarySearch(B, A[i]) >= 
0
) 

{ 

curr_max = 
0
; 

continue
; 

} 


// Proceed as in Kadane's Algorithm 

curr_max = Math.max(A[i], curr_max + A[i]); 

max_so_far = Math.max(max_so_far, curr_max); 

} 

return
max_so_far; 

} 


// Wrapper for findMaxSubarraySumUtil() 

static
void
findMaxSubarraySum(
int
A[], 
int
B[], 

int
n, 
int
m) 

{ 

// sort array B to apply Binary Search 

Arrays.sort(B); 


int
maxSubarraySum = findMaxSubarraySumUtil(A, B, 

n, m); 


// This case will occour when all elements 

// of A are present in B, thus no subarray 

// can be formed 

if
(maxSubarraySum == Integer.MIN_VALUE) 

{ 

System.out.println(
""Maximum subarray sum cant be found""
); 

} 

else

{ 

System.out.println(
""The Maximum subarray sum = ""

+ maxSubarraySum); 

} 

} 


// Driver Code 

public
static
void
main(String[] args) 

{ 

int
A[] = {
3
, 
4
, 
5
, -
4
, 
6
}; 

int
B[] = {
1
, 
8
, 
5
}; 


int
n = A.length; 

int
m = B.length; 


// Calling fucntion 

findMaxSubarraySum(A, B, n, m); 

} 
} 

// This code has been contributed by 29AjayKumar ",CorCod,607,607,nlogn
"
import
java.util.HashMap; 

/* Program for finding out majority element in an array */

class
MajorityElement 
{ 

private
static
void
findMajority(
int
[] arr) 

{ 

HashMap<Integer,Integer> map = 
new
HashMap<Integer, Integer>(); 


for
(
int
i = 
0
; i < arr.length; i++) { 

if
(map.containsKey(arr[i])) { 

int
count = map.get(arr[i]) +
1
; 

if
(count > arr.length /
2
) { 

System.out.println(
""Majority found :- ""
+ arr[i]); 

return
; 

} 
else

map.put(arr[i], count); 


} 

else

map.put(arr[i],
1
); 

} 

System.out.println(
"" No Majority element""
); 

} 



/* Driver program to test the above functions */

public
static
void
main(String[] args) 

{ 

int
a[] = 
new
int
[]{
2
,
2
,
2
,
2
,
5
,
5
,
2
,
3
,
3
}; 


findMajority(a); 

} 
} 
// This code is contributed by karan malhotra ",CorCod,110,110,linear
"import java.util.*;
public class java{
          public static void main(String[]arg) {
        	 Scanner sc=new Scanner(System.in); 
        	 int x=sc.nextInt();
        	 String s=sc.next();
        	 boolean f=true;
        	 boolean f2=true;
        	 boolean f3=true;
        	 boolean f4=true;
        	 int v=0;
        	 for(int i=0;i<s.length()-1;i++) {
        		 if(s.charAt(i)==s.charAt(i+1)&&(s.charAt(i)!='?'||s.charAt(i+1)!='?')) {
        			 f=false;
        			 break;
        		 }else {
        			 f=true;
        		 }
        	 }
        	
        	 
        	 for(int i=0;i<s.length();i++) {
        		 if(s.charAt(i)=='?') {
        			 
        			 if(i==0||i==s.length()-1) {
        				 f2=true; 
        				 v++;
        			 }else if(s.charAt(i)==s.charAt(i+1)) {
        					 f2=true;
        					 v++;
        			          }
        			 else if(s.charAt(i-1)==s.charAt(i+1)&&i!=0&&i!=s.length()-1) {
        					 f2=true;
        					 v++;
        			         }
        			 }else {
        				 if(v>0) f2=true;
        				 else f2=false;
        			 }
        		 }
        	 
        	if(f&&f2) {
        		System.out.println(""YES"");
        	}else {
        		System.out.println(""NO"");
        	}
          }
          
}
",CorCod,126,126,linear
"import java.math.BigInteger;
import java.util.Arrays;
import java.util.Scanner;

public class BigInteger7 {
    public static void main(String[] args) {
        //https://codeforces.com/contest/1011/problem/A
        Scanner scanner = new Scanner(System.in);
        BigInteger n = scanner.nextBigInteger();
        BigInteger k = scanner.nextBigInteger();
        scanner.nextLine();
        String string = scanner.nextLine();
        char ch[] = string.toCharArray();
        BigInteger ans = BigInteger.ZERO;
        BigInteger number = BigInteger.ZERO;
        Arrays.sort(ch);
        int prev = 0;
        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {
            if (i == 0) {
                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));
                prev = i;
                number = number.add(BigInteger.ONE);
            } else {
                if (ch[i] - ch[prev] > 1) {
                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));
                    prev = i;
                    number = number.add(BigInteger.ONE);
                }
            }
            if (number.equals(k)) {
                break;
            }
        }
        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {
            System.out.println(-1);
        } else {
            System.out.println(ans);
        }
    }
}
",CorCod,697,697,nlogn
"
// Java program to find maximum sum increasing 
// subsequence tiint i-th index and including 
// k-th index. 
class
GFG { 


static
int
pre_compute(
int
a[], 
int
n, 

int
index, 
int
k) 

{ 

int
dp[][] = 
new
int
[n][n]; 


// Initializing the first row of 

// the dp[][]. 

for
(
int
i = 
0
; i < n; i++) { 

if
(a[i] > a[
0
]) 

dp[
0
][i] = a[i] + a[
0
]; 

else

dp[
0
][i] = a[i]; 

} 


// Creating the dp[][] matrix. 

for
(
int
i = 
1
; i < n; i++) 

{ 

for
(
int
j = 
0
; j < n; j++) 

{ 

if
(a[j] > a[i] && j > i) 

{ 

if
(dp[i - 
1
][i] + a[j] > 

dp[i - 
1
][j]) 

dp[i][j] = dp[i - 
1
][i] 

+ a[j]; 

else

dp[i][j] = dp[i - 
1
][j]; 

} 

else

dp[i][j] = dp[i - 
1
][j]; 

} 

} 


// To calculate for i=4 and k=6. 

return
dp[index][k]; 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
a[] = { 
1
, 
101
, 
2
, 
3
, 
100
, 
4
, 
5
}; 

int
n = a.length; 

int
index = 
4
, k = 
6
; 

System.out.println( 

pre_compute(a, n, index, k)); 

} 
} 

// This code is contributed by Smitha. ",CorCod,528,528,quadratic
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.util.SortedSet;
import java.util.Set;
import java.util.NavigableSet;
import java.io.IOException;
import java.util.InputMismatchException;
import java.io.InputStreamReader;
import java.util.TreeSet;
import java.io.Writer;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Niyaz Nigmatullin
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        FastPrinter out = new FastPrinter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, FastScanner in, FastPrinter out) {
            int n = in.nextInt();
            int k = in.nextInt();
            char[] c = in.next().toCharArray();
            NavigableSet<Integer> ones = new TreeSet<>();
            NavigableSet<Integer> zeros = new TreeSet<>();
            for (int i = 0; i < n; i++) {
                if (c[i] == '0') zeros.add(i);
                else ones.add(i);
            }
            if (ones.isEmpty() || zeros.isEmpty() || ones.last() - ones.first() + 1 <= k || zeros.last() - zeros.first() + 1 <= k) {
                out.println(""tokitsukaze"");
                return;
            }
            if (check(ones, n, k) && check(zeros, n, k)) {
                out.println(""quailty"");
                return;
            }
            out.println(""once again"");
        }

        private boolean check(NavigableSet<Integer> ones, int n, int k) {
            for (int i = 0; i + k <= n; i++) {
                int left = ones.first();
                int right = ones.last();
                if (left >= i) {
                    left = ones.higher(i + k - 1);
                }
                if (right < i + k) {
                    right = ones.lower(i);
                }
                if (right - left + 1 > k) {
                    return false;
                }
            }
            return true;
        }

    }

    static class FastPrinter extends PrintWriter {
        public FastPrinter(OutputStream out) {
            super(out);
        }

        public FastPrinter(Writer out) {
            super(out);
        }

    }

    static class FastScanner extends BufferedReader {
        public FastScanner(InputStream is) {
            super(new InputStreamReader(is));
        }

        public int read() {
            try {
                int ret = super.read();
//            if (isEOF && ret < 0) {
//                throw new InputMismatchException();
//            }
//            isEOF = ret == -1;
                return ret;
            } catch (IOException e) {
                throw new InputMismatchException();
            }
        }

        public String next() {
            StringBuilder sb = new StringBuilder();
            int c = read();
            while (isWhiteSpace(c)) {
                c = read();
            }
            if (c < 0) {
                return null;
            }
            while (c >= 0 && !isWhiteSpace(c)) {
                sb.appendCodePoint(c);
                c = read();
            }
            return sb.toString();
        }

        static boolean isWhiteSpace(int c) {
            return c >= 0 && c <= 32;
        }

        public int nextInt() {
            int c = read();
            while (isWhiteSpace(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int ret = 0;
            while (c >= 0 && !isWhiteSpace(c)) {
                if (c < '0' || c > '9') {
                    throw new NumberFormatException(""digit expected "" + (char) c
                            + "" found"");
                }
                ret = ret * 10 + c - '0';
                c = read();
            }
            return ret * sgn;
        }

        public String readLine() {
            try {
                return super.readLine();
            } catch (IOException e) {
                return null;
            }
        }

    }
}

",CorCod,99,99,linear
"import java.util.*;
public class TestClass
{
   public static void main(String args[])
   {
   	Scanner in = new Scanner(System.in);
   	int n = in.nextInt();
   	int m = in.nextInt();
   	int k = in.nextInt();
   	int arr[] = new int[n+1];
   	for(int i =0;i<n;i++)
   	 arr[i+1]= in.nextInt();
   	
   	long sum[] = new long [n+1];
   	
   	for(int i=1;i<=n;i++)
   	 sum[i]=sum[i-1]+arr[i];
   	
    long dp[] = new long[n+1];

    for(int i =1;i<=n;i++)
    {
      for(int j=i;j>i-m&&j>=1;j--)
      {
        long val = sum[i]-sum[j-1]+dp[j-1]-k;
        dp[i]= Math.max(dp[i],val);
      }	
    }
    long max =0;
    for(int i =1;i<=n;i++)
     max=Math.max(max,dp[i]);
    
    System.out.println(max);
     
   }	
}",CorCod,490,490,quadratic
"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

public class Main {

	static void insert(TreeMap<Integer, Integer>map,int v,int d)
	{
		if(!map.containsKey(v))map.put(v, 0);
		map.put(v, d+map.get(v));
		if(map.get(v)==0)map.remove(v);
	}
	
	static void cut(TreeSet<Integer> cuts, TreeMap<Integer, Integer>segments,int v)
	{
		int upper = cuts.higher(v) , lower = cuts.lower(v);
		insert(segments, upper-lower, -1);
		insert(segments, upper-v, 1);
		insert(segments, v-lower, 1);
		cuts.add(v);
	}
	
	public static void main(String[] args) throws Throwable {
		Scanner sc = new Scanner(System.in);
		int w = sc.nextInt(), h = sc.nextInt() , n = sc.nextInt();
		TreeSet<Integer> vCuts = new TreeSet<>() , hCuts = new TreeSet<>();
		TreeMap<Integer, Integer> vSegments = new TreeMap<>() , hSegments = new TreeMap<>();
		vCuts.add(0);vCuts.add(w);
		hCuts.add(0);hCuts.add(h);
		insert(vSegments, w, 1);
		insert(hSegments, h, 1);
		StringBuilder sb = new StringBuilder();
		while(n-->0)
		{
			if(sc.next().equals(""H""))
				cut(hCuts, hSegments, sc.nextInt());
			else
				cut(vCuts, vSegments, sc.nextInt());
			sb.append(1l*hSegments.lastKey() * vSegments.lastKey() + ""\n"");
		}
		System.out.println(sb);
	}
	
	static class Scanner {
		StringTokenizer st;
		BufferedReader br;
		public Scanner(InputStream s) {br = new BufferedReader(new InputStreamReader(s));}
		public Scanner(String file) throws FileNotFoundException {br = new BufferedReader(new FileReader(file));}
		public String next() throws IOException {while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();}
		public int nextInt() throws IOException {return Integer.parseInt(next());}
		public long nextLong() throws IOException {return Long.parseLong(next());}
		public String nextLine() throws IOException {return br.readLine();}
		public double nextDouble() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder(""0"");
			double res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder(""0"");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}
		public int[] nexIntArray() throws Throwable {
			st = new StringTokenizer(br.readLine());
			int[] a = new int[st.countTokens()];
			for (int i = 0; i < a.length; i++)a[i] = nextInt();
			return a;
		}
		public boolean ready() throws IOException {return br.ready();}
	}
}",CorCod,633,633,nlogn
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package newpackage;
import java.util.*;
/**
 *
 * @author parpaorsa
 */
public class NewClass {
    static Scanner in=new Scanner(System.in);
    public static void main(String[] args) {
        int n = in.nextInt(),ans=Integer.MAX_VALUE,t=0;
        String x = in.next();
        for (int i = 0; i < n; i++) {
            if(x.charAt(i)=='-')t--;
            else t++;
            ans=Math.min(ans,t);
        }
           if(ans <= 0) 
               System.out.println(Math.abs(ans)+t);
           else 
               System.out.println(t);
    }
 
}
",CorCod,376,376,linear
"
// Java program to find smallest and second smallest elements 
import
java.io.*; 

class
SecondSmallest 
{ 

/* Function to print first smallest and second smallest 

elements */

static
void
print2Smallest(
int
arr[]) 

{ 

int
first, second, arr_size = arr.length; 


/* There should be atleast two elements */

if
(arr_size < 
2
) 

{ 

System.out.println(
"" Invalid Input ""
); 

return
; 

} 


first = second = Integer.MAX_VALUE; 

for
(
int
i = 
0
; i < arr_size ; i ++) 

{ 

/* If current element is smaller than first 

then update both first and second */

if
(arr[i] < first) 

{ 

second = first; 

first = arr[i]; 

} 


/* If arr[i] is in between first and second 

then update second */

else
if
(arr[i] < second && arr[i] != first) 

second = arr[i]; 

} 

if
(second == Integer.MAX_VALUE) 

System.out.println(
""There is no second""
+ 

""smallest element""
); 

else

System.out.println(
""The smallest element is ""
+ 

first + 
"" and second Smallest""
+ 

"" element is ""
+ second); 

} 


/* Driver program to test above functions */

public
static
void
main (String[] args) 

{ 

int
arr[] = {
12
, 
13
, 
1
, 
10
, 
34
, 
1
}; 

print2Smallest(arr); 

} 
} 
/*This code is contributed by Devesh Agrawal*/",CorCod,348,348,linear
"
// Java program to find number of operations 
// to make an array palindrome 

class
GFG 
{ 

// Returns minimum number of count operations 

// required to make arr[] palindrome 

static
int
findMinOps(
int
[] arr, 
int
n) 

{ 

int
ans = 
0
; 
// Initialize result 


// Start from two corners 

for
(
int
i=
0
,j=n-
1
; i<=j;) 

{ 

// If corner elements are same, 

// problem reduces arr[i+1..j-1] 

if
(arr[i] == arr[j]) 

{ 

i++; 

j--; 

} 


// If left element is greater, then 

// we merge right two elements 

else
if
(arr[i] > arr[j]) 

{ 

// need to merge from tail. 

j--; 

arr[j] += arr[j+
1
] ; 

ans++; 

} 


// Else we merge left two elements 

else

{ 

i++; 

arr[i] += arr[i-
1
]; 

ans++; 

} 

} 


return
ans; 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

int
arr[] = 
new
int
[]{
1
, 
4
, 
5
, 
9
, 
1
} ; 

System.out.println(
""Count of minimum operations is ""
+ 

findMinOps(arr, arr.length)); 


} 
} ",CorCod,27,27,linear
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author kessido
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        BTheHat solver = new BTheHat();
        solver.solve(1, in, out);
        out.close();
    }

    static class BTheHat {
        PrintWriter out;
        InputReader in;
        int n;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            this.out = out;
            this.in = in;
            n = in.NextInt();
            int desiredPair = -1;
            int result = query(1);
            if (result != 0) {
                int l = 2, r = 1 + n / 2;
                while (l < r) {
                    int m = (l + r) / 2;
                    int mRes = query(m);
                    if (mRes == 0) {
                        desiredPair = m;
                        break;
                    } else if (mRes == result) {
                        l = m + 1;
                    } else {
                        r = m;
                    }
                }
            } else {
                desiredPair = 1;
            }
            out.println(""! "" + desiredPair);
        }

        private int query(int i) {
            int iV = queryValue(i);
            int iN2V = queryValue(i + n / 2);
            if (iV < iN2V) {
                return -1;
            } else if (iV > iN2V) {
                return 1;
            }
            return 0;
        }

        private int queryValue(int i) {
            out.println(""? "" + i);
            out.flush();
            return in.NextInt();
        }

    }

    static class InputReader {
        BufferedReader reader;
        StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine(), "" \t\n\r\f,"");
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int NextInt() {
            return Integer.parseInt(next());
        }

    }
}

",CorCod,896,896,logn
"import java.util.*;
import java.io.*;

public class SonyaExhibition {
	static BufferedReader br;
	static StringTokenizer tokenizer;

	public static void main(String[] args) throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
		int n = nextInt();
		int[] arr = {0,1};
		for(int i = 0; i < n; i++) {
			System.out.print(arr[i % 2]);
		}
		System.out.println();
	}

	public static String next() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens()) {
			String line = br.readLine();
			if (line == null)
				throw new IOException();
			tokenizer = new StringTokenizer(line);
		}
		return tokenizer.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
}
",CorCod,23,23,linear
"
class
SubarraySum 
{ 

/* Returns true if the there is a subarray of arr[] with a sum equal to 

'sum' otherwise returns false. Also, prints the result */

int
subArraySum(
int
arr[], 
int
n, 
int
sum) 

{ 

int
curr_sum, i, j; 


// Pick a starting point 

for
(i = 
0
; i < n; i++) 

{ 

curr_sum = arr[i]; 


// try all subarrays starting with 'i' 

for
(j = i + 
1
; j <= n; j++) 

{ 

if
(curr_sum == sum) 

{ 

int
p = j - 
1
; 

System.out.println(
""Sum found between indexes ""
+ i 

+ 
"" and ""
+ p); 

return
1
; 

} 

if
(curr_sum > sum || j == n) 

break
; 

curr_sum = curr_sum + arr[j]; 

} 

} 


System.out.println(
""No subarray found""
); 

return
0
; 

} 


public
static
void
main(String[] args) 

{ 

SubarraySum arraysum = 
new
SubarraySum(); 

int
arr[] = {
15
, 
2
, 
4
, 
8
, 
9
, 
5
, 
10
, 
23
}; 

int
n = arr.length; 

int
sum = 
23
; 

arraysum.subArraySum(arr, n, sum); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,519,519,quadratic
"
// Java program to find pair with sum closest to x 
import
java.io.*; 
import
java.util.*; 
import
java.lang.Math; 

class
CloseSum { 


// Prints the pair with sum cloest to x 

static
void
printClosest(
int
arr[], 
int
n, 
int
x) 

{ 

int
res_l=
0
, res_r=
0
; 
// To store indexes of result pair 


// Initialize left and right indexes and difference between 

// pair sum and x 

int
l = 
0
, r = n-
1
, diff = Integer.MAX_VALUE; 


// While there are elements between l and r 

while
(r > l) 

{ 

// Check if this pair is closer than the closest pair so far 

if
(Math.abs(arr[l] + arr[r] - x) < diff) 

{ 

res_l = l; 

res_r = r; 

diff = Math.abs(arr[l] + arr[r] - x); 

} 


// If this pair has more sum, move to smaller values. 

if
(arr[l] + arr[r] > x) 

r--; 

else
// Move to larger values 

l++; 

} 


System.out.println(
"" The closest pair is ""
+arr[res_l]+
"" and ""
+ arr[res_r]); 
} 



// Driver program to test above function 

public
static
void
main(String[] args) 

{ 

int
arr[] = {
10
, 
22
, 
28
, 
29
, 
30
, 
40
}, x = 
54
; 

int
n = arr.length; 

printClosest(arr, n, x); 

} 
} 
/*This code is contributed by Devesh Agrawal*/",CorCod,287,287,linear
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Pradyumn
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        FastReader in;
        PrintWriter out;
        int n;

        public void solve(int testNumber, FastReader in, PrintWriter out) {
            this.in = in;
            this.out = out;
            n = in.nextInt();
            if (n % 4 != 0) {
                out.println(""! -1"");
                return;
            }
            int low = 0;
            int high = n >> 1;
            if (BValue(low) == 0) {
                out.println(""! "" + (low + 1));
                return;
            }
            int fSign = Integer.signum(BValue(low));
            while (high - low > 1) {
                int mid = (high + low) >> 1;
                int mSign = Integer.signum(BValue(mid));
                if (mSign == 0) {
                    out.println(""! "" + (mid + 1));
                    return;
                }
                if (mSign == -fSign) {
                    high = mid;
                } else {
                    low = mid;
                }
            }
            out.println(""! -1"");
        }

        public int BValue(int index) {
            out.println(""? "" + (index + 1));
            out.flush();
            int f = in.nextInt();
            out.println(""? "" + (index + 1 + (n >> 1)));
            out.flush();
            int s = in.nextInt();
            return f - s;
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int pnumChars;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        private int pread() {
            if (pnumChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= pnumChars) {
                curChar = 0;
                try {
                    pnumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (pnumChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            int res = 0;
            do {
                if (c == ',') {
                    c = pread();
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",CorCod,931,931,logn
"import java.util.Scanner;

public class Main {
	public static void main(String args[]) {
		Scanner in=new Scanner(System.in);
		String str=in.next();
		int cnt=0;
		for(int i=0;i<str.length();++i) {
			if(str.charAt(i)=='1') {
				++cnt;
			}
		}
		int i=0;
		for(;i<str.length();++i) {
			if(str.charAt(i)=='0') {
				System.out.print(""0"");
			}
			else if(str.charAt(i)=='2') {
				while(cnt-->0) {//
					System.out.print(""1"");
				}
				System.out.print(""2"");
			}
		}
		while(cnt-->0) {
			System.out.print(""1"");
		}
		in.close();
	}
}",CorCod,208,208,linear
"import java.util.Scanner;
public class JavaApplication7 {

    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n= sc.nextInt();
        int m=sc.nextInt();
        long sum=0;
        long []d=new long[n];
        long[]ds=new long[n];
        for(int i =0;i<n;i++){
            d[i]=sc.nextLong();
            sum+=d[i];
            ds[i]=sum;
        }
        long[]le=new long[m];
        for(int i =0;i<m;i++){
            le[i]=sc.nextLong();
        }
        int l=0;
        int h=n;
        int k=(h-l)/2;
        k+=l;
        for(int i=0;i<m;i++){
        l=0;
        h=n;
        k=(h-l)/2;
        k+=l;
            for(;l<=h;){
                k=(h-l)/2;
                k+=l;
                if(ds[k]<le[i]){
                    l=k+1;
                }
                else if(ds[k]==le[i]){break;}
                else{
                    h=k-1;
                }
            }
            //System.out.println(k);
            if(ds[k]<le[i]){
                    k++;
                }
          if(k==0){
              System.out.println((int)(k+1)+"" ""+le[i]);
           }
            else{
                System.out.println((int)(k+1)+"" ""+(long)(le[i]-ds[k-1]));
           }
        }
        
    }
    
}
",CorCod,689,689,nlogn
"
// Java program to find the longest subsequence 
// such that the difference between adjacent 
// elements of the subsequence is one. 
import
java.io.*; 

class
GFG { 


// Function to find the length of longest 

// subsequence 

static
int
longestSubseqWithDiffOne(
int
arr[], 

int
n) 

{ 

// Initialize the dp[] array with 1 as a 

// single element will be of 1 length 

int
dp[] = 
new
int
[n]; 

for
(
int
i = 
0
; i< n; i++) 

dp[i] = 
1
; 


// Start traversing the given array 

for
(
int
i = 
1
; i < n; i++) 

{ 

// Compare with all the previous 

// elements 

for
(
int
j = 
0
; j < i; j++) 

{ 

// If the element is consecutive 

// then consider this subsequence 

// and update dp[i] if required. 

if
((arr[i] == arr[j] + 
1
) || 

(arr[i] == arr[j] - 
1
)) 


dp[i] = Math.max(dp[i], dp[j]+
1
); 

} 

} 


// Longest length will be the maximum 

// value of dp array. 

int
result = 
1
; 

for
(
int
i = 
0
; i < n ; i++) 

if
(result < dp[i]) 

result = dp[i]; 

return
result; 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

// Longest subsequence with one 

// difference is 

// {1, 2, 3, 4, 3, 2} 

int
arr[] = {
1
, 
2
, 
3
, 
4
, 
5
, 
3
, 
2
}; 

int
n = arr.length; 

System.out.println(longestSubseqWithDiffOne( 

arr, n)); 

} 
} 

// This code is contributed by Prerna Saini ",CorCod,568,568,quadratic
"import java.util.*;
import java.io.*;
public class C{
    static PrintWriter out;
    static InputReader in;
    public static void main(String args[]){
        out = new PrintWriter(System.out);
        in = new InputReader();
        new C();
        out.flush(); out.close();
    }   
    C(){
       int a = solve();
       out.print(a == 0 ? ""tokitsukaze"" : a == 1 ? ""quailty"" : ""once again"");
    }
    int n, k;
    char ch[]; int a[], c0 = 0, c1 = 0;
    TreeSet<Integer> ts[] = new TreeSet[2];
    boolean check(){
        int min = 0, max = n;
        if(!ts[0].isEmpty()){
            min = ts[0].first(); max = ts[0].last();
            if(max - min + 1 > k)return true;
        }
        if(!ts[1].isEmpty()){
            min = ts[1].first(); max = ts[1].last();
            if(max - min + 1 > k)return true;   
        }
        return false;
    }
    int solve(){
        n  = in.nextInt(); k = in.nextInt();
        ch = in.next().trim().toCharArray(); a = new int[n];
        for(int i = 0; i < n; i++)c1 += a[i] = ch[i] - '0';
        c0 = n - c1;
        for(int i = 0; i < k; i++){
            if(a[i] == 0)c0--; else c1--;
        }
        if(c0 == 0 || c1 == 0)return 0;
        for(int i = k; i < n; i++){
            if(a[i] == 0)c0--; else c1--;
            if(a[i - k] == 0)c0++; else c1++;
            if(c0 == 0 || c1 == 0)return 0;
        }

        for(int i = 0; i < 2; i++)ts[i] = new TreeSet<>();
        for(int i = 0; i < n; i++){
            ts[a[i]].add(i);
        }
        for(int i = 0; i < k; i++){
            ts[a[i]].remove(i);
        }
        if(check())return 2;
        for(int i = k; i < n; i++){
            ts[a[i]].remove(i); ts[a[i - k]].add(i - k);
            if(check())return 2;
        }
        return 1;
    }
    public static class InputReader{
        BufferedReader br;
        StringTokenizer st;
        InputReader(){
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        public int nextInt(){
            return Integer.parseInt(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public String next(){
            while(st == null || !st.hasMoreTokens()){
                try{
                    st = new StringTokenizer(br.readLine());
                }catch(IOException e){}
            }
            return st.nextToken();
        }
    }
}
        ",CorCod,365,365,linear
"import java.io.*;
import java.util.*;

public class Solution{
    
    static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;

        public FastReader()
        {
            br = new BufferedReader(new
                     InputStreamReader(System.in));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt()
        {
            return Integer.parseInt(next());
        }

        long nextLong()
        {
            return Long.parseLong(next());
        }

        double nextDouble()
        {
            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
    
    public static void main(String args[] ) {
        
        FastReader sc = new FastReader();
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] arr = new int[105];
        
        for(int i=0;i<m;i++){
            int a = sc.nextInt();
            arr[a]++;
        }
        
        for(int i=1;i<=1000;i++){
            int sum=0;
            
            for(int a:arr){
                if(a!=0){
                    sum+=(a/i);
                }
            }
            
            
            if(sum<n){
                System.out.println(i-1);
                return;
            }
            
        }
    }

}
",CorCod,492,492,quadratic
"
// Java program to find Maximum path sum 
// start any column in row '0' and ends 
// up to any column in row 'n-1' 
import
java.util.*; 

class
GFG { 


static
int
N = 
4
; 


// function find maximum sum path 

static
int
MaximumPath(
int
Mat[][]) 

{ 

int
result = 
0
; 


// creat 2D matrix to store the sum 

// of the path 

int
dp[][] = 
new
int
[N][N + 
2
]; 


// initialize all dp matrix as '0' 

for
(
int
[] rows : dp) 

Arrays.fill(rows, 
0
); 


// copy all element of first column into 

// 'dp' first column 

for
(
int
i = 
0
; i < N; i++) 

dp[
0
][i + 
1
] = Mat[
0
][i]; 


for
(
int
i = 
1
; i < N; i++) 

for
(
int
j = 
1
; j <= N; j++) 

dp[i][j] = Math.max(dp[i - 
1
][j - 
1
], 

Math.max(dp[i - 
1
][j], 

dp[i - 
1
][j + 
1
])) + 

Mat[i][j - 
1
]; 


// Find maximum path sum that end ups 

// at any column of last row 'N-1' 

for
(
int
i = 
0
; i <= N; i++) 

result = Math.max(result, dp[N - 
1
][i]); 


// return maximum sum path 

return
result; 

} 


// driver code 

public
static
void
main(String arg[]) 

{ 

int
Mat[][] = { { 
4
, 
2
, 
3
, 
4
}, 

{ 
2
, 
9
, 
1
, 
10
}, 

{ 
15
, 
1
, 
3
, 
0
}, 

{ 
16
, 
92
, 
41
, 
44
} }; 


System.out.println(MaximumPath(Mat)); 

} 
} 

// This code is contributed by Anant Agarwal. ",CorCod,548,548,quadratic
"
// Java implementation to find 
// the sum of all the parent 
// nodes having child node x 
class
GFG 
{ 
// sum 
static
int
sum = 
0
; 


// Node of a binary tree 
static
class
Node 
{ 

int
data; 

Node left, right; 
}; 

// function to get a new node 
static
Node getNode(
int
data) 
{ 

// allocate memory for the node 

Node newNode = 
new
Node(); 


// put in the data 

newNode.data = data; 

newNode.left = newNode.right = 
null
; 

return
newNode; 
} 

// function to find the sum of all the 
// parent nodes having child node x 
static
void
sumOfParentOfX(Node root, 
int
x) 
{ 

// if root == NULL 

if
(root == 
null
) 

return
; 


// if left or right child 

// of root is 'x', then 

// add the root's data to 'sum' 

if
((root.left != 
null
&& root.left.data == x) || 

(root.right != 
null
&& root.right.data == x)) 

sum += root.data; 


// recursively find the required 

// parent nodes in the left and 

// right subtree 

sumOfParentOfX(root.left, x); 

sumOfParentOfX(root.right, x); 

} 

// utility function to find the 
// sum of all the parent nodes 
// having child node x 
static
int
sumOfParentOfXUtil(Node root, 

int
x) 
{ 

sum = 
0
; 

sumOfParentOfX(root, x); 


// required sum of parent nodes 

return
sum; 
} 

// Driver Code 
public
static
void
main(String args[]) 
{ 

// binary tree formation 

Node root = getNode(
4
); 
// 4 

root.left = getNode(
2
); 
// / \ 

root.right = getNode(
5
); 
// 2 5 

root.left.left = getNode(
7
); 
// / \ / \ 

root.left.right = getNode(
2
); 
// 7 2 2 3 

root.right.left = getNode(
2
); 

root.right.right = getNode(
3
); 


int
x = 
2
; 


System.out.println( 
""Sum = ""
+ 

sumOfParentOfXUtil(root, x)); 
} 
} 

// This code is contributed by Arnab Kundu ",CorCod,98,98,linear
"import java.util.*;

public class helloWorld 
{
	public static void main(String[] args) 
	{		
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int m = in.nextInt();
		String str = in.next();
		boolean[] exist = new boolean[200];
		int dn[][] = new int[200][m+1];
		
		for(int i = 0; i < n; i++) {
			int a = str.charAt(i);
			exist[a] = true;
			dn[a][1] = a - 'a' + 1;
		}
		
		for(int k = 2; k <= m; k++) 
			for(int i = 'a'; i <= 'z'; i++)
				if(exist[i]) {
					int a = 0;
					for(int j = i+2; j <= 'z'; j++)
						if(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) 
							a = dn[j][k-1];
					if(a > 0)
						dn[i][k] = a + i - 'a' + 1; 
				}
		
		int ans = -1;
		for(int i = 'a'; i <= 'z'; i++)
			if(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )
				ans = dn[i][m];
		
		System.out.println(ans);
		
		in.close();
	}
}	



",CorCod,384,384,linear
"
// Java Code for Maximum sum in a 2 x n grid 
// such that no two elements are adjacent 
import
java.util.*; 

class
GFG { 


// Function to find max sum without adjacent 

public
static
int
maxSum(
int
grid[][], 
int
n) 

{ 

// Sum including maximum element of first 

// column 

int
incl = Math.max(grid[
0
][
0
], grid[
1
][
0
]); 


// Not including first column's element 

int
excl = 
0
, excl_new; 


// Traverse for further elements 

for
(
int
i = 
1
; i < n; i++ ) 

{ 

// Update max_sum on including or 

// excluding of previous column 

excl_new = Math.max(excl, incl); 


// Include current column. Add maximum element 

// from both row of current column 

incl = excl + Math.max(grid[
0
][i], grid[
1
][i]); 


// If current column doesn't to be included 

excl = excl_new; 

} 


// Return maximum of excl and incl 

// As that will be the maximum sum 

return
Math.max(excl, incl); 

} 


/* Driver program to test above function */

public
static
void
main(String[] args) 

{ 

int
grid[][] = {{ 
1
, 
2
, 
3
, 
4
, 
5
}, 

{ 
6
, 
7
, 
8
, 
9
, 
10
}}; 


int
n = 
5
; 

System.out.println(maxSum(grid, n)); 

} 

} 
// This code is contributed by Arnav Kr. Mandal. ",CorCod,205,205,linear
"import java.util.*;

public class B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int x = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        Arrays.sort(a);
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(a[i]);
        }
        for (int i = 0; i < n - 1; i++) {
            if (a[i] == a[i + 1]) {
                System.out.println(0);
                return;
            }
        }
        for (int i = n - 1; i > 0; i--) {
            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {
                System.out.println(2);
                return;
            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {
                System.out.println(1);
                return;
            }
        }
        System.out.println(-1);
    }
}",CorCod,472,472,quadratic
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 * @author Don Li
 */
public class OlyaAndMagicalSquare {
    void solve() {
        long[] dp = new long[32];
        dp[0] = 0;
        for (int i = 1; i < 32; i++) {
            dp[i] = 4 * dp[i - 1] + 1;
        }
        
        int T = in.nextInt();
        L:
        while (T-- > 0) {
            int n = in.nextInt(); long k = in.nextLong();
            
            if (n > 31) {
                out.println(""YES "" + (n - 1));
                continue;
            }
            
            long tot = 0;
            for (int a = n - 1; a >= 0; a--) {
                k -= (1L << (n - a)) - 1;
                if (k < 0) break;
                if (k == 0) {
                    out.println(""YES "" + a);
                    continue L;
                }
                long limit = (1L << (n + 1 - a)) - 3;
                if (k <= tot || dp[a] > 0 && (k - tot + dp[a] - 1) / dp[a] <= limit) {
                    out.println(""YES "" + a);
                    continue L;
                }
                tot += dp[a] * limit;
            }
            out.println(""NO"");
        }
    }
    
    public static void main(String[] args) {
        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(System.out);
        new OlyaAndMagicalSquare().solve();
        out.close();
    }
    
    static FastScanner in;
    static PrintWriter out;
    
    static class FastScanner {
        BufferedReader in;
        StringTokenizer st;
        
        public FastScanner(BufferedReader in) {
            this.in = in;
        }
        
        public String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        
        public int nextInt() {
            return Integer.parseInt(nextToken());
        }
        
        public long nextLong() {
            return Long.parseLong(nextToken());
        }
        
        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }
}
",CorCod,901,901,logn
"import java.util.*;
import java.math.*;
public class Main{
    public static void main(String [] args)
    {
        Scanner scan=new Scanner(System.in);
        long n=scan.nextLong();
        long m=scan.nextLong();
        n=(long)Math.pow(2,n);
        long ans=m%n;
        System.out.println(ans);
    }
}",CorCod,761,761,constant
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class ElevatorOrStairs {

	private static final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
	private static final OutputStreamWriter writer = new OutputStreamWriter(System.out);
	
	public static void main(String...strings) throws Exception {
		String[] specs = reader.readLine().split("" "");
		
		int x = Integer.parseInt(specs[0]);
		int y = Integer.parseInt(specs[1]);
		int z = Integer.parseInt(specs[2]);
		int t1 = Integer.parseInt(specs[3]);
		int t2 = Integer.parseInt(specs[4]);
		int t3 = Integer.parseInt(specs[5]);
		
		reader.close();
		String ans = solve(x, y, z, t1, t2, t3);
		writer.append(ans);
		writer.flush();
		writer.close();
	}
	
	private static String solve(int x, int y, int z, int t1, int t2, int t3) {
		int time_using_stairs = Math.abs(x - y) * t1;
		int elevator_time_between_floor = Math.abs(x - z) * t2;
		int elevator_from_z_to_x = elevator_time_between_floor + 2*t3;
		
 		int time_using_elevator = elevator_from_z_to_x + (Math.abs(x - y) * t2) + t3;
 		
 		if(time_using_elevator <= time_using_stairs) {
 			return ""YES"";
 		}
 		return ""NO"";
	}
}",CorCod,850,850,constant
"
import
java.io.*; 

class
PairSum { 


// Fills element in arr[] from its pair sum array pair[]. 

// n is size of arr[] 

static
void
constructArr(
int
arr[], 
int
pair[], 
int
n) 

{ 

arr[
0
] = (pair[
0
]+pair[
1
]-pair[n-
1
]) / 
2
; 

for
(
int
i=
1
; i<n; i++) 

arr[i] = pair[i-
1
]-arr[
0
]; 

} 


// Driver program to test above function 

public
static
void
main(String[] args) 

{ 

int
pair[] = {
15
, 
13
, 
11
, 
10
, 
12
, 
10
, 
9
, 
8
, 
7
, 
5
}; 

int
n = 
5
; 

int
[] arr = 
new
int
[n]; 

constructArr(arr, pair, n); 

for
(
int
i = 
0
; i < n; i++) 

System.out.print(arr[i]+
"" ""
); 

} 
} 
/* This code is contributed by Devesh Agrawal */",CorCod,140,140,linear
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;

public class KingEscape {

    public static void main(String[] args) {
        Reader read = new Reader();

        int n = read.nextInt();
        int a1 = read.nextInt();
        int a2 = read.nextInt();
        int b1 = read.nextInt();
        int b2 = read.nextInt();
        int c1 = read.nextInt();
        int c2 = read.nextInt();

        if (b1 > a1 && b2 > a2 && c1 > a1 && c2 > a2)
            System.out.print(""YES"");
        else if (b1 > a1 && b2 < a2 && c1 > a1 && c2 < a2)
            System.out.print(""YES"");
        else if (b1 < a1 && b2 > a2 && c1 < a1 && c2 > a2)
            System.out.print(""YES"");
        else if (b1 < a1 && b2 < a2 && c1 < a1 && c2 < a2)
            System.out.print(""YES"");
        else
            System.out.print(""NO"");
    }

    private static class Reader {

        private final BufferedReader reader;
        private final String separator;
        private String ln;
        private String[] tokens;
        private int ptr;

        Reader(String separator, InputStream input) {
            this.reader = new BufferedReader(new InputStreamReader(input));
            this.separator = separator;
            this.ptr = -1;
        }

        Reader(String separator) { this(separator, System.in); }

        Reader() { this("" ""); }

        String nextStr(){
            if (Objects.isNull(ln)) {
                try {
                    ln = reader.readLine();
                } catch (IOException e) {
                    System.out.println(e.getMessage());
                }
                if (Objects.nonNull(ln)) {
                    tokens = ln.split(separator);
                    ptr = 0;
                } else {
                    throw new NoSuchElementException(""no next element"");
                }

            } else if (ptr == tokens.length) {
                ln = null;
                tokens = null;
                ptr = -1;
                return nextStr();
            }

            return tokens[ptr++];
        }

        int nextInt() { return Integer.parseInt(nextStr()); }

        long nextLong() { return Long.parseLong(nextStr()); }

        double nextDouble() { return Double.parseDouble(nextStr()); }
    }
}
",CorCod,796,796,constant
"import java.util.*;
import java.io.*;

public class MinimumDiameterTree{
    public static void main(String[] args) {
	InputReader in = new InputReader (System.in);
	PrintWriter out = new PrintWriter (System.out);

	int n = in.nextInt();
	int s = in.nextInt();
	int deg[] = new int [n];
	
	for (int i = 1; i < n; ++i) {
	    deg[in.nextInt() - 1] ++;
	    deg[in.nextInt() - 1] ++;
	}

	int l = 0;
	for (int i = 0; i < n; ++i)
	    if (deg[i] == 1) l ++;

	out.println((double) 2 * s / l);
	out.close();
    }

    public static class InputReader {
	public BufferedReader reader;
	public StringTokenizer tokenizer;

	public InputReader(InputStream stream) {
	    reader = new BufferedReader(new InputStreamReader(stream), 32768);
	    tokenizer = null;
	}

	public String next() {
	    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
		try {
		    tokenizer = new StringTokenizer(reader.readLine());
		} catch(IOException e) {
		    throw new RuntimeException(e);
		}
	    }
	    return tokenizer.nextToken();
	}

	public int nextInt() {
	    return Integer.parseInt(next());
	}

	public long nextLong() {
            return Long.parseLong(next());
        }
    }
}
",CorCod,41,41,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

/**
 * @author Don Li
 */
public class EhabAndAComponentChoosingProblem {
    
    long INF = (long) 1e18;
    
    int n;
    int[] a;
    
    int[][] G;
    
    void solve() {
        n = in.nextInt();
        a = new int[n];
        for (int i = 0; i < n; i++) a[i] = in.nextInt();
        int[] fr = new int[n - 1], to = new int[n - 1];
        for (int i = 0; i < n - 1; i++) {
            fr[i] = in.nextInt() - 1;
            to[i] = in.nextInt() - 1;
        }
        G = build_graph(n, fr, to);
        
        int[][] ret = bfs(G, 0);
        int[] par = ret[0], ord = ret[2];
        
        long best = -INF;
        long[] dp = new long[n];
        for (int i = n - 1; i >= 0; i--) {
            int u = ord[i];
            dp[u] = a[u];
            for (int v : G[u]) {
                if (v != par[u]) {
                    if (dp[v] > 0) dp[u] += dp[v];
                }
            }
            best = Math.max(best, dp[u]);
        }
        
        int k = 0;
        for (int i = n - 1; i >= 0; i--) {
            int u = ord[i];
            dp[u] = a[u];
            for (int v : G[u]) {
                if (v != par[u]) {
                    if (dp[v] > 0) dp[u] += dp[v];
                }
            }
            if (dp[u] == best) {
                dp[u] = -INF;
                k++;
            }
        }
        
        out.printf(""%d %d%n"", best * k, k);
    }
    
    int[][] bfs(int[][] G, int root) {
        int n = G.length;
        
        int[] par = new int[n];
        Arrays.fill(par, -1);
        
        int[] dep = new int[n];
        dep[root] = 0;
        
        int[] qu = new int[n];
        qu[0] = root;
        for (int l = 0, r = 1; l < r; l++) {
            int u = qu[l];
            for (int v : G[u]) {
                if (v != par[u]) {
                    qu[r++] = v;
                    par[v] = u;
                    dep[v] = dep[u] + 1;
                }
            }
        }
        
        return new int[][]{par, dep, qu};
    }
    
    int[][] build_graph(int n, int[] from, int[] to) {
        int[][] G = new int[n][];
        int[] cnt = new int[n];
        for (int i = 0; i < from.length; i++) {
            cnt[from[i]]++;
            cnt[to[i]]++;
        }
        for (int i = 0; i < n; i++) G[i] = new int[cnt[i]];
        for (int i = 0; i < from.length; i++) {
            G[from[i]][--cnt[from[i]]] = to[i];
            G[to[i]][--cnt[to[i]]] = from[i];
        }
        return G;
    }
    
    public static void main(String[] args) {
        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(System.out);
        new EhabAndAComponentChoosingProblem().solve();
        out.close();
    }
    
    static FastScanner in;
    static PrintWriter out;
    
    static class FastScanner {
        BufferedReader in;
        StringTokenizer st;
        
        public FastScanner(BufferedReader in) {
            this.in = in;
        }
        
        public String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        
        public int nextInt() {
            return Integer.parseInt(nextToken());
        }
        
        public long nextLong() {
            return Long.parseLong(nextToken());
        }
        
        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }
}
",CorCod,156,156,linear
"
// A Naive Java program to find 
// maximum sum rotation 
import
java.util.*; 
import
java.io.*; 

class
GFG { 

// Returns maximum value of i*arr[i] 
static
int
maxSum(
int
arr[], 
int
n) 
{ 
// Initialize result 
int
res = Integer.MIN_VALUE; 

// Consider rotation beginning with i 
// for all possible values of i. 
for
(
int
i = 
0
; i < n; i++) 
{ 


// Initialize sum of current rotation 

int
curr_sum = 
0
; 


// Compute sum of all values. We don't 

// actually rotation the array, but compute 

// sum by finding ndexes when arr[i] is 

// first element 

for
(
int
j = 
0
; j < n; j++) 

{ 

int
index = (i + j) % n; 

curr_sum += j * arr[index]; 

} 


// Update result if required 

res = Math.max(res, curr_sum); 
} 

return
res; 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

int
arr[] = {
8
, 
3
, 
1
, 
2
}; 

int
n = arr.length; 

System.out.println(maxSum(arr, n)); 
} 


} 

// This code is contributed by Sahil_Bansall ",CorCod,393,393,quadratic
"
// Java program to find n-th node of 
// Postorder Traversal of Binary Tree 
public
class
NthNodePostOrder { 


static
int
flag = 
0
; 


// function to find the N-th node in the postorder 

// traversal of a given binary tree 

public
static
void
NthPostordernode(Node root, 
int
N) 

{ 


if
(root == 
null
) 

return
; 


if
(flag <= N) 

{ 

// left recursion 

NthPostordernode(root.left, N); 

// right recursion 

NthPostordernode(root.right, N); 

flag++; 

// prints the n-th node of preorder traversal 

if
(flag == N) 

System.out.print(root.data); 

} 

} 



public
static
void
main(String args[]) { 

Node root = 
new
Node(
25
); 

root.left = 
new
Node(
20
); 

root.right = 
new
Node(
30
); 

root.left.left = 
new
Node(
18
); 

root.left.right = 
new
Node(
22
); 

root.right.left = 
new
Node(
24
); 

root.right.right = 
new
Node(
32
); 


int
N = 
6
; 


// prints n-th node found 

NthPostordernode(root, N); 

} 
} 

/* A binary tree node structure */
class
Node 
{ 

int
data; 

Node left, right; 

Node(
int
data) 

{ 

this
.data=data; 

} 
}; 
// This code is contributed by Gaurav Tiwari ",CorCod,84,84,linear
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.math.BigInteger;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author programajor
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        BigInteger mod = new BigInteger(""1000000007"");

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            BigInteger x = new BigInteger(in.next());
            BigInteger k = new BigInteger(in.next());
            if (x.longValue() == 0) {
                out.print(x);
                return;
            }
            BigInteger pow = powerWithMod(new BigInteger(""2""), k);
            BigInteger current = x.mod(mod).multiply(pow).mod(mod);
            BigInteger result = current.multiply(new BigInteger(""2"")).mod(mod)
                    .subtract(pow.subtract(new BigInteger(""1"")).mod(mod))
                    .mod(mod);
            out.print(result);
        }

        BigInteger powerWithMod(BigInteger base, BigInteger exponent) {
            if (exponent.longValue() == 0) {
                return new BigInteger(""1"");
            }
            BigInteger temp = powerWithMod(base, exponent.divide(new BigInteger(""2"")));
            BigInteger term = temp.mod(mod);
            if (exponent.mod(new BigInteger(""2"")).intValue() == 0) {
                return term.multiply(term.mod(mod)).mod(mod);
            } else {
                return term.multiply(term.mod(mod)).multiply(base.mod(mod)).mod(mod);
            }
        }

    }

    static class InputReader {
        private BufferedReader reader;
        private StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

    }
}

",CorCod,917,917,logn
"
// Java program to see if there is a root to leaf path 
// with given sequence. 
public
class
CheckForPath { 


// function to check given sequence of root to leaf path exist 

// in tree or not. 

// index represents current element in sequence of rooth to 

// leaf path 

public
static
boolean
existPath(Node root, 
int
arr[], 
int
index) 

{ 

// If root is NULL, then there must not be any element 

// in array. 

if
(root==
null
) 

{ 

return
arr.length==
0
; 

} 


// If this node is a leaf and matches with last entry 

// of array. 

if
((root.left==
null
&& root.right==
null
) && (root.data==arr[index] 

&& root.data==arr[arr.length-
1
])) 

{ 

return
true
; 

} 


// If current node is equal to arr[index] this means 

// that till this level path has been matched and 

// remaining path can be either in left subtree or 

// right subtree. 

return
(index<arr.length && (root.data==arr[index] && 

(existPath(root.left,arr,index+
1
) || 

existPath(root.right, arr, index+
1
)))); 

} 


public
static
void
main(String args[]) { 

// arr[] is sequence of root to leaf path 

int
arr[] = {
5
, 
8
, 
6
, 
7
}; 

Node root=
new
Node(
5
); 

root.left=
new
Node(
3
); 

root.right=
new
Node(
8
); 

root.left.left = 
new
Node(
2
); 

root.left.right = 
new
Node(
4
); 

root.left.left.left = 
new
Node(
1
); 

root.right.left = 
new
Node(
6
); 

root.right.left.right = 
new
Node(
7
); 


if
(existPath(root, arr, 
0
)) 

{ 

System.out.print(
""Path Exists""
); 

} 

else

{ 

System.out.print(
""Path does not Exist""
); 

} 

} 
} 

/* A binary tree node has data, pointer to left child 
and a pointer to right child */
class
Node 
{ 

int
data; 

Node left, right; 

Node(
int
data) 

{ 

this
.data=data; 

left=right=
null
; 

} 
}; 

// This code is contributed by Gaurav Tiwari ",CorCod,196,196,linear
"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Ideone
{
	static int check(int temp)
	{
		int count1 = 0; 
    while (temp>0) 
    { 
        if(temp % 2 != 0) 
        count1++; 
        temp/= 2; 
    } 
    return count1;
	}
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
		Scanner sc=new Scanner(System.in);
		String a=sc.next();
		String b=sc.next();
		int m=a.length();
		int n=b.length();
		int[] zero=new int[n];
		int[] one=new int[n];
		
		for(int i=0;i<n;i++)
		{
			if(i==0)
			{
				if(b.charAt(i)=='0')
				zero[i]++;
				else
				one[i]++;
			}
			else
			{
				zero[i]=zero[i-1];
				one[i]=one[i-1];
				if(b.charAt(i)=='0')
				zero[i]++;
				else
				one[i]++;
		    }
		}
		

		long res=0;
		for(int i=0;i<m;i++)
		{
		int x=n-m+i;
		if(a.charAt(i)=='0')
		res+=one[x];
		else
		res+=zero[x];
		if(i>0)
		{
			if(a.charAt(i)=='0')
			res-=one[i-1];
			else
			res-=zero[i-1];
		}
		}
		
		System.out.println(res);
	}
}",CorCod,339,339,linear
"import java.util.*;
import java.io.*;

public class _1036_B_DiagonalWalkingV2 {

	public static void main(String[] args) throws IOException {
		int Q = readInt();
		while(Q-- > 0) {
			long n = readLong(), m = readLong(), k = readLong();
			if(Math.max(n, m) > k) println(-1);
			else {
				long ans = k;
				if(n%2 != k%2) ans--;
				if(m%2 != k%2) ans--;
				println(ans);
			}
		}
		exit();
	}

	final private static int BUFFER_SIZE = 1 << 16;
	private static DataInputStream din = new DataInputStream(System.in);
	private static byte[] buffer = new byte[BUFFER_SIZE];
	private static int bufferPointer = 0, bytesRead = 0;
	static PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

	public static String readLine() throws IOException {
		byte[] buf = new byte[64]; // line length
		int cnt = 0, c;
		while ((c = Read()) != -1) {
			if (c == '\n')
				break;
			buf[cnt++] = (byte) c;
		}
		return new String(buf, 0, cnt);
	}

	public static String read() throws IOException {
		byte[] ret = new byte[1024];
		int idx = 0;
		byte c = Read();
		while (c <= ' ') {
			c = Read();
		}
		do {
			ret[idx++] = c;
			c = Read();
		} while (c != -1 && c != ' ' && c != '\n' && c != '\r');
		return new String(ret, 0, idx);
	}

	public static int readInt() throws IOException {
		int ret = 0;
		byte c = Read();
		while (c <= ' ')
			c = Read();
		boolean neg = (c == '-');
		if (neg)
			c = Read();
		do {
			ret = ret * 10 + c - '0';
		} while ((c = Read()) >= '0' && c <= '9');

		if (neg)
			return -ret;
		return ret;
	}

	public static long readLong() throws IOException {
		long ret = 0;
		byte c = Read();
		while (c <= ' ')
			c = Read();
		boolean neg = (c == '-');
		if (neg)
			c = Read();
		do {
			ret = ret * 10 + c - '0';
		} while ((c = Read()) >= '0' && c <= '9');
		if (neg)
			return -ret;
		return ret;
	}

	public static double readDouble() throws IOException {
		double ret = 0, div = 1;
		byte c = Read();
		while (c <= ' ')
			c = Read();
		boolean neg = (c == '-');
		if (neg)
			c = Read();

		do {
			ret = ret * 10 + c - '0';
		} while ((c = Read()) >= '0' && c <= '9');

		if (c == '.') {
			while ((c = Read()) >= '0' && c <= '9') {
				ret += (c - '0') / (div *= 10);
			}
		}

		if (neg)
			return -ret;
		return ret;
	}

	private static void fillBuffer() throws IOException {
		bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
		if (bytesRead == -1)
			buffer[0] = -1;
	}

	private static byte Read() throws IOException {
		if (bufferPointer == bytesRead)
			fillBuffer();
		return buffer[bufferPointer++];
	}

	static void print(Object o) {
		pr.print(o);
	}

	static void println(Object o) {
		pr.println(o);
	}

	static void flush() {
		pr.flush();
	}

	static void println() {
		pr.println();
	}

	static void exit() throws IOException {
		din.close();
		pr.close();
		System.exit(0);
	}
}
",CorCod,94,94,linear
"
// A Java program for in-place conversion of Binary Tree to DLL 

// A binary tree node has data, left pointers and right pointers 
class
Node 
{ 

int
data; 

Node left, right; 


public
Node(
int
data) 

{ 

this
.data = data; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root; 


// head --> Pointer to head node of created doubly linked list 

Node head; 


// Initialize previously visited node as NULL. This is 

// static so that the same value is accessible in all recursive 

// calls 

static
Node prev = 
null
; 


// A simple recursive function to convert a given Binary tree 

// to Doubly Linked List 

// root --> Root of Binary Tree 

void
BinaryTree2DoubleLinkedList(Node root) 

{ 

// Base case 

if
(root == 
null
) 

return
; 


// Recursively convert left subtree 

BinaryTree2DoubleLinkedList(root.left); 


// Now convert this node 

if
(prev == 
null
) 

head = root; 

else

{ 

root.left = prev; 

prev.right = root; 

} 

prev = root; 


// Finally convert right subtree 

BinaryTree2DoubleLinkedList(root.right); 

} 


/* Function to print nodes in a given doubly linked list */

void
printList(Node node) 

{ 

while
(node != 
null
) 

{ 

System.out.print(node.data + 
"" ""
); 

node = node.right; 

} 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

// Let us create the tree as shown in above diagram 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
10
); 

tree.root.left = 
new
Node(
12
); 

tree.root.right = 
new
Node(
15
); 

tree.root.left.left = 
new
Node(
25
); 

tree.root.left.right = 
new
Node(
30
); 

tree.root.right.left = 
new
Node(
36
); 


// convert to DLL 

tree.BinaryTree2DoubleLinkedList(tree.root); 


// Print the converted List 

tree.printList(tree.head); 


} 
} 
// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,148,148,linear
"
// Java program to find max value of i*arr[i] 

import
java.util.Arrays; 

class
Test 
{ 

static
int
arr[] = 
new
int
[]{
10
, 
1
, 
2
, 
3
, 
4
, 
5
, 
6
, 
7
, 
8
, 
9
}; 


// Returns max possible value of i*arr[i] 

static
int
maxSum() 

{ 

// Find array sum and i*arr[i] with no rotation 

int
arrSum = 
0
; 
// Stores sum of arr[i] 

int
currVal = 
0
; 
// Stores sum of i*arr[i] 

for
(
int
i=
0
; i<arr.length; i++) 

{ 

arrSum = arrSum + arr[i]; 

currVal = currVal+(i*arr[i]); 

} 


// Initialize result as 0 rotation sum 

int
maxVal = currVal; 


// Try all rotations one by one and find 

// the maximum rotation sum. 

for
(
int
j=
1
; j<arr.length; j++) 

{ 

currVal = currVal + arrSum-arr.length*arr[arr.length-j]; 

if
(currVal > maxVal) 

maxVal = currVal; 

} 


// Return result 

return
maxVal; 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

System.out.println(
""Max sum is ""
+ maxSum()); 

} 
} ",CorCod,338,338,linear
"		
							import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashSet;
import java.util.InputMismatchException;
											public class Solution1 implements Runnable
											{
												static final long MAX = 1000000007L;
												static class InputReader
												{
													private InputStream stream;
													private byte[] buf = new byte[1024];
													private int curChar;
													private int numChars;
													private SpaceCharFilter filter;
													private BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
											 
													public InputReader(InputStream stream)
													{
														this.stream = stream;
													}
													
													public int read()
													{
														if (numChars==-1) 
															throw new InputMismatchException();
														
														if (curChar >= numChars)
														{
															curChar = 0;
															try 
															{
																numChars = stream.read(buf);
															}
															catch (IOException e)
															{
																throw new InputMismatchException();
															}
															
															if(numChars <= 0)				
																return -1;
														}
														return buf[curChar++];
													}
												 
													public String nextLine()
													{
														String str = """";
											            try
											            {
											                str = br.readLine();
											            }
											            catch (IOException e)
											            {
											                e.printStackTrace();
											            }
											            return str;
													}
													public int nextInt()
													{
														int c = read();
														
														while(isSpaceChar(c)) 
															c = read();
														
														int sgn = 1;
														
														if (c == '-') 
														{
															sgn = -1;
															c = read();
														}
														
														int res = 0;
														do 
														{
															if(c<'0'||c>'9') 
																throw new InputMismatchException();
															res *= 10;
															res += c - '0';
															c = read();
														}
														while (!isSpaceChar(c)); 
														
														return res * sgn;
													}
													
													public long nextLong() 
													{
														int c = read();
														while (isSpaceChar(c))
															c = read();
														int sgn = 1;
														if (c == '-') 
														{
															sgn = -1;
															c = read();
														}
														long res = 0;
														
														do 
														{
															if (c < '0' || c > '9')
																throw new InputMismatchException();
															res *= 10;
															res += c - '0';
															c = read();
														}
														while (!isSpaceChar(c));
															return res * sgn;
													}
													
													public double nextDouble() 
													{
														int c = read();
														while (isSpaceChar(c))
															c = read();
														int sgn = 1;
														if (c == '-') 
														{
															sgn = -1;
															c = read();
														}
														double res = 0;
														while (!isSpaceChar(c) && c != '.') 
														{
															if (c == 'e' || c == 'E')
																return res * Math.pow(10, nextInt());
															if (c < '0' || c > '9')
																throw new InputMismatchException();
															res *= 10;
															res += c - '0';
															c = read();
														}
														if (c == '.') 
														{
															c = read();
															double m = 1;
															while (!isSpaceChar(c)) 
															{
																if (c == 'e' || c == 'E')
																	return res * Math.pow(10, nextInt());
																if (c < '0' || c > '9')
																	throw new InputMismatchException();
																m /= 10;
																res += (c - '0') * m;
																c = read();
															}
														}
														return res * sgn;
													}
													
													public String readString() 
													{
														int c = read();
														while (isSpaceChar(c))
															c = read();
														StringBuilder res = new StringBuilder();
														do 
														{
															res.appendCodePoint(c);
															c = read();
														} 
														while (!isSpaceChar(c));
														
														return res.toString();
													}
												 
													public boolean isSpaceChar(int c) 
													{
														if (filter != null)
															return filter.isSpaceChar(c);
														return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
													}
												 
													public String next() 
													{
														return readString();
													}
													
													public interface SpaceCharFilter 
													{
														public boolean isSpaceChar(int ch);
													}
												}
											 	
												public static void main(String args[]) throws Exception
												{
													new Thread(null, new Solution1(),""Solution1"",1<<26).start();
												}
												long gcd(long a, long b)
											    {
											        if (a == 0)
											            return b;
											         
											        return gcd(b%a, a);
											    }
											    // method to return LCM of two numbers
												 long lcm(long a, long b)
												    {
												        return (a*b)/gcd(a, b);
												    }
												 int root(int a){
													 while(arr[a] != a){
														 arr[a] = arr[arr[a]];
														 a = arr[a];
													 }
													 return a;
												 }
												 void union(int a,int b){
													 int xroot = root(a);
													 int yroot = root(b);
													 if(arr[xroot] < arr[yroot]){
														 arr[xroot] = yroot;
													 }else{
														 arr[yroot] = xroot;
													 }
												 }
												 boolean find(int a,int b){
													 int roota = root(a);
													 int rootb = root(b);
													 if(roota == rootb){
														 return true;
													 }else{
														 return false;
													 }
												 }
												 int[] arr;
												 final int level = 20;
												 
												public void run()
												{
													InputReader sc= new InputReader(System.in);
													PrintWriter w= new PrintWriter(System.out);
													int n = sc.nextInt();
													char[] ch = new char[n];
													char[] ch2 = new char[n];
													ch = sc.next().toCharArray();
													ch2 = sc.next().toCharArray();
													HashSet<Integer> hset[] = new HashSet[26];
													for(int i = 0;i < 26;i++){
														hset[i]  =new HashSet();
													}
													int count = 0;
													for(int i = 0;i < ch.length;i++){
														if(ch[i] != ch2[i]){
															hset[ch[i]-97].add(ch2[i]-97);
															count++;
														}
													}
													boolean flag = false;
													int swap1 = -1;
													int swap2 = -1;
													int rem = -1;
													for(int i = 0;i < ch.length;i++){
														if(ch[i] != ch2[i]){
															if(hset[ch2[i]-97].size() != 0){
																swap1 = i;
																flag = true;
																if(hset[ch2[i]-97].contains(ch[i]-97)){
																	rem = i;
																	count-=2;
																	flag = false;
																	break;
																}
															}
														}
													}
													if(flag){
														count--;
														w.println(count);
														for(int i = 0;i < n;i++){
															if(i != swap1 && ch[i] == ch2[swap1] && ch[i] != ch2[i]){
																w.println((swap1+1) + "" "" + (i+1));
																w.close();
																System.exit(0);
															}
														}
													}else{
														if(rem == -1){
															w.println(count);
															w.println(""-1 -1"");
														}else{
															w.println(count);
															for(int i = 0;i < n;i++){
																if(i != rem && ch[i] == ch2[rem] && ch[rem] == ch2[i] && ch[i] != ch2[i]){
																	w.println((rem+1) + "" "" + (i+1));
																	w.close();
																	System.exit(0);
																}
															}
														}
													}
													w.close();
												}
												boolean fun(long[] prefix,long mid,long temp,long[] arr){
													if(temp >= prefix[(int)mid]){
														return true;
													}
													return false;
												}
												static class Pair implements Comparable<Pair>{
													int x;
													int y;
													
													Pair(){}	
													Pair(int x,int y){
														this.x = x;
														this.y = y;
													
														
													}
													public int compareTo(Pair p){
														
														return Long.compare(this.x,p.x);
													}
												}
								}",CorCod,4,4,linear
"
// Java program to check children sum property 

/* A binary tree node has data, pointer to left child 

and a pointer to right child */
class
Node 
{ 

int
data; 

Node left, right; 


public
Node(
int
d) 

{ 

data = d; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root; 


/* returns 1 if children sum property holds for the given 

node and both of its children*/

int
isSumProperty(Node node) 

{ 


/* left_data is left child data and right_data is for right 

child data*/

int
left_data = 
0
, right_data = 
0
; 


/* If node is NULL or it's a leaf node then 

return true */

if
(node == 
null

|| (node.left == 
null
&& node.right == 
null
)) 

return
1
; 

else

{ 


/* If left child is not present then 0 is used 

as data of left child */

if
(node.left != 
null
) 

left_data = node.left.data; 


/* If right child is not present then 0 is used 

as data of right child */

if
(node.right != 
null
) 

right_data = node.right.data; 


/* if the node and both of its children satisfy the 

property return 1 else 0*/

if
((node.data == left_data + right_data) 

&& (isSumProperty(node.left)!=
0
) 

&& isSumProperty(node.right)!=
0
) 

return
1
; 

else

return
0
; 

} 

} 


/* driver program to test the above functions */

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
10
); 

tree.root.left = 
new
Node(
8
); 

tree.root.right = 
new
Node(
2
); 

tree.root.left.left = 
new
Node(
3
); 

tree.root.left.right = 
new
Node(
5
); 

tree.root.right.right = 
new
Node(
2
); 

if
(tree.isSumProperty(tree.root) != 
0
) 

System.out.println(
""The given tree satisfies children""

+ 
"" sum property""
); 

else

System.out.println(
""The given tree does not satisfy children""

+ 
"" sum property""
); 

} 
} ",CorCod,82,82,linear
"
// Java program to check if there exist an edge whose 
// removal creates two trees of same size 

class
Node 
{ 

int
key; 

Node left, right; 


public
Node(
int
key) 

{ 

this
.key = key; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root; 


// To calculate size of tree with given root 

int
count(Node node) 

{ 

if
(node == 
null
) 

return
0
; 


return
count(node.left) + count(node.right) + 
1
; 

} 


// This function returns true if there is an edge 

// whose removal can divide the tree in two halves 

// n is size of tree 

boolean
checkRec(Node node, 
int
n) 

{ 

// Base cases 

if
(node == 
null
) 

return
false
; 


// Check for root 

if
(count(node) == n - count(node)) 

return
true
; 


// Check for rest of the nodes 

return
checkRec(node.left, n) 

|| checkRec(node.right, n); 

} 


// This function mainly uses checkRec() 

boolean
check(Node node) 

{ 

// Count total nodes in given tree 

int
n = count(node); 


// Now recursively check all nodes 

return
checkRec(node, n); 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
5
); 

tree.root.left = 
new
Node(
1
); 

tree.root.right = 
new
Node(
6
); 

tree.root.left.left = 
new
Node(
3
); 

tree.root.right.left = 
new
Node(
7
); 

tree.root.right.right = 
new
Node(
4
); 

if
(tree.check(tree.root)==
true
) 

System.out.println(
""YES""
); 

else

System.out.println(
""NO""
); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,556,556,quadratic
"
// Java program for calculating LISS 
// using dynamic programming 

public
class
LisTree 
{ 

/* A binary tree node has data, pointer 

to left child and a pointer to right 

child */

static
class
node 

{ 

int
data, liss; 

node left, right; 


public
node(
int
data) 

{ 

this
.data = data; 

this
.liss = 
0
; 

} 

} 


// A memoization function returns size 

// of the largest independent set in 

// a given binary tree 

static
int
liss(node root) 

{ 

if
(root == 
null
) 

return
0
; 

if
(root.liss != 
0
) 

return
root.liss; 

if
(root.left == 
null
&& root.right == 
null
) 

return
root.liss = 
1
; 


// Calculate size excluding the 

// current node 

int
liss_excl = liss(root.left) + liss(root.right); 


// Calculate size including the 

// current node 

int
liss_incl = 
1
; 

if
(root.left != 
null
) 

{ 

liss_incl += (liss(root.left.left) + liss(root.left.right)); 

} 

if
(root.right != 
null
) 

{ 

liss_incl += (liss(root.right.left) + liss(root.right.right)); 

} 


// Maximum of two sizes is LISS, 

// store it for future uses. 

return
root.liss = Math.max(liss_excl, liss_incl); 

} 


public
static
void
main(String[] args) 

{ 

// Let us construct the tree given 

// in the above diagram 


node root = 
new
node(
20
); 

root.left = 
new
node(
8
); 

root.left.left = 
new
node(
4
); 

root.left.right = 
new
node(
12
); 

root.left.right.left = 
new
node(
10
); 

root.left.right.right = 
new
node(
14
); 

root.right = 
new
node(
22
); 

root.right.right = 
new
node(
25
); 

System.out.println(
""Size of the Largest Independent Set is ""
+ liss(root)); 

} 
} 

// This code is contributed by Rishabh Mahrsee ",CorCod,56,56,linear
"import java.io.*;
import java.util.*;

public class Main {
	static final int MAXN= 1005;
	static final long MOD =1_000_000_007;
	static final boolean DEBUG= false;
	static int  n, m;
	static long stlr[][]= new long[MAXN][MAXN],bell[]= new long[MAXN],occ[];
	static PrintStream cerr=System.err;
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Readin();
		stlr[0][0]= bell[0] =1;
		for (int i=1; i<=m; i++)
			for (int j=1;j<=i;j++) {
				stlr[i][j]= (stlr[i-1][j-1]+stlr[i-1][j]*(long)j)%MOD;
				bell[i]= (bell[i]+stlr[i][j])%MOD;
			}
		if (DEBUG)
			for (int i=1; i<=m; i++) cerr.println(""Bell[""+i+""] =""+bell[i]);
		Arrays.sort(occ);
		if (DEBUG) {
			cerr.println(""After Sorting"");
			for (int i=0;i<m; i++) cerr.println(occ[i]+"" "");}
		long ans=1;
		for (int i=0,j=0; i<m; i=j) {
			for (j=i+1; j<m && occ[i]==occ[j];j++);
			ans= (ans*bell[j-i])%MOD;
		}
		System.out.println(ans);
	}
	static void Readin() {
		Scanner  cin;
		if ( !DEBUG)cin= new Scanner(System.in);
		else {
			try {
				cin = new Scanner(new File(""input.txt""));
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				if ( DEBUG)cerr.println(""Not Fount input.txt"");
				return ;
			}
		}
		m = cin.nextInt(); n=cin.nextInt();
		occ= new long[m];
		for (int i=0; i<n; i++) {
			String s= cin.next();
			for (int j=0;j <m; j++)
				occ[j]|=((long)(s.charAt(j)-'0'))<<i;
		}
		cin.close();
	}
}
",CorCod,397,397,quadratic
"import java.util.*;
import java.lang.*;
import java.io.*;
public class TestClass {
    // function for finding size of set
    public static int set_size(int[] a, int N){
        HashSet <Integer> newset = new HashSet <Integer>();
        int i=0;
        while(i<N){
            newset.add(a[i++]);
        }
        int v = newset.size();
        return v;
    }
    public static void main(String args[] ) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
       StringTokenizer tk = new StringTokenizer(br.readLine());
            int N = Integer.parseInt(tk.nextToken());
            int x = Integer.parseInt(tk.nextToken());
            
            int[] a = new int[N];
            int[] b = new int[N];
            StringTokenizer tb = new StringTokenizer(br.readLine());
            for(int i=0; i<N; i++){
                a[i] = Integer.parseInt(tb.nextToken());
            }
            if(set_size(a, N) < N){
                System.out.print(""0"");
                System.exit(0);
            }
            int num=0;
        while(num++<4){
            for(int i=0; i<N; i++){
                if((a[i]&x) == a[i])
                    continue;
                else{
                    for(int j=0; j<N; j++){
                        if(i==j){
                            b[i] = (a[i]&x);
                        }
                        else{
                            b[j] = a[j];
                        }
                    }
                    int s = set_size(b, N);
                    if(s<N){
                        System.out.print(num);
                        System.exit(0);
                    }
                }
            }
            for(int i=0; i<N; i++)
                a[i] = b[i];
        }
        System.out.print(""-1"");
        System.exit(0);
    }
}",CorCod,446,446,quadratic
"import java.math.BigInteger;
import java.util.Scanner;

public class RENAMETHISBITCH {
		
	public static void main(String[] args) {
		
		try (Scanner sc = new Scanner(System.in)) {
			
			int n = sc.nextInt();
			BigInteger m = sc.nextBigInteger();
			
			System.out.println(m.mod(BigInteger.valueOf(2).pow(n)));
		}
		catch (Exception e) {
			e.printStackTrace();
		}
	}
}",CorCod,786,786,constant
"import java.io.*;


public class DS {

    /*
     * Complete the twoStacks function below.
     */
   



    public static void main(String[] args) throws IOException {
         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
       int x=Integer.parseInt(br.readLine());
         
if (x==1)
            System.out.println(-1);
else
            System.out.println(x+"" ""+x);

        }

        
    }",CorCod,797,797,constant
"
// Java program to find intersection of 
// two sorted arrays 

class
FindIntersection 
{ 

/* Function prints Intersection of arr1[] and arr2[] 

m is the number of elements in arr1[] 

n is the number of elements in arr2[] */

static
void
printIntersection(
int
arr1[], 
int
arr2[], 
int
m, 
int
n) 

{ 

int
i = 
0
, j = 
0
; 

while
(i < m && j < n) 

{ 

if
(arr1[i] < arr2[j]) 

i++; 

else
if
(arr2[j] < arr1[i]) 

j++; 

else

{ 

System.out.print(arr2[j++]+
"" ""
); 

i++; 

} 

} 

} 


public
static
void
main(String args[]) 

{ 

int
arr1[] = {
1
, 
2
, 
4
, 
5
, 
6
}; 

int
arr2[] = {
2
, 
3
, 
5
, 
7
}; 

int
m = arr1.length; 

int
n = arr2.length; 

printIntersection(arr1, arr2, m, n); 

} 
} ",CorCod,305,305,linear
"
// Java implementation to replace each node 
// in binary tree with the sum of its inorder 
// predecessor and successor 
import
java.util.*; 
class
Solution 
{ 

// node of a binary tree 
static
class
Node { 

int
data; 

Node left, right; 
} 

//INT class 
static
class
INT 
{ 

int
data; 
} 

// function to get a new node of a binary tree 
static
Node getNode(
int
data) 
{ 

// allocate node 

Node new_node =
new
Node(); 


// put in the data; 

new_node.data = data; 

new_node.left = new_node.right = 
null
; 


return
new_node; 
} 

// function to store the inorder traversal 
// of the binary tree in 'arr' 
static
void
storeInorderTraversal( Node root, 

Vector<Integer> arr) 
{ 

// if root is null 

if
(root==
null
) 

return
; 


// first recur on left child 

storeInorderTraversal(root.left, arr); 


// then store the root's data in 'arr' 

arr.add(root.data); 


// now recur on right child 

storeInorderTraversal(root.right, arr); 
} 

// function to replace each node with the sum of its 
// inorder predecessor and successor 
static
void
replaceNodeWithSum( Node root, 

Vector<Integer> arr, INT i) 
{ 

// if root is null 

if
(root==
null
) 

return
; 


// first recur on left child 

replaceNodeWithSum(root.left, arr, i); 


// replace node's data with the sum of its 

// inorder predecessor and successor 

root.data = arr.get(i.data - 
1
) + arr.get(i.data + 
1
); 


// move 'i' to point to the next 'arr' element 

i.data++; 


// now recur on right child 

replaceNodeWithSum(root.right, arr, i); 
} 

// Utility function to replace each node in binary 
// tree with the sum of its inorder predecessor 
// and successor 
static
void
replaceNodeWithSumUtil( Node root) 
{ 

// if tree is empty 

if
(root==
null
) 

return
; 


Vector<Integer> arr= 
new
Vector<Integer>(); 


// store the value of inorder predecessor 

// for the leftmost leaf 

arr.add(
0
); 


// store the inoder traversal of the tree in 'arr' 

storeInorderTraversal(root, arr); 


// store the value of inorder successor 

// for the rightmost leaf 

arr.add(
0
); 


// replace each node with the required sum 

INT i = 
new
INT(); 


i.data=
1
; 


replaceNodeWithSum(root, arr, i); 
} 

// function to print the preorder traversal 
// of a binary tree 
static
void
preorderTraversal( Node root) 
{ 

// if root is null 

if
(root==
null
) 

return
; 


// first print the data of node 

System.out.print( root.data + 
"" ""
); 


// then recur on left subtree 

preorderTraversal(root.left); 


// now recur on right subtree 

preorderTraversal(root.right); 
} 

// Driver program to test above 
public
static
void
main(String args[]) 
{ 

// binary tree formation 

Node root = getNode(
1
); 
// 1 

root.left = getNode(
2
); 
// / \ 

root.right = getNode(
3
); 
// 2 3 

root.left.left = getNode(
4
); 
// / \ / \ 

root.left.right = getNode(
5
); 
// 4 5 6 7 

root.right.left = getNode(
6
); 

root.right.right = getNode(
7
); 


System.out.println( 
""Preorder Traversal before tree modification:""
); 

preorderTraversal(root); 


replaceNodeWithSumUtil(root); 


System.out.println(
""\nPreorder Traversal after tree modification:""
); 

preorderTraversal(root); 

} 
} 
//contributed by Arnab Kundu ",CorCod,285,285,linear
"import java.util.*;

public class B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int x = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        Arrays.sort(a);
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(a[i]);
        }
        for (int i = 0; i < n - 1; i++) {
            if (a[i] == a[i + 1]) {
                System.out.println(0);
                return;
            }
        }
        for (int i = n - 1; i > 0; i--) {
            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {
                System.out.println(2);
                return;
            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {
                System.out.println(1);
                return;
            }
        }
        System.out.println(-1);
    }
}",CorCod,506,506,quadratic
"
// Java implementation for brute force method to calculate stock span values 

import
java.util.Arrays; 

class
GFG { 

// method to calculate stock span values 

static
void
calculateSpan(
int
price[], 
int
n, 
int
S[]) 

{ 

// Span value of first day is always 1 

S[
0
] = 
1
; 


// Calculate span value of remaining days by linearly checking 

// previous days 

for
(
int
i = 
1
; i < n; i++) { 

S[i] = 
1
; 
// Initialize span value 


// Traverse left while the next element on left is smaller 

// than price[i] 

for
(
int
j = i - 
1
; (j >= 
0
) && (price[i] >= price[j]); j--) 

S[i]++; 

} 

} 


// A utility function to print elements of array 

static
void
printArray(
int
arr[]) 

{ 

System.out.print(Arrays.toString(arr)); 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

int
price[] = { 
10
, 
4
, 
5
, 
90
, 
120
, 
80
}; 

int
n = price.length; 

int
S[] = 
new
int
[n]; 


// Fill the span values in array S[] 

calculateSpan(price, n, S); 


// print the calculated span values 

printArray(S); 

} 
} 
// This code is contributed by Sumit Ghosh ",CorCod,501,501,quadratic
"
// JAVA implementation of left rotation 
// of an array K number of times 
import
java.util.*; 
import
java.lang.*; 
import
java.io.*; 

class
arr_rot 
{ 

// Function to leftRotate array multiple 

// times 

static
void
leftRotate(
int
arr[], 
int
n, 

int
k) 

{ 

/* To get the starting point of 

rotated array */

int
mod = k % n; 


// Prints the rotated array from 

// start position 

for
(
int
i = 
0
; i < n; ++i) 

System.out.print(arr[(i + mod) % n] 

+ 
"" ""
); 


System.out.println(); 

} 


// Driver program 

public
static
void
main (String[] args) 

{ 

int
arr[] = { 
1
, 
3
, 
5
, 
7
, 
9
}; 

int
n = arr.length; 


int
k = 
2
; 

leftRotate(arr, n, k); 


k = 
3
; 

leftRotate(arr, n, k); 


k = 
4
; 

leftRotate(arr, n, k); 

} 
} 

// This code is contributed by Sanjal ",CorCod,100,100,linear
"/*
Roses are red
Memes are neat
All my test cases time out
Lmao yeet
*/
import java.util.*;
import java.io.*;

   public class A
   {
      public static void main(String args[]) throws Exception
      {
         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in)); 
         StringTokenizer st = new StringTokenizer(infile.readLine());
         int N = Integer.parseInt(st.nextToken());
         int L = Integer.parseInt(st.nextToken());
         int A = Integer.parseInt(st.nextToken());
         int[] arr1 = new int[N];
         int[] arr2 = new int[N];
         for(int i=0; i < N; i++)
         {
            st = new StringTokenizer(infile.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken())+x;
            arr1[i] = x;
            arr2[i] = y;
         }
         int res = 0;
         for(int i=1; i < N; i++)
            res += (arr1[i]-arr2[i-1])/A;
         if(N > 0)
            res += (L-arr2[N-1])/A+arr1[0]/A;
         else
            res += L/A;
         System.out.println(res);
      }
   }",CorCod,204,204,linear
"import java.io.*;
import java.math.*;
import java.text.*;
import java.util.*;
import java.util.regex.*;

public class DS {

    /*
     * Complete the twoStacks function below.
     */
   



    public static void main(String[] args) throws IOException {
         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
       int x=Integer.parseInt(br.readLine());
         
if (x==1)
            System.out.println(-1);
else
            System.out.println(x+"" ""+x);

        }

        
    }",CorCod,821,821,constant
"
// Java Program to find the maximum for each and every contiguous subarray of size k. 

public
class
GFG { 

// Method to find the maximum for each and every contiguous subarray of size k. 

static
void
printKMax(
int
arr[], 
int
n, 
int
k) 

{ 

int
j, max; 


for
(
int
i = 
0
; i <= n - k; i++) { 


max = arr[i]; 


for
(j = 
1
; j < k; j++) { 

if
(arr[i + j] > max) 

max = arr[i + j]; 

} 

System.out.print(max + 
"" ""
); 

} 

} 


// Driver method 

public
static
void
main(String args[]) 

{ 

int
arr[] = { 
1
, 
2
, 
3
, 
4
, 
5
, 
6
, 
7
, 
8
, 
9
, 
10
}; 

int
k = 
3
; 

printKMax(arr, arr.length, k); 

} 
} 

// This code is contributed by Sumit Ghosh ",CorCod,424,424,quadratic
"import java.util.*;

import java.lang.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.*;
 
public class Main {
        
    public static void main(String[] args) throws Exception{
        FastReader sc=new FastReader(); 
        OutputStream outputStream = System.out;
        PrintWriter out = new PrintWriter(outputStream);
        int n=sc.nextInt();
        int[] font=new int[n];
        int[] cost=new int[n];
        for(int i=0;i<n;i++) {
            font[i]=sc.nextInt();
        
        }
        for(int i=0;i<n;i++) {
            cost[i]=sc.nextInt();
        }
        int[] dou= new int[n];
        for(int i=0;i<n;i++) {
            int min=Integer.MAX_VALUE;
            for(int j=0;j<i;j++) {
                if(font[j]<font[i]) {
                    if(min>cost[i]+cost[j]) {
                        min=cost[i]+cost[j];
                    }
                }
            }
            dou[i]=min;
        }
        int ans=Integer.MAX_VALUE;
        for(int i=0;i<n;i++) {
            int min=Integer.MAX_VALUE;
            for(int j=0;j<i;j++) {
                if(dou[j]!=Integer.MAX_VALUE && font[j]<font[i]) {
                    if(min>dou[j]+cost[i]) {
                        min=dou[j]+cost[i];
                    }
                }
            }
            if(min<ans) {
                ans=min;
            }
        }
        if(ans==Integer.MAX_VALUE) {
            System.out.println(-1);
        }
        else {
            System.out.println(ans);
        }
    }
}

class FastReader 
{ 
    BufferedReader br; 
    StringTokenizer st; 
 
    public FastReader() 
    { 
        br = new BufferedReader(new
                 InputStreamReader(System.in)); 
    } 
 
    String next() 
    { 
        while (st == null || !st.hasMoreElements()) 
        { 
            try
            { 
                st = new StringTokenizer(br.readLine()); 
            } 
            catch (IOException  e) 
            { 
                e.printStackTrace(); 
            } 
        } 
        return st.nextToken(); 
    } 
 
    int nextInt() 
    { 
        return Integer.parseInt(next()); 
    } 
 
    long nextLong() 
    { 
        return Long.parseLong(next()); 
    } 
 
    double nextDouble() 
    { 
        return Double.parseDouble(next()); 
    } 
 
    String nextLine() 
    { 
        String str = """"; 
        try
        { 
            str = br.readLine(); 
        } 
        catch (IOException e) 
        { 
            e.printStackTrace(); 
        } 
        return str; 
    } 
} ",CorCod,411,411,quadratic
"import java.util.*;

public class vas2 {
    public static void main( String[] args ) {
	Scanner in = new Scanner( System.in );
	int n = in.nextInt();
	String st = in.next();
	int[] a = new int[n];
	for ( int i = 0; i < n; i++ )
	    a[i] = st.charAt( i ) - 48;
	boolean c = false;
	for ( int i = 1; !c && i < n; i++ ) {
	    int s = 0;
	    for ( int j = 0; j < i; j++ )
		s += a[j];
	    int t = 0;
	    for ( int j = i; j < n; j++ ) {
		t += a[j];
		if ( t > s )
		    if ( t - a[j] != s )
			break;
		    else
			t = a[j];
	    }
	    if ( t == s )
		c = true;
	}
	System.out.println( c ? ""YES"" : ""NO"" );
    }
}
",CorCod,449,449,quadratic
"
import
java.util.*; 
import
java.lang.*; 
class
Main 
{ 

static
void
minAbsSumPair(
int
arr[], 
int
arr_size) 

{ 

int
inv_count = 
0
; 

int
l, r, min_sum, sum, min_l, min_r; 


/* Array should have at least two elements*/

if
(arr_size < 
2
) 

{ 

System.out.println(
""Invalid Input""
); 

return
; 

} 


/* Initialization of values */

min_l = 
0
; 

min_r = 
1
; 

min_sum = arr[
0
] + arr[
1
]; 


for
(l = 
0
; l < arr_size - 
1
; l++) 

{ 

for
(r = l+
1
; r < arr_size; r++) 

{ 

sum = arr[l] + arr[r]; 

if
(Math.abs(min_sum) > Math.abs(sum)) 

{ 

min_sum = sum; 

min_l = l; 

min_r = r; 

} 

} 

} 


System.out.println(
"" The two elements whose ""
+ 

""sum is minimum are ""
+ 

arr[min_l]+ 
"" and ""
+arr[min_r]); 

} 


// main function 

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
60
, -
10
, 
70
, -
80
, 
85
}; 

minAbsSumPair(arr, 
6
); 

} 

} ",CorCod,560,560,quadratic
"
// Java program to find maximum sum 
// of all rotation of i*arr[i] using pivot. 

import
java.util.*; 
import
java.lang.*; 
import
java.io.*; 

class
GFG 
{ 

// function definition 
static
int
maxSum(
int
arr[], 
int
n) 
{ 

int
sum = 
0
; 

int
i; 

int
pivot = findPivot(arr, n); 


// difference in pivot and index of 

// last element of array 

int
diff = n - 
1
- pivot; 

for
(i = 
0
; i < n; i++) 

{ 

sum= sum + ((i + diff) % n) * arr[i]; 

} 

return
sum; 
} 

// function to find pivot 
static
int
findPivot(
int
arr[], 
int
n) 
{ 

int
i; 

for
(i = 
0
; i < n; i++) 

{ 

if
(arr[i] > arr[(i + 
1
) % n]) 

return
i; 

} 

return
0
; 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

// rotated input array 

int
arr[] = {
8
, 
3
, 
1
, 
2
}; 

int
n = arr.length; 

int
max = maxSum(arr,n); 

System.out.println(max); 

} 
} ",CorCod,373,373,linear
"
/* Java program to flip a binary tree */
import
java.util.Queue; 
import
java.util.LinkedList; 
public
class
FlipTree { 


// method to flip the binary tree 

public
static
Node flipBinaryTree(Node root) 

{ 

if
(root == 
null
) 

return
root; 

if
(root.left == 
null
&& root.right ==
null
) 

return
root; 


// recursively call the same method 

Node flippedRoot=flipBinaryTree(root.left); 


// rearranging main root Node after returning 

// from recursive call 

root.left.left=root.right; 

root.left.right=root; 

root.left=root.right=
null
; 

return
flippedRoot; 

} 


// Iterative method to do level order traversal 

// line by line 

public
static
void
printLevelOrder(Node root) 

{ 

// Base Case 

if
(root==
null
) 

return
; 


// Create an empty queue for level order traversal 

Queue<Node> q=
new
LinkedList<>(); 

// Enqueue Root and initialize height 

q.add(root); 

while
(
true
) 

{ 

// nodeCount (queue size) indicates number 

// of nodes at current lelvel. 

int
nodeCount = q.size(); 

if
(nodeCount == 
0
) 

break
; 


// Dequeue all nodes of current level and 

// Enqueue all nodes of next level 

while
(nodeCount > 
0
) 

{ 

Node node = q.remove(); 

System.out.print(node.data+
"" ""
); 

if
(node.left != 
null
) 

q.add(node.left); 

if
(node.right != 
null
) 

q.add(node.right); 

nodeCount--; 

} 

System.out.println(); 

} 

} 


public
static
void
main(String args[]) { 

Node root=
new
Node(
1
); 

root.left=
new
Node(
2
); 

root.right=
new
Node(
1
); 

root.right.left = 
new
Node(
4
); 

root.right.right = 
new
Node(
5
); 

System.out.println(
""Level order traversal of given tree""
); 

printLevelOrder(root); 


root = flipBinaryTree(root); 

System.out.println(
""Level order traversal of flipped tree""
); 

printLevelOrder(root); 

} 
} 

/* A binary tree node structure */
class
Node 
{ 

int
data; 

Node left, right; 

Node(
int
data) 

{ 

this
.data=data; 

} 
}; 
//This code is contributed by Gaurav Tiwari ",CorCod,138,138,linear
"
// Java program to find inorder successor of a node 
class
Solution 
{ 
// A Binary Tree Node 

static
class
Node 
{ 

int
data; 

Node left, right; 
} 

// Temporary node for case 2 
static
Node temp = 
new
Node(); 

// Utility function to create a new tree node 
static
Node newNode(
int
data) 

{ 

Node temp = 
new
Node(); 

temp.data = data; 

temp.left = temp.right = 
null
; 

return
temp; 
} 

// function to find left most node in a tree 
static
Node leftMostNode(Node node) 

{ 

while
(node != 
null
&& node.left != 
null
) 

node = node.left; 

return
node; 
} 

// function to find right most node in a tree 
static
Node rightMostNode(Node node) 

{ 

while
(node != 
null
&& node.right != 
null
) 

node = node.right; 

return
node; 
} 

// recursive function to find the Inorder Scuccessor 
// when the right child of node x is null 
static
Node findInorderRecursive(Node root, Node x ) 

{ 

if
(root==
null
) 

return
null
; 


if
(root==x || (temp = findInorderRecursive(root.left,x))!=
null
|| 

(temp = findInorderRecursive(root.right,x))!=
null
) 

{ 

if
(temp!=
null
) 

{ 

if
(root.left == temp) 

{ 

System.out.print( 
""Inorder Successor of ""
+x.data); 

System.out.print( 
"" is ""
+ root.data + 
""\n""
); 

return
null
; 

} 

} 


return
root; 

} 


return
null
; 
} 

// function to find inorder successor of 
// a node 
static
void
inorderSuccesor(Node root, Node x) 

{ 

// Case1: If right child is not null 

if
(x.right != 
null
) 

{ 

Node inorderSucc = leftMostNode(x.right); 

System.out.print(
""Inorder Successor of ""
+x.data+
"" is ""
); 

System.out.print(inorderSucc.data+
""\n""
); 

} 


// Case2: If right child is null 

if
(x.right == 
null
) 

{ 

int
f = 
0
; 


Node rightMost = rightMostNode(root); 


// case3: If x is the right most node 

if
(rightMost == x) 

System.out.print(
""No inorder successor! Right most node.\n""
); 

else

findInorderRecursive(root, x); 

} 
} 

// Driver program to test above functions 
public
static
void
main(String args[]) 
{ 

// Let's con the binary tree 

// as shown in above diagram 


Node root = newNode(
1
); 

root.left = newNode(
2
); 

root.right = newNode(
3
); 

root.left.left = newNode(
4
); 

root.left.right = newNode(
5
); 

root.right.right = newNode(
6
); 


// Case 1 

inorderSuccesor(root, root.right); 


// case 2 

inorderSuccesor(root, root.left.left); 


// case 3 

inorderSuccesor(root, root.right.right); 

} 
} 
//contributed by Arnab Kundu ",CorCod,297,297,linear
"
// Java program to check if there is a subset 
// with sum divisible by m. 
import
java.util.Arrays; 

class
GFG { 


// Returns true if there is a subset 

// of arr[] with sum divisible by m 

static
boolean
modularSum(
int
arr[], 

int
n, 
int
m) 

{ 

if
(n > m) 

return
true
; 


// This array will keep track of all 

// the possible sum (after modulo m) 

// which can be made using subsets of arr[] 

// initialising boolean array with all false 

boolean
DP[]=
new
boolean
[m]; 


Arrays.fill(DP, 
false
); 


// we'll loop through all the elements 

// of arr[] 

for
(
int
i = 
0
; i < n; i++) 

{ 


// anytime we encounter a sum divisible 

// by m, we are done 

if
(DP[
0
]) 

return
true
; 


// To store all the new encountered sum 

// (after modulo). It is used to make 

// sure that arr[i] is added only to 

// those entries for which DP[j] 

// was true before current iteration. 

boolean
temp[] = 
new
boolean
[m]; 

Arrays.fill(temp, 
false
); 


// For each element of arr[], we loop 

// through all elements of DP table 

// from 1 to m and we add current 

// element i. e., arr[i] to all those 

// elements which are true in DP table 

for
(
int
j = 
0
; j < m; j++) 

{ 


// if an element is true in 

// DP table 

if
(DP[j] == 
true
) 

{ 

if
(DP[(j + arr[i]) % m] == 
false
) 


// We update it in temp and update 

// to DP once loop of j is over 

temp[(j + arr[i]) % m] = 
true
; 

} 

} 


// Updating all the elements of temp 

// to DP table since iteration over 

// j is over 

for
(
int
j = 
0
; j < m; j++) 

if
(temp[j]) 

DP[j] = 
true
; 



// Also since arr[i] is a single 

// element subset, arr[i]%m is one 

// of the possible sum 

DP[arr[i] % m] = 
true
; 

} 


return
DP[
0
]; 

} 


//driver code 

public
static
void
main(String arg[]) 

{ 

int
arr[] = {
1
, 
7
}; 

int
n = arr.length; 

int
m = 
5
; 


if
(modularSum(arr, n, m)) 

System.out.print(
""YES\n""
); 

else

System.out.print(
""NO\n""
); 

} 
} 

//This code is contributed by Anant Agarwal. ",CorCod,505,505,quadratic
"

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.PriorityQueue;

public class LessorEqual_CodeForces {
	
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String temp[]=br.readLine().split("" "");
		int n = Integer.parseInt(temp[0]);
		int k = Integer.parseInt(temp[1]);
		temp=br.readLine().split("" "");
		int [] num = new int[n];
//		int [] freq = new int [1000000000];
		PriorityQueue<Integer>pq = new PriorityQueue<Integer>();  
		for(int i=0;i<n;i++){
			num[i]=Integer.parseInt(temp[i]);
			pq.add(num[i]);
		//	freq[num[i]]++;
						
		}
		if(k==0){
			int y= pq.poll();
			if(y==1){
				System.out.println(-1);
				System.exit(0);
			}
			else 
				{
				System.out.println(y-1);
				System.exit(0);
			}
				
		}
		
		//System.out.println(pq);
		int count=0;
		int max=0;
		while (!pq.isEmpty()){
			int x = pq.poll();
			while(count<=k&&!pq.isEmpty()&& pq.peek()==x){
				pq.poll();
				count++;
			}
		//	System.out.println(x);
			count++;
			max=x;
			if(count==k)
				break;
		}
		
		//System.out.println(""the count is ""+ count);
		if(count==k){
			if(!pq.contains(max+1)&& max<1e9)
				System.out.println(max+1);
			else 
				System.out.println(max);
			}
		else 
			System.out.println(-1);
 
		
	}

}
",CorCod,677,677,nlogn
"
// Java program to print the array in given order 
import
java.util.Arrays; 

public
class
GFG { 


// Function which arrange the array. 

static
void
rearrangeArray(
int
arr[], 
int
n) 

{ 

// Sorting the array elements 

Arrays.sort(arr); 


int
[] tempArr = 
new
int
[n]; 
// To store modified array 


// Adding numbers from sorted array to 

// new array accordingly 

int
ArrIndex = 
0
; 


// Traverse from begin and end simultaneously 

for
(
int
i = 
0
, j = n-
1
; i <= n / 
2
|| j > n / 
2
; 

i++, j--) { 

if
(ArrIndex < n) 

{ 

tempArr[ArrIndex] = arr[i]; 

ArrIndex++; 

} 


if
(ArrIndex < n) 

{ 

tempArr[ArrIndex] = arr[j]; 

ArrIndex++; 

} 

} 


// Modifying original array 

for
(
int
i = 
0
; i < n; i++) 

arr[i] = tempArr[i]; 

} 


// Driver Code 

public
static
void
main(String args[]) 

{ 

int
arr[] = { 
5
, 
8
, 
1
, 
4
, 
2
, 
9
, 
3
, 
7
, 
6
}; 

int
n = arr.length; 

rearrangeArray(arr, n); 


for
(
int
i = 
0
; i < n; i++) 

System.out.print(arr[i]+
"" ""
); 

} 
} 
// This code is contributed by Sumit Ghosh ",CorCod,592,592,nlogn
"
// Program to find minimum 
// total offerings required 
import
java.io.*; 

class
GFG 
{ 

// Returns minimum 
// offerings required 
static
int
offeringNumber(
int
n, 

int
templeHeight[]) 
{ 

int
sum = 
0
; 
// Initialize result 


// Go through all 

// temples one by one 

for
(
int
i = 
0
; i < n; ++i) 

{ 

// Go to left while 

// height keeps increasing 

int
left = 
0
, right = 
0
; 

for
(
int
j = i - 
1
; j >= 
0
; --j) 

{ 

if
(templeHeight[j] < 

templeHeight[j + 
1
]) 

++left; 

else

break
; 

} 


// Go to right while 

// height keeps increasing 

for
(
int
j = i + 
1
; j < n; ++j) 

{ 

if
(templeHeight[j] < 

templeHeight[j - 
1
]) 

++right; 

else

break
; 

} 


// This temple should offer 

// maximum of two values 

// to follow the rule. 

sum += Math.max(right, left) + 
1
; 

} 


return
sum; 
} 

// Driver code 
public
static
void
main (String[] args) 
{ 
int
arr1[] = {
1
, 
2
, 
2
}; 
System.out.println(offeringNumber(
3
, arr1)); 
int
arr2[] = {
1
, 
4
, 
3
, 

6
, 
2
, 
1
}; 
System.out.println(offeringNumber(
6
, arr2)); 
} 
} 

// This code is contributed by akt_mit ",CorCod,428,428,quadratic
"
// Java program to construct binary tree from 
// given array in level order fashion 

public
class
Tree { 

Node root; 


// Tree Node 

static
class
Node { 

int
data; 

Node left, right; 

Node(
int
data) 

{ 

this
.data = data; 

this
.left = 
null
; 

this
.right = 
null
; 

} 

} 


// Function to insert nodes in level order 

public
Node insertLevelOrder(
int
[] arr, Node root, 

int
i) 

{ 

// Base case for recursion 

if
(i < arr.length) { 

Node temp = 
new
Node(arr[i]); 

root = temp; 


// insert left child 

root.left = insertLevelOrder(arr, root.left, 

2
* i + 
1
); 


// insert right child 

root.right = insertLevelOrder(arr, root.right, 

2
* i + 
2
); 

} 

return
root; 

} 


// Function to print tree nodes in InOrder fashion 

public
void
inOrder(Node root) 

{ 

if
(root != 
null
) { 

inOrder(root.left); 

System.out.print(root.data + 
"" ""
); 

inOrder(root.right); 

} 

} 


// Driver program to test above function 

public
static
void
main(String args[]) 

{ 

Tree t2 = 
new
Tree(); 

int
arr[] = { 
1
, 
2
, 
3
, 
4
, 
5
, 
6
, 
6
, 
6
, 
6
}; 

t2.root = t2.insertLevelOrder(arr, t2.root, 
0
); 

t2.inOrder(t2.root); 

} 
} ",CorCod,34,34,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class SFly {

	public static void main(String[] args) throws IOException {
		
		BufferedReader lector = new BufferedReader(new InputStreamReader(System.in));
		int planet = Integer.parseInt(lector.readLine());
		int ini = Integer.parseInt(lector.readLine());
		double peso = ini;
		int[] desp = new int[planet];
		int[] ater = new int[planet];
		String[] temp = lector.readLine().split("" "");		
		for(int i=0; i<planet; i++) {
			desp[i] = Integer.parseInt(temp[i]);
			if(desp[i] == 1) {
				System.out.println(-1);
				lector.close();
				return;
			}
		}
		temp = lector.readLine().split("" "");		
		for(int i=0; i<planet; i++) {
			ater[i] = Integer.parseInt(temp[i]);
			if(ater[i] == 1) {
				System.out.println(-1);
				lector.close();
				return;
			}
		}
		temp = null;
		int i=planet-1;
		peso = (peso*ater[0])/(ater[0]-1);
		while(i>0) {
			peso = (peso*desp[i])/(desp[i]-1);
			peso = (peso*ater[i])/(ater[i]-1);
			i--;
		}
		peso = (peso*desp[0])/(desp[0]-1);
		peso = peso - ini;
		System.out.println(peso);
		lector.close();
	}
}",CorCod,20,20,linear
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;
import java.util.function.Function;

public class P1196D2 {

    static boolean multipleIndependent = true;

    void run() {
        int n = in.nextInt();
        int k = in.nextInt();
        char[] s = in.next().toCharArray();
        int[] dp = new int[3];
        char[] c = {'R', 'G', 'B'};
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < k; i++) {
            dp[0] += s[i] == c[(i + 0) % 3] ? 0 : 1;
            dp[1] += s[i] == c[(i + 1) % 3] ? 0 : 1;
            dp[2] += s[i] == c[(i + 2) % 3] ? 0 : 1;
        }
        min = Math.min(Math.min(Math.min(dp[0], dp[1]), dp[2]), min);
//        System.out.println(Arrays.toString(dp));
        for (int i = k; i < n; i++) {
            dp[0] += (s[i] == c[(i + 0) % 3] ? 0 : 1) - (s[i - k] == c[(i - k + 0) % 3] ? 0 : 1);
            dp[1] += (s[i] == c[(i + 1) % 3] ? 0 : 1) - (s[i - k] == c[(i - k + 1) % 3] ? 0 : 1);
            dp[2] += (s[i] == c[(i + 2) % 3] ? 0 : 1) - (s[i - k] == c[(i - k + 2) % 3] ? 0 : 1);
            min = Math.min(Math.min(Math.min(dp[0], dp[1]), dp[2]), min);
//            System.out.println(Arrays.toString(dp));
        }
        System.out.println(min);
    }


    /* -----: Template :----- */
    static InputReader in = new InputReader(System.in);

    public static void main(String[] args) {
        P1196D2 p = new P1196D2();
        int q = multipleIndependent ? in.nextInt() : 1;
        while (q-- > 0) {
            p.run();
        }
    }

    int numLength(long n) {
        int l = 0;
        while (n > 0) {
            n /= 10;
            l++;
        }
        return l;
    }

    <R> long binarySearch(long lowerBound, long upperBound,
            R value, Function<Long, R> generatorFunction, Comparator<R> comparator) {
        if (lowerBound <= upperBound) {
            long mid = (lowerBound + upperBound) / 2;
            int compare = comparator.compare(generatorFunction.apply(mid), value);
            if (compare == 0) {
                return mid;
            } else if (compare < 0) {
                return binarySearch(mid + 1, upperBound, value, generatorFunction, comparator);
            } else {
                return binarySearch(lowerBound, mid - 1, value, generatorFunction, comparator);
            }
        } else {
            return -1;
        }
    }

    <T> Integer[] sortSimultaneously(T[] key, Comparator<T> comparator,
            Object[]... moreArrays) {
        int n = key.length;
        for (Object[] array : moreArrays) {
            if (array.length != n) {
                throw new RuntimeException(""Arrays must have equals lengths"");
            }
        }
        Integer[] indices = new Integer[n];
        for (int i = 0; i < n; i++) {
            indices[i] = i;
        }
        Comparator<Integer> delegatingComparator = (a, b) -> {
            return comparator.compare(key[a], key[b]);
        };
        Arrays.sort(indices, delegatingComparator);
        reorder(indices, key);
        for (Object[] array : moreArrays) {
            reorder(indices, array);
        }
        return indices;
    }

    void reorder(Integer[] indices, Object[] arr) {
        if (indices.length != arr.length) {
            throw new RuntimeException(""Arrays must have equals lengths"");
        }
        int n = arr.length;
        Object[] copy = new Object[n];
        for (int i = 0; i < n; i++) {
            copy[i] = arr[indices[i]];
        }
        System.arraycopy(copy, 0, arr, 0, n);
    }

    int prodMod(int a, int b, int mod) {
        return (int) (((long) a) * b % mod);
    }

    long prodMod(long a, long b, long mod) {
        long res = 0;
        a %= mod;
        b %= mod;
        while (b > 0) {
            if ((b & 1) > 0) {
                res = (res + a) % mod;
            }
            a = (a << 1) % mod;
            b >>= 1;
        }
        return res;
    }

    long sumMod(int[] b, long mod) {
        long res = 0;
        for (int i = 0; i < b.length; i++) {
            res = (res + b[i] % mod) % mod;
        }
        return res;
    }

    long sumMod(long[] a, long mod) {
        long res = 0;
        for (int i = 0; i < a.length; i++) {
            res = (res + a[i] % mod) % mod;
        }
        return res;
    }

    long sumProdMod(int[] a, long b, long mod) {
        long res = sumMod(a, mod);
        return prodMod(res, b, mod);
    }

    long sumProdMod(long[] a, long b, long mod) {
        long res = sumMod(a, mod);
        return prodMod(res, b, mod);
    }

    long sumProdMod(int[] a, int[] b, long mod) {
        if (a.length != b.length) {
            throw new RuntimeException(""Arrays must have equals lengths"");
        }
        long res = 0;
        for (int i = 0; i < a.length; i++) {
            res = (res + prodMod(a[i], b[i], mod)) % mod;
        }
        return res;
    }

    long sumProdMod(long[] a, long[] b, long mod) {
        if (a.length != b.length) {
            throw new RuntimeException(""Arrays must have equals lengths"");
        }
        long res = 0;
        for (int i = 0; i < a.length; i++) {
            res = (res + prodMod(a[i], b[i], mod)) % mod;
        }
        return res;
    }

    int[] toPrimitive(Integer[] arr) {
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    int[][] toPrimitive(Integer[][] arr) {
        int[][] res = new int[arr.length][];
        for (int i = 0; i < arr.length; i++) {
            res[i] = toPrimitive(arr[i]);
        }
        return res;
    }

    long[] toPrimitive(Long[] arr) {
        long[] res = new long[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    long[][] toPrimitive(Long[][] arr) {
        long[][] res = new long[arr.length][];
        for (int i = 0; i < arr.length; i++) {
            res[i] = toPrimitive(arr[i]);
        }
        return res;
    }

    Integer[] toWrapper(int[] arr) {
        Integer[] res = new Integer[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    Integer[][] toWrapper(int[][] arr) {
        Integer[][] res = new Integer[arr.length][];
        for (int i = 0; i < arr.length; i++) {
            res[i] = toWrapper(arr[i]);
        }
        return res;
    }

    Long[] toWrapper(long[] arr) {
        Long[] res = new Long[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    Long[][] toWrapper(long[][] arr) {
        Long[][] res = new Long[arr.length][];
        for (int i = 0; i < arr.length; i++) {
            res[i] = toWrapper(arr[i]);
        }
        return res;
    }

    static class InputReader {

        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int[] nextIntArray(int n) {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = nextInt();
            }
            return arr;
        }

        public <T> T[] nextIntArray(int n, Function<Integer, T> function, Class<T> c) {
            T[] arr = (T[]) Array.newInstance(c, n);
            for (int i = 0; i < n; i++) {
                arr[i] = function.apply(nextInt());
            }
            return arr;
        }

        public long[] nextLongArray(int n) {
            long[] arr = new long[n];
            for (int i = 0; i < n; i++) {
                arr[i] = nextLong();
            }
            return arr;
        }

        public <T> T[] nextLongArray(int n, Function<Long, T> function, Class<T> c) {
            T[] arr = (T[]) Array.newInstance(c, n);
            for (int i = 0; i < n; i++) {
                arr[i] = function.apply(nextLong());
            }
            return arr;
        }

        public int[][] nextIntMap(int n, int m) {
            int[][] map = new int[n][m];
            for (int i = 0; i < n; i++) {
                map[i] = nextIntArray(m);
            }
            return map;
        }

        public long[][] nextLongMap(int n, int m) {
            long[][] map = new long[n][m];
            for (int i = 0; i < n; i++) {
                map[i] = nextLongArray(m);
            }
            return map;
        }

        public char[][] nextCharMap(int n) {
            char[][] map = new char[n][];
            for (int i = 0; i < n; i++) {
                map[i] = next().toCharArray();
            }
            return map;
        }

        public void readColumns(Object[]... columns) {
            int n = columns[0].length;
            for (Object[] column : columns) {
                if (column.length != n) {
                    throw new RuntimeException(""Arrays must have equals lengths"");
                }
            }
            for (int i = 0; i < n; i++) {
                for (Object[] column : columns) {
                    column[i] = read(column[i].getClass());
                }
            }
        }

        public <T> T read(Class<T> c) {
            throw new UnsupportedOperationException(""To be implemented"");
        }

    }

}
",CorCod,543,543,quadratic
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class LightItUp {

	public static void main(String[] args) throws IOException {
		 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		 StringTokenizer st = new StringTokenizer(br.readLine());
		
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		int previous = 0;
		int array[] = new int[n+1];
		int answer = 0;
		
		StringTokenizer st1 = new StringTokenizer(br.readLine());
		for(int i = 0; i < n; i++){
			array[i] = Integer.parseInt(st1.nextToken());
			if(i % 2 == 0){
				answer += (array[i] - previous);
			}
			previous = array[i];
		}
		
		if(n % 2 == 0){
			answer += (m - previous);
		}
		previous = m;
		int max = Integer.MAX_VALUE;
		
		while(n-- != 0){
			int temp = array[n];
			if(n%2 == 0){
				array[n] = array[n+1] - (previous - array[n]);
			}
			else{
				array[n] = array[n+1] + (previous - array[n]);
			}
			previous = temp;
			max = Math.min(max, array[n]);
		}
		if(max>=-1){
			System.out.println(answer);
		}
		else{
			System.out.println(answer - (max+1));
		}

	}

}
",CorCod,247,247,linear
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in Actual solution is at the top
 *
 * @author @Ziklon
 */
public class Main {
  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    InputReader in = new InputReader(inputStream);
    OutputWriter out = new OutputWriter(outputStream);
    ABirthday solver = new ABirthday();
    solver.solve(1, in, out);
    out.close();
  }

  static class ABirthday {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
      long N = in.readLong(), M = in.readLong(), K = in.readLong(), L = in.readLong();

      long ans = ((L + K) - 1) / M + 1;
      if (ans * M > N || ans * M - K < L) out.printLine(-1);
      else out.printLine(ans);
    }
  }

  static class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void close() {
      writer.close();
    }

    public void printLine(long i) {
      writer.println(i);
    }

    public void printLine(int i) {
      writer.println(i);
    }
  }

  static class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private InputReader.SpaceCharFilter filter;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) {
        throw new InputMismatchException();
      }
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new InputMismatchException();
        }
        if (numChars <= 0) {
          return -1;
        }
      }
      return buf[curChar++];
    }

    public long readLong() {
      int c = read();
      while (isSpaceChar(c)) {
        c = read();
      }
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      long res = 0;
      do {
        if (c < '0' || c > '9') {
          throw new InputMismatchException();
        }
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      if (filter != null) {
        return filter.isSpaceChar(c);
      }
      return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
      return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public interface SpaceCharFilter {
      public boolean isSpaceChar(int ch);
    }
  }
}
",CorCod,741,741,constant
"
// Java program to print a given matrix in spiral form 
import
java.io.*; 

class
GFG { 

// Function print matrix in spiral form 

static
void
spiralPrint(
int
m, 
int
n, 
int
a[][]) 

{ 

int
i, k = 
0
, l = 
0
; 

/* k - starting row index 

m - ending row index 

l - starting column index 

n - ending column index 

i - iterator 

*/


while
(k < m && l < n) { 

// Print the first row from the remaining rows 

for
(i = l; i < n; ++i) { 

System.out.print(a[k][i] + 
"" ""
); 

} 

k++; 


// Print the last column from the remaining columns 

for
(i = k; i < m; ++i) { 

System.out.print(a[i][n - 
1
] + 
"" ""
); 

} 

n--; 


// Print the last row from the remaining rows */ 

if
(k < m) { 

for
(i = n - 
1
; i >= l; --i) { 

System.out.print(a[m - 
1
][i] + 
"" ""
); 

} 

m--; 

} 


// Print the first column from the remaining columns */ 

if
(l < n) { 

for
(i = m - 
1
; i >= k; --i) { 

System.out.print(a[i][l] + 
"" ""
); 

} 

l++; 

} 

} 

} 


// driver program 

public
static
void
main(String[] args) 

{ 

int
R = 
3
; 

int
C = 
6
; 

int
a[][] = { { 
1
, 
2
, 
3
, 
4
, 
5
, 
6
}, 

{ 
7
, 
8
, 
9
, 
10
, 
11
, 
12
}, 

{ 
13
, 
14
, 
15
, 
16
, 
17
, 
18
} }; 

spiralPrint(R, C, a); 

} 
} 

// Contributed by Pramod Kumar ",CorCod,458,458,quadratic
"
class
SmallestSubArraySum 
{ 

// Returns length of smallest subarray with sum greater than x. 

// If there is no subarray with given sum, then returns n+1 

static
int
smallestSubWithSum(
int
arr[], 
int
n, 
int
x) 

{ 

// Initilize length of smallest subarray as n+1 

int
min_len = n + 
1
; 


// Pick every element as starting point 

for
(
int
start = 
0
; start < n; start++) 

{ 

// Initialize sum starting with current start 

int
curr_sum = arr[start]; 


// If first element itself is greater 

if
(curr_sum > x) 

return
1
; 


// Try different ending points for curremt start 

for
(
int
end = start + 
1
; end < n; end++) 

{ 

// add last element to current sum 

curr_sum += arr[end]; 


// If sum becomes more than x and length of 

// this subarray is smaller than current smallest 

// length, update the smallest length (or result) 

if
(curr_sum > x && (end - start + 
1
) < min_len) 

min_len = (end - start + 
1
); 

} 

} 

return
min_len; 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

int
arr1[] = {
1
, 
4
, 
45
, 
6
, 
10
, 
19
}; 

int
x = 
51
; 

int
n1 = arr1.length; 

int
res1 = smallestSubWithSum(arr1, n1, x); 

if
(res1 == n1+
1
) 

System.out.println(
""Not Possible""
); 

else

System.out.println(res1); 



int
arr2[] = {
1
, 
10
, 
5
, 
2
, 
7
}; 

int
n2 = arr2.length; 

x = 
9
; 

int
res2 = smallestSubWithSum(arr2, n2, x); 

if
(res2 == n2+
1
) 

System.out.println(
""Not Possible""
); 

else

System.out.println(res2); 


int
arr3[] = {
1
, 
11
, 
100
, 
1
, 
0
, 
200
, 
3
, 
2
, 
1
, 
250
}; 

int
n3 = arr3.length; 

x = 
280
; 

int
res3 = smallestSubWithSum(arr3, n3, x); 

if
(res3 == n3+
1
) 

System.out.println(
""Not Possible""
); 

else

System.out.println(res3); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,426,426,quadratic
"import java.util.*;
public class Solution{
	public static void main(String sp[]){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		String st = sc.next();
		
		char arr[] = st.toCharArray();
		
		boolean b=false;
		for(char j='a';j<='z';j++){
		for(int i=0;i<arr.length;i++){
			if(arr[i]==j){
				arr[i]='*';
				k--;
			}
			if(k==0){
				b=true;
				prin(arr);
				return;
			}
		}}

	}
	
	public static void prin(char arr[]){
		StringBuilder sb = new StringBuilder();
		for(int i=0;i<arr.length;i++){
			if(arr[i]!='*')
				sb.append(arr[i]);
		}
		if(sb.length()!=0)
			System.out.println(sb.toString());
	}
}",CorCod,139,139,linear
"
// Recursive Java program to search x in array 
class
Test 
{ 

static
int
arr[] = {
12
, 
34
, 
54
, 
2
, 
3
}; 


/* Recursive Method to search x in arr[l..r] */

static
int
recSearch(
int
arr[], 
int
l, 
int
r, 
int
x) 

{ 

if
(r < l) 

return
-
1
; 

if
(arr[l] == x) 

return
l; 

if
(arr[r] == x) 

return
r; 

return
recSearch(arr, l+
1
, r-
1
, x); 

} 


// Driver method 

public
static
void
main(String[] args) 

{ 

int
x = 
3
; 


//Method call to find x 

int
index = recSearch(arr, 
0
, arr.length-
1
, x); 

if
(index != -
1
) 

System.out.println(
""Element ""
+ x + 
"" is present at index ""
+ 

index); 

else

System.out.println(
""Element ""
+ x + 
"" is not present""
); 

} 

} ",CorCod,224,224,linear
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class Equator {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		int n = nextInt();
		int[] a = intArray(n);
		
		long s = 0;
		for (int x : a)
			s += x;
		
		long m = 0;
		for (int i = 0; i < n; i++) {
			m += a[i];
			if (m*2 >= s) {
				System.out.println(i+1);
				return;
			}
		}
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",CorCod,269,269,linear
"
// Java program to find maximum pair sum whose 
// difference is less than K 

import
java.io.*; 
import
java .util.*; 

class
GFG { 


// Method to return maximum sum we can get by 

// finding less than K difference pairs 

static
int
maxSumPairWithDifferenceLessThanK(
int
arr[], 

int
N, 
int
k) 

{ 

int
maxSum = 
0
; 


// Sort elements to ensure every i and i-1 is closest 

// possible pair 

Arrays.sort(arr); 


// To get maximum possible sum, iterate from largest 

// to smallest, giving larger numbers priority over 

// smaller numbers. 

for
(
int
i = N-
1
; i > 
0
; --i) 

{ 

// Case I: Diff of arr[i] and arr[i-1] is less then K, 

// add to maxSum 

// Case II: Diff between arr[i] and arr[i-1] is not less 

// then K, move to next i since with sorting we 

// know, arr[i]-arr[i-1] < arr[i]-arr[i-2] and 

// so on. 

if
(arr[i] - arr[i-
1
] < k) 

{ 

//Assuming only positive numbers. 

maxSum += arr[i]; 

maxSum += arr[i-
1
]; 


//When a match is found skip this pair 

--i; 

} 

} 


return
maxSum; 

} 


// Driver code to test above methods 

public
static
void
main (String[] args) { 


int
arr[] = {
3
, 
5
, 
10
, 
15
, 
17
, 
12
, 
9
}; 

int
N = arr.length; 

int
K = 
4
; 


System.out.println ( maxSumPairWithDifferenceLessThanK( 

arr, N, K)); 

} 
} 

//This code is contributed by vt_m. ",CorCod,624,624,nlogn
"import java.util.*;

public class helloWorld 
{
	public static void main(String[] args) 
	{		
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int m = in.nextInt();
		String str = in.next();
		boolean[] exist = new boolean[200];
		int dn[][] = new int[200][m+1];
		
		for(int i = 0; i < n; i++) {
			int a = str.charAt(i);
			exist[a] = true;
			dn[a][1] = a - 'a' + 1;
		}
		
		for(int k = 2; k <= m; k++) 
			for(int i = 'a'; i <= 'z'; i++)
				if(exist[i]) {
					int a = 0;
					for(int j = i+2; j <= 'z'; j++)
						if(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) 
							a = dn[j][k-1];
					if(a > 0)
						dn[i][k] = a + i - 'a' + 1; 
				}
		
		int ans = -1;
		for(int i = 'a'; i <= 'z'; i++)
			if(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )
				ans = dn[i][m];
		
		System.out.println(ans);
		
		in.close();
	}
}	



",CorCod,236,236,linear
"
import java.util.ArrayList;
import java.util.Scanner;

public class TaxiDriversAndLyft {
	
	static class Resident{
		Integer index;			// For all residents
		Integer type;			// 1 if driver & 0 for rider
		Integer requests;		// Only for drivers
		
		public Resident(int index, int type) {
			this.index = index;
			this.type = type;
			this.requests = 0;
		}
		
		@Override
		public String toString() {
			if(type == 0) {
				return ""Rider at index : "" + index;
			}
			else {
				return ""Driver at index : "" + index + "", Requests: "" + requests;
			}
		}
	}
	
	static ArrayList<Resident> residents;
	static ArrayList<Integer> drivers_indexes = new ArrayList<>();

	public static void main(String[] args) {
		Scanner reader = new Scanner(System.in);
		int n = reader.nextInt();
		int m = reader.nextInt();
		int length = n + m;
		
		int [] coordinates = new int[length];
		int [] types = new int[length];
		residents = new ArrayList<>();
		drivers_indexes = new ArrayList<>();
		
		for (int i = 0; i < length; i++) {
			coordinates[i] = reader.nextInt();
		}
		
		for (int i = 0; i < length; i++) {
			types[i] = reader.nextInt();
			
			if(types[i] == 1)
				drivers_indexes.add(i);
				
			residents.add(new Resident(i, types[i]));
		}
		reader.close();	
		
		for (int i = 0; i < length; i++) {
			Resident current = residents.get(i);
			if(current.type == 0) {
				int left = i-1, right = i+1;
								
				while(left >= 0 || right < length) {
					if(left >= 0 && residents.get(left).type == 1) {
						residents.get(left).requests++;
						break;
					}
					else if(right < length && residents.get(right).type == 1) {
						residents.get(right).requests++;
						break;
					}
					
					left--;
					right++;
				}
			}
		}
		
		for(int index : drivers_indexes) {
			System.out.print(residents.get(index).requests + "" "");
		}
	}

}
",CorCod,404,404,quadratic
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class EhabAndAnotherConstructionProblem {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		int x = nextInt();
		System.out.println(x == 1 ? -1 : x + "" "" + x);
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",CorCod,835,835,constant
"
// Java program to connect n ropes with minimum cost 

// A class for Min Heap 
class
MinHeap { 

int
[] harr; 
// Array of elements in heap 

int
heap_size; 
// Current number of elements in min heap 

int
capacity; 
// maximum possible size of min heap 


// Constructor: Builds a heap from 

// a given array a[] of given size 

public
MinHeap(
int
a[], 
int
size) 

{ 

heap_size = size; 

capacity = size; 

harr = a; 

int
i = (heap_size - 
1
) / 
2
; 

while
(i >= 
0
) { 

MinHeapify(i); 

i--; 

} 

} 


// A recursive method to heapify a subtree 

// with the root at given index 

// This method assumes that the subtrees 

// are already heapified 

void
MinHeapify(
int
i) 

{ 

int
l = left(i); 

int
r = right(i); 

int
smallest = i; 

if
(l < heap_size && harr[l] < harr[i]) 

smallest = l; 

if
(r < heap_size && harr[r] < harr[smallest]) 

smallest = r; 

if
(smallest != i) { 

swap(i, smallest); 

MinHeapify(smallest); 

} 

} 


int
parent(
int
i) { 
return
(i - 
1
) / 
2
; } 


// to get index of left child of node at index i 

int
left(
int
i) { 
return
(
2
* i + 
1
); } 


// to get index of right child of node at index i 

int
right(
int
i) { 
return
(
2
* i + 
2
); } 


// Method to remove minimum element (or root) from min heap 

int
extractMin() 

{ 

if
(heap_size <= 
0
) 

return
Integer.MAX_VALUE; 

if
(heap_size == 
1
) { 

heap_size--; 

return
harr[
0
]; 

} 


// Store the minimum value, and remove it from heap 

int
root = harr[
0
]; 

harr[
0
] = harr[heap_size - 
1
]; 

heap_size--; 

MinHeapify(
0
); 


return
root; 

} 


// Inserts a new key 'k' 

void
insertKey(
int
k) 

{ 

if
(heap_size == capacity) { 

System.out.println(
""Overflow: Could not insertKey""
); 

return
; 

} 


// First insert the new key at the end 

heap_size++; 

int
i = heap_size - 
1
; 

harr[i] = k; 


// Fix the min heap property if it is violated 

while
(i != 
0
&& harr[parent(i)] > harr[i]) { 

swap(i, parent(i)); 

i = parent(i); 

} 

} 


// A utility function to check 

// if size of heap is 1 or not 

boolean
isSizeOne() 

{ 

return
(heap_size == 
1
); 

} 


// A utility function to swap two elements 

void
swap(
int
x, 
int
y) 

{ 

int
temp = harr[x]; 

harr[x] = harr[y]; 

harr[y] = temp; 

} 


// The main function that returns the 

// minimum cost to connect n ropes of 

// lengths stored in len[0..n-1] 

static
int
minCost(
int
len[], 
int
n) 

{ 

int
cost = 
0
; 
// Initialize result 


// Create a min heap of capacity equal 

// to n and put all ropes in it 

MinHeap minHeap = 
new
MinHeap(len, n); 


// Iterate while size of heap doesn't become 1 

while
(!minHeap.isSizeOne()) { 

// Extract two minimum length ropes from min heap 

int
min = minHeap.extractMin(); 

int
sec_min = minHeap.extractMin(); 


cost += (min + sec_min); 
// Update total cost 


// Insert a new rope in min heap with length equal to sum 

// of two extracted minimum lengths 

minHeap.insertKey(min + sec_min); 

} 


// Finally return total minimum 

// cost for connecting all ropes 

return
cost; 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
len[] = { 
4
, 
3
, 
2
, 
6
}; 

int
size = len.length; 


System.out.println(
""Total cost for connecting ropes is ""
+ minCost(len, size)); 

} 
}; 

// This code is contributed by shubham96301 ",CorCod,716,716,nlogn
"package com.interview.binarysearch;

/**
 * Date 07/31/2016
 * @author Tushar Roy
 *
 * Given a sorted array of integers, find the starting and ending position of a given target value.
 *
 * Time complexity O(logn)
 * Space complexity O(1)
 * 
 * https://leetcode.com/problems/search-for-a-range/
 */
public class SearchForRange {
    public int[] searchRange(int[] nums, int target) {
        int first = firstOccurence(nums, target);
        if (first == -1) {
            return new int[]{-1, -1};
        }
        int last = lastOccurence(nums, target);
        return new int[]{first, last};
    }

    private int firstOccurence(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        while (low <= high) {
            int mid = low + (high - low)/2;
            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {
                return mid;
            } else if (nums[mid] >= target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }

    private int lastOccurence(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        while (low <= high) {
            int mid = low + (high - low)/2;
            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {
                return mid;
            } else if (nums[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1;
    }

    public static void main(String args[]) {
        SearchForRange searchForRange = new SearchForRange();
        int[] nums = {0, 1, 1, 3, 6, 9, 11};
        int[] r = searchForRange.searchRange(nums, 11);
        System.out.println(r[0] + "" "" + r[1]);
        r = searchForRange.searchRange(nums, 0);
        System.out.println(r[0] + "" "" + r[1]);
    }
}",CorCod,926,926,logn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author math2do
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int height = in.nextInt();
            int width = in.nextInt();
            int n1 = in.nextInt();
            int n2 = in.nextInt();
            int v = in.nextInt();
            int[] p1 = new int[n1];
            for (int i = 0; i < n1; ++i) p1[i] = in.nextInt();
            int[] p2 = new int[n2];
            for (int i = 0; i < n2; ++i) p2[i] = in.nextInt();
            int nq = in.nextInt();
            for (int iq = 0; iq < nq; ++iq) {
                int r1 = in.nextInt();
                int c1 = in.nextInt();
                int r2 = in.nextInt();
                int c2 = in.nextInt();
                if (r1 == r2) {
                    out.println(Math.abs(c1 - c2));
                } else {
                    long res = Long.MAX_VALUE;
                    int pos = Arrays.binarySearch(p1, c1);
                    if (pos < 0) pos = -(pos + 1);
                    if (pos >= 0 && pos < p1.length) {
                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));
                    }
                    --pos;
                    if (pos >= 0 && pos < p1.length) {
                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));
                    }
                    pos = Arrays.binarySearch(p2, c1);
                    if (pos < 0) pos = -(pos + 1);
                    if (pos >= 0 && pos < p2.length) {
                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);
                    }
                    --pos;
                    if (pos >= 0 && pos < p2.length) {
                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);
                    }
                    out.println(res);
                }
            }
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",CorCod,622,622,nlogn
"
// Java program to Find the repeating 
// and missing elements 

import
java.io.*; 

class
GFG { 


static
void
printTwoElements(
int
arr[], 
int
size) 

{ 

int
i; 

System.out.print(
""The repeating element is ""
); 


for
(i = 
0
; i < size; i++) { 

int
abs_val = Math.abs(arr[i]); 

if
(arr[abs_val - 
1
] > 
0
) 

arr[abs_val - 
1
] = -arr[abs_val - 
1
]; 

else

System.out.println(abs_val); 

} 


System.out.print(
""And the missing element is ""
); 

for
(i = 
0
; i < size; i++) { 

if
(arr[i] > 
0
) 

System.out.println(i + 
1
); 

} 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
7
, 
3
, 
4
, 
5
, 
5
, 
6
, 
2
}; 

int
n = arr.length; 

printTwoElements(arr, n); 

} 
} 

// This code is contributed by Gitanjali ",CorCod,71,71,linear
"// practice with rainboy
import java.io.*;
import java.util.*;

public class CF903F {
	static final int INF = 0x3f3f3f3f;
	static void fill(int[][][][] aa, int a) {
		for (int h0 = 0; h0 <= 4; h0++)
			for (int h1 = 0; h1 <= 4; h1++)
				for (int h2 = 0; h2 <= 4; h2++)
					for (int h3 = 0; h3 <= 4; h3++)
						aa[h0][h1][h2][h3] = a;
	}
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		int a1 = Integer.parseInt(st.nextToken());
		int a2 = Integer.parseInt(st.nextToken());
		int a3 = Integer.parseInt(st.nextToken());
		int a4 = Integer.parseInt(st.nextToken());
		int[] aa = new int[10];
		aa[0] = aa[1] = aa[2] = aa[3] = a1;
		aa[4] = aa[5] = aa[6] = a2;
		aa[7] = aa[8] = a3;
		aa[9] = a4;
		int[][] ww = new int[10][4];
		ww[0][0] = 1;
		ww[1][1] = 1;
		ww[2][2] = 1;
		ww[3][3] = 1;
		ww[4][0] = ww[4][1] = 2;
		ww[5][1] = ww[5][2] = 2;
		ww[6][2] = ww[6][3] = 2;
		ww[7][0] = ww[7][1] = ww[7][2] = 3;
		ww[8][1] = ww[8][2] = ww[8][3] = 3;
		ww[9][0] = ww[9][1] = ww[9][2] = ww[9][3] = 4;
		char[][] cc = new char[4][n + 8];
		for (int k = 0; k < 4; k++) {
			char[] c_ = cc[k];
			br.readLine().getChars(0, n, c_, 4);
			c_[0] = c_[1] = c_[2] = c_[3]
				= c_[n + 4] = c_[n + 5] = c_[n + 6] = c_[n + 7] = '.';
		}
		int[][][][] dp = new int[5][5][5][5];
		int[][][][] dq = new int[5][5][5][5];
		fill(dp, INF);
		dp[4][4][4][4] = 0;
		int[] hh = new int[4];
		for (int i = 0; i < n + 4; i++) {
			for (int h0 = 0; h0 <= 4; h0++)
				for (int h1 = 0; h1 <= 4; h1++)
					for (int h2 = 0; h2 <= 4; h2++)
						for (int h3 = 0; h3 <= 4; h3++)
							for (int s = 0; s < 10; s++) {
								hh[0] = h0;
								hh[1] = h1;
								hh[2] = h2;
								hh[3] = h3;
								for (int k = 0; k < 4; k++) {
									int h = ww[s][k];
									if (hh[k] < h) {
										while (h < 4 && cc[k][i + h] == '.')
											h++;
										hh[k] = h;
									}
								}
								int x = dp[h0][h1][h2][h3] + aa[s];
								if (dp[hh[0]][hh[1]][hh[2]][hh[3]] > x)
									dp[hh[0]][hh[1]][hh[2]][hh[3]] = x;
							}
			fill(dq, INF);
			for (int h0 = 1; h0 <= 4; h0++) {
				hh[0] = h0 < 4 || cc[0][i + 4] == '*' ? h0 - 1 : 4;
				for (int h1 = 1; h1 <= 4; h1++) {
					hh[1] = h1 < 4 || cc[1][i + 4] == '*' ? h1 - 1 : 4;
					for (int h2 = 1; h2 <= 4; h2++) {
						hh[2] = h2 < 4 || cc[2][i + 4] == '*' ? h2 - 1 : 4;
						for (int h3 = 1; h3 <= 4; h3++) {
							hh[3] = h3 < 4 || cc[3][i + 4] == '*' ? h3 - 1 : 4;
							int x = dp[h0][h1][h2][h3];
							if (dq[hh[0]][hh[1]][hh[2]][hh[3]] > x)
								dq[hh[0]][hh[1]][hh[2]][hh[3]] = x;
						}
					}
				}
			}
			int[][][][] tmp = dp; dp = dq; dq = tmp;
		}
		System.out.println(dp[4][4][4][4]);
	}
}
",CorCod,344,344,linear
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;

public class Div1_526C {

	static int nV;

	static ArrayList<Integer>[] chldn;

	static int root;

	static int[][] anc;
	static int[] depth;

	static int[] num;

	static int[] nLoc;

	static int[][] tree;

	public static void main(String[] args) throws IOException {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
		nV = Integer.parseInt(reader.readLine());

		chldn = new ArrayList[nV];
		for (int i = 0; i < nV; i++) {
			chldn[i] = new ArrayList<>();
		}

		anc = new int[nV][21];
		depth = new int[nV];

		num = new int[nV];
		nLoc = new int[nV];
		tree = new int[nV * 4][2];
		for (int[] a : tree) {
			a[0] = a[1] = -1;
		}

		root = 0;

		StringTokenizer inputData = new StringTokenizer(reader.readLine());
		for (int i = 0; i < nV; i++) {
			num[i] = Integer.parseInt(inputData.nextToken());
			nLoc[num[i]] = i;
		}

		inputData = new StringTokenizer(reader.readLine());
		for (int i = 1; i < nV; i++) {
			anc[i][0] = Integer.parseInt(inputData.nextToken()) - 1;
			chldn[anc[i][0]].add(i);
		}

		preprocess();

		build(1, 0, nV - 1);

		int nQ = Integer.parseInt(reader.readLine());

		while (nQ-- > 0) {
			inputData = new StringTokenizer(reader.readLine());
			if (inputData.nextToken().equals(""1"")) {
				int a = Integer.parseInt(inputData.nextToken()) - 1;
				int b = Integer.parseInt(inputData.nextToken()) - 1;

				int temp = num[a];
				num[a] = num[b];
				num[b] = temp;

				nLoc[num[a]] = a;
				nLoc[num[b]] = b;

				update(1, 0, nV - 1, num[a]);
				update(1, 0, nV - 1, num[b]);
			} else {
				printer.println(query(1, 0, nV - 1, nLoc[0], nLoc[0]) + 1);
			}
		}
		printer.close();
	}

	static void build(int nI, int cL, int cR) {
		if (cL == cR) {
			tree[nI][0] = nLoc[cL];
			tree[nI][1] = nLoc[cL];
		} else {
			int mid = (cL + cR) >> 1;
			build(nI * 2, cL, mid);
			build(nI * 2 + 1, mid + 1, cR);
			if (tree[nI * 2][0] != -1 && tree[nI * 2 + 1][0] != -1) {
				merge(tree[nI * 2][0], tree[nI * 2][1], tree[nI * 2 + 1][0], tree[nI * 2 + 1][1]);
				tree[nI][0] = mResp[0];
				tree[nI][1] = mResp[1];
			}
		}
	}

	static int query(int nI, int cL, int cR, int e1, int e2) {
		if (cL == cR) {
			merge(e1, e2, nLoc[cL], nLoc[cL]);
			if (mResp[0] != -1) {
				return cL;
			} else {
				return cL - 1;
			}
		}
		int mid = (cL + cR) >> 1;

		merge(tree[nI * 2][0], tree[nI * 2][1], e1, e2);
		if (mResp[0] != -1) {
			return query(nI * 2 + 1, mid + 1, cR, mResp[0], mResp[1]);
		}
		return query(nI * 2, cL, mid, e1, e2);
	}

	static void update(int nI, int cL, int cR, int uI) {
		if (cL == cR) {
			tree[nI][0] = nLoc[cL];
			tree[nI][1] = nLoc[cL];
		} else {
			int mid = (cL + cR) >> 1;
			if (uI <= mid) {
				update(nI * 2, cL, mid, uI);
			} else {
				update(nI * 2 + 1, mid + 1, cR, uI);
			}
			merge(tree[nI * 2][0], tree[nI * 2][1], tree[nI * 2 + 1][0], tree[nI * 2 + 1][1]);
			tree[nI][0] = mResp[0];
			tree[nI][1] = mResp[1];
		}
	}

	static int[] mResp = new int[2];

	static void merge1(int... a) {
		for (int i = 0; i < 3; i++) {
			if (a[i] == -1) {
				mResp[0] = mResp[1] = -1;
				return;
			}
		}

		if (onPath(a[0], a[1], a[2])) {
			mResp[0] = a[0];
			mResp[1] = a[1];
			return;
		}
		if (onPath(a[0], a[2], a[1])) {
			mResp[0] = a[0];
			mResp[1] = a[2];
			return;
		}
		if (onPath(a[1], a[2], a[0])) {
			mResp[0] = a[1];
			mResp[1] = a[2];
			return;
		}
		mResp[0] = mResp[1] = -1;
	}

	static void merge(int... a) {
		merge1(a[0], a[1], a[2]);
		merge1(mResp[0], mResp[1], a[3]);
	}

	static boolean onPath(int a, int b, int c) {
		if (a == c || b == c) {
			return true;
		}

		if (depth[a] > depth[c]) {
			a = jump(a, depth[a] - depth[c] - 1);
		}
		if (depth[b] > depth[c]) {
			b = jump(b, depth[b] - depth[c] - 1);
		}
		if (a == b) {
			return false;
		}

		if (anc[a][0] == c || anc[b][0] == c) {
			return true;
		}

		return false;
	}

	// good for depth of up to 1_048_576 = 2^20

	static void preprocess() {
		anc[root][0] = root;
		fParent(root);

		for (int k = 1; k <= 20; k++) {
			for (int i = 0; i < nV; i++) {
				anc[i][k] = anc[anc[i][k - 1]][k - 1];
			}
		}
	}

	static void fParent(int cV) {
		for (int aV : chldn[cV]) {
			anc[aV][0] = cV;
			depth[aV] = depth[cV] + 1;
			fParent(aV);
		}
	}

	static int fLCA(int a, int b) {
		if (depth[a] > depth[b]) {
			int temp = b;
			b = a;
			a = temp;
		}
		b = jump(b, depth[b] - depth[a]);
		if (a == b) {
			return a;
		}
		for (int i = 20; i >= 0; i--) {
			if (anc[a][i] != anc[b][i]) {
				a = anc[a][i];
				b = anc[b][i];
			}
		}
		return anc[a][0];
	}

	static int jump(int cV, int d) {
		for (int i = 0; i <= 20; i++) {
			if ((d & (1 << i)) != 0) {
				cV = anc[cV][i];
			}
		}
		return cV;
	}

	static Comparator<Integer> BY_DEPTH = new Comparator<Integer>() {
		public int compare(Integer o1, Integer o2) {
			return -Integer.compare(depth[o1], depth[o2]); // greatest depth first
		}
	};
}",CorCod,730,730,nlogn
"
// Java program to find the Minimum length Unsorted Subarray, 
// sorting which makes the complete array sorted 
class
Main 
{ 

static
void
printUnsorted(
int
arr[], 
int
n) 

{ 

int
s = 
0
, e = n-
1
, i, max, min; 


// step 1(a) of above algo 

for
(s = 
0
; s < n-
1
; s++) 

{ 

if
(arr[s] > arr[s+
1
]) 

break
; 

} 

if
(s == n-
1
) 

{ 

System.out.println(
""The complete array is sorted""
); 

return
; 

} 


// step 1(b) of above algo 

for
(e = n - 
1
; e > 
0
; e--) 

{ 

if
(arr[e] < arr[e-
1
]) 

break
; 

} 


// step 2(a) of above algo 

max = arr[s]; min = arr[s]; 

for
(i = s + 
1
; i <= e; i++) 

{ 

if
(arr[i] > max) 

max = arr[i]; 

if
(arr[i] < min) 

min = arr[i]; 

} 


// step 2(b) of above algo 

for
( i = 
0
; i < s; i++) 

{ 

if
(arr[i] > min) 

{ 

s = i; 

break
; 

} 

} 


// step 2(c) of above algo 

for
( i = n -
1
; i >= e+
1
; i--) 

{ 

if
(arr[i] < max) 

{ 

e = i; 

break
; 

} 

} 


// step 3 of above algo 

System.out.println(
"" The unsorted subarray which""
+ 

"" makes the given array sorted lies""
+ 

"" between the indices ""
+s+
"" and ""
+e); 

return
; 

} 


public
static
void
main(String args[]) 

{ 

int
arr[] = {
10
, 
12
, 
20
, 
30
, 
25
, 
40
, 
32
, 
31
, 
35
, 
50
, 
60
}; 

int
arr_size = arr.length; 

printUnsorted(arr, arr_size); 

} 
} ",CorCod,91,91,linear
"import java.util.*;
import java.io.*;



 public class Param
{
                
      public static  void main( String[]args) 
    {
       MyScanner param = new MyScanner();
      out = new PrintWriter(new BufferedOutputStream(System.out));
       long l2 =param.nextLong();
       long dice1=param.nextLong();
       long dice2=param.nextLong();
      
       long l1=1;
       long r1=1;
       long r2=l2;
       long count=0;
       long check=0;
       count=l2-dice1;
       count=count+(r2-dice2);
       check=dice1-l1;
       check=check+(dice2-r1);
       if(check<=count){
          System.out.println(""White"");
       }
       else{
          System.out.println(""Black"");
       }
      out.close();
}
public static PrintWriter out;
      
   //-----------MyScanner class for faster input----------
   public static class MyScanner {
      BufferedReader br;
      StringTokenizer st;
 
      public MyScanner() {
         br = new BufferedReader(new InputStreamReader(System.in));
      }
 
      String next() {
          while (st == null || !st.hasMoreElements()) {
              try {
                  st = new StringTokenizer(br.readLine());
              } catch (IOException e) {
                  e.printStackTrace();
              }
          }
          return st.nextToken();
      }
 
      int nextInt() {
          return Integer.parseInt(next());
      }
 
      long nextLong() {
          return Long.parseLong(next());
      }
 
      double nextDouble() {
          return Double.parseDouble(next());
      }
 
      String nextLine(){
          String str = """";
	  try {
	     str = br.readLine();
	  } catch (IOException e) {
	     e.printStackTrace();
	  }
	  return str;
      }
}
}
   ",CorCod,853,853,constant
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

public class CodeForces
{
	public static void main(String[] args)
	{
		Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int k = input.nextInt();
		int n = input.nextInt();
		int s = input.nextInt();
		int p = input.nextInt();

		int each = n / s;
		if (n % s != 0)
		{
			each++;
		}
		int all = each * k;

		if (all % p == 0)
		{
			System.out.println(all / p);
		} else
		{
			System.out.println(all / p + 1);
		}
	}
}",CorCod,781,781,constant
"//Atcoder
import java.io.*;
import java.util.*;

public class Main {

	static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner() {
            try {
                br = new BufferedReader(new InputStreamReader(System.in));
                st = new StringTokenizer(br.readLine());
            } catch (Exception e){e.printStackTrace();}
        }

        public String next() {
            if (st.hasMoreTokens()) return st.nextToken();
            try {st = new StringTokenizer(br.readLine());}
            catch (Exception e) {e.printStackTrace();}
            return st.nextToken();
        }

        public int nextInt() {return Integer.parseInt(next());}

        public long nextLong() {return Long.parseLong(next());}

        public double nextDouble() {return Double.parseDouble(next());}

        public String nextLine() {
            String line = """";
            if(st.hasMoreTokens()) line = st.nextToken();
            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}
            while(st.hasMoreTokens()) line += "" ""+st.nextToken();
            return line;
        }
    }

	public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        PrintWriter pw = new PrintWriter(System.out);

        int n = sc.nextInt();
        int m = sc.nextInt();
        int ans = 0;

        int[] a = new int[101];
        for(int i=0;i<m;i++) a[sc.nextInt()]++;

        for(int i=1;i<=100;i++) {
            int y = 0;
            for(int x : a) {
                y += x / i;
            }
            if(y >= n) {
                ans = i;
            }
        }

        pw.println(ans);
        pw.close();
    }
}
",CorCod,443,443,quadratic
"import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class Solution {
	public static void main(String[] args) {
		Solution solution = new Solution();
		System.out.println(solution.solve());
	}

	private int solve() {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int m = in.nextInt();

		int[] a = new int[m];
		for (int i = 0; i < m; ++i) a[i] = in.nextInt();

		if (n > m) return 0;

		Map<Integer, Integer> map = new HashMap<>();
		for (int k: a) map.put(k, map.getOrDefault(k, 0) + 1);

		List<Integer> keySet = new ArrayList<>(map.keySet());
		int end = m / n;

		keySet.sort((u, v) -> -Integer.compare(u, v));
		do {
			int count = 0;
			for (int k: keySet) {
				count += map.get(k) / end;
				if (count >= n) return end;
			}
		} while (--end > 0);

		return 0;
	}
}
",CorCod,723,723,nlogn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author gaidash
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            final int SIZE = 256;
            final int UNDEF = -1;

            int nPixels = in.nextInt();
            int groupSize = in.nextInt();
            int[] a = in.nextIntArray(nPixels);
            boolean[] exists = new boolean[SIZE];
            int[] left = new int[SIZE];
            int[] right = new int[SIZE];
            int[] ret = new int[nPixels];
            Arrays.fill(ret, UNDEF);

            for (int i = 0; i < nPixels; i++) {
                for (int p = 0; p < SIZE; p++) {
                    if (exists[p] && left[p] <= a[i] && a[i] <= right[p]) {
                        ret[i] = left[p];
                        left[a[i]] = left[p];
                        right[a[i]] = right[p];
                        break;
                    }
                }
                if (ret[i] == UNDEF) {
                    int l = Math.max(a[i] - groupSize + 1, 0);
                    int r = l + groupSize - 1;
                    for (int p = a[i] - 1; p >= 0; p--) {
                        if (exists[p]) {
                            if (p >= l) {
                                int d = p - l;
                                l = p + 1;
                                r += d + 1;
                            }
                            if (right[p] >= l) {
                                right[p] = l - 1;
                            }
                        }
                    }
                    for (int p = a[i] + 1; p < SIZE; p++) {
                        if (exists[p] && left[p] <= r) {
                            r = left[p] - 1;
                        }
                    }
                    left[a[i]] = l;
                    right[a[i]] = r;
                    ret[i] = l;
                }
                exists[a[i]] = true;
            }
//        for (int p : a) {
//            System.out.println(""Segment for pixel "" + p + "" = "" + ""("" + left[p] + "" , "" + right[p] + "")"");
//        }

            out.print(ret);
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(int[] array) {
            for (int i = 0; i < array.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(array[i]);
            }
        }

        public void close() {
            writer.close();
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public int[] nextIntArray(int n) {
            int[] array = new int[n];
            for (int i = 0; i < n; ++i) array[i] = nextInt();
            return array;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",CorCod,578,578,quadratic
"
import
java.util.Arrays; 

// Java program to test whether an array 
// can be sorted by swapping adjacent 
// elements using boolean array 

class
GFG { 


// Return true if array can be 

// sorted otherwise false 

static
boolean
sortedAfterSwap(
int
A[], 

boolean
B[], 
int
n) 

{ 

int
i, j; 


// Check bool array B and sorts 

// elements for continuos sequence of 1 

for
(i = 
0
; i < n - 
1
; i++) { 

if
(B[i]) { 

j = i; 

while
(B[j]) { 

j++; 

} 

// Sort array A from i to j 

Arrays.sort(A, i, 
1
+ j); 

i = j; 

} 

} 


// Check if array is sorted or not 

for
(i = 
0
; i < n; i++) { 

if
(A[i] != i + 
1
) { 

return
false
; 

} 

} 


return
true
; 

} 


// Driver program to test sortedAfterSwap() 

public
static
void
main(String[] args) 

{ 

int
A[] = { 
1
, 
2
, 
5
, 
3
, 
4
, 
6
}; 

boolean
B[] = { 
false
, 
true
, 
true
, 
true
, 
false
}; 

int
n = A.length; 


if
(sortedAfterSwap(A, B, n)) { 

System.out.println(
""A can be sorted""
); 

} 

else
{ 

System.out.println(
""A can not be sorted""
); 

} 

} 
} ",CorCod,118,118,linear
"import java.io.*;
import java.util.*;

public class CF1082D {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		int[] aa = new int[n];
		int[] i1 = new int[n];
		int[] i2 = new int[n];
		int n1 = 0, n2 = 0, m2 = 0;
		for (int i = 0; i < n; i++) {
			int a = Integer.parseInt(st.nextToken());
			aa[i] = a;
			if (a == 1)
				i1[n1++] = i;
			else {
				i2[n2++] = i;
				m2 += a;
			}
		}
		if (m2 < (n2 - 1) * 2 + n1) {
			System.out.println(""NO"");
			return;
		}
		int m = n2 - 1 + n1;
		int d = n2 - 1 + Math.min(n1, 2);
		PrintWriter pw = new PrintWriter(System.out);
		pw.println(""YES "" + d);
		pw.println(m);
		for (int i = 0; i + 1 < n2; i++) {
			pw.println((i2[i] + 1) + "" "" + (i2[i + 1] + 1));
			aa[i2[i]]--; aa[i2[i + 1]]--;
		}
		if (n1 > 0) {
			while (n2 > 0 && aa[i2[n2 - 1]] == 0)
				n2--;
			pw.println((i2[n2 - 1] + 1) + "" "" + (i1[n1 - 1] + 1));
			aa[i2[n2 - 1]]--;
			n1--;
		}
		for (int i = 0, j = 0; j < n1; j++) {
			while (aa[i2[i]] == 0)
				i++;
			pw.println((i2[i] + 1) + "" "" + (i1[j] + 1));
			aa[i2[i]]--;
		}
		pw.close();
	}
}
",CorCod,11,11,linear
"
// Java code to count the change required to 
// convert the array into non-increasing array 
import
java.util.PriorityQueue; 

class
GFG 
{ 

public
static
int
DecreasingArray(
int
a[], 
int
n) 

{ 

int
sum = 
0
, dif = 
0
; 


PriorityQueue<Integer> pq = 
new
PriorityQueue<>(); 


// Here in the loop we will 

// check that whether the upcoming 

// element of array is less than top 

// of priority queue. If yes then we 

// calculate the difference. After 

// that we will remove that element 

// and push the current element in 

// queue. And the sum is incremented 

// by the value of difference 

for
(
int
i = 
0
; i < n; i++) 

{ 

if
(!pq.isEmpty() && pq.element() < a[i]) 

{ 

dif = a[i] - pq.element(); 

sum += dif; 

pq.remove(); 

pq.add(a[i]); 

} 

pq.add(a[i]); 

} 


return
sum; 

} 


// Driver Code 

public
static
void
main(String[] args) 

{ 


int
[] a = {
3
, 
1
, 
2
, 
1
}; 


int
n = a.length; 


System.out.println(DecreasingArray(a, n)); 

} 
} 

// This Code is contributed by sanjeev2552 ",CorCod,702,702,nlogn
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.lang.reflect.Array;
import java.util.HashSet;
import java.util.StringTokenizer;

public class Main {
	public static String conv(String str) {
		boolean[] Arr = new boolean[26];
		for (int i = 0; i < str.length(); i++) {
			Arr[str.charAt(i) - 'a'] = true;
		}
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < 26; i++) {
			if (Arr[i])
				sb.append((char) (i + 'a'));
		}
		return """" + sb;
	}

	public static void main(String[] args) throws IOException, InterruptedException {
		PrintWriter pw = new PrintWriter(System.out);
		Scanner sc = new Scanner(System.in);
		HashSet<String> hs = new HashSet<String>();
		int[] Arr = new int[14];
		long max = 0;
		for (int i = 0; i < 14; i++) {
			Arr[i] = sc.nextInt();
		}

		for (int i = 0; i < 14; i++) {
			int[] arr = Arr.clone();

			long sum = 0;
			int r = arr[i];
			arr[i] = 0;
			for (int j = i + 1; j < arr.length && r > 0; j++) {
				arr[j]++;
				r--;
			}
			for (int j = 0; j < arr.length; j++) {
				arr[j] +=( r / 14);
				if (j + 1 <= (r % 14)) {
					arr[j]++;
				}
				if (arr[j] % 2 == 0) {
					sum += arr[j];
				}
			}
			max = Math.max(max, sum);

		}
		System.out.println(max);
	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public double nextDouble() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder(""0"");
			double res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder(""0"");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

	}
}
",CorCod,845,845,constant
"package com.interview.binarysearch;

/**
 * http://www.careercup.com/question?id=4877486110277632
 * Given a circle with N defined points and a point M outside the circle, 
 * find the point that is closest to M among the set of N. O(LogN)
 * Test cases
 * 1) smallest element at center
 * 2) smallest element at left/right end
 * 3) largest element at center
 * 4) smallest element at left side
 * 5) smallest element at right side
 */
public class CircularBinarySearch {

    //if mid is greater than both ends than result is low of two ends else move in direction
    //where either mid-1 or mid+1 is less
    public int search(int arr[]) {
        int low = 0;
        int high = arr.length - 1;
        int mid = 0;
        while (low < high) {
            mid = (low + high) / 2;
            //if middle is less than both mid-1 and mid+1 then mid is the answer
            if((low == mid || arr[mid] < arr[mid-1])&& arr[mid] < arr[mid+1]){
                return arr[mid];
            }
            if ((arr[mid] >= arr[low] && arr[mid] >= arr[high])){
                if(arr[low] < arr[high]){
                    high = mid-1;
                }else{
                    low = mid+1;
                }
            }else{
                if(arr[mid-1] < arr[mid+1]){
                    high = mid-1;
                }else{
                    low = mid+1;
                }
            }
        }
        return arr[low];
    }

    public static void main(String args[]) {
        CircularBinarySearch cbs = new CircularBinarySearch();
        int arr[] = { 7, 10, 8, 5, 2, 3, 5 };
        System.out.print(cbs.search(arr));

        int arr1[] = { 5, 8, 10, 7, 5, 3, 2 };
        System.out.print(cbs.search(arr1));

        int arr2[] = { 3, 5, 7, 10, 8, 5, 2 };
        System.out.print(cbs.search(arr2));

        int arr3[] = { 8, 5, 2, 3, 5, 7, 10 };
        System.out.print(cbs.search(arr3));

        int arr4[] = { 5, 3, 2, 5, 8, 10, 7 };
        System.out.print(cbs.search(arr4));

        int arr5[] = {100,20,10,5,2,8,11,16,19};
        System.out.print(cbs.search(arr5));

        int arr6[] = {200,2,10,15,20,80,110,160,190};
        System.out.print(cbs.search(arr6));

        int arr7[] = {5,10,20,50,200,800,1100,1600,1900,2};
        System.out.print(cbs.search(arr7));

        int arr8[] = {2,5,10,20,50,200,800,1100,1600,1900};
        System.out.print(cbs.search(arr8));
        
        int arr9[] = {3,1,8,5,4};
        System.out.print(cbs.search(arr9));
        
    }
}",CorCod,929,929,logn
"
// Java program to split array and move first 
// part to end. 

import
java.util.*; 
import
java.lang.*; 
class
GFG { 

public
static
void
splitArr(
int
arr[], 
int
n, 
int
k) 

{ 

for
(
int
i = 
0
; i < k; i++) { 


// Rotate array by 1. 

int
x = arr[
0
]; 

for
(
int
j = 
0
; j < n - 
1
; ++j) 

arr[j] = arr[j + 
1
]; 

arr[n - 
1
] = x; 

} 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
12
, 
10
, 
5
, 
6
, 
52
, 
36
}; 

int
n = arr.length; 

int
position = 
2
; 


splitArr(arr, 
6
, position); 


for
(
int
i = 
0
; i < n; ++i) 

System.out.print(arr[i] + 
"" ""
); 

} 
} 

// Code Contributed by Mohit Gupta_OMG <(0_o)> ",CorCod,448,448,quadratic
"import java.io.*;
import java.util.Arrays;
import java.util.Random;
import java.util.StringJoiner;
import java.util.StringTokenizer;
import java.util.concurrent.ThreadLocalRandom;
import java.util.function.Function;

public class Main {

    static int T;

    public static void main(String[] args) {
        FastScanner sc = new FastScanner(System.in);
        T = sc.nextInt();

        PrintWriter pw = new PrintWriter(System.out);
        for (int i = 0; i < T; i++) {
            int n = sc.nextInt();
            int[] a = sc.nextIntArray(n);
            int[] ans = solve(n, a);
            StringJoiner j = new StringJoiner("" "");
            for (int each : ans) {
                j.add(String.valueOf(each));
            }
            pw.println(j.toString());
        }
        pw.flush();
    }

    static int[] solve(int N, int[] A) {
        // a/b が1に近いものを探す
        shuffle(A);
        Arrays.sort(A);
        int cur = A[0];
        int time = 1;
        double r = 0;
        int prev = -1;
        int a = -1;
        int b = -1;
        for (int i = 1; i < N; i++) {
            if( cur == A[i] ) {
                time++;

                if( time == 2 ) {
                    if( prev != -1 ) {
                        double r1 = (double)prev/cur;
                        if( r1 > r ) {
                            r = r1;
                            a = prev;
                            b = cur;
                        }
                    }
                    prev = cur;
                }

                if( time == 4 ) {
                    return new int[]{cur, cur, cur, cur};
                }

            } else {
                time = 1;
                cur = A[i];
            }
        }

        return new int[]{a, a, b, b};
    }

    static void shuffle(int[] a) {
        Random r = ThreadLocalRandom.current();
        for (int i = a.length-1; i >= 0; i--) {
            int j = r.nextInt(i+1);
            int t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
    }

    @SuppressWarnings(""unused"")
    static class FastScanner {
        private BufferedReader reader;
        private StringTokenizer tokenizer;

        FastScanner(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
            tokenizer = null;
        }

        String next() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        String nextLine() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    return reader.readLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken(""\n"");
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        int[] nextIntArray(int n, int delta) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt() + delta;
            return a;
        }

        long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }
    }

    static <A> void writeLines(A[] as, Function<A, String> f) {
        PrintWriter pw = new PrintWriter(System.out);
        for (A a : as) {
            pw.println(f.apply(a));
        }
        pw.flush();
    }

    static void writeLines(int[] as) {
        PrintWriter pw = new PrintWriter(System.out);
        for (int a : as) pw.println(a);
        pw.flush();
    }

    static void writeLines(long[] as) {
        PrintWriter pw = new PrintWriter(System.out);
        for (long a : as) pw.println(a);
        pw.flush();
    }

    static int max(int... as) {
        int max = Integer.MIN_VALUE;
        for (int a : as) max = Math.max(a, max);
        return max;
    }

    static int min(int... as) {
        int min = Integer.MAX_VALUE;
        for (int a : as) min = Math.min(a, min);
        return min;
    }

    static void debug(Object... args) {
        StringJoiner j = new StringJoiner("" "");
        for (Object arg : args) {
            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));
            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));
            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));
            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));
            else j.add(arg.toString());
        }
        System.err.println(j.toString());
    }
}
",CorCod,596,596,nlogn
"
// Java program for recursive level order traversal in spiral form 

/* A binary tree node has data, pointer to left child 

and a pointer to right child */
class
Node { 

int
data; 

Node left, right; 


public
Node(
int
d) 

{ 

data = d; 

left = right = 
null
; 

} 
} 

class
BinaryTree { 

Node root; 


// Function to print the spiral traversal of tree 

void
printSpiral(Node node) 

{ 

int
h = height(node); 

int
i; 


/* ltr -> left to right. If this variable is set then the 

given label is traversed from left to right */

boolean
ltr = 
false
; 

for
(i = 
1
; i <= h; i++) { 

printGivenLevel(node, i, ltr); 


/*Revert ltr to traverse next level in opposite order*/

ltr = !ltr; 

} 

} 


/* Compute the ""height"" of a tree -- the number of 

nodes along the longest path from the root node 

down to the farthest leaf node.*/

int
height(Node node) 

{ 

if
(node == 
null
) 

return
0
; 

else
{ 


/* compute the height of each subtree */

int
lheight = height(node.left); 

int
rheight = height(node.right); 


/* use the larger one */

if
(lheight > rheight) 

return
(lheight + 
1
); 

else

return
(rheight + 
1
); 

} 

} 


/* Print nodes at a given level */

void
printGivenLevel(Node node, 
int
level, 
boolean
ltr) 

{ 

if
(node == 
null
) 

return
; 

if
(level == 
1
) 

System.out.print(node.data + 
"" ""
); 

else
if
(level > 
1
) { 

if
(ltr != 
false
) { 

printGivenLevel(node.left, level - 
1
, ltr); 

printGivenLevel(node.right, level - 
1
, ltr); 

} 

else
{ 

printGivenLevel(node.right, level - 
1
, ltr); 

printGivenLevel(node.left, level - 
1
, ltr); 

} 

} 

} 

/* Driver program to test the above functions */

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
1
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
3
); 

tree.root.left.left = 
new
Node(
7
); 

tree.root.left.right = 
new
Node(
6
); 

tree.root.right.left = 
new
Node(
5
); 

tree.root.right.right = 
new
Node(
4
); 

System.out.println(
""Spiral order traversal of Binary Tree is ""
); 

tree.printSpiral(tree.root); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,461,461,quadratic
"
// Java program to print cousins of a node 
class
GfG { 

// A Binary Tree Node 
static
class
Node 
{ 

int
data; 

Node left, right; 
} 

// A utility function to create a new Binary 
// Tree Node 
static
Node newNode(
int
item) 
{ 

Node temp = 
new
Node(); 

temp.data = item; 

temp.left = 
null
; 

temp.right = 
null
; 

return
temp; 
} 

/* It returns level of the node if it is present 
in tree, otherwise returns 0.*/
static
int
getLevel(Node root, Node node, 
int
level) 
{ 

// base cases 

if
(root == 
null
) 

return
0
; 

if
(root == node) 

return
level; 


// If node is present in left subtree 

int
downlevel = getLevel(root.left, node, level+
1
); 

if
(downlevel != 
0
) 

return
downlevel; 


// If node is not present in left subtree 

return
getLevel(root.right, node, level+
1
); 
} 

/* Print nodes at a given level such that sibling of 
node is not printed if it exists */
static
void
printGivenLevel(Node root, Node node, 
int
level) 
{ 

// Base cases 

if
(root == 
null
|| level < 
2
) 

return
; 


// If current node is parent of a node with 

// given level 

if
(level == 
2
) 

{ 

if
(root.left == node || root.right == node) 

return
; 

if
(root.left != 
null
) 

System.out.print(root.left.data + 
"" ""
); 

if
(root.right != 
null
) 

System.out.print(root.right.data + 
"" ""
); 

} 


// Recur for left and right subtrees 

else
if
(level > 
2
) 

{ 

printGivenLevel(root.left, node, level-
1
); 

printGivenLevel(root.right, node, level-
1
); 

} 
} 

// This function prints cousins of a given node 
static
void
printCousins(Node root, Node node) 
{ 

// Get level of given node 

int
level = getLevel(root, node, 
1
); 


// Print nodes of given level. 

printGivenLevel(root, node, level); 
} 

// Driver Program to test above functions 
public
static
void
main(String[] args) 
{ 

Node root = newNode(
1
); 

root.left = newNode(
2
); 

root.right = newNode(
3
); 

root.left.left = newNode(
4
); 

root.left.right = newNode(
5
); 

root.left.right.right = newNode(
15
); 

root.right.left = newNode(
6
); 

root.right.right = newNode(
7
); 

root.right.left.right = newNode(
8
); 


printCousins(root, root.left.right); 
} 
} ",CorCod,117,117,linear
"
// Java program to find triplets in a given 
// array whose sum is zero 
import
java.util.Arrays; 
import
java.io.*; 

class
GFG { 

// function to print triplets with 0 sum 
static
void
findTriplets(
int
arr[], 
int
n) 
{ 

boolean
found = 
false
; 


// sort array elements 

Arrays.sort(arr); 


for
(
int
i=
0
; i<n-
1
; i++) 

{ 

// initialize left and right 

int
l = i + 
1
; 

int
r = n - 
1
; 

int
x = arr[i]; 

while
(l < r) 

{ 

if
(x + arr[l] + arr[r] == 
0
) 

{ 

// print elements if it's sum is zero 

System.out.print(x + 
"" ""
); 

System.out.print(arr[l]+ 
"" ""
); 

System.out.println(arr[r]+ 
"" ""
); 


l++; 

r--; 

found = 
true
; 

} 


// If sum of three elements is less 

// than zero then increment in left 

else
if
(x + arr[l] + arr[r] < 
0
) 

l++; 


// if sum is greater than zero than 

// decrement in right side 

else

r--; 

} 

} 


if
(found == 
false
) 

System.out.println(
"" No Triplet Found""
); 
} 

// Driven source 

public
static
void
main (String[] args) { 


int
arr[] = {
0
, -
1
, 
2
, -
3
, 
1
}; 

int
n =arr.length; 

findTriplets(arr, n); 

} 
//This code is contributed by Tushil.. 
} ",CorCod,513,513,quadratic
"
// A O(n) time and O(1) extra 
// space solution to calculate 
// the Permutation Coefficient 
import
java.io.*; 

class
GFG 
{ 

static
int
PermutationCoeff(
int
n, 

int
k) 

{ 

int
Fn = 
1
, Fk = 
1
; 


// Compute n! and (n-k)! 

for
(
int
i = 
1
; i <= n; i++) 

{ 

Fn *= i; 

if
(i == n - k) 

Fk = Fn; 

} 

int
coeff = Fn / Fk; 

return
coeff; 

} 


// Driver Code 

public
static
void
main(String args[]) 

{ 

int
n = 
10
, k = 
2
; 

System.out.println(
""Value of P( ""
+ n + 
"",""
+ 

k +
"") is ""
+ 

PermutationCoeff(n, k) ); 

} 
} 

// This code is contributed by Nikita Tiwari. ",CorCod,144,144,linear
"import java.util.*;
import java.io.*;
public class A
{
      public static void main(String ar[]) throws Exception
      {
            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
            String s1[]=br.readLine().split("" "");
            int a=Integer.parseInt(s1[0]);
            int b=Integer.parseInt(s1[1]);
            int c=Integer.parseInt(s1[2]);
            int n=Integer.parseInt(s1[3]);
            int S=a+b-c;
            if(n-S<1 || c>Math.min(a,b))
             System.out.println(""-1"");
            else
             System.out.println(n-S);
      }
}",CorCod,748,748,constant
"
import java.util.Scanner;

public class Main {
    static Scanner scan = new Scanner(System.in);

    public static void main(String [] args){
        int num = scan.nextInt();
        for(int i=0;i<num;i++){
            int a = scan.nextInt();
            int b = scan.nextInt();
            System.out.println(a+"" ""+2*a);
        }
    }
}
	  	    	    		 	  				 		 			",CorCod,795,795,constant
"/**
 * Created by Baelish on 8/28/2018.
 */

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class F_DSU {
    public static void main(String[] args)throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        n = in.nextInt();
        
        int brr[] = new int[2*n];
        for (int i = 0; i < 2*n; i+= 2) {
            brr[i] = in.nextInt();
            brr[i+1] = in.nextInt();
        }

        arr = shrink(brr);
        int imap[] = new int[2*n];
        for (int i = 0; i < 2*n; i++) {
            imap[arr[i]] = brr[i];
        }

        int idx = binarySearch(arr.length);
        if(idx >= arr.length) pw.println(-1);
        else pw.println(imap[idx]);

        pw.close();
    }
    static int n, arr[];

    static int binarySearch(int H) {
        int lo = 0, hi = H, mid;
        while (lo < hi) {
            mid = (lo + hi) / 2;
            if (check(mid)) hi = mid;
            else lo = mid + 1;
        }
        if(lo > 0 && check(lo-1)) return lo-1;
        return lo;
    }

    static boolean check(int m){
        DSU dsu = new DSU(2*n);
        for (int i = 0; i < n; i++) {
            int u = arr[2*i], v = arr[2*i+1];
            if(u > m) return false;
            if(v > m){
                if(++dsu.cycle[dsu.find(u)] >= 2) return false;
            }
            else{
                if(!dsu.union(u, v)){
                    if(++dsu.cycle[dsu.find(u)] >= 2) return false;
                }
                else{
                    if(dsu.cycle[dsu.find(u)] >= 2) return false;
                }
            }
        }
        return true;
    }

    static class DSU{
        int parent[], cycle[], n;
        DSU(int N){
            n = N;
            parent = new int[N];
            cycle = new int[N];
            for(int i = 0; i < N; i++){
                parent[i] = i;
            }
        }

        DSU(int [] p){
            parent = p; n = p.length;
        }

        int find(int i) {
            int p = parent[i];
            if (i == p) return i;
            return parent[i] = find(p);
        }

        boolean equiv(int u, int v){
            return find(u) == find(v);
        }

        boolean union(int u, int v){
            u = find(u); v = find(v);
            if(u != v) {
                parent[u] = parent[v];
                cycle[v] += cycle[u];
            }
            return u != v;
        }

        int count(){
            int cnt = 0;
            for(int i = 0; i < n; i++){
                if(i == find(i)) cnt++;
            }
            return cnt;
        }
    }

    public static int[] shrink(int[] a) {
        int n = a.length;
        long[] b = new long[n];
        for(int i = 0;i < n;i++)b[i] = (long)a[i]<<32|i;
        Arrays.sort(b);
        int[] ret = new int[n];
        int p = 0;
        for(int i = 0;i < n;i++) {
            if(i>0 && (b[i]^b[i-1])>>32!=0)p++;
            ret[(int)b[i]] = p;
        }
        return ret;
    }

    static void debug(Object...obj) {
        System.err.println(Arrays.deepToString(obj));
    }

    static class FastReader {
        InputStream is;
        private byte[] inbuf = new byte[1024];
        private int lenbuf = 0, ptrbuf = 0;
        static final int ints[] = new int[128];

        public FastReader(InputStream is){
            for(int i='0';i<='9';i++) ints[i]=i-'0';
            this.is = is;
        }

        public int readByte(){
            if(lenbuf == -1)throw new InputMismatchException();
            if(ptrbuf >= lenbuf){
                ptrbuf = 0;
                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
                if(lenbuf <= 0)return -1;
            }
            return inbuf[ptrbuf++];
        }

        public boolean isSpaceChar(int c) {
            return !(c >= 33 && c <= 126);
        }
        public int skip() {
            int b;
            while((b = readByte()) != -1 && isSpaceChar(b));
            return b;
        }

        public String next(){
            int b = skip();
            StringBuilder sb = new StringBuilder();
            while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public int nextInt(){
            int num = 0, b;
            boolean minus = false;
            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
            if(b == '-'){
                minus = true;
                b = readByte();
            }

            while(true){
                if(b >= '0' && b <= '9'){
                    num = (num<<3) + (num<<1) + ints[b];
                }else{
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }

        public long nextLong() {
            long num = 0;
            int b;
            boolean minus = false;
            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
            if(b == '-'){
                minus = true;
                b = readByte();
            }

            while(true){
                if(b >= '0' && b <= '9'){
                    num = (num<<3) + (num<<1) + ints[b];
                }else{
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
       /* public char nextChar() {
            return (char)skip();
        }*/

        public char[] next(int n){
            char[] buf = new char[n];
            int b = skip(), p = 0;
            while(p < n && !(isSpaceChar(b))){
                buf[p++] = (char)b;
                b = readByte();
            }
            return n == p ? buf : Arrays.copyOf(buf, p);
        }

        /*private char buff[] = new char[1005];
        public char[] nextCharArray(){
            int b = skip(), p = 0;
            while(!(isSpaceChar(b))){
                buff[p++] = (char)b;
                b = readByte();
            }
            return Arrays.copyOf(buff, p);
        }*/
    }
}",CorCod,395,395,quadratic
"import java.util.*;
import java.io.*;
public class X
{
	public static void main(String args[])throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		String s1 = br.readLine();
		String s2 = br.readLine();
		int i=0;
		char c1,c2;
		int cost = 0;
		while(i<n)
		{
			c1 = s1.charAt(i);
			c2 = s2.charAt(i);
			if(c1 != c2)
			{
				if((i+1)<n && s1.charAt(i+1) != s2.charAt(i+1) && s1.charAt(i) != s1.charAt(i+1))
				{
					cost +=1;
					i++;
				}
				else
				{
					cost +=1;
				}
			}
			i++;
		}
		System.out.println(cost);
	}
}",CorCod,102,102,linear
"
// A Java program for Dijkstra's single source shortest path algorithm. 
// The program is for adjacency matrix representation of the graph 
import
java.util.*; 
import
java.lang.*; 
import
java.io.*; 

class
ShortestPath 
{ 

// A utility function to find the vertex with minimum distance value, 

// from the set of vertices not yet included in shortest path tree 

static
final
int
V=
9
; 

int
minDistance(
int
dist[], Boolean sptSet[]) 

{ 

// Initialize min value 

int
min = Integer.MAX_VALUE, min_index=-
1
; 


for
(
int
v = 
0
; v < V; v++) 

if
(sptSet[v] == 
false
&& dist[v] <= min) 

{ 

min = dist[v]; 

min_index = v; 

} 


return
min_index; 

} 


// A utility function to print the constructed distance array 

void
printSolution(
int
dist[], 
int
n) 

{ 

System.out.println(
""Vertex Distance from Source""
); 

for
(
int
i = 
0
; i < V; i++) 

System.out.println(i+
"" tt ""
+dist[i]); 

} 


// Funtion that implements Dijkstra's single source shortest path 

// algorithm for a graph represented using adjacency matrix 

// representation 

void
dijkstra(
int
graph[][], 
int
src) 

{ 

int
dist[] = 
new
int
[V]; 
// The output array. dist[i] will hold 

// the shortest distance from src to i 


// sptSet[i] will true if vertex i is included in shortest 

// path tree or shortest distance from src to i is finalized 

Boolean sptSet[] = 
new
Boolean[V]; 


// Initialize all distances as INFINITE and stpSet[] as false 

for
(
int
i = 
0
; i < V; i++) 

{ 

dist[i] = Integer.MAX_VALUE; 

sptSet[i] = 
false
; 

} 


// Distance of source vertex from itself is always 0 

dist[src] = 
0
; 


// Find shortest path for all vertices 

for
(
int
count = 
0
; count < V-
1
; count++) 

{ 

// Pick the minimum distance vertex from the set of vertices 

// not yet processed. u is always equal to src in first 

// iteration. 

int
u = minDistance(dist, sptSet); 


// Mark the picked vertex as processed 

sptSet[u] = 
true
; 


// Update dist value of the adjacent vertices of the 

// picked vertex. 

for
(
int
v = 
0
; v < V; v++) 


// Update dist[v] only if is not in sptSet, there is an 

// edge from u to v, and total weight of path from src to 

// v through u is smaller than current value of dist[v] 

if
(!sptSet[v] && graph[u][v]!=
0
&& 

dist[u] != Integer.MAX_VALUE && 

dist[u]+graph[u][v] < dist[v]) 

dist[v] = dist[u] + graph[u][v]; 

} 


// print the constructed distance array 

printSolution(dist, V); 

} 


// Driver method 

public
static
void
main (String[] args) 

{ 

/* Let us create the example graph discussed above */

int
graph[][] = 
new
int
[][]{{
0
, 
4
, 
0
, 
0
, 
0
, 
0
, 
0
, 
8
, 
0
}, 

{
4
, 
0
, 
8
, 
0
, 
0
, 
0
, 
0
, 
11
, 
0
}, 

{
0
, 
8
, 
0
, 
7
, 
0
, 
4
, 
0
, 
0
, 
2
}, 

{
0
, 
0
, 
7
, 
0
, 
9
, 
14
, 
0
, 
0
, 
0
}, 

{
0
, 
0
, 
0
, 
9
, 
0
, 
10
, 
0
, 
0
, 
0
}, 

{
0
, 
0
, 
4
, 
14
, 
10
, 
0
, 
2
, 
0
, 
0
}, 

{
0
, 
0
, 
0
, 
0
, 
0
, 
2
, 
0
, 
1
, 
6
}, 

{
8
, 
11
, 
0
, 
0
, 
0
, 
0
, 
1
, 
0
, 
7
}, 

{
0
, 
0
, 
2
, 
0
, 
0
, 
0
, 
6
, 
7
, 
0
} 

}; 

ShortestPath t = 
new
ShortestPath(); 

t.dijkstra(graph, 
0
); 

} 
} 
//This code is contributed by Aakash Hasija ",CorCod,522,522,quadratic
"
// A simple Java program to 
//count pairs with difference k 
import
java.util.*; 
import
java.io.*; 

class
GFG { 


static
int
countPairsWithDiffK(
int
arr[], 

int
n, 
int
k) 

{ 

int
count = 
0
; 


// Pick all elements one by one 

for
(
int
i = 
0
; i < n; i++) 

{ 

// See if there is a pair 

// of this picked element 

for
(
int
j = i + 
1
; j < n; j++) 

if
(arr[i] - arr[j] == k || 

arr[j] - arr[i] == k) 

count++; 

} 

return
count; 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
arr[] = { 
1
, 
5
, 
3
, 
4
, 
2
}; 

int
n = arr.length; 

int
k = 
3
; 

System.out.println(
""Count of pairs with given diff is ""

+ countPairsWithDiffK(arr, n, k)); 

} 
} 

// This code is contributed 
// by Sahil_Bansall ",CorCod,495,495,quadratic
"import java.io.*;
import java.util.*;
public class Codechef{
	

    public static void main(String []args){
    			Scanner in = new Scanner(System.in);

    long n=in.nextLong();
		long m=in.nextLong();
		long k=in.nextLong();
		long l=in.nextLong();
 
		long j=((k+l)/m);
		if((k+l)%m!=0)j++;
		if((k+l>n) || j*m>n) {
			System.out.println(-1);
		}else {
			
			System.out.println(j);
		}


    }

}",CorCod,812,812,constant
"import java.io.*;

public class GennadyAndACardGame {
	public static void main(String[] args) throws IOException {
		BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));
		String line =null;
		String[] n={};
		String s=""NO"";
		while((line=bufr.readLine())!=null)    {
			if(""over"".equals(line))
				break;
			n=bufr.readLine().split("" "");
			for(int i=0;i<n.length;i++){
				if(n[i].contains(line.substring(0,1)) || n[i].contains(line.substring(1))){
					s=""YES"";
				}
			}
			System.out.println(s);
			s=""NO"";
			bufw.flush();
		}
		bufw.close();                          //关闭
	}
}
",CorCod,254,254,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Math;
public class A {

	public static void main(String[] args) {
		BufferedReader br = null;
		br = new BufferedReader(new InputStreamReader(System.in));
        String input;
		try {
			input = br.readLine();
			long n = Long.parseLong(input.split("" "")[0]);
	        long k = Long.parseLong(input.split("" "")[1]);
	        long red = (long) (Math.ceil((n * 2.0)/k));
	        long blue = (long) (Math.ceil((n * 5.0)/k));
	        long green = (long) (Math.ceil((n * 8.0)/k));
	        System.out.println(red + blue +green);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

}
",CorCod,791,791,constant
"import java.io.*;
import java.util.*;


public class Main {

    static StringBuilder data = new StringBuilder();
    final static FastReader in = new FastReader();


    public static void main(String[] args) {
        int n = in.nextInt(), m = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        int h=0,t=n-1,answ=0;
        while (h<n&&t>=0){
            if(a[h]<=m){
                answ++;
                h++;
            }else if(a[t]<=m){
                t--;
                answ++;
            }else{
                break;
            }
        }
        System.out.println(answ);
    }


    static void fileOut(String s) {
        File out = new File(""output.txt"");
        try {
            FileWriter fw = new FileWriter(out);
            fw.write(s);
            fw.flush();
            fw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        public FastReader(String path) {
            try {
                br = new BufferedReader(new
                        InputStreamReader(new FileInputStream(path)));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        float nextFloat() {
            return Float.parseFloat(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }


        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

}",CorCod,232,232,linear
"import java.io.*;
import java.util.*;

public class Main {
  static Scanner in = new Scanner(System.in);
  static PrintWriter out = new PrintWriter(System.out);
  
  public static void main(String[] args) {
    int n = in.nextInt();
    int m = in.nextInt();
    long boyMax = 0;
    int NBoyMax = 0;

    long sweets = 0;
    TreeSet<Long> boyMember = new TreeSet<>();
    for (int i = 0; i < n; i++) {
      long input = in.nextLong();
      boyMember.add(input);
      if (boyMax < input) {
        boyMax = input;
        NBoyMax = 1;
      } else if (boyMax == input) NBoyMax++;
      sweets += (input * m);
    }

    long smallestGirl = (long) 1e8 + 1;
    long sum = 0;
    for (int i = 0; i < m; i++) {
      long input = in.nextLong();
      sum += input;
      if (smallestGirl > input) smallestGirl = input;
    }

    if (smallestGirl < boyMember.last()) {
      out.println(-1);
    } else if (smallestGirl == boyMember.last()) {
      sweets += sum - boyMember.last() * m;
      out.println(sweets);
    } else {

      if (NBoyMax > 1) {
        sweets += sum - boyMember.last() * m;
        out.println(sweets);
      } else {
        Object[] boyList = boyMember.toArray();
        if (boyList.length > 1) {
          long boy = 0;
          boy = (long)boyList[boyList.length - 2];
          sweets += (sum - smallestGirl - boyMember.last() * (m - 1));
          sweets += (smallestGirl - boy);
          out.println(sweets);
        } else {
          out.println(-1);
        }
      }
    }

    in.close();
    out.close();
  }
}",CorCod,271,271,linear
"
// Java program to print sum of all substring of 
// a number represented as a string 
import
java.util.Arrays; 

class
GFG{ 


// Returns sum of all substring of num 

public
static
int
sumOfSubstrings(String num) 

{ 

int
n = num.length(); 


// allocate memory equal to length of string 

int
sumofdigit[] = 
new
int
[n]; 


// initialize first value with first digit 

sumofdigit[
0
] = num.charAt(
0
)-
'0'
; 

int
res = sumofdigit[
0
]; 


// loop over all digits of string 

for
(
int
i = 
1
; i < n; i++) 

{ 

int
numi = num.charAt(i)-
'0'
; 


// update each sumofdigit from previous value 

sumofdigit[i] = (i+
1
) * numi + 

10
* sumofdigit[i-
1
]; 


// add current value to the result 

res += sumofdigit[i]; 

} 


return
res; 

} 


// Driver code to test above methods 

public
static
void
main(String[] args) 

{ 

String num = 
""1234""
; 


System.out.println(sumOfSubstrings(num)); 


} 
} 
// This code is contributed by Arnav Kr. Mandal. ",CorCod,273,273,linear
"
// A Java program to implement greedy algorithm for graph coloring 
import
java.io.*; 
import
java.util.*; 
import
java.util.LinkedList; 

// This class represents an undirected graph using adjacency list 
class
Graph 
{ 

private
int
V; 
// No. of vertices 

private
LinkedList<Integer> adj[]; 
//Adjacency List 


//Constructor 

Graph(
int
v) 

{ 

V = v; 

adj = 
new
LinkedList[v]; 

for
(
int
i=
0
; i<v; ++i) 

adj[i] = 
new
LinkedList(); 

} 


//Function to add an edge into the graph 

void
addEdge(
int
v,
int
w) 

{ 

adj[v].add(w); 

adj[w].add(v); 
//Graph is undirected 

} 


// Assigns colors (starting from 0) to all vertices and 

// prints the assignment of colors 

void
greedyColoring() 

{ 

int
result[] = 
new
int
[V]; 


// Initialize all vertices as unassigned 

Arrays.fill(result, -
1
); 


// Assign the first color to first vertex 

result[
0
] = 
0
; 


// A temporary array to store the available colors. False 

// value of available[cr] would mean that the color cr is 

// assigned to one of its adjacent vertices 

boolean
available[] = 
new
boolean
[V]; 


// Initially, all colors are available 

Arrays.fill(available, 
true
); 


// Assign colors to remaining V-1 vertices 

for
(
int
u = 
1
; u < V; u++) 

{ 

// Process all adjacent vertices and flag their colors 

// as unavailable 

Iterator<Integer> it = adj[u].iterator() ; 

while
(it.hasNext()) 

{ 

int
i = it.next(); 

if
(result[i] != -
1
) 

available[result[i]] = 
false
; 

} 


// Find the first available color 

int
cr; 

for
(cr = 
0
; cr < V; cr++){ 

if
(available[cr]) 

break
; 

} 


result[u] = cr; 
// Assign the found color 


// Reset the values back to true for the next iteration 

Arrays.fill(available, 
true
); 

} 


// print the result 

for
(
int
u = 
0
; u < V; u++) 

System.out.println(
""Vertex ""
+ u + 
"" ---> Color ""

+ result[u]); 

} 


// Driver method 

public
static
void
main(String args[]) 

{ 

Graph g1 = 
new
Graph(
5
); 

g1.addEdge(
0
, 
1
); 

g1.addEdge(
0
, 
2
); 

g1.addEdge(
1
, 
2
); 

g1.addEdge(
1
, 
3
); 

g1.addEdge(
2
, 
3
); 

g1.addEdge(
3
, 
4
); 

System.out.println(
""Coloring of graph 1""
); 

g1.greedyColoring(); 


System.out.println(); 

Graph g2 = 
new
Graph(
5
); 

g2.addEdge(
0
, 
1
); 

g2.addEdge(
0
, 
2
); 

g2.addEdge(
1
, 
2
); 

g2.addEdge(
1
, 
4
); 

g2.addEdge(
2
, 
4
); 

g2.addEdge(
4
, 
3
); 

System.out.println(
""Coloring of graph 2 ""
); 

g2.greedyColoring(); 

} 
} 
// This code is contributed by Aakash Hasija ",CorCod,466,466,quadratic
"
// Java program to find missing Number 

class
Main { 

// Function to ind missing number 

static
int
getMissingNo(
int
a[], 
int
n) 

{ 

int
i, total; 

total = (n + 
1
) * (n + 
2
) / 
2
; 

for
(i = 
0
; i < n; i++) 

total -= a[i]; 

return
total; 

} 


/* program to test above function */

public
static
void
main(String args[]) 

{ 

int
a[] = { 
1
, 
2
, 
4
, 
5
, 
6
}; 

int
miss = getMissingNo(a, 
5
); 

System.out.println(miss); 

} 
} ",CorCod,146,146,linear
"import sun.reflect.generics.tree.Tree;

import java.io.*;
import java.math.BigInteger;
import java.net.Inet4Address;
import java.util.*;

public class l {
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////                                                                                                               /////////
////////                                                                                                               /////////
////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////
////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMMMM      MMMMMM      OOO      OOO        SSSS   SSS     EEEEEEEEEEEEE  /////////
////////   HHHH        HHHH  EEEEE           MMMM MMM  MMM MMMM    OOO          OOO    SSSS       SSS   EEEEE          /////////
////////   HHHH        HHHH  EEEEE           MMMM  MMMMMM  MMMM   OOO            OOO   SSSS             EEEEE          /////////
////////   HHHH        HHHH  EEEEE           MMMM          MMMM  OOO              OOO   SSSSSSS         EEEEE          /////////
////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO      SSSSSS       EEEEEEEEEEE    /////////
////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO         SSSSSSS   EEEEEEEEEEE    /////////
////////   HHHH        HHHH  EEEEE           MMMM          MMMM   OOO            OOO              SSSS  EEEEE          /////////
////////   HHHH        HHHH  EEEEE           MMMM          MMMM    OOO          OOO     SSS       SSSS  EEEEE          /////////
////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM      OOO      OOO        SSS    SSSS    EEEEEEEEEEEEE  /////////
////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////
////////                                                                                                               /////////
////////                                                                                                               /////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static long mod = (int) (1e9 + 7);
    static int n;
    static StringBuilder sol;

    static class pair implements Comparable<pair> {
        int L,R;
        public pair( int x,int y) {
            L=x;R=y;
        }


        public int compareTo(pair o) {
            if (L!=o.L)return L-o.L;
            return o.R-R;
        }
        public String toString(){
            return L+"" ""+R;
        }
    }
    static boolean is;
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        //FileWriter f = new FileWriter(""C:\\Users\\Ibrahim\\out.txt"");
        PrintWriter pw = new PrintWriter(System.out);
        int m = sc.nextInt();
        int n = sc.nextInt();
        int q = sc.nextInt();
        TreeSet<Integer>length= new TreeSet<>();
        length.add(0);
        length.add(n);
        TreeSet<Integer>width= new TreeSet<>();
        width.add(0);
        width.add(m);
        TreeMap<Integer,Integer>len= new TreeMap<>();
        len.put(n,1);
        TreeMap<Integer,Integer>wid= new TreeMap<>();
        wid.put(m,1);
        while (q-->0){
            String t= sc.next();
            if (t.equals(""H"")) {
                int x = sc.nextInt();
                int k1 = length.ceiling(x);
                int k2 = length.floor(x);
                if (x != k1) {
                    int s = k1 - k2;
                    int con = len.get(s);
                    if (con == 1) len.remove(s);
                    else len.put(s, con - 1);
                    len.put((k1 - x), len.getOrDefault((k1 - x), 0) + 1);
                    len.put((x - k2), len.getOrDefault((x - k2), 0) + 1);
                    length.add(x);
                }
            }
            else {
                int x = sc.nextInt();
                int k1 = width.ceiling(x);
                int k2 = width.floor(x);
                if (x != k1) {
                    int s = k1 - k2;
                    //System.out.println(s+"" ""+k1+"" ""+k2);
                    int con = wid.get(s);
                    if (con == 1) wid.remove(s);
                    else wid.put(s, con - 1);
                    wid.put((k1 - x), wid.getOrDefault((k1 - x), 0) + 1);
                    wid.put((x - k2), wid.getOrDefault((x - k2), 0) + 1);
                    width.add(x);
                }
            }
            pw.println(1l*len.lastKey()*wid.lastKey());
        }

        pw.flush();
    }
    static class Scanner {
        StringTokenizer st;
        BufferedReader br;
        public Scanner(FileReader r) {
            br = new BufferedReader(r);
        }

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            String x = next();
            StringBuilder sb = new StringBuilder(""0"");
            double res = 0, f = 1;
            boolean dec = false, neg = false;
            int start = 0;
            if (x.charAt(0) == '-') {
                neg = true;
                start++;
            }
            for (int i = start; i < x.length(); i++)
                if (x.charAt(i) == '.') {
                    res = Long.parseLong(sb.toString());
                    sb = new StringBuilder(""0"");
                    dec = true;
                } else {
                    sb.append(x.charAt(i));
                    if (dec)
                        f *= 10;
                }
            res += Long.parseLong(sb.toString()) / f;
            return res * (neg ? -1 : 1);
        }
        public boolean ready() throws IOException {
            return br.ready();
        }


    }

}",CorCod,734,734,nlogn
"
// A simple C++ program to count number of 
//substrings starting and ending with 1 

class
CountSubString 
{ 

int
countSubStr(
char
str[],
int
n) 

{ 

int
res = 
0
; 
// Initialize result 


// Pick a starting point 

for
(
int
i = 
0
; i<n; i++) 

{ 

if
(str[i] == 
'1'
) 

{ 

// Search for all possible ending point 

for
(
int
j = i + 
1
; j< n; j++) 

{ 

if
(str[j] == 
'1'
) 

res++; 

} 

} 

} 

return
res; 

} 


// Driver program to test the above function 

public
static
void
main(String[] args) 

{ 

CountSubString count = 
new
CountSubString(); 

String string = 
""00100101""
; 

char
str[] = string.toCharArray(); 

int
n = str.length; 

System.out.println(count.countSubStr(str,n)); 

} 
} ",CorCod,567,567,quadratic
"
// Java program to find the smallest positive value that cannot be 
// represented as sum of subsets of a given sorted array 
class
FindSmallestInteger 
{ 

// Returns the smallest number that cannot be represented as sum 

// of subset of elements from set represented by sorted array arr[0..n-1] 

int
findSmallest(
int
arr[], 
int
n) 

{ 

int
res = 
1
; 
// Initialize result 


// Traverse the array and increment 'res' if arr[i] is 

// smaller than or equal to 'res'. 

for
(
int
i = 
0
; i < n && arr[i] <= res; i++) 

res = res + arr[i]; 


return
res; 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

FindSmallestInteger small = 
new
FindSmallestInteger(); 

int
arr1[] = {
1
, 
3
, 
4
, 
5
}; 

int
n1 = arr1.length; 

System.out.println(small.findSmallest(arr1, n1)); 


int
arr2[] = {
1
, 
2
, 
6
, 
10
, 
11
, 
15
}; 

int
n2 = arr2.length; 

System.out.println(small.findSmallest(arr2, n2)); 


int
arr3[] = {
1
, 
1
, 
1
, 
1
}; 

int
n3 = arr3.length; 

System.out.println(small.findSmallest(arr3, n3)); 


int
arr4[] = {
1
, 
1
, 
3
, 
4
}; 

int
n4 = arr4.length; 

System.out.println(small.findSmallest(arr4, n4)); 


} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,46,46,linear
"import java.io.*;
import java.util.*;

public class A4 {

    public BufferedReader input;
    public PrintWriter output;
    public StringTokenizer stoken = new StringTokenizer("""");

    public static void main(String[] args) throws IOException {
        new A4();
    }

    A4() throws IOException {
        input = new BufferedReader(new InputStreamReader(System.in));
        output = new PrintWriter(System.out);
        run();
        input.close();
        output.close();
    }

    private void run() throws IOException {
        int n = Math.toIntExact(nextLong());
        int m = Math.toIntExact(nextLong());
        int[] coor = new int[n + 1];
        int[] ss = new int[n + 1];
        for (int i = 0; i < n; i++) {
            coor[i] = Math.toIntExact(nextLong());
        }
        coor[n] = 1000000000;
        Arrays.sort(coor);
        for (int i = 0; i < m; i++) {
            long x1 = nextLong();
            long x2 = nextLong();
            nextLong();
            if (x1 == 1 && x2 >= coor[0]) {
                int l = 0;
                int r = n + 1;
                while (r - l > 1) {
                    int mi = (r + l) / 2;
                    if (coor[mi] > x2) {
                        r = mi;
                    } else {
                        l = mi;
                    }
                }
                ss[l]++;
            }
        }
        long[] ans = new long[n + 1];
        ans[n] = ss[n] + n;
        long min = ans[n];
        for (int i = n - 1; i > -1; i--) {
            ans[i] = ans[i + 1] - 1 + ss[i];
            if (ans[i] < min) {
                min = ans[i];
            }
        }
        System.out.println(min);
    }

    private Long nextLong() throws NumberFormatException, IOException {
        return Long.parseLong(nextString());
    }

    private String nextString() throws IOException {
        while (!stoken.hasMoreTokens()) {
            String st = input.readLine();
            stoken = new StringTokenizer(st);
        }
        return stoken.nextToken();
    }
}",CorCod,636,636,nlogn
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;


public class pr988B {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        int n = Integer.parseInt(br.readLine());

        ArrayList<String> a = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            a.add(br.readLine());
        }

        if(solve(n, a)){
            out.println(""YES"");
            for (String s : a) {
                out.println(s);
            }
        }
        else
            out.println(""NO"");

        out.flush();
        out.close();
    }

    private static boolean solve(int n, ArrayList<String> a) {
        a.sort(Comparator.comparingInt(String::length));
        for (int i = 0; i < n - 1; i++) {
            if(!a.get(i+1).contains(a.get(i))) return false;
        }
        return true;
    }
}
",CorCod,684,684,nlogn
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = in.nextInt();
            }
            int inv = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < i; j++) {
                    if (a[j] > a[i]) {
                        inv++;
                    }
                }
            }
            int m = in.nextInt();
            for (int i = 0; i < m; i++) {
                int l = in.nextInt();
                int r = in.nextInt();
                int s = (r - l + 1) * (r - l) / 2;
                inv = (inv + s) % 2;
                out.println(inv % 2 == 0 ? ""even"" : ""odd"");
            }
        }

    }

    static class InputReader {
        private BufferedReader reader;
        private StringTokenizer stt;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream));
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                return null;
            }
        }

        public String next() {
            while (stt == null || !stt.hasMoreTokens()) {
                stt = new StringTokenizer(nextLine());
            }
            return stt.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",CorCod,485,485,quadratic
"import java.util.*;
import java.lang.*;
import java.io.*;

public class java2 {
    public static void main(String[] args) {
        Scanner r = new Scanner(System.in);
        int n=r.nextInt();
        int []l=new int[1005];
        int []ri=new int[1005];
        int []candy=new int[1005];
        for(int i=1;i<=n;++i)
        {
            l[i]=r.nextInt();
        }
        for(int i=1;i<=n;++i)
        {
            ri[i]=r.nextInt();
        }
        for(int i=1;i<=n;++i)
        {
            if(l[i]>i-1||ri[i]>n-i)
            {
                System.out.println(""NO"");
                System.exit(0);
            }
            candy[i]=n-l[i]-ri[i];
        }
        for(int i=1;i<=n;++i)
        {
            int left=0,right=0;
            for(int j=1;j<=i-1;++j)
            {
                if(candy[j]>candy[i])
                {
                    ++left;
                }
            }
            for(int j=i+1;j<=n;++j)
            {
                if(candy[j]>candy[i])
                {
                    ++right;
                }
            }
            if(left!=l[i]||right!=ri[i])
            {
                System.out.println(""NO"");
                System.exit(0);
            }
        }
        System.out.println(""YES"");
        for(int i=1;i<=n;++i)
        {
            System.out.print(candy[i]+"" "");
        }
    }
}
",CorCod,487,487,quadratic
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Pradyumn
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        FastReader in;
        PrintWriter out;
        int n;

        public void solve(int testNumber, FastReader in, PrintWriter out) {
            this.in = in;
            this.out = out;
            n = in.nextInt();
            if (n % 4 != 0) {
                out.println(""! -1"");
                return;
            }
            int low = 0;
            int high = n >> 1;
            int fSign = Integer.signum(BValue(low));
            if (fSign == 0) {
                out.println(""! "" + (low + 1));
                return;
            }
            while (high - low > 1) {
                int mid = (high + low) >> 1;
                int mSign = Integer.signum(BValue(mid));
                if (mSign == 0) {
                    out.println(""! "" + (mid + 1));
                    return;
                }
                if (mSign == -fSign) {
                    high = mid;
                } else {
                    low = mid;
                }
            }
            out.println(""! -1"");
        }

        public int BValue(int index) {
            out.println(""? "" + (index + 1));
            out.flush();
            int f = in.nextInt();
            out.println(""? "" + (index + 1 + (n >> 1)));
            out.flush();
            int s = in.nextInt();
            return f - s;
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int pnumChars;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        private int pread() {
            if (pnumChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= pnumChars) {
                curChar = 0;
                try {
                    pnumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (pnumChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            int res = 0;
            do {
                if (c == ',') {
                    c = pread();
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",CorCod,928,928,logn
"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Main
{
	public static void main (String[] args) throws java.lang.Exception
	{
		Scanner s = new Scanner(System.in);
		int n = Integer.parseInt(s.nextLine());
		int ans = 0;
		String inp = s.nextLine();
		for(int i=0;i<n;i++) {
			char k = inp.charAt(i);
			if (k == '+')
				ans++;
			if (k == '-') {
				if (ans>0)
					ans--;
			}
		}
		System.out.println(ans);
	}
}",CorCod,299,299,linear
"import java.util.*;
public class Main{
	public static void main(String args[]){
		Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int k=sc.nextInt();
        if(n==k){
            String s=new String();
            for(int i=0;i<k;i++){
                s=s+""1"";
            }
            System.out.println(s);
        }
        else{
            int a=(n-k)/2;
            String s=new String();
            while(s.length()<n){
                for(int i=0;i<a && s.length()<n;i++){
                    s=s+""1"";
                }
                if(s.length()<n){
                    s=s+""0"";
                }
            }
            System.out.println(s);
        }
	}
}",CorCod,48,48,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
public class Code {

	public static void main(String[] args) throws IOException{
		 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		 int n = Integer.parseInt(br.readLine());
		 HashMap<Double,Integer>h = new HashMap<>();
		 double [] temp = new double[n];
		 int m = 0;
		 for(int i=0;i<n;i++) {
			 String l = br.readLine();
			 int[] x = new int[4];
			 int k=0;
			 boolean t = false;
			 for(int j=0;j<l.length();j++) {
				 if(l.charAt(j)=='(' || l.charAt(j)=='+' || l.charAt(j)==')' || l.charAt(j)=='/')
					 x[k++] = j;
			 }
			 double a = Integer.parseInt(l.substring(x[0]+1,x[1]));
			 double b = Integer.parseInt(l.substring(x[1]+1, x[2]));
			 double c = Integer.parseInt(l.substring(x[3]+1));
			 temp[m++] = (a+b)/c;
			 //System.out.print((a+b)/c + "" "");
			if(h.containsKey((a+b)/c))
					h.put((a+b)/c, h.get((a+b)/c)+1);
			else
				h.put((a+b)/c, 1);
		 }
		 //System.out.println(h);
		 for(int i=0;i<n;i++) {
			 System.out.print(h.get(temp[i]) + "" "");
		 }
	}
	}
",CorCod,378,378,linear
"
// Java program for finding postorder 
// traversal of BST from preorder traversal 

import
java.util.* ; 

class
Solution 
{ 
static
class
INT 
{ 

int
data; 

INT(
int
d) 

{ 

data=d; 

} 
} 

// Function to find postorder traversal from 
// preorder traversal. 
static
void
findPostOrderUtil(
int
pre[], 
int
n, 
int
minval, 

int
maxval, INT preIndex) 
{ 


// If entire preorder array is traversed then 

// return as no more element is left to be 

// added to post order array. 

if
(preIndex.data == n) 

return
; 


// If array element does not lie in range specified, 

// then it is not part of current subtree. 

if
(pre[preIndex.data] < minval || pre[preIndex.data] > maxval) { 

return
; 

} 


// Store current value, to be printed later, after 

// printing left and right subtrees. Increment 

// preIndex to find left and right subtrees, 

// and pass this updated value to recursive calls. 

int
val = pre[preIndex.data]; 

preIndex.data++; 


// All elements with value between minval and val 

// lie in left subtree. 

findPostOrderUtil(pre, n, minval, val, preIndex); 


// All elements with value between val and maxval 

// lie in right subtree. 

findPostOrderUtil(pre, n, val, maxval, preIndex); 


System.out.print( val + 
"" ""
); 
} 

// Function to find postorder traversal. 
static
void
findPostOrder(
int
pre[], 
int
n) 
{ 


// To store index of element to be 

// traversed next in preorder array. 

// This is passed by reference to 

// utility function. 

INT preIndex = 
new
INT(
0
); 


findPostOrderUtil(pre, n, Integer.MIN_VALUE, 

Integer.MAX_VALUE, preIndex); 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

int
pre[] = { 
40
, 
30
, 
35
, 
80
, 
100
}; 


int
n = pre.length; 


// Calling function 

findPostOrder(pre, n); 
} 
} 

// This code is contributed 
// by Arnab Kundu ",CorCod,38,38,linear
"import java.util.*;
import java.util.Map.Entry;
import java.io.*;
import java.lang.reflect.Array;
import java.math.*;
import java.security.SecureRandom;

public class WCS {
	
	public static class Vector implements Comparable <Vector>  {
		long x, y;
		int position;
		Vector first, second;
		boolean toReverse;
		
		public Vector(long xx, long yy, int p) {
			x = xx;
			y = yy;
			position = p;
			first = null;
			second = null;
			toReverse = false;
		}
		
		public Vector negate() {
			Vector vv = new Vector(-x, -y, position);
			vv.first = first;
			vv.second = second;
			vv.toReverse = !toReverse;
			return vv;
		}
		
		public Vector add(Vector v) {
			Vector sum = new Vector(this.x + v.x, this.y + v.y, position);
			sum.first = this;
			sum.second = v;
			return sum;
		}
		
		public Vector subtract(Vector v) {
			return this.add(v.negate());
		}
		
		public double euclideanNorm() {
			return Math.sqrt(x * x + y * y);
		}
		
		@Override
		public int compareTo(Vector v) {
			double thisa = Math.atan2(this.y, this.x);
			double va = Math.atan2(v.y, v.x);
			if(thisa < 0)
				thisa += 2 * Math.PI;
			if(va < 0)
				va += 2 * Math.PI;
			if(thisa < va)
				return -1;
			if(thisa > va)
				return 1;
			return Integer.compare(this.position, v.position);
		}
		
		@Override
		public String toString() {
			return x + "" "" + y;
		}
	}
	
	public static void dfs(Vector curr, int[] ans) {
		if(curr.first == null) {
			ans[curr.position] = curr.toReverse ? -1 : 1;
			return;
		}
		curr.first.toReverse ^= curr.toReverse;
		curr.second.toReverse ^= curr.toReverse;
		dfs(curr.first, ans);
		dfs(curr.second, ans);
	}
	
	public static boolean ok(Vector v1, Vector v2) {
		return v1.add(v2).euclideanNorm() <= Math.max(v1.euclideanNorm(), v2.euclideanNorm());
	}
	
	public static void stop(long k) {
		long time = System.currentTimeMillis();
		while(System.currentTimeMillis() - time < k);
	}
	
	public static void main(String[] args) throws IOException {
		int n = in.nextInt();
		TreeSet <Vector> vectors = new TreeSet <> ();
		for(int i = 0; i < n; i ++) {
			Vector v = new Vector(in.nextLong(), in.nextLong(), i);
			vectors.add(v);
		}
		while(vectors.size() > 2) {
			//System.out.println(vectors);
			//stop(500);
			
			TreeSet <Vector> support = new TreeSet <> ();
			
			while(vectors.size() > 0) {
				Vector curr = vectors.pollFirst();
				Vector next1 = vectors.higher(curr);
				Vector next2 = vectors.lower(curr.negate());
				Vector next3 = vectors.higher(curr.negate());
				Vector next4 = vectors.lower(curr);
				
				//System.out.println(""CURR: "" + curr + ""\n"" + next1 + ""\n"" + next2);
				
				if(next1 != null) {
					if(ok(curr, next1)) {
						support.add(curr.add(next1));
						vectors.remove(next1);
						continue;
					}
				}
				if(next1 != null) {
					if(ok(curr, next1.negate())) {
						support.add(curr.subtract(next1));
						vectors.remove(next1);
						continue;
					}
				}
				if(next2 != null) {
					if(ok(curr, next2)) {
						support.add(curr.add(next2));
						vectors.remove(next2);
						continue;
					}
				}
				if(next2 != null) {
					if(ok(curr, next2.negate())) {
						support.add(curr.subtract(next2));
						vectors.remove(next2);
						continue;
					}
				}
				if(next3 != null) {
					if(ok(curr, next3)) {
						support.add(curr.add(next3));
						vectors.remove(next3);
						continue;
					}
				}
				if(next3 != null) {
					if(ok(curr, next3.negate())) {
						support.add(curr.subtract(next3));
						vectors.remove(next3);
						continue;
					}
				}
				if(next4 != null) {
					if(ok(curr, next4)) {
						support.add(curr.add(next4));
						vectors.remove(next4);
						continue;
					}
				}
				if(next4 != null) {
					if(ok(curr, next4.negate())) {
						support.add(curr.subtract(next4));
						vectors.remove(next4);
						continue;
					}
				}
				
				support.add(curr);
			}
			
			vectors = support;
		}
		
		if(vectors.size() == 2) {
			Vector curr = vectors.pollFirst();
			Vector next = vectors.pollFirst();
			Vector add = curr.add(next);
			Vector sub = curr.subtract(next);
			if(sub.euclideanNorm() <= add.euclideanNorm())
				vectors.add(sub);
			else
				vectors.add(add);
		}
		
		//System.out.println(vectors.first().euclideanNorm());
		
		StringBuilder buffer = new StringBuilder();
		int[] ans = new int[n];
		dfs(vectors.pollFirst(), ans);
		for(int i = 0; i < n; i ++)
			buffer.append(ans[i] + "" "");
		System.out.println(buffer);
	}
    
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
 
        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
 
        BigInteger nextBigInteger() {
        	return new BigInteger(in.next());
        }
        
        int nextInt() {
            return Integer.parseInt(next());
        }
        
        char nextChar() {
            return in.next().charAt(0);
        }
 
        long nextLong() {
            return Long.parseLong(next());
        }
 
        double nextDouble() {
            return Double.parseDouble(next());
        }
 
        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
    
    static FastReader in = new FastReader();
    static OutputStream out = new BufferedOutputStream(System.out);
    
    public static byte[] toByte(Object o) {
        return String.valueOf(o).getBytes();
    }
    
    public static void sop(Object o) {
        System.out.print(o);
    }
}",CorCod,692,692,nlogn
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class TrickyAlchemy {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		long a = nextLong();
		long b = nextLong();
		long x = nextLong();
		long y = nextLong();
		long z = nextLong();
		System.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",CorCod,807,807,constant
"
import java.util.*;
import java.math.*;
public class Main {
	static class en implements Comparable<en>{
		int w,h,dex;
		en(int a,int b,int c){
			w=a;
			h=b;
			dex=c;
		}
		public int compareTo(en o) {
			return w-o.w;
		}
	}
	public static void main(String args[]) {
		Scanner cin=new Scanner(System.in);
		int n=cin.nextInt(),ww=cin.nextInt(),hh=cin.nextInt(),num=0;
		Queue<en> que=new PriorityQueue();
		for(int i=1;i<=n;i++) {
			int a=cin.nextInt(),b=cin.nextInt();
			if(a>ww&&b>hh) {
				que.add(new en(a,b,i));
				num++;
			}
		}
		int dp[][]=new int[num+5][2],ans=0,ad=0,arr[][]=new int[num+5][3];
		for(int i=1;i<=num;i++) {
			arr[i][0]=que.peek().w;
			arr[i][1]=que.peek().h;
			arr[i][2]=que.remove().dex;
		}
		for(int i=1;i<=num;i++) {
			int te=0,td=0;
			for(int j=1;j<i;j++) {
				if(arr[j][0]<arr[i][0]&&arr[j][1]<arr[i][1]&&dp[j][0]>te) {
					te=dp[j][0];
					td=j;
				}
			}
			dp[i][0]=te+1;
			dp[i][1]=td;
			if(dp[i][0]>ans) {
				ans=dp[i][0];
				ad=i;
			}
		}
		System.out.println(ans);
		ArrayList<Integer> an=new ArrayList();
		int u=ad;
		while(u>0) {
			an.add(arr[u][2]);
			u=dp[u][1];
			//System.out.println(u);
		}
		for(int i=an.size()-1;i>=0;i--) System.out.print(an.get(i)+"" "");
	}
}
",CorCod,413,413,quadratic
"import java.io.*;
import java.util.*;

public class Main {

    private static void solve(InputReader in, OutputWriter out) {
        int n = in.nextInt();

        List<List<Integer>> g = new ArrayList<>(n + 1);
        for (int i = 0; i < n + 1; i++) {
            g.add(new LinkedList<>());
        }

        int degree1 = 0, degree2 = 0, root = 0;
        for (int i = 0; i < n - 1; i++) {
            int a = in.nextInt();
            int b = in.nextInt();

            g.get(a).add(b);
            g.get(b).add(a);

            if (g.get(a).size() > degree1) {

                if (a == root) {
                    degree1 = g.get(a).size();
                } else {
                    degree2 = degree1;
                    degree1 = g.get(a).size();
                    root = a;
                }

            } else if (g.get(a).size() > degree2) {
                degree2 = g.get(a).size();
            }

            if (g.get(b).size() > degree1) {

                if (b == root) {
                    degree1 = g.get(b).size();
                } else {
                    degree2 = degree1;
                    degree1 = g.get(b).size();
                    root = b;
                }

            } else if (g.get(b).size() > degree2) {
                degree2 = g.get(b).size();
            }
        }

        if (degree2 > 2) {
            out.print(""No"");
        } else {
            out.println(""Yes"");

            List<Integer> leaves = new LinkedList<>();
            for (int i = 1; i <= n; i++) {
                if (i != root) {
                    if (g.get(i).size() == 1) {
                        leaves.add(i);
                    }
                }
            }

            out.println(leaves.size());
            for (int i : leaves) {
                out.println(root + "" "" + i);
            }
        }
    }

    private static void shuffleArray(int[] array) {
        int index;
        Random random = new Random();
        for (int i = array.length - 1; i > 0; i--) {
            index = random.nextInt(i + 1);
            if (index != i) {
                array[index] ^= array[i];
                array[i] ^= array[index];
                array[index] ^= array[i];
            }
        }
    }

    public static void main(String[] args) {
        InputReader in = new InputReader(System.in);
        OutputWriter out = new OutputWriter(System.out);
        solve(in, out);
        in.close();
        out.close();
    }

    private static class InputReader {
        private BufferedReader br;
        private StringTokenizer st;

        InputReader(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
            st = null;
        }

        String nextLine() {
            String line = null;
            try {
                line = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return line;
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                String line = nextLine();
                if (line == null) return null;
                st = new StringTokenizer(line);
            }
            return st.nextToken();
        }

        byte nextByte() {
            return Byte.parseByte(next());
        }

        short nextShort() {
            return Short.parseShort(next());
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        void close() {
            try {
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private static class OutputWriter {
        BufferedWriter bw;

        OutputWriter(OutputStream os) {
            bw = new BufferedWriter(new OutputStreamWriter(os));
        }

        void print(int i) {
            print(Integer.toString(i));
        }

        void println(int i) {
            println(Integer.toString(i));
        }

        void print(long l) {
            print(Long.toString(l));
        }

        void println(long l) {
            println(Long.toString(l));
        }

        void print(double d) {
            print(Double.toString(d));
        }

        void println(double d) {
            println(Double.toString(d));
        }

        void print(boolean b) {
            print(Boolean.toString(b));
        }

        void println(boolean b) {
            println(Boolean.toString(b));
        }

        void print(char c) {
            try {
                bw.write(c);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        void println(char c) {
            println(Character.toString(c));
        }

        void print(String s) {
            try {
                bw.write(s);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        void println(String s) {
            print(s);
            print('\n');
        }

        void close() {
            try {
                bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
",CorCod,345,345,linear
"import java.util.Scanner;

public class Amain {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int a[] = new int[100005];
		int vis[] = new int[100005];
		int maxx = -1;
		int n , k ;
		int e = 0  , s = 0 ;
		int ans = 0  ;
		
		n=sc.nextInt();
		k=sc.nextInt();

		for(int i = 1 ; i<=n ; i++ )
		{
			a[i]=sc.nextInt() ;
			if(a[i]== 1 )
			{
				e++ ; //记录带有test标签的网页个数 ; 
			}
			else
			{
				s++ ;// 记录带有社交标签的网站个数; 
			}
		}
	    // 题目中的  c=b+i⋅k 大概就是每隔 k 的就关一个网页 
		for(int i = 1 ; i<=k  ;i++ )
		{
			int e1 = 0 ; // 记录应该关闭的带有test标签的网页个数 
			int s1 = 0 ;  // 记录应该关闭的带有社交标签的网页个数
			for(int j = i ; j<=n ;j+=k )
			{
				if(a[j]==1 )
				{
					e1++ ;
				}
				else
				{
					s1++ ;
				}
			}
	        // s-s1 就是还剩的带有社交标签的网页个数;
	        // e-e1 就是还剩的带有test标签的网页个数; 
	 
			ans = Math.abs(  (s-s1)-(e-e1)) ; // | s -e |
			maxx = Math.max(maxx,ans) ; // 求最大的
		}
       System.out.print(maxx);
	}

}
",CorCod,488,488,quadratic
"import java.util.Scanner;

public class GenerateLogin {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String a = scan.next();
		String b = scan.next();
		char last = b.charAt(0);
		String ans = """"+a.charAt(0);
		for(int i = 1;i<a.length();i++){
			if(a.charAt(i)>=last)break;
			ans+=a.charAt(i);
		}
		ans+=last;
		System.out.println(ans);
	}

}
",CorCod,195,195,linear
"
// Java program to count 
// inversions in an array 
class
Test { 

static
int
arr[] = 
new
int
[] { 
1
, 
20
, 
6
, 
4
, 
5
}; 


static
int
getInvCount(
int
n) 

{ 

int
inv_count = 
0
; 

for
(
int
i = 
0
; i < n - 
1
; i++) 

for
(
int
j = i + 
1
; j < n; j++) 

if
(arr[i] > arr[j]) 

inv_count++; 


return
inv_count; 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

System.out.println(
""Number of inversions are ""

+ getInvCount(arr.length)); 

} 
} ",CorCod,520,520,quadratic
"
// Java code to find a pair with given sum 
// in a Balanced BST 
import
java.util.ArrayList; 

// A binary tree node 
class
Node { 


int
data; 

Node left, right; 


Node(
int
d) 

{ 

data = d; 

left = right = 
null
; 

} 
} 

class
BinarySearchTree { 


// Root of BST 

Node root; 


// Constructor 

BinarySearchTree() 

{ 

root = 
null
; 

} 


// Inorder traversal of the tree 

void
inorder() 

{ 

inorderUtil(
this
.root); 

} 


// Utility function for inorder traversal of the tree 

void
inorderUtil(Node node) 

{ 

if
(node == 
null
) 

return
; 


inorderUtil(node.left); 

System.out.print(node.data + 
"" ""
); 

inorderUtil(node.right); 

} 


// This method mainly calls insertRec() 

void
insert(
int
key) 

{ 

root = insertRec(root, key); 

} 


/* A recursive function to insert a new key in BST */

Node insertRec(Node root, 
int
data) 

{ 


/* If the tree is empty, return a new node */

if
(root == 
null
) { 

root = 
new
Node(data); 

return
root; 

} 


/* Otherwise, recur down the tree */

if
(data < root.data) 

root.left = insertRec(root.left, data); 

else
if
(data > root.data) 

root.right = insertRec(root.right, data); 


return
root; 

} 


// Method that adds values of given BST into ArrayList 

// and hence returns the ArrayList 

ArrayList<Integer> treeToList(Node node, ArrayList<Integer> 

list) 

{ 

// Base Case 

if
(node == 
null
) 

return
list; 


treeToList(node.left, list); 

list.add(node.data); 

treeToList(node.right, list); 


return
list; 

} 


// method that checks if there is a pair present 

boolean
isPairPresent(Node node, 
int
target) 

{ 

// This list a1 is passed as an argument 

// in treeToList method 

// which is later on filled by the values of BST 

ArrayList<Integer> a1 = 
new
ArrayList<>(); 


// a2 list contains all the values of BST 

// returned by treeToList method 

ArrayList<Integer> a2 = treeToList(node, a1); 


int
start = 
0
; 
// Starting index of a2 


int
end = a2.size() - 
1
; 
// Ending index of a2 


while
(start < end) { 


if
(a2.get(start) + a2.get(end) == target) 
// Target Found! 

{ 

System.out.println(
""Pair Found: ""
+ a2.get(start) + 
"" + ""
+ a2.get(end) + 
"" ""

+ 
""= ""
+ target); 

return
true
; 

} 


if
(a2.get(start) + a2.get(end) > target) 
// decrements end 

{ 

end--; 

} 


if
(a2.get(start) + a2.get(end) < target) 
// increments start 

{ 

start++; 

} 

} 


System.out.println(
""No such values are found!""
); 

return
false
; 

} 


// Driver function 

public
static
void
main(String[] args) 

{ 

BinarySearchTree tree = 
new
BinarySearchTree(); 

/* 

15 

/ \ 

10 20 

/ \ / \ 

8 12 16 25 */

tree.insert(
15
); 

tree.insert(
10
); 

tree.insert(
20
); 

tree.insert(
8
); 

tree.insert(
12
); 

tree.insert(
16
); 

tree.insert(
25
); 


tree.isPairPresent(tree.root, 
33
); 

} 
} 

// This code is contributed by Kamal Rawal ",CorCod,158,158,linear
"
// Java program for special level order traversal 

import
java.util.LinkedList; 
import
java.util.Queue; 

/* Class containing left and right child of current 

node and key value*/
class
Node 
{ 

int
data; 

Node left, right; 


public
Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root; 


/* Given a perfect binary tree, print its nodes in specific 

level order */

void
printSpecificLevelOrder(Node node) 

{ 

if
(node == 
null
) 

return
; 


// Let us print root and next level first 

System.out.print(node.data); 


// Since it is perfect Binary Tree, right is not checked 

if
(node.left != 
null
) 

System.out.print(
"" ""
+ node.left.data + 
"" ""
+ node.right.data); 


// Do anything more if there are nodes at next level in 

// given perfect Binary Tree 

if
(node.left.left == 
null
) 

return
; 


// Create a queue and enqueue left and right children of root 

Queue<Node> q = 
new
LinkedList<Node>(); 

q.add(node.left); 

q.add(node.right); 


// We process two nodes at a time, so we need two variables 

// to store two front items of queue 

Node first = 
null
, second = 
null
; 


// traversal loop 

while
(!q.isEmpty()) 

{ 

// Pop two items from queue 

first = q.peek(); 

q.remove(); 

second = q.peek(); 

q.remove(); 


// Print children of first and second in reverse order 

System.out.print(
"" ""
+ first.left.data + 
"" ""
+second.right.data); 

System.out.print(
"" ""
+ first.right.data + 
"" ""
+second.left.data); 


// If first and second have grandchildren, enqueue them 

// in reverse order 

if
(first.left.left != 
null
) 

{ 

q.add(first.left); 

q.add(second.right); 

q.add(first.right); 

q.add(second.left); 

} 

} 

} 


// Driver program to test for above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
1
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
3
); 


tree.root.left.left = 
new
Node(
4
); 

tree.root.left.right = 
new
Node(
5
); 

tree.root.right.left = 
new
Node(
6
); 

tree.root.right.right = 
new
Node(
7
); 


tree.root.left.left.left = 
new
Node(
8
); 

tree.root.left.left.right = 
new
Node(
9
); 

tree.root.left.right.left = 
new
Node(
10
); 

tree.root.left.right.right = 
new
Node(
11
); 

tree.root.right.left.left = 
new
Node(
12
); 

tree.root.right.left.right = 
new
Node(
13
); 

tree.root.right.right.left = 
new
Node(
14
); 

tree.root.right.right.right = 
new
Node(
15
); 


tree.root.left.left.left.left = 
new
Node(
16
); 

tree.root.left.left.left.right = 
new
Node(
17
); 

tree.root.left.left.right.left = 
new
Node(
18
); 

tree.root.left.left.right.right = 
new
Node(
19
); 

tree.root.left.right.left.left = 
new
Node(
20
); 

tree.root.left.right.left.right = 
new
Node(
21
); 

tree.root.left.right.right.left = 
new
Node(
22
); 

tree.root.left.right.right.right = 
new
Node(
23
); 

tree.root.right.left.left.left = 
new
Node(
24
); 

tree.root.right.left.left.right = 
new
Node(
25
); 

tree.root.right.left.right.left = 
new
Node(
26
); 

tree.root.right.left.right.right = 
new
Node(
27
); 

tree.root.right.right.left.left = 
new
Node(
28
); 

tree.root.right.right.left.right = 
new
Node(
29
); 

tree.root.right.right.right.left = 
new
Node(
30
); 

tree.root.right.right.right.right = 
new
Node(
31
); 


System.out.println(
""Specific Level Order traversal of binary""

+
""tree is ""
); 

tree.printSpecificLevelOrder(tree.root); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",CorCod,119,119,linear
"import java.io.*;
import java.util.*;

public class Solution{
    
    static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;

        public FastReader()
        {
            br = new BufferedReader(new
                     InputStreamReader(System.in));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt()
        {
            return Integer.parseInt(next());
        }

        long nextLong()
        {
            return Long.parseLong(next());
        }

        double nextDouble()
        {
            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
    
    public static void main(String args[] ) {
        
        FastReader sc = new FastReader();
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] arr = new int[105];
        
        for(int i=0;i<m;i++){
            int a = sc.nextInt();
            arr[a]++;
        }
        
        for(int i=1;i<=1000;i++){
            int sum=0;
            
            for(int a:arr){
                if(a!=0){
                    sum+=(a/i);
                }
            }
            
            
            if(sum<n){
                System.out.println(i-1);
                return;
            }
            
        }
    }

}
",CorCod,544,544,quadratic
"
// Java Program to construct ancestor matrix for a given tree 
import
java.util.*; 

class
GFG 
{ 

// ancestorMatrix function to populate the matrix of 

public
static
void
ancestorMatrix(Node root , 

int
matrix[][],
int
size) 

{ 


// base case: 

if
(root==
null
) 

return
; 


// call recursively for a preorder {left} 

ancestorMatrix(root.left, matrix, size); 


// call recursively for preorder {right} 

ancestorMatrix(root.right, matrix, size); 


// here we will reach the root node automatically 

// try solving on pen and paper 


if
(root.left != 
null
) 

{ 

// make the current node as parent of its children node 

matrix[root.data][root.left.data] = 
1
; 


// iterate through all the columns of children node 

// all nodes which are children to 

// children of root node will also 

// be children of root node 

for
(
int
i = 
0
; i < size; i++) 

{ 

// if children of root node is a parent 

// of someone (i.e 1) then make that node 

// as children of root also 

if
(matrix[root.left.data][i] == 
1
) 

matrix[root.data][i] = 
1
; 

} 

} 


// same procedure followed for right node as well 

if
(root.right != 
null
) 

{ 

matrix[root.data][root.right.data] = 
1
; 


for
(
int
i = 
0
; i < size; i++) 

{ 

if
(matrix[root.right.data][i]==
1
) 

matrix[root.data][i] = 
1
; 

} 

} 



} 


// Driver program to test the program 

public
static
void
main(String[] args) 

{ 


// construct the binary tree as follows 

Node tree_root = 
new
Node(
5
); 

tree_root.left = 
new
Node (
1
); 

tree_root.right = 
new
Node(
2
); 

tree_root.left.left = 
new
Node(
0
); 

tree_root.left.right = 
new
Node(
4
); 

tree_root.right.left = 
new
Node(
3
); 


// size of matrix 

int
size = 
6
; 

int
matrix [][] = 
new
int
[size][size]; 


ancestorMatrix(tree_root, matrix, size); 


for
(
int
i = 
0
; i < size; i++) 

{ 

for
(
int
j = 
0
; j < size; j++) 

{ 

System.out.print(matrix[i][j]+
"" ""
); 

} 

System.out.println(); 

} 

} 


// node class for tree node 

static
class
Node 

{ 

public
int
data ; 

public
Node left ,right; 

public
Node (
int
data) 

{ 

this
.data = data; 

this
.left = 
this
.right = 
null
; 

} 

} 
} 

// This code is contributed by Sparsh Singhal ",CorCod,532,532,quadratic
"
// Java program to find pairs with given sum such 
// that one element of pair exists in one BST and 
// other in other BST. 
import
java.util.*; 
class
solution 
{ 

// A binary Tree node 
static
class
Node 
{ 

int
data; 

Node left, right; 
}; 

// A utility function to create a new BST node 
// with key as given num 
static
Node newNode(
int
num) 
{ 

Node temp = 
new
Node(); 

temp.data = num; 

temp.left = temp.right = 
null
; 

return
temp; 
} 

// A utility function to insert a given key to BST 
static
Node insert(Node root, 
int
key) 
{ 

if
(root == 
null
) 

return
newNode(key); 

if
(root.data > key) 

root.left = insert(root.left, key); 

else

root.right = insert(root.right, key); 

return
root; 
} 

// store storeInorder traversal in auxiliary array 
static
void
storeInorder(Node ptr, Vector<Integer> vect) 
{ 

if
(ptr==
null
) 

return
; 

storeInorder(ptr.left, vect); 

vect.add(ptr.data); 

storeInorder(ptr.right, vect); 
} 

// Function to find pair for given sum in different bst 
// vect1.get() -. stores storeInorder traversal of first bst 
// vect2.get() -. stores storeInorder traversal of second bst 
static
void
pairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, 

int
sum) 
{ 

// Initialize two indexes to two different corners 

// of two Vectors. 

int
left = 
0
; 

int
right = vect2.size() - 
1
; 


// find pair by moving two corners. 

while
(left < vect1.size() && right >= 
0
) 

{ 

// If we found a pair 

if
(vect1.get(left) + vect2.get(right) == sum) 

{ 

System.out.print( 
""(""
+vect1.get(left) + 
"", ""
+ vect2.get(right) + 
""), ""
); 

left++; 

right--; 

} 


// If sum is more, move to higher value in 

// first Vector. 

else
if
(vect1.get(left) + vect2.get(right) < sum) 

left++; 


// If sum is less, move to lower value in 

// second Vector. 

else

right--; 

} 
} 

// Prints all pairs with given ""sum"" such that one 
// element of pair is in tree with root1 and other 
// node is in tree with root2. 
static
void
pairSum(Node root1, Node root2, 
int
sum) 
{ 

// Store inorder traversals of two BSTs in two 

// Vectors. 

Vector<Integer> vect1= 
new
Vector<Integer>(), vect2= 
new
Vector<Integer>(); 

storeInorder(root1, vect1); 

storeInorder(root2, vect2); 


// Now the problem reduces to finding a pair 

// with given sum such that one element is in 

// vect1 and other is in vect2. 

pairSumUtil(vect1, vect2, sum); 
} 

// Driver program to run the case 
public
static
void
main(String args[]) 
{ 

// first BST 

Node root1 = 
null
; 

root1 = insert(root1, 
8
); 

root1 = insert(root1, 
10
); 

root1 = insert(root1, 
3
); 

root1 = insert(root1, 
6
); 

root1 = insert(root1, 
1
); 

root1 = insert(root1, 
5
); 

root1 = insert(root1, 
7
); 

root1 = insert(root1, 
14
); 

root1 = insert(root1, 
13
); 


// second BST 

Node root2 = 
null
; 

root2 = insert(root2, 
5
); 

root2 = insert(root2, 
18
); 

root2 = insert(root2, 
2
); 

root2 = insert(root2, 
1
); 

root2 = insert(root2, 
3
); 

root2 = insert(root2, 
4
); 


int
sum = 
10
; 

pairSum(root1, root2, sum); 
} 
} 
//contributed by Arnab Kundu ",CorCod,10,10,linear
"
// Java program to split a number into maximum 
// number of composite numbers. 
import
java.io.*; 

class
GFG 
{ 

// function to calculate the maximum number of 

// composite numbers adding upto n 

static
int
count(
int
n) 

{ 

// 4 is the smallest composite number 

if
(n < 
4
) 

return
-
1
; 


// stores the remainder when n is divided 

// by 4 

int
rem = n % 
4
; 


// if remainder is 0, then it is perfectly 

// divisible by 4. 

if
(rem == 
0
) 

return
n / 
4
; 


// if the remainder is 1 

if
(rem == 
1
) { 


// If the number is less then 9, that 

// is 5, then it cannot be expressed as 

// 4 is the only composite number less 

// than 5 

if
(n < 
9
) 

return
-
1
; 


// If the number is greater then 8, and 

// has a remainder of 1, then express n 

// as n-9 a and it is perfectly divisible 

// by 4 and for 9, count 1. 

return
(n - 
9
) / 
4
+ 
1
; 

} 



// When remainder is 2, just subtract 6 from n, 

// so that n is perfectly divisible by 4 and 

// count 1 for 6 which is subtracted. 

if
(rem == 
2
) 

return
(n - 
6
) / 
4
+ 
1
; 



// if the number is 7, 11 which cannot be 

// expressed as sum of any composite numbers 

if
(rem == 
3
) 

{ 

if
(n < 
15
) 

return
-
1
; 


// when the remainder is 3, then subtract 

// 15 from it and n becomes perfectly 

// divisible by 4 and we add 2 for 9 and 6, 

// which is getting subtracted to make n 

// perfectly divisible by 4. 

return
(n - 
15
) / 
4
+ 
2
; 

} 

return
0
; 

} 


// Driver program 

public
static
void
main (String[] args) 

{ 

int
n = 
90
; 

System.out.println(count(n)); 


n = 
143
; 

System.out.println(count(n)); 

} 
} 

// This code is contributed by vt_m. ",CorCod,829,829,constant
"import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

/* spar5h */

public class cf1 implements Runnable{    
	
	public void run() {

		InputReader s = new InputReader(System.in);
		PrintWriter w = new PrintWriter(System.out);
		
		int t = 1;
		
		while(t-- > 0) {
			
			int n = s.nextInt(), m = s.nextInt();
			
			int[] a = new int[n + 1];
			
			for(int i = 1; i <= n; i++)
				a[i] = s.nextInt();
			
			int[] b = new int[n + 1];
			
			for(int i = 1; i <= n; i++)
				b[i] = s.nextInt();
			
			ArrayList<Integer> list = new ArrayList<Integer>();
			
			list.add(a[1]);
			
			for(int i = 2; i <= n; i++) {
				list.add(b[i]); list.add(a[i]);
			}
			
			list.add(b[1]);
			
			double wt = m;
			boolean check = true;
			
			for(int i = list.size() - 1; i >= 0; i--) {
				
				if(list.get(i) <= 1) {
					check = false; break;
				}
				
				double x = wt / (list.get(i) - 1);
						
				wt += x;
			}
			
			if(check)
				w.println(wt - m);
			else
				w.println(-1);
		}
		
		w.close();
	}
	
	static class InputReader {
		
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;
		private SpaceCharFilter filter;
		
		public InputReader(InputStream stream)
		{
			this.stream = stream;
		}
		
		public int read()
		{
			if (numChars==-1) 
				throw new InputMismatchException();
			
			if (curChar >= numChars)
			{
				curChar = 0;
				try 
				{
					numChars = stream.read(buf);
				}
				catch (IOException e)
				{
					throw new InputMismatchException();
				}
				
				if(numChars <= 0)				
					return -1;
			}
			return buf[curChar++];
		}
	 
		public String nextLine()
		{
			BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
			String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
		}
		public int nextInt()
		{
			int c = read();
			
			while(isSpaceChar(c)) 
				c = read();
			
			int sgn = 1;
			
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			
			int res = 0;
			do 
			{
				if(c<'0'||c>'9') 
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			while (!isSpaceChar(c)); 
			
			return res * sgn;
		}
		
		public long nextLong() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			long res = 0;
			
			do 
			{
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			while (!isSpaceChar(c));
				return res * sgn;
		}
		
		public double nextDouble() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			double res = 0;
			while (!isSpaceChar(c) && c != '.') 
			{
				if (c == 'e' || c == 'E')
					return res * Math.pow(10, nextInt());
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			if (c == '.') 
			{
				c = read();
				double m = 1;
				while (!isSpaceChar(c)) 
				{
					if (c == 'e' || c == 'E')
						return res * Math.pow(10, nextInt());
					if (c < '0' || c > '9')
						throw new InputMismatchException();
					m /= 10;
					res += (c - '0') * m;
					c = read();
				}
			}
			return res * sgn;
		}
		
		public String readString() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do 
			{
				res.appendCodePoint(c);
				c = read();
			} 
			while (!isSpaceChar(c));
			
			return res.toString();
		}
	 
		public boolean isSpaceChar(int c) 
		{
			if (filter != null)
				return filter.isSpaceChar(c);
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}
	 
		public String next() 
		{
			return readString();
		}
		
		public interface SpaceCharFilter 
		{
			public boolean isSpaceChar(int ch);
		}
	}
    
	public static void main(String args[]) throws Exception
	{
		new Thread(null, new cf1(),""cf1"",1<<26).start();
	}
}",CorCod,212,212,linear
"
/* Dynamic Programming Java 

implementation of Maximum Sum 

Increasing Subsequence (MSIS) 

problem */
class
GFG 
{ 

/* maxSumIS() returns the 

maximum sum of increasing 

subsequence in arr[] of size n */

static
int
maxSumIS(
int
arr[], 
int
n) 

{ 

int
i, j, max = 
0
; 

int
msis[] = 
new
int
[n]; 


/* Initialize msis values 

for all indexes */

for
(i = 
0
; i < n; i++) 

msis[i] = arr[i]; 


/* Compute maximum sum values 

in bottom up manner */

for
(i = 
1
; i < n; i++) 

for
(j = 
0
; j < i; j++) 

if
(arr[i] > arr[j] && 

msis[i] < msis[j] + arr[i]) 

msis[i] = msis[j] + arr[i]; 


/* Pick maximum of all 

msis values */

for
(i = 
0
; i < n; i++) 

if
(max < msis[i]) 

max = msis[i]; 


return
max; 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
arr[] = 
new
int
[]{
1
, 
101
, 
2
, 
3
, 
100
, 
4
, 
5
}; 

int
n = arr.length; 

System.out.println(
""Sum of maximum sum ""
+ 

""increasing subsequence is ""
+ 

maxSumIS(arr, n)); 

} 
} 

// This code is contributed 
// by Rajat Mishra ",CorCod,561,561,quadratic
"
// Java program for different tree traversals 

/* Class containing left and right child of current 

node and key value*/
class
Node 
{ 

int
key; 

Node left, right; 


public
Node(
int
item) 

{ 

key = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

// Root of Binary Tree 

Node root; 


BinaryTree() 

{ 

root = 
null
; 

} 


/* Given a binary tree, print its nodes according to the 

""bottom-up"" postorder traversal. */

void
printPostorder(Node node) 

{ 

if
(node == 
null
) 

return
; 


// first recur on left subtree 

printPostorder(node.left); 


// then recur on right subtree 

printPostorder(node.right); 


// now deal with the node 

System.out.print(node.key + 
"" ""
); 

} 


/* Given a binary tree, print its nodes in inorder*/

void
printInorder(Node node) 

{ 

if
(node == 
null
) 

return
; 


/* first recur on left child */

printInorder(node.left); 


/* then print the data of node */

System.out.print(node.key + 
"" ""
); 


/* now recur on right child */

printInorder(node.right); 

} 


/* Given a binary tree, print its nodes in preorder*/

void
printPreorder(Node node) 

{ 

if
(node == 
null
) 

return
; 


/* first print data of node */

System.out.print(node.key + 
"" ""
); 


/* then recur on left sutree */

printPreorder(node.left); 


/* now recur on right subtree */

printPreorder(node.right); 

} 


// Wrappers over above recursive functions 

void
printPostorder() { printPostorder(root); } 

void
printInorder() { printInorder(root); } 

void
printPreorder() { printPreorder(root); } 


// Driver method 

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
1
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
3
); 

tree.root.left.left = 
new
Node(
4
); 

tree.root.left.right = 
new
Node(
5
); 


System.out.println(
""Preorder traversal of binary tree is ""
); 

tree.printPreorder(); 


System.out.println(
""\nInorder traversal of binary tree is ""
); 

tree.printInorder(); 


System.out.println(
""\nPostorder traversal of binary tree is ""
); 

tree.printPostorder(); 

} 
} ",CorCod,317,317,linear
"//Author: Patel Rag
//Java version ""1.8.0_211""
import java.util.*;
import java.io.*;

public class Main
{
  static class FastReader
  {
    BufferedReader br;
    StringTokenizer st;

    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }

    String next()
    {
      while (st == null || !st.hasMoreElements())
      {
        try
        {
          st = new StringTokenizer(br.readLine());
        }
        catch (IOException  e)
        {
          e.printStackTrace();
        }
      }
      return st.nextToken();
    }

    int nextInt() { return Integer.parseInt(next()); }

    long nextLong(){ return Long.parseLong(next()); }

    double nextDouble(){ return Double.parseDouble(next()); }

    float nextFloat() { return Float.parseFloat(next()); }

    boolean nextBoolean() { return Boolean.parseBoolean(next()); }

    String nextLine()
    {
      String str = """";
      try
      {
        str = br.readLine();
      }
      catch (IOException e)
      {
        e.printStackTrace();
      }
      return str;
    }
  }
  static long modExp(long x, long n, long mod)    //binary Modular exponentiation
  {
    long result = 1;
    while(n > 0)
    {
        if(n % 2 == 1)
            result = (result%mod * x%mod)%mod;
        x = (x%mod * x%mod)%mod;
        n=n/2;
    }
    return result;
  }
  static long gcd(long a, long b)
  {
    if(a==0) return b;
    return gcd(b%a,a);
  }
  public static void main(String[] args)
  throws IOException
  {
    FastReader fr = new FastReader();
    long n = fr.nextLong();
    long x = fr.nextLong();
    long y = fr.nextLong();
    long w = Long.min(x,y) - 1 + (x - Long.min(x,y)) + (y - Long.min(x,y));
    long b = n - Long.max(x,y) + (Long.max(x,y) - x) + (Long.max(x,y) - y);
    if(w <= b) System.out.println(""White"");
    else System.out.println(""Black"");

  }
}
class Pair<U, V>  // Pair class
{
    public final U first;       // first field of a Pair
    public final V second;      // second field of a Pair

    private Pair(U first, V second)
    {
      this.first = first;
      this.second = second;
    }

    @Override
    public boolean equals(Object o)
    {
      if (this == o) return true;

      if (o == null || getClass() != o.getClass()) return false;

      Pair<?, ?> pair = (Pair<?, ?>) o;

      if (!first.equals(pair.first)) return false;
      return second.equals(pair.second);
    }

    @Override
    public int hashCode()
    {
      return 31 * first.hashCode() + second.hashCode();
    }

    public static <U, V> Pair <U, V> of(U a, V b)
    {
      return new Pair<>(a, b);
    }
}
class myComp implements Comparator<Pair>
{
  public int compare(Pair a,Pair b)
  {
    if(a.first != b.first) return ((int)a.first - (int)b.first);
    if(a.second != b.second) return ((int)a.second - (int)b.second);
    return 0;
  }
}
class BIT       //Binary Indexed Tree aka Fenwick Tree
{
  public long[] m_array;

  public BIT(long[] dat)
  {
    m_array = new long[dat.length + 1];
    Arrays.fill(m_array,0);
    for(int i = 0; i < dat.length; i++)
    {
      m_array[i + 1] = dat[i];
    }
    for(int i = 1; i < m_array.length; i++)
    {
      int j = i + (i & -i);
      if(j < m_array.length)
      {
        m_array[j] = m_array[j] + m_array[i];
      }
    }
  }

  public final long prefix_query(int i)
  {
    long result = 0;
    for(++i; i > 0; i = i - (i & -i))
    {
      result = result + m_array[i];
    }
    return result;
  }

  public final long range_query(int fro, int to)
  {
    if(fro == 0)
    {
      return prefix_query(to);
    }
    else
    {
      return (prefix_query(to) - prefix_query(fro - 1));
    }
  }

  public void update(int i, long add)
  {
    for(++i; i < m_array.length; i = i + (i & -i))
    {
      m_array[i] = m_array[i] + add;
    }
  }
}
",CorCod,753,753,constant
"import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map.Entry;

import java.util.Random;
import java.util.Scanner;
import java.util.TreeSet;

public final class CF_573_D1_A {


	static boolean verb=true;
	static void log(Object X){if (verb) System.err.println(X);}
	static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+"" "");System.err.println("""");}}
	static void log(long[] X){if (verb) {for (long U:X) System.err.print(U+"" "");System.err.println("""");}}

	static void logWln(Object X){if (verb) System.err.print(X);}
	static void info(Object o){	System.out.println(o);}
	static void output(Object o){outputWln(""""+o+""\n"");	}
	static void outputWln(Object o){try {out.write(""""+ o);} catch (Exception e) {}}

	//static long mod=1000000007;
	static long mod=998244353 ; 
	static int CX=64;


	// Global vars
	static BufferedWriter out;
	static InputReader reader;


	

	static void process() throws Exception {

		Locale.setDefault(Locale.US);
		out = new BufferedWriter(new OutputStreamWriter(System.out));
		reader = new InputReader(System.in);

		long n=reader.readLong();
		int m=reader.readInt();
		
		long k=reader.readLong();
		long[] p=new long[m];
		for (int i=0;i<m;i++)
			p[i]=reader.readLong()-1;
		
		int pid=-1;
		int rem=m;
		int win=0; // current window
		long mx=k-1; // max value of window
		int res=0;
		int idx=0;
		
		while (rem>0) {
			//log(""======"");
			while (p[idx]>mx) {
				mx+=k;
				if (mx>=n-1)
					mx=n-1;
				//log(""mx:""+mx);
			}
		
			int nxt=idx;
			while (nxt+1<m && p[nxt+1]<=mx)
				nxt++;
			int nb=nxt-idx+1;
			rem-=nb;
			mx+=nb;
			idx=nxt+1;
			res++;
		}
		output(res);

	
		try {
			out.close();
		} catch (Exception E) {
		}

	}

	public static void main(String[] args) throws Exception {
		process();

	}

	static final class InputReader {
		private final InputStream stream;
		private final byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		private int read() throws IOException {
			if (curChar >= numChars) {
				curChar = 0;
				numChars = stream.read(buf);
				if (numChars <= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}

		public final String readString() throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res = new StringBuilder();
			do {
				res.append((char) c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final int readInt() throws IOException {
			int c = read();
			boolean neg = false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d = (char) c;
			// log(""d:""+d);
			if (d == '-') {
				neg = true;
				c = read();
			}
			int res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			// log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		public final long readLong() throws IOException {
			int c = read();
			boolean neg = false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d = (char) c;
			// log(""d:""+d);
			if (d == '-') {
				neg = true;
				c = read();
			}
			long res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			// log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		private boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}
	}

}",CorCod,403,403,quadratic
"//package codeforces;

import java.util.Scanner;

public class Fingerprints {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);

		int[] code = new int[scanner.nextInt()];
		int[] prints = new int[scanner.nextInt()];

		for (int i = 0; i < code.length; i++) {
			code[i] = scanner.nextInt();
		}
		for (int i = 0; i < prints.length; i++) {
			prints[i] = scanner.nextInt();
		}
		for (int i = 0; i < code.length; i++) {
			for (int j = 0; j < prints.length; j++) {
				if (code[i] == prints[j]) {
					System.out.print(prints[j] + "" "");
				}
			}
		}
		scanner.close();
	}

}
",CorCod,572,572,quadratic
"/**
 * BaZ :D
 */
import java.util.*;
import java.io.*;
import static java.lang.Math.*;
public class Main
{
    static Reader scan;
    static PrintWriter pw;
    static int n,k,left[],right[],arr[];
    static long MOD = 1000000007,count[],dp[];
    public static void main(String[] args) {
        new Thread(null,null,""BaZ"",1<<25)
        {
            public void run()
            {
                try
                {
                    solve();
                }
                catch(Exception e)
                {
                    e.printStackTrace();
                    System.exit(1);
                }
            }
        }.start();
    }
    static void solve() throws IOException
    {
        scan = new Reader();
        pw = new PrintWriter(System.out,true);
        StringBuilder sb = new StringBuilder();
        n = ni();
        k = ni();
        int stack[] = new int[1000001];
        int top = -1;
        arr = new int[n];
        left = new int[n];
        right = new int[n];
        for(int i=0;i<n;++i) {
            arr[i] = ni();
            while(top>=0 && arr[stack[top]]<=arr[i])
                top--;
            if(top==-1)
                left[i] = 0;
            else left[i] = stack[top]+1;
            stack[++top] = i;
        }
        top = -1;
        for(int i=n-1;i>=0;--i) {
            while(top>=0 && arr[stack[top]]<arr[i])
                top--;
            if(top==-1)
                right[i] = n-1;
            else right[i] = stack[top]-1;
            stack[++top] = i;
        }
        //pa(""left"", left);
        //pa(""right"", right);
        dp = new long[n+1];
        for(int i=0;i<=n;++i) {
            if(i<k)
              continue;
            dp[i] = dp[i-k+1] + (i-k+1);
        }
        count = new long[n];
        long ans = 0;
        for(int i=0;i<n;++i) {
            int len = right[i]-left[i]+1;
            int lef = i-left[i];
            int rig = right[i]-i;
            long count = dp[len] - dp[lef] - dp[rig];
            if(count>=MOD)
              count%=MOD;
            ans += count*arr[i];
            if(ans>=MOD)
                ans%=MOD;
        }
        pl(ans);
        pw.flush();
        pw.close();
    }
    static int ni() throws IOException
    {
        return scan.nextInt();
    }
    static long nl() throws IOException
    {
        return scan.nextLong();
    }
    static double nd() throws IOException
    {
        return scan.nextDouble();
    }
    static void pl()
    {
        pw.println();
    }
    static void p(Object o)
    {
        pw.print(o+"" "");
    }
    static void pl(Object o)
    {
        pw.println(o);
    }
    static void psb(StringBuilder sb)
    {
        pw.print(sb);
    }
    static void pa(String arrayName, Object arr[])
    {
        pl(arrayName+"" : "");
        for(Object o : arr)
            p(o);
        pl();
    }
    static void pa(String arrayName, int arr[])
    {
        pl(arrayName+"" : "");
        for(int o : arr)
            p(o);
        pl();
    }
    static void pa(String arrayName, long arr[])
    {
        pl(arrayName+"" : "");
        for(long o : arr)
            p(o);
        pl();
    }
    static void pa(String arrayName, double arr[])
    {
        pl(arrayName+"" : "");
        for(double o : arr)
            p(o);
        pl();
    }
    static void pa(String arrayName, char arr[])
    {
        pl(arrayName+"" : "");
        for(char o : arr)
            p(o);
        pl();
    }
    static void pa(String listName, List list)
    {
        pl(listName+"" : "");
        for(Object o : list)
            p(o);
        pl();
    }
    static void pa(String arrayName, Object[][] arr) {
        pl(arrayName+"" : "");
        for(int i=0;i<arr.length;++i) {
            for(Object o : arr[i])
                p(o);
            pl();
        }
    }
    static void pa(String arrayName, int[][] arr) {
        pl(arrayName+"" : "");
        for(int i=0;i<arr.length;++i) {
            for(int o : arr[i])
                p(o);
            pl();
        }
    }
    static void pa(String arrayName, long[][] arr) {
        pl(arrayName+"" : "");
        for(int i=0;i<arr.length;++i) {
            for(long o : arr[i])
                p(o);
            pl();
        }
    }
    static void pa(String arrayName, char[][] arr) {
        pl(arrayName+"" : "");
        for(int i=0;i<arr.length;++i) {
            for(char o : arr[i])
                p(o);
            pl();
        }
    }
    static void pa(String arrayName, double[][] arr) {
        pl(arrayName+"" : "");
        for(int i=0;i<arr.length;++i) {
            for(double o : arr[i])
                p(o);
            pl();
        }
    }
    static class Reader {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader() {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public Reader(String file_name) throws IOException {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[64];
            int cnt = 0, c;
            while ((c = read()) != -1) {
                if (c == '\n') break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

        public int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }

        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }

        public double nextDouble() throws IOException {
            double ret = 0, div = 1;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');
            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);
            if (neg) return -ret;
            return ret;
        }

        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1) buffer[0] = -1;
        }

        private byte read() throws IOException {
            if (bufferPointer == bytesRead) fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException {
            if (din == null) return;
            din.close();
        }
    }
}",CorCod,363,363,linear
"
// Java program to find the 
// to calculate the product 
// of max element of first 
// array and min element of 
// second array 
import
java.util.*; 
import
java.lang.*; 

class
GfG 
{ 


// Function to calculate 

// the product 

public
static
int
minMaxProduct(
int
arr1[], 

int
arr2[], 

int
n1, 

int
n2) 

{ 


// Sort the arrays to find the 

// maximum and minimum elements 

// in given arrays 

Arrays.sort(arr1); 

Arrays.sort(arr2); 


// Return product of maximum 

// and minimum. 

return
arr1[n1 - 
1
] * arr2[
0
]; 

} 


// Driver Code 

public
static
void
main(String argc[]) 

{ 

int
[] arr1= 
new
int
[]{ 
10
, 
2
, 
3
, 

6
, 
4
, 
1
}; 

int
[] arr2 = 
new
int
[]{ 
5
, 
1
, 
4
, 

2
, 
6
, 
9
}; 

int
n1 = 
6
; 

int
n2 = 
6
; 

System.out.println(minMaxProduct(arr1, 

arr2, 

n1, n2)); 

} 
} 

/*This code is contributed by Sagar Shukla.*/",CorCod,657,657,nlogn
"import java.io.*;
import java.util.*;

public class Main {

	static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner() {
            try {
                br = new BufferedReader(new InputStreamReader(System.in));
                st = new StringTokenizer(br.readLine());
            } catch (Exception e){e.printStackTrace();}
        }

        public String next() {
            if (st.hasMoreTokens()) return st.nextToken();
            try {st = new StringTokenizer(br.readLine());}
            catch (Exception e) {e.printStackTrace();}
            return st.nextToken();
        }

        public int nextInt() {return Integer.parseInt(next());}

        public long nextLong() {return Long.parseLong(next());}

        public double nextDouble() {return Double.parseDouble(next());}

        public String nextLine() {
            String line = """";
            if(st.hasMoreTokens()) line = st.nextToken();
            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}
            while(st.hasMoreTokens()) line += "" ""+st.nextToken();
            return line;
        }
    }
    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        PrintWriter pw = new PrintWriter(System.out);

        int n = sc.nextInt();
        int best = 1;
        int bestTime = Integer.MAX_VALUE;
        for(int i=0;i<n;i++) {
            int time;
            int a = sc.nextInt();
            time = (a%n==0 || a%n<=i) ? a/n : (a+n)/n;
            if(time < bestTime) {
                best = i + 1;
                bestTime = time;
            }
        }

        pw.println(best);
        pw.close();
    }
}
",CorCod,210,210,linear
"import java.util.Scanner;
import java.util.Vector;

public class Main {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int a[] = new int[n];
        int b[] = new int[n];
        for (int i = 0; i < n; i++) a[i] = sc.nextInt();
        for (int i = 0; i < n; i++) b[i] = sc.nextInt();
        int c[] = new int[2 * n];
        c[0] = a[0];
        for (int i = 1; i < n; i++) {
            c[i * 2] = a[i];
            c[i * 2 - 1] = b[i];
            if (a[i] == 1 || b[i] == 1) {
                System.out.print(-1);
                System.exit(0);
            }
        }
        c[2 * n - 1] = b[0];
        if (a[0] == 1 || b[0] == 1) {
            System.out.print(-1);
            System.exit(0);
        }
        System.out.println(bin_search(c, m));
    }

    private static double bin_search(int[] c, int m) {
        double start = 0;
        double end = Integer.MAX_VALUE;
        double mid;
        while (start + 0.0000001 < end) {
            mid = (start + end) / 2;
            if (test(mid, m, c)) end = mid;
            else start = mid;
        }
        return end;
    }

    private static boolean test(double fuel, int m, int[] c) {
        for (int i = 0; i < c.length; i++) {
            fuel -= (m + fuel) / c[i];
            if (fuel < 0) {
                return false;
            }
        }
        return true;
    }
}
",CorCod,691,691,nlogn
"
// Java implementation to print the path from root 
// to a given node in a binary tree 
import
java.util.ArrayList; 
public
class
PrintPath { 


// Returns true if there is a path from root 

// to the given node. It also populates 

// 'arr' with the given path 

public
static
boolean
hasPath(Node root, ArrayList<Integer> arr, 
int
x) 

{ 

// if root is NULL 

// there is no path 

if
(root==
null
) 

return
false
; 


// push the node's value in 'arr' 

arr.add(root.data); 


// if it is the required node 

// return true 

if
(root.data == x) 

return
true
; 


// else check whether the required node lies 

// in the left subtree or right subtree of 

// the current node 

if
(hasPath(root.left, arr, x) || 

hasPath(root.right, arr, x)) 

return
true
; 


// required node does not lie either in the 

// left or right subtree of the current node 

// Thus, remove current node's value from 

// 'arr'and then return false 

arr.remove(arr.size()-
1
); 

return
false
; 

} 


// function to print the path from root to the 

// given node if the node lies in the binary tree 

public
static
void
printPath(Node root, 
int
x) 

{ 

// ArrayList to store the path 

ArrayList<Integer> arr=
new
ArrayList<>(); 


// if required node 'x' is present 

// then print the path 

if
(hasPath(root, arr, x)) 

{ 

for
(
int
i=
0
; i<arr.size()-
1
; i++) 

System.out.print(arr.get(i)+
""->""
); 

System.out.print(arr.get(arr.size() - 
1
)); 

} 


// 'x' is not present in the binary tree 

else

System.out.print(
""No Path""
); 

} 


public
static
void
main(String args[]) { 

Node root=
new
Node(
1
); 

root.left = 
new
Node(
2
); 

root.right = 
new
Node(
3
); 

root.left.left = 
new
Node(
4
); 

root.left.right = 
new
Node(
5
); 

root.right.left = 
new
Node(
6
); 

root.right.right = 
new
Node(
7
); 

int
x=
5
; 

printPath(root, x); 

} 
} 

// A node of binary tree 
class
Node 
{ 

int
data; 

Node left, right; 

Node(
int
data) 

{ 

this
.data=data; 

left=right=
null
; 

} 
}; 
//This code is contributed by Gaurav Tiwari ",CorCod,22,22,linear
"
// A simple Java program to find max subarray XOR 
class
GFG { 

static
int
maxSubarrayXOR(
int
arr[], 
int
n) 

{ 

int
ans = Integer.MIN_VALUE; 
// Initialize result 


// Pick starting points of subarrays 

for
(
int
i=
0
; i<n; i++) 

{ 

// to store xor of current subarray 

int
curr_xor = 
0
; 


// Pick ending points of subarrays starting with i 

for
(
int
j=i; j<n; j++) 

{ 

curr_xor = curr_xor ^ arr[j]; 

ans = Math.max(ans, curr_xor); 

} 

} 

return
ans; 

} 


// Driver program to test above functions 

public
static
void
main(String args[]) 

{ 

int
arr[] = {
8
, 
1
, 
2
, 
12
}; 

int
n = arr.length; 

System.out.println(
""Max subarray XOR is ""
+ 

maxSubarrayXOR(arr, n)); 

} 
} 
//This code is contributed by Sumit Ghosh ",CorCod,386,386,quadratic
"import java.util.Scanner;


public class IfAtFIrstYouDIdnt {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		Scanner input = new Scanner(System.in);
		int a = input.nextInt();
		int b = input.nextInt();
		int c = input.nextInt();
		int n  = input.nextInt();
		if(a<n && b<n && c < n && (a+b-c)<n && c<=a && c<=b){
			System.out.println((n)-(a+b-c));
		}
		else
			System.out.println(""-1"");
	}

}
",CorCod,843,843,constant
"import java.util.*;

public class helloWorld 
{
	public static void main(String[] args) 
	{		
		Scanner in = new Scanner(System.in);
		long n = in.nextLong();
		long m = in.nextLong();
		
		long ans = m / n;
		
		if(m % n > 0)
			ans++;
		
		System.out.println(ans);
		
		in.close();
	}
}

",CorCod,852,852,constant
"import java.io.*;
import java.util.StringTokenizer;
public class Main {
    
    public static void main(String[] args) {
        FastScanner sc = new FastScanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int N = sc.nextInt();
        long dest = sc.nextLong();
        long max = (long)N * ((long)N + 1L) / 2L;
        if (dest < 2 * N - 1 || dest > max) {
            out.println(""No"");
            out.close();
            return;
        }
        int[] d = new int[N + 1];
        int[] f = new int[N + 1];
        int K = 1;
        for (; K <= N; K++) {
            long dep = 1L, cnt = 1L, c = 1L;
            long t = 1L;
            while (cnt < N) {
                c = c * K;
                dep++;
                t += (dep * Math.min(c, N - cnt));
                cnt += c;
            }
            if (t <= dest) break;
        }
        out.println(""Yes"");
        int dep = 1; long cnt = 1L, c = 1L;
        long t = 1L;
        d[1] = 1;
        while (cnt < N) {
            dep++; c = c * K; 
            long x = (long)N - cnt;
            int min;
            if (c >= x) min = (int)x;
            else min = (int)c;
            d[dep] = min;
            t += (dep * Math.min(c, (long)N - cnt)); cnt += c;
        }
        dest -= t;
        int curDep = dep; int nextDep = dep + 1;
        while (dest > 0) {
            if (d[curDep] <= 1) curDep--;
            d[curDep]--;
            long next = Math.min(nextDep++, dest + curDep);
            dest -= ((int)next - curDep);
            d[(int)next]++;
        }
        int first = 1;
        for (int i = 2; i < nextDep; i++) {
            int p = 0, fn = first - d[i - 1] + 1;
            for (int j = first + 1; j <= first + d[i]; j++) {
                if (p == K) {
                    fn++; p = 0;
                }
                p++; f[j] = fn;
            }
            first += d[i];
        }
        for (int i = 2; i <= N; i++)
            out.format(""%d "", f[i]);
        out.close();
    }
            
        
    static class FastScanner {
        private BufferedReader reader = null;
        private StringTokenizer tokenizer = null;
        
        public FastScanner(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
            tokenizer = null;
        }
        
        public String next() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        
        public String nextLine() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    return reader.readLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken(""\n"");
        }
        
        public long nextLong() {
            return Long.parseLong(next());
        }
        
        public int nextInt() {
            return Integer.parseInt(next());
        }
        
       /* public double nextDouble() {
            return Double.parseDouble(next());
        }
        
        public int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; ++i) {
                a[i] = nextInt();
            }
            return a;
        }
        
        public long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextLong();
            }
            return a;
        }*/
    }
}",CorCod,646,646,nlogn
"
// Java program to print boundary traversal of binary tree 

/* A binary tree node has data, pointer to left child 

and a pointer to right child */
class
Node { 

int
data; 

Node left, right; 


Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree { 

Node root; 


// A simple function to print leaf nodes of a binary tree 

void
printLeaves(Node node) 

{ 

if
(node != 
null
) { 

printLeaves(node.left); 


// Print it if it is a leaf node 

if
(node.left == 
null
&& node.right == 
null
) 

System.out.print(node.data + 
"" ""
); 

printLeaves(node.right); 

} 

} 


// A function to print all left boundary nodes, except a leaf node. 

// Print the nodes in TOP DOWN manner 

void
printBoundaryLeft(Node node) 

{ 

if
(node != 
null
) { 

if
(node.left != 
null
) { 


// to ensure top down order, print the node 

// before calling itself for left subtree 

System.out.print(node.data + 
"" ""
); 

printBoundaryLeft(node.left); 

} 

else
if
(node.right != 
null
) { 

System.out.print(node.data + 
"" ""
); 

printBoundaryLeft(node.right); 

} 


// do nothing if it is a leaf node, this way we avoid 

// duplicates in output 

} 

} 


// A function to print all right boundary nodes, except a leaf node 

// Print the nodes in BOTTOM UP manner 

void
printBoundaryRight(Node node) 

{ 

if
(node != 
null
) { 

if
(node.right != 
null
) { 

// to ensure bottom up order, first call for right 

// subtree, then print this node 

printBoundaryRight(node.right); 

System.out.print(node.data + 
"" ""
); 

} 

else
if
(node.left != 
null
) { 

printBoundaryRight(node.left); 

System.out.print(node.data + 
"" ""
); 

} 

// do nothing if it is a leaf node, this way we avoid 

// duplicates in output 

} 

} 


// A function to do boundary traversal of a given binary tree 

void
printBoundary(Node node) 

{ 

if
(node != 
null
) { 

System.out.print(node.data + 
"" ""
); 


// Print the left boundary in top-down manner. 

printBoundaryLeft(node.left); 


// Print all leaf nodes 

printLeaves(node.left); 

printLeaves(node.right); 


// Print the right boundary in bottom-up manner 

printBoundaryRight(node.right); 

} 

} 


// Driver program to test above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
20
); 

tree.root.left = 
new
Node(
8
); 

tree.root.left.left = 
new
Node(
4
); 

tree.root.left.right = 
new
Node(
12
); 

tree.root.left.right.left = 
new
Node(
10
); 

tree.root.left.right.right = 
new
Node(
14
); 

tree.root.right = 
new
Node(
22
); 

tree.root.right.right = 
new
Node(
25
); 

tree.printBoundary(tree.root); 

} 
} ",CorCod,3,3,linear
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class A {

	public static void main(String[] args) {
		BufferedReader br = null;
		br = new BufferedReader(new InputStreamReader(System.in));
        String input;
		try {
			input = br.readLine();
			int n = Integer.parseInt(input);
			input = br.readLine();
			int qx = Integer.parseInt(input.split("" "")[0]);
			int qy = Integer.parseInt(input.split("" "")[1]);
			input = br.readLine();
			int kx = Integer.parseInt(input.split("" "")[0]);
			int ky = Integer.parseInt(input.split("" "")[1]);
			input = br.readLine();
			int gx = Integer.parseInt(input.split("" "")[0]);
			int gy = Integer.parseInt(input.split("" "")[1]);
			if((kx<qx && gx<qx)||(kx>qx && gx>qx)) {
				if((ky<qy && gy<qy)||(ky>qy && gy>qy))System.out.println(""YES"");
				else System.out.println(""NO"");
			}else System.out.println(""NO"");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

}
",CorCod,825,825,constant
"
// Program to make all array equal 
import
java.io.*; 
import
java.util.Arrays; 

class
GFG { 

// function for calculating min operations 

static
int
minOps(
int
arr[], 
int
n, 
int
k) 

{ 

// max elements of array 

Arrays.sort(arr); 

int
max = arr[arr.length - 
1
]; 

int
res = 
0
; 


// iterate for all elements 

for
(
int
i = 
0
; i < n; i++) { 


// check if element can make equal to 

// max or not if not then return -1 

if
((max - arr[i]) % k != 
0
) 

return
-
1
; 


// else update res for required operations 

else

res += (max - arr[i]) / k; 

} 


// return result 

return
res; 

} 


// Driver program 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
21
, 
33
, 
9
, 
45
, 
63
}; 

int
n = arr.length; 

int
k = 
6
; 

System.out.println(minOps(arr, n, k)); 

} 
} 

// This code is contributed by vt_m ",CorCod,699,699,nlogn
"//package contese_476;
import java.util.*;
public class q1 
{
	int m=(int)1e9+7;
public class Node
{
	int a;
	int b;
	public void Node(int a,int b)
	{
		this.a=a;
		this.b=b;
	}
}
public int mul(int a ,int b)
{
a=a%m;
b=b%m;
return((a*b)%m);
}
public int pow(int a,int b)
{
	int x=1;
	while(b>0)
	{
		if(b%2!=0)
			x=mul(x,a);
		a=mul(a,a);
		b=b/2;
	}
	return x;
}
public static long gcd(long a,long b)
{
	if(b==0)
		return a;
	else
		return gcd(b,a%b);
}
public static void main(String[] args)
{
	Scanner sc=new Scanner(System.in);
	int n=sc.nextInt();
	HashMap<Integer,Integer> h=new HashMap();
	//HashMap<Integer,Integer> h1=new HashMap();
	int[] a=new int[n];
	int x=sc.nextInt();
	for(int i=0;i<n;i++)
	{
		a[i]=sc.nextInt();
		if(h.get(a[i])==null)
		{
			h.put(a[i], 1);
			//h1.put(a[i],i);
		}
		else
		{
			System.out.print(0);
			System.exit(0);
		}
	}
	for(int i=0;i<n;i++)
	{
		int num=a[i]&x;
		if(num==a[i])
			continue;
		if(h.get(num)==null)
			continue;
		
		else
		{
			
			System.out.print(1);
			System.exit(0);
		}
	}
	for(int i=0;i<n;i++)
	{
		int num=a[i]&x;
		if(num==a[i])
			continue;
		if(h.get(num)==null)
			h.put(num, 1);
		else
		{
			System.out.print(2);
			System.exit(0);
		}
	}
	System.out.print(-1);
	
     
}

}",CorCod,349,349,linear
"import com.sun.org.apache.xerces.internal.util.SynchronizedSymbolTable;
import jdk.management.cmm.SystemResourcePressureMXBean;

import java.awt.*;
import java.io.*;
import java.lang.reflect.Array;
import java.text.DecimalFormat;
import java.util.*;
import java.util.List;
import java.math.*;

public class Newbie {

    static InputReader sc = new InputReader(System.in);
    static PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
        solver s = new solver();
        int t = 1;
        while (t > 0) {
            s.solve();
            t--;
        }
        out.close();
    }

   /* static class descend implements Comparator<pair1> {
        public int compare(pair1 o1, pair1 o2) {
            if (o1.pop != o2.pop)
                return (int) (o1.pop - o2.pop);
            else
                return o1.in - o2.in;
        }
    }*/

    static class InputReader {
        public BufferedReader br;
        public StringTokenizer token;

        public InputReader(InputStream stream) {
            br = new BufferedReader(new InputStreamReader(stream), 32768);
            token = null;
        }

        public String next() {
            while (token == null || !token.hasMoreTokens()) {
                try {
                    token = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return token.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }

    static class card {
        long a;
        int cnt;
        int i;

        public card(long a, int cnt, int i) {
            this.a = a;
            this.cnt = cnt;
            this.i = i;
        }
    }

    static class ascend implements Comparator<pair> {
        public int compare(pair o1, pair o2) {
            return o1.a - o2.a;
        }
    }

    static class extra {

        static boolean v[] = new boolean[100001];
        static List<Integer> l = new ArrayList<>();
        static int t;

        static void shuffle(long a[]) {
            List<Long> l = new ArrayList<>();
            for (int i = 0; i < a.length; i++)
                l.add(a[i]);
            Collections.shuffle(l);
            for (int i = 0; i < a.length; i++)
                a[i] = l.get(i);
        }

        static long gcd(long a, long b) {
            if (b == 0)
                return a;
            else
                return gcd(b, a % b);
        }

        static boolean valid(int i, int j, int r, int c) {
            if (i >= 0 && i < r && j >= 0 && j < c)
                return true;
            else
                return false;
        }

        static void seive() {
            for (int i = 2; i < 100001; i++) {
                if (!v[i]) {
                    t++;
                    l.add(i);
                    for (int j = 2 * i; j < 100001; j += i)
                        v[j] = true;
                }
            }
        }

        static int binary(long a[], long val, int n) {
            int mid = 0, l = 0, r = n - 1, ans = 0;
            while (l <= r) {
                mid = (l + r) >> 1;
                if (a[mid] == val) {
                    r = mid - 1;
                    ans = mid;
                } else if (a[mid] > val)
                    r = mid - 1;
                else {
                    l = mid + 1;
                    ans = l;
                }
            }
            return (ans + 1);
        }

        static long fastexpo(int x, int y) {
            long res = 1;
            while (y > 0) {
                if ((y & 1) == 1) {
                    res *= x;
                }
                y = y >> 1;
                x = x * x;
            }
            return res;
        }

        static long lfastexpo(int x, int y, int p) {
            long res = 1;
            x = x % p;
            while (y > 0) {
                if ((y & 1) == 1) {
                    res = (res * x) % p;
                }
                y = y >> 1;
                x = (x * x) % p;
            }
            return res;
        }
    }

    static class pair {
        int a;
        int b;

        public pair(int a, int i) {
            this.a = a;
            this.b = i;
        }
    }

    static class pair1 {
        pair p;
        int in;

        public pair1(pair a, int n) {
            this.p = a;
            this.in = n;
        }
    }

    static long m = (long) 1e9 + 7;

    static class solver {
        void solve() {
            int n = sc.nextInt();
            int ans=0;
            int a[]=new int[2*n];
            for (int i = 0; i < 2 * n; i++) {
               a[i]=sc.nextInt();
            }
            for(int i=0;i<2*n;i++)
            {
                if(a[i]>0)
                {
                    int j=0;
                    for(j=i+1;a[i]!=a[j];j++)
                    {
                        if(a[j]>0)
                            ans++;
                    }
                    a[j]=0;
                }
            }
            System.out.println(ans);
        }
    }
}",CorCod,551,551,quadratic
"
// Java program for solution of 
// friends pairing problem 
import
java.io.*; 

class
GFG { 


// Returns count of ways n people 

// can remain single or paired up. 

static
int
countFriendsPairings(
int
n) 

{ 

int
dp[] = 
new
int
[n + 
1
]; 


// Filling dp[] in bottom-up manner using 

// recursive formula explained above. 

for
(
int
i = 
0
; i <= n; i++) { 

if
(i <= 
2
) 

dp[i] = i; 

else

dp[i] = dp[i - 
1
] + (i - 
1
) * dp[i - 
2
]; 

} 


return
dp[n]; 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
n = 
4
; 

System.out.println(countFriendsPairings(n)); 

} 
} 

// This code is contributed by vt_m ",CorCod,203,203,linear
"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int num=sc.nextInt();
		long sum1=0,sum2=0;
		for(int i=0;i<num*2;i++){
			sum1+=sc.nextInt();
			sum2+=sc.nextInt();
		}
		System.out.println(sum1/num+"" ""+sum2/num);
	}
}
				  			 		  	 			 				 	",CorCod,223,223,linear
"
// Java Solution 
public
class
LongestPalinSubstring 
{ 

// A utility function to print a substring str[low..high] 

static
void
printSubStr(String str, 
int
low, 
int
high) { 

System.out.println(str.substring(low, high + 
1
)); 

} 


// This function prints the longest palindrome substring 

// of str[]. 

// It also returns the length of the longest palindrome 

static
int
longestPalSubstr(String str) { 

int
n = str.length(); 
// get length of input string 


// table[i][j] will be false if substring str[i..j] 

// is not palindrome. 

// Else table[i][j] will be true 

boolean
table[][] = 
new
boolean
[n][n]; 


// All substrings of length 1 are palindromes 

int
maxLength = 
1
; 

for
(
int
i = 
0
; i < n; ++i) 

table[i][i] = 
true
; 


// check for sub-string of length 2. 

int
start = 
0
; 

for
(
int
i = 
0
; i < n - 
1
; ++i) { 

if
(str.charAt(i) == str.charAt(i + 
1
)) { 

table[i][i + 
1
] = 
true
; 

start = i; 

maxLength = 
2
; 

} 

} 


// Check for lengths greater than 2. k is length 

// of substring 

for
(
int
k = 
3
; k <= n; ++k) { 


// Fix the starting index 

for
(
int
i = 
0
; i < n - k + 
1
; ++i) 

{ 

// Get the ending index of substring from 

// starting index i and length k 

int
j = i + k - 
1
; 


// checking for sub-string from ith index to 

// jth index iff str.charAt(i+1) to 

// str.charAt(j-1) is a palindrome 

if
(table[i + 
1
][j - 
1
] && str.charAt(i) == 

str.charAt(j)) { 

table[i][j] = 
true
; 


if
(k > maxLength) { 

start = i; 

maxLength = k; 

} 

} 

} 

} 

System.out.print(
""Longest palindrome substring is; ""
); 

printSubStr(str, start, start + maxLength - 
1
); 


return
maxLength; 
// return length of LPS 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) { 


String str = 
""forgeeksskeegfor""
; 

System.out.println(
""Length is: ""
+ 

longestPalSubstr(str)); 

} 
} 

// This code is contributed by Sumit Ghosh ",CorCod,511,511,quadratic
"
// Java program to find maximum average 
// subarray of given length. 
import
java .io.*; 

class
GFG { 


// Returns beginning index 

// of maximum average 

// subarray of length 'k' 

static
int
findMaxAverage(
int
[]arr, 

int
n, 
int
k) 

{ 


// Check if 'k' is valid 

if
(k > n) 

return
-
1
; 


// Create and fill array 

// to store cumulative 

// sum. csum[i] stores 

// sum of arr[0] to arr[i] 

int
[]csum = 
new
int
[n]; 


csum[
0
] = arr[
0
]; 

for
(
int
i = 
1
; i < n; i++) 

csum[i] = csum[i - 
1
] + arr[i]; 


// Initialize max_sm as 

// sum of first subarray 

int
max_sum = csum[k - 
1
], 

max_end = k - 
1
; 


// Find sum of other 

// subarrays and update 

// max_sum if required. 

for
(
int
i = k; i < n; i++) 

{ 

int
curr_sum = csum[i] - 

csum[i - k]; 

if
(curr_sum > max_sum) 

{ 

max_sum = curr_sum; 

max_end = i; 

} 

} 


// To avoid memory leak 

//delete [] csum; 


// Return starting index 

return
max_end - k + 
1
; 

} 


// Driver Code 

static
public
void
main (String[] args) 

{ 

int
[]arr = {
1
, 
12
, -
5
, -
6
, 
50
, 
3
}; 

int
k = 
4
; 

int
n = arr.length; 


System.out.println(
""The maximum ""

+ 
""average subarray of length ""

+ k + 
"" begins at index ""

+ findMaxAverage(arr, n, k)); 

} 
} 

// This code is contributed by anuj_67. ",CorCod,49,49,linear
"
// Java implementation of an O(n) approach of level order 
// traversal in spiral form 

import
java.util.*; 

// A Binary Tree node 
class
Node { 

int
data; 

Node left, right; 


public
Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree { 


static
Node root; 


void
printSpiral(Node node) 

{ 

if
(node == 
null
) 

return
; 
// NULL check 


// Create two stacks to store alternate levels 

// For levels to be printed from right to left 

Stack<Node> s1 = 
new
Stack<Node>(); 

// For levels to be printed from left to right 

Stack<Node> s2 = 
new
Stack<Node>(); 


// Push first level to first stack 's1' 

s1.push(node); 


// Keep printing while any of the stacks has some nodes 

while
(!s1.empty() || !s2.empty()) { 

// Print nodes of current level from s1 and push nodes of 

// next level to s2 

while
(!s1.empty()) { 

Node temp = s1.peek(); 

s1.pop(); 

System.out.print(temp.data + 
"" ""
); 


// Note that is right is pushed before left 

if
(temp.right != 
null
) 

s2.push(temp.right); 


if
(temp.left != 
null
) 

s2.push(temp.left); 

} 


// Print nodes of current level from s2 and push nodes of 

// next level to s1 

while
(!s2.empty()) { 

Node temp = s2.peek(); 

s2.pop(); 

System.out.print(temp.data + 
"" ""
); 


// Note that is left is pushed before right 

if
(temp.left != 
null
) 

s1.push(temp.left); 

if
(temp.right != 
null
) 

s1.push(temp.right); 

} 

} 

} 


public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
1
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
3
); 

tree.root.left.left = 
new
Node(
7
); 

tree.root.left.right = 
new
Node(
6
); 

tree.root.right.left = 
new
Node(
5
); 

tree.root.right.right = 
new
Node(
4
); 

System.out.println(
""Spiral Order traversal of Binary Tree is ""
); 

tree.printSpiral(root); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,141,141,linear
"import java.util.*;
import java.io.*;
public class code{
    public static void main(String[] args) throws IOException{
        Scanner sc = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int ok,ok2;
        int va,vb;
        va = 0;
        vb = 0;
        out.println(""? ""+va+"" ""+vb);
        out.flush();
        ok = sc.nextInt();
        for(int i=29;i>=0;i--){
            if(ok==0){
                va += (1<<i);
                out.println(""? ""+va+"" ""+vb);
                out.flush();
                ok2 = sc.nextInt();
                if(ok2==1){
                    va -= (1<<i);
                }else{
                    vb += (1<<i);
                }
            }else{
                va += (1<<i);
                vb += (1<<i);
                out.println(""? ""+va+"" ""+vb);
                out.flush();
                ok2 = sc.nextInt();
                if(ok==ok2){
                    vb -= (1<<i);
                    out.println(""? ""+va+"" ""+vb);
                    out.flush();
                    ok2 = sc.nextInt();
                    if(ok2==1){
                        va -= (1<<i);
                    }else{
                        vb += (1<<i);
                    }
                }else{
                    if(ok==1){
                        vb -= (1<<i);
                        out.println(""? ""+va+"" ""+vb);
                        out.flush();
                        ok = sc.nextInt();
                    }
                    else {
                        va -= (1<<i);
                        out.println(""? ""+va+"" ""+vb);
                        out.flush();
                        ok = sc.nextInt();
                    }
                }
            }
        }
        out.println(""! ""+va+"" ""+vb);
        out.flush();
    }
}",CorCod,916,916,logn
"import java.io.*;
import java.util.*;
import java.lang.*;
import java.math.BigInteger;
 
public class Main {
 
    private static final FS scanner = new FS(System.in);
	//private static final Scanner scanner = new Scanner(System.in);
	
	public static void main(String[] args) throws Exception {

        int n = scanner.nextInt();
        int sumA = 0;
        int sumB = 0;
        int rem = n % 4;
        for (int i = rem; i >= 1 ; i--) {
            if (sumB <= sumA) {
                sumB += i;
            }
            else {
                sumA +=i;
            }
        }

        System.out.println(Math.abs(sumA - sumB));
    }
	
    static class FS {
        BufferedReader br;
        StringTokenizer st;

        public FS(InputStream i) {
            br = new BufferedReader(new InputStreamReader(i));
            st = new StringTokenizer("""");
        }

        public String next() throws IOException {
            if(st.hasMoreTokens())
                return st.nextToken();
            else
                st = new StringTokenizer(br.readLine());
            return next();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }
        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }
 
}",CorCod,780,780,constant
"
class
MinimumDistance 
{ 

int
minDist(
int
arr[], 
int
n, 
int
x, 
int
y) 

{ 

int
i = 
0
; 

int
min_dist = Integer.MAX_VALUE; 

int
prev=
0
; 


// Find the first occurence of any of the two numbers (x or y) 

// and store the index of this occurence in prev 

for
(i = 
0
; i < n; i++) 

{ 

if
(arr[i] == x || arr[i] == y) 

{ 

prev = i; 

break
; 

} 

} 


// Traverse after the first occurence 

for
(; i < n; i++) 

{ 

if
(arr[i] == x || arr[i] == y) 

{ 

// If the current element matches with any of the two then 

// check if current element and prev element are different 

// Also check if this value is smaller than minimum distance 

// so far 

if
(arr[prev] != arr[i] && (i - prev) < min_dist) 

{ 

min_dist = i - prev; 

prev = i; 

} 

else

prev = i; 

} 

} 


return
min_dist; 

} 


/* Driver program to test above functions */

public
static
void
main(String[] args) { 

MinimumDistance min = 
new
MinimumDistance(); 

int
arr[] = {
3
, 
5
, 
4
, 
2
, 
6
, 
3
, 
0
, 
0
, 
5
, 
4
, 
8
, 
3
}; 

int
n = arr.length; 

int
x = 
3
; 

int
y = 
6
; 


System.out.println(
""Minimum distance between ""
+ x + 
"" and ""
+ y 

+ 
"" is ""
+ min.minDist(arr, n, x, y)); 

} 
} ",CorCod,199,199,linear
"import java.util.Scanner;
public class Codeforces {
    public static Scanner input = new Scanner(System.in);
    public static void main(String[] args){
        int n,k;
        n=input.nextInt();
        k=input.nextInt();
        String s=input.next();
        int[] wtArray=new int[n];
        for(int i=0;i<s.length();i++)
            wtArray[i]=s.charAt(i)-96;
        for(int i=1;i<n;i++)
            for(int j=0;j<n-i;j++)
                if(wtArray[j]>wtArray[j+1]){
                    int temp=wtArray[j+1];
                    wtArray[j+1]=wtArray[j];
                    wtArray[j]=temp;
                }

        int sum=wtArray[0];
        k--;
        int temp=sum;
        for(int i=1;k!=0 &&i <n;i++){
            if((wtArray[i]-temp)>1){
                sum+=wtArray[i];
                k--;
                temp=wtArray[i];
            }
        }
        if(k!=0)
            sum=-1;
        System.out.println(sum);
    }

}",CorCod,499,499,quadratic
"import java.io.*;
import java.util.*;
public class Main{
public static void main(String[] args){
 Scanner s= new Scanner(System.in);
 int n=s.nextInt();StringBuilder sb=new StringBuilder();
 long[] a=new long[n/2];
 for(int i=0;i<n/2;i++){
                  a[i]=s.nextLong();
 }int j=0;long[] a2=new long[n/2];long[] a1=new long[n/2];
 a1[j]=a[a.length-1]/2;
 a2[j]=a[a.length-1]-a[a.length-1]/2;
 for(int i=(n-1)/2-1;i>=0;i--){
 //    a1[j]=a[i]/2;a2[j++]=a[i]-a[i]/2;
    long n1=a1[j];
    if((a[i]-n1)<a2[j]){
      a2[j+1]=a2[j++];a1[j]=a[i]-a2[j];                      
     }else{a1[++j]=n1;a2[j]=a[i]-n1;}
 }int k=0;//int[] ans=new int[2*n];
 for(int i=(n-1)/2;i>=0;i--)
   sb.append(a1[i]+"" "");
  for(int i=0;i<n/2;i++)
    sb.append(a2[i]+"" "");
            System.out.println(sb.toString());     
}
}",CorCod,83,83,linear
"// http://www.geeksforgeeks.org/count-1s-sorted-binary-array/
class CountOne {

  public static void main(String[] args) {
    int[] arr={0, 0, 0, 0, 0, 0, 0};
    //int[] arr={1, 1, 1, 1, 1, 1, 1};
    //int[] arr = {1, 1, 1, 0, 0, 0, 0};  
    countOne(arr);
  }

  public static void countOne(int[] a)
  {
       int l = 0;
       int h = a.length-1;
       int mid = -1;
      
       while(l<=h)
       {
         mid = (l+h)/2;
         
         if( (mid == h || a[mid+1] == 0) && a[mid] == 1)
         {
             System.out.println(""Count "" + (mid + 1));
             return;
         }
           
         if( a[mid] < 1)
         {
             h = mid - 1;
         } else {
             l = mid + 1;
         } 
       }
       System.out.println("" No one's found "");
       return;
  }
}",CorCod,893,893,logn
"import java.io.*;
import java.util.*;

import javax.lang.model.util.ElementScanner6;
public class codef
{
    public static void main(String ar[]) throws IOException
    {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer nk=new StringTokenizer(br.readLine());
        int n=Integer.parseInt(nk.nextToken());
        int k=Integer.parseInt(nk.nextToken());
        String st[]=br.readLine().split("" "");
        
        int ans[]=new int[n];
        int a[]=new int[n];
        for(int i=0;i<n;i++)
            ans[i]=Integer.parseInt(st[i]);  

        for(int i=1;i<n;i++)
            a[i]=ans[i]-ans[i-1];
        a[0]=-1;

        Arrays.sort(a);
        int count=0,sum=0;
        for(int i=0;i<n;i++)
            if(a[i]<0)
                count++;
            else
                sum=sum+a[i];
        
        k=k-count;
        int i=n-1;
        while(k>0 && i>=0)
        {
            if(a[i]>-1)
            {
                sum=sum-a[i];
                k--;
            }
            i--;
        }
        System.out.println(sum);
    }
}",CorCod,698,698,nlogn
"import java.util.Arrays;
import java.util.Scanner;

public class Solution {

    private static int[] a;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(), m = sc.nextInt();

        a = new int[101];
        for (int i = 0; i < m; i++) {
            int type = sc.nextInt();
            a[type] = a[type] + 1;
        }

        int lo=1, hi=100, max=0;

        while (lo <= hi) {
            int mid = lo + (hi - lo)/2;
            if (check(n, mid)) {
                max = mid;
                lo = mid+1;
            } else {
                hi = mid -1;
            }
        }
        System.out.println(max);
    }

    public static boolean check(int n, int target) {
        int result = 0;
        for (int i=0; i <a.length; i++) {
            result = result + (a[i] / target);
        }
        if (result >= n) {return true;}
        return false;
    }
}",CorCod,695,695,nlogn
"
// Java Code for Maximum weight path ending at 
// any element of last row in a matrix 
import
java.util.*; 

class
GFG { 


/* Function which return the maximum weight 

path sum */

public
static
int
maxCost(
int
mat[][], 
int
N) 

{ 

// create 2D matrix to store the sum of 

// the path 

int
dp[][]=
new
int
[N][N]; 


dp[
0
][
0
] = mat[
0
][
0
]; 


// Initialize first column of total 

// weight array (dp[i to N][0]) 

for
(
int
i = 
1
; i < N; i++) 

dp[i][
0
] = mat[i][
0
] + dp[i-
1
][
0
]; 


// Calculate rest path sum of weight matrix 

for
(
int
i = 
1
; i < N; i++) 

for
(
int
j = 
1
; j < i + 
1
&& j < N; j++) 

dp[i][j] = mat[i][j] + 

Math.max(dp[i-
1
][j-
1
], 

dp[i-
1
][j]); 


// find the max weight path sum to reach 

// the last row 

int
result = 
0
; 

for
(
int
i = 
0
; i < N; i++) 

if
(result < dp[N-
1
][i]) 

result = dp[N-
1
][i]; 


// return maximum weight path sum 

return
result; 

} 


/* Driver program to test above function */

public
static
void
main(String[] args) 

{ 

int
mat[][] = { { 
4
, 
1
,
5
,
6
, 
1
}, 

{ 
2
,
9
,
2
,
11
,
10
}, 

{ 
15
,
1
,
3
,
15
, 
2
}, 

{ 
16
, 
92
, 
41
,
4
,
3
}, 

{ 
8
, 
142
, 
6
, 
4
, 
8
} 

}; 

int
N = 
5
; 

System.out.println(
""Maximum Path Sum : ""
+ 

maxCost(mat, N)); 

} 
} 
// This code is contributed by Arnav Kr. Mandal. ",CorCod,527,527,quadratic
"
// Java program to find minimum value node in Binary Search Tree 

// A binary tree node 
class
Node { 


int
data; 

Node left, right; 


Node(
int
d) { 

data = d; 

left = right = 
null
; 

} 
} 

class
BinaryTree { 


static
Node head; 


/* Given a binary search tree and a number, 

inserts a new node with the given number in 

the correct place in the tree. Returns the new 

root pointer which the caller should then use 

(the standard trick to avoid using reference 

parameters). */

Node insert(Node node, 
int
data) { 


/* 1. If the tree is empty, return a new, 

single node */

if
(node == 
null
) { 

return
(
new
Node(data)); 

} 
else
{ 


/* 2. Otherwise, recur down the tree */

if
(data <= node.data) { 

node.left = insert(node.left, data); 

} 
else
{ 

node.right = insert(node.right, data); 

} 


/* return the (unchanged) node pointer */

return
node; 

} 

} 


/* Given a non-empty binary search tree, 

return the minimum data value found in that 

tree. Note that the entire tree does not need 

to be searched. */

int
minvalue(Node node) { 

Node current = node; 


/* loop down to find the leftmost leaf */

while
(current.left != 
null
) { 

current = current.left; 

} 

return
(current.data); 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) { 

BinaryTree tree = 
new
BinaryTree(); 

Node root = 
null
; 

root = tree.insert(root, 
4
); 

tree.insert(root, 
2
); 

tree.insert(root, 
1
); 

tree.insert(root, 
3
); 

tree.insert(root, 
6
); 

tree.insert(root, 
5
); 


System.out.println(
""Minimum value of BST is ""
+ tree.minvalue(root)); 

} 
} 

// This code is contributed by Mayank Jaiswal ",CorCod,87,87,linear
"//package contest1196;

import java.util.*;
import java.io.*;

public class D {

	public static int[][] dp = new int[200005][3];
	
	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
		PrintWriter cout = new PrintWriter(System.out);
		
		int q = cin.nextInt();
		int[] a = new int[200005];
		int n, k;
		while (q-- > 0) {
			n = cin.nextInt();
			k = cin.nextInt();
			String chuoi = cin.nextLine();
			chuoi = cin.nextLine();
			for (int i = 1; i <= n; i++) {
				char ch = chuoi.charAt(i-1);
				if (ch == 'R') a[i] = 1;
				if (ch == 'G') a[i] = 2;
				if (ch == 'B') a[i] = 0;
			}
			
			for (int i = 1; i <= n; i++)
				for (int x = 0; x < 3; x++) {
					dp[i][x] = dp[i-1][x];
					if (a[i] != (x + i)%3) dp[i][x]++;
				}
			
			int res = 1000000007;
			for (int i = k; i <= n; i++) 
				for (int x = 0; x < 3; x++)
					res = Math.min(res, dp[i][x] - dp[i-k][x]);
					
			cout.println(res);
		}
		cout.close();
	}
}
",CorCod,545,545,quadratic
"import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class B 
{
	
	static StringBuilder st ; 
	
	public static void main(String[] args) throws Exception
	{
		Scanner sc = new Scanner () ;
		PrintWriter out = new PrintWriter(System.out);
		
		int n = sc.nextInt();
		int m = sc.nextInt();
		
		String first = """" ; 
		String second = """" ; 
		
		
		for(int i = 0 ; i < 126 ;i++ )
		{
			first+= ""9"";
			second+=""9"";
		}
		
		for(int i = 0 ; i < 125 ;i++ )
			first+= ""0"";
		
		first += ""1"";
		
		out.println(first+"" ""+second);
		
		out.flush();
		out.close();
	
	}
	
	static int sumDigits(int num)
	{
		int ans = 0 ;
		
		while(num > 0)
		{
			ans += num % 10  ;
			
			num /= 10;
		}
		
		return ans ;
		
	}
	
	static class Scanner 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;

		String next() throws Exception 
		{
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());

			return st.nextToken();
		}

		int nextInt() throws Exception { return Integer.parseInt(next()); }
		
		long nextLong() throws Exception { return Long.parseLong(next()); }

		double nextDouble() throws Exception { return Double.parseDouble(next()); }

		char nextChar() throws Exception { return next().charAt(0); }
		
		char [] nextCharArray() throws Exception{ return next().toCharArray() ; }
	}

}
",CorCod,832,832,constant
"
	
	
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.PrintWriter;
	import java.math.BigInteger;
	import java.util.*;
	
	
	public class usd {
		
		static int r=0;static int c=0;
		static void fillzero(int a[][],int n)
		{
			for(int i=0;i<n;i++)
			{
				for(int j=0;j<n-1;j++)
				{
					if(a[j][i]==0&&a[j+1][i]==0)
					{
						a[j][i]=1;a[j+1][i]=1;
						r=j;c=i;
						return;
					}
				}
			}
		}
		static void fillone(int a[][],int n)
		{
			for(int i=0;i<n;i++)
			{
				for(int j=0;j<n-1;j++)
				{
					if(a[i][j]==0&&a[i][j+1]==0)
					{
						a[i][j]=1;a[i][j+1]=1;
						r=i;c=j;
						return;
					}
				}
			}
		}
		
		static void check(int a[][],int n)
		{
			for(int i=0;i<4;i++)
			{
				if(a[i][0]==1&&a[i][1]==1&&a[i][2]==1&&a[i][3]==1)
				{
					a[i][0]=0;a[i][1]=0;a[i][2]=0;a[i][3]=0;
				}
			}
			for(int i=0;i<4;i++)
			{
				if(a[0][i]==1&&a[1][i]==1&&a[2][i]==1&&a[3][i]==1)
				{
					a[0][i]=0;a[1][i]=0;a[2][i]=0;a[3][i]=0;;
				}
			}
		}
		
		
		public static void main(String[] args) throws NumberFormatException, IOException {
			
			
		Scanner in=new Scanner (System.in);
		HashMap<String,Integer>map=new HashMap<String,Integer>();
		ArrayList<Integer>list=new ArrayList<Integer>();
	
long n=in.nextLong();
long ans=Long.MAX_VALUE;
long sum=0;long sum2=(n*(n+1))/2;
if(sum2%2==0)
System.out.println(0);
else
	System.out.println(1);


		
		
		
		
		}
		
		
	}
",CorCod,844,844,constant
"
// Java program to find triplets in a given 
// array whose sum is zero 
import
java.util.*; 

class
GFG 
{ 


// function to print triplets with 0 sum 

static
void
findTriplets(
int
arr[], 
int
n) 

{ 

boolean
found = 
false
; 


for
(
int
i = 
0
; i < n - 
1
; i++) 

{ 

// Find all pairs with sum equals to 

// ""-arr[i]"" 

HashSet<Integer> s = 
new
HashSet<Integer>(); 

for
(
int
j = i + 
1
; j < n; j++) 

{ 

int
x = -(arr[i] + arr[j]); 

if
(s.contains(x)) 

{ 

System.out.printf(
""%d %d %d\n""
, x, arr[i], arr[j]); 

found = 
true
; 

} 

else

{ 

s.add(arr[j]); 

} 

} 

} 


if
(found == 
false
) 

{ 

System.out.printf(
"" No Triplet Found\n""
); 

} 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
arr[] = {
0
, -
1
, 
2
, -
3
, 
1
}; 

int
n = arr.length; 

findTriplets(arr, n); 

} 
} 

// This code contributed by Rajput-Ji ",CorCod,536,536,quadratic
"import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int m = sc.nextInt();

        long totalBlocks = 0;
        long a[] = new long[n];
        for(int i = 0; i < n; ++i) {
            a[i] = sc.nextLong();
            totalBlocks += a[i];
        }

        Arrays.sort(a);

        long selected = 0;
        for(int i = 0; i < n; ++i) {
            if(a[i] > selected)
                selected++;
        }

        long leftCols = a[n - 1] - selected;
        long remBlocks = totalBlocks - leftCols - n;

        System.out.print(remBlocks);
    }
}",CorCod,639,639,nlogn
"import java.util.*;
import java.io.*;
public class A{
       
       public static void main(String args[]){
              Scanner sc = new Scanner(System.in);
              int n = sc.nextInt();
              int ans = 0;
              for(int i = 1; i <= n; i++){
                     ans += ((i*2) <= n) ? i : n-i+1;
              }
              System.out.println(ans);
       }
}",CorCod,115,115,linear
"

import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc=new Scanner(System.in);
		while(sc.hasNext()) {
			int n=sc.nextInt();
			if(n%2==0) {
				System.out.println(""Mahmoud"");
			}else {
				System.out.println(""Ehab"");
			}
		}
	}
}

		 	  						  			 			   	 		 		",CorCod,747,747,constant
"import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;

public class CodeForces {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int d = in.nextInt(), sum = in.nextInt();
		List<Data> data = new ArrayList<>();
		
		for (int i = 0; i < d; ++i) {
			int min = in.nextInt(), max = in.nextInt();
			int centre = (min + max) / 2;
			data.add(new Data(centre - min, max - centre, centre));
			sum -= centre;
		}
		
		Iterator<Data> it = data.iterator();
		
		while (sum != 0) {
			if (!it.hasNext()) {
				System.out.println(""NO"");
				return;
			}
			
			Data da = it.next();

			if (sum > 0) {
				da.centre += da.above;
				sum -= da.above;
			} else {
				da.centre -= da.below;
				sum += da.below;
			}
		}
		
		System.out.println(""YES"");
		
		for (Data da : data) {
			System.out.print(da.centre + "" "");
		}
	}
}

class Data {
	int below, above, centre;
	
	Data(int below, int above, int centre) {
		this.below = below;
		this.above = above;
		this.centre = centre;
	}
}",CorCod,5,5,linear
"import java.util.*;
import java.io.*;
public class A
{
      public static void main(String ar[]) throws Exception
      {
            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
            String s1[]=br.readLine().split("" "");
            int n=Integer.parseInt(s1[0]);
            int m=Integer.parseInt(s1[1]);
            int a[]=new int[n];
            String s2[]=br.readLine().split("" "");
            long S=0;
            for(int i=0;i<n;i++)
            { a[i]=Integer.parseInt(s2[i]);  S+=(long)a[i]; }
            
            Arrays.sort(a);
            m=a[n-1];
            int last=1;
            int t=1;
            for(int i=1;i<n-1;i++)
            {
                  if(a[i]==last)
                   t++;
                  else
                  {
                        t++;
                        last=last+1;
                  }
            }
            if(last<m)
            { t+=m-last; }
            else
             t++;
            System.out.println(S-t);
      }
}",CorCod,669,669,nlogn
"
import java.io.*;
import java.lang.reflect.Array;
import java.util.*;
import java.math.*;
import java.lang.*;
import static java.lang.Math.*;

public class TaskB implements Runnable {
    boolean prime[] = new boolean[(int)1e6+10];
    InputReader c;
    PrintWriter w;

    public void run() {
        c = new InputReader(System.in);
        w = new PrintWriter(System.out);

        char a[] = c.next().toCharArray(), b[] = c.next().toCharArray();
        int n = a.length, m = b.length;

        int[][] prefix = new int[m][2];
        for(int i=0;i<m;i++){
            if(i!=0) {
                prefix[i][0] = prefix[i-1][0];
                prefix[i][1] = prefix[i-1][1];
            }
            prefix[i][b[i] - '0']++;
            //w.println(prefix[i][0]+"" ""+prefix[i][1]);
        }

        long res = 0;
        for(int i=0;i<n;i++){
            int temp = a[i] - '0';

            res += prefix[m - n + i][temp^1];
            if(i!=0) res -= prefix[i-1][temp^1];
        }

        w.println(res);

        w.close();
    }

    void sieveOfEratosthenes(int n) {
        for(int i=0;i<n;i++)
            prime[i] = true;

        for(int p = 2; p*p <=n; p++)
        {
            if(prime[p] == true)
            {
                for(int i = p*p; i <= n; i += p)
                    prime[i] = false;
            }
        }
    }
    class pair implements Comparable<pair>{
        char ch;
        int ind;

        @Override
        public String toString() {
            return ""pair{"" +
                    ""ch="" + ch +
                    "", ind="" + ind +
                    '}';
        }

        public pair(char ch, int ind) {
            this.ch = ch;
            this.ind = ind;
        }
        public int compareTo(pair car) {
            if(this.ch==car.ch)
                return this.ind - car.ind;
            return this.ch - car.ch;
        }
    }
    public static void sortbyColumn(int arr[][], int col){
        Arrays.sort(arr, new Comparator<int[]>()
        {
            public int compare(int[] o1, int[] o2){
                return(Integer.valueOf(o1[col]).compareTo(o2[col]));
            }
        });

    }
    static long gcd(long a, long b){
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }
    public static class DJSet {
        public int[] upper;
        public DJSet(int n) {
            upper = new int[n];
            Arrays.fill(upper, -1);
        }

        public int root(int x) {
            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
        }

        public boolean equiv(int x, int y) {
            return root(x) == root(y);
        }

        public boolean union(int x, int y) {
            x = root(x);
            y = root(y);
            if (x != y) {
                if (upper[y] < upper[x]) {
                    int d = x;
                    x = y;
                    y = d;
                }
                upper[x] += upper[y];
                upper[y] = x;
            }
            return x == y;
        }
    }
    public static int[] radixSort(int[] f) {
        int[] to = new int[f.length];
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        return f;
    }
    public void printArray(int[] a){
        for(int i=0;i<a.length;i++)
            w.print(a[i]+"" "");
        w.println();
    }
    public int[] scanArrayI(int n){
        int a[] = new int[n];
        for(int i=0;i<n;i++)
            a[i] = c.nextInt();
        return a;
    }
    public long[] scanArrayL(int n){
        long a[] = new long[n];
        for(int i=0;i<n;i++)
            a[i] = c.nextLong();
        return a;
    }
    public void printArray(long[] a){
        for(int i=0;i<a.length;i++)
            w.print(a[i]+"" "");
        w.println();
    }
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars==-1)
                throw new InputMismatchException();

            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                }
                catch (IOException e) {
                    throw new InputMismatchException();
                }

                if(numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            int c = read();

            while(isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;
            do {
                if(c<'0'||c>'9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    public static void main(String args[]) throws Exception {
        new Thread(null, new TaskB(),""TaskB"",1<<26).start();
    }
}



",CorCod,215,215,linear
"import java.util.*;
import static java.lang.Math.*;
import java.io.*;

public class SolutionB {
      public static void main(String args[])throws IOException{
              Scanner sc = new Scanner(System.in);
              int a[] = new int[1501];
              for(int i = 0; i < 3; i++){
                     a[sc.nextInt()]++;
              }
              if(a[1] > 0 || a[2] > 1 || a[3] > 2 || (a[4] == 2 && a[2] == 1)){
                     System.out.println(""YES"");
              }else{
                     System.out.println(""NO"");
              }
      }
}",CorCod,862,862,constant
"import java.util.*;
import java.io.*;

public class Sol {
	public static void main(String[] args) {
		MyScanner sc = new MyScanner();
		out = new PrintWriter(new BufferedOutputStream(System.out));
		int n = sc.nextInt();
		int k = sc.nextInt();
		int l = sc.nextInt();
		Integer[] a = new Integer[n*k];
		for(int i = 0; i < n*k; i++){
			a[i] = sc.nextInt();
		}
		Arrays.sort(a);
		if (a[n - 1] - a[0] > l) {
			out.println(0);
		} else {
			int maxPos = n*k - 1;
			for (int i = 0; i < n*k; i++) {
				if (a[i] - a[0] > l) {
					maxPos = i-1;
					break;
				}
			}
			long o = a[0];
			int s = 0;
			int t = 1;
			for (int i = 1; i <= maxPos; i++) {
				//System.out.print(a[i]);
				if (s < k - 1 && maxPos-i+1 > n-t) {
					//System.out.println("" @"");
					s++;
				} else {
					//System.out.println("" #"");
					s = 0;
					t++;
					o += a[i];
				}
			}
			out.println(o);
		}
		out.close();
	}

	// -----------PrintWriter for faster output-------------
	public static PrintWriter out;

	// -----------MyScanner class for faster input----------
	public static class MyScanner {
		BufferedReader br;
		StringTokenizer st;

		public MyScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}

	}
	// --------------------------------------------------------
}",CorCod,705,705,nlogn
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;


public class pr1073B {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        int n = Integer.parseInt(br.readLine());

        int[] a = new int[n];
        int[] b = new int[n];

        StringTokenizer st = new StringTokenizer(br.readLine());

        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(st.nextToken());
        }
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            b[i] = Integer.parseInt(st.nextToken());
        }

        solve(n, a, b, out);
        out.flush();
        out.close();
    }

    private static void solve(int n, int[] a, int[] b, PrintWriter out) {
        boolean[] book = new boolean[n+1];
        boolean f;
        int j1 = 0, j2 = 0;
        for (int i = 0; i < n; i++) {
            f = false;
            int num = b[i];
            if(!book[num]) {
                f = true;
                j1 = j2;
                for (;j2 < n; j2++) {
                    book[a[j2]] = true;
                    if (a[j2] == num) {
                        j2++;
                        break;
                    }
                }
            }
            out.print(f ? j2-j1 + "" "": 0 + "" "");
        }
    }
}
",CorCod,125,125,linear
"import java.util.*;
		public class mohamedy23
		{
	      public static void main (String args[])
		    {
		    	Scanner sc=new Scanner(System.in);
		    	int n=sc.nextInt();String s=sc.next();int i=s.length()-1;
		    	
		    	if(n==1) {
		    		if(s.charAt(0)=='1') {
		    			System.out.print(""YES"");return;
		    		}else {
		    			System.out.print(""NO"");return;
		    		}
		    	}else if(n==2) {
		    		if(s.contains(""00"")||s.contains(""11"")) {
		    			System.out.print(""NO"");return;
		    		}else {
		    			System.out.print(""Yes"");return;
		    		}
		    	}
		    	else if(s.contains(""000"")||s.contains(""11"")) {
		    		System.out.print(""NO"");return;
		    	}
		    	else	if(s.charAt(0)=='0'&&s.charAt(1)=='0'&&s.charAt(2)=='1') {
		    		System.out.print(""NO"");return;
		    	}
		    	else	if(s.charAt(i)=='0'&&s.charAt(i-1)=='0') {
		    		System.out.print(""NO"");
		    		return;
		    		}
		    	 System.out.print(""YES"");
		    }
		}
		 ",CorCod,159,159,linear
"
// Space optimized CPP implementation of 
// longest common substring. 
import
java.io.*; 
import
java.util.*; 

public
class
GFG { 


// Function to find longest 

// common substring. 

static
int
LCSubStr(String X, String Y) 

{ 


// Find length of both the strings. 

int
m = X.length(); 

int
n = Y.length(); 


// Variable to store length of longest 

// common substring. 

int
result = 
0
; 


// Matrix to store result of two 

// consecutive rows at a time. 

int
[][]len = 
new
int
[
2
][n]; 


// Variable to represent which row of 

// matrix is current row. 

int
currRow = 
0
; 


// For a particular value of 

// i and j, len[currRow][j] 

// stores length of longest 

// common substring in string 

// X[0..i] and Y[0..j]. 

for
(
int
i = 
0
; i < m; i++) { 

for
(
int
j = 
0
; j < n; j++) { 

if
(i == 
0
|| j == 
0
) { 

len[currRow][j] = 
0
; 

} 

else
if
(X.charAt(i - 
1
) == 

Y.charAt(j - 
1
)) 

{ 

len[currRow][j] = 

len[(
1
- currRow)][(j - 
1
)] 

+ 
1
; 

result = Math.max(result, 

len[currRow][j]); 

} 

else

{ 

len[currRow][j] = 
0
; 

} 

} 


// Make current row as previous 

// row and previous row as 

// new current row. 

currRow = 
1
- currRow; 

} 


return
result; 

} 


// Driver Code 

public
static
void
main(String args[]) 

{ 

String X = 
""GeeksforGeeks""
; 

String Y = 
""GeeksQuiz""
; 


System.out.print(LCSubStr(X, Y)); 

} 
} 

// This code is contributed by 
// Manish Shaw (manishshaw1) ",CorCod,483,483,quadratic
"

// Java program to convert an arbitrary binary tree to a tree that holds 
// children sum property 

// A binary tree node 
class
Node 
{ 

int
data; 

Node left, right; 


Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root; 

/* This function changes a tree to hold children sum 

property */


void
convertTree(Node node) 

{ 

int
left_data = 
0
, right_data = 
0
, diff; 


/* If tree is empty or it's a leaf node then 

return true */

if
(node == 
null

|| (node.left == 
null
&& node.right == 
null
)) 

return
; 

else

{ 

/* convert left and right subtrees */

convertTree(node.left); 

convertTree(node.right); 


/* If left child is not present then 0 is used 

as data of left child */

if
(node.left != 
null
) 

left_data = node.left.data; 


/* If right child is not present then 0 is used 

as data of right child */

if
(node.right != 
null
) 

right_data = node.right.data; 


/* get the diff of node's data and children sum */

diff = left_data + right_data - node.data; 


/* If node's children sum is greater than the node's data */

if
(diff > 
0
) 

node.data = node.data + diff; 


/* THIS IS TRICKY --> If node's data is greater than children 

sum, then increment subtree by diff */

if
(diff < 
0
) 


// -diff is used to make diff positive 

increment(node, -diff); 

} 

} 


/* This function is used to increment subtree by diff */

void
increment(Node node, 
int
diff) 

{ 

/* IF left child is not NULL then increment it */

if
(node.left != 
null
) 

{ 

node.left.data = node.left.data + diff; 


// Recursively call to fix the descendants of node->left 

increment(node.left, diff); 

} 

else
if
(node.right != 
null
) 
// Else increment right child 

{ 

node.right.data = node.right.data + diff; 


// Recursively call to fix the descendants of node->right 

increment(node.right, diff); 

} 

} 


/* Given a binary tree, printInorder() prints out its 

inorder traversal*/

void
printInorder(Node node) 

{ 

if
(node == 
null
) 

return
; 


/* first recur on left child */

printInorder(node.left); 


/* then print the data of node */

System.out.print(node.data + 
"" ""
); 


/* now recur on right child */

printInorder(node.right); 

} 


// Driver program to test above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
50
); 

tree.root.left = 
new
Node(
7
); 

tree.root.right = 
new
Node(
2
); 

tree.root.left.left = 
new
Node(
3
); 

tree.root.left.right = 
new
Node(
5
); 

tree.root.right.left = 
new
Node(
1
); 

tree.root.right.right = 
new
Node(
30
); 


System.out.println(
""Inorder traversal before conversion is :""
); 

tree.printInorder(tree.root); 


tree.convertTree(tree.root); 

System.out.println(
""""
); 


System.out.println(
""Inorder traversal after conversion is :""
); 

tree.printInorder(tree.root); 


} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",CorCod,489,489,quadratic
"
// JAVA Code to find total count of an element 
// in a range 

class
GFG { 


// Returns count of element in arr[left-1..right-1] 

public
static
int
findFrequency(
int
arr[], 
int
n, 

int
left, 
int
right, 

int
element) 

{ 

int
count = 
0
; 

for
(
int
i = left - 
1
; i < right; ++i) 

if
(arr[i] == element) 

++count; 

return
count; 

} 


/* Driver program to test above function */

public
static
void
main(String[] args) 

{ 

int
arr[] = {
2
, 
8
, 
6
, 
9
, 
8
, 
6
, 
8
, 
2
, 
11
}; 

int
n = arr.length; 


// Print frequency of 2 from position 1 to 6 

System.out.println(
""Frequency of 2 from 1 to 6 = ""
+ 

findFrequency(arr, n, 
1
, 
6
, 
2
)); 


// Print frequency of 8 from position 4 to 9 

System.out.println(
""Frequency of 8 from 4 to 9 = ""
+ 

findFrequency(arr, n, 
4
, 
9
, 
8
)); 


} 

} 
// This code is contributed by Arnav Kr. Mandal. ",CorCod,93,93,linear
