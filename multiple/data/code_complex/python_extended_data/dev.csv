content,problem,from,idx,problem_title,problem_description,input_output_specification,tags,label
"n = int(input()) 
ax,ay = [int(s) for s in input().split()]
bx,by = [int(s) for s in input().split()]
cx,cy = [int(s) for s in input().split()]
if ((bx-ax < 0 and cx-ax < 0 or
    bx-ax > 0 and cx-ax > 0) and
    (by-ay < 0 and cy-ay < 0 or
    by-ay > 0 and cy-ay > 0)):
        print(""YES"")
else:
    print(""NO"")",1033_A,CODEFORCES,455,King Escape,"Alice and Bob are playing chess on a huge chessboard with dimensions $$$n \times n$$$. Alice has a single piece left — a queen, located at $$$(a_x, a_y)$$$, while Bob has only the king standing at $$$(b_x, b_y)$$$. Alice thinks that as her queen is dominating the chessboard, victory is hers. 
But Bob has made a devious plan to seize the victory for himself — he needs to march his king to $$$(c_x, c_y)$$$ in order to claim the victory for himself. As Alice is distracted by her sense of superiority, she no longer moves any pieces around, and it is only Bob who makes any turns.
Bob will win if he can move his king from $$$(b_x, b_y)$$$ to $$$(c_x, c_y)$$$ without ever getting in check. Remember that a king can move to any of the $$$8$$$ adjacent squares. A king is in check if it is on the same rank (i.e. row), file (i.e. column), or diagonal as the enemy queen. 
Find whether Bob can win or not.
The first line contains a single integer $$$n$$$ ($$$3 \leq n \leq 1000$$$) — the dimensions of the chessboard.
The second line contains two integers $$$a_x$$$ and $$$a_y$$$ ($$$1 \leq a_x, a_y \leq n$$$) — the coordinates of Alice's queen.
The third line contains two integers $$$b_x$$$ and $$$b_y$$$ ($$$1 \leq b_x, b_y \leq n$$$) — the coordinates of Bob's king.
The fourth line contains two integers $$$c_x$$$ and $$$c_y$$$ ($$$1 \leq c_x, c_y \leq n$$$) — the coordinates of the location that Bob wants to get to.
It is guaranteed that Bob's king is currently not in check and the target location is not in check either.
Furthermore, the king is not located on the same square as the queen (i.e. $$$a_x \neq b_x$$$ or $$$a_y \neq b_y$$$), and the target does coincide neither with the queen's position (i.e. $$$c_x \neq a_x$$$ or $$$c_y \neq a_y$$$) nor with the king's position (i.e. $$$c_x \neq b_x$$$ or $$$c_y \neq b_y$$$).
Print ""YES"" (without quotes) if Bob can get from $$$(b_x, b_y)$$$ to $$$(c_x, c_y)$$$ without ever getting in check, otherwise print ""NO"".
You can print each letter in any case (upper or lower).
In the diagrams below, the squares controlled by the black queen are marked red, and the target square is marked blue.
In the first case, the king can move, for instance, via the squares $$$(2, 3)$$$ and $$$(3, 2)$$$. Note that the direct route through $$$(2, 2)$$$ goes through check.
","input
In the second case, the queen watches the fourth rank, and the king has no means of crossing it.
output
In the third case, the queen watches the third file.
","dfsandsimilar, graphs, implementation",1
"import math

input()
all_days_problems = list(map(int, input().split()))
sum_count = sum(all_days_problems)
half_problems = math.ceil(sum_count/2)
current_sum = 0
answer = 0
for num in all_days_problems:
    answer += 1
    current_sum +=num
    if current_sum >=half_problems:
        break

print(answer)
 	   	 	 	 								 	  		 	   	",0962_A,CODEFORCES,1604,Equator,"Polycarp has created his own training plan to prepare for the programming contests. He will train for $$$n$$$ days, all days are numbered from $$$1$$$ to $$$n$$$, beginning from the first.
On the $$$i$$$-th day Polycarp will necessarily solve $$$a_i$$$ problems. One evening Polycarp plans to celebrate the equator. He will celebrate it on the first evening of such a day that from the beginning of the training and to this day inclusive he will solve half or more of all the problems.
Determine the index of day when Polycarp will celebrate the equator.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of days to prepare for the programming contests.
The second line contains a sequence $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10\,000$$$), where $$$a_i$$$ equals to the number of problems, which Polycarp will solve on the $$$i$$$-th day.
Print the index of the day when Polycarp will celebrate the equator.
","input
In the first example Polycarp will celebrate the equator on the evening of the second day, because up to this day (inclusive) he will solve $$$4$$$ out of $$$7$$$ scheduled problems on four days of the training.
output
In the second example Polycarp will celebrate the equator on the evening of the third day, because up to this day (inclusive) he will solve $$$6$$$ out of $$$12$$$ scheduled problems on six days of the training.
",implementation,3
"def f_pow(a, n):
    if n < 0:
        return 0
    if n == 0:
        return 1
    if n % 2 == 0:
        return f_pow(a * a, n // 2)
    else:
        return a * f_pow(a, n - 1)


def get_c(n):
    if(n > 68):
        return int(1e40)
    return (f_pow(4, n) - 4) // 12

def get_cc(n):
    if(n > 51):
        return int(1e30)
    return (f_pow(4, n) - 4) // 12

def ans(n, k):
    side = n - 1
    way = 4
    cnt_all = get_c(n + 1)
    c = 2
    op = 1
    while (True):
        if k < op or side < 0:
            break
        way_blocks = way - 1
        if(get_cc(side - 1) > k):
            return side
        per_block = get_cc(side + 1)
        kk = k - op
        if cnt_all - way_blocks * per_block - op >= kk:
            return side

        side -= 1
        op += (1 << c) - 1
        c += 1
        way *= 2
    return -1

def read():
    return [int(i) for i in input().split()]


t = int(input())

for i in range(t):
    n, k = read()
    a = ans(n, k)
    if(a == -1):
        print(""NO"")
    else:
        print(""YES {}"".format(a))",1080_D,CODEFORCES,1198,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"n = int(input())
a = []
for i in range(n):
    a.append(list(map(int,input().split()))+[i+1])
a.sort(key = lambda e:e[0])
f = 0
for i in range(n-1):
    if a[i][0] == a[i+1][0]:
        if a[i][1] >= a[i+1][1]:
            print(a[i+1][2],a[i][2])
        else:print(a[i][2],a[i+1][2])
        f =1
        break
    if a[i][1] >= a[i+1][1]:
        f = 1
        print(a[i+1][2],a[i][2])
        break
if f == 0:print(-1,-1)
",0976_C,CODEFORCES,2517,Nested Segments,"You are given a sequence a1, a2, ..., an of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment ai lies within segment aj.
Segment [l1, r1] lies within segment [l2, r2] iff l1 ≥ l2 and r1 ≤ r2.
Print indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
The first line contains one integer n (1 ≤ n ≤ 3·105) — the number of segments.
Each of the next n lines contains two integers li and ri (1 ≤ li ≤ ri ≤ 109) — the i-th segment.
","input
Print two distinct indices i and j such that segment ai lies within segment aj. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
output
In the first example the following pairs are considered correct:
","greedy, implementation, sortings",4
"n, m = map(int, input().split())
grid = []
for i in range(n):
    grid.append(input())
cnts = [0 for i in range(m)]
for i in range(n):
    for j in range(m):
        cnts[j] += 0 if grid[i][j] == '0' else 1
for i in range(n):
    flag = True
    for j in range(m):
        if grid[i][j] == '1' and cnts[j] == 1:
            flag = False
            break
    if flag:
        print('YES')
        exit(0)
print('NO')
 	    					 	  	 		 					  		 	",0985_B,CODEFORCES,3243,Switches and Lamps,"You are given n switches and m lamps. The i-th switch turns on some subset of the lamps. This information is given as the matrix a consisting of n rows and m columns where ai, j = 1 if the i-th switch turns on the j-th lamp and ai, j = 0 if the i-th switch is not connected to the j-th lamp.
Initially all m lamps are turned off.
Switches change state only from ""off"" to ""on"". It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards.
It is guaranteed that if you push all n switches then all m lamps will be turned on.
Your think that you have too many switches and you would like to ignore one of them. 
Your task is to say if there exists such a switch that if you will ignore (not use) it but press all the other n - 1 switches then all the m lamps will be turned on.
The first line of the input contains two integers n and m (1 ≤ n, m ≤ 2000) — the number of the switches and the number of the lamps.
The following n lines contain m characters each. The character ai, j is equal to '1' if the i-th switch turns on the j-th lamp and '0' otherwise.
","input
It is guaranteed that if you press all n switches all m lamps will be turned on.
output
Print ""YES"" if there is a switch that if you will ignore it and press all the other n - 1 switches then all m lamps will be turned on. Print ""NO"" if there is no such switch.
",implementation,5
"n = int(input())
x, y = [int(i) for i in input().split()]

d1 = abs(x - 1) + abs(y - 1)
d2 = abs(n - x) + abs(n - y)

print(""White"" if d1 <= d2 else ""Black"")
",1075_A,CODEFORCES,560,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"n,m = map(int,input().split())
for _ in range(m):
    x,y = map(int,input().split())

cnt = 0
ans = []
for i in range(n):
    if cnt%2 == 0:
        ans.append(""0"")

    else:
        ans.append(""1"")

    cnt += 1

print("""".join(ans))",1004_B,CODEFORCES,1765,Sonya and Exhibition,"Sonya decided to organize an exhibition of flowers. Since the girl likes only roses and lilies, she decided that only these two kinds of flowers should be in this exhibition.
There are $$$n$$$ flowers in a row in the exhibition. Sonya can put either a rose or a lily in the $$$i$$$-th position. Thus each of $$$n$$$ positions should contain exactly one flower: a rose or a lily.
She knows that exactly $$$m$$$ people will visit this exhibition. The $$$i$$$-th visitor will visit all flowers from $$$l_i$$$ to $$$r_i$$$ inclusive. The girl knows that each segment has its own beauty that is equal to the product of the number of roses and the number of lilies.
Sonya wants her exhibition to be liked by a lot of people. That is why she wants to put the flowers in such way that the sum of beauties of all segments would be maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\leq n, m\leq 10^3$$$) — the number of flowers and visitors respectively.
Each of the next $$$m$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1\leq l_i\leq r_i\leq n$$$), meaning that $$$i$$$-th visitor will visit all flowers from $$$l_i$$$ to $$$r_i$$$ inclusive.
Print the string of $$$n$$$ characters. The $$$i$$$-th symbol should be «0» if you want to put a rose in the $$$i$$$-th position, otherwise «1» if you want to put a lily.
If there are multiple answers, print any.
In the first example, Sonya can put roses in the first, fourth, and fifth positions, and lilies in the second and third positions;
The total beauty is equal to $$$2+2+4=8$$$.
","input
In the second example, Sonya can put roses in the third, fourth, and sixth positions, and lilies in the first, second, and fifth positions;
output
The total beauty is equal to $$$1+4+2=7$$$.
","constructivealgorithms, greedy, implementation, math",3
"n = int(input())
a = list(map(int, input().split()))
 
dp = [[505]*n for _ in range(n)]
Max = [[0]*n for _ in range(n)]
 
for i in range(n):  
    dp[i][i] = 1
    Max[i][i] = a[i]
 
for len in range(1, n+1):
    for i in range(n-len+1):
        j = i + len - 1
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:
                dp[i][j] = 1
                Max[i][j] = Max[i][k] + 1
print(dp[0][n-1])",1312_E,CODEFORCES,3866,Array Shrinking,"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation any number of times:
After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array $$$a$$$ you can get?
The first line contains the single integer $$$n$$$ ($$$1 \le n \le 500$$$) — the initial length of the array $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$) — the initial array $$$a$$$.
Print the only integer — the minimum possible length you can get after performing the operation described above any number of times.
In the first test, this is one of the optimal sequences of operations: $$$4$$$ $$$3$$$ $$$2$$$ $$$2$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$\rightarrow$$$ $$$5$$$ $$$3$$$.
","input
In the second test, this is one of the optimal sequences of operations: $$$3$$$ $$$3$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$5$$$ $$$4$$$ $$$\rightarrow$$$ $$$6$$$ $$$4$$$.
output
In the third and fourth tests, you can't perform the operation at all.
","dp, greedy",6
"import math
n=int(input())
# 99-9
# 999-99
a=[9]
for i in range(2,20):
    a.append(10**i   - 10**(i-1) )
b=[0]
for i in range(1,20):
    b.append(b[-1]+ i*a[i-1])
for i in range(20):
    if n<=b[i]:
        break
p=b[i-1]
k=n-p
# print(p,k)
ans=10**(i-1) - 1 + math.ceil(k/(i))
# print(k,p,i)
# print(ans,i,k)
if k%i==0:
    print(('0'+str(ans))[i])
else:
    print(('0'+str(ans))[k%i])",1177_B,CODEFORCES,1250,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"n = int(input())
a = list(map(int, input().split()))
max1 = float('inf')
for q in range(len(a)):
    if q >= n-q-1:
        max1 = min(max1, min(a[q], a[0])//q)
    if q <= n-q-1:
        max1 = min(max1, min(a[q], a[-1]) // (n-q-1))
print(max1)
",1159_B,CODEFORCES,2122,Expansion coefficient of the array,"Let's call an array of non-negative integers $$$a_1, a_2, \ldots, a_n$$$ a $$$k$$$-extension for some non-negative integer $$$k$$$ if for all possible pairs of indices $$$1 \leq i, j \leq n$$$ the inequality $$$k \cdot |i - j| \leq min(a_i, a_j)$$$ is satisfied. The expansion coefficient of the array $$$a$$$ is the maximal integer $$$k$$$ such that the array $$$a$$$ is a $$$k$$$-extension. Any array is a 0-expansion, so the expansion coefficient always exists.
You are given an array of non-negative integers $$$a_1, a_2, \ldots, a_n$$$. Find its expansion coefficient.
The first line contains one positive integer $$$n$$$ — the number of elements in the array $$$a$$$ ($$$2 \leq n \leq 300\,000$$$). The next line contains $$$n$$$ non-negative integers $$$a_1, a_2, \ldots, a_n$$$, separated by spaces ($$$0 \leq a_i \leq 10^9$$$).
Print one non-negative integer — expansion coefficient of the array $$$a_1, a_2, \ldots, a_n$$$.
","input
In the first test, the expansion coefficient of the array $$$[6, 4, 5, 5]$$$ is equal to $$$1$$$ because $$$|i-j| \leq min(a_i, a_j)$$$, because all elements of the array satisfy $$$a_i \geq 3$$$. On the other hand, this array isn't a $$$2$$$-extension, because $$$6 = 2 \cdot |1 - 4| \leq min(a_1, a_4) = 5$$$ is false.
output
In the second test, the expansion coefficient of the array $$$[0, 1, 2]$$$ is equal to $$$0$$$ because this array is not a $$$1$$$-extension, but it is $$$0$$$-extension.
","implementation, math",3
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
M=1000
for i in range(N):
    dp[i+M] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+M*k], dp[j+k+M*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+M*i] = u+1;break


#print(dp)
dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp[j+(i+1-j)*M] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",1312_E,CODEFORCES,3832,Array Shrinking,"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation any number of times:
After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array $$$a$$$ you can get?
The first line contains the single integer $$$n$$$ ($$$1 \le n \le 500$$$) — the initial length of the array $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$) — the initial array $$$a$$$.
Print the only integer — the minimum possible length you can get after performing the operation described above any number of times.
In the first test, this is one of the optimal sequences of operations: $$$4$$$ $$$3$$$ $$$2$$$ $$$2$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$\rightarrow$$$ $$$5$$$ $$$3$$$.
","input
In the second test, this is one of the optimal sequences of operations: $$$3$$$ $$$3$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$5$$$ $$$4$$$ $$$\rightarrow$$$ $$$6$$$ $$$4$$$.
output
In the third and fourth tests, you can't perform the operation at all.
","dp, greedy",6
"#!/usr/bin/python

x,k = map(int, input().strip().split())

MOD = 1000000007

if x > 0:
	r = (pow(2, k+1, MOD) * x - pow(2, k, MOD) + 1 + MOD * 10) % MOD
else:
	r = 0

print(r)",0992_C,CODEFORCES,1023,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"def solve(a):
    aa = sorted(a)
    maxr = aa[0]
    for ai in aa:
        if ai[2] != maxr[2]:
            if ai[1] <= maxr[1] and ai[0] >= maxr[0]:
                return(ai[2], maxr[2])
            if ai[1] >= maxr[1] and ai[0] <= maxr[0]:
                return(maxr[2], ai[2])
        if ai[1] > maxr[1]:
            maxr = ai
    return(-1, -1)

n = int(input())
a = []
for i in range(n):
    l,r = [int(s) for s in input().split()]
    a.append((l, r, i+1))
i,j = solve(a)
print(i,j)
",0976_C,CODEFORCES,2527,Nested Segments,"You are given a sequence a1, a2, ..., an of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment ai lies within segment aj.
Segment [l1, r1] lies within segment [l2, r2] iff l1 ≥ l2 and r1 ≤ r2.
Print indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
The first line contains one integer n (1 ≤ n ≤ 3·105) — the number of segments.
Each of the next n lines contains two integers li and ri (1 ≤ li ≤ ri ≤ 109) — the i-th segment.
","input
Print two distinct indices i and j such that segment ai lies within segment aj. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
output
In the first example the following pairs are considered correct:
","greedy, implementation, sortings",4
"# cook your dish here
# from math import * 
#for _ in range(int(input().strip())):

x,k = map(int,input().split())
if x==0:
    print(0)
    exit()
mod = 10**9+7
print((pow(2,k+1,mod)*x%mod - (pow(2,k,mod) - 1)) % mod )",0992_C,CODEFORCES,1058,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"n,s=map(int,input().split())
count=0
for i in range(n):
    count+=(s//(n-i))
    s-=(s//(n-i))*(n-i)
print(count)
",1061_A,CODEFORCES,524,Coins,"You have unlimited number of coins with values $$$1, 2, \ldots, n$$$. You want to select some set of coins having the total value of $$$S$$$. 
It is allowed to have multiple coins with the same value in the set. What is the minimum number of coins required to get sum $$$S$$$?
The only line of the input contains two integers $$$n$$$ and $$$S$$$ ($$$1 \le n \le 100\,000$$$, $$$1 \le S \le 10^9$$$)
Print exactly one integer — the minimum number of coins required to obtain sum $$$S$$$.
In the first example, some of the possible ways to get sum $$$11$$$ with $$$3$$$ coins are: 
It is impossible to get sum $$$11$$$ with less than $$$3$$$ coins.
","input
In the second example, some of the possible ways to get sum $$$16$$$ with $$$3$$$ coins are: 
output
It is impossible to get sum $$$16$$$ with less than $$$3$$$ coins.
","greedy, implementation, math",1
"'''input

'''
def solve():
	c,d = 0,0
	print(""?"",c,d,flush=True)
	ans = int(input())
	if ans==0:
		#both the numbers are equal 
		num = 0 
		for i in range(29,-1,-1):
			c = 1<<i
			d = 0
			print(""?"",c,d,flush=True)
			ans =int(input())
			if ans ==-2:
				return
			if ans == -1:
				num+=(1<<i)
		print(""!"",num,num)
	else:
		l = [0,0]
		if ans == 1:
			cur = 0 
		else:
			cur = 1

		prev = ans
		#first find set of mutually exclusive bits
		for i in range(29,-1,-1):
			tc = c|(1<<i)
			td = d|(1<<i)
			print(""?"",tc,td,flush=True)
			ans = int(input())
			if ans ==-2:
				return
			if ans ==0:
				break
			if ans !=prev:
				l[cur] += (1<<i)
				if cur ==0:
					c = tc
				else:
					d = td
				print(""?"",c,d,flush=True)
				temp = int(input())
				prev = temp
				if temp == 1:
					cur = 0
				else:
					cur = 1
		c = l[0]
		d = l[1]
		# now try to find common bits
		for i in range(29,-1,-1):
			if c&(1<<i) != 0 or d&(1<<i) !=0 :
				continue
			tc = c|(1<<i)
			print(""?"",tc,d,flush=True)
			ans = int(input())
			if ans==-2:
				return
			if ans==-1:
				l[0]|=(1<<i)
				l[1]|=(1<<i)
		print(""!"",l[0],l[1])
	return 

t = 1
# t = int(input())
while t>0:
	t-=1
	solve()",1088_D,CODEFORCES,1235,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",2
"n,k = map(int, input().split())
d = (n-k)//2+1
ans = ['1' if (i+1)%d==0 else '0' for i in range(n)]
print(''.join(ans))
",1159_D,CODEFORCES,2131,The minimal unique substring,"Let $$$s$$$ be some string consisting of symbols ""0"" or ""1"". Let's call a string $$$t$$$ a substring of string $$$s$$$, if there exists such number $$$1 \leq l \leq |s| - |t| + 1$$$ that $$$t = s_l s_{l+1} \ldots s_{l + |t| - 1}$$$. Let's call a substring $$$t$$$ of string $$$s$$$ unique, if there exist only one such $$$l$$$. 
For example, let $$$s = $$$""1010111"". A string $$$t = $$$""010"" is an unique substring of $$$s$$$, because $$$l = 2$$$ is the only one suitable number. But, for example $$$t = $$$""10"" isn't a unique substring of $$$s$$$, because $$$l = 1$$$ and $$$l = 3$$$ are suitable. And for example $$$t =$$$""00"" at all isn't a substring of $$$s$$$, because there is no suitable $$$l$$$.
Today Vasya solved the following problem at the informatics lesson: given a string consisting of symbols ""0"" and ""1"", the task is to find the length of its minimal unique substring. He has written a solution to this problem and wants to test it. He is asking you to help him.
You are given $$$2$$$ positive integers $$$n$$$ and $$$k$$$, such that $$$(n \bmod 2) = (k \bmod 2)$$$, where $$$(x \bmod 2)$$$ is operation of taking remainder of $$$x$$$ by dividing on $$$2$$$. Find any string $$$s$$$ consisting of $$$n$$$ symbols ""0"" or ""1"", such that the length of its minimal unique substring is equal to $$$k$$$.
The first line contains two integers $$$n$$$ and $$$k$$$, separated by spaces ($$$1 \leq k \leq n \leq 100\,000$$$, $$$(k \bmod 2) = (n \bmod 2)$$$).
Print a string $$$s$$$ of length $$$n$$$, consisting of symbols ""0"" and ""1"". Minimal length of the unique substring of $$$s$$$ should be equal to $$$k$$$. You can find any suitable string. It is guaranteed, that there exists at least one such string.
In the first test, it's easy to see, that the only unique substring of string $$$s = $$$""1111"" is all string $$$s$$$, which has length $$$4$$$.
","input
In the second test a string $$$s = $$$""01010"" has minimal unique substring $$$t =$$$""101"", which has length $$$3$$$.
output
In the third test a string $$$s = $$$""1011011"" has minimal unique substring $$$t =$$$""110"", which has length $$$3$$$.
","bruteforce, constructivealgorithms, greedy, math, strings",3
"class edge(object):
	def __init__(self,ne,to,fl):
		self.ne=ne
		self.to=to
		self.fl=fl

def add(x,y,z):
	global tot
	tot+=1
	e.append(edge(he[x],y,z))
	he[x]=tot

def addedge(x,y,z):
	add(x,y,z)
	add(y,x,0)

def bfs():
	global deep
	deep=[0 for i in range(T+1)]
	q=[]
	q.append(S)
	deep[S]=1
	while (len(q)>0):
		x=q[0]
		del(q[0])
		i=he[x]
		while (i):
			y=e[i].to
			if ((deep[y]==0)and(e[i].fl!=0)):
				deep[y]=deep[x]+1
				q.append(y)
			i=e[i].ne
	return deep[T]!=0

def dfs(x,flow):
	global deep
	if ((x==T)or(flow==0)):
		return flow
	used=0
	i=he[x]
	while (i):
		y=e[i].to
		if ((deep[y]==deep[x]+1)and(e[i].fl!=0)):
			now=dfs(y,min(flow-used,e[i].fl))
			used+=now
			e[i].fl-=now
			e[i^1].fl+=now
			if (flow==used):
				break;
		i=e[i].ne
	if (used==0):
		deep[x]=-1
	return used

def dinic():
	res=0
	while (bfs()):
		res+=dfs(S,INF)
	return res

n,m=map(int,input().split())
ans=0
weight=[0]+list(map(int,input().split()))

e=[0,0]
tot=1
S=n+m+1
T=S+1
he=[0 for i in range(T+1)]
INF=1000000007

for i in range(1,n+1):
	addedge(S,i,weight[i]);
for i in range(1,m+1):
	x,y,w=map(int,input().split())
	addedge(n+i,T,w)
	addedge(x,n+i,INF)
	addedge(y,n+i,INF)
	ans+=w
ans-=dinic()
print(ans)",1082_G,CODEFORCES,3787,Petya and Graph,"Petya has a simple graph (that is, a graph without loops or multiple edges) consisting of $$$n$$$ vertices and $$$m$$$ edges.
The weight of the $$$i$$$-th vertex is $$$a_i$$$.
The weight of the $$$i$$$-th edge is $$$w_i$$$.
A subgraph of a graph is some set of the graph vertices and some set of the graph edges. The set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. 
The weight of a subgraph is the sum of the weights of its edges, minus the sum of the weights of its vertices. You need to find the maximum weight of subgraph of given graph. The given graph does not contain loops and multiple edges.
The first line contains two numbers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^3, 0 \le m \le 10^3$$$) - the number of vertices and edges in the graph, respectively.
The next line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) - the weights of the vertices of the graph.
The following $$$m$$$ lines contain edges: the $$$i$$$-e edge is defined by a triple of integers $$$v_i, u_i, w_i$$$ ($$$1 \le v_i, u_i \le n, 1 \le w_i \le 10^9, v_i \neq u_i$$$). This triple means that between the vertices $$$v_i$$$ and $$$u_i$$$ there is an edge of weight $$$w_i$$$. It is guaranteed that the graph does not contain loops and multiple edges.
","input
Print one integer — the maximum weight of the subgraph of the given graph.
output
In the first test example, the optimal subgraph consists of the vertices $$${1, 3, 4}$$$ and has weight $$$4 + 4 + 5 - (1 + 2 + 2) = 8$$$. In the second test case, the optimal subgraph is empty.
","flows, graphs",6
"n = int(input())

m = input()

s = list(m)

if n==1:
    ans = s[0]
else:
    count = 0
    for i in range(0,n):
        if s[i]=='0':
            count = count + 1
    ans = '1'
    for i in range(0,count):
        ans = ans + '0'

print(ans)",0976_A,CODEFORCES,1637,Minimum Binary Number,"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".
You are given a correct string s.
You can perform two different operations on this string: 
Let val(s) be such a number that s is its binary representation.
Correct string a is less than some other correct string b iff val(a) < val(b).
Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).
The first line contains integer number n (1 ≤ n ≤ 100) — the length of string s.
The second line contains the string s consisting of characters ""0"" and ""1"". It is guaranteed that the string s is correct.
Print one string — the minimum correct string that you can obtain from the given one.
","input
In the first example you can obtain the answer by the following sequence of operations: ""1001""  ""1010""  ""1100""  ""100"".
output
In the second example you can't obtain smaller answer no matter what operations you use.
",implementation,3
"c = 0
def backtracking(actuales,restantes,l,r,x):
    global c
    if sum(actuales)<=r and sum(actuales) >= l:
        if max(actuales)- min(actuales) >= x:
            c += 1
    if restantes:
        for i in range(len(restantes)):
            backtracking(actuales+[restantes[i]], restantes[i+1:],l,r,x)
    return 0
def main():
    n,l,r,x = input().split("" "")
    n,l,r,x = int(n), int(l), int(r), int(x)
    difficulties = input().split("" "")
    for i in range(len(difficulties)):
        difficulties[i] = int(difficulties[i])
    difficulties.sort()
    backtracking([],difficulties,l,r,x) 
    global c     
    return c
 
if __name__ == ""__main__"":
    print(main())",0550_B,CODEFORCES,4427,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"def solve():
    from sys import stdin
    f_i = stdin
    
    n = int(f_i.readline())
    
    segments = []
    for i in range(n):
        x, w = map(int, f_i.readline().split())
        segments.append((x + w, x - w)) # (end, start)
    segments.sort()
    
    ans = 0
    t = segments[0][1]
    for end, start in segments:
        if t <= start:
            ans += 1
            t = end
    
    print(ans)

solve()",0528_B,CODEFORCES,2434,Clique Problem,"The clique problem is one of the most well-known NP-complete problems. Under some simplification it can be formulated as follows. Consider an undirected graph G. It is required to find a subset of vertices C of the maximum size such that any two of them are connected by an edge in graph G. Sounds simple, doesn't it? Nobody yet knows an algorithm that finds a solution to this problem in polynomial time of the size of the graph. However, as with many other NP-complete problems, the clique problem is easier if you consider a specific type of a graph.
Consider n distinct points on a line. Let the i-th point have the coordinate xi and weight wi. Let's form graph G, whose vertices are these points and edges connect exactly the pairs of points (i, j), such that the distance between them is not less than the sum of their weights, or more formally: |xi - xj| ≥ wi + wj.
Find the size of the maximum clique in such graph.
The first line contains the integer n (1 ≤ n ≤ 200 000) — the number of points.
Each of the next n lines contains two numbers xi, wi (0 ≤ xi ≤ 109, 1 ≤ wi ≤ 109) — the coordinate and the weight of a point. All xi are different.
Print a single number — the number of vertexes in the maximum clique of the given graph.
","input
If you happen to know how to solve this problem without using the specific properties of the graph formulated in the problem statement, then you are able to get a prize of one million dollars!
output
The picture for the sample test.
","dp, greedy",4
"N, K = map(int, input().split())
if N == K:
    print(""0""*N)
elif K == 1:
    print(""0""*(N-1) + ""1"")
elif K == 3:
    print(""1"" + ""0""*(N-4) + ""101"")
else:
    res = [""0""]*N
    for i in range(0, N, N//2-K//2+1):
        res[i] = ""1""
    print(''.join(res))",1159_D,CODEFORCES,2132,The minimal unique substring,"Let $$$s$$$ be some string consisting of symbols ""0"" or ""1"". Let's call a string $$$t$$$ a substring of string $$$s$$$, if there exists such number $$$1 \leq l \leq |s| - |t| + 1$$$ that $$$t = s_l s_{l+1} \ldots s_{l + |t| - 1}$$$. Let's call a substring $$$t$$$ of string $$$s$$$ unique, if there exist only one such $$$l$$$. 
For example, let $$$s = $$$""1010111"". A string $$$t = $$$""010"" is an unique substring of $$$s$$$, because $$$l = 2$$$ is the only one suitable number. But, for example $$$t = $$$""10"" isn't a unique substring of $$$s$$$, because $$$l = 1$$$ and $$$l = 3$$$ are suitable. And for example $$$t =$$$""00"" at all isn't a substring of $$$s$$$, because there is no suitable $$$l$$$.
Today Vasya solved the following problem at the informatics lesson: given a string consisting of symbols ""0"" and ""1"", the task is to find the length of its minimal unique substring. He has written a solution to this problem and wants to test it. He is asking you to help him.
You are given $$$2$$$ positive integers $$$n$$$ and $$$k$$$, such that $$$(n \bmod 2) = (k \bmod 2)$$$, where $$$(x \bmod 2)$$$ is operation of taking remainder of $$$x$$$ by dividing on $$$2$$$. Find any string $$$s$$$ consisting of $$$n$$$ symbols ""0"" or ""1"", such that the length of its minimal unique substring is equal to $$$k$$$.
The first line contains two integers $$$n$$$ and $$$k$$$, separated by spaces ($$$1 \leq k \leq n \leq 100\,000$$$, $$$(k \bmod 2) = (n \bmod 2)$$$).
Print a string $$$s$$$ of length $$$n$$$, consisting of symbols ""0"" and ""1"". Minimal length of the unique substring of $$$s$$$ should be equal to $$$k$$$. You can find any suitable string. It is guaranteed, that there exists at least one such string.
In the first test, it's easy to see, that the only unique substring of string $$$s = $$$""1111"" is all string $$$s$$$, which has length $$$4$$$.
","input
In the second test a string $$$s = $$$""01010"" has minimal unique substring $$$t =$$$""101"", which has length $$$3$$$.
output
In the third test a string $$$s = $$$""1011011"" has minimal unique substring $$$t =$$$""110"", which has length $$$3$$$.
","bruteforce, constructivealgorithms, greedy, math, strings",3
"n,k=map(int,input().split())
a=list(map(int,input().split()))
q={0}
e=0
l=[]
for i in range(n):
    if a[i] not in q:
        e+=1
        q.add(a[i])
    if e==k:
        e=0
        q={0}
        l+=[i]
w=10**5
t=0
for i in l:
    e=0
    q={0}
    for j in range(i,-1,-1):
        if a[j] not in q:
            e+=1
            q.add(a[j])
        if e==k:
            if w>len(q):
                w=j+1
                t=i+1
            break
if len(set(a))>=k:print(w,t)
else:print(-1,-1)
",0224_B,CODEFORCES,1465,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers",3
"import io
import os

from collections import Counter, defaultdict, deque


def solveBFS(NR, NG, NB, R, G, B):
    def pack(i, j, k):
        return i * 256 * 256 + j * 256 + k

    def unpack(ijk):
        i, jk = divmod(ijk, 256 * 256)
        j, k = divmod(jk, 256)
        return i, j, k

    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)
    dp = [0 for i in range(256 ** 3)]
    q = deque([0])
    while q:
        ijk = q.popleft()
        d = dp[ijk]
        i, j, k = unpack(ijk)

        if i < NR:
            r = R[i]

        if j < NG:
            g = G[j]
        if k < NB:
            b = B[k]
        if i + 1 <= NR and j + 1 <= NG:
            rg = pack(i + 1, j + 1, k)
            dp[rg] = max(dp[rg], r * g + d)
            q.append(rg)

        if i + 1 <= NR and k + 1 <= NB:
            rb = pack(i + 1, j, k + 1)
            dp[rb] = max(dp[rb], r * b + d)
            q.append(rb)

        if j + 1 <= NG and k + 1 <= NB:
            gb = pack(i, j + 1, k + 1)
            dp[gb] = max(dp[gb], g * b + d)
            q.append(gb)

    return max(dp)


def solve(NR, NG, NB, R, G, B):
    assert NR == len(R)
    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)

    R += [0]
    G += [0]
    B += [0]

    NR1 = NR + 2
    NG1 = NG + 2
    NB1 = NB + 2
    dp = [0 for i in range((NR1) * (NG1) * (NB1))]

    def pack(i, j, k):
        return i * NG1 * NB1 + j * NB1 + k

    inf = float(""inf"")
    for i in range(NR + 1):
        for j in range(NG + 1):
            dp[pack(i, j, -1)] = -inf
    for i in range(NR + 1):
        for k in range(NB + 1):
            dp[pack(i, -1, k)] = -inf

    for j in range(NG + 1):
        for k in range(NB + 1):
            dp[pack(-1, j, k)] = -inf

    for l in range(2, NR + NG + NB + 1, 2):
        for j in range(NG + 1):
            for k in range(NB + 1):
                i = l - j - k
                if i < 0 or i > NR:
                    continue
                r = R[i - 1]
                g = G[j - 1]
                b = B[k - 1]
                dp[pack(i, j, k)] = max(
                    r * g + dp[pack(i - 1, j - 1, k)],
                    r * b + dp[pack(i - 1, j, k - 1)],
                    b * g + dp[pack(i, j - 1, k - 1)],
                )

    return max(dp)


if False:
    import random

    random.seed()
    N = 5
    for t in range(100):
        R = [random.randint(1, 10) for i in range(random.randint(1, N))]
        G = [random.randint(1, 10) for i in range(random.randint(1, N))]
        B = [random.randint(1, 10) for i in range(random.randint(1, N))]
        ans1 = solveBFS(len(R), len(G), len(B), R, G, B)
        ans2 = solve(len(R), len(G), len(B), R, G, B)
        if ans1 != ans2:
            print(ans1, ans2)
            print(R, G, B)
        exit()
if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    NR, NG, NB = [int(x) for x in input().split()]
    R = [int(x) for x in input().split()]
    G = [int(x) for x in input().split()]
    B = [int(x) for x in input().split()]
    ans = solve(NR, NG, NB, R, G, B)
    print(ans)

",1398_D,CODEFORCES,3917,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"n = int(raw_input())
a = list(raw_input())
b = list(raw_input())

ans = 0

for i in range(n - 1):
    if a[i] == b[i]:
        continue
    if a[i + 1] == b[i + 1]:
        continue

    if a[i] == b[i + 1] and a[i + 1] == b[i]:
        a[i], a[i + 1] = a[i + 1], a[i]
        ans += 1


for i in range(n):
    ans += a[i] != b[i]

print(ans)
",1037_C,CODEFORCES,1919,Equalize,"You are given two binary strings $$$a$$$ and $$$b$$$ of the same length. You can perform the following two operations on the string $$$a$$$:
Find the minimum cost to make the string $$$a$$$ equal to $$$b$$$. It is not allowed to modify string $$$b$$$.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^6$$$) — the length of the strings $$$a$$$ and $$$b$$$.
The second and third lines contain strings $$$a$$$ and $$$b$$$ respectively.
Both strings $$$a$$$ and $$$b$$$ have length $$$n$$$ and contain only '0' and '1'.
Output the minimum cost to make the string $$$a$$$ equal to $$$b$$$.
In the first example, one of the optimal solutions is to flip index $$$1$$$ and index $$$3$$$, the string $$$a$$$ changes in the following way: ""100"" $$$\to$$$ ""000"" $$$\to$$$ ""001"". The cost is $$$1 + 1 = 2$$$.
","input
The other optimal solution is to swap bits and indices $$$1$$$ and $$$3$$$, the string $$$a$$$ changes then ""100"" $$$\to$$$ ""001"", the cost is also $$$|1 - 3| = 2$$$.
output
In the second example, the optimal solution is to swap bits at indices $$$2$$$ and $$$3$$$, the string $$$a$$$ changes as ""0101"" $$$\to$$$ ""0011"". The cost is $$$|2 - 3| = 1$$$.
","dp, greedy, strings",3
"x,k=map(int,input().split())
mod=1000000007
print((pow(2,k+1,mod)*x-pow(2,k,mod)+1)%mod if x>0 else 0)",0992_C,CODEFORCES,1111,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n, m = read_int_array()
    bmin = read_int_array()
    gmax = read_int_array()

    bmin.sort()
    gmax.sort()

    max_boy = bmin[-1]
    min_girl = gmax[0]
    if max_boy > min_girl:
        write(-1)
    elif max_boy == min_girl:
        bmin.pop()
        out = sum(gmax) + sum(x * m for x in bmin)
        write(out)
    else:
        bmin.pop()
        out = sum(gmax) - min_girl + max_boy
        out += min_girl + bmin[-1] * (m-1)
        bmin.pop()
        out += sum(x * m for x in bmin)
        write(out)


main()
",1159_C,CODEFORCES,2924,The Party and Sweets,"$$$n$$$ boys and $$$m$$$ girls came to the party. Each boy presented each girl some integer number of sweets (possibly zero). All boys are numbered with integers from $$$1$$$ to $$$n$$$ and all girls are numbered with integers from $$$1$$$ to $$$m$$$. For all $$$1 \leq i \leq n$$$ the minimal number of sweets, which $$$i$$$-th boy presented to some girl is equal to $$$b_i$$$ and for all $$$1 \leq j \leq m$$$ the maximal number of sweets, which $$$j$$$-th girl received from some boy is equal to $$$g_j$$$.
More formally, let $$$a_{i,j}$$$ be the number of sweets which the $$$i$$$-th boy give to the $$$j$$$-th girl. Then $$$b_i$$$ is equal exactly to the minimum among values $$$a_{i,1}, a_{i,2}, \ldots, a_{i,m}$$$ and $$$g_j$$$ is equal exactly to the maximum among values $$$b_{1,j}, b_{2,j}, \ldots, b_{n,j}$$$.
You are interested in the minimum total number of sweets that boys could present, so you need to minimize the sum of $$$a_{i,j}$$$ for all $$$(i,j)$$$ such that $$$1 \leq i \leq n$$$ and $$$1 \leq j \leq m$$$. You are given the numbers $$$b_1, \ldots, b_n$$$ and $$$g_1, \ldots, g_m$$$, determine this number. 
The first line contains two integers $$$n$$$ and $$$m$$$, separated with space — the number of boys and girls, respectively ($$$2 \leq n, m \leq 100\,000$$$). The second line contains $$$n$$$ integers $$$b_1, \ldots, b_n$$$, separated by spaces — $$$b_i$$$ is equal to the minimal number of sweets, which $$$i$$$-th boy presented to some girl ($$$0 \leq b_i \leq 10^8$$$). The third line contains $$$m$$$ integers $$$g_1, \ldots, g_m$$$, separated by spaces — $$$g_j$$$ is equal to the maximal number of sweets, which $$$j$$$-th girl received from some boy ($$$0 \leq g_j \leq 10^8$$$).
If the described situation is impossible, print $$$-1$$$. In another case, print the minimal total number of sweets, which boys could have presented and all conditions could have satisfied.
In the first test, the minimal total number of sweets, which boys could have presented is equal to $$$12$$$. This can be possible, for example, if the first boy presented $$$1$$$ and $$$4$$$ sweets, the second boy presented $$$3$$$ and $$$2$$$ sweets and the third boy presented $$$1$$$ and $$$1$$$ sweets for the first and the second girl, respectively. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$12$$$.
","input
In the second test, the boys couldn't have presented sweets in such way, that all statements satisfied.
output
In the third test, the minimal total number of sweets, which boys could have presented is equal to $$$4$$$. This can be possible, for example, if the first boy presented $$$1$$$, $$$1$$$, $$$2$$$ sweets for the first, second, third girl, respectively and the second boy didn't present sweets for each girl. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$4$$$.
","greedy, implementation, math",4
"n, m = map(int, input().split())
daf1 = list(map(int, input().split()))
daf2 = dict()

for i in range(n):
    daf2[i+1] = 0

for i in daf1:
    if i in daf2.keys():
        daf2[i] += 1

print(min(daf2.values()))
",0961_A,CODEFORCES,3165,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation,5
"# import os

n,m = map(int,input().split())

a = list(map(int,input().split()))
b = list(map(int,input().split()))

r = []

for i in a:
    if i in b:
        r.append(i)
print(' '.join(map(str, r)))


",0994_A,CODEFORCES,3307,Fingerprints,"You are locked in a room with a door that has a keypad with 10 keys corresponding to digits from 0 to 9. To escape from the room, you need to enter a correct code. You also have a sequence of digits.
Some keys on the keypad have fingerprints. You believe the correct code is the longest not necessarily contiguous subsequence of the sequence you have that only contains digits with fingerprints on the corresponding keys. Find such code.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 10$$$) representing the number of digits in the sequence you have and the number of keys on the keypad that have fingerprints.
The next line contains $$$n$$$ distinct space-separated integers $$$x_1, x_2, \ldots, x_n$$$ ($$$0 \le x_i \le 9$$$) representing the sequence.
The next line contains $$$m$$$ distinct space-separated integers $$$y_1, y_2, \ldots, y_m$$$ ($$$0 \le y_i \le 9$$$) — the keys with fingerprints.
In a single line print a space-separated sequence of integers representing the code. If the resulting sequence is empty, both printing nothing and printing a single line break is acceptable.
","input
In the first example, the only digits with fingerprints are $$$1$$$, $$$2$$$ and $$$7$$$. All three of them appear in the sequence you know, $$$7$$$ first, then $$$1$$$ and then $$$2$$$. Therefore the output is 7 1 2. Note that the order is important, and shall be the same as the order in the original sequence.
output
In the second example digits $$$0$$$, $$$1$$$, $$$7$$$ and $$$9$$$ have fingerprints, however only $$$0$$$ and $$$1$$$ appear in the original sequence. $$$1$$$ appears earlier, so the output is 1 0. Again, the order is important.
",implementation,5
"from sys import stdin,stdout
from math import ceil,log
def main():
	d={}
	n=int(stdin.readline())
	a=list(map(int,stdin.readline().split( )))
	m=-1;mm=10**10
	for v in a:
		if v not in d:
			d[v]=1
		else:
			d[v]+=1
		m=max(m,v)
		mm=min(mm,v)
	ans=0
	
	for v in a:
		
		exponent=ceil(log(v,2))
		power=2**exponent
		find=0
		while power-v>=0:
			if power-v>mm and power-v>m:
				break
			
			element=power-v
			if element in d and element==v and d[element]>1:
				find=1
				break
			elif element in d and element!=v:
				find=1
				break
			power=power*2
		if find==0:
			ans+=1
	stdout.write(""%d\n""%(ans))

main()",1005_C,CODEFORCES,2675,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation",4
"
rd = lambda: list(map(int, input().split()))
n, k = rd()
a = rd()
r = 0
s = [0]
for x in a:
    s.append(s[-1] + x)
for i in range(n - k + 1):
    for j in range(i + k, min(n + 1, i + 2 * k)):
        r = max(r, (s[j] - s[i]) / (j - i))
print(r)
",1003_C,CODEFORCES,3354,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math",5
"import sys
stdin=sys.stdin

ip=lambda: int(sp())
fp=lambda: float(sp())
lp=lambda:list(map(int,stdin.readline().split()))
sp=lambda:stdin.readline().rstrip()
Yp=lambda:print('Yes')
Np=lambda:print('No')

N = ip()
L = []
for _ in range(N):
    x,w = lp()
    L.append([x-w,x+w])
L.sort(reverse=True)
ans = 0
edge = 1<<40
for i in range(N):
    if L[i][1] <= edge:
        edge = L[i][0]
        ans += 1
print(ans)",0528_B,CODEFORCES,2422,Clique Problem,"The clique problem is one of the most well-known NP-complete problems. Under some simplification it can be formulated as follows. Consider an undirected graph G. It is required to find a subset of vertices C of the maximum size such that any two of them are connected by an edge in graph G. Sounds simple, doesn't it? Nobody yet knows an algorithm that finds a solution to this problem in polynomial time of the size of the graph. However, as with many other NP-complete problems, the clique problem is easier if you consider a specific type of a graph.
Consider n distinct points on a line. Let the i-th point have the coordinate xi and weight wi. Let's form graph G, whose vertices are these points and edges connect exactly the pairs of points (i, j), such that the distance between them is not less than the sum of their weights, or more formally: |xi - xj| ≥ wi + wj.
Find the size of the maximum clique in such graph.
The first line contains the integer n (1 ≤ n ≤ 200 000) — the number of points.
Each of the next n lines contains two numbers xi, wi (0 ≤ xi ≤ 109, 1 ≤ wi ≤ 109) — the coordinate and the weight of a point. All xi are different.
Print a single number — the number of vertexes in the maximum clique of the given graph.
","input
If you happen to know how to solve this problem without using the specific properties of the graph formulated in the problem statement, then you are able to get a prize of one million dollars!
output
The picture for the sample test.
","dp, greedy",4
"import sys,bisect,string,math,time,functools,random,fractions
from heapq import heappush,heappop,heapify
from collections import deque,defaultdict,Counter
from itertools import permutations,combinations,groupby
rep=range;R=range
def Golf():n,*t=map(int,open(0).read().split())
def I():return int(input())
def S_():return input()
def IS():return input().split()
def LS():return [i for i in input().split()]
def MI():return map(int,input().split())
def LI():return [int(i) for i in input().split()]
def LI_():return [int(i)-1 for i in input().split()]
def NI(n):return [int(input()) for i in range(n)]
def NI_(n):return [int(input())-1 for i in range(n)]
def StoLI():return [ord(i)-97 for i in input()]
def ItoS(n):return chr(n+97)
def LtoS(ls):return ''.join([chr(i+97) for i in ls])
def RA():return map(int,open(0).read().split())
def RLI(n=8,a=1,b=10):return [random.randint(a,b)for i in range(n)]
def RI(a=1,b=10):return random.randint(a,b)
def Rtest(T):
    case,err=0,0
    for i in range(T):
        inp=INP()
        a1,ls=naive(*inp)
        a2=solve(*inp)
        if a1!=a2:
            print((a1,a2),inp)
            err+=1
        case+=1
    print('Tested',case,'case with',err,'errors')
def GI(V,E,ls=None,Directed=False,index=1):
    org_inp=[];g=[[] for i in range(V)]
    FromStdin=True if ls==None else False
    for i in range(E):
        if FromStdin:
            inp=LI()
            org_inp.append(inp)
        else:
            inp=ls[i]
        if len(inp)==2:
            a,b=inp;c=1
        else:
            a,b,c=inp
        if index==1:a-=1;b-=1
        aa=(a,c);bb=(b,c);g[a].append(bb)
        if not Directed:g[b].append(aa)
    return g,org_inp
def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1):
    #h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1) # sample usage
    mp=[boundary]*(w+2);found={}
    for i in R(h):
        s=input()
        for char in search:
            if char in s:
                found[char]=((i+1)*(w+2)+s.index(char)+1)
                mp_def[char]=mp_def[replacement_of_found]
        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]
    mp+=[boundary]*(w+2)
    return h+2,w+2,mp,found
def TI(n):return GI(n,n-1)
def accum(ls):
    rt=[0]
    for i in ls:rt+=[rt[-1]+i]
    return rt
def bit_combination(n,base=2):
    rt=[]
    for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s]
    return rt
def gcd(x,y):
    if y==0:return x
    if x%y==0:return y
    while x%y!=0:x,y=y,x%y
    return y
def YN(x):print(['NO','YES'][x])
def Yn(x):print(['No','Yes'][x])
def show(*inp,end='\n'):
    if show_flg:print(*inp,end=end)

mo=10**9+7
inf=float('inf')
FourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip('WENS',FourNb));cursol=dict(zip('LRUD',FourNb))
l_alp=string.ascii_lowercase
#sys.setrecursionlimit(10**9)
read=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()


show_flg=False
show_flg=True

ans=0

#for _ in range(I()):
x,y,z=LI()
R=sorted(LI())[::-1]
G=sorted(LI())[::-1]
B=sorted(LI())[::-1]

dp=[[[0]*(z+1) for j in range(y+1)]for i in range(x+1)]

n=x+y+z
for t in range(0,n+1,2):
    for i in range(x+1):
        for j in range(y+1):
            k=t-i-j
            if 0<=k<=z:
                if i+1<=x and j+1<=y:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
                if i+1<=x and k+1<=z:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
                if j+1<=y and k+1<=z:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])
                #show((i,j,k),dp)
ans=max([dp[i][y][z]for i in range(x+1)])
ans=max(max([dp[x][i][z]for i in range(y+1)]),ans)
ans=max(max([dp[x][y][i]for i in range(z+1)]),ans)

print(ans)


    
    
    
    ",1398_D,CODEFORCES,3960,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"from sys import stdin
input = stdin.readline

n = int(input())
a = []
for i in range(4):
    a.append([[int(x) for x in list(input().rstrip())] for _ in range(n)])
    if i < 3: input()
b = []
for i in range(4):
    b.append([])
    for j in range(2):
        c = 0
        for y in range(n):
            for x in range(n):
                if j == 1:   
                    z = (x + y) % 2
                else:
                    z = 1 - (x + y) % 2
                c += a[i][y][x] != z
        b[-1].append(c)
ans = float(""inf"")
for i in (3, 5, 6, 9, 10, 12):
    ans = min(ans, b[0][i & 1] + b[1][i >> 1 & 1] + b[2][i >> 2 & 1] + b[3][i >> 3 & 1])
print(ans)",0961_C,CODEFORCES,3175,Chessboard,"Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into 4 pieces, each of size n by n, n is always odd. And what's even worse, some squares were of wrong color. j-th square of the i-th row of k-th piece of the board has color ak, i, j; 1 being black and 0 being white. 
Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be 2n by 2n. You are allowed to move pieces but not allowed to rotate or flip them.
The first line contains odd integer n (1 ≤ n ≤ 100) — the size of all pieces of the board. 
","input
Then 4 segments follow, each describes one piece of the board. Each consists of n lines of n characters; j-th one of i-th line is equal to 1 if the square is black initially and 0 otherwise. Segments are separated by an empty line.
output
Print one number — minimum number of squares Magnus should recolor to be able to obtain a valid chessboard.
","bitmasks, bruteforce, implementation",5
"import math

n,m,kk=[int(x) for x in input().split()]
right,down=[],[]
for i in range(n) :
	a=[int(x) for x in input().split()]
	right.append(a)

for i in range(n-1) :
	a=[int(x) for x in input().split()]
	down.append(a)

dp,dpCopy=[],[]
for i in range(n) :
	li,li1=[],[]
	for j in range(m) :
		li.append(math.inf)
		li1.append(math.inf)
	dp.append(li)
	dpCopy.append(li1)

'''for i in range(n) :
	li=[]
	for j in range(m) :
		li.append(math.inf)
	dpCopy.append(li)'''

for i in range(1,(kk//2)+1) :
	#print(i)
	for j in range(n) :
		for k in range(m) :
			if i==1 :
				if j==0 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j][k])
				elif j==n-1 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j-1][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k])
				elif k==0 :
					dp[j][k]=min(dp[j][k],right[j][k],down[j-1][k],down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k],down[j][k])
				else :
					dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k],down[j][k])
				#print(dpCopy)
				continue

			if j==0 :
				if k==0 :
					dp[j][k]=min(dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j+1][k]+down[j][k])
				else :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
			elif j==n-1 :
				if k==0 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k+1]+right[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1])
				else :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])
			elif k==0 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k+1]+right[j][k])
			elif k==m-1 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1])
			else :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])
			#print(dp)

	for ii in range(n) :
		for jj in range(m) :
			dpCopy[ii][jj]=dp[ii][jj]

if kk%2==1 :
	for i in range(n) :
		for j in range(m) :
			print(-1,end=' ')
		print()
	exit(0)

for i in range(n) :
	for j in range(m) :
		print(2*dp[i][j],end=' ')
	print()",1517_D,CODEFORCES,4152,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"def sss(l,r,tt):
    f = -1
    while(l<=r):
        mid = (l + r) >> 1
        if(a[mid]-a[tt] <= m):
           f = mid
           l = mid + 1
        else :
           r = mid - 1
    return f

n , m =  map(int, input().split())
a = [int(x) for x in input().split()]
f = 0
l  = len(a)
#print(""l=="" + str(l))
Maxx = -1
for i in range(0,l-2):
    if(a[i+2] - a[i]<= m):
         k = sss(i+2,l-1,i)
         if(k != -1):
             Maxx = max(Maxx,(a[k] - a[i+1])/(a[k]-a[i]))
if(Maxx == -1):
    print(-1)
else: print(""%.15f\n"" % Maxx)",0957_C,CODEFORCES,2471,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers",4
"""""""
2 3 1 2
""""""


import sys
import bisect
import heapq
import math

INF = 10**9+7
sys.setrecursionlimit(INF)

def fi():
    return int(sys.stdin.readline())

def fi2():
    return map(int, sys.stdin.readline().split())

def fi3():
    return sys.stdin.readline().rstrip()

def fo(*args):
    for s in args:
        sys.stdout.write(str(s)+' ')
    sys.stdout.write('\n')
##    sys.stdout.flush()

def puts(*args):
    for s in args:
        sys.stdout.write(str(s))

##

def mask(n1):
    arr = []
    for i in range(64):
        arr.append(n1&1)
        n1 = n1 >> 1
    arr.reverse()
    return arr

def getn(mask):
    if sum(mask) == 0:
        return 0
    res = 0
    for i in range(63, -1, -1):
        res += (2*mask[i])**(63-i)
    return res





##
#main

n1, n2 = fi2()
m1 = mask(n1)
m2 = mask(n2)



sol = [0 for i in range(64)]

for i in range(64):
    if m1[i] != m2[i]:
        sol[i] = 1
        break
    
i += 1
for j in range(i, 64):
    sol[j] = 1

res = getn(sol)
fo(res)


            
                

            
        

    

",0276_D,CODEFORCES,812,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"from collections import deque
import sys
input = sys.stdin.readline

n, d, k = map(int, input().split())
if n == 1 or n <= d:
    ans = ""NO""
elif k == 1:
    ans = ""YES"" if n == 2 and d == 1 else ""NO""
    e = [(1, 2)]
else:
    e = [(i + 1, i + 2) for i in range(d)]
    q = deque()
    l, r = 1, d + 1
    if k > 2:
        for i in range(2, d + 1):
            q.append((i, 2, min(i - l, r - i)))
    ans = ""YES""
    for i in range(d + 2, n + 1):
        if not q:
            ans = ""NO""
            break
        j, k0, d0 = q.popleft()
        e.append((j, i))
        if k0 + 1 < k:
            q.append((j, k0 + 1, d0))
        if d0 - 1 > 0:
            q.append((i, 1, d0 - 1))
print(ans)
if ans == ""YES"":
    for u, v in e:
        print(u, v)",1003_E,CODEFORCES,3359,Tree Constructing,"You are given three integers $$$n$$$, $$$d$$$ and $$$k$$$.
Your task is to construct an undirected tree on $$$n$$$ vertices with diameter $$$d$$$ and degree of each vertex at most $$$k$$$, or say that it is impossible.
An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Diameter of a tree is the maximum length of a simple path (a path in which each vertex appears at most once) between all pairs of vertices of this tree.
Degree of a vertex is the number of edges incident to this vertex (i.e. for a vertex $$$u$$$ it is the number of edges $$$(u, v)$$$ that belong to the tree, where $$$v$$$ is any other vertex of a tree).
The first line of the input contains three integers $$$n$$$, $$$d$$$ and $$$k$$$ ($$$1 \le n, d, k \le 4 \cdot 10^5$$$).
","input
If there is no tree satisfying the conditions above, print only one word ""NO"" (without quotes).
output
Otherwise in the first line print ""YES"" (without quotes), and then print $$$n - 1$$$ lines describing edges of a tree satisfying the conditions above. Vertices of the tree must be numbered from $$$1$$$ to $$$n$$$. You can print edges and vertices connected by an edge in any order. If there are multiple answers, print any of them.1
","constructivealgorithms, graphs",5
"n, v = map(int, input().split())

result = v-1 + (n-v)*(n-v+1)//2 if n-1 > v else n-1
print(result)",1113_A,CODEFORCES,680,Sasha and His Trip,"Sasha is a very happy guy, that's why he is always on the move. There are $$$n$$$ cities in the country where Sasha lives. They are all located on one straight line, and for convenience, they are numbered from $$$1$$$ to $$$n$$$ in increasing order. The distance between any two adjacent cities is equal to $$$1$$$ kilometer. Since all roads in the country are directed, it's possible to reach the city $$$y$$$ from the city $$$x$$$ only if $$$x < y$$$. 
Once Sasha decided to go on a trip around the country and to visit all $$$n$$$ cities. He will move with the help of his car, Cheetah-2677. The tank capacity of this model is $$$v$$$ liters, and it spends exactly $$$1$$$ liter of fuel for $$$1$$$ kilometer of the way. At the beginning of the journey, the tank is empty. Sasha is located in the city with the number $$$1$$$ and wants to get to the city with the number $$$n$$$. There is a gas station in each city. In the $$$i$$$-th city, the price of $$$1$$$ liter of fuel is $$$i$$$ dollars. It is obvious that at any moment of time, the tank can contain at most $$$v$$$ liters of fuel.
Sasha doesn't like to waste money, that's why he wants to know what is the minimum amount of money is needed to finish the trip if he can buy fuel in any city he wants. Help him to figure it out!
The first line contains two integers $$$n$$$ and $$$v$$$ ($$$2 \le n \le 100$$$, $$$1 \le v \le 100$$$)  — the number of cities in the country and the capacity of the tank.
Print one integer — the minimum amount of money that is needed to finish the trip.
","input
In the first example, Sasha can buy $$$2$$$ liters for $$$2$$$ dollars ($$$1$$$ dollar per liter) in the first city, drive to the second city, spend $$$1$$$ liter of fuel on it, then buy $$$1$$$ liter for $$$2$$$ dollars in the second city and then drive to the $$$4$$$-th city. Therefore, the answer is $$$1+1+2=4$$$.
output
In the second example, the capacity of the tank allows to fill the tank completely in the first city, and drive to the last city without stops in other cities.
","dp, greedy, math",1
"import sys, os
 
numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)
 
base = []
out = []
 
for i in range(n):
    x = numbs[i]
    how = 0
    
    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep
    
    if x:
        how |= 1 << i
 
        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))
    
        out.append(0)
    else:
        outind = len(out)
        out.append(-1)
        
        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind
 
os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))",0504_D,CODEFORCES,4384,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks,7
"def onseg(p,q,r):
    return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and \
           min(p[1], r[1]) <= q[1] <= max(p[1], r[1])

def orientation(p,q,r):
    val = (q[1] - p[1]) * (r[0] - q[0]) - \
          (q[0] - p[0]) * (r[1] - q[1])
 
    if (val == 0): return 0  # colinear
    return 1 if val > 0 else 2 # clock or counterclock wise

def doint(p1, q1, p2, q2):
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)
 
    if o1 != o2 and o3 != o4:
        return True
 
    if o1 == 0 and onseg(p1, p2, q1): return True
    if o2 == 0 and onseg(p1, q2, q1): return True
    if o3 == 0 and onseg(p2, p1, q2): return True
    if o4 == 0 and onseg(p2, q1, q2): return True
 
    return False

x0,y0,x1,y1,x2,y2,x3,y3 = map(int,input().split())
x4,y4,x5,y5,x6,y6,x7,y7 = map(int,input().split())

A = x0,y0
B = x1,y1
C = x2,y2
D = x3,y3
a = x4,y4
b = x5,y5
c = x6,y6
d = x7,y7

if doint(A,B,a,b) or doint(A,C,a,b) or doint(A,D,a,b) or doint(B,C,a,b) or doint(B,D,a,b) or doint(C,D,a,b) or \
   doint(A,B,a,c) or doint(A,C,a,c) or doint(A,D,a,c) or doint(B,C,a,c) or doint(B,D,a,c) or doint(C,D,a,c) or \
   doint(A,B,a,d) or doint(A,C,a,d) or doint(A,D,a,d) or doint(B,C,a,d) or doint(B,D,a,d) or doint(C,D,a,d) or \
   doint(A,B,b,c) or doint(A,C,b,c) or doint(A,D,b,c) or doint(B,C,b,c) or doint(B,D,b,c) or doint(C,D,b,c) or \
   doint(A,B,b,d) or doint(A,C,b,d) or doint(A,D,b,d) or doint(B,C,b,d) or doint(B,D,b,d) or doint(C,D,b,d) or \
   doint(A,B,c,d) or doint(A,C,c,d) or doint(A,D,c,d) or doint(B,C,c,d) or doint(B,D,c,d) or doint(C,D,c,d):
    print('YES')
else:
    print('NO')

",0994_C,CODEFORCES,392,Two Squares,"You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.
The interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.
The input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order.
The first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees.
All the values are integer and between $$$-100$$$ and $$$100$$$.
Print ""Yes"" if squares intersect, otherwise print ""No"".
You can print each letter in any case (upper or lower).
In the first example the second square lies entirely within the first square, so they do intersect.
","input
In the second sample squares do not have any points in common.
output
Here are images corresponding to the samples:
",bruteforce,1
"import math
for _ in range (int(input())):
    n=int(input())
    s=1
    ch=0
    for i in range (1,31):
        s*=2
        d=math.sqrt(n//s)
        if n%s==0 and d==int(d):
            ch=1
            break
    if ch:
        print(""YES"")
    else:
        print(""NO"")",1515_B,CODEFORCES,767,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",1
"n, t = map(int, input().split())
arr = []
for i in range(n):
    a, b = map(int, input().split())
    arr.append((a-(b / 2), a+ (b / 2)))
 
arr.sort()
ans = 0
for i in range(1, n):
    if abs(arr[i][0] - arr[i - 1][1]) == t:
        ans += 1
    elif abs(arr[i][0] - arr[i - 1][1]) > t:
        ans += 2
print(ans + 2)",0015_A,CODEFORCES,2266,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))

if max(b) > min(g):
    print(-1)
else:
    total = m*sum(b)
    b.sort()
    g.sort()
    while len(g) > 0:
        current = 0
        count = 1
        if len(b) > 0:
            current = b.pop()
        while len(g) > 0 and g[-1] > current and count < m:
            total += g[-1] - current
            g.pop()
            count += 1
        while len(g) > 0 and g[-1] == current:
            g.pop()
    print(total)
",1159_C,CODEFORCES,2938,The Party and Sweets,"$$$n$$$ boys and $$$m$$$ girls came to the party. Each boy presented each girl some integer number of sweets (possibly zero). All boys are numbered with integers from $$$1$$$ to $$$n$$$ and all girls are numbered with integers from $$$1$$$ to $$$m$$$. For all $$$1 \leq i \leq n$$$ the minimal number of sweets, which $$$i$$$-th boy presented to some girl is equal to $$$b_i$$$ and for all $$$1 \leq j \leq m$$$ the maximal number of sweets, which $$$j$$$-th girl received from some boy is equal to $$$g_j$$$.
More formally, let $$$a_{i,j}$$$ be the number of sweets which the $$$i$$$-th boy give to the $$$j$$$-th girl. Then $$$b_i$$$ is equal exactly to the minimum among values $$$a_{i,1}, a_{i,2}, \ldots, a_{i,m}$$$ and $$$g_j$$$ is equal exactly to the maximum among values $$$b_{1,j}, b_{2,j}, \ldots, b_{n,j}$$$.
You are interested in the minimum total number of sweets that boys could present, so you need to minimize the sum of $$$a_{i,j}$$$ for all $$$(i,j)$$$ such that $$$1 \leq i \leq n$$$ and $$$1 \leq j \leq m$$$. You are given the numbers $$$b_1, \ldots, b_n$$$ and $$$g_1, \ldots, g_m$$$, determine this number. 
The first line contains two integers $$$n$$$ and $$$m$$$, separated with space — the number of boys and girls, respectively ($$$2 \leq n, m \leq 100\,000$$$). The second line contains $$$n$$$ integers $$$b_1, \ldots, b_n$$$, separated by spaces — $$$b_i$$$ is equal to the minimal number of sweets, which $$$i$$$-th boy presented to some girl ($$$0 \leq b_i \leq 10^8$$$). The third line contains $$$m$$$ integers $$$g_1, \ldots, g_m$$$, separated by spaces — $$$g_j$$$ is equal to the maximal number of sweets, which $$$j$$$-th girl received from some boy ($$$0 \leq g_j \leq 10^8$$$).
If the described situation is impossible, print $$$-1$$$. In another case, print the minimal total number of sweets, which boys could have presented and all conditions could have satisfied.
In the first test, the minimal total number of sweets, which boys could have presented is equal to $$$12$$$. This can be possible, for example, if the first boy presented $$$1$$$ and $$$4$$$ sweets, the second boy presented $$$3$$$ and $$$2$$$ sweets and the third boy presented $$$1$$$ and $$$1$$$ sweets for the first and the second girl, respectively. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$12$$$.
","input
In the second test, the boys couldn't have presented sweets in such way, that all statements satisfied.
output
In the third test, the minimal total number of sweets, which boys could have presented is equal to $$$4$$$. This can be possible, for example, if the first boy presented $$$1$$$, $$$1$$$, $$$2$$$ sweets for the first, second, third girl, respectively and the second boy didn't present sweets for each girl. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$4$$$.
","greedy, implementation, math",4
"n,k = map(int,input().split())
s = input()
f = 0
for i in range(1,n):
    if s[:n-i]==s[i:]:
        f=1
        break
if f==0:
    print(s*k)
else:
    j = n-i
    final = s[j:]
    print(s+final*(k-1))",1029_A,CODEFORCES,3455,Many Equal Substrings,"You are given a string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters and an integer number $$$k$$$.
Let's define a substring of some string $$$s$$$ with indices from $$$l$$$ to $$$r$$$ as $$$s[l \dots r]$$$.
Your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ positions $$$i$$$ such that $$$s[i \dots i + n - 1] = t$$$. In other words, your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
It is guaranteed that the answer is always unique.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 50$$$) — the length of the string $$$t$$$ and the number of substrings.
The second line of the input contains the string $$$t$$$ consisting of exactly $$$n$$$ lowercase Latin letters.
","input
Print such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
output
It is guaranteed that the answer is always unique.
","implementation, strings",5
"import zlib, base64
exec(zlib.decompress(base64.b64decode(b'eJyFV8lu2zAQPTdfIenAUGhR9FygXxLk4MJu4SJwAscJSIEfX4nLzHtDpT0kGM6+j3w83IYfw8M0BhemL8M0+pBiWuYMBzdGtwjYgMUpWGRWtnFJq6Srkh7g4JqSjW9Jm3wKjdYohIzALkivfuX/m02nYBUJ2ZNVLjZPAM5hrFTR5BFGasLg/RbOvPniIsSU0AXAtMgMnanRShPVFx+QA+jRad5CyWhoMUbIqCBL0RII5jSZd+Fg+sLB7dpNWOItRcaFNKqVyFpKgdkR9ELB2PpzhIJGt1amli/aSDlOQ1W5ymHiJFsYYHCkD0VZsMSmDSMl1XpmYM2R9HtTwgOYgCe3KLwXmJUdMRaiID+w28WKfGVICbfyzMaHNKq36IWCC+Qp7gTLoVYRL+28GH6Pjb7JmDjJ1l6AsDu2CGFzJR5RM58wnDCZ/8it9nlXgzYrihNlNr2dFmUoamj1pv961Y93meJ9B62u0gF2rkXzB3qlJziEzfWuYFHWPJQLSrNZExXlgesBaI1S7dDm4v6AYYZkwNRD40AGaBck3vYLibQi4e7Mpzdhf7YtAgh+loaltc0HVw5zYkuEsS7ggJBtuAiJjOrDswaBanOqF9E6C7ebnO0wdKn5+BjM3k1HOl5245pj1yknlqH5iOnZ4TG5pSsPGSN7oesOHf3AbWGaglqiO/MpdM2Q3zUjZBNwYFBD7Q46XvMWlWxICAFca8Mq7x2nQwpdqS0Pa6nXHaxAQUZTtby1qnH+YLH6sFyySaV6qRYumsLpNS4dRyPdzjkSFitEDDDFtXB6irVwggtgVE55RYBFZW4rWm62iMd91wK4JjOL11vfO9LMUS85aODCdWuK7Mu3g7BkuNqOLKSfJwXMY8k/hxLiokkkR2bGIdiZtTWOCWVgH+1NYMPDXMl+q8siUffUp05hY4Q6alBt8DSSVi3jvlzTAppNKU8dpwppDSokDq2uhenx7tfzdTgP58twPVx+n/z5clv/Xt5ufp7n73efXq4b5ni4PZzeD09++vZzGj4P9/df/zyfL/7p/Hrz19P76fp6OqrcPD/Od38BvToehw==')))
 			   	 	   	   	  		 	  			 	",0913_E,CODEFORCES,3114,Logical Expression,"You are given a boolean function of three variables which is defined by its truth table. You need to find an expression of minimum length that equals to this function. The expression may consist of: 
If more than one expression of minimum length exists, you should find the lexicographically smallest one.
Operations have standard priority. NOT has the highest priority, then AND goes, and OR has the lowest priority. The expression should satisfy the following grammar:
E ::= E '|' T | T
T ::= T '&' F | F
F ::= '!' F | '(' E ')' | 'x' | 'y' | 'z'
The first line contains one integer n — the number of functions in the input (1 ≤ n ≤ 10 000).
The following n lines contain descriptions of functions, the i-th of them contains a string of length 8 that consists of digits 0 and 1 — the truth table of the i-th function. The digit on position j (0 ≤ j < 8) equals to the value of the function in case of ,  and .
You should output n lines, the i-th line should contain the expression of minimum length which equals to the i-th function. If there is more than one such expression, output the lexicographically smallest of them. Expressions should satisfy the given grammar and shouldn't contain white spaces.
","input
The truth table for the second function:
output

","bitmasks, dp, shortestpaths",5
"import sys
from collections import deque
import heapq
input = sys.stdin.readline

N=int(input())
EDGE=[list(map(int,input().split())) for i in range(N-1)]

EDGELIST=[[] for i in range(N+1)]

for i,j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)

#EDGES=[[] for i in range(N+1)]
REDG=[None for i in range(N+1)]
QUE=deque([1])
check=[0]*(N+1)
DEPTH=[None]*(N+1)
i=0
while QUE:
    NQUE=deque()
    i+=1
    
    while QUE:
        x=QUE.pop()
        DEPTH[x]=i
        check[x]=1
        for to in EDGELIST[x]:
            if check[to]==1:
                continue
            else:
                #EDGES[x].append(to)
                REDG[to]=x
                NQUE.append(to)
    QUE=NQUE


check=[0]*(N+1)
check[1]=1
#NEXT=[]

#for i in EDGES[1]:
#    check[i]=1
#    NEXT.append(i)

#for j in NEXT:
#    for k in EDGES[j]:
#        check[k]=1


LEAF=[]
for i in range(2,N+1):
    if len(EDGELIST[i])==1:
        LEAF.append((-DEPTH[i],i))

QUE=LEAF
heapq.heapify(QUE)
ANS=0

#print(check,QUE)

while QUE:
    dep,x=heapq.heappop(QUE)
    if check[x]!=0 or dep>=-3:
        continue

    if check[REDG[x]]==2:
        continue

    if check[x]==0:
        check[x]=1
    if check[REDG[REDG[x]]]==0:
        check[REDG[REDG[x]]]=1
    check[REDG[x]]=2   
    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))
    ANS+=1

    #print(x,QUE,check)

print(ANS)



",1029_E,CODEFORCES,1899,Tree with Small Distances,"You are given an undirected tree consisting of $$$n$$$ vertices. An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Your task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex $$$1$$$ to any other vertex is at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — the number of vertices in the tree.
The following $$$n - 1$$$ lines contain edges: edge $$$i$$$ is given as a pair of vertices $$$u_i, v_i$$$ ($$$1 \le u_i, v_i \le n$$$). It is guaranteed that the given edges form a tree. It is guaranteed that there are no loops and multiple edges in the given edges.
Print a single integer — the minimum number of edges you have to add in order to make the shortest distance from the vertex $$$1$$$ to any other vertex at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The tree corresponding to the first example:  The answer is $$$2$$$, some of the possible answers are the following: $$$[(1, 5), (1, 6)]$$$, $$$[(1, 4), (1, 7)]$$$, $$$[(1, 6), (1, 7)]$$$.
","input
The tree corresponding to the second example:  The answer is $$$0$$$.
output
The tree corresponding to the third example:  The answer is $$$1$$$, only one possible way to reach it is to add the edge $$$(1, 3)$$$.
","dp, graphs, greedy",3
"a,b=map(int,input().split())
print((1<<(a^b).bit_length())-1)",0276_D,CODEFORCES,776,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import sys
n = int(input().strip())
sizes = list(map(int, input().strip().split()))
cost = list(map(int, input().strip().split()))
tot = []
for i in range(n):
    tot.append([sizes[i], cost[i]])
ret = False
lcomp = []
for j in range(len(tot)):
    if j > 0 and j < len(tot)-1:
        temp1 = tot[:j]
        temp2 = tot[j+1:]
        mi_1 = sys.maxsize
        ret1 = False
        for i in range(len(temp1)):
            if temp1[i][0] < tot[j][0]:
                mi_1 = min(mi_1, temp1[i][1])
                ret1 = True
        mi_2 = sys.maxsize
        ret2 = False
        for k in range(len(temp2)):
            if temp2[k][0] > tot[j][0]:
                mi_2 = min(mi_2, temp2[k][1])
                ret2 = True
        if ret1 and ret2:
            ret = True
            lcomp.append(mi_1+tot[j][1]+mi_2)
            #print(mi_1, tot[j][1], mi_2)
if ret:
    print(min(lcomp))
else:
    print(-1)
",0987_C,CODEFORCES,3259,Three displays,"It is the middle of 2018 and Maria Stepanovna, who lives outside Krasnokamensk (a town in Zabaikalsky region), wants to rent three displays to highlight an important problem.
There are $$$n$$$ displays placed along a road, and the $$$i$$$-th of them can display a text with font size $$$s_i$$$ only. Maria Stepanovna wants to rent such three displays with indices $$$i < j < k$$$ that the font size increases if you move along the road in a particular direction. Namely, the condition $$$s_i < s_j < s_k$$$ should be held.
The rent cost is for the $$$i$$$-th display is $$$c_i$$$. Please determine the smallest cost Maria Stepanovna should pay.
The first line contains a single integer $$$n$$$ ($$$3 \le n \le 3\,000$$$) — the number of displays.
The second line contains $$$n$$$ integers $$$s_1, s_2, \ldots, s_n$$$ ($$$1 \le s_i \le 10^9$$$) — the font sizes on the displays in the order they stand along the road.
The third line contains $$$n$$$ integers $$$c_1, c_2, \ldots, c_n$$$ ($$$1 \le c_i \le 10^8$$$) — the rent costs for each display.
If there are no three displays that satisfy the criteria, print -1. Otherwise print a single integer — the minimum total rent cost of three displays with indices $$$i < j < k$$$ such that $$$s_i < s_j < s_k$$$.
","input
In the first example you can, for example, choose displays $$$1$$$, $$$4$$$ and $$$5$$$, because $$$s_1 < s_4 < s_5$$$ ($$$2 < 4 < 10$$$), and the rent cost is $$$40 + 10 + 40 = 90$$$.
output
In the second example you can't select a valid triple of indices, so the answer is -1.
","bruteforce, dp, implementation",5
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    if n % 2 == 1:
        print(""NO"")
        return
    n //= 2
    if n == int(n ** 0.5) ** 2:
        print(""YES"")
        return
    if n % 2 == 1:
        print(""NO"")
        return
    n //= 2
    if n == int(n ** 0.5) ** 2:
        print(""YES"")
        return
    print(""NO"")
        

        
for _ in range(int(input())):
    main()",1515_B,CODEFORCES,763,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",1
"n = int(input())
l = [*map(int, input().split())]

p = [0] * n
for i in range(n): p[l[i] - 1] = i

res = ['?'] * n

for e in range(n, 0, -1):
    i = p[e - 1]
    res[i] = 'B'
    for j in range(i % e, n, e):
        if i != j and l[i] <= l[j] and res[j] == 'B':
            res[i] = 'A'
            break 
print(''.join(res))",1033_C,CODEFORCES,3492,Permutation Game,"After a long day, Alice and Bob decided to play a little game. The game board consists of $$$n$$$ cells in a straight line, numbered from $$$1$$$ to $$$n$$$, where each cell contains a number $$$a_i$$$ between $$$1$$$ and $$$n$$$. Furthermore, no two cells contain the same number. 
A token is placed in one of the cells. They take alternating turns of moving the token around the board, with Alice moving first. The current player can move from cell $$$i$$$ to cell $$$j$$$ only if the following two conditions are satisfied: 
Whoever is unable to make a move, loses. For each possible starting position, determine who wins if they both play optimally. It can be shown that the game is always finite, i.e. there always is a winning strategy for one of the players.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of numbers.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$). Furthermore, there are no pair of indices $$$i \neq j$$$ such that $$$a_i = a_j$$$.
","input
Print $$$s$$$ — a string of $$$n$$$ characters, where the $$$i$$$-th character represents the outcome of the game if the token is initially placed in the cell $$$i$$$. If Alice wins, then $$$s_i$$$ has to be equal to ""A""; otherwise, $$$s_i$$$ has to be equal to ""B"". 
output
In the first sample, if Bob puts the token on the number (not position): 
","bruteforce, dp, games",5
"input()
c = list(map(int, input().split()))
a = list(map(int, input().split()))

u = [0] * len(a)

ans = 0

for i in range(len(a)):
    if u[i] != 0:
        continue
    idx = i
    while u[idx] == 0:
        u[idx] = 1
        idx = a[idx] - 1
    
    if (u[idx] == 2):
        idx = i
        while u[idx] == 1:
            u[idx] = 2
            idx = a[idx] - 1
        continue

    start = idx
    mn = c[idx]
    u[idx] = 2
    while a[idx] - 1 != start:
        idx = a[idx] - 1
        mn = min(mn, c[idx])
        u[idx] = 2

    idx = i
    while u[idx] == 1:
        u[idx] = 2
        idx = a[idx] - 1
    ans += mn
print(ans)",1027_D,CODEFORCES,1887,Mouse Hunt,"Medicine faculty of Berland State University has just finished their admission campaign. As usual, about $$$80\%$$$ of applicants are girls and majority of them are going to live in the university dormitory for the next $$$4$$$ (hopefully) years.
The dormitory consists of $$$n$$$ rooms and a single mouse! Girls decided to set mouse traps in some rooms to get rid of the horrible monster. Setting a trap in room number $$$i$$$ costs $$$c_i$$$ burles. Rooms are numbered from $$$1$$$ to $$$n$$$.
Mouse doesn't sit in place all the time, it constantly runs. If it is in room $$$i$$$ in second $$$t$$$ then it will run to room $$$a_i$$$ in second $$$t + 1$$$ without visiting any other rooms inbetween ($$$i = a_i$$$ means that mouse won't leave room $$$i$$$). It's second $$$0$$$ in the start. If the mouse is in some room with a mouse trap in it, then the mouse get caught into this trap.
That would have been so easy if the girls actually knew where the mouse at. Unfortunately, that's not the case, mouse can be in any room from $$$1$$$ to $$$n$$$ at second $$$0$$$.
What it the minimal total amount of burles girls can spend to set the traps in order to guarantee that the mouse will eventually be caught no matter the room it started from?
The first line contains as single integers $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of rooms in the dormitory.
The second line contains $$$n$$$ integers $$$c_1, c_2, \dots, c_n$$$ ($$$1 \le c_i \le 10^4$$$) — $$$c_i$$$ is the cost of setting the trap in room number $$$i$$$.
The third line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le n$$$) — $$$a_i$$$ is the room the mouse will run to the next second after being in room $$$i$$$.
Print a single integer — the minimal total amount of burles girls can spend to set the traps in order to guarantee that the mouse will eventually be caught no matter the room it started from.
In the first example it is enough to set mouse trap in rooms $$$1$$$ and $$$4$$$. If mouse starts in room $$$1$$$ then it gets caught immideately. If mouse starts in any other room then it eventually comes to room $$$4$$$.
In the second example it is enough to set mouse trap in room $$$2$$$. If mouse starts in room $$$2$$$ then it gets caught immideately. If mouse starts in any other room then it runs to room $$$2$$$ in second $$$1$$$.
","input
Here are the paths of the mouse from different starts from the third example:
output
So it's enough to set traps in rooms $$$2$$$ and $$$6$$$.
","dfsandsimilar, graphs",3
"from itertools import accumulate
n,m,k = map(int,input().split())
a = list(map(int,input().split()))
als = []
for i in range(m):
  ls = a[:]
  for j in range(n):
    if j%m == i:
      ls[j] -= k
  als.append(list(accumulate(ls)))
ans = 0
for i in range(m):
  ls = als[i]
  mn = 0
  anstmp = 0
  for j in range(n):
    if mn > ls[j]:
      mn = ls[j]
    if j%m == i:
      anstmp = max(anstmp,ls[j]-mn)
  ans = max(ans,anstmp)
print(ans)",1197_D,CODEFORCES,3651,Yet Another Subarray Problem,"You are given an array $$$a_1, a_2, \dots , a_n$$$ and two integers $$$m$$$ and $$$k$$$.
You can choose some subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$. 
The cost of subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$ is equal to $$$\sum\limits_{i=l}^{r} a_i - k \lceil \frac{r - l + 1}{m} \rceil$$$, where $$$\lceil x \rceil$$$ is the least integer greater than or equal to $$$x$$$. 
The cost of empty subarray is equal to zero.
For example, if $$$m = 3$$$, $$$k = 10$$$ and $$$a = [2, -4, 15, -3, 4, 8, 3]$$$, then the cost of some subarrays are:
Your task is to find the maximum cost of some subarray (possibly empty) of array $$$a$$$.
The first line contains three integers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \le n \le 3 \cdot 10^5, 1 \le m \le 10, 1 \le k \le 10^9$$$).
","input
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$).
output
Print the maximum cost of some subarray of array $$$a$$$.
","dp, greedy, math",5
"candies = 0
n, k = map(int,input().split())
summ = 0
if k == 0:
    for i in range (n-1,-1,-1):
        summ = summ + 1
        candies = candies + summ
        if candies == i:
            print(i)
            break

if k != 0:
    for i in range (n-1,-1,-1):
        summ = summ + 1
        candies = candies + summ
        if candies - i == k:
            print(i)
            break
  			 		 			 	 						  	  			",1195_B,CODEFORCES,1390,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"n = int(input())
a = iter(map(int, input().split()))
prev_type = 3
prev_res = 2
curr_a = next(a)
res = []
for _ in range(1):
	for next_a in a:
		if next_a > curr_a:
			if prev_type == 1 or prev_res == 1:
				prev_res += 1
				if prev_res == 5:
					break
			else:
				prev_res = 1
			prev_type = 1
		elif next_a < curr_a:
			if prev_type == 2 or prev_res == 5:
				prev_res -= 1
				if prev_res == 1:
					break
			else:
				prev_res = 5
			prev_type = 2
		else:
			if prev_type == 1:
				prev_res += 1
			elif prev_type == 2:
				prev_res -= 1
			elif prev_res != 2:
				prev_res = 2
			else:
				prev_res = 3
			prev_type = 3
		res.append(prev_res)
		curr_a = next_a
	else:
		if prev_type == 1:
			res.append(prev_res + 1)
		elif prev_type == 2:
			res.append(prev_res - 1)
		elif prev_res != 1:
			res.append(1)
		else:
			res.append(2)
		print(*res)
		break
else:
	print('-1')
",1032_C,CODEFORCES,1906,Playing Piano,"Little Paul wants to learn how to play piano. He already has a melody he wants to start with. For simplicity he represented this melody as a sequence $$$a_1, a_2, \ldots, a_n$$$ of key numbers: the more a number is, the closer it is to the right end of the piano keyboard.
Paul is very clever and knows that the essential thing is to properly assign fingers to notes he's going to play. If he chooses an inconvenient fingering, he will then waste a lot of time trying to learn how to play the melody by these fingers and he will probably not succeed.
Let's denote the fingers of hand by numbers from $$$1$$$ to $$$5$$$. We call a fingering any sequence $$$b_1, \ldots, b_n$$$ of fingers numbers. A fingering is convenient if for all $$$1\leq i \leq n - 1$$$ the following holds:
Please provide any convenient fingering or find out that there is none.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) denoting the number of notes.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 2\cdot10^5$$$) denoting the positions of notes on the keyboard.
","input
If there is no convenient fingering, print $$$-1$$$. Otherwise, print $$$n$$$ numbers $$$b_1, b_2, \ldots, b_n$$$, each from $$$1$$$ to $$$5$$$, denoting a convenient fingering, separated by spaces.
output
The third sample test is kinda ""Non stop"" song by Reflex.
","constructivealgorithms, dp",3
"R = lambda: map(int, input().split())
for _ in range(int(input())):
    n,k = R()
    s = input()
    p = (k+2)//2
    l = ""RGB""*p
    res = n
    for i in range(n-k+1):
        c = 0
        #print(l[0:k])
        for j in range(0,k):
            c += (s[i+j] != l[j])
        res = min(res,c)
        #print(c)
        c = 0
        #print(l[1:k+1])
        for j in range(1,k+1):
            c += (s[i+j-1] != l[j])
        res = min(res,c)
        #print(c)
        c = 0
        #print(l[2:k+2])
        for j in range(2,k+2):
            c += (s[i+j-2] != l[j])
        res = min(res,c)
        #print(c)
    print(res)",1196_D1,CODEFORCES,3610,RGB Substring (easy version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2000$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2000$$$ ($$$\sum n \le 2000$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
",implementation,5
"n,k=map(int, input().split())
a = list(map(int, input().split()))

c = a[-1] - a[0]

d = [a[i]-a[i-1] for i in range(1, n)]
d = sorted(d)[::-1]
c -= sum(d[:k-1])
print(c)

",1197_C,CODEFORCES,3027,Array Splitting,"You are given a sorted array $$$a_1, a_2, \dots, a_n$$$ (for each index $$$i > 1$$$ condition $$$a_i \ge a_{i-1}$$$ holds) and an integer $$$k$$$.
You are asked to divide this array into $$$k$$$ non-empty consecutive subarrays. Every element in the array should be included in exactly one subarray. 
Let $$$max(i)$$$ be equal to the maximum in the $$$i$$$-th subarray, and $$$min(i)$$$ be equal to the minimum in the $$$i$$$-th subarray. The cost of division is equal to $$$\sum\limits_{i=1}^{k} (max(i) - min(i))$$$. For example, if $$$a = [2, 4, 5, 5, 8, 11, 19]$$$ and we divide it into $$$3$$$ subarrays in the following way: $$$[2, 4], [5, 5], [8, 11, 19]$$$, then the cost of division is equal to $$$(4 - 2) + (5 - 5) + (19 - 8) = 13$$$.
Calculate the minimum cost you can obtain by dividing the array $$$a$$$ into $$$k$$$ non-empty consecutive subarrays. 
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 3 \cdot 10^5$$$).
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$ 1 \le a_i \le 10^9$$$, $$$a_i \ge a_{i-1}$$$). 
","input
Print the minimum cost you can obtain by dividing the array $$$a$$$ into $$$k$$$ nonempty consecutive subarrays. 
output
In the first test we can divide array $$$a$$$ in the following way: $$$[4, 8, 15, 16], [23], [42]$$$. 
","greedy, sortings",4
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
A=[list(map(int,input().split())) for i in range(n)]

SET=set()
for a in A:
    SET|=set(a)

compression_dict={a: ind for ind, a in enumerate(sorted(SET))}

for i in range(n):
    A[i]=[compression_dict[a] for a in A[i]]

OK=0
NG=len(compression_dict)
ANS=[1,1]
B=[set()]*n
P=[2,3,5,7,11,13,17,19]
Q=1
for j in range(m):
    Q*=P[j]
    
import math

def ya(x):
    xr=math.ceil(math.sqrt(x))

    LIST=[]
    for i in range(1,xr+1):
        if x%i==0:
            LIST.append(i)
            LIST.append(x//i)

    return LIST

while NG>OK+1:
    mid=(OK+NG)//2
    SET=set()

    for i in range(n):
        NOW=1
        for j in range(m):
            if A[i][j]>=mid:
                NOW*=P[j]
        B[i]=NOW
        SET.add(NOW)

    #print(mid,SET)
    flag=0

    for s in SET:
        for l in ya(s):
            if Q//l in SET:
                flag=1
                OK=mid
                break
        if flag:
            break

    else:
        NG=mid

SET=set()
for i in range(n):
    NOW=1
    for j in range(m):
        if A[i][j]>=OK:
            NOW*=P[j]
    B[i]=NOW
    SET.add(NOW)

flag=0
for i in range(n):
    for l in ya(B[i]):
        if Q//l in SET:
            ANS1=i
            flag=1
            break
    if flag:
        break

LIST=ya(B[i])
SET=set(LIST)

for i in range(n):
    if Q//B[i] in SET:
        ANS2=i

print(ANS1+1,ANS2+1)
",1288_D,CODEFORCES,4656,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"mod = 1000000000 + 7

n, m = map(int, input().split())

if n == 0:
    print(0)
    exit()

ans = n * 2
ans %= mod

if m:
    t = 1
    x = 2
    while m > 0:
        if m & 1:
            t = t * x % mod
        x = x * x % mod
        m >>= 1
    ans -= 1
    ans = (t * ans + 1) % mod

print(ans)",0992_C,CODEFORCES,1057,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"n=int(input())
s=list(input())
t=list(input())

cnt=0
ans=[]
f1=0
for i in range(n):
    if s[i]==t[i]:
        continue
    f=0
    for j in range(i+1,n):
        if s[j]==t[i]:
            f=1
            for k in range(j,i,-1):
                s[k-1],s[k]=s[k],s[k-1]
                ans.append(k)
            break
    if f==0:
        print(-1)
        exit()

print(len(ans))
print(*ans)",1015_B,CODEFORCES,3386,Obtaining the String,"You are given two strings $$$s$$$ and $$$t$$$. Both strings have length $$$n$$$ and consist of lowercase Latin letters. The characters in the strings are numbered from $$$1$$$ to $$$n$$$.
You can successively perform the following move any number of times (possibly, zero):
You can't apply a move to the string $$$t$$$. The moves are applied to the string $$$s$$$ one after another.
Your task is to obtain the string $$$t$$$ from the string $$$s$$$. Find any way to do it with at most $$$10^4$$$ such moves.
You do not have to minimize the number of moves, just find any sequence of moves of length $$$10^4$$$ or less to transform $$$s$$$ into $$$t$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 50$$$) — the length of strings $$$s$$$ and $$$t$$$.
The second line of the input contains the string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters.
The third line of the input contains the string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters.
If it is impossible to obtain the string $$$t$$$ using moves, print ""-1"".
Otherwise in the first line print one integer $$$k$$$ — the number of moves to transform $$$s$$$ to $$$t$$$. Note that $$$k$$$ must be an integer number between $$$0$$$ and $$$10^4$$$ inclusive.
In the second line print $$$k$$$ integers $$$c_j$$$ ($$$1 \le c_j < n$$$), where $$$c_j$$$ means that on the $$$j$$$-th move you swap characters $$$s_{c_j}$$$ and $$$s_{c_j + 1}$$$.
If you do not need to apply any moves, print a single integer $$$0$$$ in the first line and either leave the second line empty or do not print it at all.
","input
In the first example the string $$$s$$$ changes as follows: ""abcdef"" $$$\rightarrow$$$ ""abdcef"" $$$\rightarrow$$$ ""abdcfe"" $$$\rightarrow$$$ ""abdfce"" $$$\rightarrow$$$ ""abdfec"".
output
In the second example there is no way to transform the string $$$s$$$ into the string $$$t$$$ through any allowed moves.
",implementation,5
"n,s = [int(x) for x in input().split()]
def check(x):
    y = list(str(x))
    ans = x
    for i in y:
        ans-=int(i)
    if (ans>=s):
        return True
    return False
    
ans = 0
l = 1
r = n
while(l<=r):
    m = (l+r)//2
    if (check(m)):
        ans = n-m+1
        r = m-1
    else:
        l = m+1
print(ans)",0817_C,CODEFORCES,949,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap,0,len(heap)-1)
from math import gcd as Gcd
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,readline().split())
S=[readline().rstrip() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",0908_E,CODEFORCES,3061,New Year and Entity Enumeration,"You are given an integer m.
Let M = 2m - 1.
You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m.
A set of integers S is called ""good"" if the following hold. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.
Count the number of good sets S, modulo 109 + 7.
The first line will contain two integers m and n (1 ≤ m ≤ 1 000, 1 ≤ n ≤ min(2m, 50)).
The next n lines will contain the elements of T. Each line will contain exactly m zeros and ones. Elements of T will be distinct.
","input
Print a single integer, the number of good sets modulo 109 + 7. 
output
An example of a valid set S is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.
","bitmasks, combinatorics, dp, math",5
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial

n, k = map(int, stdin.readline().split())
stdout.write(str((n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k))",1080_A,CODEFORCES,573,Petya and Origami,"Petya is having a party soon, and he has decided to invite his $$$n$$$ friends.
He wants to make invitations in the form of origami. For each invitation, he needs two red sheets, five green sheets, and eight blue sheets. The store sells an infinite number of notebooks of each color, but each notebook consists of only one color with $$$k$$$ sheets. That is, each notebook contains $$$k$$$ sheets of either red, green, or blue.
Find the minimum number of notebooks that Petya needs to buy to invite all $$$n$$$ of his friends.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1\leq n, k\leq 10^8$$$) — the number of Petya's friends and the number of sheets in each notebook respectively.
Print one number — the minimum number of notebooks that Petya needs to buy.
","input
In the first example, we need $$$2$$$ red notebooks, $$$3$$$ green notebooks, and $$$5$$$ blue notebooks.
output
In the second example, we need $$$5$$$ red notebooks, $$$13$$$ green notebooks, and $$$20$$$ blue notebooks.
",math,1
"import sys
if locals()['__file__'][-2:] == 'py':
    sys.stdin = open('in.txt', 'r')
n = int(input())
a = []
for i in range(1, n + 1):
    l, r = map(int, input().split())
    a.append([l, -r, i])
a.sort()
ma = a[0][1]
nma = a[0][2]
for i in range(1, n):
    if a[i][1] >= ma:
        print(a[i][2], nma)
        exit()
    else:
        ma = a[i][1]
        nma = a[i][2]
print(-1, -1)
",0976_C,CODEFORCES,2518,Nested Segments,"You are given a sequence a1, a2, ..., an of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment ai lies within segment aj.
Segment [l1, r1] lies within segment [l2, r2] iff l1 ≥ l2 and r1 ≤ r2.
Print indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
The first line contains one integer n (1 ≤ n ≤ 3·105) — the number of segments.
Each of the next n lines contains two integers li and ri (1 ≤ li ≤ ri ≤ 109) — the i-th segment.
","input
Print two distinct indices i and j such that segment ai lies within segment aj. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
output
In the first example the following pairs are considered correct:
","greedy, implementation, sortings",4
"def go():
    n = int(input())
    for i in range(n):
        a, b, d = [int(i) for i in input().split(' ')]
        if a > d or b > d:
            print(-1)
        elif a % 2 == b % 2:
            if a % 2 == d % 2:
                print(d)
            else:
                print(d - 2)
        else:
            if a % 2 == b % 2:
                if d % 2 == a % 2:
                    print(d)
                else:
                    print(d - 2)
            else:
                print(d - 1)
go()
",1036_B,CODEFORCES,492,Diagonal Walking v,"Mikhail walks on a Cartesian plane. He starts at the point $$$(0, 0)$$$, and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $$$(0, 0)$$$, he can go to any of the following points in one move: 
If Mikhail goes from the point $$$(x1, y1)$$$ to the point $$$(x2, y2)$$$ in one move, and $$$x1 \ne x2$$$ and $$$y1 \ne y2$$$, then such a move is called a diagonal move.
Mikhail has $$$q$$$ queries. For the $$$i$$$-th query Mikhail's target is to go to the point $$$(n_i, m_i)$$$ from the point $$$(0, 0)$$$ in exactly $$$k_i$$$ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in $$$k_i$$$ moves.
Note that Mikhail can visit any point any number of times (even the destination point!).
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 10^4$$$) — the number of queries.
Then $$$q$$$ lines follow. The $$$i$$$-th of these $$$q$$$ lines contains three integers $$$n_i$$$, $$$m_i$$$ and $$$k_i$$$ ($$$1 \le n_i, m_i, k_i \le 10^{18}$$$) — $$$x$$$-coordinate of the destination point of the query, $$$y$$$-coordinate of the destination point of the query and the number of moves in the query, correspondingly.
Print $$$q$$$ integers. The $$$i$$$-th integer should be equal to -1 if Mikhail cannot go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in exactly $$$k_i$$$ moves described above. Otherwise the $$$i$$$-th integer should be equal to the the maximum number of diagonal moves among all possible movements.
One of the possible answers to the first test case: $$$(0, 0) \to (1, 0) \to (1, 1) \to (2, 2)$$$.
","input
One of the possible answers to the second test case: $$$(0, 0) \to (0, 1) \to (1, 2) \to (0, 3) \to (1, 4) \to (2, 3) \to (3, 2) \to (4, 3)$$$.
output
In the third test case Mikhail cannot reach the point $$$(10, 1)$$$ in 9 moves.
",math,1
"a,b = map(int,input().split())
ans = 0
if(a > b):
    ans += int(a//b)
    a = a%b
while(b!=0):
    ans += int(a//b)
    a,b = b,a%b
print(ans)",0343_A,CODEFORCES,128,Rational Resistance,"Mad scientist Mike is building a time machine in his spare time. To finish the work, he needs a resistor with a certain resistance value.
However, all Mike has is lots of identical resistors with unit resistance R0 = 1. Elements with other resistance can be constructed from these resistors. In this problem, we will consider the following as elements: 
With the consecutive connection the resistance of the new element equals R = Re + R0. With the parallel connection the resistance of the new element equals . In this case Re equals the resistance of the element being connected.
Mike needs to assemble an element with a resistance equal to the fraction . Determine the smallest possible number of resistors he needs to make such an element.
The single input line contains two space-separated integers a and b (1 ≤ a, b ≤ 1018). It is guaranteed that the fraction  is irreducible. It is guaranteed that a solution always exists.
Print a single number — the answer to the problem.
Please do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.
","input
In the first sample, one resistor is enough.
output
In the second sample one can connect the resistors in parallel, take the resulting element and connect it to a third resistor consecutively. Then, we get an element with resistance . We cannot make this element using two resistors.
","math, numbertheory",1
"n=input()
ans=0
r,c=0,0
for i in n:
    r+=int(i)
    c+=1
    if int(i)%3==0 or r%3==0 or c==3:
        ans+=1
        r,c=0,0
print(ans)",1005_D,CODEFORCES,1770,Polycarp and Div 3,"Polycarp likes numbers that are divisible by 3.
He has a huge number $$$s$$$. Polycarp wants to cut from it the maximum number of numbers that are divisible by $$$3$$$. To do this, he makes an arbitrary number of vertical cuts between pairs of adjacent digits. As a result, after $$$m$$$ such cuts, there will be $$$m+1$$$ parts in total. Polycarp analyzes each of the obtained numbers and finds the number of those that are divisible by $$$3$$$.
For example, if the original number is $$$s=3121$$$, then Polycarp can cut it into three parts with two cuts: $$$3|1|21$$$. As a result, he will get two numbers that are divisible by $$$3$$$.
Polycarp can make an arbitrary number of vertical cuts, where each cut is made between a pair of adjacent digits. The resulting numbers cannot contain extra leading zeroes (that is, the number can begin with 0 if and only if this number is exactly one character '0'). For example, 007, 01 and 00099 are not valid numbers, but 90, 0 and 10001 are valid.
What is the maximum number of numbers divisible by $$$3$$$ that Polycarp can obtain?
The first line of the input contains a positive integer $$$s$$$. The number of digits of the number $$$s$$$ is between $$$1$$$ and $$$2\cdot10^5$$$, inclusive. The first (leftmost) digit is not equal to 0.
Print the maximum number of numbers divisible by $$$3$$$ that Polycarp can get by making vertical cuts in the given number $$$s$$$.
In the first example, an example set of optimal cuts on the number is 3|1|21.
In the second example, you do not need to make any cuts. The specified number 6 forms one number that is divisible by $$$3$$$.
","input
In the third example, cuts must be made between each pair of digits. As a result, Polycarp gets one digit 1 and $$$33$$$ digits 0. Each of the $$$33$$$ digits 0 forms a number that is divisible by $$$3$$$.
output
In the fourth example, an example set of optimal cuts is 2|0|1|9|201|81. The numbers $$$0$$$, $$$9$$$, $$$201$$$ and $$$81$$$ are divisible by $$$3$$$.
","dp, greedy, numbertheory",3
"from math import factorial as fc
def per(a,b):
    return fc(a+b)/(fc(a)*fc(b))
import sys
s=input()
s1=input()
x=s.count(""+"")
y=s.count(""-"")
x1=s1.count(""+"")
y1=s1.count(""-"")
p=x-y
p1=x1-y1
q=s1.count(""?"")
dif=p-p1
if q<abs(p1-p) or dif>q:
    print(0.0)
    sys.exit()
m=abs(y-y1)
pl=abs(x-x1)
print(per(m,pl)/(2**(m+pl)))
    
",0476_B,CODEFORCES,4309,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"k = int(input())
prev=0
nextt=0
NumofDigits=0
#i = 0
#while(summ<(2^12)):
while(True):
    prev = nextt
    nextt = nextt+(9*(10**(NumofDigits-1))*NumofDigits)
    if(k>= prev and k<=nextt):
        break
    NumofDigits=NumofDigits+1
if(NumofDigits==1):
    print(k)
else:
    result = (10**(NumofDigits-1))+int((k-(prev+1))/NumofDigits)
    i=0
    while(True):
        if (k-int(prev+1))%NumofDigits == i:
            break
        i=i+1
    result = str(result)
    print(result[i])",1177_B,CODEFORCES,1252,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"# _
#####################################################################################################################

def main():
    pieces_Dimension = int(input())
    piece1 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece2 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece3 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece4 = ''.join(input() for _ in range(pieces_Dimension))

    brokenPieces = (piece1, piece2, piece3, piece4)
    nSquares = pieces_Dimension*pieces_Dimension
    squares = '01'*(nSquares//2) + '0'

    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)


def nSquaresToRecolorIn(brokenPieces, nSquares, squares):
    possible_nSquares = [sum(piece[i] != squares[i] for i in range(nSquares)) for piece in brokenPieces]
    possible_nSquares.sort()

    return 2*nSquares + possible_nSquares[0] + possible_nSquares[1] - possible_nSquares[2] - possible_nSquares[3]


if __name__ == '__main__':
    print(main())
    # main()
",0961_C,CODEFORCES,3181,Chessboard,"Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into 4 pieces, each of size n by n, n is always odd. And what's even worse, some squares were of wrong color. j-th square of the i-th row of k-th piece of the board has color ak, i, j; 1 being black and 0 being white. 
Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be 2n by 2n. You are allowed to move pieces but not allowed to rotate or flip them.
The first line contains odd integer n (1 ≤ n ≤ 100) — the size of all pieces of the board. 
","input
Then 4 segments follow, each describes one piece of the board. Each consists of n lines of n characters; j-th one of i-th line is equal to 1 if the square is black initially and 0 otherwise. Segments are separated by an empty line.
output
Print one number — minimum number of squares Magnus should recolor to be able to obtain a valid chessboard.
","bitmasks, bruteforce, implementation",5
"n = int(input())
x, y = map(int, input().split())

if abs(x - 1) + abs(y - 1) <= abs(x - n) + abs(y - n):
    print('White')
else:
    print('Black')
",1075_A,CODEFORCES,562,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"n=int(input())-1
print(2*n*(n+1)+1)
",1180_A,CODEFORCES,719,Alex and a Rhombus,"While playing with geometric figures Alex has accidentally invented a concept of a $$$n$$$-th order rhombus in a cell grid.
A $$$1$$$-st order rhombus is just a square $$$1 \times 1$$$ (i.e just a cell).
A $$$n$$$-th order rhombus for all $$$n \geq 2$$$ one obtains from a $$$n-1$$$-th order rhombus adding all cells which have a common side with it to it (look at the picture to understand it better).
Alex asks you to compute the number of cells in a $$$n$$$-th order rhombus.
The first and only input line contains integer $$$n$$$ ($$$1 \leq n \leq 100$$$) — order of a rhombus whose numbers of cells should be computed.
","input
Print exactly one integer — the number of cells in a $$$n$$$-th order rhombus.
output
Images of rhombus corresponding to the examples are given in the statement.
","dp, implementation, math",1
"def pow_mod(x, pwr, mod):
	res = 1
	multiplier = x
	while pwr > 0:
		if pwr%2 == 1: 
			res = res*multiplier % mod
		multiplier = multiplier*multiplier % mod

		pwr //= 2

	return res

[x, k] = map(int, input().split())

MOD = 1000000007

if x == 0:
	res = 0
else:
	res = pow_mod(2, k+1, MOD)*x % MOD
	res = (res - pow_mod(2, k, MOD)) % MOD
	res = (res + 1) % MOD

print(res)",0992_C,CODEFORCES,1105,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"MOD = 10**9 + 7
x, k = map(int, input().split())
y = (2*x - 1) % MOD
mult = pow(2, k, MOD)
if x:
    print((y * mult + 1) % MOD)
else:
    print(0)",0992_C,CODEFORCES,1080,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"n = int(input())
m = input().split(' ')
j = 0
mark = [1]
for i in range(1,len(m)) :
    tmp = max(mark[i-1],int(m[i])+1)
    mark.append(tmp)

j+=mark[len(m)-1]-int(m[len(m)-1])-1
for i in range(len(m)-2,-1,-1):
    if mark[i]<mark[i+1]-1:
        mark[i] = mark[i+1]-1
    j+=mark[i]-int(m[i])-1
print(j)
",0924_C,CODEFORCES,1562,Riverside Curio,"Arkady decides to observe a river for n consecutive days. The river's water level on each day is equal to some real value.
Arkady goes to the riverside each day and makes a mark on the side of the channel at the height of the water level, but if it coincides with a mark made before, no new mark is created. The water does not wash the marks away. Arkady writes down the number of marks strictly above the water level each day, on the i-th day this value is equal to mi.
Define di as the number of marks strictly under the water level on the i-th day. You are to find out the minimum possible sum of di over all days. There are no marks on the channel before the first day.
The first line contains a single positive integer n (1 ≤ n ≤ 105) — the number of days.
The second line contains n space-separated integers m1, m2, ..., mn (0 ≤ mi < i) — the number of marks strictly above the water on each day.
Output one single integer — the minimum possible sum of the number of marks strictly below the water level among all days.
In the first example, the following figure shows an optimal case.
","input
Note that on day 3, a new mark should be created because if not, there cannot be 3 marks above water on day 4. The total number of marks underwater is 0 + 0 + 2 + 0 + 3 + 1 = 6.
output
In the second example, the following figure shows an optimal case.
","datastructures, dp, greedy",3
"money=input()
initi=money
# if money>0:pass
    
if int(money)<0:
    lst_dig=money[-1]
    lsec_dig=money[-2]
    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-2]
    else:money=money[:-2]+money[-1]
    print(int(money))
else:
    lst_dig=money[-1]
    lsec_dig=money[-2]
    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-1]
    else:money=money[:-2]+money[-2]
    if int(initi)>=int(money):
        print(initi)
    else:
        print(money)
    ",0313_A,CODEFORCES,121,Ilya and Bank Account,"Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.
Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.
Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.
The single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.
In a single line print an integer — the maximum state of the bank account that Ilya can get. 
","input
In the first test sample Ilya doesn't profit from using the present.
output
In the second test sample you can delete digit 1 and get the state of the account equal to 0.
","implementation, numbertheory",1
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp = [[[0 for ___ in range(B+1)] for __ in range(G+1)] for _ in range(R+1)]
mx = 0

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i < R and j < G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i] * g[j])
            if i < R and k < B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i] * b[k])
            if j < G and k < B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j] * b[k])
            mx = max(mx, dp[i][j][k])

print(mx)",1398_D,CODEFORCES,3891,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"n = int(input())
x,y = map(int,input().split())
if max(x-1,y-1) > max(n-x,n-y):
    print(""Black"")
else:
    print(""White"")
",1075_A,CODEFORCES,555,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"n=int(input())
a=input().split(' ')
for i in range(len(a)):
    a[i]=int(a[i])
khat=n*[0]
ted=0
assl=0
khat[0]=1
lol=[0,0]
for i in range(1,len(khat)):
    khat[i]=max([khat[i-1],a[i]+1])
for i in range(len(khat)-2,-1,-1):
    if khat[i]<khat[i+1]-1:
        khat[i]=khat[i+1]-1
    ted=ted+(khat[i]-(a[i]+1))
ted=ted+(khat[n-1]-(a[n-1]+1))
print(ted)
",0924_C,CODEFORCES,1563,Riverside Curio,"Arkady decides to observe a river for n consecutive days. The river's water level on each day is equal to some real value.
Arkady goes to the riverside each day and makes a mark on the side of the channel at the height of the water level, but if it coincides with a mark made before, no new mark is created. The water does not wash the marks away. Arkady writes down the number of marks strictly above the water level each day, on the i-th day this value is equal to mi.
Define di as the number of marks strictly under the water level on the i-th day. You are to find out the minimum possible sum of di over all days. There are no marks on the channel before the first day.
The first line contains a single positive integer n (1 ≤ n ≤ 105) — the number of days.
The second line contains n space-separated integers m1, m2, ..., mn (0 ≤ mi < i) — the number of marks strictly above the water on each day.
Output one single integer — the minimum possible sum of the number of marks strictly below the water level among all days.
In the first example, the following figure shows an optimal case.
","input
Note that on day 3, a new mark should be created because if not, there cannot be 3 marks above water on day 4. The total number of marks underwater is 0 + 0 + 2 + 0 + 3 + 1 = 6.
output
In the second example, the following figure shows an optimal case.
","datastructures, dp, greedy",3
"a = int(input())
print((a // 2) * 3)",0084_A,CODEFORCES,21,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr()):
    n=nmbr()
    a=lst()
    b=lst()
    dp=[0]*n
    for i in range(n):
        v=float('inf')
        for j in range(i+1,n):
            if a[j]>a[i]:v=min(v,b[i]+b[j])
        dp[i]=v
    # print(dp)
    for i in range(n):
        v = float('inf')
        for j in range(i + 1, n):
            if a[j] > a[i]: v = min(v, b[i] + dp[j])
        dp[i] = v
    ans=min(dp)
    print(ans if ans!=float('inf') else -1)",0987_C,CODEFORCES,3256,Three displays,"It is the middle of 2018 and Maria Stepanovna, who lives outside Krasnokamensk (a town in Zabaikalsky region), wants to rent three displays to highlight an important problem.
There are $$$n$$$ displays placed along a road, and the $$$i$$$-th of them can display a text with font size $$$s_i$$$ only. Maria Stepanovna wants to rent such three displays with indices $$$i < j < k$$$ that the font size increases if you move along the road in a particular direction. Namely, the condition $$$s_i < s_j < s_k$$$ should be held.
The rent cost is for the $$$i$$$-th display is $$$c_i$$$. Please determine the smallest cost Maria Stepanovna should pay.
The first line contains a single integer $$$n$$$ ($$$3 \le n \le 3\,000$$$) — the number of displays.
The second line contains $$$n$$$ integers $$$s_1, s_2, \ldots, s_n$$$ ($$$1 \le s_i \le 10^9$$$) — the font sizes on the displays in the order they stand along the road.
The third line contains $$$n$$$ integers $$$c_1, c_2, \ldots, c_n$$$ ($$$1 \le c_i \le 10^8$$$) — the rent costs for each display.
If there are no three displays that satisfy the criteria, print -1. Otherwise print a single integer — the minimum total rent cost of three displays with indices $$$i < j < k$$$ such that $$$s_i < s_j < s_k$$$.
","input
In the first example you can, for example, choose displays $$$1$$$, $$$4$$$ and $$$5$$$, because $$$s_1 < s_4 < s_5$$$ ($$$2 < 4 < 10$$$), and the rent cost is $$$40 + 10 + 40 = 90$$$.
output
In the second example you can't select a valid triple of indices, so the answer is -1.
","bruteforce, dp, implementation",5
"n, k = map(int, input().split())
grid = [['.']*n for i in range(4)]
if k % 2 == 0:
    for i in range(k//2):
        grid[1][1+i], grid[2][1+i] = '#', '#'
else:
    m = n//2
    if k > n - 2:
        for i in range(1, n-1):
            grid[1][i] = '#'
        for i in range(1, (k-n+2)//2 + 1):
            grid[2][m+i], grid[2][m-i] = '#', '#'
    else:
        grid[1][m] = '#'
        if k > 1:
            for i in range(1, k//2 + 1):
                grid[1][m-i], grid[1][m+i] = '#', '#'
print('YES')
for i in grid:
    print(''.join(i))",0980_B,CODEFORCES,1666,Marlin,"The city of Fishtopia can be imagined as a grid of $$$4$$$ rows and an odd number of columns. It has two main villages; the first is located at the top-left cell $$$(1,1)$$$, people who stay there love fishing at the Tuna pond at the bottom-right cell $$$(4, n)$$$. The second village is located at $$$(4, 1)$$$ and its people love the Salmon pond at $$$(1, n)$$$.
The mayor of Fishtopia wants to place $$$k$$$ hotels in the city, each one occupying one cell. To allow people to enter the city from anywhere, hotels should not be placed on the border cells.
A person can move from one cell to another if those cells are not occupied by hotels and share a side.
Can you help the mayor place the hotels in a way such that there are equal number of shortest paths from each village to its preferred pond?
The first line of input contain two integers, $$$n$$$ and $$$k$$$ ($$$3 \leq n \leq 99$$$, $$$0 \leq k \leq 2\times(n-2)$$$), $$$n$$$ is odd, the width of the city, and the number of hotels to be placed, respectively.
","input
Print ""YES"", if it is possible to place all the hotels in a way that satisfies the problem statement, otherwise print ""NO"".
output
If it is possible, print an extra $$$4$$$ lines that describe the city, each line should have $$$n$$$ characters, each of which is ""#"" if that cell has a hotel on it, or ""."" if not.
",constructivealgorithms,3
"#""xxx""が連続部分文字列としていくつ含まれるか
#文字ごとでグループに分ければキーがxのグループのみに注目することができる
#xがキーのグループの長さをlとするならmax(0,l-3+1)がそのグループに含まれる""xxx""の個数
from itertools import groupby
n=int(input())
s=input()
x=[len(list(group)) for key,group in groupby(s) if key==""x""]
ans=sum(max(0,l-3+1) for l in x)
print(ans)",0978_B,CODEFORCES,1647,File Name,"You can not just take the file and send it. When Polycarp trying to send a file in the social network ""Codehorses"", he encountered an unexpected problem. If the name of the file contains three or more ""x"" (lowercase Latin letters ""x"") in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed.
Determine the minimum number of characters to remove from the file name so after that the name does not contain ""xxx"" as a substring. Print 0 if the file name does not initially contain a forbidden substring ""xxx"".
You can delete characters in arbitrary positions (not necessarily consecutive). If you delete a character, then the length of a string is reduced by $$$1$$$. For example, if you delete the character in the position $$$2$$$ from the string ""exxxii"", then the resulting string is ""exxii"".
The first line contains integer $$$n$$$ $$$(3 \le n \le 100)$$$ — the length of the file name.
The second line contains a string of length $$$n$$$ consisting of lowercase Latin letters only — the file name.
","input
Print the minimum number of characters to remove from the file name so after that the name does not contain ""xxx"" as a substring. If initially the file name dost not contain a forbidden substring ""xxx"", print 0.
output
In the first example Polycarp tried to send a file with name contains number $$$33$$$, written in Roman numerals. But he can not just send the file, because it name contains three letters ""x"" in a row. To send the file he needs to remove any one of this letters.
","greedy, strings",3
"import sys

n, k = map(int, next(sys.stdin).rstrip().split())

xs = list(map(int, next(sys.stdin).rstrip().split()))

mapka = {}
lengths = {}

result = []

for x in xs:
    
    if x in mapka:
        result.append(mapka[x])
    else:
        left = max(0, x - k + 1)
        range_potential = x - left
        for i in range(range_potential, -1, -1):
            potential_left = x - i
            if potential_left not in mapka:
                result.append(potential_left)
                for y in range(potential_left, x + 1):
                    mapka[y] = potential_left

                lengths[potential_left] = x - potential_left + 1

                break
            else:

                if lengths[mapka[potential_left]] + (x - potential_left) <= k:
                    result.append(mapka[potential_left])
                    for y in range(mapka[potential_left] + lengths[mapka[potential_left]], x + 1):
                        mapka[y] = mapka[potential_left]
                        lengths[mapka[potential_left]] += 1

                    break
            
print(' '.join(map(str, result)))
",0980_C,CODEFORCES,3207,Posterized,"Professor Ibrahim has prepared the final homework for his algorithm’s class. He asked his students to implement the Posterization Image Filter.
Their algorithm will be tested on an array of integers, where the $$$i$$$-th integer represents the color of the $$$i$$$-th pixel in the image. The image is in black and white, therefore the color of each pixel will be an integer between 0 and 255 (inclusive).
To implement the filter, students are required to divide the black and white color range [0, 255] into groups of consecutive colors, and select one color in each group to be the group’s key. In order to preserve image details, the size of a group must not be greater than $$$k$$$, and each color should belong to exactly one group.
Finally, the students will replace the color of each pixel in the array with that color’s assigned group key.
To better understand the effect, here is an image of a basking turtle where the Posterization Filter was applied with increasing $$$k$$$ to the right. 
To make the process of checking the final answer easier, Professor Ibrahim wants students to divide the groups and assign the keys in a way that produces the lexicographically smallest possible array.
The first line of input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 10^5$$$, $$$1 \leq k \leq 256$$$), the number of pixels in the image, and the maximum size of a group, respectively.
The second line contains $$$n$$$ integers $$$p_1, p_2, \dots, p_n$$$ ($$$0 \leq p_i \leq 255$$$), where $$$p_i$$$ is the color of the $$$i$$$-th pixel.
Print $$$n$$$ space-separated integers; the lexicographically smallest possible array that represents the image after applying the Posterization filter.
One possible way to group colors and assign keys for the first sample:
Color $$$2$$$ belongs to the group $$$[0,2]$$$, with group key $$$0$$$.
Color $$$14$$$ belongs to the group $$$[12,14]$$$, with group key $$$12$$$.
","input
Colors $$$3$$$ and $$$4$$$ belong to group $$$[3, 5]$$$, with group key $$$3$$$.
output
Other groups won't affect the result so they are not listed here.
","games, greedy",5
"from sys import stdin
 
def read_lines(sep=' ', input_type=None):
    #list of rows
    _lines = stdin.readlines()
    cast = input_type is not None
    lines = []
    for line in _lines:
        line = line[:-1].split(sep)
        if cast:
            line = [input_type(x) for x in line]
        lines.append(line)
    return lines

import math
        
if __name__ == '__main__':
 
    lines = read_lines(input_type=int)
    
    #t = lines[0]
    #lines = lines[1:]
    
    n,m = lines[0][0], lines[1][0]
    
    if n <= math.log2(m):
        print(m % (2**n))
    else:
        print(m)
        ",0913_A,CODEFORCES,241,Modular Exponentiation,"The following problem is well-known: given integers n and m, calculate
where 2n = 2·2·...·2 (n factors), and  denotes the remainder of division of x by y.
You are asked to solve the ""reverse"" problem. Given integers n and m, calculate
The first line contains a single integer n (1 ≤ n ≤ 108).
The second line contains a single integer m (1 ≤ m ≤ 108).
Output a single integer — the value of .
","input
In the first example, the remainder of division of 42 by 24 = 16 is equal to 10.
output
In the second example, 58 is divisible by 21 = 2 without remainder, and the answer is 0.
","implementation, math",1
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
k1, k2, k3  = sorted(map(int, input().split()))
'''
we have 1       - obvious
2 twos          - they can cover everything
3 threes        - they can cover everything
2 3 3           - also possible. need to cover all odd numbers with 2 threes:
                2*x+1 + 3*k
                2*x+3 + 3*k
at least 1 > 3  - 
x3 + k3*i, where k3 > 3
we can choose x3, so it's >= max(x1, x2, x3)
=> need to cover:
x3+1, x3+2, x3+3, ...
we can cover x3+1 and x3+3 using 2.
?

lcm(k1, k2, k3)
xmax = max(x1, x2, x3)
xmin = min(x1, x2, x3)
one of xi can be taken as zero (just substract xmin from all)
also, it doesn't make sense to take any of xi > 0 greater than lcm
therefore, we can check interval [lcm, 2*lcm] to be covered

1 2 3 4 5 6 7 8 9 10
  x   x   x   x   x
3 3 3
x x x x x x x x x x
2 3 3 - doesn't seems to work
x x   x   x x x   x
x   x x   x x   x x

(k1 == 2 and k3 % k2 == 0) - passed 5th test
k1 == 2, k2 >= 3
2 4 4
1 2 3 4 5 6 7 8 9 10
x x x x x x x x x x
'''
# def gcd(a, b):
#     if b == 0:
#         return a
#     return gcd(b, a % b)

# gcdk = gcd(gcd(k1, k2), k3)
#lcmk = k1*k2*k3 // gcdk

if 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \
    or (k1 == 2 and k2 == 4 and k3 == 4):
    print(""YES"")
else:
    print(""NO"")",0911_C,CODEFORCES,189,Three Garlands,"Mishka is decorating the Christmas tree. He has got three garlands, and all of them will be put on the tree. After that Mishka will switch these garlands on.
When a garland is switched on, it periodically changes its state — sometimes it is lit, sometimes not. Formally, if i-th garland is switched on during x-th second, then it is lit only during seconds x, x + ki, x + 2ki, x + 3ki and so on.
Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland. Formally, Mishka wants to choose three integers x1, x2 and x3 (not necessarily distinct) so that he will switch on the first garland during x1-th second, the second one — during x2-th second, and the third one — during x3-th second, respectively, and during each second starting from max(x1, x2, x3) at least one garland will be lit.
Help Mishka by telling him if it is possible to do this!
The first line contains three integers k1, k2 and k3 (1 ≤ ki ≤ 1500) — time intervals of the garlands.
If Mishka can choose moments of time to switch on the garlands in such a way that each second after switching the garlands on at least one garland will be lit, print YES.
Otherwise, print NO.
","input
In the first example Mishka can choose x1 = 1, x2 = 2, x3 = 1. The first garland will be lit during seconds 1, 3, 5, 7, ..., the second — 2, 4, 6, 8, ..., which already cover all the seconds after the 2-nd one. It doesn't even matter what x3 is chosen. Our choice will lead third to be lit during seconds 1, 4, 7, 10, ..., though.
output
In the second example there is no way to choose such moments of time, there always be some seconds when no garland is lit.
","bruteforce, constructivealgorithms",1
"#------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
#-------------------game starts now----------------------------------------------------
n,m=map(int,input().split())
s=0
e=n-1
for i in range(n//2):
    for j in range(m):
        print(s+1,j+1)
        print(e+1,m-j)
    s+=1
    e-=1
if n%2==1:
    s=n//2
    for j in range(m//2):
            print(s+1,j+1)
            print(s+1,m-j)
    if m%2==1:
            print(s+1,m//2+1)",1179_B,CODEFORCES,3600,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms,5
"x, k = map(int, input().split())
mod = 1000000007
if (k == 0):
    print((2 * x) % mod)
elif (x == 0):
    print(0)
else:
    ans = ((2 * x - 1) * pow(2, k, mod) + 1) % mod
    print(ans)
",0992_C,CODEFORCES,1031,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import sys
import bisect
#input=sys.stdin.readline
l=input().split()
a=l[0]
b=l[1]
p=[]
for i in range(len(a)):
    for j in range(len(b)):
        ok=a[:i+1]+b[:j+1]
        p.append(ok)
print(min(p))
",0909_A,CODEFORCES,1523,Generate Login,"The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.
You are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).
As a reminder, a prefix of a string s is its substring which occurs at the beginning of s: ""a"", ""ab"", ""abc"" etc. are prefixes of string ""{abcdef}"" but ""b"" and 'bc"" are not. A string a is alphabetically earlier than a string b, if a is a prefix of b, or a and b coincide up to some position, and then a has a letter that is alphabetically earlier than the corresponding letter in b: ""a"" and ""ab"" are alphabetically earlier than ""ac"" but ""b"" and ""ba"" are alphabetically later than ""ac"".
","input
The input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive. 
output
Output a single string — alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.
","bruteforce, greedy, sortings",3
"n = int(input())
s = input()
t = input()
pair2ind = {}
letters_s = [0] * 26
letters_t = [0] * 26
non_common = set()
cnt = 0
for i in range(n):
    if s[i] != t[i]:
        pair2ind[(s[i], t[i])] = i + 1
        letters_s[ord(s[i]) - ord('a')] = i + 1
        letters_t[ord(t[i]) - ord('a')] = i + 1
        non_common.add(i + 1)
        cnt += 1

sim = -1
for i in range(26):
    if letters_s[i] != 0 and letters_t[i] != 0:
        sim = letters_s[i]
        break
else:
    print(cnt)
    print(-1, -1)
    exit()

for i in range(n):
    if s[i] != t[i]:
        if (t[i], s[i]) in pair2ind:
            print(cnt - 2)
            print(pair2ind[(s[i], t[i])], pair2ind[(t[i], s[i])])
            exit()

non_common.remove(sim)
print(cnt - 1)
print(sim, letters_t[ord(s[sim-1]) - ord('a')])
exit()
",0527_B,CODEFORCES,1483,Error Correct System,"Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be ""similar"". After a brief search on the Internet, he learned about the Hamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words ""permanent"" and ""pergament"" is two, as these words differ in the fourth and sixth letters.
Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string S, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.
Help him do this!
The first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.
The second line contains string S.
The third line contains string T.
Each of the lines only contains lowercase Latin letters.
In the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.
In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print ""-1 -1"", if it is not necessary to swap characters.
","input
If there are multiple possible answers, print any of them.
output
In the second test it is acceptable to print i = 2, j = 3.
",greedy,3
"import os, sys
from io import BytesIO, IOBase


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[[float('inf')] * (k // 2 + 1) for _ in range(m + 1)] for _ in range(n + 1)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j][0] = 0

for k1 in range(1, k // 2 + 1):
    for i in range(n):
        for j in range(m):
            ans = []
            ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])
            ans.append(mem[i + 1][j][k1 - 1] + down[i][j])
            ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])
            ans.append(mem[i][j + 1][k1 - 1] + right[i][j])
            mem[i][j][k1] = min(ans)

[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]
",1517_D,CODEFORCES,4179,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"from itertools import chain, combinations
from random import randint
def powerset(iterable):
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

n,l,r,x=map(int,input().split())
ll=list(map(int,input().split()))
subsets=powerset(ll)
res=0
for i in subsets:
    if len(i) >= 2 and l<= sum(i) <=r and max(i)-min(i) >= x:
        res+=1
print(res)
",0550_B,CODEFORCES,4430,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"## 
max_ = 10**18
arr  = [0, 1]
arr2 = [0, 3] 
while arr[-1] < max_:
    arr.append(arr[-1]*4)
    arr2.append(arr2[-1]*2+1)
    
for i in range(1, len(arr)):
    arr[i] += arr[i-1]
    
def solve(n, k):
    if n==2 and k==3:
        return 'NO'
    if n==2 and k==4:
        return 'YES 0'
    if n+1<=len(arr) and k > arr[n]:
         return 'NO'
        
    i=0
    while k >= arr[i+1]:
        i+=1
    if k-arr[i] > arr2[i]:
        i+=1
    return 'YES ' +str(n-i)    

for _ in range(int(input())):
    n, k = map(int, input().split())
    print(solve(n, k))",1080_D,CODEFORCES,1211,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"n,m=map(int,input().split())
a=list(map(int,input().split()))
k=0
ans=-1
for i in range(n-1):
    while k<n-1 and a[k+1] - a[i]<=m:
        k+=1
    if i<k-1:
        ans=max(ans,(a[k]-a[i+1]) / (a[k]-a[i]))
print(ans)",0957_C,CODEFORCES,2469,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers",4
"from sys import stdin,stdout
input=stdin.readline
for _ in range(int(input())):
    x=10**5
    n,k=map(int,input().split())
    s=input()
    a=10**9
    ans=[[0]*n for i in range(3)]
    curr=['R','G','B']
    for l in range(3):
        z=l
        for j in range(n):
            if s[j]!=curr[z]:
                ans[l][j]=1
            z+=1
            z%=3
    for i in range(3):
        ans[i]=[0]+ans[i]
    for l in range(3):
        z=l
        for j in range(1,n+1):
            ans[l][j]+=ans[l][j-1]
    for l in range(3):
        for j in range(1,n-k+2):
            a=min(a,ans[l][j+k-1]-ans[l][j-1])
   # print(ans)
    print(a)
            ",1196_D2,CODEFORCES,2244,RGB Substring (hard version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2 \cdot 10^5$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2 \cdot 10^5$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
","datastructures, dp, implementation, twopointers",3
"from sys import stdin
input=stdin.readline
def answer():
    dp=[[[1e9 for i in range(k//2 + 1)] for j in range(m)] for i in range(n)]

    for i in range(n):
        for j in range(m):
            dp[i][j][0]=0
    
    for x in range(1,k//2 + 1):

        for i in range(n):
            for j in range(m):

                if(i > 0):
                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1] + c[i-1][j])
                if(j > 0):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1] + r[i][j-1])
                if(i + 1 < n):
                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1] + c[i][j])
                if(j + 1 < m):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1] + r[i][j])

    for i in range(n):
        for j in range(m):
            print(2*dp[i][j][-1],end=' ')

        print()



n,m,k=map(int,input().split())

r=[list(map(int,input().split())) for i in range(n)]
c=[list(map(int,input().split())) for i in range(n-1)]

if(k & 1):
    for i in range(n):
        for j in range(m):
            print(-1,end=' ')
    
else:answer()
",1517_D,CODEFORCES,4160,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"def main():
    q = int(input())
    ans = []
    for i in range(q):
        n, k = map(int, input().split())
        s = input()
        min_ans = 10 ** 9
        pr1 = [0]
        pr2 = [0]
        pr3 = [0]        
        for i in range(n):
            count1 = 0
            count2 = 0
            count3 = 0
            if i % 3 == 0:
                if s[i] != ""R"":
                    count1 += 1
                if s[i] != ""G"":
                    count2 += 1
                if s[i] != ""B"":
                    count3 += 1
            if i % 3 == 1:
                if s[i] != ""G"":
                    count1 += 1
                if s[i] != ""B"":
                    count2 += 1
                if s[i] != ""R"":
                    count3 += 1 
            if i % 3 == 2:
                if s[i] != ""B"":
                    count1 += 1
                if s[i] != ""R"":
                    count2 += 1
                if s[i] != ""G"":
                    count3 += 1
            pr1.append(pr1[-1] + count1)
            pr2.append(pr2[-1] + count2)
            pr3.append(pr3[-1] + count3)
            j = i + 1
            if j >= k:
                count1 = pr1[j] - pr1[j - k]
                count2 = pr2[j] - pr2[j - k]
                count3 = pr3[j] - pr3[j - k]
                min_ans = min(min_ans, count1, count2, count3)     
        ans.append(min_ans)
    print(*ans, sep=""\n"")

main()",1196_D2,CODEFORCES,2245,RGB Substring (hard version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2 \cdot 10^5$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2 \cdot 10^5$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
","datastructures, dp, implementation, twopointers",3
"
n=int(input())
m=int(input())
# x=(2**n)
if n>(m+1)/2:
	print(m)
else:
	print(int(m%(2**n)))
# print(x)",0913_A,CODEFORCES,230,Modular Exponentiation,"The following problem is well-known: given integers n and m, calculate
where 2n = 2·2·...·2 (n factors), and  denotes the remainder of division of x by y.
You are asked to solve the ""reverse"" problem. Given integers n and m, calculate
The first line contains a single integer n (1 ≤ n ≤ 108).
The second line contains a single integer m (1 ≤ m ≤ 108).
Output a single integer — the value of .
","input
In the first example, the remainder of division of 42 by 24 = 16 is equal to 10.
output
In the second example, 58 is divisible by 21 = 2 without remainder, and the answer is 0.
","implementation, math",1
"s = input()
one = s.count('1')
zero = 0
ind = -1
for i in range(len(s)):
    if s[i]=='2':
        ind=i
        break
    if s[i]=='0':
        zero+=1
d = """"
if ind==-1:
    print(""0""*zero+""1""*one)
    exit()
d =  d + ""0""*zero+""1""*one
for i in s[ind:]:
    if i!='1':
        d+=i
print(d)        
        
    
",1009_B,CODEFORCES,1787,Minimum Ternary String,"You are given a ternary string (it is a string which consists only of characters '0', '1' and '2').
You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace ""01"" with ""10"" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace ""12"" with ""21"" or vice versa).
For example, for string ""010210"" we can perform the following moves: 
Note than you cannot swap ""02"" $$$\rightarrow$$$ ""20"" and vice versa. You cannot perform any other operations with the given string excluding described above.
You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).
String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \le i \le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.
","input
The first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).
output
Print a single string — the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).
","greedy, implementation",3
"n=int(input())
if n==1:
    exit(print(1))
y=n
i=1
while n!=0:
    j=n//2+n%2
    if i*2>y and n==1:
        i=i>>1
        x=y//i
        print(i*x)
    else:
        print((str(i)+' ')*j,end='')
    i=i<<1
    n=n//2",1059_C,CODEFORCES,2833,Sequence Transformation,"Let's call the following process a transformation of a sequence of length $$$n$$$.
If the sequence is empty, the process ends. Otherwise, append the greatest common divisor (GCD) of all the elements of the sequence to the result and remove one arbitrary element from the sequence. Thus, when the process ends, we have a sequence of $$$n$$$ integers: the greatest common divisors of all the elements in the sequence before each deletion.
You are given an integer sequence $$$1, 2, \dots, n$$$. Find the lexicographically maximum result of its transformation.
A sequence $$$a_1, a_2, \ldots, a_n$$$ is lexicographically larger than a sequence $$$b_1, b_2, \ldots, b_n$$$, if there is an index $$$i$$$ such that $$$a_j = b_j$$$ for all $$$j < i$$$, and $$$a_i > b_i$$$.
The first and only line of input contains one integer $$$n$$$ ($$$1\le n\le 10^6$$$).
Output $$$n$$$ integers  — the lexicographically maximum result of the transformation.
","input
In the first sample the answer may be achieved this way:
output
We get the sequence $$$[1, 1, 3]$$$ as the result.
","constructivealgorithms, math",4
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr())
    n,d=lst()
    a=sorted(lst())
    s=set()
    for i in range(n):
        x=a[i]-d
        left=a[i-1] if i>=1 else float('inf')
        if abs(x-left)>=d:s.add(x)
        x=a[i]+d
        right=a[i+1] if i+1<n else float('inf')
        if abs(x-right)>=d:s.add(x)
    print(len(s))",1004_A,CODEFORCES,1751,Sonya and Hotels,"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.
The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $$$n$$$ hotels, where the $$$i$$$-th hotel is located in the city with coordinate $$$x_i$$$. Sonya is a smart girl, so she does not open two or more hotels in the same city.
Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $$$d$$$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 
Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $$$n$$$ hotels to the new one is equal to $$$d$$$.
The first line contains two integers $$$n$$$ and $$$d$$$ ($$$1\leq n\leq 100$$$, $$$1\leq d\leq 10^9$$$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.
The second line contains $$$n$$$ different integers in strictly increasing order $$$x_1, x_2, \ldots, x_n$$$ ($$$-10^9\leq x_i\leq 10^9$$$) — coordinates of Sonya's hotels.
Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $$$d$$$.
","input
In the first example, there are $$$6$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$-6$$$, $$$5$$$, $$$6$$$, $$$12$$$, $$$13$$$, and $$$19$$$.
output
In the second example, there are $$$5$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$2$$$, $$$6$$$, $$$13$$$, $$$16$$$, and $$$21$$$.
",implementation,3
"
n=int(raw_input())

ans=[]
p=1
fin=n
while len(ans)<n-1:
	for i in range(fin-(n/(2**p))):
		ans.append(2**(p-1))
		fin-=1
	p+=1

if 2**(p-2) + 2**(p-1) <=n:
	ans.append(2**(p-1) + 2**(p-2))
else:
	ans.append(2**(p-1))

s="" "".join(str(x) for x in ans)

print(s)
",1059_C,CODEFORCES,2829,Sequence Transformation,"Let's call the following process a transformation of a sequence of length $$$n$$$.
If the sequence is empty, the process ends. Otherwise, append the greatest common divisor (GCD) of all the elements of the sequence to the result and remove one arbitrary element from the sequence. Thus, when the process ends, we have a sequence of $$$n$$$ integers: the greatest common divisors of all the elements in the sequence before each deletion.
You are given an integer sequence $$$1, 2, \dots, n$$$. Find the lexicographically maximum result of its transformation.
A sequence $$$a_1, a_2, \ldots, a_n$$$ is lexicographically larger than a sequence $$$b_1, b_2, \ldots, b_n$$$, if there is an index $$$i$$$ such that $$$a_j = b_j$$$ for all $$$j < i$$$, and $$$a_i > b_i$$$.
The first and only line of input contains one integer $$$n$$$ ($$$1\le n\le 10^6$$$).
Output $$$n$$$ integers  — the lexicographically maximum result of the transformation.
","input
In the first sample the answer may be achieved this way:
output
We get the sequence $$$[1, 1, 3]$$$ as the result.
","constructivealgorithms, math",4
"n = int(input())
dicta = {}
dictb = {}
for i in range(n):
    a, x = map(int, input().split())
    dicta[a] = x
m = int(input())
for i in range(m):
    b, y = map(int, input().split())
    dictb[b] = y
ans = 0
for i in dicta.keys():
    if i in dictb.keys():
        ans += max(dicta[i], dictb[i])
        del dictb[i]
    else :
        ans += dicta[i]
for i in dictb.values():
    ans += i
print(ans)
",0981_B,CODEFORCES,2541,Businessmen Problems,"Two famous competing companies ChemForces and TopChemist decided to show their sets of recently discovered chemical elements on an exhibition. However they know that no element should be present in the sets of both companies.
In order to avoid this representatives of both companies decided to make an agreement on the sets the companies should present. The sets should be chosen in the way that maximizes the total income of the companies.
All elements are enumerated with integers. The ChemForces company has discovered $$$n$$$ distinct chemical elements with indices $$$a_1, a_2, \ldots, a_n$$$, and will get an income of $$$x_i$$$ Berland rubles if the $$$i$$$-th element from this list is in the set of this company.
The TopChemist company discovered $$$m$$$ distinct chemical elements with indices $$$b_1, b_2, \ldots, b_m$$$, and it will get an income of $$$y_j$$$ Berland rubles for including the $$$j$$$-th element from this list to its set.
In other words, the first company can present any subset of elements from $$$\{a_1, a_2, \ldots, a_n\}$$$ (possibly empty subset), the second company can present any subset of elements from $$$\{b_1, b_2, \ldots, b_m\}$$$ (possibly empty subset). There shouldn't be equal elements in the subsets.
Help the representatives select the sets in such a way that no element is presented in both sets and the total income is the maximum possible.
The first line contains a single integer $$$n$$$ ($$$1 \leq n \leq 10^5$$$)  — the number of elements discovered by ChemForces.
The $$$i$$$-th of the next $$$n$$$ lines contains two integers $$$a_i$$$ and $$$x_i$$$ ($$$1 \leq a_i \leq 10^9$$$, $$$1 \leq x_i \leq 10^9$$$)  — the index of the $$$i$$$-th element and the income of its usage on the exhibition. It is guaranteed that all $$$a_i$$$ are distinct.
The next line contains a single integer $$$m$$$ ($$$1 \leq m \leq 10^5$$$)  — the number of chemicals invented by TopChemist.
The $$$j$$$-th of the next $$$m$$$ lines contains two integers $$$b_j$$$ and $$$y_j$$$, ($$$1 \leq b_j \leq 10^9$$$, $$$1 \leq y_j \leq 10^9$$$)  — the index of the $$$j$$$-th element and the income of its usage on the exhibition. It is guaranteed that all $$$b_j$$$ are distinct.
Print the maximum total income you can obtain by choosing the sets for both companies in such a way that no element is presented in both sets.
","input
In the first example ChemForces can choose the set ($$$3, 7$$$), while TopChemist can choose ($$$1, 2, 4$$$). This way the total income is $$$(10 + 2) + (4 + 4 + 4) = 24$$$.
output
In the second example ChemForces can choose the only element $$$10^9$$$, while TopChemist can choose ($$$14, 92, 35$$$). This way the total income is $$$(239) + (15 + 65 + 89) = 408$$$.
",sortings,4
"# Fonte XXXX
l, r = [int(x) for x in input().split()]

q = l ^ r
a = 1
while q:
    q //=2
    a <<= 1
print(a-1)

 	 			 	 			    	 			 			 		 		",0276_D,CODEFORCES,848,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"from sys import stdin, stdout

get_string = lambda: stdin.readline().strip('\n')
get_intmap = lambda: map( int, get_string().split(' ') )
#get_intmap

def testcase():
    n, M = get_intmap()
    a = [0] + list(get_intmap()) + [M]
    ontime = [0] * (n + 1)
    tmp = 0
    for ind in range(n, -1, -1):
        if ind %2 == 0: #light will be on from now
            tmp += a[ind + 1] - a[ind]#total ontime from ind
        ontime[ind] = tmp
    mx = ontime[0]
    #insert at ai + 1 or ai+1 - 1
    for ind in range(n + 1):#iterate over segments
        l,r = a[ind], a[ind+1]
        if r - l <= 1: continue
        for x in (l+1, r-1):
            newtime = ontime[0] - ontime[ind]
            if ind % 2 == 0:
                newtime += x - l
            else:
                newtime += r - x
            newtime += (M - r) - ontime[ind]
            mx = max(mx, newtime)
    print(mx)
        

    

testcase();quit()
for t in range(int(input())):
    testcase()
",1000_B,CODEFORCES,1745,Light It Up,"Recently, you bought a brand new smart lamp with programming features. At first, you set up a schedule to the lamp. Every day it will turn power on at moment $$$0$$$ and turn power off at moment $$$M$$$. Moreover, the lamp allows you to set a program of switching its state (states are ""lights on"" and ""lights off""). Unfortunately, some program is already installed into the lamp.
The lamp allows only good programs. Good program can be represented as a non-empty array $$$a$$$, where $$$0 < a_1 < a_2 < \dots < a_{|a|} < M$$$. All $$$a_i$$$ must be integers. Of course, preinstalled program is a good program.
The lamp follows program $$$a$$$ in next manner: at moment $$$0$$$ turns power and light on. Then at moment $$$a_i$$$ the lamp flips its state to opposite (if it was lit, it turns off, and vice versa). The state of the lamp flips instantly: for example, if you turn the light off at moment $$$1$$$ and then do nothing, the total time when the lamp is lit will be $$$1$$$. Finally, at moment $$$M$$$ the lamp is turning its power off regardless of its state.
Since you are not among those people who read instructions, and you don't understand the language it's written in, you realize (after some testing) the only possible way to alter the preinstalled program. You can insert at most one element into the program $$$a$$$, so it still should be a good program after alteration. Insertion can be done between any pair of consecutive elements of $$$a$$$, or even at the begining or at the end of $$$a$$$.
Find such a way to alter the program that the total time when the lamp is lit is maximum possible. Maybe you should leave program untouched. If the lamp is lit from $$$x$$$ till moment $$$y$$$, then its lit for $$$y - x$$$ units of time. Segments of time when the lamp is lit are summed up.
First line contains two space separated integers $$$n$$$ and $$$M$$$ ($$$1 \le n \le 10^5$$$, $$$2 \le M \le 10^9$$$) — the length of program $$$a$$$ and the moment when power turns off.
Second line contains $$$n$$$ space separated integers $$$a_1, a_2, \dots, a_n$$$ ($$$0 < a_1 < a_2 < \dots < a_n < M$$$) — initially installed program $$$a$$$.
Print the only integer — maximum possible total time when the lamp is lit.
In the first example, one of possible optimal solutions is to insert value $$$x = 3$$$ before $$$a_1$$$, so program will be $$$[3, 4, 6, 7]$$$ and time of lamp being lit equals $$$(3 - 0) + (6 - 4) + (10 - 7) = 8$$$. Other possible solution is to insert $$$x = 5$$$ in appropriate place.
","input
In the second example, there is only one optimal solution: to insert $$$x = 2$$$ between $$$a_1$$$ and $$$a_2$$$. Program will become $$$[1, 2, 10]$$$, and answer will be $$$(1 - 0) + (10 - 2) = 9$$$.
output
In the third example, optimal answer is to leave program untouched, so answer will be $$$(3 - 0) + (7 - 4) = 6$$$.
",greedy,3
"def digit_sum(n):
	cnt = 0
	while n:
		cnt += n % 10
		n //= 10
	return cnt


def bsearch(low, high, s):
	h = high
	ans = -1
	while low <= high:
		mid = (low + high) // 2
		if mid - digit_sum(mid) >= s:
			ans = mid
			high = mid - 1
		else:
			low = mid + 1
	if ans == -1:
		return 0
	else:
		return h - ans + 1


n, s = map(int, input().split())
st = 1
end = 10
cnt = 0
cnt += (bsearch(1, n, s))
print(cnt)
",0817_C,CODEFORCES,1007,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

#?############################################################


def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

#?############################################################


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p


#?############################################################

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))


#?############################################################

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

#?############################################################


def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime


#?############################################################

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

#?############################################################


def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

#?############################################################


def mapin():
    return map(int, input().split())

#?############################################################


# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
# python3 15.py<in>op
a, b, c, n = mapin()
d = a+b-c

if(d > n-1 or c > a or c > b):
    print(-1)
else:
    print(n-d)",0991_A,CODEFORCES,366,If at first you don't succeed,"Each student eagerly awaits the day he would pass the exams successfully. Thus, Vasya was ready to celebrate, but, alas, he didn't pass it. However, many of Vasya's fellow students from the same group were more successful and celebrated after the exam.
Some of them celebrated in the BugDonalds restaurant, some of them — in the BeaverKing restaurant, the most successful ones were fast enough to celebrate in both of restaurants. Students which didn't pass the exam didn't celebrate in any of those restaurants and elected to stay home to prepare for their reexamination. However, this quickly bored Vasya and he started checking celebration photos on the Kilogramm. He found out that, in total, BugDonalds was visited by $$$A$$$ students, BeaverKing — by $$$B$$$ students and $$$C$$$ students visited both restaurants. Vasya also knows that there are $$$N$$$ students in his group.
Based on this info, Vasya wants to determine either if his data contradicts itself or, if it doesn't, how many students in his group didn't pass the exam. Can you help him so he won't waste his valuable preparation time?
The first line contains four integers — $$$A$$$, $$$B$$$, $$$C$$$ and $$$N$$$ ($$$0 \leq A, B, C, N \leq 100$$$).
If a distribution of $$$N$$$ students exists in which $$$A$$$ students visited BugDonalds, $$$B$$$ — BeaverKing, $$$C$$$ — both of the restaurants and at least one student is left home (it is known that Vasya didn't pass the exam and stayed at home), output one integer — amount of students (including Vasya) who did not pass the exam. 
If such a distribution does not exist and Vasya made a mistake while determining the numbers $$$A$$$, $$$B$$$, $$$C$$$ or $$$N$$$ (as in samples 2 and 3), output $$$-1$$$.
The first sample describes following situation: $$$5$$$ only visited BugDonalds, $$$5$$$ students only visited BeaverKing, $$$5$$$ visited both of them and $$$5$$$ students (including Vasya) didn't pass the exam.
","input
In the second sample $$$2$$$ students only visited BugDonalds and $$$2$$$ only visited BeaverKing, but that means all $$$4$$$ students in group passed the exam which contradicts the fact that Vasya didn't pass meaning that this situation is impossible.
output
The third sample describes a situation where $$$2$$$ students visited BugDonalds but the group has only $$$1$$$ which makes it clearly impossible.
",implementation,1
"def solve(d, n, k):
    mv = sum(d[0:k])
    v = mv
    for i in range(1, n-k+1):
        mv = mv + d[i+k-1] - d[i-1]
        v = min(v, mv)
    return v

for _ in range(int(input())):
    n, k = tuple(map(int, input().split()))
    s = input()
    st = 'RGB' * (n//3 + 3)
    diff1, diff2, diff3 = [0 for _ in range(n)], [0 for _ in range(n)], [0 for _ in range(n)]

    for i in range(n):
        if s[i] != st[i]: diff1[i] = 1
        if s[i] != st[i+1]: diff2[i] = 1
        if s[i] != st[i+2]: diff3[i] = 1

    print(min(solve(diff1, n, k), solve(diff2, n, k), solve(diff3, n, k)))",1196_D1,CODEFORCES,2235,RGB Substring (easy version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2000$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2000$$$ ($$$\sum n \le 2000$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
",implementation,3
"import os,sys
from io import BytesIO, IOBase

from collections import deque, Counter,defaultdict as dft
from heapq import heappop ,heappush
from math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor
from bisect import bisect,bisect_left,bisect_right
from decimal import *
import sys,threading
from itertools import permutations, combinations
from copy import deepcopy
input = sys.stdin.readline


ii = lambda: int(input())
si = lambda: input().rstrip()
mp = lambda: map(int, input().split())
ms=  lambda: map(str,input().strip().split("" ""))
ml = lambda: list(mp())
mf = lambda: map(float, input().split())


alphs = ""abcdefghijklmnopqrstuvwxyz""




def solve():
    n,m,k=map(int,input().split())
    dct={}
    global case
    case=0
    iput=[]
    for i in range(n):
        word=input()
        dct[word]=i+1
        iput.append(word)
    d=[[] for i in range(n+1)]
    size=[0]*(n+1)
    for _ in range(m):
        
        word,idx=input().split()
        idx=int(idx)
        temp=1
        w=iput[idx-1]
        
        for x in range(k):
            if w[x]!='_' and w[x]!=word[x]:
                temp=0
                print(""NO"")
                exit()
                break
        
        
        res=[]
        for i in range(1<<k):
            s="""".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)])
            #print(s)
            
            if s in dct:
                j=dct[s]
                if j!=idx:
                    d[idx].append(j)
                    size[j]+=1
    
    
    
    
    st=[nd  for nd in range(1,n+1) if size[nd]==0]
    
    for i in st:
        #print(st)
        for j in d[i]:
            size[j]-=1
            if size[j]==0:
                st.append(j)
    
    
    if len(st)==n:
        print(""YES"")
        print(*st)
    else:
        print(""NO"")
        
    

 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
 
if __name__ == ""__main__"":
    tc=1
    #tc = ii()
    for i in range(tc):
    	solve()",1476_E,CODEFORCES,4746,Pattern Matching,"You are given $$$n$$$ patterns $$$p_1, p_2, \dots, p_n$$$ and $$$m$$$ strings $$$s_1, s_2, \dots, s_m$$$. Each pattern $$$p_i$$$ consists of $$$k$$$ characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string $$$s_j$$$ consists of $$$k$$$ lowercase Latin letters.
A string $$$a$$$ matches a pattern $$$b$$$ if for each $$$i$$$ from $$$1$$$ to $$$k$$$ either $$$b_i$$$ is a wildcard character or $$$b_i=a_i$$$.
You are asked to rearrange the patterns in such a way that the first pattern the $$$j$$$-th string matches is $$$p[mt_j]$$$. You are allowed to leave the order of the patterns unchanged.
Can you perform such a rearrangement? If you can, then print any valid order.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \le n, m \le 10^5$$$, $$$1 \le k \le 4$$$) — the number of patterns, the number of strings and the length of each pattern and string.
Each of the next $$$n$$$ lines contains a pattern — $$$k$$$ characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct.
Each of the next $$$m$$$ lines contains a string — $$$k$$$ lowercase Latin letters, and an integer $$$mt$$$ ($$$1 \le mt \le n$$$) — the index of the first pattern the corresponding string should match.
Print ""NO"" if there is no way to rearrange the patterns in such a way that the first pattern that the $$$j$$$-th string matches is $$$p[mt_j]$$$.
Otherwise, print ""YES"" in the first line. The second line should contain $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ — the order of the patterns. If there are multiple answers, print any of them.
The order of patterns after the rearrangement in the first example is the following: 
Thus, the first string matches patterns ab__, _bcd, _b_d in that order, the first of them is ab__, that is indeed $$$p[4]$$$. The second string matches __b_ and ab__, the first of them is __b_, that is $$$p[2]$$$. The last string matches _bcd and _b_d, the first of them is _bcd, that is $$$p[5]$$$.
The answer to that test is not unique, other valid orders also exist.
","input
In the second example cba doesn't match __c, thus, no valid order exists.
output
In the third example the order (a_, _b) makes both strings match pattern $$$1$$$ first and the order (_b, a_) makes both strings match pattern $$$2$$$ first. Thus, there is no order that produces the result $$$1$$$ and $$$2$$$.
","bitmasks, datastructures, dfsandsimilar, graphs, hashing, sortings, strings",7
"from __future__ import division
from sys import stdin, stdout
from collections import *

rstr = lambda: stdin.readline().strip()
rstrs = lambda: [str(x) for x in stdin.readline().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(stdin.readline())
rints = lambda: [int(x) for x in stdin.readline().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
pr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\n')
ceil1, out = lambda a, b: (a + b - 1) // b, []

n, s = rints()
a, ans = rints_2d(n), -1

for i in range(26):
    for j in range(60):
        tem = i * 60 + j
        ans = (i, j)
        for h, m in a:
            tem2 = h * 60 + m
            if tem <= tem2:
                if tem2 - (tem + 1) < s:
                    ans = -1
                    break
            else:
                if tem - (tem2 + 1) < s:
                    ans = -1
                    break

        if ans != -1:
            print('%d %d' % (ans[0], ans[1]))
            exit()
",0967_A,CODEFORCES,1621,Mind the Gap,"These days Arkady works as an air traffic controller at a large airport. He controls a runway which is usually used for landings only. Thus, he has a schedule of planes that are landing in the nearest future, each landing lasts $$$1$$$ minute.
He was asked to insert one takeoff in the schedule. The takeoff takes $$$1$$$ minute itself, but for safety reasons there should be a time space between the takeoff and any landing of at least $$$s$$$ minutes from both sides.
Find the earliest time when Arkady can insert the takeoff.
The first line of input contains two integers $$$n$$$ and $$$s$$$ ($$$1 \le n \le 100$$$, $$$1 \le s \le 60$$$) — the number of landings on the schedule and the minimum allowed time (in minutes) between a landing and a takeoff.
Each of next $$$n$$$ lines contains two integers $$$h$$$ and $$$m$$$ ($$$0 \le h \le 23$$$, $$$0 \le m \le 59$$$) — the time, in hours and minutes, when a plane will land, starting from current moment (i. e. the current time is $$$0$$$ $$$0$$$). These times are given in increasing order.
Print two integers $$$h$$$ and $$$m$$$ — the hour and the minute from the current moment of the earliest time Arkady can insert the takeoff.
In the first example note that there is not enough time between 1:20 and 3:21, because each landing and the takeoff take one minute.
","input
In the second example there is no gaps in the schedule, so Arkady can only add takeoff after all landings. Note that it is possible that one should wait more than $$$24$$$ hours to insert the takeoff.
output
In the third example Arkady can insert the takeoff even between the first landing.
",implementation,3
"import sys
m,n = [int(i) for i in input().split(' ')]
l = [[] for _ in range(m)]
for i in range(m):
	l[i] = input()
inks = []
for i in range(1, m-1):
	for j in range(1, n-1):
		if l[i-1][j-1] == '#' and l[i][j-1] == '#' and l[i+1][j-1] == '#' and l[i-1][j] == '#' and l[i+1][j] == '#' and l[i-1][j+1] == '#'and l[i][j+1] == '#'and l[i+1][j+1] == '#':
			   inks += [(i-1,j-1),(i,j-1),(i+1,j-1),
					    (i-1,j  )        ,(i+1,j  ),
						(i-1,j+1),(i,j+1),(i+1,j+1),]
for i in range(m):
	for j in range(n):
		if l[i][j] == '#' and not (i,j) in inks:
			print(""NO"")
			sys.exit()
else:
	print(""YES"")
			
			
		   
		
",1059_B,CODEFORCES,3558,Forgery,"Student Andrey has been skipping physical education lessons for the whole term, and now he must somehow get a passing grade on this subject. Obviously, it is impossible to do this by legal means, but Andrey doesn't give up. Having obtained an empty certificate from a local hospital, he is going to use his knowledge of local doctor's handwriting to make a counterfeit certificate of illness. However, after writing most of the certificate, Andrey suddenly discovered that doctor's signature is impossible to forge. Or is it?
For simplicity, the signature is represented as an $$$n\times m$$$ grid, where every cell is either filled with ink or empty. Andrey's pen can fill a $$$3\times3$$$ square without its central cell if it is completely contained inside the grid, as shown below.
Determine whether is it possible to forge the signature on an empty $$$n\times m$$$ grid.
The first line of input contains two integers $$$n$$$ and $$$m$$$ ($$$3 \le n, m \le 1000$$$).
Then $$$n$$$ lines follow, each contains $$$m$$$ characters. Each of the characters is either '.', representing an empty cell, or '#', representing an ink filled cell.
If Andrey can forge the signature, output ""YES"". Otherwise output ""NO"".
You can print each letter in any case (upper or lower).
In the first sample Andrey can paint the border of the square with the center in $$$(2, 2)$$$.
In the second sample the signature is impossible to forge.
","input
In the third sample Andrey can paint the borders of the squares with the centers in $$$(2, 2)$$$ and $$$(3, 2)$$$: 
output
In the fourth sample Andrey can paint the borders of the squares with the centers in $$$(3, 3)$$$ and $$$(3, 5)$$$.
",implementation,5
"def inn1(s1):
    t=False
    for i in s1:
        if i[0]>=xmi1 and i[0]<=xma1 and i[1]>=ymi1 and i[1]<=yma1:
            t=True
            break
    if c2[0]>=xmi1 and c2[0]<=xma1 and c2[1]>=ymi1 and c2[1]<=yma1:
            t=True
    return t
def inn2(s):
    t=False
    for i in s:
        if i[0]>=xmi2 and i[0]<=xma2 and i[1]>=ymi2 and i[1]<=yma2:
            t=True
            break
    if c1[0]>=xmi2 and c1[0]<=xma2 and c1[1]>=ymi2 and c1[1]<=yma2:
            t=True
    return t
def conv(s):
    for i in range(4):
        x=s[i][0]
        y=s[i][1]
        s[i][0]=x+y
        s[i][1]=x-y
    return s
aux=list(map(int,input().split()))
s=[]
for i in range(0,8,2):
    s.append([aux[i],aux[i+1]])
aux=list(map(int,input().split()))
s1=[]
for i in range(0,8,2):
    s1.append([aux[i],aux[i+1]])
st=set()
for i in s:
    st.add(i[1])
xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]
for i in range(4):
    xma1=max(xma1,s[i][0])
    xma2=max(xma2,s1[i][0])
    xmi1=min(xmi1,s[i][0])
    xmi2=min(xmi2,s1[i][0])
    yma1=max(yma1,s[i][1])
    yma2=max(yma2,s1[i][1])
    ymi1=min(ymi1,s[i][1])
    ymi2=min(ymi2,s1[i][1])
c1=[(xma1+xmi1)/2,(yma1+ymi1)/2]
c2=[(xma2+xmi2)/2,(yma2+ymi2)/2]
t=False
if len(st)==2:
    t=True
if t:
    t1=inn1(s1)
    s=conv(s)
    s1=conv(s1)
    xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]
    for i in range(4):
        xma1=max(xma1,s[i][0])
        xma2=max(xma2,s1[i][0])
        xmi1=min(xmi1,s[i][0])
        xmi2=min(xmi2,s1[i][0])
        yma1=max(yma1,s[i][1])
        yma2=max(yma2,s1[i][1])
        ymi1=min(ymi1,s[i][1])
        ymi2=min(ymi2,s1[i][1])
    c1=[(xma1+xmi1)/2,(yma1+ymi1)/2]
    c2=[(xma2+xmi2)/2,(yma2+ymi2)/2]
    t2=inn2(s)
else:
    t1=inn2(s)
    s=conv(s)
    s1=conv(s1)
    xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]
    for i in range(4):
        xma1=max(xma1,s[i][0])
        xma2=max(xma2,s1[i][0])
        xmi1=min(xmi1,s[i][0])
        xmi2=min(xmi2,s1[i][0])
        yma1=max(yma1,s[i][1])
        yma2=max(yma2,s1[i][1])
        ymi1=min(ymi1,s[i][1])
        ymi2=min(ymi2,s1[i][1])
    c1=[(xma1+xmi1)/2,(yma1+ymi1)/2]
    c2=[(xma2+xmi2)/2,(yma2+ymi2)/2]
    t2=inn1(s1)
    
if t1 or t2:
    print(""YES"")
else:
    print(""NO"")
    
",0994_C,CODEFORCES,391,Two Squares,"You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.
The interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.
The input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order.
The first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees.
All the values are integer and between $$$-100$$$ and $$$100$$$.
Print ""Yes"" if squares intersect, otherwise print ""No"".
You can print each letter in any case (upper or lower).
In the first example the second square lies entirely within the first square, so they do intersect.
","input
In the second sample squares do not have any points in common.
output
Here are images corresponding to the samples:
",bruteforce,1
"import sys

def pprint(s):
    sys.stdout.write(str(s) + ""\n"")

def solve(n, d, k):
    for i in range(1, d+1):
        pprint(str(i)  + ' ' + str(i+1))
        if i + 1 == n:
            exit()

    q = d+2
    for i in range(2, d+1):
        for j in range(k-2):
            pprint(str(i)  + ' ' + str(q))
            if q == n:
                exit()
            q += 1
            def rec(depth, current, head):
                if depth == 0:
                    return current

                for i in range(k-1):
                    pprint(str(head)  + ' ' + str(current))
                    if current == n:
                        exit()
                    current += 1
                        
                    current = rec(depth-1, current, current-1)

                return current

            if i <= (d+2)/2:
                depth = i-2
            else:
                depth = d-i

            q = rec(depth, q, q-1)


    




n, d, k = map(int, input().split())

q = k-1
maxi = 0
if k == 2:
    maxi = d+1
else:
    if d % 2:
        maxi = (q * (1-q**(d//2)) // (1-q) + 1) * 2
    else:
        maxi = (q * (1-q**(d//2-1)) // (1-q) + 1) * 3 + 1

if d == 2:
    maxi = k + 1

if n > maxi or n <= d:
    print(""NO"")
else:
    print(""YES"")
    solve(n, d, k)",1003_E,CODEFORCES,3356,Tree Constructing,"You are given three integers $$$n$$$, $$$d$$$ and $$$k$$$.
Your task is to construct an undirected tree on $$$n$$$ vertices with diameter $$$d$$$ and degree of each vertex at most $$$k$$$, or say that it is impossible.
An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Diameter of a tree is the maximum length of a simple path (a path in which each vertex appears at most once) between all pairs of vertices of this tree.
Degree of a vertex is the number of edges incident to this vertex (i.e. for a vertex $$$u$$$ it is the number of edges $$$(u, v)$$$ that belong to the tree, where $$$v$$$ is any other vertex of a tree).
The first line of the input contains three integers $$$n$$$, $$$d$$$ and $$$k$$$ ($$$1 \le n, d, k \le 4 \cdot 10^5$$$).
","input
If there is no tree satisfying the conditions above, print only one word ""NO"" (without quotes).
output
Otherwise in the first line print ""YES"" (without quotes), and then print $$$n - 1$$$ lines describing edges of a tree satisfying the conditions above. Vertices of the tree must be numbered from $$$1$$$ to $$$n$$$. You can print edges and vertices connected by an edge in any order. If there are multiple answers, print any of them.1
","constructivealgorithms, graphs",5
"n = int(input())

x, y = map(int, input().split())

ans = (x - 1) + (y - 1) <= (n - x) + (n - y)
print('White' if ans else 'Black')
",1075_A,CODEFORCES,561,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"def number(pos):
    ans = 0
    for i in range(pos + 1):
        ans += 2**(i)
    return ans

l, r = input().split()
l = int(l)
r = int(r)

if(l == r):
    print(0)
else:
    b_pos = 0
    i = 0
    while(l > 0 or r > 0):
        if(l%2 != r%2):
            b_pos = i
        l >>= 1
        r >>= 1
        i += 1
    print(number(b_pos))

	 		 	 	 	 	  	  				  	 	 	",0276_D,CODEFORCES,842,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"#!/usr/bin/env python
# coding: utf-8

# In[46]:


a=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999990000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
b=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
print(a)
print(b)

",1028_B,CODEFORCES,435,Unnatural Conditions,"Let $$$s(x)$$$ be sum of digits in decimal representation of positive integer $$$x$$$. Given two integers $$$n$$$ and $$$m$$$, find some positive integers $$$a$$$ and $$$b$$$ such that 
The only line of input contain two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1129$$$).
","input
Print two lines, one for decimal representation of $$$a$$$ and one for decimal representation of $$$b$$$. Both numbers must not contain leading zeros and must have length no more than $$$2230$$$.
output
In the first sample, we have $$$n = 6$$$ and $$$m = 5$$$. One valid solution is $$$a = 6$$$, $$$b = 7$$$. Indeed, we have $$$s(a) = 6 \ge n$$$ and $$$s(b) = 7 \ge n$$$, and also $$$s(a + b) = s(13) = 4 \le m$$$.
","constructivealgorithms, math",1
"from os import path
import sys,time
# mod = int(1e9 + 7)
# import re
from math import ceil, floor,gcd,log,log2 ,factorial
from collections import * 
# from bisect import *
maxx = float('inf')
#----------------------------INPUT FUNCTIONS------------------------------------------#
I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().strip('\n')
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
#left shift --- num*(2**k) --(k - shift)
s=S()
ans = s.replace('1','')+'2'
t =  ans.find('2')
# print(ans,t)
print(ans[:t]+'1'*s.count('1')+ans[t:len(ans)-1])






if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",1009_B,CODEFORCES,1785,Minimum Ternary String,"You are given a ternary string (it is a string which consists only of characters '0', '1' and '2').
You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace ""01"" with ""10"" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace ""12"" with ""21"" or vice versa).
For example, for string ""010210"" we can perform the following moves: 
Note than you cannot swap ""02"" $$$\rightarrow$$$ ""20"" and vice versa. You cannot perform any other operations with the given string excluding described above.
You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).
String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \le i \le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.
","input
The first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).
output
Print a single string — the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).
","greedy, implementation",3
"n,l,r,x=map(int,input().split())
num=list(map(int,input().split()))
ans=0
for i in range(2**n):
    st=bin(i)[2:]
    st='0'*(n-len(st))+st
    if st.count('1')>=2:
        pt=[]
        for i in range(len(st)):
            if st[i]=='1':
                pt.append(num[i])
        if sum(pt)<=r and sum(pt)>=l and max(pt)-min(pt)>=x:
            ans+=1
print(ans)",0550_B,CODEFORCES,4436,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"import math

n, r = map(int, input().split())
angle = math.pi / n
s = math.sin(angle)
#rad = 1 / math.sin(angle) - 1
#print('%.8f' % (r / rad))
print('%.8f' % (r * s / (1 - s)))
",1100_C,CODEFORCES,663,NN and the Optical Illusion,"NN is an experienced internet user and that means he spends a lot of time on the social media. Once he found the following image on the Net, which asked him to compare the sizes of inner circles:
It turned out that the circles are equal. NN was very surprised by this fact, so he decided to create a similar picture himself.
He managed to calculate the number of outer circles $$$n$$$ and the radius of the inner circle $$$r$$$. NN thinks that, using this information, you can exactly determine the radius of the outer circles $$$R$$$ so that the inner circle touches all of the outer ones externally and each pair of neighboring outer circles also touches each other. While NN tried very hard to guess the required radius, he didn't manage to do that. 
Help NN find the required radius for building the required picture.
The first and the only line of the input file contains two numbers $$$n$$$ and $$$r$$$ ($$$3 \leq n \leq 100$$$, $$$1 \leq r \leq 100$$$) — the number of the outer circles and the radius of the inner circle respectively.
Output a single number $$$R$$$ — the radius of the outer circle required for building the required picture. 
","input
Your answer will be accepted if its relative or absolute error does not exceed $$$10^{-6}$$$.
output
Formally, if your answer is $$$a$$$ and the jury's answer is $$$b$$$. Your answer is accepted if and only when $$$\frac{|a-b|}{max(1, |b|)} \le 10^{-6}$$$.
","binarysearch, geometry, math",1
"from copy import deepcopy
x,k=map(int,input().split(' '))
if(x==0):
	print(0)
else:
	print((((pow(2,k,1000000007))*((2*x-1)%1000000007))+1)%1000000007)
",0992_C,CODEFORCES,1090,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"t=int(input())
for i in range(t):
    n=int(input())
    ar=list(map(int,input().split()))
    if(n<=2):
        print(0)
        continue
    ar=sorted(ar)[::-1]
    ans=0
    for i in range(1,n-1):
        if(ar[0]>i and ar[1]>i):
            ans=i
    print(ans)
",1197_A,CODEFORCES,3002,DIY Wooden Ladder,"Let's denote a $$$k$$$-step ladder as the following structure: exactly $$$k + 2$$$ wooden planks, of which
Note that neither the base planks, nor the steps planks are required to be equal.
For example, ladders $$$1$$$ and $$$3$$$ are correct $$$2$$$-step ladders and ladder $$$2$$$ is a correct $$$1$$$-step ladder. On the first picture the lengths of planks are $$$[3, 3]$$$ for the base and $$$[1]$$$ for the step. On the second picture lengths are $$$[3, 3]$$$ for the base and $$$[2]$$$ for the step. On the third picture lengths are $$$[3, 4]$$$ for the base and $$$[2, 3]$$$ for the steps. 
You have $$$n$$$ planks. The length of the $$$i$$$-th planks is $$$a_i$$$. You don't have a saw, so you can't cut the planks you have. Though you have a hammer and nails, so you can assemble the improvised ""ladder"" from the planks.
The question is: what is the maximum number $$$k$$$ such that you can choose some subset of the given planks and assemble a $$$k$$$-step ladder using them?
The first line contains a single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of queries. The queries are independent.
Each query consists of two lines. The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^5$$$) — the number of planks you have.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^5$$$) — the lengths of the corresponding planks.
It's guaranteed that the total number of planks from all queries doesn't exceed $$$10^5$$$.
Print $$$T$$$ integers — one per query. The $$$i$$$-th integer is the maximum number $$$k$$$, such that you can choose some subset of the planks given in the $$$i$$$-th query and assemble a $$$k$$$-step ladder using them.
Print $$$0$$$ if you can't make even $$$1$$$-step ladder from the given set of planks.
","input
Examples for the queries $$$1-3$$$ are shown at the image in the legend section.
output
The Russian meme to express the quality of the ladders:
","greedy, math, sortings",4
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#######################################
from heapq import heapify,heappush as hp,heappop as hpop
def check(x,y):
    if 0<=x<=n-1 and 0<=y<=m-1:
        return True
    return False
n,m,k=map(int,input().split())
l1=[]
l2=[]
for i in range(n):
    l1.append(list(map(int,input().split())))
for  i in range(n-1):
    l2.append(list(map(int,input().split())))
inf=10**18
dp=[[[inf]*21 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        if check(i,j+1):
            dp[i][j][1]=min(l1[i][j],dp[i][j][1])
        if check(i,j-1):
            dp[i][j][1]=min(l1[i][j-1],dp[i][j][1])
        if check(i+1,j):
            dp[i][j][1]=min(l2[i][j],dp[i][j][1])
        if check(i-1,j):
            dp[i][j][1]=min(l2[i-1][j],dp[i][j][1])
for x in range(2,k//2+1):
    for i in range(n):
        for j in range(m):
            if check(i,j+1):
                dp[i][j][x]=min(l1[i][j]+dp[i][j+1][x-1],dp[i][j][x])
            if check(i,j-1):
                dp[i][j][x]=min(l1[i][j-1]+dp[i][j-1][x-1],dp[i][j][x])
            if check(i+1,j):
                dp[i][j][x]=min(l2[i][j]+dp[i+1][j][x-1],dp[i][j][x])
            if check(i-1,j):
                dp[i][j][x]=min(l2[i-1][j]+dp[i-1][j][x-1],dp[i][j][x])
           
ans=[[inf]*m for i in range(n)]
for i in range(n):
    for j in range(m):
        if k%2:
            ans[i][j]=-1
            continue
        ans[i][j]=2*dp[i][j][k//2] 
for i in ans:
    print(*i)
",1517_D,CODEFORCES,4127,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"a = list(map(int,input().split()))
if a.count(1)>=1 or a.count(2)>=2 or a.count(3)==3 or (a.count(2)==1 and a.count(4)==2):
    print(""YES"")
else:
    print(""NO"")",0911_C,CODEFORCES,200,Three Garlands,"Mishka is decorating the Christmas tree. He has got three garlands, and all of them will be put on the tree. After that Mishka will switch these garlands on.
When a garland is switched on, it periodically changes its state — sometimes it is lit, sometimes not. Formally, if i-th garland is switched on during x-th second, then it is lit only during seconds x, x + ki, x + 2ki, x + 3ki and so on.
Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland. Formally, Mishka wants to choose three integers x1, x2 and x3 (not necessarily distinct) so that he will switch on the first garland during x1-th second, the second one — during x2-th second, and the third one — during x3-th second, respectively, and during each second starting from max(x1, x2, x3) at least one garland will be lit.
Help Mishka by telling him if it is possible to do this!
The first line contains three integers k1, k2 and k3 (1 ≤ ki ≤ 1500) — time intervals of the garlands.
If Mishka can choose moments of time to switch on the garlands in such a way that each second after switching the garlands on at least one garland will be lit, print YES.
Otherwise, print NO.
","input
In the first example Mishka can choose x1 = 1, x2 = 2, x3 = 1. The first garland will be lit during seconds 1, 3, 5, 7, ..., the second — 2, 4, 6, 8, ..., which already cover all the seconds after the 2-nd one. It doesn't even matter what x3 is chosen. Our choice will lead third to be lit during seconds 1, 4, 7, 10, ..., though.
output
In the second example there is no way to choose such moments of time, there always be some seconds when no garland is lit.
","bruteforce, constructivealgorithms",1
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal
import pprint


def ria():
    return [int(i) for i in input().split()]


if getpass.getuser() != 'frohenk':
    filename = 'half'
    # sys.stdin = open('input.txt')
    # sys.stdout = open('output.txt', 'w')
else:
    sys.stdin = open('input.txt')
    # sys.stdin.close()
# sys.stdout = open('output.txt', 'w')


n = ria()[0]
x, y = ria()
d1 = abs(1 - x) + abs(1 - y)
d2 = abs(n - x) + abs(n - y)
if d1<=d2:
    print('White')
else:
    print('Black')",1075_A,CODEFORCES,563,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
#            print(j,i,accu)            
            effect[j][i] = index


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",1550_E,CODEFORCES,4760,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers",7
"one = list(map(int, input().split()))
two = list(map(int, input().split()))

one_ = sorted([(one[i], one[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))
two_ = sorted([(two[i], two[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))

ones = [one_[0], one_[2], one_[3], one_[1]]
twos = [two_[1], two_[3], two_[2], two_[0]]

L, D, U, R = ones[0][0], ones[0][1], ones[2][1], ones[2][0]


def in_one(point):
    x, y = point

    return L <= x <= R and D <= y <= U


def in_two(point):
    x_0, y_0 = twos[0]

    def U_p(x_):
        return x_ + y_0 - x_0

    def D_m(x_):
        return -x_ + y_0 + x_0

    x_1, y_1 = twos[2]

    def U_m(x_):
        return -x_ + y_1 + x_1

    def D_p(x_):
        return x_ + y_1 - x_1

    x, y = point
    
    return D_m(x) <= y <= U_p(x) and D_p(x) <= y <= U_m(x)


c_one = ((L + R) / 2, (U + D) / 2)
c_two = ((twos[0][0] + twos[2][0]) / 2, (twos[1][1] + twos[3][1]) / 2)

ones.append(c_one)
twos.append(c_two)

for p in ones:
    if in_two(p):
        print('YES')
        exit()

for p in twos:
    if in_one(p):
        print('YES')
        exit()

print('NO')
",0994_C,CODEFORCES,397,Two Squares,"You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.
The interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.
The input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order.
The first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees.
All the values are integer and between $$$-100$$$ and $$$100$$$.
Print ""Yes"" if squares intersect, otherwise print ""No"".
You can print each letter in any case (upper or lower).
In the first example the second square lies entirely within the first square, so they do intersect.
","input
In the second sample squares do not have any points in common.
output
Here are images corresponding to the samples:
",bruteforce,1
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))

cost=[(l[i]+r[i],i) for i in range(n)]

cost.sort()

CANDIES=[None]*n
CANDIES[cost[0][1]]=n

candy=n
for i in range(1,n):
    if cost[i][0]==cost[i-1][0]:
        CANDIES[cost[i][1]]=candy
    else:
        candy-=1
        CANDIES[cost[i][1]]=candy

#print(CANDIES)

check=1    
for i in range(n):
    lc=0
    rc=0
    for j in range(i):
        if CANDIES[j]>CANDIES[i]:
            lc+=1
    for j in range(i+1,n):
        if CANDIES[j]>CANDIES[i]:
            rc+=1

    #print(i,lc,rc)

    if lc!=l[i] or rc!=r[i]:
        check=0

if check==1:
    print(""YES"")
    for c in CANDIES:
        print(c,end="" "")
    #print(CANDIES)
else:
    print(""NO"")
    #print(CANDIES)
          
    
",1054_C,CODEFORCES,3509,Candies Distribution,"There are $$$n$$$ children numbered from $$$1$$$ to $$$n$$$ in a kindergarten. Kindergarten teacher gave $$$a_i$$$ ($$$1 \leq a_i \leq n$$$) candies to the $$$i$$$-th child. Children were seated in a row in order from $$$1$$$ to $$$n$$$ from left to right and started eating candies. 
While the $$$i$$$-th child was eating candies, he calculated two numbers $$$l_i$$$ and $$$r_i$$$ — the number of children seating to the left of him that got more candies than he and the number of children seating to the right of him that got more candies than he, respectively.
Formally, $$$l_i$$$ is the number of indices $$$j$$$ ($$$1 \leq j < i$$$), such that $$$a_i < a_j$$$ and $$$r_i$$$ is the number of indices $$$j$$$ ($$$i < j \leq n$$$), such that $$$a_i < a_j$$$.
Each child told to the kindergarten teacher the numbers $$$l_i$$$ and $$$r_i$$$ that he calculated. Unfortunately, she forgot how many candies she has given to each child. So, she asks you for help: given the arrays $$$l$$$ and $$$r$$$ determine whether she could have given the candies to the children such that all children correctly calculated their values $$$l_i$$$ and $$$r_i$$$, or some of them have definitely made a mistake. If it was possible, find any way how she could have done it.
On the first line there is a single integer $$$n$$$ ($$$1 \leq n \leq 1000$$$) — the number of children in the kindergarten.
On the next line there are $$$n$$$ integers $$$l_1, l_2, \ldots, l_n$$$ ($$$0 \leq l_i \leq n$$$), separated by spaces.
On the next line, there are $$$n$$$ integer numbers $$$r_1, r_2, \ldots, r_n$$$ ($$$0 \leq r_i \leq n$$$), separated by spaces.
If there is no way to distribute the candies to the children so that all of them calculated their numbers correctly, print «NO» (without quotes).
Otherwise, print «YES» (without quotes) on the first line. On the next line, print $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$, separated by spaces — the numbers of candies the children $$$1, 2, \ldots, n$$$ received, respectively. Note that some of these numbers can be equal, but all numbers should satisfy the condition $$$1 \leq a_i \leq n$$$. The number of children seating to the left of the $$$i$$$-th child that got more candies than he should be equal to $$$l_i$$$ and the number of children seating to the right of the $$$i$$$-th child that got more candies than he should be equal to $$$r_i$$$. If there is more than one solution, find any of them.
In the first example, if the teacher distributed $$$1$$$, $$$3$$$, $$$1$$$, $$$2$$$, $$$1$$$ candies to $$$1$$$-st, $$$2$$$-nd, $$$3$$$-rd, $$$4$$$-th, $$$5$$$-th child, respectively, then all the values calculated by the children are correct. For example, the $$$5$$$-th child was given $$$1$$$ candy, to the left of him $$$2$$$ children were given $$$1$$$ candy, $$$1$$$ child was given $$$2$$$ candies and $$$1$$$ child — $$$3$$$ candies, so there are $$$2$$$ children to the left of him that were given more candies than him.
","input
In the second example it is impossible to distribute the candies, because the $$$4$$$-th child made a mistake in calculating the value of $$$r_4$$$, because there are no children to the right of him, so $$$r_4$$$ should be equal to $$$0$$$.
output
In the last example all children may have got the same number of candies, that's why all the numbers are $$$0$$$. Note that each child should receive at least one candy.
","constructivealgorithms, implementation",5
"import sys, string

n, k = map(int, sys.stdin.readline().split())
arr = list(sys.stdin.readline().rstrip())
st = []
ans = []
for i in range(n):
    if k <= 0:
        break
    else:
        if arr[i] == '(':
            st.append((arr[i], i))
        else:
            if st and st[-1][0] == '(':
                k -= 2
                ans.append(st.pop())
                ans.append((arr[i], i))
            else:
                st.append((arr[i], i))

ans.sort(key=lambda x: x[1])
res = []
for i in ans:
    res.append(i[0])
print(''.join(res))",1023_C,CODEFORCES,1864,Bracket Subsequence,"A bracket sequence is a string containing only characters ""("" and "")"". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()()"" and ""(())"" are regular (the resulting expressions are: ""(1)+(1)"" and ""((1+1)+1)""), and "")("", ""("" and "")"" are not.
Subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.
You are given a regular bracket sequence $$$s$$$ and an integer number $$$k$$$. Your task is to find a regular bracket sequence of length exactly $$$k$$$ such that it is also a subsequence of $$$s$$$.
It is guaranteed that such sequence always exists.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \le k \le n \le 2 \cdot 10^5$$$, both $$$n$$$ and $$$k$$$ are even) — the length of $$$s$$$ and the length of the sequence you are asked to find.
The second line is a string $$$s$$$ — regular bracket sequence of length $$$n$$$.
","input
Print a single string — a regular bracket sequence of length exactly $$$k$$$ such that it is also a subsequence of $$$s$$$.
output
It is guaranteed that such sequence always exists.
",greedy,3
"n=int(input())
a=list(map(int,input().split()))
temp=max(a)
if len(set(a))==1 and a[0]==1:
    print(*a[:-1],2)
else:
    a[a.index(temp)]=1
    a.sort()
    print(*a)",0135_A,CODEFORCES,2299,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings",4
"from collections import deque
 
m, k = list(map(int, input().split()))
 
G = [set() for _ in range(m + 1)]
 
q, nq = deque(), deque()
 
for _ in range(m - 1):
    u, v = list(map(int, input().split()))
    G[u].add(v)
    G[v].add(u)
 
for u in range(1, m + 1):
    if len(G[u]) == 1:
        q.append(u)
 
step = 0
removed = 0
ok = True
 
while removed < m - 1:
    each = {}
    for u in q:
        nxt = G[u].pop()
        G[nxt].remove(u)
        each[nxt] = each.get(nxt, 0) + 1
        removed += 1
        if len(G[nxt]) == 0:
            break
        if len(G[nxt]) == 1:
            nq.append(nxt)
    if any(v < 3 for k,v in each.items()):
        ok = False
        break
    q, nq = nq, deque()
    step += 1
 
if ok and step == k and removed == m - 1:
    print('Yes')
else:
    print('No')
",1067_B,CODEFORCES,2871,Multihedgehog,"Someone give a strange birthday present to Ivan. It is hedgehog — connected undirected graph in which one vertex has degree at least $$$3$$$ (we will call it center) and all other vertices has degree 1. Ivan thought that hedgehog is too boring and decided to make himself $$$k$$$-multihedgehog.
Let us define $$$k$$$-multihedgehog as follows:
Thereby $$$k$$$-multihedgehog is a tree. Ivan made $$$k$$$-multihedgehog but he is not sure that he did not make any mistakes. That is why he asked you to check if his tree is indeed $$$k$$$-multihedgehog.
First line of input contains $$$2$$$ integers $$$n$$$, $$$k$$$ ($$$1 \le n \le 10^{5}$$$, $$$1 \le k \le 10^{9}$$$) — number of vertices and hedgehog parameter.
Next $$$n-1$$$ lines contains two integers $$$u$$$ $$$v$$$ ($$$1 \le u, \,\, v \le n; \,\, u \ne v$$$) — indices of vertices connected by edge.
It is guaranteed that given graph is a tree.
Print ""Yes"" (without quotes), if given graph is $$$k$$$-multihedgehog, and ""No"" (without quotes) otherwise.
2-multihedgehog from the first example looks like this:

","input
Its center is vertex $$$13$$$. Hedgehogs created on last step are: [4 (center), 1, 2, 3], [6 (center), 7, 8, 9], [5 (center), 10, 11, 12, 13].
output
Tree from second example is not a hedgehog because degree of center should be at least $$$3$$$.
","dfsandsimilar, graphs, shortestpaths",4
"t = int(input())

for iter in range(t):
    n, k = map(int, input().split())
    if n >= 50:
        if k == 0:
            print(""YES "" + str(n))
        else:
            print(""YES "" + str(n - 1))
    else:
        a = [0] * (n + 1)
        b = [0] * (n + 1)
        c = [0] * (n + 1)
        a[0] = 0
        b[n] = 1
        c[n] = 0

        for i in range(1, n + 1):
            a[i] = 4 * a[i - 1] + 1
        for i in range(n - 1, -1, -1):
            b[i] = b[i + 1] * 2 + 1
        for i in range(n - 1, -1, -1):
            c[i] = c[i + 1] + b[i + 1]

        res = -1
        for d in range(n + 1):
            if c[d] <= k and k <= a[n] - a[d] * b[d]:
                res = d

        if res == -1:
            print(""NO"")
        else:
            print(""YES "" + str(res))
",1080_D,CODEFORCES,1174,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"n = int(input())
a = list(map(int, input().split()))
ans = 0
pos = 2*n - 2
for i in range(n):
	x = a[-1]
	a.pop(-1)
	y = a.index(x)
	ans += pos - y
	pos -= 2
	a.pop(y)
print(ans)
 	 	   			   		  		  	       	",0995_B,CODEFORCES,3325,Suit and Tie,"Allen is hosting a formal dinner party. $$$2n$$$ people come to the event in $$$n$$$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $$$2n$$$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.
Help Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 100$$$), the number of pairs of people.
The second line contains $$$2n$$$ integers $$$a_1, a_2, \dots, a_{2n}$$$. For each $$$i$$$ with $$$1 \le i \le n$$$, $$$i$$$ appears exactly twice. If $$$a_j = a_k = i$$$, that means that the $$$j$$$-th and $$$k$$$-th people in the line form a couple.
Output a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.
","input
In the first sample case, we can transform $$$1 1 2 3 3 2 4 4 \rightarrow 1 1 2 3 2 3 4 4 \rightarrow 1 1 2 2 3 3 4 4$$$ in two steps. Note that the sequence $$$1 1 2 3 3 2 4 4 \rightarrow 1 1 3 2 3 2 4 4 \rightarrow 1 1 3 3 2 2 4 4$$$ also works in the same number of steps.
output
The second sample case already satisfies the constraints; therefore we need $$$0$$$ swaps.
","greedy, implementation, math",5
"def check(s,a):
    st=''
    for i in range(len(s)):
        st+=s[i]
    st=int(st)
    if (st>a):
        return False
    else:
        return True
a = input()
b = input()
s=[]
ans=''
for i in range(len(a)):
    s.append(a[i])
s.sort()
if (len(b)>len(a)):
    for i in range(len(s)):
        print(s[len(s)-i-1],end='')
else:
    for i in range(len(a)):
        j=0
        temp2=-1
        while ((j<len(s)-1) and (s[j+1]<=b[i])):
            j+=1
            if (s[j]!=s[j-1]):
                temp2=j-1    
        temp=s[j]
        s.remove(s[j])
        if (i==len(a)-1 or check(s,int(b[i+1:len(b)])) or temp<b[i]):
            ans+=temp
            if (ans[i]<b[i]):
                for k in range(len(s)):
                    ans+=s[len(s)-k-1]
        else:
            s.append(temp)
            s.sort()
            temp2=s[temp2]
            ans+=temp2
            s.remove(temp2)
            for k in range(len(s)):
                    ans+=s[len(s)-k-1]      
        if (len(ans)==len(a)):
            break          
print(ans)        
            
    
",915C_,CODEFORCES,4210,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"from sys import stdin, stdout, exit

n, m, k = map(int, stdin.readline().split())
a = list(map(int, stdin.readline().split()))

def bf(a):
    best = 0
    best_arg = (-1, -1)
    for i in range(n):
        for j in range(i, n):
            cur = sum(a[i:j+1]) - k*((j - i) // m + 1)
            if cur > best:
                best = max(best, cur)
                best_arg = (i,j)
    return best, best_arg

def max_sum(a):
    if len(a) == 0:
        return 0
    elif len(a) == 1:
        return max(0, a[0] - k)
    mid = len(a) // 2
    l_rec = max_sum(a[:mid])
    r_rec = max_sum(a[mid:])
    l_bests = [0]*m
    r_bests = [0]*m
    l_sum = 0
    for idx in range(1,mid+1):
        l_sum += a[mid-idx]
        if idx % m == 0:
            l_sum -= k
        l_bests[idx%m] = max(l_bests[idx%m], l_sum)
    r_sum = 0
    for idx in range(0, len(a)-mid):
        r_sum += a[idx+mid]
        if (idx+1) % m == 0:
            r_sum -= k
        r_bests[(idx+1)%m] = max(r_bests[(idx+1)%m], r_sum)

 #   print(""Array:"", a, ""mid:"", mid)
#    print(l_bests)
  #  print(r_bests)
    best_acr = 0
    for i in range(m):
        for j in range(m):
            best_acr = max(best_acr, l_bests[i] + r_bests[j] - (k if i+j>0 else 0) - (k if i+j>m else 0))
    ans = max(l_rec,r_rec, best_acr)
   # print(""Answer:"", ans)
    return ans


ans = max_sum(a)
stdout.write(str(ans) + ""\n"")
#stdout.write(str(bf(a))+""\n"")
",1197_D,CODEFORCES,3632,Yet Another Subarray Problem,"You are given an array $$$a_1, a_2, \dots , a_n$$$ and two integers $$$m$$$ and $$$k$$$.
You can choose some subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$. 
The cost of subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$ is equal to $$$\sum\limits_{i=l}^{r} a_i - k \lceil \frac{r - l + 1}{m} \rceil$$$, where $$$\lceil x \rceil$$$ is the least integer greater than or equal to $$$x$$$. 
The cost of empty subarray is equal to zero.
For example, if $$$m = 3$$$, $$$k = 10$$$ and $$$a = [2, -4, 15, -3, 4, 8, 3]$$$, then the cost of some subarrays are:
Your task is to find the maximum cost of some subarray (possibly empty) of array $$$a$$$.
The first line contains three integers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \le n \le 3 \cdot 10^5, 1 \le m \le 10, 1 \le k \le 10^9$$$).
","input
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$).
output
Print the maximum cost of some subarray of array $$$a$$$.
","dp, greedy, math",5
"k, n, s, p = map(int, input().split())
L = (n - 1) // s + 1
L *= k
print((L - 1) // p + 1)",0965_A,CODEFORCES,276,Paper Airplanes,"To make a paper airplane, one has to use a rectangular piece of paper. From a sheet of standard size you can make $$$s$$$ airplanes.
A group of $$$k$$$ people decided to make $$$n$$$ airplanes each. They are going to buy several packs of paper, each of them containing $$$p$$$ sheets, and then distribute the sheets between the people. Each person should have enough sheets to make $$$n$$$ airplanes. How many packs should they buy?
The only line contains four integers $$$k$$$, $$$n$$$, $$$s$$$, $$$p$$$ ($$$1 \le k, n, s, p \le 10^4$$$) — the number of people, the number of airplanes each should make, the number of airplanes that can be made using one sheet and the number of sheets in one pack, respectively.
Print a single integer — the minimum number of packs they should buy.
","input
In the first sample they have to buy $$$4$$$ packs of paper: there will be $$$12$$$ sheets in total, and giving $$$2$$$ sheets to each person is enough to suit everyone's needs.
output
In the second sample they have to buy a pack for each person as they can't share sheets.
",math,1
"l,r = map(int,input().split())
if l%2:
    l+=1
if r-l<2:
    print(-1)
else:
    print(l,l+1,l+2)
",0483_A,CODEFORCES,166,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"# XXXX
leng = 0
s = input()
for i in range(len(s)):
    for j in range(i + 1, len(s) + 1):
        sub = s[i:j]
        if s.count(sub) >= 2 and len(sub) > leng:
            leng = len(sub)
        elif s.count(sub) == 1:
            for k in range(1, len(sub)):
                if s[i - k:j - k] == sub and len(sub) > leng:
                    leng = len(sub)
print(leng)

",0023_A,CODEFORCES,3711,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"n=int(input())
s=list(map(int,input().split()))
c=list(map(int,input().split()))
dp=[float('inf')]*(n)
for i in range(1,n):
    mn=float('inf')
    for j in range(i):
        if s[i]>s[j]:
            mn=min(mn,c[i]+c[j])
    dp[i]=mn
res=float('inf')
for i in range(1,n):
    for j in range(i):
        if s[i]>s[j]:
            res=min(res,c[i]+dp[j])
if res==float('inf'):
    res=-1
print(res)
            
    
    ",0987_C,CODEFORCES,3271,Three displays,"It is the middle of 2018 and Maria Stepanovna, who lives outside Krasnokamensk (a town in Zabaikalsky region), wants to rent three displays to highlight an important problem.
There are $$$n$$$ displays placed along a road, and the $$$i$$$-th of them can display a text with font size $$$s_i$$$ only. Maria Stepanovna wants to rent such three displays with indices $$$i < j < k$$$ that the font size increases if you move along the road in a particular direction. Namely, the condition $$$s_i < s_j < s_k$$$ should be held.
The rent cost is for the $$$i$$$-th display is $$$c_i$$$. Please determine the smallest cost Maria Stepanovna should pay.
The first line contains a single integer $$$n$$$ ($$$3 \le n \le 3\,000$$$) — the number of displays.
The second line contains $$$n$$$ integers $$$s_1, s_2, \ldots, s_n$$$ ($$$1 \le s_i \le 10^9$$$) — the font sizes on the displays in the order they stand along the road.
The third line contains $$$n$$$ integers $$$c_1, c_2, \ldots, c_n$$$ ($$$1 \le c_i \le 10^8$$$) — the rent costs for each display.
If there are no three displays that satisfy the criteria, print -1. Otherwise print a single integer — the minimum total rent cost of three displays with indices $$$i < j < k$$$ such that $$$s_i < s_j < s_k$$$.
","input
In the first example you can, for example, choose displays $$$1$$$, $$$4$$$ and $$$5$$$, because $$$s_1 < s_4 < s_5$$$ ($$$2 < 4 < 10$$$), and the rent cost is $$$40 + 10 + 40 = 90$$$.
output
In the second example you can't select a valid triple of indices, so the answer is -1.
","bruteforce, dp, implementation",5
"import math 

if __name__ == '__main__':
	
	n,q = [int(x) for x in raw_input().split()]
	qq = str(raw_input())
	s = [ int(x) for x in qq] 
	prefix = [0]*n
	prefix[0]= s[0]
	temp = [0]*(n+1)
	temp[0]=1
	mod = (pow(10,9)//1)+7
	for i in range(1,n):
		prefix[i] += prefix[i-1] + s[i]
		temp[i] =( 2*(temp[i-1]%mod) )%mod

	temp[n] = (2*(temp[n-1]%mod))%mod
	ansarr=[]
	while q> 0:
		q-=1
		l,r = [int(x)-1 for x in raw_input().split()]
		a = prefix[r]-prefix[l]+s[l]
		d = r-l+1
		val1 = temp[d] 
		val2 = temp[d-a] 
		# val2 = val2%mod
		ansarr.append((val1-val2)%mod)
	print('\n'.join(map(str, ansarr)))",1062_C,CODEFORCES,1996,Banh-mi,"JATC loves Banh-mi (a Vietnamese food). His affection for Banh-mi is so much that he always has it for breakfast. This morning, as usual, he buys a Banh-mi and decides to enjoy it in a special way.
First, he splits the Banh-mi into $$$n$$$ parts, places them on a row and numbers them from $$$1$$$ through $$$n$$$. For each part $$$i$$$, he defines the deliciousness of the part as $$$x_i \in \{0, 1\}$$$. JATC's going to eat those parts one by one. At each step, he chooses arbitrary remaining part and eats it. Suppose that part is the $$$i$$$-th part then his enjoyment of the Banh-mi will increase by $$$x_i$$$ and the deliciousness of all the remaining parts will also increase by $$$x_i$$$. The initial enjoyment of JATC is equal to $$$0$$$.
For example, suppose the deliciousness of $$$3$$$ parts are $$$[0, 1, 0]$$$. If JATC eats the second part then his enjoyment will become $$$1$$$ and the deliciousness of remaining parts will become $$$[1, \_, 1]$$$. Next, if he eats the first part then his enjoyment will become $$$2$$$ and the remaining parts will become $$$[\_, \_, 2]$$$. After eating the last part, JATC's enjoyment will become $$$4$$$.
However, JATC doesn't want to eat all the parts but to save some for later. He gives you $$$q$$$ queries, each of them consisting of two integers $$$l_i$$$ and $$$r_i$$$. For each query, you have to let him know what is the maximum enjoyment he can get if he eats all the parts with indices in the range $$$[l_i, r_i]$$$ in some order.
All the queries are independent of each other. Since the answer to the query could be very large, print it modulo $$$10^9+7$$$.
The first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \le n, q \le 100\,000$$$).
The second line contains a string of $$$n$$$ characters, each character is either '0' or '1'. The $$$i$$$-th character defines the deliciousness of the $$$i$$$-th part.
Each of the following $$$q$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the segment of the corresponding query.
Print $$$q$$$ lines, where $$$i$$$-th of them contains a single integer — the answer to the $$$i$$$-th query modulo $$$10^9 + 7$$$.
","input
In the first example: 
output
In the second example, any order of eating parts leads to the same answer.
","greedy, implementation, math",3
"from math import sqrt
n,k = map(int, input().split())

ub = k*(k+1)//2 - k+1

if n> ub:
    print(-1)
elif n == ub:
    print(k-1)
elif n == 1:
    print(0)
elif n<=k:
    print(1)
else:
    st = 1
    en = k-1
    target = n-1
    ub = k*(k-1)//2
    p = lambda x: ub - x*(x-1)//2
    ans = -1

    while st <= en:
        md = (st+en)//2
        if p(md) <= target:
            ans = md
            
            en = md-1
        else:
            st = md +1
    
    if p(ans) == target:
        print(k-ans)
    else:
        print(k-ans+1)
",0287_B,CODEFORCES,897,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq
# sys.setrecursionlimit(100000)
# ^^^TAKE CARE FOR MEMORY LIMIT^^^
import random


def main():
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def binary(n):
    return (bin(n).replace(""0b"", """"))


def decimal(s):
    return (int(s, 2))


def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)


def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)


def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)


def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)


def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum


def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m


def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)


def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c


def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p


def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))


def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s
def chk1(i):
    '''
    .
    ..
    '''
    if(i!=n-1 and l1[i]==l2[i]==l2[i+1]==""0""):
        l1[i] = l2[i] = l2[i + 1] = ""X""
        return True
    return False
def chk2(i):
    '''
    ..
    .
    '''
    if(i!=n-1 and l1[i]==l1[i+1]==l2[i]==""0""):
        l1[i] = l1[i + 1] = l2[i] = ""X""
        return True
    return False
def chk3(i):
    if (i != n - 1 and l1[i] == l1[i + 1] == l2[i+1] == ""0""):
        l1[i] = l1[i + 1] = l2[i+1] = ""X""
        return True
    return False
def chk4(i):
    if (i != n - 1 and l2[i+1] == l1[i + 1] == l2[i] == ""0""):
        l1[i] = l1[i + 1] = l2[i] = ""X""
        return True
    return False


def check1(i):
    if (i <= n - 3 and l1[i:i + 3] == l2[i:i + 3] == [""0"",""0"",""0""]):
        for j in range(i,i+3):
            l1[j]=l2[j]=""X""
        return True


def check2(i):
    if(chk1(i) or chk2(i) or chk3(i) or chk4(i)):
        return True
    return False


l1=list(input())
l2=list(input())
#print(l1,l2)
n=len(l1)
i=0
ans=0
while(i<n):
    if(check1(i)):
        #print(i)
        ans+=2
        i+=3
    else:
        if(check2(i)):
            ans+=1
            i+=2
        else:
            i+=1
print(ans)
#print(l1)
#print(l2)",0991_D,CODEFORCES,385,Bishwock,"Bishwock is a chess figure that consists of three squares resembling an ""L-bar"". This figure can be rotated by 90, 180 and 270 degrees so it can have four possible states:
Bishwocks don't attack any squares and can even occupy on the adjacent squares as long as they don't occupy the same square. 
Vasya has a board with $$$2\times n$$$ squares onto which he wants to put some bishwocks. To his dismay, several squares on this board are already occupied by pawns and Vasya can't put bishwocks there. However, pawns also don't attack bishwocks and they can occupy adjacent squares peacefully.
Knowing the positions of pawns on the board, help Vasya to determine the maximum amount of bishwocks he can put onto the board so that they wouldn't occupy the same squares and wouldn't occupy squares with pawns.
","input
The input contains two nonempty strings that describe Vasya's board. Those strings contain only symbols ""0"" (zero) that denote the empty squares and symbols ""X"" (uppercase English letter) that denote the squares occupied by pawns. Strings are nonempty and are of the same length that does not exceed $$$100$$$.
output
Output a single integer — the maximum amount of bishwocks that can be placed onto the given board.
","dp, greedy",1
"n=int(input())
arr=list(map(int,input().split()))
arr=sorted(arr)
if arr[-1]==1:arr[-1]=2
else:arr=[1]+arr[:n-1]
print(*arr)
",0135_A,CODEFORCES,2298,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings",4
"#     Educational Codeforces Round 45 (Rated for Div. 2)
import collections
from functools import cmp_to_key
#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )

import sys
def getIntList():
    return list(map(int, input().split()))    

 
            
    
n,a,b = getIntList()
a0 = a
b0 = b
if a0>b0:
    a0,b0 = b,a
if n==2 and (a0,b0) == (1,1):
    print('NO')
    sys.exit()
if n==3 and (a0,b0) == (1,1):
    print('NO')
    sys.exit()    
if a>1 and b>1:
    print('NO')
    sys.exit()

mat = [['0' for y in range(n)]for x in range(n)]
mat1 = [['1' for y in range(n)]for x in range(n)]
if b==1:
    for x in range(n-a):
        mat[x][x+1] = '1'
        mat[x+1][x] = '1'
else:
    mat = mat1
    for x in range(n):
        mat[x][x] = '0'
    for x in range(n-b):
        mat[x][x+1] = '0'
        mat[x+1][x] = '0'

print('YES')
for x in range(n):
    print(''.join(mat[x]))
",0990_D,CODEFORCES,3278,Graph And Its Complement,"Given three numbers $$$n, a, b$$$. You need to find an adjacency matrix of such an undirected graph that the number of components in it is equal to $$$a$$$, and the number of components in its complement is $$$b$$$. The matrix must be symmetric, and all digits on the main diagonal must be zeroes.
In an undirected graph loops (edges from a vertex to itself) are not allowed. It can be at most one edge between a pair of vertices.
The adjacency matrix of an undirected graph is a square matrix of size $$$n$$$ consisting only of ""0"" and ""1"", where $$$n$$$ is the number of vertices of the graph and the $$$i$$$-th row and the $$$i$$$-th column correspond to the $$$i$$$-th vertex of the graph. The cell $$$(i,j)$$$ of the adjacency matrix contains $$$1$$$ if and only if the $$$i$$$-th and $$$j$$$-th vertices in the graph are connected by an edge.
A connected component is a set of vertices $$$X$$$ such that for every two vertices from this set there exists at least one path in the graph connecting this pair of vertices, but adding any other vertex to $$$X$$$ violates this rule.
The complement or inverse of a graph $$$G$$$ is a graph $$$H$$$ on the same vertices such that two distinct vertices of $$$H$$$ are adjacent if and only if they are not adjacent in $$$G$$$.
In a single line, three numbers are given $$$n, a, b \,(1 \le n \le 1000, 1 \le a, b \le n)$$$: is the number of vertexes of the graph, the required number of connectivity components in it, and the required amount of the connectivity component in it's complement. 
If there is no graph that satisfies these constraints on a single line, print ""NO"" (without quotes).
","input
Otherwise, on the first line, print ""YES""(without quotes). In each of the next $$$n$$$ lines, output $$$n$$$ digits such that $$$j$$$-th digit of $$$i$$$-th line must be $$$1$$$ if and only if there is an edge between vertices $$$i$$$ and $$$j$$$ in $$$G$$$ (and $$$0$$$ otherwise). Note that the matrix must be symmetric, and all digits on the main diagonal must be zeroes. 
output
If there are several matrices that satisfy the conditions — output any of them.
","constructivealgorithms, graphs, implementation",5
"s = input()
n = len(s)

for L in range(n-1, 0, -1):
    if len({s[i:i+L] for i in range(n-L+1)}) < n-L+1:
        print(L)
        break
else:
    print(0)",0023_A,CODEFORCES,3734,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"from queue import Queue
import datetime

with open(""input.txt"", 'r') as in_file:
    n, m = (int(i) for i in in_file.readline().split("" ""))
    k = int(in_file.readline())
    ints = [int(i) for i in in_file.readline().split("" "")]

pairs = []
for i in range(0, len(ints), 2):
    x = ints[i]
    y = ints[i+1]
    pairs.append((x, y))


last_tree = (1, 1)
maxd = 0
mult = m * n
for i in range(1, n+1):
    for j in range(1, m+1):
        md = mult
        # print(""par"", i, j)
        for pair in pairs:
            x, y = pair
            d = abs(i-x)+abs(j-y)
            # print(""punto"", x, y)
            # print(""distancia"", d)
            md = min(md, d)
            # print(""min"", md)
        if md > maxd:
            # print(""max"", md)
            last_tree = (i, j)
            maxd = md
        # print("""")

# print(""res"", last_tree)
with open(""output.txt"", 'w') as out_file:
    out_file.write(f""{last_tree[0]} {last_tree[1]}"")

	 		 	 			  		 		         		  	",0035_C,CODEFORCES,3764,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"n, m = map(int, input().split())
boys = list(map(int, input().split()))
girls = list(map(int, input().split()))
boys.sort(reverse=True)
girls.sort(reverse=True)
s = sum(boys)
ma = max(boys)
#print(s, m)
res = 0
for i in range(0, m):
    #print(girls[i])
    if girls[i] < ma:
        print(-1)
        exit(0)
    res += s
    if (girls[i] == ma):
        girls[i] = 0
j = 0
usage = 0
for i in range(0, m):
    if (usage == m - 1):
        j += 1
    if (j >= n):
        print(-1)
        exit(0)
  #  girls[i] -= max(0, boys[j])
    res += max(0, girls[i] - boys[j])
    usage += 1
print(res)",1159_C,CODEFORCES,2928,The Party and Sweets,"$$$n$$$ boys and $$$m$$$ girls came to the party. Each boy presented each girl some integer number of sweets (possibly zero). All boys are numbered with integers from $$$1$$$ to $$$n$$$ and all girls are numbered with integers from $$$1$$$ to $$$m$$$. For all $$$1 \leq i \leq n$$$ the minimal number of sweets, which $$$i$$$-th boy presented to some girl is equal to $$$b_i$$$ and for all $$$1 \leq j \leq m$$$ the maximal number of sweets, which $$$j$$$-th girl received from some boy is equal to $$$g_j$$$.
More formally, let $$$a_{i,j}$$$ be the number of sweets which the $$$i$$$-th boy give to the $$$j$$$-th girl. Then $$$b_i$$$ is equal exactly to the minimum among values $$$a_{i,1}, a_{i,2}, \ldots, a_{i,m}$$$ and $$$g_j$$$ is equal exactly to the maximum among values $$$b_{1,j}, b_{2,j}, \ldots, b_{n,j}$$$.
You are interested in the minimum total number of sweets that boys could present, so you need to minimize the sum of $$$a_{i,j}$$$ for all $$$(i,j)$$$ such that $$$1 \leq i \leq n$$$ and $$$1 \leq j \leq m$$$. You are given the numbers $$$b_1, \ldots, b_n$$$ and $$$g_1, \ldots, g_m$$$, determine this number. 
The first line contains two integers $$$n$$$ and $$$m$$$, separated with space — the number of boys and girls, respectively ($$$2 \leq n, m \leq 100\,000$$$). The second line contains $$$n$$$ integers $$$b_1, \ldots, b_n$$$, separated by spaces — $$$b_i$$$ is equal to the minimal number of sweets, which $$$i$$$-th boy presented to some girl ($$$0 \leq b_i \leq 10^8$$$). The third line contains $$$m$$$ integers $$$g_1, \ldots, g_m$$$, separated by spaces — $$$g_j$$$ is equal to the maximal number of sweets, which $$$j$$$-th girl received from some boy ($$$0 \leq g_j \leq 10^8$$$).
If the described situation is impossible, print $$$-1$$$. In another case, print the minimal total number of sweets, which boys could have presented and all conditions could have satisfied.
In the first test, the minimal total number of sweets, which boys could have presented is equal to $$$12$$$. This can be possible, for example, if the first boy presented $$$1$$$ and $$$4$$$ sweets, the second boy presented $$$3$$$ and $$$2$$$ sweets and the third boy presented $$$1$$$ and $$$1$$$ sweets for the first and the second girl, respectively. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$12$$$.
","input
In the second test, the boys couldn't have presented sweets in such way, that all statements satisfied.
output
In the third test, the minimal total number of sweets, which boys could have presented is equal to $$$4$$$. This can be possible, for example, if the first boy presented $$$1$$$, $$$1$$$, $$$2$$$ sweets for the first, second, third girl, respectively and the second boy didn't present sweets for each girl. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$4$$$.
","greedy, implementation, math",4
"from math import *
a, vm = map(int, input().split())
l, d, vd = map(int, input().split())
if vm <= vd or sqrt(2 * a * d) <= vd:
    if vm ** 2 / (2 * a) >= l:
        ans = sqrt(2 * l / a)
    else:
        ans = vm / a + (l - vm ** 2 / (2 * a)) / vm
else:
    s1 = (vm ** 2 - vd ** 2) / (2 * a)
    if s1 >= (l - d):
        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a)
    else:
        ans = (vm - vd) / a + (l - d - s1) / vm
    v1 = sqrt((2 * a * d + vd ** 2) / 2)
    if v1 <= vm:
        ans = ans + v1 / a + (v1 - vd) / a
    else:
        s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a)
        ans = ans + vm / a + (vm - vd) / a + s1 / vm
print('%.12f' % ans)
",0005_D,CODEFORCES,1,Follow Traffic Rules,"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.
It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km/h2, and has maximum speed of v km/h. The road has the length of l km, and the speed sign, limiting the speed to w km/h, is placed d km (1 ≤ d < l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.
The car can enter Bercouver at any speed.
","input
The first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).
output
Print the answer with at least five digits after the decimal point.
","implementation, math",1
"n=int(input())
n+=1

if n%2==0 or n==1:
	print(n//2)
else:
	print(n)",0979_A,CODEFORCES,330,"Pizza, Pizza, Pizza!!!","Katie, Kuro and Shiro are best friends. They have known each other since kindergarten. That's why they often share everything with each other and work together on some very hard problems.
Today is Shiro's birthday. She really loves pizza so she wants to invite her friends to the pizza restaurant near her house to celebrate her birthday, including her best friends Katie and Kuro.
She has ordered a very big round pizza, in order to serve her many friends. Exactly $$$n$$$ of Shiro's friends are here. That's why she has to divide the pizza into $$$n + 1$$$ slices (Shiro also needs to eat). She wants the slices to be exactly the same size and shape. If not, some of her friends will get mad and go home early, and the party will be over.
Shiro is now hungry. She wants to cut the pizza with minimum of straight cuts. A cut is a straight segment, it might have ends inside or outside the pizza. But she is too lazy to pick up the calculator.
As usual, she will ask Katie and Kuro for help. But they haven't come yet. Could you help Shiro with this problem?
A single line contains one non-negative integer $$$n$$$ ($$$0 \le n \leq 10^{18}$$$) — the number of Shiro's friends. The circular pizza has to be sliced into $$$n + 1$$$ pieces.
A single integer — the number of straight cuts Shiro needs.
","input
To cut the round pizza into quarters one has to make two cuts through the center with angle $$$90^{\circ}$$$ between them.
output
To cut the round pizza into five equal parts one has to make five cuts.
",math,1
"n=int(input())
s=[c=='1' for c in input()]
m=len(s)
z=[[0,0]]
for c in s:
 ind = z[-1][c]
 z[-1][c] = len(z)
 z.append(z[ind][:])
assert(len(z) == m+1)
z[m][0] = z[m][1] = m # make it sticky

# how many things match directly
dp = [0 for _ in range(m+1)]
dp[0] = 1
for i in range(n):
 ndp = [0 for _ in range(m+1)]
 for i in range(m+1):
  ndp[z[i][0]] += dp[i]
  ndp[z[i][1]] += dp[i]
 dp = ndp
res = dp[m]

for k in range(1, m):
 s0 = 0
 for c in s[-k:]:
  s0 = z[s0][c]
 dp = [0 for _ in range(m+1)]
 dp[s0] = 1
 for i in range(n - k):
  ndp = [0 for _ in range(m+1)]
  for i in range(m+1):
   ndp[z[i][0]] += dp[i]
   ndp[z[i][1]] += dp[i]
  dp = ndp
 for s1 in range(m): # skip m
  v = dp[s1]
  for c in s[-k:]:
   if s1 == m: v = 0
   s1 = z[s1][c]
  if s1 == m: res += v
print(res)",1038_F,CODEFORCES,4557,Wrap Around,"You are given a binary string $$$s$$$.
Find the number of distinct cyclical binary strings of length $$$n$$$ which contain $$$s$$$ as a substring.
The cyclical string $$$t$$$ contains $$$s$$$ as a substring if there is some cyclical shift of string $$$t$$$, such that $$$s$$$ is a substring of this cyclical shift of $$$t$$$.
For example, the cyclical string ""000111"" contains substrings ""001"", ""01110"" and ""10"", but doesn't contain ""0110"" and ""10110"".
Two cyclical strings are called different if they differ from each other as strings. For example, two different strings, which differ from each other by a cyclical shift, are still considered different cyclical strings.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 40$$$) — the length of the target string $$$t$$$.
The next line contains the string $$$s$$$ ($$$1 \le |s| \le n$$$) — the string which must be a substring of cyclical string $$$t$$$. String $$$s$$$ contains only characters '0' and '1'.
Print the only integer — the number of distinct cyclical binary strings $$$t$$$, which contain $$$s$$$ as a substring.
","input
In the first example, there are three cyclical strings, which contain ""0"" — ""00"", ""01"" and ""10"".
output
In the second example, there are only two such strings — ""1010"", ""0101"".
","dp, strings",7
"import sys
input=sys.stdin.readline
def fun(k):
    global li,t
    tem=[]
    count=0
    for i in li:
        if(i[0]>=k):
            tem.append(i)
            count+=1
    if(count>=k):
        ans=0
        for i in range(k):
            ans+=tem[i][1]
        if(ans<=t):
            return True
        else:
            return False
    else:
        return False
                  
n,t=map(int,input().split())
li=[]
for _ in range(n):
    li.append(list(map(int,input().split()))+[_])
li.sort(key=lambda x:x[1])
l=0
r=n
while(r-l>1):
    mid=(l+r)//2
    if(fun(mid)):
        l=mid
    else:
        r=mid
fin=0
for i in range(l,r+1):
    if(fun(i)):
        fin=i
print(fin)
print(fin)
tem=[]
for i in range(n):
    if(li[i][0]>=fin):
        tem.append(li[i][2]+1)
print(*tem[:fin])",0913_D,CODEFORCES,2465,Too Easy Problems,"You are preparing for an exam on scheduling theory. The exam will last for exactly T milliseconds and will consist of n problems. You can either solve problem i in exactly ti milliseconds or ignore it and spend no time. You don't need time to rest after solving a problem, either.
Unfortunately, your teacher considers some of the problems too easy for you. Thus, he assigned an integer ai to every problem i meaning that the problem i can bring you a point to the final score only in case you have solved no more than ai problems overall (including problem i).
Formally, suppose you solve problems p1, p2, ..., pk during the exam. Then, your final score s will be equal to the number of values of j between 1 and k such that k ≤ apj.
You have guessed that the real first problem of the exam is already in front of you. Therefore, you want to choose a set of problems to solve during the exam maximizing your final score in advance. Don't forget that the exam is limited in time, and you must have enough time to solve all chosen problems. If there exist different sets of problems leading to the maximum final score, any of them will do.
The first line contains two integers n and T (1 ≤ n ≤ 2·105; 1 ≤ T ≤ 109) — the number of problems in the exam and the length of the exam in milliseconds, respectively.
Each of the next n lines contains two integers ai and ti (1 ≤ ai ≤ n; 1 ≤ ti ≤ 104). The problems are numbered from 1 to n.
In the first line, output a single integer s — your maximum possible final score.
In the second line, output a single integer k (0 ≤ k ≤ n) — the number of problems you should solve.
In the third line, output k distinct integers p1, p2, ..., pk (1 ≤ pi ≤ n) — the indexes of problems you should solve, in any order.
If there are several optimal sets of problems, you may output any of them.
In the first example, you should solve problems 3, 1, and 4. In this case you'll spend 80 + 100 + 90 = 270 milliseconds, falling within the length of the exam, 300 milliseconds (and even leaving yourself 30 milliseconds to have a rest). Problems 3 and 1 will bring you a point each, while problem 4 won't. You'll score two points.
","input
In the second example, the length of the exam is catastrophically not enough to solve even a single problem.
output
In the third example, you have just enough time to solve both problems in 42 + 58 = 100 milliseconds and hand your solutions to the teacher with a smile.
","binarysearch, bruteforce, datastructures, greedy, sortings",4
"N, M, K, L = map(int, input().split())
if N < M or K + L > N:
    print(-1)
else:
    print((L + K - 1) // M + 1 if ((L + K - 1) // M + 1) * M <= N else -1)",1068_A,CODEFORCES,540,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math,1
"n=int(input())
x,y=map(int,input().split())
val1=max(x,y)-1
val2=n-min(x,y)
if(val1<=val2):
    print('White')
else:
    print('Black')",1075_A,CODEFORCES,566,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"from math import gcd
n, x, y = map(int, input().split())

def solve(n, x, y):
    g = gcd(x, y)
    if gcd(x, y) != 1:
        return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g)
    ans = 0
    for s in [0, 1]:
        dp = [-n, -n]
        dp[s] = 0
        for i in range(x + y):
            dp = [max(dp[0], dp[1]), dp[0] + (n // (x + y)) + (i * x % (x + y) < n % (x + y))]
        ans = max(ans, dp[s])
    return ans
    
print(solve(n, x, y))",1463_F,CODEFORCES,4705,Max Correct Set,"Let's call the set of positive integers $$$S$$$ correct if the following two conditions are met: 
For the given values $$$n$$$, $$$x$$$, and $$$y$$$, you have to find the maximum size of the correct set.
","input
A single line contains three integers $$$n$$$, $$$x$$$ and $$$y$$$ ($$$1 \le n \le 10^9$$$; $$$1 \le x, y \le 22$$$). 
output
Print one integer — the maximum size of the correct set.
","bitmasks, dp, math",7
"n, k = map(int, input().split())
lst = []
for i in range(n):
    a, b = map(int, input().split())
    lst.append([-a, b])
lst.sort()
print(lst.count(lst[k-1]))",0166_A,CODEFORCES,2330,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"import sys


n, k = [int(i) for i in sys.stdin.readline().split()]


left = 0
right = n - 1

while left <=  right:
    mid = left + (right - left)//2
    fmid = (mid+1)*(mid +2)/2  - (n  - (mid + 1))
    if fmid == k:

        print(n - 1 - mid )
    if fmid > k:
        right = mid - 1
    else: # less or equal
        left = mid + 1






",1195_B,CODEFORCES,1384,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"n,k = map(int,input().split())
mod = 998244353
dp = [[[0,0]for j in range(2*n+1)] for i in range(n)]
dp[0][0][0] = dp[0][1][1] = 1
for i in range(1,n):
  for j in range(2*n-1):
    dp[i][j][0] +=  (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][1]) %mod
    dp[i][j+1][0] += dp[i-1][j][0] % mod
    dp[i][j+1][1] += (dp[i-1][j][0] + dp[i-1][j][0])%mod
    dp[i][j][1] += dp[i-1][j][1] %mod
    dp[i][j+2][1] += dp[i-1][j][1] %mod
print(sum(dp[n-1][k-1])*2%mod)",1051_D,CODEFORCES,4568,Bicolorings,"You are given a grid, consisting of $$$2$$$ rows and $$$n$$$ columns. Each cell of this grid should be colored either black or white.
Two cells are considered neighbours if they have a common border and share the same color. Two cells $$$A$$$ and $$$B$$$ belong to the same component if they are neighbours, or if there is a neighbour of $$$A$$$ that belongs to the same component with $$$B$$$.
Let's call some bicoloring beautiful if it has exactly $$$k$$$ components.
Count the number of beautiful bicolorings. The number can be big enough, so print the answer modulo $$$998244353$$$.
The only line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 1000$$$, $$$1 \le k \le 2n$$$) — the number of columns in a grid and the number of components required.
","input
Print a single integer — the number of beautiful bicolorings modulo $$$998244353$$$.
output
One of possible bicolorings in sample $$$1$$$:
","bitmasks, dp",7
"def m():
	[x, y, k] = [int(i) for i in input().split()]
	d=min(x, y)
	x-=d
	y-=d
	k-=d
	
	if k-x-y<0:
		print(-1)
	else:
		x+=y
		if x%2 > 0 and k%2>0:
			print(d+k-1)
		elif x%2 >0:
			print(d+k-1)
		elif k%2>0:
			print(d+k-2)
		else:
			print(d+k)
			
		
			
	
n=int(input())
for i in range(n):
	m()",1036_B,CODEFORCES,489,Diagonal Walking v,"Mikhail walks on a Cartesian plane. He starts at the point $$$(0, 0)$$$, and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $$$(0, 0)$$$, he can go to any of the following points in one move: 
If Mikhail goes from the point $$$(x1, y1)$$$ to the point $$$(x2, y2)$$$ in one move, and $$$x1 \ne x2$$$ and $$$y1 \ne y2$$$, then such a move is called a diagonal move.
Mikhail has $$$q$$$ queries. For the $$$i$$$-th query Mikhail's target is to go to the point $$$(n_i, m_i)$$$ from the point $$$(0, 0)$$$ in exactly $$$k_i$$$ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in $$$k_i$$$ moves.
Note that Mikhail can visit any point any number of times (even the destination point!).
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 10^4$$$) — the number of queries.
Then $$$q$$$ lines follow. The $$$i$$$-th of these $$$q$$$ lines contains three integers $$$n_i$$$, $$$m_i$$$ and $$$k_i$$$ ($$$1 \le n_i, m_i, k_i \le 10^{18}$$$) — $$$x$$$-coordinate of the destination point of the query, $$$y$$$-coordinate of the destination point of the query and the number of moves in the query, correspondingly.
Print $$$q$$$ integers. The $$$i$$$-th integer should be equal to -1 if Mikhail cannot go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in exactly $$$k_i$$$ moves described above. Otherwise the $$$i$$$-th integer should be equal to the the maximum number of diagonal moves among all possible movements.
One of the possible answers to the first test case: $$$(0, 0) \to (1, 0) \to (1, 1) \to (2, 2)$$$.
","input
One of the possible answers to the second test case: $$$(0, 0) \to (0, 1) \to (1, 2) \to (0, 3) \to (1, 4) \to (2, 3) \to (3, 2) \to (4, 3)$$$.
output
In the third test case Mikhail cannot reach the point $$$(10, 1)$$$ in 9 moves.
",math,1
"n=int(input())
c=[0]*4
for k in range(4):
 for i in range(n):
  s=input()
  for j in range(n):
   if(i+j)%2!=int(s[j]):c[k]+=1
 if k<3:input()
c.sort()
print(c[0]+c[1]+2*n*n-c[2]-c[3])
",0961_C,CODEFORCES,3182,Chessboard,"Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into 4 pieces, each of size n by n, n is always odd. And what's even worse, some squares were of wrong color. j-th square of the i-th row of k-th piece of the board has color ak, i, j; 1 being black and 0 being white. 
Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be 2n by 2n. You are allowed to move pieces but not allowed to rotate or flip them.
The first line contains odd integer n (1 ≤ n ≤ 100) — the size of all pieces of the board. 
","input
Then 4 segments follow, each describes one piece of the board. Each consists of n lines of n characters; j-th one of i-th line is equal to 1 if the square is black initially and 0 otherwise. Segments are separated by an empty line.
output
Print one number — minimum number of squares Magnus should recolor to be able to obtain a valid chessboard.
","bitmasks, bruteforce, implementation",5
"import sys
from collections import deque
#from functools import *
#from fractions import Fraction as f
from copy import *
from bisect import *	
#from heapq import *
from math import gcd,ceil,sqrt
from itertools import permutations as prm,product
 
def eprint(*args):
    print(*args, file=sys.stderr)
zz=1
 
#sys.setrecursionlimit(10**6)
if zz:
	input=sys.stdin.readline
else:	
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('all.txt','w')
di=[[-1,0],[1,0],[0,1],[0,-1]]

def string(s):
	return """".join(s)
def fori(n):
	return [fi() for i in range(n)]	
def inc(d,c,x=1):
	d[c]=d[c]+x if c in d else x
def bo(i):
	return ord(i)-ord('A')	
def li():
	return [int(xx) for xx in input().split()]
def fli():
	return [float(x) for x in input().split()]	
def comp(a,b):
	if(a>b):
		return 2
	return 2 if a==b else 0		
def gi():	
	return [xx for xx in input().split()]
def gtc(tc,ans):
	print(""Case #""+str(tc)+"":"",ans)	
def cil(n,m):
	return n//m+int(n%m>0)	
def fi():
	return int(input())
def pro(a): 
	return reduce(lambda a,b:a*b,a)		
def swap(a,i,j): 
	a[i],a[j]=a[j],a[i]	
def si():
	return list(input().rstrip())	
def mi():
	return 	map(int,input().split())			
def gh():
	sys.stdout.flush()
def isvalid(i,j,n,m):
	return 0<=i<n and 0<=j<m 
def bo(i):
	return ord(i)-ord('a')	
def graph(n,m):
	for i in range(m):
		x,y=mi()
		a[x].append(y)
		a[y].append(x)


t=1

while t>0:
	t-=1
	l,r=mi()	
	if len(bin(l))<len(bin(r)):
		print(2**len(bin(r)[2:])-1)
	else:
		p=bin(l)[2:]
		q=bin(r)[2:]
		r=0
		for i in range(len(q)):
			if p[i]!=q[i]:
				r=len(p)-i
				break
		print(2**r-1)		





",0276_D,CODEFORCES,886,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"x=input();l=len(x);m=0
for i in range(l-1):
    f=i
    while 1 : 
        idx = x[f+1:].find(x[f])         
        if idx == -1 :
            break
        else:
            idx += f+1 ; c=ans=0
            for j in range(idx , l) :
               if x[j] == x[i+c]:
                    ans+=1
                    c+=1  
               else:
                   break
               
            if m < ans :
                m=ans
            f = idx              
print(m)

 				         			 	 						   		",0023_A,CODEFORCES,3747,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"from math import *
a,v=list(map(int,input().split()))
l,d,w=list(map(int,input().split()))
if v>w:
    s1=w**2/2/a
    if d<=s1:
        s=min(v**2/2/a,l)
        t=sqrt(2*s/a)+(l-s)/v
    else:
        t=sqrt(2*s1/a)
        s2=min((d-s1)/2,(v**2-w**2)/(2*a))
        if s2==(d-s1)/2:
            t+=2*(sqrt(2*(s1+s2)/a)-sqrt(2*s1/a))
        else:
            t+=2*(v-w)/a+(d-s1-2*s2)/v
        s3=min((v**2-w**2)/2/a,l-d)
        t+=sqrt(2*(s3+s1)/a)-sqrt(2*s1/a)+(l-d-s3)/v
else:
    s=min(v**2/2/a,l)
    t=sqrt(2*s/a)+(l-s)/v
print(t)",0005_D,CODEFORCES,4,Follow Traffic Rules,"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.
It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km/h2, and has maximum speed of v km/h. The road has the length of l km, and the speed sign, limiting the speed to w km/h, is placed d km (1 ≤ d < l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.
The car can enter Bercouver at any speed.
","input
The first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).
output
Print the answer with at least five digits after the decimal point.
","implementation, math",1
"import io,os,bisect;input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline;prime = [2]
for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue 
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0: flag = True;break
    if not flag:  prime.append(i)
def primefactor(num):
    index = 0;output = []
    while num>=prime[index]**2:
        times = 0
        while num%prime[index]==0:num = num // prime[index];times += 1
        if times&1:  output.append(prime[index])
        index += 1 
    if num>1: output.append(num)
    return tuple(output)
for _ in range(int(input())):
    n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:            bisect.insort(stack,fact[factor]+1)            
        fact[factor] = i
        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]
    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1)
    print(dp[-1][-1])   ",1497_E2,CODEFORCES,4023,Square-Free Division (hard version),"This is the hard version of the problem. The only difference is that in this version $$$0 \leq k \leq 20$$$.
There is an array $$$a_1, a_2, \ldots, a_n$$$ of $$$n$$$ positive integers. You should divide it into a minimal number of continuous segments, such that in each segment there are no two numbers (on different positions), whose product is a perfect square.
Moreover, it is allowed to do at most $$$k$$$ such operations before the division: choose a number in the array and change its value to any positive integer.
What is the minimum number of continuous segments you should use if you will make changes optimally?
The first line contains a single integer $$$t$$$ $$$(1 \le t \le 1000)$$$  — the number of test cases.
The first line of each test case contains two integers $$$n$$$, $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$0 \leq k \leq 20$$$).
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 10^7$$$).
It's guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \cdot 10^5$$$.
For each test case print a single integer  — the answer to the problem.
","input
In the first test case it is possible to change the array this way: $$$[\underline{3}, 6, 2, 4, \underline{5}]$$$ (changed elements are underlined). After that the array does not need to be divided, so the answer is $$$1$$$.
output
In the second test case it is possible to change the array this way: $$$[6, 2, \underline{3}, 8, 9, \underline{5}, 3, 6, \underline{10}, \underline{11}, 7]$$$. After that such division is optimal: 
","datastructures, dp, greedy, math, numbertheory, twopointers",6
"import sys;input = sys.stdin.readline
def topological_sorted(digraph):
    n = len(digraph);indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:indegree[nxt_v] += 1
    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)

    return len(tp_order) == n, tp_order
n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {}
for idx, ptn in enumerate(p):
    val = 0
    for i in range(k):
        if ptn[i] != ""_"":val += (ord(ptn[i]) - 96) * (27 ** i)
    memo[val] = idx

for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)

graph = [[] for i in range(n)]
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:
        print(""NO"")
        exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:print(""YES"");print(*[i + 1 for i in res])
else:print(""NO"")",1476_E,CODEFORCES,4729,Pattern Matching,"You are given $$$n$$$ patterns $$$p_1, p_2, \dots, p_n$$$ and $$$m$$$ strings $$$s_1, s_2, \dots, s_m$$$. Each pattern $$$p_i$$$ consists of $$$k$$$ characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string $$$s_j$$$ consists of $$$k$$$ lowercase Latin letters.
A string $$$a$$$ matches a pattern $$$b$$$ if for each $$$i$$$ from $$$1$$$ to $$$k$$$ either $$$b_i$$$ is a wildcard character or $$$b_i=a_i$$$.
You are asked to rearrange the patterns in such a way that the first pattern the $$$j$$$-th string matches is $$$p[mt_j]$$$. You are allowed to leave the order of the patterns unchanged.
Can you perform such a rearrangement? If you can, then print any valid order.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \le n, m \le 10^5$$$, $$$1 \le k \le 4$$$) — the number of patterns, the number of strings and the length of each pattern and string.
Each of the next $$$n$$$ lines contains a pattern — $$$k$$$ characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct.
Each of the next $$$m$$$ lines contains a string — $$$k$$$ lowercase Latin letters, and an integer $$$mt$$$ ($$$1 \le mt \le n$$$) — the index of the first pattern the corresponding string should match.
Print ""NO"" if there is no way to rearrange the patterns in such a way that the first pattern that the $$$j$$$-th string matches is $$$p[mt_j]$$$.
Otherwise, print ""YES"" in the first line. The second line should contain $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ — the order of the patterns. If there are multiple answers, print any of them.
The order of patterns after the rearrangement in the first example is the following: 
Thus, the first string matches patterns ab__, _bcd, _b_d in that order, the first of them is ab__, that is indeed $$$p[4]$$$. The second string matches __b_ and ab__, the first of them is __b_, that is $$$p[2]$$$. The last string matches _bcd and _b_d, the first of them is _bcd, that is $$$p[5]$$$.
The answer to that test is not unique, other valid orders also exist.
","input
In the second example cba doesn't match __c, thus, no valid order exists.
output
In the third example the order (a_, _b) makes both strings match pattern $$$1$$$ first and the order (_b, a_) makes both strings match pattern $$$2$$$ first. Thus, there is no order that produces the result $$$1$$$ and $$$2$$$.
","bitmasks, datastructures, dfsandsimilar, graphs, hashing, sortings, strings",7
"from collections import defaultdict


def main():
    R, G, B = map(int, input().split())
    red = list(map(int, input().split()))
    green = list(map(int, input().split()))
    blue = list(map(int, input().split()))
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    dp = [[[-2*10**9]*(B+10) for i in range(G+10)] for j in range(R+10)]
    dp[0][0][0] = 0
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+red[i-1]*green[j-1], dp[i]
                                  [j-1][k-1]+green[j-1]*blue[k-1], dp[i-1][j][k-1]+red[i-1]*blue[k-1])
                ans = max(ans, dp[i][j][k])
    print(ans)
    return


if __name__ == ""__main__"":
    main()


",1398_D,CODEFORCES,4006,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"d = {
    ""purple"": ""Power"",
    ""green"": ""Time"",
    ""blue"": ""Space"",
    ""orange"": ""Soul"",
    ""red"": ""Reality"",
    ""yellow"": ""Mind"",
}

all_colors = list(d.keys())

n = int(input())
colors = [input() for i in range(n)]

print(len(d) - len(colors))
for color in all_colors:
    if color not in colors:
        print(d[color])
",0987_A,CODEFORCES,343,Infinity Gauntlet,"You took a peek on Thanos wearing Infinity Gauntlet. In the Gauntlet there is a place for six Infinity Gems:
Using colors of Gems you saw in the Gauntlet determine the names of absent Gems.
In the first line of input there is one integer $$$n$$$ ($$$0 \le n \le 6$$$) — the number of Gems in Infinity Gauntlet.
In next $$$n$$$ lines there are colors of Gems you saw. Words used for colors are: purple, green, blue, orange, red, yellow. It is guaranteed that all the colors are distinct. All colors are given in lowercase English letters.
In the first line output one integer $$$m$$$ ($$$0 \le m \le 6$$$) — the number of absent Gems.
Then in $$$m$$$ lines print the names of absent Gems, each on its own line. Words used for names are: Power, Time, Space, Soul, Reality, Mind. Names can be printed in any order. Keep the first letter uppercase, others lowercase.
","input
In the first sample Thanos already has Reality, Power, Mind and Soul Gems, so he needs two more: Time and Space.
output
In the second sample Thanos doesn't have any Gems, so he needs all six.
",implementation,1
"n = int(input())
arr = list(map(int,input().strip().split()))[:n]


new = sorted(arr)
count = 0

for i in range(n):
    if arr[i] != new[i]:
        count += 1

if count <= 2:
    print('YES')
else:
    print('NO')
",0220_A,CODEFORCES,2362,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"def pow(n):
    if(n > 0):
        if(n % 2 == 0):
            x = pow(n // 2) % 1000000007
            return (x * x) % 1000000007
        else: return (pow(n - 1) * 2)% 1000000007
    else:
        return 1

n, k = map(int, input().split())
if(n == 0): print(0)
else: print((pow(k) * (2 * n - 1) + 1) % 1000000007)
",0992_C,CODEFORCES,1055,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"print(int(input())//2 + 1)
",0964_A,CODEFORCES,273,Splits,"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. 
For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.
The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.
The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.
For a given $$$n$$$, find out the number of different weights of its splits.
The first line contains one integer $$$n$$$ ($$$1 \leq n \leq 10^9$$$).
Output one integer — the answer to the problem.
In the first sample, there are following possible weights of splits of $$$7$$$:
Weight 1: [$$$\textbf 7$$$] 
Weight 2: [$$$\textbf 3$$$, $$$\textbf 3$$$, 1] 
","input
Weight 3: [$$$\textbf 2$$$, $$$\textbf 2$$$, $$$\textbf 2$$$, 1] 
output
Weight 7: [$$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$]
",math,1
"
def combine(n, k, w=1, out=[], result=[]):
    if k == 0:
        result.append(out)

    for i in range(w, n + 1):
        new_out = out[:]
        new_out.append(i)
        combine(n, k-1, i+1, new_out)

    return result


def main():

    n, l, r, x = [int(i) for i in input().split()]
    c = [int(i) for i in input().split()]

    if n < 2:
        print(0)
        return

    result = None
    for i in range(2, n + 1):
        if i == n:
            result = combine(n, i)
        else:
            combine(n, i)

    for i in range(len(result)):
        comb = result[i]
        for j in range(len(comb)):
            comb[j] = c[comb[j] - 1]

    cnt = 0
    for i in range(len(result)):
        sm = sum(result[i])
        if sm >= l and sm <= r and (max(result[i]) - min(result[i]) >= x):
            cnt += 1

    print(cnt)



if __name__ == '__main__':
    main()


",0550_B,CODEFORCES,4435,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"import math

v = [int(x) for x in input().split()]
n = len(v)
val = 0
for i in range(n):
    a = v[i] // n
    arr = v.copy()
    arr[i] = 0
    for j in range(n):
        arr[j] += a
    b = v[i] % n
    k = i + 1
    l = 0
    while l < b:
        if k > n - 1:
            k = 0
        arr[k] += 1
        k += 1
        l += 1

    count = 0
    for j in range(n):
        if arr[j] % 2 == 0:
            count += arr[j]
    val = max(val, count)
print(val)





",0975_B,CODEFORCES,308,Mancala,"Mancala is a game famous in the Middle East. It is played on a board that consists of 14 holes. 
Initially, each hole has $$$a_i$$$ stones. When a player makes a move, he chooses a hole which contains a positive number of stones. He takes all the stones inside it and then redistributes these stones one by one in the next holes in a counter-clockwise direction.
Note that the counter-clockwise order means if the player takes the stones from hole $$$i$$$, he will put one stone in the $$$(i+1)$$$-th hole, then in the $$$(i+2)$$$-th, etc. If he puts a stone in the $$$14$$$-th hole, the next one will be put in the first hole.
After the move, the player collects all the stones from holes that contain even number of stones. The number of stones collected by player is the score, according to Resli.
Resli is a famous Mancala player. He wants to know the maximum score he can obtain after one move.
The only line contains 14 integers $$$a_1, a_2, \ldots, a_{14}$$$ ($$$0 \leq a_i \leq 10^9$$$) — the number of stones in each hole.
It is guaranteed that for any $$$i$$$ ($$$1\leq i \leq 14$$$) $$$a_i$$$ is either zero or odd, and there is at least one stone in the board.
","input
Output one integer, the maximum possible score after one move.
output
In the first test case the board after the move from the hole with $$$7$$$ stones will look like 1 2 2 0 0 0 0 0 0 0 1 1 1 1. Then the player collects the even numbers and ends up with a score equal to $$$4$$$.
","bruteforce, implementation",1
"def palin(s):
    global ans
    if (s[::-1] != s or len(s) == 0):
        return len(s)
    else:
        return palin(s[1:])
s = input()
print(palin(s))",0981_A,CODEFORCES,1671,Antipalindrome,"A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.
A substring $$$s[l \ldots r]$$$ ($$$1 \leq l \leq r \leq |s|$$$) of a string $$$s = s_{1}s_{2} \ldots s_{|s|}$$$ is the string $$$s_{l}s_{l + 1} \ldots s_{r}$$$.
Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $$$s$$$ is changed into its longest substring that is not a palindrome. If all the substrings of $$$s$$$ are palindromes, she skips the word at all.
Some time ago Ann read the word $$$s$$$. What is the word she changed it into?
The first line contains a non-empty string $$$s$$$ with length at most $$$50$$$ characters, containing lowercase English letters only.
If there is such a substring in $$$s$$$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $$$0$$$.
Note that there can be multiple longest substrings that are not palindromes, but their length is unique.
""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $$$3$$$.
","input
The string ""uffuw"" is one of the longest non-palindrome substrings (of length $$$5$$$) of the string ""wuffuw"", so the answer for the second example is $$$5$$$.
output
All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $$$0$$$.
","bruteforce, implementation, strings",3
"n, m, k = map(int, input().split())
DATA = [input() for i in range(n)]

#dp[n_day][used_cost]
#ans = min(dp[n_day][used_cost] for used_cost in range(k + 1))
#dp[n_day][used_cost] := min(dp[n_day - 1][prev_cost] + cost(pay used_cost - prev_cost in n_day) for prev_cost in range(used_cost + 1))
INF = 1 << 60
dp = [[INF]*(k + 10) for i in range(n + 10)]
dp[0][0] = 0

COST = [[INF]*(k + 10) for i in range(n + 10)]
for i, string in enumerate(DATA):
    #COST[i + 1]
    stack = []
    for j in range(m):
        if string[j] == ""1"":
            stack.append(j)
    L = len(stack)
    for j in range(k + 10):
        if j >= L:
            COST[i + 1][j] = 0
            continue
        else:
            for pos in range(j + 1):
                l = pos
                r = pos + L - 1 - j
                COST[i+1][j] = min(COST[i+1][j], stack[r] - stack[l] + 1)
for day in range(1, n + 1):
    for used_cost in range(k + 1):
        dp[day][used_cost] = min(dp[day - 1][prev_cost] + COST[day]
                                 [used_cost - prev_cost] for prev_cost in range(used_cost + 1))

ans = min(dp[n][used_cost] for used_cost in range(k + 1))
print(ans)
",946D_,CODEFORCES,4258,Timetable,"Ivan is a student at Berland State University (BSU). There are n days in Berland week, and each of these days Ivan might have some classes at the university.
There are m working hours during each Berland day, and each lesson at the university lasts exactly one hour. If at some day Ivan's first lesson is during i-th hour, and last lesson is during j-th hour, then he spends j - i + 1 hours in the university during this day. If there are no lessons during some day, then Ivan stays at home and therefore spends 0 hours in the university.
Ivan doesn't like to spend a lot of time in the university, so he has decided to skip some lessons. He cannot skip more than k lessons during the week. After deciding which lessons he should skip and which he should attend, every day Ivan will enter the university right before the start of the first lesson he does not skip, and leave it after the end of the last lesson he decides to attend. If Ivan skips all lessons during some day, he doesn't go to the university that day at all.
Given n, m, k and Ivan's timetable, can you determine the minimum number of hours he has to spend in the university during one week, if he cannot skip more than k lessons?
The first line contains three integers n, m and k (1 ≤ n, m ≤ 500, 0 ≤ k ≤ 500) — the number of days in the Berland week, the number of working hours during each day, and the number of lessons Ivan can skip, respectively.
Then n lines follow, i-th line containing a binary string of m characters. If j-th character in i-th line is 1, then Ivan has a lesson on i-th day during j-th hour (if it is 0, there is no such lesson).
Print the minimum number of hours Ivan has to spend in the university during the week if he skips not more than k lessons.
","input
In the first example Ivan can skip any of two lessons during the first day, so he spends 1 hour during the first day and 4 hours during the second day.
output
In the second example Ivan can't skip any lessons, so he spends 4 hours every day.
",dp,6
"class SortedList:
    def __init__(self, iterable=None, _load=200):
        """"""Initialize sorted list instance.""""""
        if iterable is None:
            iterable = []
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len

    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)

    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))
n,x,y=map(int,input().split())
xx=[]
for i in range(n):
    xx.append(tuple(map(int,input().split())))

xx.sort()
#print(xx)
mod=10**9+7
tv=SortedList()
end=[]
c=0
an=0
for i in xx:

    if not len(tv):
        tv.add(i[1])
        an+=x+(i[1]-i[0])*y
    else:
        if tv[0]>=i[0]:
            tv.add(i[1])
            an =(an+ x + (i[1] - i[0]) * y)%mod
        else:
            pp=tv.bisect_left(i[0])-1
            tt=tv[pp]
            del tv[pp]
            tv.add(i[1])
            an=(an+min(x,(i[0]-tt)*y)+(i[1]-i[0])*y)%mod
    #print(tv, an)
print(an)",1061_D,CODEFORCES,2859,TV Shows,"There are $$$n$$$ TV shows you want to watch. Suppose the whole time is split into equal parts called ""minutes"". The $$$i$$$-th of the shows is going from $$$l_i$$$-th to $$$r_i$$$-th minute, both ends inclusive.
You need a TV to watch a TV show and you can't watch two TV shows which air at the same time on the same TV, so it is possible you will need multiple TVs in some minutes. For example, if segments $$$[l_i, r_i]$$$ and $$$[l_j, r_j]$$$ intersect, then shows $$$i$$$ and $$$j$$$ can't be watched simultaneously on one TV.
Once you start watching a show on some TV it is not possible to ""move"" it to another TV (since it would be too distracting), or to watch another show on the same TV until this show ends.
There is a TV Rental shop near you. It rents a TV for $$$x$$$ rupees, and charges $$$y$$$ ($$$y < x$$$) rupees for every extra minute you keep the TV. So in order to rent a TV for minutes $$$[a; b]$$$ you will need to pay $$$x + y \cdot (b - a)$$$. 
You can assume, that taking and returning of the TV doesn't take any time and doesn't distract from watching other TV shows. Find the minimum possible cost to view all shows. Since this value could be too large, print it modulo $$$10^9 + 7$$$.
The first line contains integers $$$n$$$, $$$x$$$ and $$$y$$$ ($$$1 \le n \le 10^5$$$, $$$1 \le y < x \le 10^9$$$) — the number of TV shows, the cost to rent a TV for the first minute and the cost to rent a TV for every subsequent minute.
Each of the next $$$n$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \le l_i \le r_i \le 10^9$$$) denoting the start and the end minute of the $$$i$$$-th TV show.
Print exactly one integer — the minimum cost to view all the shows taken modulo $$$10^9 + 7$$$.
In the first example, the optimal strategy would be to rent $$$3$$$ TVs to watch:
This way the cost for the first TV is $$$4 + 3 \cdot (2 - 1) = 7$$$, for the second is $$$4 + 3 \cdot (10 - 4) = 22$$$ and for the third is $$$4 + 3 \cdot (11 - 2) = 31$$$, which gives $$$60$$$ int total.
","input
In the second example, it is optimal watch each show on a new TV.
output
In third example, it is optimal to watch both shows on a new TV. Note that the answer is to be printed modulo $$$10^9 + 7$$$.
","datastructures, greedy, implementation, sortings",4
"import random

n = int(input())
v = []
a = []
for i in range(n):
    a.append(i)

for _ in range(0, n):
    x, y = map(int, input().split())
    v.append([x, y, x*x+y*y])

while 1>0:
    x = 0
    y = 0
    ans = [0]*n
    random.shuffle(a)
    for i in range(n):
        if (x+v[a[i]][0])**2+(y+v[a[i]][1])**2 <= (x-v[a[i]][0])**2+(y-v[a[i]][1])**2:
            x += v[a[i]][0]
            y += v[a[i]][1]
            ans[a[i]] = 1
        else:
            x -= v[a[i]][0]
            y -= v[a[i]][1]
            ans[a[i]] = -1
    if x*x+y*y <= 1500000**2:
        print(*ans)
        break

",0995_C,CODEFORCES,2651,Leaving the Bar,"For a vector $$$\vec{v} = (x, y)$$$, define $$$|v| = \sqrt{x^2 + y^2}$$$.
Allen had a bit too much to drink at the bar, which is at the origin. There are $$$n$$$ vectors $$$\vec{v_1}, \vec{v_2}, \cdots, \vec{v_n}$$$. Allen will make $$$n$$$ moves. As Allen's sense of direction is impaired, during the $$$i$$$-th move he will either move in the direction $$$\vec{v_i}$$$ or $$$-\vec{v_i}$$$. In other words, if his position is currently $$$p = (x, y)$$$, he will either move to $$$p + \vec{v_i}$$$ or $$$p - \vec{v_i}$$$.
Allen doesn't want to wander too far from home (which happens to also be the bar). You need to help him figure out a sequence of moves (a sequence of signs for the vectors) such that his final position $$$p$$$ satisfies $$$|p| \le 1.5 \cdot 10^6$$$ so that he can stay safe.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of moves.
Each of the following lines contains two space-separated integers $$$x_i$$$ and $$$y_i$$$, meaning that $$$\vec{v_i} = (x_i, y_i)$$$. We have that $$$|v_i| \le 10^6$$$ for all $$$i$$$.
","input
Output a single line containing $$$n$$$ integers $$$c_1, c_2, \cdots, c_n$$$, each of which is either $$$1$$$ or $$$-1$$$. Your solution is correct if the value of $$$p = \sum_{i = 1}^n c_i \vec{v_i}$$$, satisfies $$$|p| \le 1.5 \cdot 10^6$$$.
output
It can be shown that a solution always exists under the given constraints.
","bruteforce, datastructures, geometry, greedy, math, sortings",4
"
a0 = (1 << 30) - 1

a0 = 3
b0 = 1

def mock_query(c, d):
    res = (a0 ^ c) - (b0 ^ d)
    if res > 0:
        return 1
    elif res < 0:
        return -1
    else:
        return 0

def query2(c, d):
    ans = mock_query(c, d)
    print('? {:08b} {:08b} --> {}'.format(c, d, ans))
    return ans

def query(c, d):
    print('?', c, d)
    return int(input())

# query = query2

def solve():
    a = 0
    b = 0
    last_ans = query(0, 0)

    pos = 29
    while pos >= 0:
        bit = 1 << pos

        ans = query(a + bit, b + bit)
        if (last_ans, ans) == (1, -1):
            a += bit
            last_ans = query(a, b)
        elif (last_ans, ans) == (-1, 1):
            b += bit
            last_ans = query(a, b)
        # elif ans == 0:
            # pass
        else:
            last_ans = ans
            ans = query(a + bit, b)
            if ans == -1:
                a += bit
                b += bit

        pos -= 1

    print('!', a, b)

solve()
",1088_D,CODEFORCES,1218,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",2
"from sys import stdin, stdout
import math
N = int(input())

#N,M,K = [int(x) for x in stdin.readline().split()]

arr = [int(x) for x in stdin.readline().split()]

if sum(arr)==0:
    print('cslnb')
    quit()
    
arr.sort()
zeros = 0
freq = {}
dup = 0
res = 0

for i in range(N):
    num = arr[i]
    if num==0:
        zeros += 1
        if zeros==2:
            print('cslnb')
            quit()
            
    if num not in freq:
        freq[num] = 1
    else:
        dup += 1
        freq[num] += 1

    if dup==2:
        print('cslnb')
        quit()
    


for i in range(N):
    num = arr[i]
    if freq[num]==2:
        if (num-1) not in freq:
            freq[num-1] = 1
            freq[num] = 1
            arr[i] = arr[i] - 1
            res += 1
            break
        else:
            print('cslnb')
            quit()


#print(arr)
minus = [0]*N

level = 0
for i in range(N):
    minus[i] = min(arr[i],level)
    if arr[i]>=level:
        level += 1
        
for i in range(N):
    res += arr[i] - minus[i]
 
if res%2==0:
    print('cslnb')
else:
    print('sjfnb')





        
    
        ",1191_D,CODEFORCES,2986,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy",4
"#! /usr/bin/env python3
# -*- coding: utf-8 -*-
from sys import stdout

ask_count = 0
#a = [0,1,0,1,2,3,4,5,4,3,2,1,0,1,2,1]
#a = [-1, -2, -1, -2, -3, -2, -1, 0, 1, 0, -1, 0, 1, 0, 1, 2, 1, 0, 1, 0, 1, 0, 1, 0, -1, -2, -1, -2, -3, -4, -5, -6, -5, -6, -7, -6, -5, -4, -3, -2, -1, -2, -3, -4, -3, -4, -3, -4, -3, -2, -3, -4, -5, -6, -7, -6, -7, -6, -5, -6, -7, -6, -5, -6, -7, -6, -7, -8, -7, -6, -7, -6, -5, -6, -5, -4, -3, -4, -3, -2, -1, -2, -1, 0, 1, 2, 1, 0, -1, -2, -1, 0, 1, 2, 1, 0, 1, 0, 1, 0]
#n = len(a)
#print(""n"", n)
n = int(input())



def ask(num):
    global ask_count
    print(""? "" + str(num))
    stdout.flush()
    ask_count += 1
    return int(input())
    #return a[num-1]

def ans(num):
    print(""! "" + str(num))
    stdout.flush()

def opposite(num):
    return num + n // 2

low = 1
high = opposite(low)
lval = ask(low)
hval = ask(high)
prev_l_less_h = (lval < hval)
#print(prev_l_less_h)


while high - low > 1:
    #print(""low"", low, "";high"", high)
    mid = (low + high) // 2

    lval = ask(mid)
    hval = ask(opposite(mid))
    l_less_h = (lval < hval)

    if abs(lval - hval) % 2 == 1:
        ans(-1)
        exit(0)
    elif hval == lval:
        ans(mid)
        exit(0)
    else:
        if l_less_h == prev_l_less_h:
            low = mid
        else:
            high = mid
ans(-1)",1019_B,CODEFORCES,1150,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive",2
"my_list = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""yellow"":""Mind"", ""red"":""Reality""}

n = int(input())
for i in range(n):
    my_list.pop(input())

print(len(my_list))
for i in my_list:
    print(my_list[i])",0987_A,CODEFORCES,337,Infinity Gauntlet,"You took a peek on Thanos wearing Infinity Gauntlet. In the Gauntlet there is a place for six Infinity Gems:
Using colors of Gems you saw in the Gauntlet determine the names of absent Gems.
In the first line of input there is one integer $$$n$$$ ($$$0 \le n \le 6$$$) — the number of Gems in Infinity Gauntlet.
In next $$$n$$$ lines there are colors of Gems you saw. Words used for colors are: purple, green, blue, orange, red, yellow. It is guaranteed that all the colors are distinct. All colors are given in lowercase English letters.
In the first line output one integer $$$m$$$ ($$$0 \le m \le 6$$$) — the number of absent Gems.
Then in $$$m$$$ lines print the names of absent Gems, each on its own line. Words used for names are: Power, Time, Space, Soul, Reality, Mind. Names can be printed in any order. Keep the first letter uppercase, others lowercase.
","input
In the first sample Thanos already has Reality, Power, Mind and Soul Gems, so he needs two more: Time and Space.
output
In the second sample Thanos doesn't have any Gems, so he needs all six.
",implementation,1
"a = input()
l = 0
for i in range(1, len(a)):
  for j in range(0, len(a) - i + 1):
    #print(a[j:j + i + 1], i, j)
    t = a.find(a[j:j + i])
    c = a.rfind(a[j:j + i])
    #print(t, c)
    if t != c:
      if i > l:
        l = i
print(l)",0023_A,CODEFORCES,3729,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"def good(x1, y1, x2, y2):
    if (x1 > x2):
        x1, x2 = x2, x1
        y1, y2 = y2, y1
    return (x2 >= y1) 

def check(cent):
    for i in range(n):
        if (not good(cent - t, cent + t, x[i] - a[i], x[i] + a[i])):
            return 0
    return 1

n, t = map(int, input().split())
x = [0] * n
a = [0] * n
for i in range(n):
    x[i], a[i] = map(int, input().split())
    x[i] *= 2

ans = set()

for i in range(n):
    val1 = x[i] - a[i] - t
    val2 = x[i] + a[i] + t
    if (check(val1)):
        ans.add(val1)
    if (check(val2)):
        ans.add(val2)
print(len(ans))
",0015_A,CODEFORCES,2259,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"A, B = map(int, input().split())
x, y, z = map(int, input().split())
nA = 2*x+y
nB = 3*z+y
r = 0
if nA > A:
    r += nA-A
if nB > B:
    r += nB-B
print(r)
",0912_A,CODEFORCES,217,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation,1
"import sys
input = sys.stdin.readline
q = int(input())
for i in range(q):
    n, k = map(int, input().split())
    s = input()
    R, G, B = 0, 0, 0
    ans = float('inf')
    for j in range(n):
        if j % 3 == 0:
            if s[j] == 'R':
                G += 1
                B += 1
            elif s[j] == 'G':
                R += 1
                B += 1
            else:
                R += 1
                G += 1
        elif j % 3 == 1:
            if s[j] == 'R':
                G += 1
                R += 1
            elif s[j] == 'G':
                G += 1
                B += 1
            else:
                R += 1
                B += 1
        else:
            if s[j] == 'R':
                R += 1
                B += 1
            elif s[j] == 'G':
                R += 1
                G += 1
            else:
                G += 1
                B += 1
        if j >= k - 1:
            ans = min(ans, R, G, B)
            if (j - k + 1) % 3 == 0:
                if s[j - k + 1] == 'R':
                    G -= 1
                    B -= 1
                elif s[j - k + 1] == 'G':
                    R -= 1
                    B -= 1
                else:
                    R -= 1
                    G -= 1
            elif (j - k + 1) % 3 == 1:
                if s[j - k + 1] == 'R':
                    G -= 1
                    R -= 1
                elif s[j - k + 1] == 'G':
                    G -= 1
                    B -= 1
                else:
                    R -= 1
                    B -= 1
            else:
                if s[j - k + 1] == 'R':
                    R -= 1
                    B -= 1
                elif s[j - k + 1] == 'G':
                    R -= 1
                    G -= 1
                else:
                    G -= 1
                    B -= 1

    print(ans)",1196_D2,CODEFORCES,2242,RGB Substring (hard version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2 \cdot 10^5$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2 \cdot 10^5$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
","datastructures, dp, implementation, twopointers",3
"n,m=map(int, input().split())
out=[n]
i=n-1
m-=1
for _ in range(n-1):
    if m%2:
        out.append(i)
    else:
        out=[i]+out
    
    m//=2
    i-=1

for i in out:
    print(i, end="" "")
print()
",0513_B1,CODEFORCES,4402,Permutations,"You are given a permutation p of numbers 1, 2, ..., n. Let's define f(p) as the following sum:
Find the lexicographically m-th permutation of length n in the set of permutations having the maximum possible value of f(p).
The single line of input contains two integers n and m (1 ≤ m ≤ cntn), where cntn is the number of permutations of length n with maximum possible value of f(p).
The problem consists of two subproblems. The subproblems have different constraints on the input. You will get some score for the correct submission of the subproblem. The description of the subproblems follows.
","input
Output n number forming the required permutation.
output
In the first example, both permutations of numbers {1, 2} yield maximum possible f(p) which is equal to 4. Among them, (2, 1) comes second in lexicographical order.
",bruteforce,7
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase

def main():
    n,k = map(int,input().split())
    card = list(map(int,input().split()))
    fav = list(map(int,input().split()))
    joy = [0]+list(map(int,input().split()))
    dp = [[0]*(n*k+1) for _ in range(n+1)]
    for i in range(len(joy)):
        dp[1][i] = joy[i]
    for i in range(len(joy),n*k+1):
        dp[1][i] = joy[-1]
    for i in range(2,n+1):
        for j in range(1,n*k+1):
            for kk in range(min(k+1,j+1)):
                dp[i][j] = max(dp[i][j],dp[i-1][j-kk]+dp[1][kk])
    tot = [0]*(10**5+1)
    for i in card:
        tot[i] += 1
    tot1 = [0]*(10**5+1)
    for i in fav:
        tot1[i] += 1
    ans = 0
    for i in range(10**5+1):
        ans += dp[tot1[i]][tot[i]]
    print(ans)

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",0999_F,CODEFORCES,3769,Cards and Joy,"There are $$$n$$$ players sitting at the card table. Each player has a favorite number. The favorite number of the $$$j$$$-th player is $$$f_j$$$.
There are $$$k \cdot n$$$ cards on the table. Each card contains a single integer: the $$$i$$$-th card contains number $$$c_i$$$. Also, you are given a sequence $$$h_1, h_2, \dots, h_k$$$. Its meaning will be explained below.
The players have to distribute all the cards in such a way that each of them will hold exactly $$$k$$$ cards. After all the cards are distributed, each player counts the number of cards he has that contains his favorite number. The joy level of a player equals $$$h_t$$$ if the player holds $$$t$$$ cards containing his favorite number. If a player gets no cards with his favorite number (i.e., $$$t=0$$$), his joy level is $$$0$$$.
Print the maximum possible total joy levels of the players after the cards are distributed. Note that the sequence $$$h_1, \dots, h_k$$$ is the same for all the players.
The first line of input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 500, 1 \le k \le 10$$$) — the number of players and the number of cards each player will get.
The second line contains $$$k \cdot n$$$ integers $$$c_1, c_2, \dots, c_{k \cdot n}$$$ ($$$1 \le c_i \le 10^5$$$) — the numbers written on the cards.
The third line contains $$$n$$$ integers $$$f_1, f_2, \dots, f_n$$$ ($$$1 \le f_j \le 10^5$$$) — the favorite numbers of the players.
The fourth line contains $$$k$$$ integers $$$h_1, h_2, \dots, h_k$$$ ($$$1 \le h_t \le 10^5$$$), where $$$h_t$$$ is the joy level of a player if he gets exactly $$$t$$$ cards with his favorite number written on them. It is guaranteed that the condition $$$h_{t - 1} < h_t$$$ holds for each $$$t \in [2..k]$$$.
Print one integer — the maximum possible total joy levels of the players among all possible card distributions.
In the first example, one possible optimal card distribution is the following:
","input
Thus, the answer is $$$2 + 6 + 6 + 7 = 21$$$.
output
In the second example, no player can get a card with his favorite number. Thus, the answer is $$$0$$$.
",dp,6
"arr = []
d = {}
for _ in range(int(input())):
    s = input()
    a,b,c = tuple(map(int, s.replace(""("","""").replace("")"","""").replace(""/"",""."").replace(""+"",""."").split(""."")))
    x = (a+b)/c
    arr.append(x)
    if x not in d:
        d[x] = 0
    d[x] += 1

for i in arr:
    print(d[i], end = "" "")",0958_D1,CODEFORCES,1573,Hyperspace Jump (easy),"The Rebel fleet is on the run. It consists of m ships currently gathered around a single planet. Just a few seconds ago, the vastly more powerful Empire fleet has appeared in the same solar system, and the Rebels will need to escape into hyperspace. In order to spread the fleet, the captain of each ship has independently come up with the coordinate to which that ship will jump. In the obsolete navigation system used by the Rebels, this coordinate is given as the value of an arithmetic expression of the form .
To plan the future of the resistance movement, Princess Heidi needs to know, for each ship, how many ships are going to end up at the same coordinate after the jump. You are her only hope!
The first line of the input contains a single integer m (1 ≤ m ≤ 200 000) – the number of ships. The next m lines describe one jump coordinate each, given as an arithmetic expression. An expression has the form (a+b)/c. Namely, it consists of: an opening parenthesis (, a positive integer a of up to two decimal digits, a plus sign +, a positive integer b of up to two decimal digits, a closing parenthesis ), a slash /, and a positive integer c of up to two decimal digits.
Print a single line consisting of m space-separated integers. The i-th integer should be equal to the number of ships whose coordinate is equal to that of the i-th ship (including the i-th ship itself).
","input
In the sample testcase, the second and the third ship will both end up at the coordinate 3.
output
Note that this problem has only two versions – easy and hard.
","expressionparsing, math",3
"z,zz=input,lambda:list(map(int,z().split()))
zzz=lambda:[int(i) for i in stdin.readline().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from re import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
        
    return 1
def dfs(u,visit,graph):
    visit[u]=True
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)

###########################---Test-Case---#################################
""""""



""""""
###########################---START-CODING---##############################

l=z()
n=len(l)
ans=0
for i in range(n):

    for j in range(i+1,n+1):
        p=l[i:j]
        t=len(p)
        x=0

        for k in range( n):
            if l[k:k+t]==p:
                x+=1
        if x>=2:
            ans=max(ans,t)
print(ans)




	   			   	 		      	   	 	   	",0023_A,CODEFORCES,3754,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"n,M=map(int,input().split())
a=[0]+[int(x) for x in input().split()]+[M]

t1=[]
t2=[]
for i in range(n+1):
    if i%2==0:
        t1.append(a[i+1]-a[i])
    else:
        t2.append(a[i+1]-a[i])
t2.append(0)

import math
ans=sum(t1)
p=0
q=sum(t2)
for i in range(math.ceil(n/2)):
    p=p+t1[i]
    q=q-t2[i-1]
    ans=max(ans,p+q-1)
print(ans)
",1000_B,CODEFORCES,1740,Light It Up,"Recently, you bought a brand new smart lamp with programming features. At first, you set up a schedule to the lamp. Every day it will turn power on at moment $$$0$$$ and turn power off at moment $$$M$$$. Moreover, the lamp allows you to set a program of switching its state (states are ""lights on"" and ""lights off""). Unfortunately, some program is already installed into the lamp.
The lamp allows only good programs. Good program can be represented as a non-empty array $$$a$$$, where $$$0 < a_1 < a_2 < \dots < a_{|a|} < M$$$. All $$$a_i$$$ must be integers. Of course, preinstalled program is a good program.
The lamp follows program $$$a$$$ in next manner: at moment $$$0$$$ turns power and light on. Then at moment $$$a_i$$$ the lamp flips its state to opposite (if it was lit, it turns off, and vice versa). The state of the lamp flips instantly: for example, if you turn the light off at moment $$$1$$$ and then do nothing, the total time when the lamp is lit will be $$$1$$$. Finally, at moment $$$M$$$ the lamp is turning its power off regardless of its state.
Since you are not among those people who read instructions, and you don't understand the language it's written in, you realize (after some testing) the only possible way to alter the preinstalled program. You can insert at most one element into the program $$$a$$$, so it still should be a good program after alteration. Insertion can be done between any pair of consecutive elements of $$$a$$$, or even at the begining or at the end of $$$a$$$.
Find such a way to alter the program that the total time when the lamp is lit is maximum possible. Maybe you should leave program untouched. If the lamp is lit from $$$x$$$ till moment $$$y$$$, then its lit for $$$y - x$$$ units of time. Segments of time when the lamp is lit are summed up.
First line contains two space separated integers $$$n$$$ and $$$M$$$ ($$$1 \le n \le 10^5$$$, $$$2 \le M \le 10^9$$$) — the length of program $$$a$$$ and the moment when power turns off.
Second line contains $$$n$$$ space separated integers $$$a_1, a_2, \dots, a_n$$$ ($$$0 < a_1 < a_2 < \dots < a_n < M$$$) — initially installed program $$$a$$$.
Print the only integer — maximum possible total time when the lamp is lit.
In the first example, one of possible optimal solutions is to insert value $$$x = 3$$$ before $$$a_1$$$, so program will be $$$[3, 4, 6, 7]$$$ and time of lamp being lit equals $$$(3 - 0) + (6 - 4) + (10 - 7) = 8$$$. Other possible solution is to insert $$$x = 5$$$ in appropriate place.
","input
In the second example, there is only one optimal solution: to insert $$$x = 2$$$ between $$$a_1$$$ and $$$a_2$$$. Program will become $$$[1, 2, 10]$$$, and answer will be $$$(1 - 0) + (10 - 2) = 9$$$.
output
In the third example, optimal answer is to leave program untouched, so answer will be $$$(3 - 0) + (7 - 4) = 6$$$.
",greedy,3
"#!/usr/bin/env python
import os
import re
import sys
from bisect import bisect, bisect_left, insort, insort_left
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from fractions import gcd
from io import BytesIO, IOBase
from itertools import (
    accumulate, combinations, combinations_with_replacement, groupby,
    permutations, product)
from math import (
    acos, asin, atan, ceil, cos, degrees, factorial, hypot, log2, pi, radians,
    sin, sqrt, tan)
from operator import itemgetter, mul
from string import ascii_lowercase, ascii_uppercase, digits


def inp():
    return(int(input()))


def inlist():
    return(list(map(int, input().split())))


def instr():
    s = input()
    return(list(s[:len(s)]))


def invr():
    return(map(int, input().split()))


def getReamin(action, n):
    n -= action
    ans = (n*(n+1) // 2) - action
    return ans


def main():
    # sys.stdin = open('input.txt', 'r')
    # sys.stdout = open('output.txt', 'w')

    n, k = invr()
    l = 1
    r = n
    res = 0
    while l <= r:
        mid = l + (r-l)//2
        remain = getReamin(mid, n)
        if remain == k:
            res = mid
            break
        if remain > k:
            l = mid + 1
        else:
            r = mid - 1
    print(res)


    # region fastio
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")

# endregion


if __name__ == ""__main__"":
    main()
",1195_B,CODEFORCES,1410,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import itertools
import sys

""""""
created by shhuan at 2018/12/15 22:46

""""""

N = int(input())
B = [int(x) for x in input().split()]

A = [0] * N

i, j = N//2-1, N//2
A[i] = B[-1] // 2
A[j] = B[-1] // 2 if B[-1] % 2 == 0 else B[-1] // 2 + 1
l, r = A[i], A[j]
for bi in range(len(B)-2, -1, -1):
    b = B[bi]
    i -= 1
    j += 1

    if b-l >= A[j-1]:
        A[i] = l
        A[j] = b-l
        r = b-l
    else:
        A[j] = r
        A[i] = b-r
        l = b-r

print(' '.join(map(str, A)))
",1093_C,CODEFORCES,2086,Mishka and the Last Exam,"Mishka is trying really hard to avoid being kicked out of the university. In particular, he was doing absolutely nothing for the whole semester, miraculously passed some exams so that just one is left.
There were $$$n$$$ classes of that subject during the semester and on $$$i$$$-th class professor mentioned some non-negative integer $$$a_i$$$ to the students. It turned out, the exam was to tell the whole sequence back to the professor. 
Sounds easy enough for those who attended every class, doesn't it?
Obviously Mishka didn't attend any classes. However, professor left some clues on the values of $$$a$$$ to help out students like Mishka: 
Professor also mentioned that any sequence $$$a$$$, which produces sequence $$$b$$$ with the presented technique, will be acceptable.
Help Mishka to pass that last exam. Restore any sorted sequence $$$a$$$ of non-negative integers, which produces sequence $$$b$$$ with the presented technique. It is guaranteed that there exists at least one correct sequence $$$a$$$, which produces the given sequence $$$b$$$.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — the length of sequence $$$a$$$. $$$n$$$ is always even.
The second line contains $$$\frac n 2$$$ integers $$$b_1, b_2, \dots, b_{\frac n 2}$$$ ($$$0 \le b_i \le 10^{18}$$$) — sequence $$$b$$$, where $$$b_i = a_i + a_{n - i + 1}$$$.
It is guaranteed that there exists at least one correct sequence $$$a$$$, which produces the given sequence $$$b$$$.
Print $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$0 \le a_i \le 10^{18}$$$) in a single line.
","input
$$$a_1 \le a_2 \le \dots \le a_n$$$ should be satisfied.
output
$$$b_i = a_i + a_{n - i + 1}$$$ should be satisfied for all valid $$$i$$$.
",greedy,3
"n = int(input())
ans = 0
if n==1:
    print(1)
    exit()
if n==2:
    print(2)
    exit()
if n==3:
    print(6)
    exit()
if n%2==0:
    if n%3==0:
        ans=(n-1)*(n-2)*(n-3)
    else:
        ans=n*(n-1)*(n-3)
else:
    ans=n*(n-1)*(n-2)

print(ans)",0235_A,CODEFORCES,80,LCM Challenge,"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.
But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than n. Can you help me to find the maximum possible least common multiple of these three integers?
The first line contains an integer n (1 ≤ n ≤ 106) — the n mentioned in the statement.
Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than n.
The least common multiple of some positive integers is the least positive integer which is multiple for each of them.
","input
The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.
output
For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.
",numbertheory,1
"import sys
from math import floor, ceil

input = sys.stdin.readline

n, k = map(int, input().split())

print(ceil((n*2)/k) + ceil((n*5)/k) + ceil((n*8)/k))",1080_A,CODEFORCES,577,Petya and Origami,"Petya is having a party soon, and he has decided to invite his $$$n$$$ friends.
He wants to make invitations in the form of origami. For each invitation, he needs two red sheets, five green sheets, and eight blue sheets. The store sells an infinite number of notebooks of each color, but each notebook consists of only one color with $$$k$$$ sheets. That is, each notebook contains $$$k$$$ sheets of either red, green, or blue.
Find the minimum number of notebooks that Petya needs to buy to invite all $$$n$$$ of his friends.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1\leq n, k\leq 10^8$$$) — the number of Petya's friends and the number of sheets in each notebook respectively.
Print one number — the minimum number of notebooks that Petya needs to buy.
","input
In the first example, we need $$$2$$$ red notebooks, $$$3$$$ green notebooks, and $$$5$$$ blue notebooks.
output
In the second example, we need $$$5$$$ red notebooks, $$$13$$$ green notebooks, and $$$20$$$ blue notebooks.
",math,1
"import io, sys
input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()
 
ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())

n, k = mi()
ans = None
for x in range(1, n + 1):
    if x * (x + 3) == 2 * (k + n):
        ans = n - x
        break
print(ans)",1195_B,CODEFORCES,2222,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",3
"mod = 10**9+7
x, k = map(int, input().split(' '))
if (x == 0):
    print(0)
else:
    val1 = pow(2,k+1,mod) * x
    val2 = pow(2, k, mod) - 1
    val1 -= val2
    val1 %= mod
    print(val1)
",0992_C,CODEFORCES,1022,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"def f(n):
    k=2
    while k*k<=n:
        if n%k==0:
            return False
        k+=1
    return True
n,k=map(int,input().split())
a=[]
x=0
for i in range(2,n+1):
    if f(i):
        a.append(i)
for i in range(len(a)-2):
    if a[i]+a[i+1]+1 in a:
        x+=1
if x>=k:
    print('YES')
else:
    print('NO')
",0017_A,CODEFORCES,1437,Noldbach problem,"Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least k prime numbers from 2 to n inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.
Two prime numbers are called neighboring if there are no other prime numbers between them.
You are to help Nick, and find out if he is right or wrong.
The first line of the input contains two integers n (2 ≤ n ≤ 1000) and k (0 ≤ k ≤ 1000).
","input
Output YES if at least k prime numbers from 2 to n inclusively can be expressed as it was described above. Otherwise output NO.
output
In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.
","bruteforce, math, numbertheory",3
"import copy
import sys

def find_loop(g, w, k, n):
    visited = [False] * n
    visited_int = [False] * n
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        visited_int[i] = True
        while stack:
            if not stack[-1]:
                stack.pop()
                visited_int[path[-1]] = False
                path.pop()
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited_int[nxt]:
                return True
            if visited[nxt]:
                continue
            visited[nxt] = True
            visited_int[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)
    return False


def top_sort(g, w, k, n):
    visited = [False] * n
    order = [-1] * n
    cnt = 0
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        while stack:
            if not stack[-1]:
                order[path[-1]] = cnt
                path.pop()
                stack.pop()
                cnt += 1
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited[nxt]:
                continue
            visited[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)

    to_reverse = []
    for a, b in w.items():
        if b > k:
            continue
        if order[a[0]] < order[a[1]]:
            to_reverse.append(a)
    return to_reverse


if __name__ == '__main__':
    n, m = map(int, input().split())
    w = {}
    g = [[] for _ in range(n)]
    w_tmp = {}
    c_m = 0
    kk = [0]
    lines = sys.stdin.readlines()
    for i, line in enumerate(lines): #range(1, m + 1):
        u, v, c = map(int, line.split())
        g[u - 1].append(v - 1)
        if (u - 1, v - 1) in w.keys():
            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)
        else:
            w[(u - 1, v - 1)] = c
        if (u - 1, v - 1) in w_tmp.keys():
            w_tmp[(u - 1, v - 1)].append(str(i + 1))
        else:
            w_tmp[(u - 1, v - 1)] = [str(i + 1)]
        kk.append(c)

    kk.sort()
    l, r = 0, len(kk)
    if not find_loop(g, w, kk[l], n):
        print(0, 0)
        exit(0)
    if find_loop(g, w, kk[-1], n):
        kkk = kk[-1]
    else:
        while l + 1 != r:
            m = int((l + r) / 2)
            if find_loop(g, w, kk[m], n):
                l = m
            else:
                r = m
        kkk = kk[l+1]

    to_reverse = top_sort(g, w, kkk, n)
    num = 0
    s = []
    for t in to_reverse:
        num += len(w_tmp[t])
        s.extend(w_tmp[t])

    print(kkk, num)
    print("" "".join(s))",1100_E,CODEFORCES,2913,Andrew and Taxi,"Andrew prefers taxi to other means of transport, but recently most taxi drivers have been acting inappropriately. In order to earn more money, taxi drivers started to drive in circles. Roads in Andrew's city are one-way, and people are not necessary able to travel from one part to another, but it pales in comparison to insidious taxi drivers.
The mayor of the city decided to change the direction of certain roads so that the taxi drivers wouldn't be able to increase the cost of the trip endlessly. More formally, if the taxi driver is on a certain crossroads, they wouldn't be able to reach it again if he performs a nonzero trip. 
Traffic controllers are needed in order to change the direction the road goes. For every road it is known how many traffic controllers are needed to change the direction of the road to the opposite one. It is allowed to change the directions of roads one by one, meaning that each traffic controller can participate in reversing two or more roads.
You need to calculate the minimum number of traffic controllers that you need to hire to perform the task and the list of the roads that need to be reversed.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \leq n \leq 100\,000$$$, $$$1 \leq m \leq 100\,000$$$) — the number of crossroads and the number of roads in the city, respectively.
Each of the following $$$m$$$ lines contain three integers $$$u_{i}$$$, $$$v_{i}$$$ and $$$c_{i}$$$ ($$$1 \leq u_{i}, v_{i} \leq n$$$, $$$1 \leq c_{i} \leq 10^9$$$, $$$u_{i} \ne v_{i}$$$) — the crossroads the road starts at, the crossroads the road ends at and the number of traffic controllers required to reverse this road.
In the first line output two integers the minimal amount of traffic controllers required to complete the task and amount of roads $$$k$$$ which should be reversed. $$$k$$$ should not be minimized.
In the next line output $$$k$$$ integers separated by spaces — numbers of roads, the directions of which should be reversed. The roads are numerated from $$$1$$$ in the order they are written in the input. If there are many solutions, print any of them.
","input
There are two simple cycles in the first example: $$$1 \rightarrow 5 \rightarrow 2 \rightarrow 1$$$ and $$$2 \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow 2$$$. One traffic controller can only reverse the road $$$2 \rightarrow 1$$$ and he can't destroy the second cycle by himself. Two traffic controllers can reverse roads $$$2 \rightarrow 1$$$ and $$$2 \rightarrow 3$$$ which would satisfy the condition.
output
In the second example one traffic controller can't destroy the cycle $$$ 1 \rightarrow 3 \rightarrow 2 \rightarrow 1 $$$. With the help of three controllers we can, for example, reverse roads $$$1 \rightarrow 3$$$ ,$$$ 2 \rightarrow 4$$$, $$$1 \rightarrow 5$$$.
","binarysearch, dfsandsimilar, graphs",4
"import collections, bisect
n, m = map(int, input().split())
arr = list(map(int, input().split()))
cs = collections.Counter(arr)
print(min(cs[x] for x in range(1, n + 1)))
",0961_A,CODEFORCES,3154,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation,5
"import math
s1=str(input())
s2=str(input())
d1=0;d2=0;n=0
answer=0
for i in s1:
    if i=='+':d1+=1
    else:
        d1-=1
for i in s2:
    if i=='+':d2+=1
    elif i=='?':n+=1
    else:
        d2-=1
if n>=abs(d2-d1):
    y=(n-abs(d1-d2))/2
    if y%1==0:
        answer=math.factorial(n)/math.factorial(n-y)/math.factorial(y)/2**n
print('%.9f'%answer)",0476_B,CODEFORCES,4365,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"import sys, math
 
n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().rstrip()))
if len(set(arr)) == 1:
    print('YES')
else:
    val = sum(arr)
    factor = set()
    for i in range(1, int(val ** 0.5) + 1):
        if val % i == 0:
            factor.add(i)
            factor.add(val // i)
    can = False
    for i in factor:
        each = val // i
        if 1 < i <= n:
            idx = 0
            temp = 0
            cnt = 0
            while idx < n:
                if temp + arr[idx] < each:
                    temp += arr[idx]
                elif temp + arr[idx] > each:
                    temp = 0
                else:
                    temp = 0
                    cnt += 1
                idx += 1
            if cnt == i:
                can = True
    print('YES' if can else 'NO')
 ",1030_C,CODEFORCES,3461,Vasya and Golden Ticket,"Recently Vasya found a golden ticket — a sequence which consists of $$$n$$$ digits $$$a_1a_2\dots a_n$$$. Vasya considers a ticket to be lucky if it can be divided into two or more non-intersecting segments with equal sums. For example, ticket $$$350178$$$ is lucky since it can be divided into three segments $$$350$$$, $$$17$$$ and $$$8$$$: $$$3+5+0=1+7=8$$$. Note that each digit of sequence should belong to exactly one segment.
Help Vasya! Tell him if the golden ticket he found is lucky or not.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 100$$$) — the number of digits in the ticket.
The second line contains $$$n$$$ digits $$$a_1 a_2 \dots a_n$$$ ($$$0 \le a_i \le 9$$$) — the golden ticket. Digits are printed without spaces.
If the golden ticket is lucky then print ""YES"", otherwise print ""NO"" (both case insensitive).
","input
In the first example the ticket can be divided into $$$7$$$, $$$34$$$ and $$$52$$$: $$$7=3+4=5+2$$$.
output
In the second example it is impossible to divide ticket into segments with equal sum.
",implementation,5
"n, m = map(int, input().split())
print(m // n + (1 if m % n else 0))
",1036_A,CODEFORCES,466,Function Height,"You are given a set of $$$2n+1$$$ integer points on a Cartesian plane. Points are numbered from $$$0$$$ to $$$2n$$$ inclusive. Let $$$P_i$$$ be the $$$i$$$-th point. The $$$x$$$-coordinate of the point $$$P_i$$$ equals $$$i$$$. The $$$y$$$-coordinate of the point $$$P_i$$$ equals zero (initially). Thus, initially $$$P_i=(i,0)$$$.
The given points are vertices of a plot of a piecewise function. The $$$j$$$-th piece of the function is the segment $$$P_{j}P_{j + 1}$$$.
In one move you can increase the $$$y$$$-coordinate of any point with odd $$$x$$$-coordinate (i.e. such points are $$$P_1, P_3, \dots, P_{2n-1}$$$) by $$$1$$$. Note that the corresponding segments also change.
For example, the following plot shows a function for $$$n=3$$$ (i.e. number of points is $$$2\cdot3+1=7$$$) in which we increased the $$$y$$$-coordinate of the point $$$P_1$$$ three times and $$$y$$$-coordinate of the point $$$P_5$$$ one time:
Let the area of the plot be the area below this plot and above the coordinate axis OX. For example, the area of the plot on the picture above is 4 (the light blue area on the picture above is the area of the plot drawn on it).
Let the height of the plot be the maximum $$$y$$$-coordinate among all initial points in the plot (i.e. points $$$P_0, P_1, \dots, P_{2n}$$$). The height of the plot on the picture above is 3.
Your problem is to say which minimum possible height can have the plot consisting of $$$2n+1$$$ vertices and having an area equal to $$$k$$$. Note that it is unnecessary to minimize the number of moves.
It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 10^{18}$$$) — the number of vertices in a plot of a piecewise function and the area we need to obtain.
Print one integer — the minimum possible height of a plot consisting of $$$2n+1$$$ vertices and with an area equals $$$k$$$. It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
One of the possible answers to the first example:
The area of this plot is 3, the height of this plot is 1.
","input
There is only one possible answer to the second example:
output
The area of this plot is 12, the height of this plot is 3.
",math,1
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]
 
DP = [0] * ((R+1) * (G+1) * (B+1))
def idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b
 
for r in range(R+1):
	for g in range(G+1):
		for b in range(B+1):
			best = 0
 
			if r:
				if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
				if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])
 
			if g and b:
				best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])
 
			DP[idx(r, g, b)] = best
 
print(max(DP))",1398_D,CODEFORCES,3998,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"def rotate(L):
    L1 = ['' for i in range(n)]
    for i in range(n):
        for j in range(n):
            L1[n - j - 1] += L[i][j]
    return L1

def flip_v(L):
    L1 = []
    for i in range(n):
        L1.append(L[i][::-1])
    return L1

def flip_h(L):
    L1 = []
    for i in range(n):
        L1.append(L[n - i - 1])
    return L1

n = int(input())
L = []
M = []
for i in range(n):
    L.append(input())
for i in range(n):
    M.append(input())
L1 = rotate(L)
L2 = rotate(L1)
L3 = rotate(L2)
L4 = flip_v(L)
L5 = flip_h(L)
L6 = rotate(L4)
L7 = rotate(L6)
L8 = rotate(L7)
L9 = rotate(L5)
L10 = rotate(L9)
L11 = rotate(L10)
if L == M or L1 == M or L2 == M or L3 == M or L4 == M or L5 == M or L6 == M or L7 == M or L8 == M or L9 == M or L10 == M or L11 == M:
    print('Yes')
else:
    print('No')",0958_A1,CODEFORCES,3138,Death Stars (easy),"The stardate is 1977 and the science and art of detecting Death Stars is in its infancy. Princess Heidi has received information about the stars in the nearby solar system from the Rebel spies and now, to help her identify the exact location of the Death Star, she needs to know whether this information is correct. 
Two rebel spies have provided her with the maps of the solar system. Each map is an N × N grid, where each cell is either occupied by a star or empty. To see whether the information is correct, Heidi needs to know whether the two maps are of the same solar system, or if possibly one of the spies is actually an Empire double agent, feeding her false information.
Unfortunately, spies may have accidentally rotated a map by 90, 180, or 270 degrees, or flipped it along the vertical or the horizontal axis, before delivering it to Heidi. If Heidi can rotate or flip the maps so that two of them become identical, then those maps are of the same solar system. Otherwise, there are traitors in the Rebel ranks! Help Heidi find out.
The first line of the input contains one number N (1 ≤ N ≤ 10) – the dimension of each map. Next N lines each contain N characters, depicting the first map: 'X' indicates a star, while 'O' indicates an empty quadrant of space. Next N lines each contain N characters, depicting the second map in the same format.
The only line of output should contain the word Yes if the maps are identical, or No if it is impossible to match them by performing rotations and translations.
","input
In the first test, you can match the first map to the second map by first flipping the first map along the vertical axis, and then by rotating it 90 degrees clockwise.
output
 
",implementation,5
"import sys

k = int(input())
d = [0]
for i in range(1, 12):
    d.append((10 ** i - 10 ** (i - 1)) * i + d[i - 1])
# print(d)
for i in range(1, len(d)):
    if k <= d[i]:
        f = d[i - 1]
        f1 = 10 ** (i - 1)
        # print(i, f)
        # print(str(((k - f - 1) // i) + f1))
        print(str(((k - f - 1) // i) + f1)[(k - f - 1) % i])
        sys.exit()
",1177_B,CODEFORCES,1306,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"import sys, math
import io, os
# data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
# from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
# from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal
# from fractions import Fraction
# sys.setrecursionlimit(100000)
INF = 10001
mod = int(1e9) + 7


def cal(l,r):
    if l==r:
        dp1[l][r]=a[l]
        dp3[l][r] = 1
        return dp1[l][r]
    if dp1[l][r]!=-1:
        return dp1[l][r]
    for i in range(l,r):
        if cal(l,i) == cal(i+1,r) != 0:
            dp1[l][r]=dp1[l][i]+1
            dp3[l][r]=1
        dp3[l][r]=min(dp3[l][r],dp3[l][i]+dp3[i+1][r])
    if dp1[l][r] == -1:
        dp1[l][r] = 0
    return dp1[l][r]


n=int(data())
a=mdata()
ans=[n]
dp1=[[-1]*n for i in range(n)]
dp3=[[10001]*n for i in range(n)]
cal(0,n-1)
out(dp3[0][n-1])",1312_E,CODEFORCES,3878,Array Shrinking,"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation any number of times:
After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array $$$a$$$ you can get?
The first line contains the single integer $$$n$$$ ($$$1 \le n \le 500$$$) — the initial length of the array $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$) — the initial array $$$a$$$.
Print the only integer — the minimum possible length you can get after performing the operation described above any number of times.
In the first test, this is one of the optimal sequences of operations: $$$4$$$ $$$3$$$ $$$2$$$ $$$2$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$\rightarrow$$$ $$$5$$$ $$$3$$$.
","input
In the second test, this is one of the optimal sequences of operations: $$$3$$$ $$$3$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$5$$$ $$$4$$$ $$$\rightarrow$$$ $$$6$$$ $$$4$$$.
output
In the third and fourth tests, you can't perform the operation at all.
","dp, greedy",6
"#import sys
#input = sys.stdin.readline
def main():
    R, G, B = map( int, input().split())
    Rs = list( map( int, input().split()))
    Gs = list( map( int, input().split()))
    Bs = list( map( int, input().split()))

    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)

    dp = [[[0]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                t = 0
                if i > 0 and j > 0:
                    if dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1] > t:
                        t = dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1]
                if j > 0 and k > 0:
                    if dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1] > t:
                        t = dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1]
                if k > 0 and i > 0:
                    if dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1] > t:
                        t = dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1]
                dp[i][j][k] = t
                if ans < t:
                    ans = t
    print(ans)
                        

if __name__ == '__main__':
    main()
",1398_D,CODEFORCES,3925,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"from os import path
import sys,time
# mod = int(1e9 + 7)
# import re
from math import ceil, floor,gcd,log,log2 ,factorial
from collections import * 
# from bisect import *
maxx = float('inf')
#----------------------------INPUT FUNCTIONS------------------------------------------#
I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
#left shift --- num*(2**k) --(k - shift)

n , k= tup()
s = S()

fl =0
l = None
for i in range(1, n):
	x =s[i:n]
	for j in range(n):
		if x == s[:j+1]:
			l = j+1
			fl = 1
			break
	if fl :
		break
if fl :
	ans = s + s[l:n]*(k-1)
	print(ans)
else:
	print(s*k)






# n = I()
# ls = [int(i) for i in S()]
# pre , s =[] , 0
# for i in ls:
# 	s+=i
# 	pre.append(s)
# for i in range(n-1):
# 	cnt =0
# 	su =0
# 	for j in range(i+1 , n):
# 		su+=ls[j]
# 		if su == pre[i]:
# 			cnt+=1
# 			su =0
# 	if cnt and su ==0:
# 		print('YES')
# 		exit()
# print('NO')









if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",1029_A,CODEFORCES,3433,Many Equal Substrings,"You are given a string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters and an integer number $$$k$$$.
Let's define a substring of some string $$$s$$$ with indices from $$$l$$$ to $$$r$$$ as $$$s[l \dots r]$$$.
Your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ positions $$$i$$$ such that $$$s[i \dots i + n - 1] = t$$$. In other words, your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
It is guaranteed that the answer is always unique.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 50$$$) — the length of the string $$$t$$$ and the number of substrings.
The second line of the input contains the string $$$t$$$ consisting of exactly $$$n$$$ lowercase Latin letters.
","input
Print such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
output
It is guaranteed that the answer is always unique.
","implementation, strings",5
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq
# sys.setrecursionlimit(100000)
# ^^^TAKE CARE FOR MEMORY LIMIT^^^
import random


def main():
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def binary(n):
    return (bin(n).replace(""0b"", """"))


def decimal(s):
    return (int(s, 2))


def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)


def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)


def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)


def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)


def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum


def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m


def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)


def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c


def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p


def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))


def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s
x,k=map(int,input().split())
mod=1000000007
tp=pow(2,k+1,mod)
tp2=pow(2,k,mod)
ans=(tp*x-tp2+1)%mod
print(ans if x!=0 else 0)
",0992_C,CODEFORCES,1017,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"n = int(input())
lst = list(map(int,input().split()))
lst.sort()
lst.reverse()
m = 0
for i in range(n):
  if sum(lst[:i]) > sum(lst[i:]):
    break
  else:
    m+=1
print(m)",0160_A,CODEFORCES,2316,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"import sys
import bisect
from bisect import bisect_left as lb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()
#sys.setrecursionlimit(10**6)
mod=10**9+7
mod1=998244353
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)
ans=0
def setting(s):
    if s=='0':
        return -1
    i=len(s)-1
    cc=0
    while(i>=0 and s[i]=='0'):
        cc+=1
        i-=1
    return cc
def hnbhai(tc):
    n,q=sd()
    up=n+1
    x=len(bin(n)[2:])-1
    for i in range(q):
        v=sb()
        s=sa()
        for j in s:
            temp=bin(v)[2:]
            abe=setting(temp)
            #print(v,abe)
            if j==""U"":
                if abe>=x:
                    continue
                p=v+(1<<(abe))
                n=v-(1<<(abe))
                x1=setting(bin(p)[2:])
                #print(p,x1)
                x2=setting(bin(n)[2:])
                if x1==abe+1:
                    v=p
                else:
                    v=n
            elif j==""L"":
                if abe<=0:
                    continue
                v=v-(1<<(abe-1))
                #print(""v"",v)
            else:
                if abe<=0:
                    continue
                v=v+(1<<(abe-1))
        print(v)
for _ in range(1):
    hnbhai(_+1)
",0792_D,CODEFORCES,4528,Paths in a Complete Binary Tree,"T is a complete binary tree consisting of n vertices. It means that exactly one vertex is a root, and each vertex is either a leaf (and doesn't have children) or an inner node (and has exactly two children). All leaves of a complete binary tree have the same depth (distance from the root). So n is a number such that n + 1 is a power of 2.
In the picture you can see a complete binary tree with n = 15.
Vertices are numbered from 1 to n in a special recursive way: we recursively assign numbers to all vertices from the left subtree (if current vertex is not a leaf), then assign a number to the current vertex, and then recursively assign numbers to all vertices from the right subtree (if it exists). In the picture vertices are numbered exactly using this algorithm. It is clear that for each size of a complete binary tree exists exactly one way to give numbers to all vertices. This way of numbering is called symmetric.
You have to write a program that for given n answers q queries to the tree.
Each query consists of an integer number ui (1 ≤ ui ≤ n) and a string si, where ui is the number of vertex, and si represents the path starting from this vertex. String si doesn't contain any characters other than 'L', 'R' and 'U', which mean traverse to the left child, to the right child and to the parent, respectively. Characters from si have to be processed from left to right, considering that ui is the vertex where the path starts. If it's impossible to process a character (for example, to go to the left child of a leaf), then you have to skip it. The answer is the number of vertex where the path represented by si ends.
For example, if ui = 4 and si = «UURL», then the answer is 10.
The first line contains two integer numbers n and q (1 ≤ n ≤ 1018, q ≥ 1). n is such that n + 1 is a power of 2.
The next 2q lines represent queries; each query consists of two consecutive lines. The first of these two lines contains ui (1 ≤ ui ≤ n), the second contains non-empty string si. si doesn't contain any characters other than 'L', 'R' and 'U'.
","input
It is guaranteed that the sum of lengths of si (for each i such that 1 ≤ i ≤ q) doesn't exceed 105.
output
Print q numbers, i-th number must be the answer to the i-th query.
","bitmasks, trees",7
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
from collections import defaultdict
from itertools import permutations
 

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
#-------------------game starts now-----------------------------------------------------
n,k=map(int,sys.stdin.readline().split())
 
mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):
    
    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]
        
        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0
ans=sum(dp[k])
ans%=mod
print(ans)",1051_D,CODEFORCES,4578,Bicolorings,"You are given a grid, consisting of $$$2$$$ rows and $$$n$$$ columns. Each cell of this grid should be colored either black or white.
Two cells are considered neighbours if they have a common border and share the same color. Two cells $$$A$$$ and $$$B$$$ belong to the same component if they are neighbours, or if there is a neighbour of $$$A$$$ that belongs to the same component with $$$B$$$.
Let's call some bicoloring beautiful if it has exactly $$$k$$$ components.
Count the number of beautiful bicolorings. The number can be big enough, so print the answer modulo $$$998244353$$$.
The only line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 1000$$$, $$$1 \le k \le 2n$$$) — the number of columns in a grid and the number of components required.
","input
Print a single integer — the number of beautiful bicolorings modulo $$$998244353$$$.
output
One of possible bicolorings in sample $$$1$$$:
","bitmasks, dp",7
"#by Nick ""LordVader"" Proshin
import sys
input = sys.stdin.readline
out = sys.stdout
t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if len(set(a)) == 1:
        print(a[0],a[0],a[0],a[0])
    else:
        a.sort()
        g1 = False
        d = {}
        mx = 10001
        for i in a:
            if i not in d.keys():
                d[i] = 1
            else:
                d[i] += 1
            if d[i] == 4:
                g1 = True
                if i < mx:
                    mx = i
        if g1:
            out.write(str(mx)+"" ""+str(mx)+"" ""+str(mx)+"" ""+str(mx)+""\n"")
        else:
            res = []
            for k in d.keys():
                if d[k] >= 2:
                    res.append(k)
            m = len(res)
            minj = 0
            for j in range(m - 1):
                if res[j]*res[j+1]*(res[minj]**2 + res[minj+1]**2) > res[minj]*res[minj+1]*(res[j]**2+res[j+1]**2):
                    minj = j
            out.write(str(res[minj])+"" ""+str(res[minj])+"" ""+str(res[minj+1])+"" ""+str(res[minj+1])+""\n"")
          ",1027_C,CODEFORCES,2774,Minimum Value Rectangle,"You have $$$n$$$ sticks of the given lengths.
Your task is to choose exactly four of them in such a way that they can form a rectangle. No sticks can be cut to pieces, each side of the rectangle must be formed by a single stick. No stick can be chosen multiple times. It is guaranteed that it is always possible to choose such sticks.
Let $$$S$$$ be the area of the rectangle and $$$P$$$ be the perimeter of the rectangle. 
The chosen rectangle should have the value $$$\frac{P^2}{S}$$$ minimal possible. The value is taken without any rounding.
If there are multiple answers, print any of them.
Each testcase contains several lists of sticks, for each of them you are required to solve the problem separately.
The first line contains a single integer $$$T$$$ ($$$T \ge 1$$$) — the number of lists of sticks in the testcase.
Then $$$2T$$$ lines follow — lines $$$(2i - 1)$$$ and $$$2i$$$ of them describe the $$$i$$$-th list. The first line of the pair contains a single integer $$$n$$$ ($$$4 \le n \le 10^6$$$) — the number of sticks in the $$$i$$$-th list. The second line of the pair contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_j \le 10^4$$$) — lengths of the sticks in the $$$i$$$-th list.
It is guaranteed that for each list there exists a way to choose four sticks so that they form a rectangle.
The total number of sticks in all $$$T$$$ lists doesn't exceed $$$10^6$$$ in each testcase.
Print $$$T$$$ lines. The $$$i$$$-th line should contain the answer to the $$$i$$$-th list of the input. That is the lengths of the four sticks you choose from the $$$i$$$-th list, so that they form a rectangle and the value $$$\frac{P^2}{S}$$$ of this rectangle is minimal possible. You can print these four lengths in arbitrary order.
If there are multiple answers, print any of them.
There is only one way to choose four sticks in the first list, they form a rectangle with sides $$$2$$$ and $$$7$$$, its area is $$$2 \cdot 7 = 14$$$, perimeter is $$$2(2 + 7) = 18$$$. $$$\frac{18^2}{14} \approx 23.143$$$.
","input
The second list contains subsets of four sticks that can form rectangles with sides $$$(1, 2)$$$, $$$(2, 8)$$$ and $$$(1, 8)$$$. Their values are $$$\frac{6^2}{2} = 18$$$, $$$\frac{20^2}{16} = 25$$$ and $$$\frac{18^2}{8} = 40.5$$$, respectively. The minimal one of them is the rectangle $$$(1, 2)$$$.
output
You can choose any four of the $$$5$$$ given sticks from the third list, they will form a square with side $$$5$$$, which is still a rectangle with sides $$$(5, 5)$$$.
",greedy,4
"n, m = map(int, input().split())
a = []
b = []
ma = 0
macount = 0
mi = 1000000000000000000000000000
su = 0
for el in map(int, input().split()):
    if el > ma:
        ma = el
        macount = 1
    elif el == ma:
        macount += 1
    a.append(el)
for el in map(int, input().split()):
    mi = min(el, mi)
    b.append(el)
    su += el
if ma > mi:
    print(-1)
elif ma == mi or macount > 1:
    f = True
    for i in range(n):
        if a[i] == ma and f:
            f = False
        else:
            su += a[i] * m
    print(su)
else:
    secmax = 0
    for el in a:
        if el > secmax and el < ma:
            secmax = el
    f = True
    for i in range(n):
        if a[i] == ma and f:
            f = False
        else:
            su += a[i] * m
    print(su + ma - secmax)
",1159_C,CODEFORCES,2126,The Party and Sweets,"$$$n$$$ boys and $$$m$$$ girls came to the party. Each boy presented each girl some integer number of sweets (possibly zero). All boys are numbered with integers from $$$1$$$ to $$$n$$$ and all girls are numbered with integers from $$$1$$$ to $$$m$$$. For all $$$1 \leq i \leq n$$$ the minimal number of sweets, which $$$i$$$-th boy presented to some girl is equal to $$$b_i$$$ and for all $$$1 \leq j \leq m$$$ the maximal number of sweets, which $$$j$$$-th girl received from some boy is equal to $$$g_j$$$.
More formally, let $$$a_{i,j}$$$ be the number of sweets which the $$$i$$$-th boy give to the $$$j$$$-th girl. Then $$$b_i$$$ is equal exactly to the minimum among values $$$a_{i,1}, a_{i,2}, \ldots, a_{i,m}$$$ and $$$g_j$$$ is equal exactly to the maximum among values $$$b_{1,j}, b_{2,j}, \ldots, b_{n,j}$$$.
You are interested in the minimum total number of sweets that boys could present, so you need to minimize the sum of $$$a_{i,j}$$$ for all $$$(i,j)$$$ such that $$$1 \leq i \leq n$$$ and $$$1 \leq j \leq m$$$. You are given the numbers $$$b_1, \ldots, b_n$$$ and $$$g_1, \ldots, g_m$$$, determine this number. 
The first line contains two integers $$$n$$$ and $$$m$$$, separated with space — the number of boys and girls, respectively ($$$2 \leq n, m \leq 100\,000$$$). The second line contains $$$n$$$ integers $$$b_1, \ldots, b_n$$$, separated by spaces — $$$b_i$$$ is equal to the minimal number of sweets, which $$$i$$$-th boy presented to some girl ($$$0 \leq b_i \leq 10^8$$$). The third line contains $$$m$$$ integers $$$g_1, \ldots, g_m$$$, separated by spaces — $$$g_j$$$ is equal to the maximal number of sweets, which $$$j$$$-th girl received from some boy ($$$0 \leq g_j \leq 10^8$$$).
If the described situation is impossible, print $$$-1$$$. In another case, print the minimal total number of sweets, which boys could have presented and all conditions could have satisfied.
In the first test, the minimal total number of sweets, which boys could have presented is equal to $$$12$$$. This can be possible, for example, if the first boy presented $$$1$$$ and $$$4$$$ sweets, the second boy presented $$$3$$$ and $$$2$$$ sweets and the third boy presented $$$1$$$ and $$$1$$$ sweets for the first and the second girl, respectively. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$12$$$.
","input
In the second test, the boys couldn't have presented sweets in such way, that all statements satisfied.
output
In the third test, the minimal total number of sweets, which boys could have presented is equal to $$$4$$$. This can be possible, for example, if the first boy presented $$$1$$$, $$$1$$$, $$$2$$$ sweets for the first, second, third girl, respectively and the second boy didn't present sweets for each girl. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$4$$$.
","greedy, implementation, math",3
"import math

types_of_toy , toy_pair = map(int,input().split())

if(toy_pair <= types_of_toy ):
    print(math.floor( ( toy_pair - 1 ) /2))
elif( toy_pair <= 2*types_of_toy - 1):
    print(math.floor( ( types_of_toy +1 -(toy_pair - types_of_toy) )/ 2)) 
else:
    print(0)


",1023_B,CODEFORCES,418,Pair of Toys,"Tanechka is shopping in the toy shop. There are exactly $$$n$$$ toys in the shop for sale, the cost of the $$$i$$$-th toy is $$$i$$$ burles. She wants to choose two toys in such a way that their total cost is $$$k$$$ burles. How many ways to do that does she have?
Each toy appears in the shop exactly once. Pairs $$$(a, b)$$$ and $$$(b, a)$$$ are considered equal. Pairs $$$(a, b)$$$, where $$$a=b$$$, are not allowed.
The first line of the input contains two integers $$$n$$$, $$$k$$$ ($$$1 \le n, k \le 10^{14}$$$) — the number of toys and the expected total cost of the pair of toys.
Print the number of ways to choose the pair of toys satisfying the condition above. Print 0, if Tanechka can choose no pair of toys in such a way that their total cost is $$$k$$$ burles.
In the first example Tanechka can choose the pair of toys ($$$1, 4$$$) or the pair of toys ($$$2, 3$$$).
In the second example Tanechka can choose only the pair of toys ($$$7, 8$$$).
","input
In the third example choosing any pair of toys will lead to the total cost less than $$$20$$$. So the answer is 0.
output
In the fourth example she can choose the following pairs: $$$(1, 1000000000000)$$$, $$$(2, 999999999999)$$$, $$$(3, 999999999998)$$$, ..., $$$(500000000000, 500000000001)$$$. The number of such pairs is exactly $$$500000000000$$$.
",math,1
"n = int(input())
if n==0:
    print(*[0,0,0])
elif n==1:
    print(*[0,0,1])
else:
    prev2 = 0
    prev1 = 1
    prev = 1
    while prev!=n:
        curr = prev+prev1
        prev2 = prev1
        prev1 = prev
        prev = curr
    print(*[0,prev2,prev1])
",0199_A,CODEFORCES,64,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"n = int(input())
arr = list(map(int, input().strip().split()))
k = min(arr)
h = max(arr)
s = 0
for i in arr:
    if i >= 0:
        s += i
    else:
        s -= i

if n == 1:
    print(arr[0])
elif ((k < 0 and h >= 0)):
    print(s)
else:
    if (k >= 0):
        print(s - 2 * k)
    else:
        print(s + 2 * h)",1038_D,CODEFORCES,1948,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation",3
"# from math import ceil
#
#
# n, k = map(int, input().split())
# lst = [0] * k
# sets = ceil(n/2)
# stud = 0
# for i in range(n):
#     temp = int(input())
#     if sets == 0:
#         continue
#     for i in range(1, k+1):
#         if temp ==  i:
#             if lst[i-1] == 0:
#                 lst[i-1] += 1
#             else:
#                 sets -= 1
#                 lst[i-1] = 0
#                 stud += 2
# if sets == 0:
#     print(stud)
# else:
#     print(stud + sets)
from math import sqrt
n, k = map(int, input().split())
a = 1
b = -1 * (2*n + 3)
c = n * (n + 1) - 2 * k

res = (-1 * b) - sqrt((b * b) - 4 * a * c)
res = res / 2
res = int(res)
print(res)
",1195_B,CODEFORCES,1365,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"def cross(a, b):
    return a[0] * b[1] - a[1] * b[0]


def f(v, i1, i2):
    d = [v[i2][i] - v[i1][i] for i in range(len(v[i1]))]

    res = []
    for x in v:
        d2 = [x[i] - v[i1][i] for i in range(len(v[i1]))]
        if cross(d, d2) != 0:
            res.append(x)

    return res


n = int(input())
if n <= 4:
    print(""YES"")
    exit(0)

v = []
for i in range(n):
    v.append(list(map(int, input().split())))

ok = False
for first in range(3):
    if ok:
        break

    for second in range(first+1, 3):
        other = f(v, first, second)

        if len(other) <= 2:
            ok = True
            break

        remainder = f(other, 0, 1)

        if not remainder:
            ok = True


if ok:
    print(""YES"")
else:
    print(""NO"")
",0961_D,CODEFORCES,2496,Pair Of Lines,"You are given n points on Cartesian plane. Every point is a lattice point (i. e. both of its coordinates are integers), and all points are distinct.
You may draw two straight lines (not necessarily distinct). Is it possible to do this in such a way that every point lies on at least one of these lines?
The first line contains one integer n (1 ≤ n ≤ 105) — the number of points you are given.
Then n lines follow, each line containing two integers xi and yi (|xi|, |yi| ≤ 109)— coordinates of i-th point. All n points are distinct.
","input
If it is possible to draw two straight lines in such a way that each of given points belongs to at least one of these lines, print YES. Otherwise, print NO.
output
In the first example it is possible to draw two lines, the one containing the points 1, 3 and 5, and another one containing two remaining points.
",geometry,4
"
import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
 
n,x,y=map(int,input().split())
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))
y+=x
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",1463_F,CODEFORCES,4715,Max Correct Set,"Let's call the set of positive integers $$$S$$$ correct if the following two conditions are met: 
For the given values $$$n$$$, $$$x$$$, and $$$y$$$, you have to find the maximum size of the correct set.
","input
A single line contains three integers $$$n$$$, $$$x$$$ and $$$y$$$ ($$$1 \le n \le 10^9$$$; $$$1 \le x, y \le 22$$$). 
output
Print one integer — the maximum size of the correct set.
","bitmasks, dp, math",7
"#!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase


def main():
    from math import sqrt
    for _ in range(int(input())):
        n = int(input())
        if (round(sqrt(n)) ** 2 == n and n % 2 == 0) or round(sqrt(n * 2)) ** 2 == 2 * n:
            print(""YES"")
        else:
            print(""NO"")


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()",1515_B,CODEFORCES,758,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",1
"a = list(map(int, input().split()))

ans = 0
for i in range(len(a)):
    x = a[i]
    b = [j for j in a]
    b[i] = 0
    for j in range(len(a)):
        b[j] += x // 14
    
    for j in range(1, x % 14 + 1):
        b[(i + j) % 14] += 1
        
    ans_now = 0
    for j in b:
        if j % 2 == 0:
            ans_now += j
    ans = max(ans_now, ans)
print(ans)",0975_B,CODEFORCES,313,Mancala,"Mancala is a game famous in the Middle East. It is played on a board that consists of 14 holes. 
Initially, each hole has $$$a_i$$$ stones. When a player makes a move, he chooses a hole which contains a positive number of stones. He takes all the stones inside it and then redistributes these stones one by one in the next holes in a counter-clockwise direction.
Note that the counter-clockwise order means if the player takes the stones from hole $$$i$$$, he will put one stone in the $$$(i+1)$$$-th hole, then in the $$$(i+2)$$$-th, etc. If he puts a stone in the $$$14$$$-th hole, the next one will be put in the first hole.
After the move, the player collects all the stones from holes that contain even number of stones. The number of stones collected by player is the score, according to Resli.
Resli is a famous Mancala player. He wants to know the maximum score he can obtain after one move.
The only line contains 14 integers $$$a_1, a_2, \ldots, a_{14}$$$ ($$$0 \leq a_i \leq 10^9$$$) — the number of stones in each hole.
It is guaranteed that for any $$$i$$$ ($$$1\leq i \leq 14$$$) $$$a_i$$$ is either zero or odd, and there is at least one stone in the board.
","input
Output one integer, the maximum possible score after one move.
output
In the first test case the board after the move from the hole with $$$7$$$ stones will look like 1 2 2 0 0 0 0 0 0 0 1 1 1 1. Then the player collects the even numbers and ends up with a score equal to $$$4$$$.
","bruteforce, implementation",1
"import sys
import math
#import random
#sys.setrecursionlimit(100000000)
input = sys.stdin.readline
 
############ ---- USER DEFINED INPUT FUNCTIONS ---- ############
def inp():
    return(int(input()))
def inara():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
################################################################
############ ---- THE ACTUAL CODE STARTS BELOW ---- ############

n,k=invr()

ans=0
lo=0
hi=n

def possible(a,b):
	koyta=a*(a+1)//2
	return koyta>=b+k

while hi>=lo:
	mid=(hi+lo)//2
	
	if possible(n-mid,mid):
		lo=mid+1
		ans=mid
	else:
		hi=mid-1

print(ans)

",1195_B,CODEFORCES,1403,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"a = list(input())
b = list(input())
n = len(a)
a.sort()

def listtostring(li:list):
    return ''.join(li)


for i in range(0,n):
    for j in range(0,n):
        t = a.copy()
        t[i],t[j] = t[j],t[i]
        if((int(listtostring(t)) >= int(listtostring(a))) and (int(listtostring(t))<= int(listtostring(b)))):
         #   print(""BEFORE"",a,a[i],a[j],i,j)
            a[i],a[j] = a[j],a[i]
         #   print(""AFTER"",a,a[i],a[j],i,j)
        
print(listtostring(a))",915C_,CODEFORCES,4206,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"def raschot(d, e, g, h):
    if d > e:
        return 1
    key = d, g, h
    if key in b:
        return b[key]
    f = 0
    for x in (['0', '1'] if a0[d] == '?' else [a0[d]]):
        if d == e:
            a = [x]
        else:
            a = ['0', '1'] if a0[e] == '?' else [a0[e]]
        for y in a:
            if not ((g and x > y) or (h and x == y == '1')):
                f += raschot(d + 1, e - 1, g and x == y, h and x != y)
    b[key] = f
    return f


n, m = map(int, input().split())
m += 1
a0 = ['?'] * n
for i in range(n):
    a0[i] = '0'
    b = {}
    c = raschot(0, n - 1, True, True)
    if m > c:
        m -= c
        a0[i] = '1'
if a0[0] == '0':
    print(''.join(a0))
else:
    print(-1)
",0008_E,CODEFORCES,3689,Beads,"One Martian boy called Zorg wants to present a string of beads to his friend from the Earth — Masha. He knows that Masha likes two colours: blue and red, — and right in the shop where he has come, there is a variety of adornments with beads of these two colours. All the strings of beads have a small fastener, and if one unfastens it, one might notice that all the strings of beads in the shop are of the same length. Because of the peculiarities of the Martian eyesight, if Zorg sees one blue-and-red string of beads first, and then the other with red beads instead of blue ones, and blue — instead of red, he regards these two strings of beads as identical. In other words, Zorg regards as identical not only those strings of beads that can be derived from each other by the string turnover, but as well those that can be derived from each other by a mutual replacement of colours and/or by the string turnover.
It is known that all Martians are very orderly, and if a Martian sees some amount of objects, he tries to put them in good order. Zorg thinks that a red bead is smaller than a blue one. Let's put 0 for a red bead, and 1 — for a blue one. From two strings the Martian puts earlier the string with a red bead in the i-th position, providing that the second string has a blue bead in the i-th position, and the first two beads i - 1 are identical.
At first Zorg unfastens all the strings of beads, and puts them into small heaps so, that in each heap strings are identical, in his opinion. Then he sorts out the heaps and chooses the minimum string in each heap, in his opinion. He gives the unnecassary strings back to the shop assistant and says he doesn't need them any more. Then Zorg sorts out the remaining strings of beads and buys the string with index k. 
All these manupulations will take Zorg a lot of time, that's why he asks you to help and find the string of beads for Masha.
The input file contains two integers n and k (2 ≤ n ≤ 50;1 ≤ k ≤ 1016) —the length of a string of beads, and the index of the string, chosen by Zorg. 
","input
Output the k-th string of beads, putting 0 for a red bead, and 1 — for a blue one. If it s impossible to find the required string, output the only number -1.
output
Let's consider the example of strings of length 4 — 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110. Zorg will divide them into heaps: {0001, 0111, 1000, 1110}, {0010, 0100, 1011, 1101}, {0011, 1100}, {0101, 1010}, {0110, 1001}. Then he will choose the minimum strings of beads in each heap: 0001, 0010, 0011, 0101, 0110. The forth string — 0101.
","dp, graphs",6
"n = int(input())
melody = [int(x) for x in input().split()]
ref = [[-1] * 5 for _ in range(n)]
can_finish = [[False] * 5 for _ in range(n)]
can_finish[0] = [True] * 5

for idx, key in enumerate(melody[:-1]):
    if not any(can_finish[idx]):
        break
    for finger in range(5):
        if melody[idx] < melody[idx + 1] and can_finish[idx][finger]:
            for i in range(finger + 1, 5):
                can_finish[idx + 1][i] = True
                ref[idx + 1][i] = finger
            break
        elif melody[idx] > melody[idx + 1] and can_finish[idx][finger] and finger > 0:
            for i in range(finger):
                can_finish[idx + 1][i] = True
                ref[idx + 1][i] = finger
        elif melody[idx] == melody[idx + 1] and can_finish[idx][finger]:
            tmp_val, tmp_ref = can_finish[idx + 1][finger], ref[idx + 1][finger]
            can_finish[idx + 1] = [True] * 5
            ref[idx + 1] = [finger] * 5
            can_finish[idx + 1][finger], ref[idx + 1][finger] = tmp_val, tmp_ref

finger = next((i for i in range(5) if can_finish[n - 1][i]), None)
if finger is None:
    print(-1)
else:
    seq = [finger]
    for i in range(n - 1, 0, -1):
        finger = ref[i][finger]
        seq.append(finger)
    print(' '.join(str(x + 1) for x in seq[::-1]))
",1032_C,CODEFORCES,3480,Playing Piano,"Little Paul wants to learn how to play piano. He already has a melody he wants to start with. For simplicity he represented this melody as a sequence $$$a_1, a_2, \ldots, a_n$$$ of key numbers: the more a number is, the closer it is to the right end of the piano keyboard.
Paul is very clever and knows that the essential thing is to properly assign fingers to notes he's going to play. If he chooses an inconvenient fingering, he will then waste a lot of time trying to learn how to play the melody by these fingers and he will probably not succeed.
Let's denote the fingers of hand by numbers from $$$1$$$ to $$$5$$$. We call a fingering any sequence $$$b_1, \ldots, b_n$$$ of fingers numbers. A fingering is convenient if for all $$$1\leq i \leq n - 1$$$ the following holds:
Please provide any convenient fingering or find out that there is none.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) denoting the number of notes.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 2\cdot10^5$$$) denoting the positions of notes on the keyboard.
","input
If there is no convenient fingering, print $$$-1$$$. Otherwise, print $$$n$$$ numbers $$$b_1, b_2, \ldots, b_n$$$, each from $$$1$$$ to $$$5$$$, denoting a convenient fingering, separated by spaces.
output
The third sample test is kinda ""Non stop"" song by Reflex.
","constructivealgorithms, dp",5
"def main_function():
    counter = int(input())
    max_counter = 9
    digits_per_number = 1
    while max_counter < counter:
        digits_per_number += 1
        max_counter = max_counter + digits_per_number * 9 * 10 ** (digits_per_number - 1)
    max_real_number = int(str(9) * digits_per_number)
    dif  = max_counter - counter
    rem = dif % digits_per_number
    real_number = max_real_number - dif // digits_per_number
    print(str(real_number)[-1-rem])





main_function()",1177_B,CODEFORCES,1246,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"k=int(input())
i=0
r=1
while(k>=r):
    r+=9*(i+1)*10**i
    i+=1
r=r-(9*i*10**(i-1))
ans=str(((k-r)//i)+10**(i-1))[(k-r)%i]
print(ans)",1177_B,CODEFORCES,1251,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"

n=int(input())

x=1

while n>(10**(len(str(x))-1)*9*len(str(x))):
    n-=10**(len(str(x))-1)*9*len(str(x))

    x*=10
    
t=len(str(x))
nadighe=False
while nadighe==False:
    qw=1
    nadighe=True
    while n>(10**(len(str(qw))-1)*9*t):
        n-=10**(len(str(qw))-1)*9*t
        nadighe=False
        qw*=10
    x+=qw-1
   
    
while n>len(str(x)):
    n-=len(str(x))
    x+=1
for i in range(len(str(x))):
    if n!=0:
        s=str(x)[i]
        n-=1
print(s)
    
",1177_B,CODEFORCES,1259,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"s=list(input())
dic={}
for i in range(0,len(s)):
    for j in range(i,len(s)):
        ele="""".join(s[i:j+1])
        if ele not in dic:
            dic[ele]=1
        else:
            dic[ele]+=1
#print(dic)
        
ans=[]        
for key in dic.keys():
    if dic[key]>=2:

        ans.append(len(key))
ans.sort()
if ans==[]:
    print(0)
else:
    
    print(ans[-1])


        
",0023_A,CODEFORCES,3733,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"#!/usr/bin/env python3

n, k, A = map(int, input().rstrip().split())
senators = []
mx_bribe = 0

for i in range(n):
    lvl, loy = map(int, input().rstrip().split())
    senators.append((lvl, loy))
    mx_bribe += (100 - loy) // 10

bribe = [0] * n


def calc(votes):
    bsum, cnt, p = 0, 0, 1.0
    for i, s in enumerate(senators):
        if votes & (1 << i):
            p *= (s[1] + bribe[i]) / 100
            cnt += 1
        else:
            p *= (100 - s[1] - bribe[i]) / 100
            bsum += s[0]

    if cnt > (n / 2):
        return p
    else:
        return p * A / (A + bsum)


def dfs(cur, rk):
    if cur >= n:
        if rk > 0:
            return 0.0
        sm = 0.0
        for i in range(1 << n):
            sm += calc(i)

        return sm

    mx = 0.0
    for i in range(rk + 1):
        if i * 10 + senators[cur][1] > 100:
            break
        bribe[cur] = i * 10
        tmp = dfs(cur+1, rk-i)
        mx = max(tmp, mx)
    return mx


print(dfs(0, min(k, mx_bribe)))
",0105_B,CODEFORCES,4286,Dark Assembly,"Dark Assembly is a governing body in the Netherworld. Here sit the senators who take the most important decisions for the player. For example, to expand the range of the shop or to improve certain characteristics of the character the Dark Assembly's approval is needed.
The Dark Assembly consists of n senators. Each of them is characterized by his level and loyalty to the player. The level is a positive integer which reflects a senator's strength. Loyalty is the probability of a positive decision in the voting, which is measured as a percentage with precision of up to 10%. 
Senators make decisions by voting. Each of them makes a positive or negative decision in accordance with their loyalty. If strictly more than half of the senators take a positive decision, the player's proposal is approved. 
If the player's proposal is not approved after the voting, then the player may appeal against the decision of the Dark Assembly. To do that, player needs to kill all the senators that voted against (there's nothing wrong in killing senators, they will resurrect later and will treat the player even worse). The probability that a player will be able to kill a certain group of senators is equal to A / (A + B), where A is the sum of levels of all player's characters and B is the sum of levels of all senators in this group. If the player kills all undesired senators, then his proposal is approved.
Senators are very fond of sweets. They can be bribed by giving them candies. For each received candy a senator increases his loyalty to the player by 10%. It's worth to mention that loyalty cannot exceed 100%. The player can take no more than k sweets to the courtroom. Candies should be given to the senators before the start of voting.
Determine the probability that the Dark Assembly approves the player's proposal if the candies are distributed among the senators in the optimal way.
The first line contains three integers n, k and A (1 ≤ n, k ≤ 8, 1 ≤ A ≤ 9999).
Then n lines follow. The i-th of them contains two numbers — bi and li — the i-th senator's level and his loyalty.
The levels of all senators are integers in range from 1 to 9999 (inclusive). The loyalties of all senators are integers in range from 0 to 100 (inclusive) and all of them are divisible by 10.
Print one real number with precision 10 - 6 — the maximal possible probability that the Dark Assembly approves the player's proposal for the best possible distribution of candies among the senators.
","input
In the first sample the best way of candies' distribution is giving them to first three of the senators. It ensures most of votes.
output
It the second sample player should give all three candies to the fifth senator.
","bruteforce, probabilities",7
"def get_smallest(m, l):
    res = ''
    for i in ""0123456789"":
        if m.get(i, 0):
            if i == l:
                res += i * (m[i] - 1)
            else:
                res += i * m[i]
    return res 

a = input()
b = input()

if len(a) < len(b):
    a = sorted(a)
    a.reverse()
    print(''.join(a))
elif a == b:
    print(a)
else:
    cmap = dict()
    for i in a:
        cmap[i] = cmap.get(i, 0) + 1

    cur = 0
    res = ''
    gm = False 

    while cur < len(a):
        for i in ""9876543210"":
            if cmap.get(i, 0):
                if cur == len(a) - 1 or i < b[cur] or gm:
                    res += i
                    cmap[i] -= 1
                    gm = True
                    break
                elif i == b[cur]:
                    if get_smallest(cmap, i) <= b[cur + 1:]:
                        res += i
                        cmap[i] -= 1
                        break
        cur += 1

    print(res)",915C_,CODEFORCES,4232,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################
import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math 


alphabets = list('abcdefghijklmnopqrstuvwxyz')


def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):
    """"""
    L is a list.
    The function returns the power set, but as a list of lists.
    """"""
    cardinality=len(L)
    n=2 ** cardinality
    powerset = []
    
    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
        
    #the function could stop here closing with
    #return powerset

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)
        
    return powerset_orderred
def fastPlrintNextLines(a):
    # 12
    # 3
    # 1
    #like this
    #a is list of strings
    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

#__________________________TEMPLATE__________________OVER_______________________________________________________


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
# else:
#     input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1
# t = int(input())
for _ in range(t):
    n,m = li()
    s = list(si())
    t = list(si())
    if '*' not in s:
        if s==t:
            print(""YES"")
        else:
            print(""NO"")
        continue
    i = s.index('*')
    if s[:i]==t[:i]:
        s = s[i:]
        t = t[i:]
        s=s[::-1]
        t = t[::-1]
        i = s.index('*')
        
        if len(t)>=i and s[:i]==t[:i]:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")
    
",1023_A,CODEFORCES,1861,Single Wildcard Pattern Matching,"You are given two strings $$$s$$$ and $$$t$$$. The string $$$s$$$ consists of lowercase Latin letters and at most one wildcard character '*', the string $$$t$$$ consists only of lowercase Latin letters. The length of the string $$$s$$$ equals $$$n$$$, the length of the string $$$t$$$ equals $$$m$$$.
The wildcard character '*' in the string $$$s$$$ (if any) can be replaced with an arbitrary sequence (possibly empty) of lowercase Latin letters. No other character of $$$s$$$ can be replaced with anything. If it is possible to replace a wildcard character '*' in $$$s$$$ to obtain a string $$$t$$$, then the string $$$t$$$ matches the pattern $$$s$$$.
For example, if $$$s=$$$""aba*aba"" then the following strings match it ""abaaba"", ""abacaba"" and ""abazzzaba"", but the following strings do not match: ""ababa"", ""abcaaba"", ""codeforces"", ""aba1aba"", ""aba?aba"".
If the given string $$$t$$$ matches the given string $$$s$$$, print ""YES"", otherwise print ""NO"".
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 2 \cdot 10^5$$$) — the length of the string $$$s$$$ and the length of the string $$$t$$$, respectively.
The second line contains string $$$s$$$ of length $$$n$$$, which consists of lowercase Latin letters and at most one wildcard character '*'.
The third line contains string $$$t$$$ of length $$$m$$$, which consists only of lowercase Latin letters.
Print ""YES"" (without quotes), if you can obtain the string $$$t$$$ from the string $$$s$$$. Otherwise print ""NO"" (without quotes).
In the first example a wildcard character '*' can be replaced with a string ""force"". So the string $$$s$$$ after this replacement is ""codeforces"" and the answer is ""YES"".
In the second example a wildcard character '*' can be replaced with an empty string. So the string $$$s$$$ after this replacement is ""vkcup"" and the answer is ""YES"".
","input
There is no wildcard character '*' in the third example and the strings ""v"" and ""k"" are different so the answer is ""NO"".
output
In the fourth example there is no such replacement of a wildcard character '*' that you can obtain the string $$$t$$$ so the answer is ""NO"".
","bruteforce, implementation, strings",3
"import sys
import math
import collections
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n,k=get_ints()
    arr=get_list()
    ans=0
    for i in range(n):
        val=arr[i]
        c=1
        sol=0
        if c >= k:
            sol = max(sol, val / c)
        for j in range(i+1,n):
            val+=arr[j]
            c+=1
            if c>=k:
                sol=max(sol,val/c)
        ans=max(sol,ans)
    print(ans)",1003_C,CODEFORCES,3342,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math",5
"import sys     
import math as mt
import bisect
input=sys.stdin.readline
#t=int(input())
t=1
def ncr_util():
    inv[0]=inv[1]=1
    fact[0]=fact[1]=1
    for i in range(2,300001):
        inv[i]=(inv[i%p]*(p-p//i))%p
    for i in range(1,300001):
        inv[i]=(inv[i-1]*inv[i])%p
        fact[i]=(fact[i-1]*i)%p
def solve():
    a=1
    b=2*n+3
    c=n+n**2-2*k
    x1=b+int(mt.sqrt(b**2-4*a*c))
    x2=b-int(mt.sqrt(b**2-4*a*c))
    if x1%2==0 and x1//2<=n:
        return x1//2
    return x2//2    
        
    
for _ in range(t):
    #n=int(input())
    #n1=int(input())
    #s=input()
    #n=int(input())
    n,k=(map(int,input().split()))
    #n1=n
    #a=int(input())
    #b=int(input())
    #a,b,c,r=map(int,input().split())
    #x2,y2=map(int,input().split())
    #n=int(input())
    #s=input()
    #s1=input()
    #p=input()
    #l=list(map(int,input().split()))
    #l=str(n)
    #l.sort(reverse=True)
    #l2.sort(reverse=True)
    #l1.sort(reverse=True)
    print(solve())            
        ",1195_B,CODEFORCES,1416,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"n,k=map(int,input().split())
l=[]
for i in range(n):
   manan,surbhi=map(int,input().split())
   l.append((manan,surbhi))

l.sort(key=lambda x:(x[0], -x[1]),reverse=True)
ans=1
ps=l[k-1][0]
tp=l[k-1][1]
for i in range(k,n):
    if l[i][0]==ps and l[i][1]==tp:
        ans+=1
    else:
        break
for i in range(k-2,-1,-1):
    if l[i][0]==ps and l[i][1]==tp:
        ans+=1
    else:
        break
             
print(ans)
",0166_A,CODEFORCES,2333,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"import sys, os

numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)

base = []
out = []

for i in range(n):
    x = numbs[i]
    how = 0
    
    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep
    
    if x:
        how |= 1 << i

        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))
    
        out.append(0)
    else:
        outind = len(out)
        out.append(-1)
        
        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind

os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))
",0504_D,CODEFORCES,4383,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks,7
"def pow2(n):
    j=0
    while(n%2==0):
        n//=2
        j+=1
    return j    
n,q=map(int,input().split())
for j in range(q):
    u=int(input())
    s=input()
    for k in range(len(s)):
        num=pow2(u)
        if(s[k]==""R"" and num!=0):
            u=u+2**(num-1)
        elif(s[k]==""L"" and num!=0):
            u=u-2**(num-1)
        elif(s[k]==""U"" and u!=(n+1)//2):
            m1=u+2**(num)
            m2=u-2**(num)
            if(pow2(m1)==(num+1)):
                u=m1
            else:
                u=m2
    print(u)                ",0792_D,CODEFORCES,4537,Paths in a Complete Binary Tree,"T is a complete binary tree consisting of n vertices. It means that exactly one vertex is a root, and each vertex is either a leaf (and doesn't have children) or an inner node (and has exactly two children). All leaves of a complete binary tree have the same depth (distance from the root). So n is a number such that n + 1 is a power of 2.
In the picture you can see a complete binary tree with n = 15.
Vertices are numbered from 1 to n in a special recursive way: we recursively assign numbers to all vertices from the left subtree (if current vertex is not a leaf), then assign a number to the current vertex, and then recursively assign numbers to all vertices from the right subtree (if it exists). In the picture vertices are numbered exactly using this algorithm. It is clear that for each size of a complete binary tree exists exactly one way to give numbers to all vertices. This way of numbering is called symmetric.
You have to write a program that for given n answers q queries to the tree.
Each query consists of an integer number ui (1 ≤ ui ≤ n) and a string si, where ui is the number of vertex, and si represents the path starting from this vertex. String si doesn't contain any characters other than 'L', 'R' and 'U', which mean traverse to the left child, to the right child and to the parent, respectively. Characters from si have to be processed from left to right, considering that ui is the vertex where the path starts. If it's impossible to process a character (for example, to go to the left child of a leaf), then you have to skip it. The answer is the number of vertex where the path represented by si ends.
For example, if ui = 4 and si = «UURL», then the answer is 10.
The first line contains two integer numbers n and q (1 ≤ n ≤ 1018, q ≥ 1). n is such that n + 1 is a power of 2.
The next 2q lines represent queries; each query consists of two consecutive lines. The first of these two lines contains ui (1 ≤ ui ≤ n), the second contains non-empty string si. si doesn't contain any characters other than 'L', 'R' and 'U'.
","input
It is guaranteed that the sum of lengths of si (for each i such that 1 ≤ i ≤ q) doesn't exceed 105.
output
Print q numbers, i-th number must be the answer to the i-th query.
","bitmasks, trees",7
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

# ------------------------------


def main():
    n = N()
    arr = RLL()

    dp = [[n]*n for i in range(n)]
    rec = [[0]*n for i in range(n)]

    for i in range(n):
        rec[i][i] = arr[i]
        dp[i][i] = 1

    for le in range(2, n+1):
        for l in range(n):
            r = l+le-1
            if r>n-1: break
            for m in range(l, r):
                dp[l][r] = min(dp[l][r], dp[l][m] + dp[m+1][r])

                if rec[l][m]==rec[m+1][r] and dp[l][m]==dp[m+1][r]==1:
                    dp[l][r] = 1
                    rec[l][r] = rec[l][m]+1
    print(dp[0][-1])


if __name__ == ""__main__"":
    main()

",1312_E,CODEFORCES,3870,Array Shrinking,"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation any number of times:
After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array $$$a$$$ you can get?
The first line contains the single integer $$$n$$$ ($$$1 \le n \le 500$$$) — the initial length of the array $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$) — the initial array $$$a$$$.
Print the only integer — the minimum possible length you can get after performing the operation described above any number of times.
In the first test, this is one of the optimal sequences of operations: $$$4$$$ $$$3$$$ $$$2$$$ $$$2$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$\rightarrow$$$ $$$5$$$ $$$3$$$.
","input
In the second test, this is one of the optimal sequences of operations: $$$3$$$ $$$3$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$5$$$ $$$4$$$ $$$\rightarrow$$$ $$$6$$$ $$$4$$$.
output
In the third and fourth tests, you can't perform the operation at all.
","dp, greedy",6
"n,k= map(int,input().split(' '))
l= list(map(int,input().split(' ')))
f =list(map(int,input().split(' ')))
h=list(map(int,input().split(' ')))
d1=dict({(a,0) for a in f})
d2=dict({(a,0) for a in f})
for a in l:
	if(a in d1):d1[a]+=1
for a in f:
	d2[a]+=1
#print(d1,d2)
dp = [[0 for i in range(520*12)] for j in range(520)]
#print(len(dp), len(dp[0]))
for x in range(n+1):
	for y in range(n*k+1):
		for i in range(k+1):
				dp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )
ss=0
for i in d1:
	#print(dp[d1[i]][d2[i]])
	ss+=dp[d2[i]][d1[i]]
print(ss)",0999_F,CODEFORCES,3779,Cards and Joy,"There are $$$n$$$ players sitting at the card table. Each player has a favorite number. The favorite number of the $$$j$$$-th player is $$$f_j$$$.
There are $$$k \cdot n$$$ cards on the table. Each card contains a single integer: the $$$i$$$-th card contains number $$$c_i$$$. Also, you are given a sequence $$$h_1, h_2, \dots, h_k$$$. Its meaning will be explained below.
The players have to distribute all the cards in such a way that each of them will hold exactly $$$k$$$ cards. After all the cards are distributed, each player counts the number of cards he has that contains his favorite number. The joy level of a player equals $$$h_t$$$ if the player holds $$$t$$$ cards containing his favorite number. If a player gets no cards with his favorite number (i.e., $$$t=0$$$), his joy level is $$$0$$$.
Print the maximum possible total joy levels of the players after the cards are distributed. Note that the sequence $$$h_1, \dots, h_k$$$ is the same for all the players.
The first line of input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 500, 1 \le k \le 10$$$) — the number of players and the number of cards each player will get.
The second line contains $$$k \cdot n$$$ integers $$$c_1, c_2, \dots, c_{k \cdot n}$$$ ($$$1 \le c_i \le 10^5$$$) — the numbers written on the cards.
The third line contains $$$n$$$ integers $$$f_1, f_2, \dots, f_n$$$ ($$$1 \le f_j \le 10^5$$$) — the favorite numbers of the players.
The fourth line contains $$$k$$$ integers $$$h_1, h_2, \dots, h_k$$$ ($$$1 \le h_t \le 10^5$$$), where $$$h_t$$$ is the joy level of a player if he gets exactly $$$t$$$ cards with his favorite number written on them. It is guaranteed that the condition $$$h_{t - 1} < h_t$$$ holds for each $$$t \in [2..k]$$$.
Print one integer — the maximum possible total joy levels of the players among all possible card distributions.
In the first example, one possible optimal card distribution is the following:
","input
Thus, the answer is $$$2 + 6 + 6 + 7 = 21$$$.
output
In the second example, no player can get a card with his favorite number. Thus, the answer is $$$0$$$.
",dp,6
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n,m=get_ints()
    space=0
    saved=[]
    for i in range(n):
        a,b=get_ints()
        space+=a
        saved.append(a-b)
    saved.sort(reverse=True)
    if space-sum(saved)>m:
        print(-1)
        continue
    i=0
    count=0
    if space<=m:
        print(0)
        continue
    while i<n:
        count+=1
        space-=saved[i]
        if space<=m:
            print(count)
            break
        i+=1",1015_C,CODEFORCES,2743,Songs Compression,"Ivan has $$$n$$$ songs on his phone. The size of the $$$i$$$-th song is $$$a_i$$$ bytes. Ivan also has a flash drive which can hold at most $$$m$$$ bytes in total. Initially, his flash drive is empty.
Ivan wants to copy all $$$n$$$ songs to the flash drive. He can compress the songs. If he compresses the $$$i$$$-th song, the size of the $$$i$$$-th song reduces from $$$a_i$$$ to $$$b_i$$$ bytes ($$$b_i < a_i$$$).
Ivan can compress any subset of the songs (possibly empty) and copy all the songs to his flash drive if the sum of their sizes is at most $$$m$$$. He can compress any subset of the songs (not necessarily contiguous).
Ivan wants to find the minimum number of songs he needs to compress in such a way that all his songs fit on the drive (i.e. the sum of their sizes is less than or equal to $$$m$$$).
If it is impossible to copy all the songs (even if Ivan compresses all the songs), print ""-1"". Otherwise print the minimum number of songs Ivan needs to compress.
The first line of the input contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 10^9$$$) — the number of the songs on Ivan's phone and the capacity of Ivan's flash drive.
The next $$$n$$$ lines contain two integers each: the $$$i$$$-th line contains two integers $$$a_i$$$ and $$$b_i$$$ ($$$1 \le a_i, b_i \le 10^9$$$, $$$a_i > b_i$$$) — the initial size of the $$$i$$$-th song and the size of the $$$i$$$-th song after compression.
If it is impossible to compress a subset of the songs in such a way that all songs fit on the flash drive, print ""-1"". Otherwise print the minimum number of the songs to compress.
","input
In the first example Ivan can compress the first and the third songs so after these moves the sum of sizes will be equal to $$$8 + 7 + 1 + 5 = 21 \le 21$$$. Also Ivan can compress the first and the second songs, then the sum of sizes will be equal $$$8 + 4 + 3 + 5 = 20 \le 21$$$. Note that compressing any single song is not sufficient to copy all the songs on the flash drive (for example, after compressing the second song the sum of sizes will be equal to $$$10 + 4 + 3 + 5 = 22 > 21$$$).
output
In the second example even if Ivan compresses all the songs the sum of sizes will be equal $$$8 + 4 + 1 + 4 = 17 > 16$$$.
",sortings,4
"from bisect import bisect_left


if __name__ == ""__main__"":
    n, m = map(int, raw_input().split())
    verticals = [int(raw_input()) for _ in range(n)]
    h = [map(int, raw_input().split()) for _ in range(m)]
    horizontals = [t[1] for t in h if t[0] == 1] 

    verticals.sort()
    horizontals.sort()
    verticals.append(10**9)
    min_blockers = n + m
    for i, v in enumerate(verticals):
        cur_blockers = len(horizontals) - bisect_left(horizontals, v) + i
        min_blockers = min(min_blockers, cur_blockers)

    print(min_blockers)
",1075_C,CODEFORCES,2887,The Tower is Going Home,"On a chessboard with a width of $$$10^9$$$ and a height of $$$10^9$$$, the rows are numbered from bottom to top from $$$1$$$ to $$$10^9$$$, and the columns are numbered from left to right from $$$1$$$ to $$$10^9$$$. Therefore, for each cell of the chessboard you can assign the coordinates $$$(x,y)$$$, where $$$x$$$ is the column number and $$$y$$$ is the row number.
Every day there are fights between black and white pieces on this board. Today, the black ones won, but at what price? Only the rook survived, and it was driven into the lower left corner — a cell with coordinates $$$(1,1)$$$. But it is still happy, because the victory has been won and it's time to celebrate it! In order to do this, the rook needs to go home, namely — on the upper side of the field (that is, in any cell that is in the row with number $$$10^9$$$).
Everything would have been fine, but the treacherous white figures put spells on some places of the field before the end of the game. There are two types of spells: 
Let's recall that the rook is a chess piece that in one move can move to any point that is in the same row or column with its initial position. In our task, the rook can move from the cell $$$(r_0,c_0)$$$ into the cell $$$(r_1,c_1)$$$ only under the condition that $$$r_1 = r_0$$$ or $$$c_1 = c_0$$$ and there is no blocking lines or blocking segments between these cells (For better understanding, look at the samples).
Fortunately, the rook can remove spells, but for this it has to put tremendous efforts, therefore, it wants to remove the minimum possible number of spells in such way, that after this it can return home. Find this number!
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$0 \le n,m \le 10^5$$$) — the number of vertical and horizontal spells.
Each of the following $$$n$$$ lines contains one integer $$$x$$$ ($$$1 \le x < 10^9$$$) — the description of the vertical spell. It will create a blocking line between the columns of $$$x$$$ and $$$x+1$$$.
Each of the following $$$m$$$ lines contains three integers $$$x_1$$$, $$$x_2$$$ and $$$y$$$ ($$$1 \le x_{1} \le x_{2} \le 10^9$$$, $$$1 \le y < 10^9$$$) — the numbers that describe the horizontal spell. It will create a blocking segment that passes through the top sides of the cells that are in the row with the number $$$y$$$, in columns from $$$x_1$$$ to $$$x_2$$$ inclusive.
It is guaranteed that all spells are different, as well as the fact that for each pair of horizontal spells it is true that the segments that describe them do not have common points.
In a single line print one integer — the minimum number of spells the rook needs to remove so it can get from the cell $$$(1,1)$$$ to at least one cell in the row with the number $$$10^9$$$
In the first sample, in order for the rook return home, it is enough to remove the second horizontal spell.
In the second sample, in order for the rook to return home, it is enough to remove the only vertical spell. If we tried to remove just one of the horizontal spells, it would not allow the rook to get home, because it would be blocked from above by one of the remaining horizontal spells (either first one or second one), and to the right it would be blocked by a vertical spell.
In the third sample, we have two horizontal spells that go through the whole field. These spells can not be bypassed, so we need to remove both of them.
","input
In the fourth sample, we have no spells, which means that we do not need to remove anything.
output
In the fifth example, we can remove the first vertical and third horizontal spells.
",twopointers,4
"import math
n, r = list(map(int, input().split(' ')))
l = 2 * r * math.sin(math.pi/n)
R = l * r / (-l + 2*r)
print(R)",1100_C,CODEFORCES,661,NN and the Optical Illusion,"NN is an experienced internet user and that means he spends a lot of time on the social media. Once he found the following image on the Net, which asked him to compare the sizes of inner circles:
It turned out that the circles are equal. NN was very surprised by this fact, so he decided to create a similar picture himself.
He managed to calculate the number of outer circles $$$n$$$ and the radius of the inner circle $$$r$$$. NN thinks that, using this information, you can exactly determine the radius of the outer circles $$$R$$$ so that the inner circle touches all of the outer ones externally and each pair of neighboring outer circles also touches each other. While NN tried very hard to guess the required radius, he didn't manage to do that. 
Help NN find the required radius for building the required picture.
The first and the only line of the input file contains two numbers $$$n$$$ and $$$r$$$ ($$$3 \leq n \leq 100$$$, $$$1 \leq r \leq 100$$$) — the number of the outer circles and the radius of the inner circle respectively.
Output a single number $$$R$$$ — the radius of the outer circle required for building the required picture. 
","input
Your answer will be accepted if its relative or absolute error does not exceed $$$10^{-6}$$$.
output
Formally, if your answer is $$$a$$$ and the jury's answer is $$$b$$$. Your answer is accepted if and only when $$$\frac{|a-b|}{max(1, |b|)} \le 10^{-6}$$$.
","binarysearch, geometry, math",1
"from collections import deque
from collections import OrderedDict
import math
 
import sys
import os
import threading
import bisect
 
import operator
 
import heapq
 
 
from atexit import register
from io import BytesIO
 
#sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
#sys.stdout = BytesIO()
#register(lambda: os.write(1, sys.stdout.getvalue()))
 
 
import io
#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
#sys.stdin = open(""F:\PY\\test.txt"", ""r"")
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#input = sys.stdin.readline

#a = [int(x) for x in input().split()]




r,g,b = map(int, input().split())
a = []
for i in range(3):
    a.append([int(x) for x in input().split()])
    a[i].sort(reverse=True)

dp = [[[0 for i in range(205)] for j in range(205)] for k in range(205)]
answer = 0

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k], dp[i][j][k]+a[0][i]*a[1][j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1], dp[i][j][k]+a[0][i]*a[2][k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1], dp[i][j][k]+a[1][j]*a[2][k])
            answer=max(answer, dp[i][j][k])
print(answer)
    



sys.exit(0)





class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person(""heelo"", 27)

print(help(Person))


age = 26
name = 'Swaroop'
print('Возрас {} -- {} лет'.format(name, age))
print(help(object))


'''
for _ in range(int(input())):
    
    n = int(input())
    ar = list(map(int, input().split()))
    dp = [0]*100005
    for i in range(n):
        dp[ar[i]]+=1
    ar.clear()
    for i in range(len(dp)):
        if dp[i]!=0:
            ar.append(dp[i])       
    ar.sort()
    maxC = ar[len(ar)-1]
    sumA = sum(ar)
    answer=0
    for i in range(len(ar)):
        if ar[i]==maxC:
            answer+=1
            sumA-=maxC
    answer-=1
    answer+= min(sumA//(maxC-1), len(ar)-1)
    print(answer)
    #sys.exit(0)   
         
    




def maxDisjointIntervals(list_):
    list_.sort(key=lambda x: x[1])
    print(list_[0][0], list_[0][1])
    r1 = list_[0][1]
    for i in range(1, len(list_)):
        l1 = list_[i][0]
        r2 = list_[i][1]
        if l1>r1:
            print(l1, r2)
            r1 = r2

if __name__ ==""__main__1"":
    N=4
    intervals = [[1, 4], [2, 3], [4,6], [8,9]]
    maxDisjointIntervals(intervals)
    
    '''
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    ",1398_D,CODEFORCES,3967,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"def combinations(arr,n):
    if(n==0):
        return([[]])
    l=[]
    for i in range(len(arr)):
        m=arr[i]
        rem=arr[i+1:]
        for j in combinations(rem,n-1):
            l.append([m]+j)
    return l

        
def solve(arr,n,l,r,x):
    subset=[]
    for i in range(2,n+1):
        for j in combinations(arr,i):
            if(sum(j)>=l and sum(j)<=r):
                subset.append(j)
    count=0
    for i in subset:
        mn=min(i)
        mx=max(i)
        if(mx-mn>=x):
            count+=1
                
    return(count)
            
n,l,r,x=map(int,input().split())
arr=list(map(int,input().split()))
print(solve(arr,n,l,r,x))
",0550_B,CODEFORCES,4489,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"import math

t = int(input())


def eval_(n, k):
    level = 0.5*math.log2(3*k+1)
    if n > 30:
        cond = (level - n) > 0
    else:
        cond = (3*k+1) > 4**n
    if cond:
        return ""NO""
    elif n == 2 and k == 3:
        return ""NO""
    else:
        level = math.floor(level)
        # print(level)
        if n > 5:
            # return ""YES "" +  str(n - level)
            temp = 1 + 0.5*math.log2(3*(k-1) + 1)
            if n > temp:
                return ""YES "" + str(n - 1)
            else:
                return ""YES  0""
        else:
            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3
            start = (4**(level)-1)//3
            if k <=(start+delta):
                return ""YES "" + str(n - level)
            else:
                return ""YES "" + str(n - level-1)



for i in range(t):
    (n, k) = [int(i) for i in input().split()]
    print(eval_(n, k))",1080_D,CODEFORCES,1188,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

n = int(input())
a = [list(input()) for i in range(n)]
b = [list(input()) for i in range(n)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(n)] for u in range(n)]
    for t in range(n):
        for u in range(n):
            c[t][u] = b[u][n - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')
",0958_A1,CODEFORCES,3139,Death Stars (easy),"The stardate is 1977 and the science and art of detecting Death Stars is in its infancy. Princess Heidi has received information about the stars in the nearby solar system from the Rebel spies and now, to help her identify the exact location of the Death Star, she needs to know whether this information is correct. 
Two rebel spies have provided her with the maps of the solar system. Each map is an N × N grid, where each cell is either occupied by a star or empty. To see whether the information is correct, Heidi needs to know whether the two maps are of the same solar system, or if possibly one of the spies is actually an Empire double agent, feeding her false information.
Unfortunately, spies may have accidentally rotated a map by 90, 180, or 270 degrees, or flipped it along the vertical or the horizontal axis, before delivering it to Heidi. If Heidi can rotate or flip the maps so that two of them become identical, then those maps are of the same solar system. Otherwise, there are traitors in the Rebel ranks! Help Heidi find out.
The first line of the input contains one number N (1 ≤ N ≤ 10) – the dimension of each map. Next N lines each contain N characters, depicting the first map: 'X' indicates a star, while 'O' indicates an empty quadrant of space. Next N lines each contain N characters, depicting the second map in the same format.
The only line of output should contain the word Yes if the maps are identical, or No if it is impossible to match them by performing rotations and translations.
","input
In the first test, you can match the first map to the second map by first flipping the first map along the vertical axis, and then by rotating it 90 degrees clockwise.
output
 
",implementation,5
"from math import gcd
from collections import defaultdict as dd
m=int(input())
d=dd(int)
l=[]
ans=[]
for i in range(m):
    s=input().split()[0]
    a=0
    b=0
    c=0
    n=len(s)
    ind=0
    for i in range(1,n):
        if(s[i]=='+'):
            ind=i+1
            break
        a=a*10+int(s[i])
    for i in range(ind,n):
        if(s[i]==')'):
            ind1=i+2
            break
        b=b*10+int(s[i])
    for i in range(ind1,n):
        c=c*10+int(s[i])
    a=a+b
    g=gcd(a,c)
    a=a//g
    c=c//g
    d[(a,c)]+=1
    l.append((a,c))
for i in l:
    ans.append(d[i])
print(*ans)",0958_D1,CODEFORCES,1580,Hyperspace Jump (easy),"The Rebel fleet is on the run. It consists of m ships currently gathered around a single planet. Just a few seconds ago, the vastly more powerful Empire fleet has appeared in the same solar system, and the Rebels will need to escape into hyperspace. In order to spread the fleet, the captain of each ship has independently come up with the coordinate to which that ship will jump. In the obsolete navigation system used by the Rebels, this coordinate is given as the value of an arithmetic expression of the form .
To plan the future of the resistance movement, Princess Heidi needs to know, for each ship, how many ships are going to end up at the same coordinate after the jump. You are her only hope!
The first line of the input contains a single integer m (1 ≤ m ≤ 200 000) – the number of ships. The next m lines describe one jump coordinate each, given as an arithmetic expression. An expression has the form (a+b)/c. Namely, it consists of: an opening parenthesis (, a positive integer a of up to two decimal digits, a plus sign +, a positive integer b of up to two decimal digits, a closing parenthesis ), a slash /, and a positive integer c of up to two decimal digits.
Print a single line consisting of m space-separated integers. The i-th integer should be equal to the number of ships whose coordinate is equal to that of the i-th ship (including the i-th ship itself).
","input
In the sample testcase, the second and the third ship will both end up at the coordinate 3.
output
Note that this problem has only two versions – easy and hard.
","expressionparsing, math",3
"from sys import stdout
m = 30
a, b = 0, 0
fle = 1
for i in range(m):
    if fle:
        print('? {} {}'.format(a, b))
        stdout.flush()
        resp1 = int(raw_input())
        fle = 0
    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))
    stdout.flush()
    resp2 = int(raw_input())
    #print(resp1,resp2,a,b)
    if resp1 == -1 and resp2 == 1:
        b += 2**(m-1-i)
        fle = 1
    elif resp1 == 1 and resp2 == -1:
        a += 2**(m-1-i)
        fle = 1
    else:
        fle = 0
        print('? {} {}'.format(a + 2**(m-1-i), b))
        stdout.flush()
        resp3 = int(raw_input())
        if resp3 == -1:
            b += 2**(m-1-i)
            a += 2**(m-1-i)
        #print(resp1,resp2,resp3,a,b)
print('! {} {}'.format(a,b))
stdout.flush()",1088_D,CODEFORCES,1229,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",2
"import pprint
nr, ng, nb = map(int, input().split())
*r, = map(int, input().split())
*g, = map(int, input().split())
*b, = map(int, input().split())
dp = []
for _ in range(nr + 1):
    dp.append([[0] * (nb + 1) for _ in range(ng + 1)])

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

mx = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if i and j:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            if i and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])
            if j and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])


mx_i = mx_j = mx_k = -1

for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if dp[i][j][k] > mx:
                mx_i = i
                mx_j = j
                mx_k = k
                mx = dp[i][j][k]

print(mx)
",1398_D,CODEFORCES,3989,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]
 
d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)
 
for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)
 
a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",1312_E,CODEFORCES,3881,Array Shrinking,"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation any number of times:
After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array $$$a$$$ you can get?
The first line contains the single integer $$$n$$$ ($$$1 \le n \le 500$$$) — the initial length of the array $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$) — the initial array $$$a$$$.
Print the only integer — the minimum possible length you can get after performing the operation described above any number of times.
In the first test, this is one of the optimal sequences of operations: $$$4$$$ $$$3$$$ $$$2$$$ $$$2$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$\rightarrow$$$ $$$5$$$ $$$3$$$.
","input
In the second test, this is one of the optimal sequences of operations: $$$3$$$ $$$3$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$5$$$ $$$4$$$ $$$\rightarrow$$$ $$$6$$$ $$$4$$$.
output
In the third and fourth tests, you can't perform the operation at all.
","dp, greedy",6
"k = int(input())
prev=0
next=0
NumofDigits=0
#i = 0
#while(sum<(2^12)):
while(True):
    prev = next
    next = next+(9*(10**(NumofDigits-1))*NumofDigits)
    if(k>= prev and k<=next):
        break
    NumofDigits=NumofDigits+1
if(NumofDigits==1):
    print(k)
else:
    result = (10**(NumofDigits-1))+int((k-(prev+1))/NumofDigits)
    i=0
    while(True):
        if (k-int(prev+1))%NumofDigits == i:
            break
        i=i+1
    result = str(result)
    print(result[i])",1177_B,CODEFORCES,1308,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"inp = list(map(int, input().strip().split()))
moves = inp[0]
candiesAtTheEnd = inp[1]

def find(moves, candiesAtTheEnd):
  result = -1
  start = 0
  end = moves-1
  while result!=candiesAtTheEnd:
    #print(""start: "",start, "", end: "", end)
    mid=((end-start+1)//2)+start
    #print(""mid: "", mid)
    pluses=moves-mid
    minuses=mid
    #print(""pluses: "", pluses, "", minuses: "", minuses)
    result=((pluses+1)/2)*pluses
    result=result-minuses
    #print(""result: "", result)
    if result==candiesAtTheEnd:
      return minuses
    elif result>candiesAtTheEnd:
      start=mid
    else:
      end=mid
    

result_final=find(moves,candiesAtTheEnd)
print(result_final)
",1195_B,CODEFORCES,1399,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import math
def getx(n):
    return math.floor(math.sqrt(n))
def getans(n,x):
    l1=[i for i in range(n,0,-1)]
    l2=[]
    i=0
    while(i<n):
        l2=l2+sorted(l1[i:i+x])
        i+=x
    return l2
n=int(input())
a=getx(n)
ans=getans(n,a)
ans1=[str(i) for i in ans]
print(' '.join(ans1))",1017_C,CODEFORCES,1850,The Phone Number,"Mrs. Smith is trying to contact her husband, John Smith, but she forgot the secret phone number!
The only thing Mrs. Smith remembered was that any permutation of $$$n$$$ can be a secret phone number. Only those permutations that minimize secret value might be the phone of her husband.
The sequence of $$$n$$$ integers is called a permutation if it contains all integers from $$$1$$$ to $$$n$$$ exactly once.
The secret value of a phone number is defined as the sum of the length of the longest increasing subsequence (LIS) and length of the longest decreasing subsequence (LDS). 
A subsequence $$$a_{i_1}, a_{i_2}, \ldots, a_{i_k}$$$ where $$$1\leq i_1 < i_2 < \ldots < i_k\leq n$$$ is called increasing if $$$a_{i_1} < a_{i_2} < a_{i_3} < \ldots < a_{i_k}$$$. If $$$a_{i_1} > a_{i_2} > a_{i_3} > \ldots > a_{i_k}$$$, a subsequence is called decreasing. An increasing/decreasing subsequence is called longest if it has maximum length among all increasing/decreasing subsequences.
For example, if there is a permutation $$$[6, 4, 1, 7, 2, 3, 5]$$$, LIS of this permutation will be $$$[1, 2, 3, 5]$$$, so the length of LIS is equal to $$$4$$$. LDS can be $$$[6, 4, 1]$$$, $$$[6, 4, 2]$$$, or $$$[6, 4, 3]$$$, so the length of LDS is $$$3$$$.
Note, the lengths of LIS and LDS can be different.
So please help Mrs. Smith to find a permutation that gives a minimum sum of lengths of LIS and LDS.
The only line contains one integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the length of permutation that you need to build.
Print a permutation that gives a minimum sum of lengths of LIS and LDS. 
If there are multiple answers, print any.
","input
In the first sample, you can build a permutation $$$[3, 4, 1, 2]$$$. LIS is $$$[3, 4]$$$ (or $$$[1, 2]$$$), so the length of LIS is equal to $$$2$$$. LDS can be ony of $$$[3, 1]$$$, $$$[4, 2]$$$, $$$[3, 2]$$$, or $$$[4, 1]$$$. The length of LDS is also equal to $$$2$$$. The sum is equal to $$$4$$$. Note that $$$[3, 4, 1, 2]$$$ is not the only permutation that is valid.
output
In the second sample, you can build a permutation $$$[2, 1]$$$. LIS is $$$[1]$$$ (or $$$[2]$$$), so the length of LIS is equal to $$$1$$$. LDS is $$$[2, 1]$$$, so the length of LDS is equal to $$$2$$$. The sum is equal to $$$3$$$. Note that permutation $$$[1, 2]$$$ is also valid.
","constructivealgorithms, greedy",3
"def tonum(count):
    return (count - 1) // 3


def check(n, k, logdivl):
    divl = 2**logdivl

    min_k = 2**(logdivl+1) - 2 - logdivl
    # print(divl * divl, divl * divl - (2*divl - 1), ((2**(n-logdivl))**2 - 1))
    max_k = tonum(divl * divl + (divl * divl - (2*divl - 1)) * ((2**(n-logdivl))**2 - 1))
    # print(n,k,logdivl, min_k, max_k)
    return min_k <= k <= max_k

def main(n, k):
    if k == 1:
        return n - 1

    if n > 100:
        return n - 1

    if ((2 ** (n-1)) ** 2 - 1) // 3 + 1 >= k:
        return n -1

    for logdivl in range(1, n+1):
        if check(n, k, logdivl):
            return n - logdivl

    return None


t = int(input())
for i in range(t):
    n, k  = list(map(int, input().split()))
    ans = main(n, k)
    if ans is not None:
        print(""YES {}"".format(ans))
    else:
        print(""NO"")
",1080_D,CODEFORCES,1176,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if n == 1:
        print(0)
    else:
        max1 = max2 = -1
        for q in a:
            if q > max1:
                max1, max2 = q, max1
            elif q > max2:
                max2 = q
        print(max(0, min(max2-1, len(a)-2)))
",1197_A,CODEFORCES,2248,DIY Wooden Ladder,"Let's denote a $$$k$$$-step ladder as the following structure: exactly $$$k + 2$$$ wooden planks, of which
Note that neither the base planks, nor the steps planks are required to be equal.
For example, ladders $$$1$$$ and $$$3$$$ are correct $$$2$$$-step ladders and ladder $$$2$$$ is a correct $$$1$$$-step ladder. On the first picture the lengths of planks are $$$[3, 3]$$$ for the base and $$$[1]$$$ for the step. On the second picture lengths are $$$[3, 3]$$$ for the base and $$$[2]$$$ for the step. On the third picture lengths are $$$[3, 4]$$$ for the base and $$$[2, 3]$$$ for the steps. 
You have $$$n$$$ planks. The length of the $$$i$$$-th planks is $$$a_i$$$. You don't have a saw, so you can't cut the planks you have. Though you have a hammer and nails, so you can assemble the improvised ""ladder"" from the planks.
The question is: what is the maximum number $$$k$$$ such that you can choose some subset of the given planks and assemble a $$$k$$$-step ladder using them?
The first line contains a single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of queries. The queries are independent.
Each query consists of two lines. The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^5$$$) — the number of planks you have.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^5$$$) — the lengths of the corresponding planks.
It's guaranteed that the total number of planks from all queries doesn't exceed $$$10^5$$$.
Print $$$T$$$ integers — one per query. The $$$i$$$-th integer is the maximum number $$$k$$$, such that you can choose some subset of the planks given in the $$$i$$$-th query and assemble a $$$k$$$-step ladder using them.
Print $$$0$$$ if you can't make even $$$1$$$-step ladder from the given set of planks.
","input
Examples for the queries $$$1-3$$$ are shown at the image in the legend section.
output
The Russian meme to express the quality of the ladders:
","greedy, math, sortings",3
"import sys

n, m = [int(w) for w in input().split()]
x = [int(w) for w in input().split()]
t = [int(w) for w in input().split()]

if m == 1:
    print(n)
    sys.exit(0)

p = []
tx = []
for i in range(n+m):
    (tx if t[i] == 1 else p).append(x[i])

a = [0] * m
i = 0
for pi in p:
    while i < m-1 and pi > (tx[i]+tx[i+1])/2:
        i += 1
    a[i] += 1

print("" "".join(str(ai) for ai in a))
",1075_B,CODEFORCES,2877,Taxi drivers and Lyft,"Palo Alto is an unusual city because it is an endless coordinate line. It is also known for the office of Lyft Level 5.
Lyft has become so popular so that it is now used by all $$$m$$$ taxi drivers in the city, who every day transport the rest of the city residents — $$$n$$$ riders.
Each resident (including taxi drivers) of Palo-Alto lives in its unique location (there is no such pair of residents that their coordinates are the same).
The Lyft system is very clever: when a rider calls a taxi, his call does not go to all taxi drivers, but only to the one that is the closest to that person. If there are multiple ones with the same distance, then to taxi driver with a smaller coordinate is selected.
But one morning the taxi drivers wondered: how many riders are there that would call the given taxi driver if they were the first to order a taxi on that day? In other words, you need to find for each taxi driver $$$i$$$ the number $$$a_{i}$$$ — the number of riders that would call the $$$i$$$-th taxi driver when all drivers and riders are at their home?
The taxi driver can neither transport himself nor other taxi drivers.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n,m \le 10^5$$$) — number of riders and taxi drivers.
The second line contains $$$n + m$$$ integers $$$x_1, x_2, \ldots, x_{n+m}$$$ ($$$1 \le x_1 < x_2 < \ldots < x_{n+m} \le 10^9$$$), where $$$x_i$$$ is the coordinate where the $$$i$$$-th resident lives. 
The third line contains $$$n + m$$$ integers $$$t_1, t_2, \ldots, t_{n+m}$$$ ($$$0 \le t_i \le 1$$$). If $$$t_i = 1$$$, then the $$$i$$$-th resident is a taxi driver, otherwise $$$t_i = 0$$$.
It is guaranteed that the number of $$$i$$$ such that $$$t_i = 1$$$ is equal to $$$m$$$.
Print $$$m$$$ integers $$$a_1, a_2, \ldots, a_{m}$$$, where $$$a_i$$$ is the answer for the $$$i$$$-th taxi driver. The taxi driver has the number $$$i$$$ if among all the taxi drivers he lives in the $$$i$$$-th smallest coordinate (see examples for better understanding).
In the first example, we have only one taxi driver, which means an order from any of $$$n$$$ riders will go to him.
","input
In the second example, the first taxi driver lives at the point with the coordinate $$$2$$$, and the second one lives at the point with the coordinate $$$6$$$. Obviously, the nearest taxi driver to the rider who lives on the $$$3$$$ coordinate is the first one, and to the rider who lives on the coordinate $$$5$$$ is the second one. The rider who lives on the $$$4$$$ coordinate has the same distance to the first and the second taxi drivers, but since the first taxi driver has a smaller coordinate, the call from this rider will go to the first taxi driver.
output
In the third example, we have one rider and the taxi driver nearest to him is the fourth one.
","implementation, sortings",4
"import math


class Read:
    @staticmethod
    def int():
        return int(input())

    @staticmethod
    def list(sep=' '):
        return input().split(sep)

    @staticmethod
    def list_int(sep=' '):
        return list(map(int, input().split(sep)))


def solve():
    n, k = Read.list_int()
    s = input()

    sf = 'RGB' * (k + 2)

    max_s = 0
    for i in range(n - k + 1):
        for j in range(3):
            count = 0
            for b in range(k):
                if sf[j + b] == s[i + b]:
                    count += 1
            if count > max_s:
                max_s = count

    print(k - max_s)


query_count = Read.int()
for j in range(query_count):
    solve()
",1196_D1,CODEFORCES,3611,RGB Substring (easy version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2000$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2000$$$ ($$$\sum n \le 2000$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
",implementation,5
"import sys
from collections import deque
n=int(input())
visited=[False for i in range(n+1)]
dp=[0 for i in range(n+1)]
l=[[] for i in range(n+1)]
for i in range(n-1):
    a,b=map(int,input().split())
    l[a].append(b)
    l[b].append(a)
b=list(map(int,input().split()))
s=[1]
visited[1]=True
c=1
c1=0
while len(s)!=n :
    aux=0
    for i in l[s[c1]]:
        if not visited[i]:
            visited[i]=True
            dp[i]=1
            aux+=1
    for i in range(c,c+aux):
        if dp[b[i]]==1:
            s.append(b[i])
            dp[b[i]]=0
        else:
            print(""No"")
            sys.exit()
    c+=aux
    c1+=1
print(""Yes"")
",1037_D,CODEFORCES,2809,Valid BFS?,"The BFS algorithm is defined as follows.
Since the order of choosing neighbors of each vertex can vary, it turns out that there may be multiple sequences which BFS can print.
In this problem you need to check whether a given sequence corresponds to some valid BFS traversal of the given tree starting from vertex $$$1$$$. The tree is an undirected graph, such that there is exactly one simple path between any two vertices.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) which denotes the number of nodes in the tree. 
The following $$$n - 1$$$ lines describe the edges of the tree. Each of them contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x, y \le n$$$) — the endpoints of the corresponding edge of the tree. It is guaranteed that the given graph is a tree.
The last line contains $$$n$$$ distinct integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$) — the sequence to check.
Print ""Yes"" (quotes for clarity) if the sequence corresponds to some valid BFS traversal of the given tree and ""No"" (quotes for clarity) otherwise.
You can print each letter in any case (upper or lower).
Both sample tests have the same tree in them.
","input
In this tree, there are two valid BFS orderings: 
output
The ordering $$$1, 2, 4, 3$$$ doesn't correspond to any valid BFS order.
","dfsandsimilar, graphs, shortestpaths, trees",4
"n,k=map(int,input().split())
print(-(-k//n))",1036_A,CODEFORCES,461,Function Height,"You are given a set of $$$2n+1$$$ integer points on a Cartesian plane. Points are numbered from $$$0$$$ to $$$2n$$$ inclusive. Let $$$P_i$$$ be the $$$i$$$-th point. The $$$x$$$-coordinate of the point $$$P_i$$$ equals $$$i$$$. The $$$y$$$-coordinate of the point $$$P_i$$$ equals zero (initially). Thus, initially $$$P_i=(i,0)$$$.
The given points are vertices of a plot of a piecewise function. The $$$j$$$-th piece of the function is the segment $$$P_{j}P_{j + 1}$$$.
In one move you can increase the $$$y$$$-coordinate of any point with odd $$$x$$$-coordinate (i.e. such points are $$$P_1, P_3, \dots, P_{2n-1}$$$) by $$$1$$$. Note that the corresponding segments also change.
For example, the following plot shows a function for $$$n=3$$$ (i.e. number of points is $$$2\cdot3+1=7$$$) in which we increased the $$$y$$$-coordinate of the point $$$P_1$$$ three times and $$$y$$$-coordinate of the point $$$P_5$$$ one time:
Let the area of the plot be the area below this plot and above the coordinate axis OX. For example, the area of the plot on the picture above is 4 (the light blue area on the picture above is the area of the plot drawn on it).
Let the height of the plot be the maximum $$$y$$$-coordinate among all initial points in the plot (i.e. points $$$P_0, P_1, \dots, P_{2n}$$$). The height of the plot on the picture above is 3.
Your problem is to say which minimum possible height can have the plot consisting of $$$2n+1$$$ vertices and having an area equal to $$$k$$$. Note that it is unnecessary to minimize the number of moves.
It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 10^{18}$$$) — the number of vertices in a plot of a piecewise function and the area we need to obtain.
Print one integer — the minimum possible height of a plot consisting of $$$2n+1$$$ vertices and with an area equals $$$k$$$. It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
One of the possible answers to the first example:
The area of this plot is 3, the height of this plot is 1.
","input
There is only one possible answer to the second example:
output
The area of this plot is 12, the height of this plot is 3.
",math,1
"n, pos, l, r=map(int, input().split())
if l==1 and r==n:
	print(0)
elif l==1 and r!=n:
	print(abs(pos-r)+1)
elif l!=1 and r==n:
	print(abs(pos-l)+1)
else:
	print(r-l+2+min(abs(pos-l), abs(pos-r)))",0915_B,CODEFORCES,242,Browser,"Luba is surfing the Internet. She currently has n opened tabs in her browser, indexed from 1 to n from left to right. The mouse cursor is currently located at the pos-th tab. Luba needs to use the tabs with indices from l to r (inclusive) for her studies, and she wants to close all the tabs that don't belong to this segment as fast as possible.
Each second Luba can either try moving the cursor to the left or to the right (if the cursor is currently at the tab i, then she can move it to the tab max(i - 1, a) or to the tab min(i + 1, b)) or try closing all the tabs to the left or to the right of the cursor (if the cursor is currently at the tab i, she can close all the tabs with indices from segment [a, i - 1] or from segment [i + 1, b]). In the aforementioned expressions a and b denote the minimum and maximum index of an unclosed tab, respectively. For example, if there were 7 tabs initially and tabs 1, 2 and 7 are closed, then a = 3, b = 6.
What is the minimum number of seconds Luba has to spend in order to leave only the tabs with initial indices from l to r inclusive opened?
The only line of input contains four integer numbers n, pos, l, r (1 ≤ n ≤ 100, 1 ≤ pos ≤ n, 1 ≤ l ≤ r ≤ n) — the number of the tabs, the cursor position and the segment which Luba needs to leave opened.
Print one integer equal to the minimum number of seconds required to close all the tabs outside the segment [l, r].
In the first test Luba can do the following operations: shift the mouse cursor to the tab 2, close all the tabs to the left of it, shift the mouse cursor to the tab 3, then to the tab 4, and then close all the tabs to the right of it.
","input
In the second test she only needs to close all the tabs to the right of the current position of the cursor.
output
In the third test Luba doesn't need to do anything.
",implementation,1
"n = int(input())
lst = [int(i) for i in input().split()]
st = set()
flag = False
count = 0
for i in lst:
    if i not in st:
        st.add(i)
    else:
        flag = True
        count+=1
        lol = i
sum1 = n*(n-1)//2
if count>1:
    print('cslnb')
    quit()
if not flag:    
    if (sum(lst)- sum1)% 2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
else:
    if (lol-1) in lst or lol == 0:
        print('cslnb')
    else:
        if (sum(lst)- sum1)% 2 == 0:
            print('cslnb')
        else:
            print('sjfnb')
",1191_D,CODEFORCES,2218,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy",3
"MAX = 100001
parent = []

def makeSet():
    global parent
    parent = [i for i in range(MAX + 1)]

def findSet(u):
    global parent
    if u != parent[u]:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

makeSet()
n, a, b = map(int, input().split())
p = list(map(int, input().split()))
pos = dict()
for i in range(n):
    pos[p[i]] = i + 1

for i in range(n):
    unionSet(i + 1, pos.get(a - p[i], n + 1))
    unionSet(i + 1, pos.get(b - p[i], 0))

A = findSet(0)
B = findSet(n + 1)

if A != B:
    print('YES')
    for i in range(1, n + 1):
        if findSet(i) == B:
            print('1', end = "" "")
        else:
            print('0', end = "" "")
else:
    print('NO')
",0468_B,CODEFORCES,1475,Two Sets,"Little X has n distinct integers: p1, p2, ..., pn. He wants to divide all of them into two sets A and B. The following two conditions must be satisfied:
Help Little X divide the numbers into two sets or determine that it's impossible.
The first line contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The next line contains n space-separated distinct integers p1, p2, ..., pn (1 ≤ pi ≤ 109).
If there is a way to divide the numbers into two sets, then print ""YES"" in the first line. Then print n integers: b1, b2, ..., bn (bi equals either 0, or 1), describing the division. If bi equals to 0, then pi belongs to set A, otherwise it belongs to set B.
","input
If it's impossible, print ""NO"" (without the quotes).
output
It's OK if all the numbers are in the same set, and the other one is empty.
","2-sat, dfsandsimilar, dsu, graphmatchings, greedy",3
"n=int(input())
print(2*n*n-2*n+1)",1180_A,CODEFORCES,724,Alex and a Rhombus,"While playing with geometric figures Alex has accidentally invented a concept of a $$$n$$$-th order rhombus in a cell grid.
A $$$1$$$-st order rhombus is just a square $$$1 \times 1$$$ (i.e just a cell).
A $$$n$$$-th order rhombus for all $$$n \geq 2$$$ one obtains from a $$$n-1$$$-th order rhombus adding all cells which have a common side with it to it (look at the picture to understand it better).
Alex asks you to compute the number of cells in a $$$n$$$-th order rhombus.
The first and only input line contains integer $$$n$$$ ($$$1 \leq n \leq 100$$$) — order of a rhombus whose numbers of cells should be computed.
","input
Print exactly one integer — the number of cells in a $$$n$$$-th order rhombus.
output
Images of rhombus corresponding to the examples are given in the statement.
","dp, implementation, math",1
"n=int(input())
s=input()
cur=0
for a in s:
    cur=max(cur,0)
    if(a=='-'):
        cur-=1
    else: cur+=1
    cur=max(cur,0)
print(cur)",1159_A,CODEFORCES,2110,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math",3
"import sys
import string


def ria():
    return [int(i) for i in input().split()]


n, k = ria()
mp = {}
for i in string.ascii_uppercase[:k]:
    mp[i] = 0
for i in input():
    if i in mp:
        mp[i] += 1
print(min(mp.values())*k)",1038_A,CODEFORCES,1937,Equality,"You are given a string $$$s$$$ of length $$$n$$$, which consists only of the first $$$k$$$ letters of the Latin alphabet. All letters in string $$$s$$$ are uppercase.
A subsequence of string $$$s$$$ is a string that can be derived from $$$s$$$ by deleting some of its symbols without changing the order of the remaining symbols. For example, ""ADE"" and ""BD"" are subsequences of ""ABCDE"", but ""DEA"" is not.
A subsequence of $$$s$$$ called good if the number of occurences of each of the first $$$k$$$ letters of the alphabet is the same.
Find the length of the longest good subsequence of $$$s$$$. 
The first line of the input contains integers $$$n$$$ ($$$1\le n \le 10^5$$$) and $$$k$$$ ($$$1 \le k \le 26$$$).
The second line of the input contains the string $$$s$$$ of length $$$n$$$. String $$$s$$$ only contains uppercase letters from 'A' to the $$$k$$$-th letter of Latin alphabet.
Print the only integer — the length of the longest good subsequence of string $$$s$$$.
","input
In the first example, ""ACBCAB"" (""ACAABCCAB"") is one of the subsequences that has the same frequency of 'A', 'B' and 'C'. Subsequence ""CAB"" also has the same frequency of these letters, but doesn't have the maximum possible length.
output
In the second example, none of the subsequences can have 'D', hence the answer is $$$0$$$.
","implementation, strings",3
"a = [str(i) for i in input().split()]
a.sort()
first = a[0]
second = a[1]
third = a[2]
firstnum = int(first[0])
secondnum = int(second[0])
thirdnum = int(third[0])
if(first == second):
	if(second == third):
		print(0)
	else:
		print(1)
elif(second == third):
	print(1)
elif(first[1] == second[1] and second[1] == third[1]):
	if(firstnum +1 == secondnum and secondnum + 1 == thirdnum):
		print(0)
	elif(firstnum + 1 == secondnum or firstnum + 2 == secondnum):
		print(1)
	elif(secondnum + 1 == thirdnum or secondnum + 2 == thirdnum):
		print(1)
	else:
		print(2)
elif(first[1] == second[1] and (firstnum + 1 == secondnum or firstnum+2 == secondnum)):
	print(1)
elif(second[1] == third[1] and (secondnum + 1 == thirdnum or secondnum+2 == thirdnum)):
	print(1)
elif(first[1] == third[1] and (firstnum + 1 == thirdnum or firstnum + 2 == thirdnum)):
	print(1)
else:
	print(2)",1191_B,CODEFORCES,2978,Tokitsukaze and Mahjong,"Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $$$1$$$ to $$$9$$$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $$$\ldots$$$, 9m, 1p, 2p, $$$\ldots$$$, 9p, 1s, 2s, $$$\ldots$$$, 9s.
In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.
Do you know the minimum number of extra suited tiles she needs to draw so that she can win?
Here are some useful definitions in this game:
Some examples: 
Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.
The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $$$1$$$ to $$$9$$$ and the second character is m, p or s.
Print a single integer — the minimum number of extra suited tiles she needs to draw.
In the first example, Tokitsukaze already has a shuntsu.
","input
In the second example, Tokitsukaze already has a koutsu.
output
In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
","bruteforce, implementation",4
"n, k = map(int, input().split())

m = 2 * (n - 1) - k * (k - 1)

if m > 0: print(-1)

else:

    x = int((1 + (1 - 4 * m) ** 0.5) / 2)

    if x * (x - 1) + m > 0: x -= 1

    print(k - x)



# Made By Mostafa_Khaled",0287_B,CODEFORCES,903,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"n, m = [int(x) for x in input().split()]

a = [int(x) for x in input().split()]

a.sort()
last = 0
total = 0
for i in range(n - 1):
    if a[i]>0 :
        total += a[i] - 1
        last = min(last + 1, a[i])

print(total + max(a[n-1] - max(1, a[n - 1] - last), 0))",1061_B,CODEFORCES,2855,Views Matter,"You came to the exhibition and one exhibit has drawn your attention. It consists of $$$n$$$ stacks of blocks, where the $$$i$$$-th stack consists of $$$a_i$$$ blocks resting on the surface.
The height of the exhibit is equal to $$$m$$$. Consequently, the number of blocks in each stack is less than or equal to $$$m$$$.
There is a camera on the ceiling that sees the top view of the blocks and a camera on the right wall that sees the side view of the blocks.
Find the maximum number of blocks you can remove such that the views for both the cameras would not change.
Note, that while originally all blocks are stacked on the floor, it is not required for them to stay connected to the floor after some blocks are removed. There is no gravity in the whole exhibition, so no block would fall down, even if the block underneath is removed. It is not allowed to move blocks by hand either.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 100\,000$$$, $$$1 \le m \le 10^9$$$) — the number of stacks and the height of the exhibit.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le m$$$) — the number of blocks in each stack from left to right.
Print exactly one integer — the maximum number of blocks that can be removed.
","input
The following pictures illustrate the first example and its possible solution.
output
Blue cells indicate removed blocks. There are $$$10$$$ blue cells, so the answer is $$$10$$$.
","greedy, implementation, sortings",4
"import sys
from math import floor

if __name__ == '__main__':

    entrada = input()
    entrada_str = list(entrada.split("" ""))
    entrada_int = list(map(int, entrada_str))

    a = entrada_int[0]
    b = entrada_int[1]

    if a == b:
        print(0)
        sys.exit()

    string_1 = """"
    string_2 = """"
    while a:
        if a%2 == 0:
            string_1 = string_1 + ""0""
        else:
            string_1 = string_1 + ""1""
        a = floor(a/2)

    while b:
        if b%2 == 0:
            string_2 = string_2 + ""0""
        else:
            string_2 = string_2 + ""1""
        b = floor(b/2)

    lista_1 = list(string_1)
    lista_1.reverse()
    contrario_1 = """".join(lista_1)

    lista_2 = list(string_2)
    lista_2.reverse()
    contrario_2 = """".join(lista_2)

    if len(string_1) != len(string_2):
        resposta = pow(2, len(string_2)) - 1
    else:
        potencia = 0
        for i in range(len(string_1)):
            if contrario_1[i] != contrario_2[i]:
                break
            potencia += 1

        potencia = len(string_1) - potencia
        resposta = pow(2, potencia)-1

    print(resposta)



		    		 			  				 	 	   		 		",0276_D,CODEFORCES,839,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"from math import gcd
import sys
input=sys.stdin.readline
from collections import defaultdict as dd
m=int(input())
d=dd(int)
l=[]
for i in range(m):
    s=input().split()[0]
    a=0
    b=0
    c=0
    n=len(s)
    ind=0
    for i in range(1,n):
        if(s[i]=='+'):
            ind=i+1
            break
        a=a*10+int(s[i])
    for i in range(ind,n):
        if(s[i]==')'):
            ind1=i+2
            break
        b=b*10+int(s[i])
    for i in range(ind1,n):
        c=c*10+int(s[i])
    a=a+b
    g=gcd(a,c)
    a=a//g
    c=c//g
    d[(a,c)]+=1
    l.append((a,c))
for i in l:
    print(d[i],end="" "")
",0958_D1,CODEFORCES,1574,Hyperspace Jump (easy),"The Rebel fleet is on the run. It consists of m ships currently gathered around a single planet. Just a few seconds ago, the vastly more powerful Empire fleet has appeared in the same solar system, and the Rebels will need to escape into hyperspace. In order to spread the fleet, the captain of each ship has independently come up with the coordinate to which that ship will jump. In the obsolete navigation system used by the Rebels, this coordinate is given as the value of an arithmetic expression of the form .
To plan the future of the resistance movement, Princess Heidi needs to know, for each ship, how many ships are going to end up at the same coordinate after the jump. You are her only hope!
The first line of the input contains a single integer m (1 ≤ m ≤ 200 000) – the number of ships. The next m lines describe one jump coordinate each, given as an arithmetic expression. An expression has the form (a+b)/c. Namely, it consists of: an opening parenthesis (, a positive integer a of up to two decimal digits, a plus sign +, a positive integer b of up to two decimal digits, a closing parenthesis ), a slash /, and a positive integer c of up to two decimal digits.
Print a single line consisting of m space-separated integers. The i-th integer should be equal to the number of ships whose coordinate is equal to that of the i-th ship (including the i-th ship itself).
","input
In the sample testcase, the second and the third ship will both end up at the coordinate 3.
output
Note that this problem has only two versions – easy and hard.
","expressionparsing, math",3
"A=[9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889]
k=int(input())
if k<10:
    print(k)
else:    
    for n in range (0,12):
        if k>A[n+1]:
            continue
        else:
            a=10**(n+1)+(k-A[n]-1)//(n+2)
            b=(k-A[n]-1)%(n+2)
            print(str(a)[b])
            break",1177_B,CODEFORCES,1286,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"# -*- coding: utf-8 -*-
""""""
Created on Sun May 26 12:02:26 2019

@author: avina
""""""

N,L,H,d = map(int, input().split())

l = list(map(int, input().split()))
e = 0
for i in range(1 << N ):
    k = []
    for j in range(N):
        if i >> j & 1:
            k.append(l[j])
    if len(k)>0:
        maz = max(k)
        mins = min(k)
        sums = sum(k)
        if sums >= L and sums <=H:
            if maz - mins >=d:
                e+=1
print(e)",0550_B,CODEFORCES,4451,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"n = int(input())

l = list(map(int,input().split()))

s = list(set(l))

s.sort()

if len(s)>1:
    ans = s[1]
else:
    ans='NO'
    
print(ans)",0022_A,CODEFORCES,2284,Second Order Statistics,"Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.
","input
The first input line contains integer n (1 ≤ n ≤ 100) — amount of numbers in the sequence. The second line contains n space-separated integer numbers — elements of the sequence. These numbers don't exceed 100 in absolute value.
output
If the given sequence has the second order statistics, output this order statistics, otherwise output NO.
",bruteforce,4
"k=int(input(""""))
t=0
if k==0:
    print(""Invalid input"")
    exit()
d=0
e=0
n=5
while(1):
    u=9*n*(10**n)+1-(10**n)-9*k
    if u>0:
        d+=1
        if e>0:
            u=i
            break
        n=n-1
    elif u<0:
        i=u
        e+=1
        if d>0:
            n=n+1
            break
        n=n+1
    else:
        print(9)
        exit()
import math
u=abs(u)
u=u//9
m=u//n
p=u%(n)
if p==0:
    q=10**(n-1)+m-1
    o=q%10
else:
    q = 10**(n-1) + m
    o=((q//(10**(n-p)))%10)
print(o)",1177_B,CODEFORCES,1278,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):#排他的論理和の階乗
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=None):
        self.BIT=[0]*(n+1)
        self.num=n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        self.mod = mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n = int(input())
a = li()

inv = 0
for i in range(n):
    for j in range(i+1,n):
        if a[i] > a[j]:
            inv += 1
inv %= 2

m = int(input())
for _ in range(m):
    l,r = mi()
    L = r-l+1

    all = L*(L-1)//2
    if all%2==1:
        inv = 1 - inv

    print(""odd"" if inv else ""even"")
",0911_D,CODEFORCES,3091,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"n=input()
n1=int(n)
c=[]
for i in range(0,n1):
    z4=0
    p,q=input().split()
    a=int(p)
    b=int(q)
    while a!=0 and b!=0:
        z1=z3=0
        if a<=b:
          z=(b/a)
          z1=int(z)
          b=b-(z1*a) 
        if b<=a and b!=0:
          z2=a/b
          z3=int(z2)
          a=a-(z3*b) 
        z4=z4+z1+z3    
    c.append(z4)
l=len(c)
for j in range(0,l):
    print(c[j])
    ",0267_A,CODEFORCES,98,Subtractions,"You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).
You've got some number of pairs (ai, bi). How many operations will be performed for each of them?
","input
The first line contains the number of pairs n (1  ≤  n  ≤  1000). Then follow n lines, each line contains a pair of positive integers ai, bi (1  ≤  ai,  bi  ≤  109).
output
Print the sought number of operations for each pair on a single line.
","math, numbertheory",1
"parent = [i for i in range(int(1e5 + 10))]
def findSet(u):
    if parent[u] != u:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]])
        else:
            unionSet(i, n)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]])
        else:
            unionSet(i, n + 1)

    if findSet(n) == findSet(n + 1):
        print('NO')
    else:
        print('YES')
        tmp = findSet(n + 1)
        lst = [0 if findSet(i) == tmp else 1 for i in range(n)]
        print(*lst)",0468_B,CODEFORCES,1468,Two Sets,"Little X has n distinct integers: p1, p2, ..., pn. He wants to divide all of them into two sets A and B. The following two conditions must be satisfied:
Help Little X divide the numbers into two sets or determine that it's impossible.
The first line contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The next line contains n space-separated distinct integers p1, p2, ..., pn (1 ≤ pi ≤ 109).
If there is a way to divide the numbers into two sets, then print ""YES"" in the first line. Then print n integers: b1, b2, ..., bn (bi equals either 0, or 1), describing the division. If bi equals to 0, then pi belongs to set A, otherwise it belongs to set B.
","input
If it's impossible, print ""NO"" (without the quotes).
output
It's OK if all the numbers are in the same set, and the other one is empty.
","2-sat, dfsandsimilar, dsu, graphmatchings, greedy",3
"n = int(input())
l = [int(x) - 1 for x in input().split()]
parity = 0
explore = set(l)
while len(explore) > 0:
    x = explore.pop()
    tmp = x
    found = [x]
    while l[tmp] != x:
        tmp = l[tmp]
        found.append(tmp)
    for i in found[1:]:
        explore.remove(i)
    parity ^= (len(found) - 1) % 2

if parity == n % 2:
    print(""Petr"")
else:
    print(""Um_nik"")",0986_B,CODEFORCES,2572,Petr and Permutations,"Petr likes to come up with problems about randomly generated data. This time problem is about random permutation. He decided to generate a random permutation this way: he takes identity permutation of numbers from $$$1$$$ to $$$n$$$ and then $$$3n$$$ times takes a random pair of different elements and swaps them. Alex envies Petr and tries to imitate him in all kind of things. Alex has also come up with a problem about random permutation. He generates a random permutation just like Petr but swaps elements $$$7n+1$$$ times instead of $$$3n$$$ times. Because it is more random, OK?!
You somehow get a test from one of these problems and now you want to know from which one.
In the first line of input there is one integer $$$n$$$ ($$$10^{3} \le n \le 10^{6}$$$).
In the second line there are $$$n$$$ distinct integers between $$$1$$$ and $$$n$$$ — the permutation of size $$$n$$$ from the test.
It is guaranteed that all tests except for sample are generated this way: First we choose $$$n$$$ — the size of the permutation. Then we randomly choose a method to generate a permutation — the one of Petr or the one of Alex. Then we generate a permutation using chosen method.
If the test is generated via Petr's method print ""Petr"" (without quotes). If the test is generated via Alex's method print ""Um_nik"" (without quotes).
","input
Please note that the sample is not a valid test (because of limitations for $$$n$$$) and is given only to illustrate input/output format. Your program still has to print correct answer to this test to get AC.
output
Due to randomness of input hacks in this problem are forbidden.
","combinatorics, math",4
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
b = li()

done = set()
j = 0
ans = []
for i in range(n):
    if b[i] in done:
        ans.append(0)
    else:
        c = 0
        while a[j] != b[i]:
            done.add(a[j])
            j += 1
            c += 1
        done.add(a[j])
        j += 1
        ans.append(c + 1)
print(*ans)",1073_B,CODEFORCES,2015,Vasya and Books,"Vasya has got $$$n$$$ books, numbered from $$$1$$$ to $$$n$$$, arranged in a stack. The topmost book has number $$$a_1$$$, the next one — $$$a_2$$$, and so on. The book at the bottom of the stack has number $$$a_n$$$. All numbers are distinct.
Vasya wants to move all the books to his backpack in $$$n$$$ steps. During $$$i$$$-th step he wants to move the book number $$$b_i$$$ into his backpack. If the book with number $$$b_i$$$ is in the stack, he takes this book and all the books above the book $$$b_i$$$, and puts them into the backpack; otherwise he does nothing and begins the next step. For example, if books are arranged in the order $$$[1, 2, 3]$$$ (book $$$1$$$ is the topmost), and Vasya moves the books in the order $$$[2, 1, 3]$$$, then during the first step he will move two books ($$$1$$$ and $$$2$$$), during the second step he will do nothing (since book $$$1$$$ is already in the backpack), and during the third step — one book (the book number $$$3$$$). Note that $$$b_1, b_2, \dots, b_n$$$ are distinct.
Help Vasya! Tell him the number of books he will put into his backpack during each step.
The first line contains one integer $$$n~(1 \le n \le 2 \cdot 10^5)$$$ — the number of books in the stack.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n~(1 \le a_i \le n)$$$ denoting the stack of books.
The third line contains $$$n$$$ integers $$$b_1, b_2, \dots, b_n~(1 \le b_i \le n)$$$ denoting the steps Vasya is going to perform.
All numbers $$$a_1 \dots a_n$$$ are distinct, the same goes for $$$b_1 \dots b_n$$$.
Print $$$n$$$ integers. The $$$i$$$-th of them should be equal to the number of books Vasya moves to his backpack during the $$$i$$$-th step.
","input
The first example is described in the statement.
output
In the second example, during the first step Vasya will move the books $$$[3, 1, 4]$$$. After that only books $$$2$$$ and $$$5$$$ remain in the stack ($$$2$$$ is above $$$5$$$). During the second step Vasya will take the books $$$2$$$ and $$$5$$$. After that the stack becomes empty, so during next steps Vasya won't move any books.
","implementation, math",3
"from itertools import combinations
n,l,r,x=map(int,input().split())
arr=list(map(int,input().split()))
ans=0
for i in range(2,n+1):
	brr=list(combinations(arr,i))
	for j in brr:
		s=sum(j)
		if l<=s<=r and max(j)-min(j)>=x:
			ans+=1
print(ans)
",0550_B,CODEFORCES,4418,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"s = input().split()
hand = {'m': [], 'p': [], 's':[]}

for item in s:
	hand[item[1]].append(int(item[0]))


min_steps_needed = 10

for symb in ['m', 'p', 's']:
	hand[symb] = sorted(hand[symb])
	for start in range(1, 10):
		a_needed = 10
		b_needed = 10

		a_needed = 3 - hand[symb].count(start)

		b1, b2, b3 = 0, 0, 0
		if hand[symb].count(start) > 0:
			b1 = 1
		if hand[symb].count(start+1) > 0:
			b2 = 1
		if hand[symb].count(start+2) > 0:
			b3 = 1

		b_needed = 3 - b1 - b2 - b3

		if a_needed < min_steps_needed:
			min_steps_needed = a_needed
		if b_needed < min_steps_needed:
			min_steps_needed = b_needed



# print(s)
# print(hand)
print(min_steps_needed)",1191_B,CODEFORCES,2204,Tokitsukaze and Mahjong,"Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $$$1$$$ to $$$9$$$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $$$\ldots$$$, 9m, 1p, 2p, $$$\ldots$$$, 9p, 1s, 2s, $$$\ldots$$$, 9s.
In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.
Do you know the minimum number of extra suited tiles she needs to draw so that she can win?
Here are some useful definitions in this game:
Some examples: 
Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.
The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $$$1$$$ to $$$9$$$ and the second character is m, p or s.
Print a single integer — the minimum number of extra suited tiles she needs to draw.
In the first example, Tokitsukaze already has a shuntsu.
","input
In the second example, Tokitsukaze already has a koutsu.
output
In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
","bruteforce, implementation",3
"import sys
def countR(ip):
    c=0
    for i in ip:
        if(i=='R'):
            c+=1
    return c
    
def countB(ip):
    c=0
    for i in ip:
        if(i=='B'):
            c+=1
    return c
    
def countG(ip):
    c=0
    for i in ip:
        if(i=='G'):
            c+=1
    return c
# sys.stdin.readline()
t=int(sys.stdin.readline())
x='RGB'*680
y='GBR'*680
z='BRG'*680
for i in range(t):
    n,k=list(map(int,sys.stdin.readline().strip().split()))
    a=sys.stdin.readline().strip()
    xk=x[:k]
    yk=y[:k]
    zk=z[:k]
    # print(k,xk,zk)
    # xc=[]
    # yc=[]
    # zc=[]
    # xc.append(countR(xk))
    # xc.append(countG(xk))
    # xc.append(countB(xk))
   
    # yc.append(countR(yk))
    # yc.append(countG(yk))
    # yc.append(countB(yk))
    
    # zc.append(countR(zk))
    # zc.append(countG(zk))
    # zc.append(countB(zk))
    op=2001
    for j in range(n-k+1):
        b=a[j:j+k]
        # print(len(b),xc,zc)
        # bc=[]
        
        # bc.append(countR(b))
        # bc.append(countG(b))
        # bc.append(countB(b))
        xd=0
        yd=0
        zd=0
        # print(a,b,xc,yc,zc,bc)
        for jj in range(len(b)):
            if(b[jj]!=xk[jj]):
                xd+=1
            if(b[jj]!=yk[jj]):
                yd+=1
            if(b[jj]!=zk[jj]):
                zd+=1
         # print(a,b,xd,yd,zd,z)
        op=min(op,xd,yd,zd)
    print(op)
    ",1196_D1,CODEFORCES,3604,RGB Substring (easy version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2000$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2000$$$ ($$$\sum n \le 2000$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
",implementation,5
"from sys import stdin, stdout

n = int(stdin.readline())
values = list(map(int, stdin.readline().split()))

cnt = 0
for i in range(n):
    for j in range(i + 1, n):
        if values[i] > values[j]:
            cnt += 1

m = int(stdin.readline())
for i in range(m):
    l, r = map(int, stdin.readline().split())
    n = r - l + 1
    
    cnt += n * (n - 1) // 2
    cnt &= 1
    
    if cnt == 1:
        stdout.write('odd\n')
    else:
        stdout.write('even\n')",0911_D,CODEFORCES,3100,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import sys
n=int(input())

if n<=3:
    print(0)
    sys.exit()

score=0
import math
def score(x):
    ANS=0
    xr=math.ceil(math.sqrt(x))

    LIST=[]
    for i in range(1,xr+3):
        if x%i==0:
            LIST.append(i)
            LIST.append(x//i)

    LIST=sorted(list(set(LIST)))

    for l in LIST[1:-1]:
        ANS+=x//l

    return ANS

ANS=0
for i in range(4,n+1):
    ANS+=score(i)

print(ANS*4)
    

",1062_D,CODEFORCES,1998,Fun with Integers,"You are given a positive integer $$$n$$$ greater or equal to $$$2$$$. For every pair of integers $$$a$$$ and $$$b$$$ ($$$2 \le |a|, |b| \le n$$$), you can transform $$$a$$$ into $$$b$$$ if and only if there exists an integer $$$x$$$ such that $$$1 < |x|$$$ and ($$$a \cdot x = b$$$ or $$$b \cdot x = a$$$), where $$$|x|$$$ denotes the absolute value of $$$x$$$.
After such a transformation, your score increases by $$$|x|$$$ points and you are not allowed to transform $$$a$$$ into $$$b$$$ nor $$$b$$$ into $$$a$$$ anymore.
Initially, you have a score of $$$0$$$. You can start at any integer and transform it as many times as you like. What is the maximum score you can achieve?
A single line contains a single integer $$$n$$$ ($$$2 \le n \le 100\,000$$$) — the given integer described above.
Print an only integer — the maximum score that can be achieved with the transformations. If it is not possible to perform even a single transformation for all possible starting integers, print $$$0$$$.
","input
In the first example, the transformations are $$$2 \rightarrow 4 \rightarrow (-2) \rightarrow (-4) \rightarrow 2$$$.
output
In the third example, it is impossible to perform even a single transformation.
","dfsandsimilar, graphs, implementation, math",3
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
T, = getIntList()
#print(N)

MAXN = 10**18 + 10
def getUpper(N):
    z = 1
    r = 0
    for i in range(N):
        r+=z
        z*=4
        if r>MAXN:
            break
    return r
for _ in range(T):
    N,K = getIntList()
    tk = K
    z = 1
    for i in range(N):
        tk -= z
        z*= 4
        if tk<0: break
    if tk>0:
        print('NO')
        continue
    nowcut =  0
    nt = 1
    nowupper = 0
    ok = False
    for i in range(N):
        nt *=2
        nowcut += nt-1
        
        if nowcut >K: break
        t = (nt *2 - 3)
        tu  = t * getUpper(N-1-i)
        nowupper += tu
        dprint('bound', nowcut, nowcut+nowupper)
        if nowcut<=K<= nowcut+nowupper:
            ok = True
            break
    if ok:
        print('YES', N-1-i)
    else:
        print(""NO"")


",1080_D,CODEFORCES,3567,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",5
"n, = map(int,input().split())

s = input()
if s=='0':
    print(0)
else:
    print(""1""+""0""*s.count('0'))",0976_A,CODEFORCES,1639,Minimum Binary Number,"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".
You are given a correct string s.
You can perform two different operations on this string: 
Let val(s) be such a number that s is its binary representation.
Correct string a is less than some other correct string b iff val(a) < val(b).
Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).
The first line contains integer number n (1 ≤ n ≤ 100) — the length of string s.
The second line contains the string s consisting of characters ""0"" and ""1"". It is guaranteed that the string s is correct.
Print one string — the minimum correct string that you can obtain from the given one.
","input
In the first example you can obtain the answer by the following sequence of operations: ""1001""  ""1010""  ""1100""  ""100"".
output
In the second example you can't obtain smaller answer no matter what operations you use.
",implementation,3
"from sys import stdin,stdout
import heapq
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr()):
    n,k=lst()
    l=sorted(zip(lst(),lst(),range(n)))
    h=[];sm=0
    ans={}
    for i in range(n):
        pwr,cns,ind=l[i]
        sm+=cns
        if len(h)>k:
            p=0
            for i in range(len(h)):
                if h[p]>h[i]:
                    p=i
            sm-=h.pop(p)
        ans[ind]=sm
        h+=[cns]
    for i in range(n):
        stdout.write(str(ans[i])+' ')
    print()",0994_B,CODEFORCES,2634,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings",4
"import math
a=list(input())
b=list(input())
p=a.count('+')-b.count('+')
m=a.count('-')-b.count('-')
if m<0 or p<0:
    print(0)
    exit(0)
l=math.factorial(p+m)/(math.factorial(p)*math.factorial(m))
print(l*(.5**(p+m)))",0476_B,CODEFORCES,4376,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"l, r = map(int, input().split())

ans = 0
for i in range(63, -1, -1):
    if r & (1 << i) > 0 and l & (1 << i) == 0:
        ans = (1 << (i + 1)) - 1
        break
print(ans)
",0276_D,CODEFORCES,827,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase

def solve(s,t):
    if len(t) == 1:
        if s.count(t[0]):
            return 'YES'
        return 'NO'
    for i in range(1,len(t)):
        dp = [[-1000]*(i+1) for _ in range(len(s)+1)]
        dp[0][0] = 0
        for j in range(len(s)):
            dp[j+1] = dp[j][:]
            for k in range(i+1):
                if k != i and s[j] == t[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])
                if abs(dp[j][k]+i) < len(t) and s[j] == t[dp[j][k]+i]:
                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)
        for l in range(len(s)+1):
            if dp[l][-1] == len(t)-i:
                return 'YES'
    return 'NO'

def main():
    for _ in range(int(input())):
        s = input().strip()
        t = input().strip()
        print(solve(s,t))

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",1303_E,CODEFORCES,3797,Erase Subsequences,"You are given a string $$$s$$$. You can build new string $$$p$$$ from $$$s$$$ using the following operation no more than two times: 
Of course, initially the string $$$p$$$ is empty. 
For example, let $$$s = \text{ababcd}$$$. At first, let's choose subsequence $$$s_1 s_4 s_5 = \text{abc}$$$ — we will get $$$s = \text{bad}$$$ and $$$p = \text{abc}$$$. At second, let's choose $$$s_1 s_2 = \text{ba}$$$ — we will get $$$s = \text{d}$$$ and $$$p = \text{abcba}$$$. So we can build $$$\text{abcba}$$$ from $$$\text{ababcd}$$$.
Can you build a given string $$$t$$$ using the algorithm above?
The first line contains the single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of test cases.
Next $$$2T$$$ lines contain test cases — two per test case. The first line contains string $$$s$$$ consisting of lowercase Latin letters ($$$1 \le |s| \le 400$$$) — the initial string.
The second line contains string $$$t$$$ consisting of lowercase Latin letters ($$$1 \le |t| \le |s|$$$) — the string you'd like to build.
","input
It's guaranteed that the total length of strings $$$s$$$ doesn't exceed $$$400$$$.
output
Print $$$T$$$ answers — one per test case. Print YES (case insensitive) if it's possible to build $$$t$$$ and NO (case insensitive) otherwise.
","dp, strings",6
"# XXXX

n = int(input())

if n > 0:
    print(n)
else:
    n = n * -1
    x = n % 10
    y = (n // 10) % 10

    if x > y:
        print(-(n // 10))
    else:
        print(-((n // 100)* 10 + x))
",0313_A,CODEFORCES,106,Ilya and Bank Account,"Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.
Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.
Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.
The single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.
In a single line print an integer — the maximum state of the bank account that Ilya can get. 
","input
In the first test sample Ilya doesn't profit from using the present.
output
In the second test sample you can delete digit 1 and get the state of the account equal to 0.
","implementation, numbertheory",1
"n,m = map(int,input().split())
x = input().split()
t = input().split()
r = [0]*n
d = [0]*m
countr = 0
countd = 0
for i in range(n+m):
    if int(t[i]) == 1:
        d[countd] = int(x[i])
        countd += 1
    else:
        r[countr] = int(x[i])
        countr += 1
current = 0
count = [0]*m
for i in range(n):
    while current < m-1:
        if d[current+1] >= r[i]:
            break
        current += 1
    if current == m-1:
        count[m-1] += (n-i)
        break
    if 2*r[i] <= (d[current]+d[current+1]):
        count[current] += 1
    else:
        count[current+1] += 1
s = """"
for i in range(m):
    s += str(count[i])+"" ""
print(s[:-1])
",1075_B,CODEFORCES,2878,Taxi drivers and Lyft,"Palo Alto is an unusual city because it is an endless coordinate line. It is also known for the office of Lyft Level 5.
Lyft has become so popular so that it is now used by all $$$m$$$ taxi drivers in the city, who every day transport the rest of the city residents — $$$n$$$ riders.
Each resident (including taxi drivers) of Palo-Alto lives in its unique location (there is no such pair of residents that their coordinates are the same).
The Lyft system is very clever: when a rider calls a taxi, his call does not go to all taxi drivers, but only to the one that is the closest to that person. If there are multiple ones with the same distance, then to taxi driver with a smaller coordinate is selected.
But one morning the taxi drivers wondered: how many riders are there that would call the given taxi driver if they were the first to order a taxi on that day? In other words, you need to find for each taxi driver $$$i$$$ the number $$$a_{i}$$$ — the number of riders that would call the $$$i$$$-th taxi driver when all drivers and riders are at their home?
The taxi driver can neither transport himself nor other taxi drivers.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n,m \le 10^5$$$) — number of riders and taxi drivers.
The second line contains $$$n + m$$$ integers $$$x_1, x_2, \ldots, x_{n+m}$$$ ($$$1 \le x_1 < x_2 < \ldots < x_{n+m} \le 10^9$$$), where $$$x_i$$$ is the coordinate where the $$$i$$$-th resident lives. 
The third line contains $$$n + m$$$ integers $$$t_1, t_2, \ldots, t_{n+m}$$$ ($$$0 \le t_i \le 1$$$). If $$$t_i = 1$$$, then the $$$i$$$-th resident is a taxi driver, otherwise $$$t_i = 0$$$.
It is guaranteed that the number of $$$i$$$ such that $$$t_i = 1$$$ is equal to $$$m$$$.
Print $$$m$$$ integers $$$a_1, a_2, \ldots, a_{m}$$$, where $$$a_i$$$ is the answer for the $$$i$$$-th taxi driver. The taxi driver has the number $$$i$$$ if among all the taxi drivers he lives in the $$$i$$$-th smallest coordinate (see examples for better understanding).
In the first example, we have only one taxi driver, which means an order from any of $$$n$$$ riders will go to him.
","input
In the second example, the first taxi driver lives at the point with the coordinate $$$2$$$, and the second one lives at the point with the coordinate $$$6$$$. Obviously, the nearest taxi driver to the rider who lives on the $$$3$$$ coordinate is the first one, and to the rider who lives on the coordinate $$$5$$$ is the second one. The rider who lives on the $$$4$$$ coordinate has the same distance to the first and the second taxi drivers, but since the first taxi driver has a smaller coordinate, the call from this rider will go to the first taxi driver.
output
In the third example, we have one rider and the taxi driver nearest to him is the fourth one.
","implementation, sortings",4
"import math

n, r = map(float, input().split())
a = math.pi / n
s = math.sin(a)
R = (r * s) / (1 - s)
print(R)
",1100_C,CODEFORCES,662,NN and the Optical Illusion,"NN is an experienced internet user and that means he spends a lot of time on the social media. Once he found the following image on the Net, which asked him to compare the sizes of inner circles:
It turned out that the circles are equal. NN was very surprised by this fact, so he decided to create a similar picture himself.
He managed to calculate the number of outer circles $$$n$$$ and the radius of the inner circle $$$r$$$. NN thinks that, using this information, you can exactly determine the radius of the outer circles $$$R$$$ so that the inner circle touches all of the outer ones externally and each pair of neighboring outer circles also touches each other. While NN tried very hard to guess the required radius, he didn't manage to do that. 
Help NN find the required radius for building the required picture.
The first and the only line of the input file contains two numbers $$$n$$$ and $$$r$$$ ($$$3 \leq n \leq 100$$$, $$$1 \leq r \leq 100$$$) — the number of the outer circles and the radius of the inner circle respectively.
Output a single number $$$R$$$ — the radius of the outer circle required for building the required picture. 
","input
Your answer will be accepted if its relative or absolute error does not exceed $$$10^{-6}$$$.
output
Formally, if your answer is $$$a$$$ and the jury's answer is $$$b$$$. Your answer is accepted if and only when $$$\frac{|a-b|}{max(1, |b|)} \le 10^{-6}$$$.
","binarysearch, geometry, math",1
"def main():
    high = 10 ** 12
    n, m, k = map(int, input().split())
    hozs = []
    for i in range(n):
        hozs.append(list(map(int, input().split())))
    verts = []
    for i in range(n - 1):
        verts.append(list(map(int, input().split())))
    if k % 2:
        for i in range(n):
            print(""-1 "" * m)
        return
    k //= 2
    dp = []
    for i in range(n):
        dp.append([])
        for j in range(m):
            dp[-1].append([])
            for kay in range(k + 1):
                dp[-1][-1].append(0)
    for depth in range(1, k + 1):
        for i in range(n):
            for j in range(m):
                if i == 0:
                    up = high
                else:
                    up = verts[i - 1][j] + dp[i - 1][j][depth - 1]
                if i == n - 1:
                    down = high
                else:
                    down = verts[i][j] + dp[i + 1][j][depth - 1]
                if j == 0:
                    left = high
                else:
                    left = hozs[i][j - 1] + dp[i][j - 1][depth - 1]
                if j == m - 1:
                    right = high
                else:
                    right = hozs[i][j] + dp[i][j + 1][depth - 1]
                min_cost = min(up, down, left, right)
                ''''
                if min_cost == up:
                    dp[i][j][depth] = dp[i - 1][j][depth - 1]
                elif min_cost == down:
                    dp[i][j][depth] = dp[i + 1][j][depth - 1]
                elif min_cost == left:
                    dp[i][j][depth] = dp[i][j - 1][depth - 1]
                else:
                    dp[i][j][depth] = dp[i][j + 1][depth - 1]
                '''
                dp[i][j][depth] += min_cost
    for i in range(n):
        print(*[2 * dp[i][j][k] for j in range(m)])
main()",1517_D,CODEFORCES,4087,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"[n, k]=[int(i) for i in input().split()]
print((k+n-1)//n)",1036_A,CODEFORCES,471,Function Height,"You are given a set of $$$2n+1$$$ integer points on a Cartesian plane. Points are numbered from $$$0$$$ to $$$2n$$$ inclusive. Let $$$P_i$$$ be the $$$i$$$-th point. The $$$x$$$-coordinate of the point $$$P_i$$$ equals $$$i$$$. The $$$y$$$-coordinate of the point $$$P_i$$$ equals zero (initially). Thus, initially $$$P_i=(i,0)$$$.
The given points are vertices of a plot of a piecewise function. The $$$j$$$-th piece of the function is the segment $$$P_{j}P_{j + 1}$$$.
In one move you can increase the $$$y$$$-coordinate of any point with odd $$$x$$$-coordinate (i.e. such points are $$$P_1, P_3, \dots, P_{2n-1}$$$) by $$$1$$$. Note that the corresponding segments also change.
For example, the following plot shows a function for $$$n=3$$$ (i.e. number of points is $$$2\cdot3+1=7$$$) in which we increased the $$$y$$$-coordinate of the point $$$P_1$$$ three times and $$$y$$$-coordinate of the point $$$P_5$$$ one time:
Let the area of the plot be the area below this plot and above the coordinate axis OX. For example, the area of the plot on the picture above is 4 (the light blue area on the picture above is the area of the plot drawn on it).
Let the height of the plot be the maximum $$$y$$$-coordinate among all initial points in the plot (i.e. points $$$P_0, P_1, \dots, P_{2n}$$$). The height of the plot on the picture above is 3.
Your problem is to say which minimum possible height can have the plot consisting of $$$2n+1$$$ vertices and having an area equal to $$$k$$$. Note that it is unnecessary to minimize the number of moves.
It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 10^{18}$$$) — the number of vertices in a plot of a piecewise function and the area we need to obtain.
Print one integer — the minimum possible height of a plot consisting of $$$2n+1$$$ vertices and with an area equals $$$k$$$. It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
One of the possible answers to the first example:
The area of this plot is 3, the height of this plot is 1.
","input
There is only one possible answer to the second example:
output
The area of this plot is 12, the height of this plot is 3.
",math,1
"n, k=[int(v) for v in input().split()]
if n==1:
    print(0)
elif n-1>(1+k-1)*(k-1)//2:
    print(-1)
else:
    n-=1
    k-=1
    l, r=0, k+1
    while r-l>1:
        m=(l+r)//2
        if (m+k)*(k-m+1)//2>=n:
            l=m
        else:
            r=m
    print(k-l+1)",0287_B,CODEFORCES,899,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"n,l,r,x = [int(x) for x in input().split("" "")]
arr = [int(x) for x in input().split("" "")]
ans = 0
for i in range(2**n):
	subset = [] 
	for j in range(n): 
		if (i & (1 << j)) != 0: 
			subset.append(arr[j])
	if len(subset)>1:
	    mx = max(subset)
	    mn = min(subset)
	    sm = sum(subset)
	    if l<=sm<=r and mx-mn>=x:
	        ans+=1
print(ans)",0550_B,CODEFORCES,4481,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"v = input().split()
n = int(v[0])
k = int(v[1])

s = input()
ap = 0

i = 1
while i < n:
    if s[:i] == s[-i:]:
        ap = i

    i += 1

print(s + s[ap:]*(k-1))",1029_A,CODEFORCES,3454,Many Equal Substrings,"You are given a string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters and an integer number $$$k$$$.
Let's define a substring of some string $$$s$$$ with indices from $$$l$$$ to $$$r$$$ as $$$s[l \dots r]$$$.
Your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ positions $$$i$$$ such that $$$s[i \dots i + n - 1] = t$$$. In other words, your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
It is guaranteed that the answer is always unique.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 50$$$) — the length of the string $$$t$$$ and the number of substrings.
The second line of the input contains the string $$$t$$$ consisting of exactly $$$n$$$ lowercase Latin letters.
","input
Print such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
output
It is guaranteed that the answer is always unique.
","implementation, strings",5
"# TC - O(n)
#SC - O(n)
size = int(input())
s = input()


ct = 0
F = 0
for i in range(size-2):
    if s[i]==s[i+1] and s[i+1]==s[i+2] and s[i] == 'x':
        ct += 1
        F = 1

if F == 0:
    print(0)
else:
    print(ct)",0978_B,CODEFORCES,1644,File Name,"You can not just take the file and send it. When Polycarp trying to send a file in the social network ""Codehorses"", he encountered an unexpected problem. If the name of the file contains three or more ""x"" (lowercase Latin letters ""x"") in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed.
Determine the minimum number of characters to remove from the file name so after that the name does not contain ""xxx"" as a substring. Print 0 if the file name does not initially contain a forbidden substring ""xxx"".
You can delete characters in arbitrary positions (not necessarily consecutive). If you delete a character, then the length of a string is reduced by $$$1$$$. For example, if you delete the character in the position $$$2$$$ from the string ""exxxii"", then the resulting string is ""exxii"".
The first line contains integer $$$n$$$ $$$(3 \le n \le 100)$$$ — the length of the file name.
The second line contains a string of length $$$n$$$ consisting of lowercase Latin letters only — the file name.
","input
Print the minimum number of characters to remove from the file name so after that the name does not contain ""xxx"" as a substring. If initially the file name dost not contain a forbidden substring ""xxx"", print 0.
output
In the first example Polycarp tried to send a file with name contains number $$$33$$$, written in Roman numerals. But he can not just send the file, because it name contains three letters ""x"" in a row. To send the file he needs to remove any one of this letters.
","greedy, strings",3
"import sys
n,m,k = map(int,input().split())

if k%2:
    ans = [[-1]*m for _ in range(n)]
    for row in ans:
        print(*row)
    exit()
A = []
B = []
inf = float('inf')
for _ in range(n):
    A.append(list(map(int,input().split())))
for _ in range(n-1):
    B.append(list(map(int,input().split())))

# dp = [[[inf for _ in range(k//2+1)] for _ in range(m)] for _ in range(n)]

# new
dp = [[inf]*m for _ in range(n)]
ans = [[None]*m for _ in range(n)]

for l in range(k//2+1):
    new_dp = [[inf]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if l == 0:
                new_dp[i][j] = 0
                continue

            up = B[i-1][j]*2 + dp[i-1][j] if i-1>=0 else inf
            right = A[i][j]*2 + dp[i][j+1] if j+1<m else inf
            left = A[i][j-1]*2 + dp[i][j-1] if j-1>=0 else inf
            down = B[i][j]*2 + dp[i+1][j] if i+1<n else inf

            new_dp[i][j] = min(up,right,left,down)
            if l == k//2:
                ans[i][j] = new_dp[i][j]
    dp = new_dp
for row in ans:
    print(*row)
",1517_D,CODEFORCES,4080,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"n = int(input())
arr = list(map(int, input().split()))
codd = 0
ceven = 0
ptodd = -1
pteven = -1
for i in range(n):
    if arr[i]%2 == 0:
        ceven += 1
        pteven = i
    else:
        codd += 1
        ptodd = i

if ceven == 1:
    print(pteven+1)
else:
    print(ptodd+1)",0025_A,CODEFORCES,1441,IQ test,"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given n numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given n numbers finds one that is different in evenness.
","input
The first line contains integer n (3 ≤ n ≤ 100) — amount of numbers in the task. The second line contains n space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.
output
Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.
",bruteforce,3
"import sys
input = sys.stdin.readline
maxn = int(1e5 + 10)
ST = [0] * (4 * maxn)
def update(id, l, r, val):
    if l == r == val:
        ST[id] = 1
        return
    if l > val or r < val:
        return
    mid = int((l + r) / 2)
    update(id * 2, l, mid, val)
    update(id * 2 + 1, mid + 1, r, val)
    ST[id] = ST[id * 2] + ST[id * 2 + 1]
    return
def get(id, l, r, x, y):
    if l > y or r < x:
        return 0
    if x <= l and r <= y:
        return ST[id]
    mid = int((l + r) / 2)
    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)
n, res = int(input()), 0
for x in list(map(int, input().split())):
    res ^= get(1, 1, n, x + 1, n) % 2
    update(1, 1, n, x)
for i in range (int(input())):
    x, y = list(map(int, input().split()))
    if int((y - x) * (y - x + 1) / 2) & 1:
        res ^= 1
    if res:
        print(""odd"")
    else:
        print(""even"")",0911_D,CODEFORCES,3110,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"i = int(input())
s = input().split()

l = []
for j in s:
    if not l or  int(j)%2 != l[-1]:
        l.append(int(j)%2)
    else:
        l.pop()

if len(l) < 2:
    print('YES')
else:
    print('NO')
",1092_D1,CODEFORCES,2081,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math",3
"n, k = map(int, input().split())
a, b, c = 2 * n, 5 * n, 8 * n
ceil = lambda x, y: (x + y - 1) // y
print(ceil(a, k) + ceil(b, k) + ceil(c, k))
",1080_A,CODEFORCES,574,Petya and Origami,"Petya is having a party soon, and he has decided to invite his $$$n$$$ friends.
He wants to make invitations in the form of origami. For each invitation, he needs two red sheets, five green sheets, and eight blue sheets. The store sells an infinite number of notebooks of each color, but each notebook consists of only one color with $$$k$$$ sheets. That is, each notebook contains $$$k$$$ sheets of either red, green, or blue.
Find the minimum number of notebooks that Petya needs to buy to invite all $$$n$$$ of his friends.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1\leq n, k\leq 10^8$$$) — the number of Petya's friends and the number of sheets in each notebook respectively.
Print one number — the minimum number of notebooks that Petya needs to buy.
","input
In the first example, we need $$$2$$$ red notebooks, $$$3$$$ green notebooks, and $$$5$$$ blue notebooks.
output
In the second example, we need $$$5$$$ red notebooks, $$$13$$$ green notebooks, and $$$20$$$ blue notebooks.
",math,1
"n, k = map(int, input().split())
P = map(int, input().split())

parent = list(range(256))
sz = [1] * 256
def rt(x):
    if x != parent[x]:
        parent[x] = rt(parent[x])
    return parent[x]

def u(rx, ry):
    parent[ry] = rx
    sz[rx] += sz[ry]

ans = [0] * n
for i, p in enumerate(P):
    rx = rt(p)
    while rx > 0 and sz[rx] + sz[rt(rx - 1)] <= k:        
        u(rt(rx - 1), rx)
        rx = rt(p)
    ans[i] = rt(p)
print(' '.join(map(str, ans)))
",0980_C,CODEFORCES,3195,Posterized,"Professor Ibrahim has prepared the final homework for his algorithm’s class. He asked his students to implement the Posterization Image Filter.
Their algorithm will be tested on an array of integers, where the $$$i$$$-th integer represents the color of the $$$i$$$-th pixel in the image. The image is in black and white, therefore the color of each pixel will be an integer between 0 and 255 (inclusive).
To implement the filter, students are required to divide the black and white color range [0, 255] into groups of consecutive colors, and select one color in each group to be the group’s key. In order to preserve image details, the size of a group must not be greater than $$$k$$$, and each color should belong to exactly one group.
Finally, the students will replace the color of each pixel in the array with that color’s assigned group key.
To better understand the effect, here is an image of a basking turtle where the Posterization Filter was applied with increasing $$$k$$$ to the right. 
To make the process of checking the final answer easier, Professor Ibrahim wants students to divide the groups and assign the keys in a way that produces the lexicographically smallest possible array.
The first line of input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 10^5$$$, $$$1 \leq k \leq 256$$$), the number of pixels in the image, and the maximum size of a group, respectively.
The second line contains $$$n$$$ integers $$$p_1, p_2, \dots, p_n$$$ ($$$0 \leq p_i \leq 255$$$), where $$$p_i$$$ is the color of the $$$i$$$-th pixel.
Print $$$n$$$ space-separated integers; the lexicographically smallest possible array that represents the image after applying the Posterization filter.
One possible way to group colors and assign keys for the first sample:
Color $$$2$$$ belongs to the group $$$[0,2]$$$, with group key $$$0$$$.
Color $$$14$$$ belongs to the group $$$[12,14]$$$, with group key $$$12$$$.
","input
Colors $$$3$$$ and $$$4$$$ belong to group $$$[3, 5]$$$, with group key $$$3$$$.
output
Other groups won't affect the result so they are not listed here.
","games, greedy",5
"lst = list()

lst.append(0)
lst.append(1)

now = 1
while now <= 1e25 :
	now = now * 4 + 1
	# print(now)
	lst.append(now)

t = int(input())

for i in range(t):
	s = input().split()
	n = int(s[0])
	k = int(s[1])
	if(n >= 34):
		print(""YES "" + str(n - 1))
		continue

	sek = 0
	ambil = 1
	nyak = 0
	cnt = 0

	sudah = False
	while (sek < n):
		cnt = cnt + (1 << (sek + 1)) - 1
		# print(str(cnt) + "" here"")
		if cnt > k:
			print(""NO"")
			sudah = True
			break

		next_ambil = (ambil + 1) * 2 - 1
		sisa = 4 * ambil - next_ambil
		ambil = next_ambil

		sek += 1
		nyak = nyak + sisa * lst[n - sek]
		if (nyak + cnt) >= k :
			print(""YES "" + str(n - sek))
			sudah = True
			break

	if sudah == False:
		print(""NO"")
",1080_D,CODEFORCES,2041,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",3
"""""""
ID: happyn61
LANG: PYTHON3
PROB: loan
""""""
from itertools import product
import itertools
#from collections import defaultdict
import sys
import heapq
from collections import deque
MOD=1000000000007
#fin = open ('loan.in', 'r')
#fout = open ('loan.out', 'w')
#print(dic[""4734""])
def find(parent,i):


    if parent[i] != i: 
        parent[i]=find(parent,parent[i]) 
    return parent[i] 

        # A utility function to do union of two subsets 
def union(parent,rank,xx,yy): 
    x=find(parent,xx)
    y=find(parent,yy)
    if rank[x]>rank[y]:
        parent[y]=x
    elif rank[y]>rank[x]:
        parent[x]=y
    else:
        parent[y]=x
        rank[x]+=1
ans=0
#NK=sys.stdin.readline().strip().split()
#K=int(sys.stdin.readline().strip())
#N=int(NK[0])
#K=int(NK[1])
#M=int(NK[2])
#ol=list(map(int,sys.stdin.readline().strip().split()))
#d={0:0,1:0}

x=0
y=0

MAX=1000000000
N,M,K=list(map(int,sys.stdin.readline().strip().split()))
W=[[[MAX,MAX,MAX,MAX] for j in range(M)] for i in range(N)] #L R U D
for i in range(N):
    l=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(M-1):
        W[i][j][1]=l[j]
        W[i][j+1][0]=l[j]
for i in range(N-1):
    l=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(M):
        #print(l,i,j)
        W[i][j][3]=l[j]
        W[i+1][j][2]=l[j]
        
#print(W)
if K%2==1:
    for i in range(N):
        ans=[]
        for j in range(M):
            ans.append(""-1"")
        print("" "".join(ans))
else:
    
    K=K//2
    dp=[[[0 for j in range(M)] for i in range(N)] for k in range(K+1)]
    for kt in range(1,K+1):
        
        dl=((0,-1),(0,1),(-1,0),(1,0))
        for i in range(N):
            for j in range(M):
                ans=MAX
                for t in range(4):
                    
                    ii,jj=dl[t]
                
                    if i+ii>=0 and i+ii<N and j+jj>=0 and j+jj<M:
                        ans=min(ans,dp[kt-1][i+ii][j+jj]+W[i][j][t]*2)
                    #print(i,j,ii,jj,ans)
                dp[kt][i][j]=ans
    #print(dp[-1])
    for i in range(N):
        ans=[]
        for j in range(M):
            ans.append(str(dp[-1][i][j]))
        print("" "".join(ans))

                
",1517_D,CODEFORCES,4089,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"from sys import stdin,stdout
def main():
	n=int(stdin.readline())
	s=stdin.readline()
	sum=0
	a=[]
	for v in s:
		if v!='0' and v!='\n':
			a.append(v)
	if not a and n>1:
		return 'YES'
	n=len(a)
	s=a
	for i in range(n-1):
		sum+=int(s[i])
		j=i+1
		check=1
		while j<n:
			temp=int(s[j])
			j+=1
			while j<n:
				if temp>=sum:
					break
				temp+=int(s[j])
				j+=1
			if sum!=temp:
				check=1
				break
		if sum!=temp:
			check=0
		if check:
			return 'YES'
	return 'NO'
print(main())

",1030_C,CODEFORCES,3460,Vasya and Golden Ticket,"Recently Vasya found a golden ticket — a sequence which consists of $$$n$$$ digits $$$a_1a_2\dots a_n$$$. Vasya considers a ticket to be lucky if it can be divided into two or more non-intersecting segments with equal sums. For example, ticket $$$350178$$$ is lucky since it can be divided into three segments $$$350$$$, $$$17$$$ and $$$8$$$: $$$3+5+0=1+7=8$$$. Note that each digit of sequence should belong to exactly one segment.
Help Vasya! Tell him if the golden ticket he found is lucky or not.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 100$$$) — the number of digits in the ticket.
The second line contains $$$n$$$ digits $$$a_1 a_2 \dots a_n$$$ ($$$0 \le a_i \le 9$$$) — the golden ticket. Digits are printed without spaces.
If the golden ticket is lucky then print ""YES"", otherwise print ""NO"" (both case insensitive).
","input
In the first example the ticket can be divided into $$$7$$$, $$$34$$$ and $$$52$$$: $$$7=3+4=5+2$$$.
output
In the second example it is impossible to divide ticket into segments with equal sum.
",implementation,5
"import sys
from collections import deque
import bisect
def chk(l,r,total):
    b = len(l)
    prev = 0
    i = 0
    f = 1
    cnt = 0
    while i < b:
        prev = prev+l[i]
        if cnt == total and prev == r:
            i = i+1
            continue

        if prev == r:
            cnt += 1
            if cnt != total:
                prev = 0

        i = i+1

    if cnt < total or i != b:
        f = 0

    return f


for _ in range(1):
    n = int(input())
    s = input()
    l = []
    som = 0
    for i in s:
        l.append(int(i))
        som += int(i)

    flag = 0
    for i in range(2,n+1):
        if som%i == 0:
            r = som//i
            if chk(l,r,i):
                flag = 1
                break

        if flag:
            break

    if flag:
        print(""YES"")

    else:
        print(""NO"")
",1030_C,CODEFORCES,3466,Vasya and Golden Ticket,"Recently Vasya found a golden ticket — a sequence which consists of $$$n$$$ digits $$$a_1a_2\dots a_n$$$. Vasya considers a ticket to be lucky if it can be divided into two or more non-intersecting segments with equal sums. For example, ticket $$$350178$$$ is lucky since it can be divided into three segments $$$350$$$, $$$17$$$ and $$$8$$$: $$$3+5+0=1+7=8$$$. Note that each digit of sequence should belong to exactly one segment.
Help Vasya! Tell him if the golden ticket he found is lucky or not.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 100$$$) — the number of digits in the ticket.
The second line contains $$$n$$$ digits $$$a_1 a_2 \dots a_n$$$ ($$$0 \le a_i \le 9$$$) — the golden ticket. Digits are printed without spaces.
If the golden ticket is lucky then print ""YES"", otherwise print ""NO"" (both case insensitive).
","input
In the first example the ticket can be divided into $$$7$$$, $$$34$$$ and $$$52$$$: $$$7=3+4=5+2$$$.
output
In the second example it is impossible to divide ticket into segments with equal sum.
",implementation,5
"#!/usr/bin/python
# encoding:UTF-8
# Filename:Base.py

import sys
import random

from itertools import permutations, combinations
from math import sqrt, fabs, ceil
from collections import namedtuple

# ------Util Const--------

in_file_path = ""input.txt""
output_file_path = ""output.txt""

SUBMIT = True


def read_num(fin, num_type=int):
    tmp_list = [num_type(x) for x in fin.readline().strip().split()]
    if len(tmp_list) == 1:
        return tmp_list[0]
    else:
        return tuple(tmp_list)


# A
# def solve(fin, fout):
#     n, k = read_num(fin)
#     print(ceil((n * 8.0) / k) + ceil((n * 2.0) / k) + ceil((n * 5.0) / k))

# B
# def solve(fin):
#     n = read_num(fin)
#     for _ in range(0, n):
#         l, r = read_num(fin)
#         if (r - l + 1) % 2 == 0:
#             if l % 2 == 0:
#                 print(int(-(r - l + 1) / 2))
#             else:
#                 print(int((r - l + 1) / 2))
#         else:
#             if l % 2 == 0:
#                 print(int(-(r - l) / 2 + r))
#             else:
#                 print(int((r - l) / 2 - r))

# C
# def solve(fin):
#     def count_color(x, y, xx, yy):
#         # return _w(x, y, xx, yy), _b(x, y, xx, yy)
#         if x > xx or y > yy:
#             return 0, 0
#         t = (xx - x + 1) * (yy - y + 1)
#         if t % 2 == 0:
#             return t // 2, t // 2
#         else:
#             if (x + y) % 2 == 0:
#                 return t - t // 2, t // 2
#             else:
#                 return t // 2, t - t // 2
#
#     T = read_num(fin)
#     for _ in range(0, T):
#         # print('Test: ',T)
#         n, m = read_num(fin)
#         x1, y1, x2, y2 = read_num(fin)
#         x3, y3, x4, y4 = read_num(fin)
#         w, _ = count_color(1, 1, n, m)
#         if (max(x1, x3) > min(x2, x4)) or (max(y1, y3) > min(y2, y4)):
#             tmp_w, tmp_b = count_color(x1, y1, x2, y2)
#             w += tmp_b
#             tmp_w, tmp_b = count_color(x3, y3, x4, y4)
#             w -= tmp_w
#         else:
#             tmp_w, tmp_b = count_color(x1, y1, x2, y2)
#             w += tmp_b
#             tmp_w, tmp_b = count_color(x3, y3, x4, y4)
#             w -= tmp_w
#             tmp_x_list = sorted([x1, x2, x3, x4])
#             tmp_y_list = sorted([y1, y2, y3, y4])
#             x5, x6 = tmp_x_list[1], tmp_x_list[2]
#             y5, y6 = tmp_y_list[1], tmp_y_list[2]
#             tmp_w, tmp_b = count_color(x5, y5, x6, y6)
#             w -= tmp_b
#         print(w, n * m - w)

def solve(fin):
    T = read_num(fin)
    for _ in range(0, T):
        n, k = read_num(fin)
        if n > 34 or k == 1:
            print('YES', n - 1)
        else:
            f = [0]
            for _ in range(0, n):
                f.append(f[-1] * 4 + 1)
            min_step = 1
            max_step = 1 + f[n - 1]
            # print(f)
            # print(f[n - 1])
            out_range = 3
            flag = True
            for i in range(0, n):
                # print(min_step, max_step)
                if min_step <= k <= max_step:
                    print('YES', n - i - 1)
                    flag = False
                    break
                max_step += out_range
                min_step += out_range
                out_range = out_range * 2 + 1
                if n - 2 - i >= 0:
                    # print(out_range - 2, f[n - 2 - i])
                    max_step += (out_range - 2) * f[n - 2 - i]

            if flag:
                print('NO')


if __name__ == '__main__':
    if SUBMIT:
        solve(sys.stdin)
    else:
        solve(open(in_file_path, 'r'))
",1080_D,CODEFORCES,1194,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"n = int(input())
a = list(map(int, input().split()))

a = sorted(a)
ans = 0
b = [0] * n
for i in range(n):
    if b[i] == 0:
        ans += 1
        for j in range(i, n):
            if a[j] % a[i] == 0:
                b[j] = 1
print(ans)
",1209_A,CODEFORCES,3667,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"n=int(input())
l=list(map(int,input().split()))
s=set(l)
x=0
if x in s:
    print(len(s)-1)
else:
    print(len(s))",0992_A,CODEFORCES,1709,Nastya and an Array,"Nastya owns too many arrays now, so she wants to delete the least important of them. However, she discovered that this array is magic! Nastya now knows that the array has the following properties:
Nastya is always busy, so she wants to explode the array as fast as possible. Compute the minimum time in which the array can be exploded.
The first line contains a single integer n (1 ≤ n ≤ 105) — the size of the array.
The second line contains n integers a1, a2, ..., an ( - 105 ≤ ai ≤ 105) — the elements of the array.
Print a single integer — the minimum number of seconds needed to make all elements of the array equal to zero.
","input
In the first example you can add  - 1 to all non-zero elements in one second and make them equal to zero.
output
In the second example you can add  - 2 on the first second, then the array becomes equal to [0, 0,  - 3]. On the second second you can add 3 to the third (the only non-zero) element.
","implementation, sortings",3
"import sys
coins = []
coinsValueTotal = 0
n = int(sys.stdin.readline())
inputs = sys.stdin.readline().split()
for i in range(len(inputs)):
    coin = int(inputs[i])
    coins.append(coin)
    coinsValueTotal += coin
coins.sort(reverse = True)
minCoins = 0
halfCoinsValueTotal = coinsValueTotal / 2
for i in range(len(coins)):
    minCoins +=  coins[i]
    if(minCoins > halfCoinsValueTotal):
        print(i+1)
        break
",0160_A,CODEFORCES,2324,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"n,l,r,x = map(int,input().split())
diff = list(map(int,input().split()))

ans = 0
currSum = 0
maxim = 0
minim = 0

for i in range(2**n):

    currSum = 0
    maxim = 0
    minim = 1000001
    ptr = n-1
    
    while i > 0:

        if i & 1:

            currSum += diff[ptr]
            maxim = max(maxim,diff[ptr])
            minim = min(minim,diff[ptr])

        ptr -= 1
        i = i >> 1

    if currSum <= r and currSum >= l:

        if maxim - minim >= x:

            ans += 1

print(ans)
        

        
    
",0550_B,CODEFORCES,4421,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"import math

N,r=map(int,input().split())

#sin(360/N)=R/(r+R)

print(r*math.sin(math.pi/N)/(1-math.sin(math.pi/N)))
#print(math.sin(math.pi/N))
",1100_C,CODEFORCES,678,NN and the Optical Illusion,"NN is an experienced internet user and that means he spends a lot of time on the social media. Once he found the following image on the Net, which asked him to compare the sizes of inner circles:
It turned out that the circles are equal. NN was very surprised by this fact, so he decided to create a similar picture himself.
He managed to calculate the number of outer circles $$$n$$$ and the radius of the inner circle $$$r$$$. NN thinks that, using this information, you can exactly determine the radius of the outer circles $$$R$$$ so that the inner circle touches all of the outer ones externally and each pair of neighboring outer circles also touches each other. While NN tried very hard to guess the required radius, he didn't manage to do that. 
Help NN find the required radius for building the required picture.
The first and the only line of the input file contains two numbers $$$n$$$ and $$$r$$$ ($$$3 \leq n \leq 100$$$, $$$1 \leq r \leq 100$$$) — the number of the outer circles and the radius of the inner circle respectively.
Output a single number $$$R$$$ — the radius of the outer circle required for building the required picture. 
","input
Your answer will be accepted if its relative or absolute error does not exceed $$$10^{-6}$$$.
output
Formally, if your answer is $$$a$$$ and the jury's answer is $$$b$$$. Your answer is accepted if and only when $$$\frac{|a-b|}{max(1, |b|)} \le 10^{-6}$$$.
","binarysearch, geometry, math",1
"k = 1000001
a = [True] * k
a[0] = a[1] = False

for i in range(k):
    if a[i]:
        for j in range(2*i, k, i):
            a[j] = False

n = int(input())
for i in range(4, n):
    if not a[i] and not a[n-i]:
        print(i, n-i)
        exit()",0472_A,CODEFORCES,156,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory",1
"n = int(input())
arr = list(map(int, input().split()))
arr.sort()
if arr[-1] == 1:
    arr[-1] = 2
else:
    arr[-1] = 1
arr.sort()
print(*arr)
",0135_A,CODEFORCES,2302,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings",4
"s = input()
res = 0
for i in range(len(s)):
    for j in range(i,len(s)):
        for f in range(i+1,len(s)):
            if len(s) >= f + j-i:
                if (s[i:j]== s[f:f+j-i]):
                    res = max(res,j - i)
                    
print(res)",0023_A,CODEFORCES,3712,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"from sys import stdin
s=stdin.readline()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)",0023_A,CODEFORCES,3742,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"def problem(s, p):
    for i in range(len(p)):
        l = p[:i] + ' '
        r = p[i:] + ' '

        dp = [0] + [None] * i

        for x in s:
            for j in range(i, -1, -1):
                if dp[j] is None:
                    continue

                if l[j] == x:
                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])

                temp = r[dp[j]]
                if r[dp[j]] == x:
                    dp[j] += 1

        if dp[-1] == len(r) - 1:
            return 'YES'

    return 'NO'


for _ in range(int(input())):
    print(problem(input(), input()))
",1303_E,CODEFORCES,3805,Erase Subsequences,"You are given a string $$$s$$$. You can build new string $$$p$$$ from $$$s$$$ using the following operation no more than two times: 
Of course, initially the string $$$p$$$ is empty. 
For example, let $$$s = \text{ababcd}$$$. At first, let's choose subsequence $$$s_1 s_4 s_5 = \text{abc}$$$ — we will get $$$s = \text{bad}$$$ and $$$p = \text{abc}$$$. At second, let's choose $$$s_1 s_2 = \text{ba}$$$ — we will get $$$s = \text{d}$$$ and $$$p = \text{abcba}$$$. So we can build $$$\text{abcba}$$$ from $$$\text{ababcd}$$$.
Can you build a given string $$$t$$$ using the algorithm above?
The first line contains the single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of test cases.
Next $$$2T$$$ lines contain test cases — two per test case. The first line contains string $$$s$$$ consisting of lowercase Latin letters ($$$1 \le |s| \le 400$$$) — the initial string.
The second line contains string $$$t$$$ consisting of lowercase Latin letters ($$$1 \le |t| \le |s|$$$) — the string you'd like to build.
","input
It's guaranteed that the total length of strings $$$s$$$ doesn't exceed $$$400$$$.
output
Print $$$T$$$ answers — one per test case. Print YES (case insensitive) if it's possible to build $$$t$$$ and NO (case insensitive) otherwise.
","dp, strings",6
"# cook your dish here
a,b,c = map(int,input().split())
arr = list(map(int,input().split()))

arr.sort()
p = 0
a-=1
while(a>=0 and c<b):
    c-=1
    p+=1
    c+=arr[a]
    a-=1
if(c<b):
    print(-1)
else:
    print(p)",0257_A,CODEFORCES,2389,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings",4
"
def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]
#visited = [[False for i in range(m)] for j in range(n)]
#sys.stdin = open(r'input.txt' , 'r')
#sys.stdout = open(r'output.txt' , 'w')
#for tt in range(INT()):

s = STR()

if len(set(s)) == len(s):
    print('0')
    exit(0)

d = []

for i in range(len(s)):
    for j in range(i+1 , len(s)):
        x = ''
        for k in range(i , j+1):
            x += s[k]

        d.append(x)

v = {}
for i in range(len(s)):
    if s[i] not in v :
        v[s[i]] = 1
    else:
        v[s[i]] +=1


for i in d :
    if i not in v :
        v[i] = 1
    else:
        v[i]+=1

#print(v)
mx = -1
ans = ''

for i in v :
    if v[i] >= 2 :
        if len(i) > mx :
            mx = max(mx , len(i))

print(mx)

",0023_A,CODEFORCES,3692,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import sys, heapq

n = int(sys.stdin.readline())
key = []
for i in ['S', 'M', 'L']:
    for j in range(4):
        key.append(j * 'X' + i)
prev = dict().fromkeys(key, 0)
now = dict().fromkeys(key, 0)
for _ in range(n):
    prev[sys.stdin.readline().rstrip()] += 1
for _ in range(n):
    now[sys.stdin.readline().rstrip()] += 1
for i in key:
    temp = min(prev[i], now[i])
    prev[i] -= temp
    now[i] -= temp
ans = 0
for i in key:
    ans += now[i]
print(ans)

",1000_A,CODEFORCES,1731,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation",3
"n, m = map(int, input().split())

mp = []

for i in range(n):
    line = input().strip()
    
    mp.append(list(map(lambda c: c == '#', line)))

mp1 = [[False for _ in range(m)] for _ in range(n)]

for i in range(1, n - 1):
    for j in range(1, m - 1):
        f = all(mp[i - 1][j - k] for k in range(-1, 1+1))
        f = f and all(mp[i + 1][j - k] for k in range(-1, 1+1))
        f = f and (mp[i][j - 1] and mp[i][j + 1])
        
        if not f:
            continue
        
        for ik in range(-1, 2):
            for jk in range(-1, 2):
                if ik == 0 and jk == 0:
                    continue
                mp1[i + ik][j + jk] = True

if all(all(mp[i][j] == mp1[i][j] for j in range(m)) for i in range(n)):
    print('YES')
else:
    print('NO')
        ",1059_B,CODEFORCES,3536,Forgery,"Student Andrey has been skipping physical education lessons for the whole term, and now he must somehow get a passing grade on this subject. Obviously, it is impossible to do this by legal means, but Andrey doesn't give up. Having obtained an empty certificate from a local hospital, he is going to use his knowledge of local doctor's handwriting to make a counterfeit certificate of illness. However, after writing most of the certificate, Andrey suddenly discovered that doctor's signature is impossible to forge. Or is it?
For simplicity, the signature is represented as an $$$n\times m$$$ grid, where every cell is either filled with ink or empty. Andrey's pen can fill a $$$3\times3$$$ square without its central cell if it is completely contained inside the grid, as shown below.
Determine whether is it possible to forge the signature on an empty $$$n\times m$$$ grid.
The first line of input contains two integers $$$n$$$ and $$$m$$$ ($$$3 \le n, m \le 1000$$$).
Then $$$n$$$ lines follow, each contains $$$m$$$ characters. Each of the characters is either '.', representing an empty cell, or '#', representing an ink filled cell.
If Andrey can forge the signature, output ""YES"". Otherwise output ""NO"".
You can print each letter in any case (upper or lower).
In the first sample Andrey can paint the border of the square with the center in $$$(2, 2)$$$.
In the second sample the signature is impossible to forge.
","input
In the third sample Andrey can paint the borders of the squares with the centers in $$$(2, 2)$$$ and $$$(3, 2)$$$: 
output
In the fourth sample Andrey can paint the borders of the squares with the centers in $$$(3, 3)$$$ and $$$(3, 5)$$$.
",implementation,5
"from collections import defaultdict
import sys
sys.setrecursionlimit(500000)
test = 0


def countleaf(tree, n, leafs):
    leafs[n] = 1 if len(tree[n]) == 0 else 0

    for i in tree[n]:
        leafs[n] += countleaf(tree, i, leafs)
    
    return leafs[n]
    
n = int(input())
edges = list(map(int, input().split()))
tree = [[] for i in range(n)]

leafs = [0] * n

for i, e in enumerate(edges):
    tree[e - 1] += [i + 1]

if test: print(tree)

for i in range(n - 1, -1, -1):
    if not tree[i]:
        leafs[i] = 1
    else:
        leafs[i] = sum(leafs[j] for j in tree[i])

print(*sorted(leafs))
",1056_D,CODEFORCES,2817,Decorate Apple Tree,"There is one apple tree in Arkady's garden. It can be represented as a set of junctions connected with branches so that there is only one way to reach any junctions from any other one using branches. The junctions are enumerated from $$$1$$$ to $$$n$$$, the junction $$$1$$$ is called the root.
A subtree of a junction $$$v$$$ is a set of junctions $$$u$$$ such that the path from $$$u$$$ to the root must pass through $$$v$$$. Note that $$$v$$$ itself is included in a subtree of $$$v$$$.
A leaf is such a junction that its subtree contains exactly one junction.
The New Year is coming, so Arkady wants to decorate the tree. He will put a light bulb of some color on each leaf junction and then count the number happy junctions. A happy junction is such a junction $$$t$$$ that all light bulbs in the subtree of $$$t$$$ have different colors.
Arkady is interested in the following question: for each $$$k$$$ from $$$1$$$ to $$$n$$$, what is the minimum number of different colors needed to make the number of happy junctions be greater than or equal to $$$k$$$?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of junctions in the tree.
The second line contains $$$n - 1$$$ integers $$$p_2$$$, $$$p_3$$$, ..., $$$p_n$$$ ($$$1 \le p_i < i$$$), where $$$p_i$$$ means there is a branch between junctions $$$i$$$ and $$$p_i$$$. It is guaranteed that this set of branches forms a tree.
Output $$$n$$$ integers. The $$$i$$$-th of them should be the minimum number of colors needed to make the number of happy junctions be at least $$$i$$$.
","input
In the first example for $$$k = 1$$$ and $$$k = 2$$$ we can use only one color: the junctions $$$2$$$ and $$$3$$$ will be happy. For $$$k = 3$$$ you have to put the bulbs of different colors to make all the junctions happy.
output
In the second example for $$$k = 4$$$ you can, for example, put the bulbs of color $$$1$$$ in junctions $$$2$$$ and $$$4$$$, and a bulb of color $$$2$$$ into junction $$$5$$$. The happy junctions are the ones with indices $$$2$$$, $$$3$$$, $$$4$$$ and $$$5$$$ then.
","constructivealgorithms, dfsandsimilar, dp, graphs, greedy, sortings, trees",4
"from itertools import permutations,combinations
from math import factorial
word1 = list(map(str,input()))
word2 = list(map(str,input()))
expected = 0
for i in word1:
    if i=='+':
        expected+=1
    else:
        expected-=1
blank = 0
for i in word2:
    if i=='+':
        expected-=1
    elif i=='-':
        expected+=1
    else:
        blank+=1
if abs(expected)>blank:
    print(float(0))
elif blank==0:
    if expected==0:
        print(1)
    else:
        print(0)
else:
    total = 2**blank
    if expected==blank-1:
        print(float(0))
    else:
        f = (blank-expected)//2
        if expected>0:
            a,b = expected+f,f
        elif expected<0:
            a,b = expected+f,f
        else:
            a,b = f,f
        ans = factorial(a+b)/(factorial(a))
        ans = ans/factorial(b)
        ans = ans/total
        print(ans)",0476_B,CODEFORCES,4367,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"import math
n,k=map(int,input().split())
for _ in range(k):
    l,r=map(int,input().split())
for i in range(1,n+1):
    if i%2==0:
        print('0',end='')
    else:
        print('1',end='')
print()

",1004_B,CODEFORCES,1761,Sonya and Exhibition,"Sonya decided to organize an exhibition of flowers. Since the girl likes only roses and lilies, she decided that only these two kinds of flowers should be in this exhibition.
There are $$$n$$$ flowers in a row in the exhibition. Sonya can put either a rose or a lily in the $$$i$$$-th position. Thus each of $$$n$$$ positions should contain exactly one flower: a rose or a lily.
She knows that exactly $$$m$$$ people will visit this exhibition. The $$$i$$$-th visitor will visit all flowers from $$$l_i$$$ to $$$r_i$$$ inclusive. The girl knows that each segment has its own beauty that is equal to the product of the number of roses and the number of lilies.
Sonya wants her exhibition to be liked by a lot of people. That is why she wants to put the flowers in such way that the sum of beauties of all segments would be maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\leq n, m\leq 10^3$$$) — the number of flowers and visitors respectively.
Each of the next $$$m$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1\leq l_i\leq r_i\leq n$$$), meaning that $$$i$$$-th visitor will visit all flowers from $$$l_i$$$ to $$$r_i$$$ inclusive.
Print the string of $$$n$$$ characters. The $$$i$$$-th symbol should be «0» if you want to put a rose in the $$$i$$$-th position, otherwise «1» if you want to put a lily.
If there are multiple answers, print any.
In the first example, Sonya can put roses in the first, fourth, and fifth positions, and lilies in the second and third positions;
The total beauty is equal to $$$2+2+4=8$$$.
","input
In the second example, Sonya can put roses in the third, fourth, and sixth positions, and lilies in the first, second, and fifth positions;
output
The total beauty is equal to $$$1+4+2=7$$$.
","constructivealgorithms, greedy, implementation, math",3
"import sys

n = int(input())
prob = [list(map(float, input().split())) for _ in range(n)]
dp = [[0.0]*n for _ in range(1 << n)]
dp[1][0] = 1.0

for mask in range(3, 1 << n):
    for i in range(n):
        if not (mask & (1 << i)):
            continue
        for j in range(n):
            if i != j and mask & (1 << j):
                dp[mask][i] = max(
                    dp[mask][i],
                    dp[mask - (1 << j)][i] * prob[i][j]
                    + dp[mask - (1 << i)][j] * prob[j][i]
                )

print(max(dp[-1]))
",0678_E,CODEFORCES,4523,Another Sith Tournament,"The rules of Sith Tournament are well known to everyone. n Sith take part in the Tournament. The Tournament starts with the random choice of two Sith who will fight in the first battle. As one of them loses, his place is taken by the next randomly chosen Sith who didn't fight before. Does it need to be said that each battle in the Sith Tournament ends with a death of one of opponents? The Tournament ends when the only Sith remains alive.
Jedi Ivan accidentally appeared in the list of the participants in the Sith Tournament. However, his skills in the Light Side of the Force are so strong so he can influence the choice of participants either who start the Tournament or who take the loser's place after each battle. Of course, he won't miss his chance to take advantage of it. Help him to calculate the probability of his victory.
The first line contains a single integer n (1 ≤ n ≤ 18) — the number of participants of the Sith Tournament.
Each of the next n lines contains n real numbers, which form a matrix pij (0 ≤ pij ≤ 1). Each its element pij is the probability that the i-th participant defeats the j-th in a duel.
The elements on the main diagonal pii are equal to zero. For all different i, j the equality pij + pji = 1 holds. All probabilities are given with no more than six decimal places.
","input
Jedi Ivan is the number 1 in the list of the participants.
output
Output a real number — the probability that Jedi Ivan will stay alive after the Tournament. Absolute or relative error of the answer must not exceed 10 - 6.
","bitmasks, dp, math, probabilities",7
"import sys
input=sys.stdin.readline
n,k=map(int,input().split())
theorems=list(map(int,input().split()))
sleep=list(map(int,input().split()))
tsum=[]
ts=0
sleepsum=[]
slsum=0
for i in range(n):
    ts+=theorems[i]
    tsum.append(ts)
    if(sleep[i]==1):
        slsum+=theorems[i]
    sleepsum.append(slsum)
#print(""tsum="",tsum)
#print(""sleepsum="",sleepsum)
maxdiff=0
#print(""slsum="",slsum)
maxdiff=tsum[k-1]-sleepsum[k-1]
for i in range(1,n-k+1):
    diff=(tsum[i+k-1]-tsum[i-1])-(sleepsum[i+k-1]-sleepsum[i-1])
    #print(""i="",i,""diff="",diff)
    maxdiff=max(maxdiff,diff)
#print(""maxdiff="",maxdiff)
print(slsum+maxdiff)",0961_B,CODEFORCES,1593,Lecture Sleep,"Your friend Mishka and you attend a calculus lecture. Lecture lasts n minutes. Lecturer tells ai theorems during the i-th minute.
Mishka is really interested in calculus, though it is so hard to stay awake for all the time of lecture. You are given an array t of Mishka's behavior. If Mishka is asleep during the i-th minute of the lecture then ti will be equal to 0, otherwise it will be equal to 1. When Mishka is awake he writes down all the theorems he is being told — ai during the i-th minute. Otherwise he writes nothing.
You know some secret technique to keep Mishka awake for k minutes straight. However you can use it only once. You can start using it at the beginning of any minute between 1 and n - k + 1. If you use it on some minute i then Mishka will be awake during minutes j such that  and will write down all the theorems lecturer tells.
You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
The first line of the input contains two integer numbers n and k (1 ≤ k ≤ n ≤ 105) — the duration of the lecture in minutes and the number of minutes you can keep Mishka awake.
The second line of the input contains n integer numbers a1, a2, ... an (1 ≤ ai ≤ 104) — the number of theorems lecturer tells during the i-th minute.
The third line of the input contains n integer numbers t1, t2, ... tn (0 ≤ ti ≤ 1) — type of Mishka's behavior at the i-th minute of the lecture.
","input
Print only one integer — the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
output
In the sample case the better way is to use the secret technique at the beginning of the third minute. Then the number of theorems Mishka will be able to write down will be equal to 16.
","datastructures, dp, implementation, twopointers",3
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
# sys.setrecursionlimit(111111) 
 
def main():
    

  
 

          
                  
    # mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    

            


    ###CODE
    tc = 1
    for _ in range(tc):
        n,x=ria()
        a=ria()
        d=Counter(a)
        sa=set(a)
        if len(sa)<n:
            print(0)
        else:
            c=0
            for i in a:
                k=i&x
                if k!=i and k in d:
                    c=1
                    print(1)
                    break            
            if c==0:
                z=[]
                for i in a:
                    z.append(i&x)
                if len(set(z))<n:
                    print(2)
                else:
                    print(""-1"")
        
        
                
        
            
        
                    
                                    
                
        
            
                    
                    
        
            
        
        
        
            
            
            
            
            
        
        
                    
            
        
        
                    
                
        
        
            
                
        

            
        

               
            
        
              
                
        
        
            
        
        
            
            
        
        
                
                
                
                
            
        
        
            
           
        
            
                    

                                 
                
                
        

                
        
        
        
            
        
        
                
            
        
        
                    
        
        
        
            
                    
            

                
            
            
                
            
                
            
            
            
            
                
            
        
        
        
        
        
        
        
                    
        
        
        
                
                
        
            
            
            
        

                    
        
                
        
        
                        
        
                            

        

                
            
        

                
            
                    
                
                
        
        
         
        

                        
                            
                
        
                            
                    

                
            
        
                
            
                
        
        
        
                             
        
            
        
        
            
                        
                        
                    
            
        
        
        
        
        
                        
       

        
                           
        
        
        
            
        
        
        
                      

      
                            
            
        
        
            
            
            
            
            
        
        
        
            
        
        
        
            
        
        
        
        
            
            
        
        
        
        
        
        
        
                
                
                    
        
        
            
            
        
                
            
            
        
        
        
        
                
        
            
        
                
        
        
            
        
       
            

                
        
        
        
   
            
        
        
        
        
            
        
                
        
        
        
            
            
        
        
            
        
        

        
        
            
        
        
            
        
                        

        
        
            
     
        
        
            
        
        
                
            
        
        
        
                
            
        

            
             
        
            
        
        
        
                
        
            
        
        
        
        
                
        
        
            
        
        
        
        
                
        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",1013_B,CODEFORCES,1835,And,"There is an array with n elements a1, a2, ..., an and the number x.
In one operation you can select some i (1 ≤ i ≤ n) and replace element ai with ai & x, where & denotes the bitwise and operation.
You want the array to have at least two equal elements after applying some operations (possibly, none). In other words, there should be at least two distinct indices i ≠ j such that ai = aj. Determine whether it is possible to achieve and, if possible, the minimal number of operations to apply.
The first line contains integers n and x (2 ≤ n ≤ 100 000, 1 ≤ x ≤ 100 000), number of elements in the array and the number to and with.
The second line contains n integers ai (1 ≤ ai ≤ 100 000), the elements of the array.
Print a single integer denoting the minimal number of operations to do, or -1, if it is impossible.
In the first example one can apply the operation to the last element of the array. That replaces 7 with 3, so we achieve the goal in one move.
","input
In the second example the array already has two equal elements.
output
In the third example applying the operation won't change the array at all, so it is impossible to make some pair of elements equal.
",greedy,3
"t = int(input())
for i in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    a = sorted(a)
    print(min(a[-2]-1, n-2))
",1197_A,CODEFORCES,3011,DIY Wooden Ladder,"Let's denote a $$$k$$$-step ladder as the following structure: exactly $$$k + 2$$$ wooden planks, of which
Note that neither the base planks, nor the steps planks are required to be equal.
For example, ladders $$$1$$$ and $$$3$$$ are correct $$$2$$$-step ladders and ladder $$$2$$$ is a correct $$$1$$$-step ladder. On the first picture the lengths of planks are $$$[3, 3]$$$ for the base and $$$[1]$$$ for the step. On the second picture lengths are $$$[3, 3]$$$ for the base and $$$[2]$$$ for the step. On the third picture lengths are $$$[3, 4]$$$ for the base and $$$[2, 3]$$$ for the steps. 
You have $$$n$$$ planks. The length of the $$$i$$$-th planks is $$$a_i$$$. You don't have a saw, so you can't cut the planks you have. Though you have a hammer and nails, so you can assemble the improvised ""ladder"" from the planks.
The question is: what is the maximum number $$$k$$$ such that you can choose some subset of the given planks and assemble a $$$k$$$-step ladder using them?
The first line contains a single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of queries. The queries are independent.
Each query consists of two lines. The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^5$$$) — the number of planks you have.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^5$$$) — the lengths of the corresponding planks.
It's guaranteed that the total number of planks from all queries doesn't exceed $$$10^5$$$.
Print $$$T$$$ integers — one per query. The $$$i$$$-th integer is the maximum number $$$k$$$, such that you can choose some subset of the planks given in the $$$i$$$-th query and assemble a $$$k$$$-step ladder using them.
Print $$$0$$$ if you can't make even $$$1$$$-step ladder from the given set of planks.
","input
Examples for the queries $$$1-3$$$ are shown at the image in the legend section.
output
The Russian meme to express the quality of the ladders:
","greedy, math, sortings",4
"import os,sys,math 
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192
#complete the main function with number of test cases to complete greater than x
def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:            
        return len(a)

def solve():
    n=I()
    points,l=[],[]
    for i in range(n):
        a,b=In()
        l.append((a,b))
        points.append(a)
        points.append(b)
    points.sort()
    k=0 
    d={}
    l1=[]
    for i in range(2*n):
        if d.get(points[i],-1)==-1:
            d[points[i]]=k
            l1.append(points[i])
            k+=1
    # print(l1)
    n1=len(d)
    dp=[[0,0] for i in range(n1)]
    for a,b in l:
        dp[d[a]][0]+=1
        dp[d[b]][1]-=1

    ans={}
    last=dp[0][0]
    ans[last]=1
    last+=dp[0][1]
    for i in range(1,n1):
        cnts=l1[i]-l1[i-1]-1
        if ans.get(last,-1)!=-1:
            ans[last]+=cnts
        else:
            ans[last]=cnts
        last+=dp[i][0]
        if ans.get(last,-1)!=-1:
            ans[last]+=1
        else:
            ans[last]=1
        last+=dp[i][1]
    if ans.get(last,-1)!=-1:
        ans[last]+=1
    else:
        ans[last]=1
    for i in range(1,n+1):
        print(ans.get(i,0),end=' ')
    print()
    pass
def main():
    T=1
    for i in range(T):
        solve()
        
M = 998244353
P = 1000000007
 




class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == '__main__':
    main()",1000_C,CODEFORCES,2659,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings",4
"from itertools import*
def out1(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==1 and b==0 and c==0:
        return 1
    return a*(out2(a-1,b,c)+out3(a-1,b,c))
def out2(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==1 and c==0:
        return 1
    return b*(out1(a,b-1,c)+out3(a,b-1,c))
def out3(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==0 and c==1:
        return 1
    return c*(out2(a,b,c-1)+out1(a,b,c-1))
def column(matrix, i):
    return [row[i] for row in matrix]
N, T = [int(x) for x in raw_input().split()]
A = []
s = 0
for i in range(N):
    A.append([int(x) for x in raw_input().split()])
for i in range(1,N+1):
    comb = list(combinations(A, i))
    for x in comb:
        if sum(column(x,0))==T:
            a = column(x,1).count(1)
            b = column(x,1).count(2)
            c = column(x,1).count(3)
            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))
print(s%1000000007)",1185_G1,CODEFORCES,4605,Playlist for Polycarp (easy version),"The only difference between easy and hard versions is constraints.
Polycarp loves to listen to music, so he never leaves the player, even on the way home from the university. Polycarp overcomes the distance from the university to the house in exactly $$$T$$$ minutes.
In the player, Polycarp stores $$$n$$$ songs, each of which is characterized by two parameters: $$$t_i$$$ and $$$g_i$$$, where $$$t_i$$$ is the length of the song in minutes ($$$1 \le t_i \le 15$$$), $$$g_i$$$ is its genre ($$$1 \le g_i \le 3$$$).
Polycarp wants to create such a playlist so that he can listen to music all the time on the way from the university to his home, and at the time of his arrival home, the playlist is over. Polycarp never interrupts songs and always listens to them from beginning to end. Thus, if he started listening to the $$$i$$$-th song, he would spend exactly $$$t_i$$$ minutes on its listening. Polycarp also does not like when two songs of the same genre play in a row (i.e. successively/adjacently) or when the songs in his playlist are repeated.
Help Polycarpus count the number of different sequences of songs (their order matters), the total duration is exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different.
The first line of the input contains two integers $$$n$$$ and $$$T$$$ ($$$1 \le n \le 15, 1 \le T \le 225$$$) — the number of songs in the player and the required total duration, respectively.
Next, the $$$n$$$ lines contain descriptions of songs: the $$$i$$$-th line contains two integers $$$t_i$$$ and $$$g_i$$$ ($$$1 \le t_i \le 15, 1 \le g_i \le 3$$$) — the duration of the $$$i$$$-th song and its genre, respectively.
Output one integer — the number of different sequences of songs, the total length of exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different. Since the answer may be huge, output it modulo $$$10^9 + 7$$$ (that is, the remainder when dividing the quantity by $$$10^9 + 7$$$).
In the first example, Polycarp can make any of the $$$6$$$ possible playlist by rearranging the available songs: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$ and $$$[3, 2, 1]$$$ (indices of the songs are given).
","input
In the second example, the first and second songs cannot go in succession (since they have the same genre). Thus, Polycarp can create a playlist in one of $$$2$$$ possible ways: $$$[1, 3, 2]$$$ and $$$[2, 3, 1]$$$ (indices of the songs are given).
output
In the third example, Polycarp can make the following playlists: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$, $$$[3, 2, 1]$$$, $$$[1, 4]$$$, $$$[4, 1]$$$, $$$[2, 3, 4]$$$ and $$$[4, 3, 2]$$$ (indices of the songs are given).
","bitmasks, combinatorics, dp",7
"n = int(input())
a = list(map(int,input().split()))

dupes = 0
dupeVal = -1
d = set()
for el in a:
    if el in d:
        dupes += 1
        dupeVal = el
    else:
        d.add(el)

inPlay = True
if dupes > 1:
    print('cslnb')
    inPlay = False
elif dupes == 1:
    if dupeVal == 0 or (dupeVal - 1) in d:
        print('cslnb')
        inPlay = False

if inPlay:
    finalSum = (n*(n-1))//2
    Sum = sum(a)
    if (Sum - finalSum) % 2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
    
",1190_B,CODEFORCES,2185,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
",games,3
"
def main():
  N, M = map(int, input().split())
  L = [tuple(map(int, input().split())) for _ in range(N)]
  maxi = max(max(t) for t in L)+1
  mini, res = max((min(t), i) for i, t in enumerate(L))
  res = res, res
  BITMASK = (1 << M)
  while True:
    mid = (maxi+mini)//2
    #print(f'{mini} {mid} {maxi}')
    if mid == mini:
      break
    masks = [None]*BITMASK
    for i, t in enumerate(L):
      tmask = 0
      for v in t:
        tmask *= 2
        if v >= mid:
          tmask += 1
      if masks[tmask] is not None:
        continue
      masks[tmask] = i
      for k in range(BITMASK):
        if masks[k] is not None and k | tmask == BITMASK-1:
          res = masks[k], i
          mini = mid = min(max(a, b) for a, b in zip(L[res[0]], L[res[1]]))
          break
      else:
        continue
      break
    else:
      maxi = mid
    #print(masks)
  print(res[0]+1, res[1]+1)


main()
",1288_D,CODEFORCES,4658,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"import sys
input = sys.stdin.readline

n, m = map(int, input().split())
mask = (1 << m) - 1

l = []
for i in range(n):
    l.append(list(map(int,input().split())))

lo = -1 #Possible
hi = 10 ** 9 + 1 #Impossible
while hi - lo > 1:
    test = (hi + lo) // 2

    things = dict()
    for i in range(n):
        curr = 0
        for v in l[i]:
            curr *= 2
            if v >= test:
                curr += 1
        things[curr] = i

    works = False
    for v1 in things:
        for v2 in things:
            if v1 | v2 == mask:
                outi = things[v1]
                outj = things[v2]
                works = True
                break
        if works:
            break

    if works:
        lo = test
    else:
        hi = test

print(outi + 1, outj + 1)
",1288_D,CODEFORCES,4651,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"actual = input()
processed = input()


def factorial(num: int):
    res = 1
    while num >= 1:
        res *= num
        num -= 1
    return res


actualPos = actual.count('+')
actualNeg = actual.count('-')
processedPos = processed.count('+')
processedNeg = processed.count('-')

if processedPos > actualPos or processedNeg > actualNeg:
    print(0)
elif processedPos == actualPos and processedNeg == actualNeg:
    print(1)
else:
    remainPos = actualPos - processedPos
    remainNeg = actualNeg - processedNeg

    print((factorial(remainPos + remainNeg) / (factorial(remainPos) * factorial(remainNeg))) / 2 ** (
            remainPos + remainNeg))
",0476_B,CODEFORCES,4319,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

n,k=kk()
pre,post = [],[]
k-=1
v = 1
for i in range(n-2,-1,-1):
	if k&(2**i):
		post.append(v)
	else:
		pre.append(v)
	v+=1
print(*pre,n,*reversed(post))",0513_B1,CODEFORCES,4403,Permutations,"You are given a permutation p of numbers 1, 2, ..., n. Let's define f(p) as the following sum:
Find the lexicographically m-th permutation of length n in the set of permutations having the maximum possible value of f(p).
The single line of input contains two integers n and m (1 ≤ m ≤ cntn), where cntn is the number of permutations of length n with maximum possible value of f(p).
The problem consists of two subproblems. The subproblems have different constraints on the input. You will get some score for the correct submission of the subproblem. The description of the subproblems follows.
","input
Output n number forming the required permutation.
output
In the first example, both permutations of numbers {1, 2} yield maximum possible f(p) which is equal to 4. Among them, (2, 1) comes second in lexicographical order.
",bruteforce,7
"from bisect import bisect_right as br
from bisect import bisect_left as bl
from math import *

def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2: 
        return True    
    if not n & 1: 
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False

    return True

def mhd(a,b,x,y):

    return abs(a-x)+abs(b-y)


n = int(input())
a,b = map(int,input().split())
if(mhd(a,b,1,1)<=mhd(a,b,n,n)):
    print('White')
else:
    print('Black')",1075_A,CODEFORCES,564,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"n = int(input())
a = list(map(int, input().split()))
s = 0

for j, i in enumerate(a):
    if i > s:
        print(j + 1)
        exit()
    if i == s:
        s += 1

print(-1)
",1054_B,CODEFORCES,1959,Appending Mex,"Initially Ildar has an empty array. He performs $$$n$$$ steps. On each step he takes a subset of integers already added to the array and appends the mex of this subset to the array. 
The mex of an multiset of integers is the smallest non-negative integer not presented in the multiset. For example, the mex of the multiset $$$[0, 2, 3]$$$ is $$$1$$$, while the mex of the multiset $$$[1, 2, 1]$$$ is $$$0$$$.
More formally, on the step $$$m$$$, when Ildar already has an array $$$a_1, a_2, \ldots, a_{m-1}$$$, he chooses some subset of indices $$$1 \leq i_1 < i_2 < \ldots < i_k < m$$$ (possibly, empty), where $$$0 \leq k < m$$$, and appends the $$$mex(a_{i_1}, a_{i_2}, \ldots a_{i_k})$$$ to the end of the array.
After performing all the steps Ildar thinks that he might have made a mistake somewhere. He asks you to determine for a given array $$$a_1, a_2, \ldots, a_n$$$ the minimum step $$$t$$$ such that he has definitely made a mistake on at least one of the steps $$$1, 2, \ldots, t$$$, or determine that he could have obtained this array without mistakes.
The first line contains a single integer $$$n$$$ ($$$1 \leq n \leq 100\,000$$$) — the number of steps Ildar made.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 10^9$$$) — the array Ildar obtained.
If Ildar could have chosen the subsets on each step in such a way that the resulting array is $$$a_1, a_2, \ldots, a_n$$$, print $$$-1$$$.
Otherwise print a single integer $$$t$$$ — the smallest index of a step such that a mistake was made on at least one step among steps $$$1, 2, \ldots, t$$$.
In the first example it is possible that Ildar made no mistakes. Here is the process he could have followed.
Thus, he can get the array without mistakes, so the answer is $$$-1$$$.
","input
In the second example he has definitely made a mistake on the very first step, because he could not have obtained anything different from $$$0$$$.
output
In the third example he could have obtained $$$[0, 1, 2]$$$ without mistakes, but $$$239$$$ is definitely wrong.
",implementation,3
"# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
import collections
 
#T = int(input())
 
#W,H = [int(x) for x in stdin.readline().split()]
#arr = [int(x) for x in stdin.readline().split()]
 
#s = input()
#N = len(s)
 
N,M,K = [int(x) for x in stdin.readline().split()]
arr = [int(x) for x in stdin.readline().split()]
 


res = 0
for j in range(M):
    s = 0
    mini = 0
    for i in range(j,N):
        if i%M==j:
            mini = min(mini,s)
            s -= K
        
        s += arr[i]
        
        res = max(res,s-mini)
        
print(res)

",1197_D,CODEFORCES,3636,Yet Another Subarray Problem,"You are given an array $$$a_1, a_2, \dots , a_n$$$ and two integers $$$m$$$ and $$$k$$$.
You can choose some subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$. 
The cost of subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$ is equal to $$$\sum\limits_{i=l}^{r} a_i - k \lceil \frac{r - l + 1}{m} \rceil$$$, where $$$\lceil x \rceil$$$ is the least integer greater than or equal to $$$x$$$. 
The cost of empty subarray is equal to zero.
For example, if $$$m = 3$$$, $$$k = 10$$$ and $$$a = [2, -4, 15, -3, 4, 8, 3]$$$, then the cost of some subarrays are:
Your task is to find the maximum cost of some subarray (possibly empty) of array $$$a$$$.
The first line contains three integers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \le n \le 3 \cdot 10^5, 1 \le m \le 10, 1 \le k \le 10^9$$$).
","input
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$).
output
Print the maximum cost of some subarray of array $$$a$$$.
","dp, greedy, math",5
"import math
from collections import defaultdict
ml=lambda:map(int,input().split())
ll=lambda:list(map(int,input().split()))
ii=lambda:int(input())
ip=lambda:list(input())

""""""========main code===============""""""

n,k=ml()
ans=0;
for i in range(1,1000001):
    val=(i*(i+1))//2
    if(val-(n-i)==k):
        ans=n-i
print(ans)        ",1195_B,CODEFORCES,1406,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))
b.sort()
g.sort()
if b[-1] > g[0]:
    print(-1)
    import sys
    sys.exit(0)
a = 0
a += sum(g) - g[0]
if g[0] == b[-1]:
    a += g[0]
    a += m * sum(b[:-1])
    print(a)
else:
    a += g[0]
    a += m * sum(b[:-2]) + (m - 1) * b[-2] + b[-1]
    print(a)
",1159_C,CODEFORCES,2932,The Party and Sweets,"$$$n$$$ boys and $$$m$$$ girls came to the party. Each boy presented each girl some integer number of sweets (possibly zero). All boys are numbered with integers from $$$1$$$ to $$$n$$$ and all girls are numbered with integers from $$$1$$$ to $$$m$$$. For all $$$1 \leq i \leq n$$$ the minimal number of sweets, which $$$i$$$-th boy presented to some girl is equal to $$$b_i$$$ and for all $$$1 \leq j \leq m$$$ the maximal number of sweets, which $$$j$$$-th girl received from some boy is equal to $$$g_j$$$.
More formally, let $$$a_{i,j}$$$ be the number of sweets which the $$$i$$$-th boy give to the $$$j$$$-th girl. Then $$$b_i$$$ is equal exactly to the minimum among values $$$a_{i,1}, a_{i,2}, \ldots, a_{i,m}$$$ and $$$g_j$$$ is equal exactly to the maximum among values $$$b_{1,j}, b_{2,j}, \ldots, b_{n,j}$$$.
You are interested in the minimum total number of sweets that boys could present, so you need to minimize the sum of $$$a_{i,j}$$$ for all $$$(i,j)$$$ such that $$$1 \leq i \leq n$$$ and $$$1 \leq j \leq m$$$. You are given the numbers $$$b_1, \ldots, b_n$$$ and $$$g_1, \ldots, g_m$$$, determine this number. 
The first line contains two integers $$$n$$$ and $$$m$$$, separated with space — the number of boys and girls, respectively ($$$2 \leq n, m \leq 100\,000$$$). The second line contains $$$n$$$ integers $$$b_1, \ldots, b_n$$$, separated by spaces — $$$b_i$$$ is equal to the minimal number of sweets, which $$$i$$$-th boy presented to some girl ($$$0 \leq b_i \leq 10^8$$$). The third line contains $$$m$$$ integers $$$g_1, \ldots, g_m$$$, separated by spaces — $$$g_j$$$ is equal to the maximal number of sweets, which $$$j$$$-th girl received from some boy ($$$0 \leq g_j \leq 10^8$$$).
If the described situation is impossible, print $$$-1$$$. In another case, print the minimal total number of sweets, which boys could have presented and all conditions could have satisfied.
In the first test, the minimal total number of sweets, which boys could have presented is equal to $$$12$$$. This can be possible, for example, if the first boy presented $$$1$$$ and $$$4$$$ sweets, the second boy presented $$$3$$$ and $$$2$$$ sweets and the third boy presented $$$1$$$ and $$$1$$$ sweets for the first and the second girl, respectively. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$12$$$.
","input
In the second test, the boys couldn't have presented sweets in such way, that all statements satisfied.
output
In the third test, the minimal total number of sweets, which boys could have presented is equal to $$$4$$$. This can be possible, for example, if the first boy presented $$$1$$$, $$$1$$$, $$$2$$$ sweets for the first, second, third girl, respectively and the second boy didn't present sweets for each girl. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$4$$$.
","greedy, implementation, math",4
"l,r = map(int, input().split())
ans = 0
a,b,c = [],[],[]
if l==r:
    print(0)
    exit()

for i in range(63, -1, -1):
    if (r^l) & (1<<i):
        for j in range(i,-1,-1):
            ans|= 1<<j
        break
print(ans)",0276_D,CODEFORCES,883,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations


def li():
	return list(map(int , input().split()))


def num():
	return map(int , input().split())


def nu():
	return int(input())


n,m=num()
a=li()
ind=-1
z=0
ll=sorted(a)
mx=ll[n-1]-1
cc=0
for i in range(n-2,-1,-1):
	if (ll[i] == 0):
		continue
	if(mx==0):
		cc += ll[i] - 1
		continue

	if(ll[i]>=mx):
		cc+=1
		mx-=1
		cc+=ll[i]-1
		ll[i]=1
	else:
		mx=ll[i]
		cc+=1
		mx-=1
		cc += ll[i] - 1
		ll[i] = 1

print(cc)",1061_B,CODEFORCES,2846,Views Matter,"You came to the exhibition and one exhibit has drawn your attention. It consists of $$$n$$$ stacks of blocks, where the $$$i$$$-th stack consists of $$$a_i$$$ blocks resting on the surface.
The height of the exhibit is equal to $$$m$$$. Consequently, the number of blocks in each stack is less than or equal to $$$m$$$.
There is a camera on the ceiling that sees the top view of the blocks and a camera on the right wall that sees the side view of the blocks.
Find the maximum number of blocks you can remove such that the views for both the cameras would not change.
Note, that while originally all blocks are stacked on the floor, it is not required for them to stay connected to the floor after some blocks are removed. There is no gravity in the whole exhibition, so no block would fall down, even if the block underneath is removed. It is not allowed to move blocks by hand either.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 100\,000$$$, $$$1 \le m \le 10^9$$$) — the number of stacks and the height of the exhibit.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le m$$$) — the number of blocks in each stack from left to right.
Print exactly one integer — the maximum number of blocks that can be removed.
","input
The following pictures illustrate the first example and its possible solution.
output
Blue cells indicate removed blocks. There are $$$10$$$ blue cells, so the answer is $$$10$$$.
","greedy, implementation, sortings",4
"import math
from decimal import Decimal

def sum2(s, e):
    return sum1(e) - sum1(s - 1) - (e - s)

def sum1(i):
    return i * (i + 1) / 2

line = input().split()
n = Decimal(line[0])
k = Decimal(line[1])
if(n == 1):
    print(0)
elif(k > n):
    print(1)
elif(sum2(Decimal(2),k) < n):
    print(-1)
else:
    c = 2 * n + k - k * k
    discriminant = (9 - 4 * c).sqrt()
    tmp = discriminant / 2
    const = Decimal(3/2)
    res1 = math.floor(const + tmp)
    res2 = math.floor(const - tmp)
    res1 = max(res1, res2)
    print(k - res1 + 1);",0287_B,CODEFORCES,912,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline    
 
n,m,k = [int(i) for i in input().split()]
h = []
for i in range (n):
    h.append([int(i) for i in input().split()])
v = []
for i in range (n-1):
    v.append([int(i) for i in input().split()])
if k%2:
    for i in range (n):
        for j in range (m):
            print(-1,end="" "")
        print()
    exit()
dp = [[[float('inf')]*m for i in range (n)] for j in range (k//2+1)]
for i in range (n):
    for j in range (m):
        dp[0][i][j] = 0
for x in range (1,k//2+1):
    for i in range (n):
        for j in range (m):
            if i!=0:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i-1][j] + v[i-1][j])
            if i!=n-1:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i+1][j] + v[i][j])
            if j!=0:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i][j-1] + h[i][j-1])
            if j!=m-1:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i][j+1] + h[i][j])
 
for i in range (n):
    for j in range (m):
        print(2*dp[k//2][i][j],end="" "")
    print()",1517_D,CODEFORCES,4171,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"q = int(input())
for _ in range(q):
    n, k = map(int, input().split())
    s = input()
    ans = k
    sample = ""RGB""
    for i in range(n - k + 1):
        cnt = 0
        x = 0
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3
        #print(ans, 7)
        ans = min(ans, cnt)
        cnt = 0
        x = 1
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3
        ans = min(ans, cnt)
        #print(ans, 8)
        cnt = 0
        x = 2
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3
        ans = min(ans, cnt) 
        #print(ans, 9)       
    print(ans)",1196_D1,CODEFORCES,3606,RGB Substring (easy version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2000$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2000$$$ ($$$\sum n \le 2000$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
",implementation,5
"from sys import *

n, k = map(int, stdin.readline().split())
arr = list(map(int, stdin.readline().split()))
avg = 0
for i in range(n):
	cnt = 0
	sum = 0
	for j in range(i, n):
		sum += arr[j]
		cnt += 1
		if cnt >= k:
			avg = max(avg, sum / cnt)
print(avg)",1003_C,CODEFORCES,3350,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math",5
"n, m, a, b = map(int, input().split())
print(min(n%m*b, (m-n%m)*a))
",0990_A,CODEFORCES,1694,Commentary Boxes,"Berland Football Cup starts really soon! Commentators from all over the world come to the event.
Organizers have already built $$$n$$$ commentary boxes. $$$m$$$ regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.
If $$$n$$$ is not divisible by $$$m$$$, it is impossible to distribute the boxes to the delegations at the moment.
Organizers can build a new commentary box paying $$$a$$$ burles and demolish a commentary box paying $$$b$$$ burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.
What is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$)?
The only line contains four integer numbers $$$n$$$, $$$m$$$, $$$a$$$ and $$$b$$$ ($$$1 \le n, m \le 10^{12}$$$, $$$1 \le a, b \le 100$$$), where $$$n$$$ is the initial number of the commentary boxes, $$$m$$$ is the number of delegations to come, $$$a$$$ is the fee to build a box and $$$b$$$ is the fee to demolish a box.
Output the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$). It is allowed that the final number of the boxes is equal to $$$0$$$.
In the first example organizers can build $$$5$$$ boxes to make the total of $$$14$$$ paying $$$3$$$ burles for the each of them.
","input
In the second example organizers can demolish $$$2$$$ boxes to make the total of $$$0$$$ paying $$$7$$$ burles for the each of them.
output
In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get $$$5$$$ boxes.
","implementation, math",3
"n = int(input())
arr = input().split() 
b = []
 
for x in arr:
	b.append(int(x))
 
cnt = {}
ans = 0
 
for i in range(n):
	ans += b[i]*(i) + (-b[i])*(n - i - 1)
 
 
for i in range(n):
	if((b[i] - 1) in cnt.keys()):
		ans -= cnt[b[i] - 1]
	if((b[i] + 1) in cnt.keys()):
		ans += cnt[b[i] + 1]
	if((b[i]) in cnt.keys()):
		cnt[b[i]] += 1
	else:
		cnt[b[i]] = 1
 
print(ans)",0903_D,CODEFORCES,2448,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math",4
"n = int(input())
w = list(map(int, input().split()))
ent = input()
mp = {w[i]: i+1 for i in range(n)}
sorted(mp)
w.sort()
ptr = 0
a = 0
stk = []
for i in range(2 * n):
    if ent[i] == ""0"":
        print(mp[w[ptr]], end="" "")
        stk.append(mp[w[ptr]])
        ptr += 1
    else:
        print(stk.pop(), end="" "")
    # print(pr.queue)
print()
",0982_B,CODEFORCES,2560,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation",4
"import os
import sys
from io import BytesIO, IOBase
# region fastio
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def getint(): return int(input())
def getints(): return list(map(int, input().split()))
def getint1(): return list(map(lambda x: int(x) - 1, input().split()))

def main():
    a,b = getints()
    print(result(a,b))

def result(a,b):
    if a==0 or b==0:
        return 0
    if a>b:
        return a//b+result(a%b,b)
    else:
        return b//a+result(b%a,a)

if __name__ == ""__main__"":
    main()",0343_A,CODEFORCES,138,Rational Resistance,"Mad scientist Mike is building a time machine in his spare time. To finish the work, he needs a resistor with a certain resistance value.
However, all Mike has is lots of identical resistors with unit resistance R0 = 1. Elements with other resistance can be constructed from these resistors. In this problem, we will consider the following as elements: 
With the consecutive connection the resistance of the new element equals R = Re + R0. With the parallel connection the resistance of the new element equals . In this case Re equals the resistance of the element being connected.
Mike needs to assemble an element with a resistance equal to the fraction . Determine the smallest possible number of resistors he needs to make such an element.
The single input line contains two space-separated integers a and b (1 ≤ a, b ≤ 1018). It is guaranteed that the fraction  is irreducible. It is guaranteed that a solution always exists.
Print a single number — the answer to the problem.
Please do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.
","input
In the first sample, one resistor is enough.
output
In the second sample one can connect the resistors in parallel, take the resulting element and connect it to a third resistor consecutively. Then, we get an element with resistance . We cannot make this element using two resistors.
","math, numbertheory",1
"n=int(input())
d={}
for _ in range(n):
    a,x=map(int, input().split())
    d[a]=x
m=int(input())
for _ in range(m):
    b,y=map(int, input().split())
    d[b]=max(y, d.get(b,0))
print(sum(d.values()))
    
",0981_B,CODEFORCES,2531,Businessmen Problems,"Two famous competing companies ChemForces and TopChemist decided to show their sets of recently discovered chemical elements on an exhibition. However they know that no element should be present in the sets of both companies.
In order to avoid this representatives of both companies decided to make an agreement on the sets the companies should present. The sets should be chosen in the way that maximizes the total income of the companies.
All elements are enumerated with integers. The ChemForces company has discovered $$$n$$$ distinct chemical elements with indices $$$a_1, a_2, \ldots, a_n$$$, and will get an income of $$$x_i$$$ Berland rubles if the $$$i$$$-th element from this list is in the set of this company.
The TopChemist company discovered $$$m$$$ distinct chemical elements with indices $$$b_1, b_2, \ldots, b_m$$$, and it will get an income of $$$y_j$$$ Berland rubles for including the $$$j$$$-th element from this list to its set.
In other words, the first company can present any subset of elements from $$$\{a_1, a_2, \ldots, a_n\}$$$ (possibly empty subset), the second company can present any subset of elements from $$$\{b_1, b_2, \ldots, b_m\}$$$ (possibly empty subset). There shouldn't be equal elements in the subsets.
Help the representatives select the sets in such a way that no element is presented in both sets and the total income is the maximum possible.
The first line contains a single integer $$$n$$$ ($$$1 \leq n \leq 10^5$$$)  — the number of elements discovered by ChemForces.
The $$$i$$$-th of the next $$$n$$$ lines contains two integers $$$a_i$$$ and $$$x_i$$$ ($$$1 \leq a_i \leq 10^9$$$, $$$1 \leq x_i \leq 10^9$$$)  — the index of the $$$i$$$-th element and the income of its usage on the exhibition. It is guaranteed that all $$$a_i$$$ are distinct.
The next line contains a single integer $$$m$$$ ($$$1 \leq m \leq 10^5$$$)  — the number of chemicals invented by TopChemist.
The $$$j$$$-th of the next $$$m$$$ lines contains two integers $$$b_j$$$ and $$$y_j$$$, ($$$1 \leq b_j \leq 10^9$$$, $$$1 \leq y_j \leq 10^9$$$)  — the index of the $$$j$$$-th element and the income of its usage on the exhibition. It is guaranteed that all $$$b_j$$$ are distinct.
Print the maximum total income you can obtain by choosing the sets for both companies in such a way that no element is presented in both sets.
","input
In the first example ChemForces can choose the set ($$$3, 7$$$), while TopChemist can choose ($$$1, 2, 4$$$). This way the total income is $$$(10 + 2) + (4 + 4 + 4) = 24$$$.
output
In the second example ChemForces can choose the only element $$$10^9$$$, while TopChemist can choose ($$$14, 92, 35$$$). This way the total income is $$$(239) + (15 + 65 + 89) = 408$$$.
",sortings,4
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))

A.sort()

ANS=[0]*n

NOW=1
for i in range(n):
    if ANS[i]==0:
        ANS[i]=NOW

        for j in range(i,n):
            if A[j]%A[i]==0 and ANS[j]==0:
                ANS[j]=NOW

        NOW+=1

print(max(ANS))
",1209_A,CODEFORCES,3663,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"n = int(input())
a = [int(s) for s in input().split()]
ans = [None]*n

def get(p):
    # print(ans)
    if ans[p] is not None:
        return ans[p]
    elif a[p] == 1:
        ans[p] = ""A""
    elif a[p] == n:
        ans[p] = ""B""
    else:
        for i in range(p+a[p], n, a[p]):
            if a[i] > a[p]:
                if get(i) == ""B"":
                    ans[p] = ""A""
                    return ans[p]
        for i in range(p-a[p], -1, -a[p]):
            if a[i] > a[p]:
                if get(i) == ""B"":
                    ans[p] = ""A""
                    return ans[p]
        ans[p] = ""B""
    return ans[p]

if n == 1:
    print(""B"")
else:
    for i in range(n-1, -1, -1):
        get(i)
    print(''.join(ans))",1033_C,CODEFORCES,1911,Permutation Game,"After a long day, Alice and Bob decided to play a little game. The game board consists of $$$n$$$ cells in a straight line, numbered from $$$1$$$ to $$$n$$$, where each cell contains a number $$$a_i$$$ between $$$1$$$ and $$$n$$$. Furthermore, no two cells contain the same number. 
A token is placed in one of the cells. They take alternating turns of moving the token around the board, with Alice moving first. The current player can move from cell $$$i$$$ to cell $$$j$$$ only if the following two conditions are satisfied: 
Whoever is unable to make a move, loses. For each possible starting position, determine who wins if they both play optimally. It can be shown that the game is always finite, i.e. there always is a winning strategy for one of the players.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of numbers.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$). Furthermore, there are no pair of indices $$$i \neq j$$$ such that $$$a_i = a_j$$$.
","input
Print $$$s$$$ — a string of $$$n$$$ characters, where the $$$i$$$-th character represents the outcome of the game if the token is initially placed in the cell $$$i$$$. If Alice wins, then $$$s_i$$$ has to be equal to ""A""; otherwise, $$$s_i$$$ has to be equal to ""B"". 
output
In the first sample, if Bob puts the token on the number (not position): 
","bruteforce, dp, games",3
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations


def li():
	return list(map(int , input().split()))


# XXXX
def modInverse(a , m):
	m0 = m
	y = 0
	x = 1
	if (m == 1):
		return 0
	while (a > 1):
		q = a // m
		t = m
		m = a % m
		a = t
		t = y
		y = x - q * y
		x = t
	if (x < 0):
		x = x + m0
	return x


def num():
	return map(int , input().split())


def nu():
	return int(input())


def find_gcd(x , y):
	while (y):
		x , y = y , x % y
	return x

n,m=num()
a=[0]*n
for i in range(n):
	a[i]=[0]*m
for i in range(n):
	s=input()
	for j in range(m):
		a[i][j]=s[j]
z=["".""]*n
for i in range(n):
	z[i]=["".""]*m
for i in range(n):
	for j in range(m):
		if(j-1>=0 and j+1 <m and i+1<n and i-1>=0):
			if(a[i-1][j]==""#"" and a[i+1][j]==""#"" and a[i][j-1]==""#"" and a[i][j+1]==""#"" and a[i-1][j-1]==""#"" and a[i-1][j+1]==""#"" and a[i+1][j-1]==""#"" and a[i+1][j+1]==""#""):
				z[i-1][j]=""#""
				z[i + 1][j] = ""#""
				z[i][j - 1] = ""#""
				z[i][j + 1] = ""#""
				z[i - 1][j - 1] = ""#""
				z[i - 1][j + 1] = ""#""
				z[i + 1][j - 1] = ""#""
				z[i + 1][j + 1] = ""#""
ff=True

for i in range(n):
	for j in range(m):
		if(z[i][j]!=a[i][j]):
			ff=False
			break
if(ff):
	print(""YES"")
else:
	print(""NO"")",1059_B,CODEFORCES,3559,Forgery,"Student Andrey has been skipping physical education lessons for the whole term, and now he must somehow get a passing grade on this subject. Obviously, it is impossible to do this by legal means, but Andrey doesn't give up. Having obtained an empty certificate from a local hospital, he is going to use his knowledge of local doctor's handwriting to make a counterfeit certificate of illness. However, after writing most of the certificate, Andrey suddenly discovered that doctor's signature is impossible to forge. Or is it?
For simplicity, the signature is represented as an $$$n\times m$$$ grid, where every cell is either filled with ink or empty. Andrey's pen can fill a $$$3\times3$$$ square without its central cell if it is completely contained inside the grid, as shown below.
Determine whether is it possible to forge the signature on an empty $$$n\times m$$$ grid.
The first line of input contains two integers $$$n$$$ and $$$m$$$ ($$$3 \le n, m \le 1000$$$).
Then $$$n$$$ lines follow, each contains $$$m$$$ characters. Each of the characters is either '.', representing an empty cell, or '#', representing an ink filled cell.
If Andrey can forge the signature, output ""YES"". Otherwise output ""NO"".
You can print each letter in any case (upper or lower).
In the first sample Andrey can paint the border of the square with the center in $$$(2, 2)$$$.
In the second sample the signature is impossible to forge.
","input
In the third sample Andrey can paint the borders of the squares with the centers in $$$(2, 2)$$$ and $$$(3, 2)$$$: 
output
In the fourth sample Andrey can paint the borders of the squares with the centers in $$$(3, 3)$$$ and $$$(3, 5)$$$.
",implementation,5
"def isValid(arr, l, r, x):
	return l <= sum(arr) <= r and max(arr)-min(arr) >= x

n, l, r, x = map(int, input().strip().split())
arr = list(map(int, input().strip().split()))
valid = 0

for i in range(1, 1<<n):
	s = str(bin(i))[2:].rjust(n, '0')
	temp = []
	for j in range(n):
		if s[j] == '1':
			temp.append(arr[j])
	if isValid(temp, l, r, x):
		valid += 1
print(valid)",0550_B,CODEFORCES,4452,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"n,k = map(int,input().split())
B = [1]*(n+1)
B[0] = B[1] = 0
for i in range(2,n+1):
    if B[i] == 1:
        m = 2
        while m*i <= n:
            B[m*i] = 0
            m += 1
C = []
D = []
for i in range(len(B)):
    if B[i] != 0:
        D.append(i)
for i in range(1,len(D)):
    c = D[i] + D[i-1] + 1
    if c <= n:
        C.append(c)
x = 0
for i in range(len(C)):
    if B[C[i]] == 1:
        x += 1
if x >= k:
    print('YES')
else:
    print('NO')",0017_A,CODEFORCES,1432,Noldbach problem,"Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least k prime numbers from 2 to n inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.
Two prime numbers are called neighboring if there are no other prime numbers between them.
You are to help Nick, and find out if he is right or wrong.
The first line of the input contains two integers n (2 ≤ n ≤ 1000) and k (0 ≤ k ≤ 1000).
","input
Output YES if at least k prime numbers from 2 to n inclusively can be expressed as it was described above. Otherwise output NO.
output
In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.
","bruteforce, math, numbertheory",3
"import sys
import string


def ria():
    return [int(i) for i in input().split()]


n = ria()[0]
ar = ria()

if n == 1:
    print(ar[0])
    exit(0)

onlyNegs = True
onlyPos = True

if max(ar) >= 0:
    onlyNegs = False
if min(ar) <= 0:
    onlyPos = False

if onlyNegs:
    print(abs(sum(ar)) + max(ar) * 2)
    exit(0)

if onlyPos:
    print(abs(sum(ar)) - min(ar) * 2)
    exit(0)

print(sum([abs(i) for i in ar]))
",1038_D,CODEFORCES,1942,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation",3
"def binarySearch (N,l,r,x): 
    if r >= l: 
        mid = l + (r - l)//2
        Temp = (mid*(mid+1))//2
        if Temp-x == N-mid: 
            return N-mid 
        elif Temp-x > N-mid: 
            return binarySearch(N,l, mid-1, x)  
        else: 
            return binarySearch(N,mid + 1, r, x) 
    else: 
        return -1
n,k=list(map(int,input().split()))
print(binarySearch (n,0,n,k))",1195_B,CODEFORCES,1380,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"from __future__ import division
from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, m = rints()
a, cur, ans = rints()[::-1], 2, -1

for i in range(n - 2):
    cur = max(cur, i + 2)
    for j in range(cur, n):
        if a[i] - a[j] < 1:
            cur += 1
            continue

        if a[i] - a[j] > m:
            break

        cur += 1
        # print(cur, a[i])
        v = (a[i] - a[j - 1]) / (a[i] - a[j])
        ans = max(ans, v)

print(ans)
",0957_C,CODEFORCES,2478,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers",4
"import time
from copy import deepcopy
import itertools
from bisect import bisect_left
from bisect import bisect_right
import math
from collections import deque
from collections import Counter


def read():
    return int(input())


def readmap():
    return map(int, input().split())


def readlist():
    return list(map(int, input().split()))


n, m = readmap()
X = []
D = []
for _ in range(m):
    x, d = readmap()
    X.append(x)
    D.append(d)

summ = n * sum(X)

for i in range(m):
    d = D[i]
    if d < 0:
        if n % 2 == 1:
            summ += d * (n // 2) * (n // 2 + 1)
        else:
            summ += d * (n // 2) * (n // 2)
    else:
        summ += d * (n - 1) * n // 2

print(summ / n)",1009_C,CODEFORCES,1801,Annoying Present,"Alice got an array of length $$$n$$$ as a birthday present once again! This is the third year in a row! 
And what is more disappointing, it is overwhelmengly boring, filled entirely with zeros. Bob decided to apply some changes to the array to cheer up Alice.
Bob has chosen $$$m$$$ changes of the following form. For some integer numbers $$$x$$$ and $$$d$$$, he chooses an arbitrary position $$$i$$$ ($$$1 \le i \le n$$$) and for every $$$j \in [1, n]$$$ adds $$$x + d \cdot dist(i, j)$$$ to the value of the $$$j$$$-th cell. $$$dist(i, j)$$$ is the distance between positions $$$i$$$ and $$$j$$$ (i.e. $$$dist(i, j) = |i - j|$$$, where $$$|x|$$$ is an absolute value of $$$x$$$).
For example, if Alice currently has an array $$$[2, 1, 2, 2]$$$ and Bob chooses position $$$3$$$ for $$$x = -1$$$ and $$$d = 2$$$ then the array will become $$$[2 - 1 + 2 \cdot 2,~1 - 1 + 2 \cdot 1,~2 - 1 + 2 \cdot 0,~2 - 1 + 2 \cdot 1]$$$ = $$$[5, 2, 1, 3]$$$. Note that Bob can't choose position $$$i$$$ outside of the array (that is, smaller than $$$1$$$ or greater than $$$n$$$).
Alice will be the happiest when the elements of the array are as big as possible. Bob claimed that the arithmetic mean value of the elements will work fine as a metric.
What is the maximum arithmetic mean value Bob can achieve?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 10^5$$$) — the number of elements of the array and the number of changes.
Each of the next $$$m$$$ lines contains two integers $$$x_i$$$ and $$$d_i$$$ ($$$-10^3 \le x_i, d_i \le 10^3$$$) — the parameters for the $$$i$$$-th change.
","input
Print the maximal average arithmetic mean of the elements Bob can achieve.
output
Your answer is considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$.
","greedy, math",3
"
def bin_ser(arr,curr):
    l=0
    r=len(arr)-1
    ans=-1
    while l<=r:
        mid=(l+r)//2
        if arr[mid]<=curr:
            ans=mid
            l=mid+1
        else:
            r=mid-1
    return ans


def main():
    n,q=map(int,input().split())
    arr=list(map(int,input().split()))
    brr=list(map(int,input().split()))
    su=sum(arr)
    curr=0
    for i in range(1,n):
        arr[i]=arr[i]+arr[i-1]
    for b in brr:
        curr+=b
        pos=n-bin_ser(arr,curr)-1
        if pos==0:
            pos=n
        print(pos)
        if curr>=su:
            curr=0

main()",0975_C,CODEFORCES,2506,Valhalla Siege,"Ivar the Boneless is a great leader. He is trying to capture Kattegat from Lagertha. The war has begun and wave after wave Ivar's warriors are falling in battle.
Ivar has $$$n$$$ warriors, he places them on a straight line in front of the main gate, in a way that the $$$i$$$-th warrior stands right after $$$(i-1)$$$-th warrior. The first warrior leads the attack.
Each attacker can take up to $$$a_i$$$ arrows before he falls to the ground, where $$$a_i$$$ is the $$$i$$$-th warrior's strength.
Lagertha orders her warriors to shoot $$$k_i$$$ arrows during the $$$i$$$-th minute, the arrows one by one hit the first still standing warrior. After all Ivar's warriors fall and all the currently flying arrows fly by, Thor smashes his hammer and all Ivar's warriors get their previous strengths back and stand up to fight again. In other words, if all warriors die in minute $$$t$$$, they will all be standing to fight at the end of minute $$$t$$$.
The battle will last for $$$q$$$ minutes, after each minute you should tell Ivar what is the number of his standing warriors.
The first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \le n, q \leq 200\,000$$$) — the number of warriors and the number of minutes in the battle.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \leq a_i \leq 10^9$$$) that represent the warriors' strengths.
The third line contains $$$q$$$ integers $$$k_1, k_2, \ldots, k_q$$$ ($$$1 \leq k_i \leq 10^{14}$$$), the $$$i$$$-th of them represents Lagertha's order at the $$$i$$$-th minute: $$$k_i$$$ arrows will attack the warriors.
","input
Output $$$q$$$ lines, the $$$i$$$-th of them is the number of standing warriors after the $$$i$$$-th minute.
output
In the first example: 
",binarysearch,4
"from string import digits
from collections import Counter
a = input()
b = input()
ca = Counter(a)
l = list()
if len(b) > len(a):
    for i in digits[::-1]:
        if i in ca:
            l.extend(i * ca[i])
else:
    def asd(i, s):
        if i == len(b):
            return True
        if s:
            for j in digits[::-1]:
                if j in ca and ca[j] > 0:
                    l.extend(j * ca[j])
            return True
        else:
            for j in digits[:int(b[i])+1][::-1]:
                if j in ca and ca[j] > 0:
                    ca[j] -= 1
                    l.append(j)
                    if asd(i + 1, j != b[i]):
                        return True
                    ca[j] += 1
                    l.pop()
            return False
    asd(0, False)
print("""".join(l))

       		  	 	  	 	 	 	 	   			",915C_,CODEFORCES,4243,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"#ecnerwala's algorithm

import math
def solve(n, x, y):
    g = math.gcd(x, y)
    if g != 1:
        return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g)
    p = x + y
    weights = [n // p] * p
    for i in range(p):
        if (i * x) % p < n % p:
            weights[i] += 1
    ans = -n
    for i in range(2):
        dp = [-n, -n]
        dp[i] = 0
        for w in weights:
            dp = [max(dp[0], dp[1]), dp[0] + w]
        ans = max(ans, dp[i])
    return ans

def main():
    n, x, y = [int(x) for x in input().split()]
    print(solve(n, x, y))

main()",1463_F,CODEFORCES,4707,Max Correct Set,"Let's call the set of positive integers $$$S$$$ correct if the following two conditions are met: 
For the given values $$$n$$$, $$$x$$$, and $$$y$$$, you have to find the maximum size of the correct set.
","input
A single line contains three integers $$$n$$$, $$$x$$$ and $$$y$$$ ($$$1 \le n \le 10^9$$$; $$$1 \le x, y \le 22$$$). 
output
Print one integer — the maximum size of the correct set.
","bitmasks, dp, math",7
"from math import log
from collections import deque
n,k=map(int,input().split())
s=list(map(int,input().split()))
ans=0
s.sort()
s1=deque(s)
for j in range(11):
    d=dict()
    z=10**j
    for i in s:
        y=i*z
        u=y%k
        if u in d:
            d[u]+=1
        else:
            d.update({u:1})
    aux=0
    for i in s1:
        y=i
        lg=int(log(i,10))+1
        lg=10**lg
        if lg==z:
            aux1=(y*z)%k
            aux2=y%k
            d[aux1]-=1
            x=(k-aux2)
            if aux2==0:
                x=0
            if x in d:
                ans+=d[x]
            d[aux1]+=1
            aux+=1
        else:
            break
    for i in range(aux):
        s1.popleft()     
print(ans)
",1029_D,CODEFORCES,2791,Concatenated Multiples,"You are given an array $$$a$$$, consisting of $$$n$$$ positive integers.
Let's call a concatenation of numbers $$$x$$$ and $$$y$$$ the number that is obtained by writing down numbers $$$x$$$ and $$$y$$$ one right after another without changing the order. For example, a concatenation of numbers $$$12$$$ and $$$3456$$$ is a number $$$123456$$$.
Count the number of ordered pairs of positions $$$(i, j)$$$ ($$$i \neq j$$$) in array $$$a$$$ such that the concatenation of $$$a_i$$$ and $$$a_j$$$ is divisible by $$$k$$$.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$2 \le k \le 10^9$$$).
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
Print a single integer — the number of ordered pairs of positions $$$(i, j)$$$ ($$$i \neq j$$$) in array $$$a$$$ such that the concatenation of $$$a_i$$$ and $$$a_j$$$ is divisible by $$$k$$$.
In the first example pairs $$$(1, 2)$$$, $$$(1, 3)$$$, $$$(2, 3)$$$, $$$(3, 1)$$$, $$$(3, 4)$$$, $$$(4, 2)$$$, $$$(4, 3)$$$ suffice. They produce numbers $$$451$$$, $$$4510$$$, $$$110$$$, $$$1045$$$, $$$1012$$$, $$$121$$$, $$$1210$$$, respectively, each of them is divisible by $$$11$$$.
","input
In the second example all $$$n(n - 1)$$$ pairs suffice.
output
In the third example no pair is sufficient.
","implementation, math",4
"def get(g):
    s = [str(i) for i in g]
    num = int("""".join(s))
    return num

a = input()
b = input()
bb = int(b)
mark = [0 for i in range(len(a))]
c = a
f = []
g = []

for i in range(0 , len(a)):
    g.append(a[i])

g.sort()
g.reverse()
num = get(g)

index = []

if num <= bb:
    print(num)
    exit(0)


for i in range(0 , min(len(a) , len(b))):
    mx = '-1'
    idx = 0
    for j in range(0 , len(a)):
        if mark[j] == 0 and a[j] <= b[i]:
            if a[j] > mx:
                mx = a[j]
                idx = j

    if mx == '-1':
        rem = []

        while True and len(f) > 0:
            ma = '-1'
            id = 0
            for j in range(0 , len(a)):
                if mark[j] == 0 and a[j] < f[-1]:
                    if a[j] > ma:
                        ma = a[j]
                        id = j

            if ma == '-1':
                mark[index.pop()] = 0
                f.pop()
                continue
            else:
                mark[index.pop()] = 0
                f.pop()
                f.append(ma)
                mark[id] = 1
                break

        for j in range(0, len(a)):
            if mark[j] == 0:
                rem.append(a[j])

        rem.sort()
        rem.reverse()

        for j in rem:
            f.append(j)

        print(get(f))
        exit(0)

    f.append(mx)
    mark[idx] = 1
    index.append(idx)

    if mx < b[i] and mx != '-1':
        break

rem = []

for i in range(0 , len(a)):
    if mark[i] == 0:
        rem.append(a[i])

rem.sort()
rem.reverse()
for i in rem:
    f.append(i)

print(get(f))",915C_,CODEFORCES,4252,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"""""""n,L,a=map(int,input().split())
#s=[int(x) for x in input().split()]
ed=0
ct=0
for j in range(0,n):
    t,l=map(int,input().split())
    ct=ct+((t-ed)//a)
    ed=t+l
t=L
ct=ct+((t-ed)//a)
print(ct)""""""

n,m=map(int,input().split())
dp=[[-1 for i in range(m)] for j in range(n)]
dp2=[[-1 for i in range(m)] for j in range(n)]
#dp=[]
#dp2=[]
for i in range(0,n):
    s=input()
    for j in range(0,m):
        if(s[j]=='.'):
            dp[i][j]=-1
        else:
            dp[i][j]=s[j]
for i in range(0,n-2):
    for j in range(0,m-2):
        #print(i,j)
        p=0
        c=0
        for k in range(i,i+3):
            for h in range(j,j+3):
                p=p+1
                if(p!=5):
                    if(dp[k][h]=='#'):
                        c=c+1

                    
        if(c==8):
            p=0
            for k in range(i,i+3):
                for h in range(j,j+3):
                    p=p+1
                    if(p!=5):
                        dp2[k][h]='#'


                        
#print(dp)
#print(dp2)
if(dp==dp2):
    print('YES')
else:
    print('NO')

                            
",1059_B,CODEFORCES,3549,Forgery,"Student Andrey has been skipping physical education lessons for the whole term, and now he must somehow get a passing grade on this subject. Obviously, it is impossible to do this by legal means, but Andrey doesn't give up. Having obtained an empty certificate from a local hospital, he is going to use his knowledge of local doctor's handwriting to make a counterfeit certificate of illness. However, after writing most of the certificate, Andrey suddenly discovered that doctor's signature is impossible to forge. Or is it?
For simplicity, the signature is represented as an $$$n\times m$$$ grid, where every cell is either filled with ink or empty. Andrey's pen can fill a $$$3\times3$$$ square without its central cell if it is completely contained inside the grid, as shown below.
Determine whether is it possible to forge the signature on an empty $$$n\times m$$$ grid.
The first line of input contains two integers $$$n$$$ and $$$m$$$ ($$$3 \le n, m \le 1000$$$).
Then $$$n$$$ lines follow, each contains $$$m$$$ characters. Each of the characters is either '.', representing an empty cell, or '#', representing an ink filled cell.
If Andrey can forge the signature, output ""YES"". Otherwise output ""NO"".
You can print each letter in any case (upper or lower).
In the first sample Andrey can paint the border of the square with the center in $$$(2, 2)$$$.
In the second sample the signature is impossible to forge.
","input
In the third sample Andrey can paint the borders of the squares with the centers in $$$(2, 2)$$$ and $$$(3, 2)$$$: 
output
In the fourth sample Andrey can paint the borders of the squares with the centers in $$$(3, 3)$$$ and $$$(3, 5)$$$.
",implementation,5
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy


def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])


class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

            if id != None:
                for i in range(r):
                    self.mat[i][i] = 1

    def __add__(self, other):
        mat0 = Matrix(self.r, self.c)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]

        return mat0

    def __mul__(self, other):
        mat0 = Matrix(self.r, other.c)

        for i in range(self.r):
            for j in range(other.c):
                for k in range(self.c):
                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]

        return mat0

    def dot_mul(self, other):
        res = 0
        for i in range(self.r):
            for j in range(self.c):
                res += self.mat[i][j] * other.mat[j][i]

        return res

    def trace(self):
        res = 0
        for i in range(self.r):
            res += self.mat[i][i]

        return res

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def mat_pow(self, mat, p, mod=None):
        sq = Matrix(mat.r, mat.r, id=1)

        while p:
            if p & 1:
                p -= 1
                sq = sq * mat

            p //= 2
            mat = mat * mat

        return sq.mat


# FASTIO REGION
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",0958_A1,CODEFORCES,3125,Death Stars (easy),"The stardate is 1977 and the science and art of detecting Death Stars is in its infancy. Princess Heidi has received information about the stars in the nearby solar system from the Rebel spies and now, to help her identify the exact location of the Death Star, she needs to know whether this information is correct. 
Two rebel spies have provided her with the maps of the solar system. Each map is an N × N grid, where each cell is either occupied by a star or empty. To see whether the information is correct, Heidi needs to know whether the two maps are of the same solar system, or if possibly one of the spies is actually an Empire double agent, feeding her false information.
Unfortunately, spies may have accidentally rotated a map by 90, 180, or 270 degrees, or flipped it along the vertical or the horizontal axis, before delivering it to Heidi. If Heidi can rotate or flip the maps so that two of them become identical, then those maps are of the same solar system. Otherwise, there are traitors in the Rebel ranks! Help Heidi find out.
The first line of the input contains one number N (1 ≤ N ≤ 10) – the dimension of each map. Next N lines each contain N characters, depicting the first map: 'X' indicates a star, while 'O' indicates an empty quadrant of space. Next N lines each contain N characters, depicting the second map in the same format.
The only line of output should contain the word Yes if the maps are identical, or No if it is impossible to match them by performing rotations and translations.
","input
In the first test, you can match the first map to the second map by first flipping the first map along the vertical axis, and then by rotating it 90 degrees clockwise.
output
 
",implementation,5
"n = int(input())
visit = [0 for i in range(n+1)]
res = []
c = 0
s,t=0,0
def do(i):
	global c,s,t
	for j in range(i,n+1,2*i):
		res.append(i)
		c += 1
		if c >= (n-1) and n>2:
			if s == 0:
				s = j
			else:
				t = j
	return res
curr = 0
i = 1
while(i<=n):
	# print(i)
	do(i)
	i = 2*i
if n>2:
	res[n-1] = max(s,t)
# print(s,t)
for i in res:
	print(i,end="" "")",1059_C,CODEFORCES,2830,Sequence Transformation,"Let's call the following process a transformation of a sequence of length $$$n$$$.
If the sequence is empty, the process ends. Otherwise, append the greatest common divisor (GCD) of all the elements of the sequence to the result and remove one arbitrary element from the sequence. Thus, when the process ends, we have a sequence of $$$n$$$ integers: the greatest common divisors of all the elements in the sequence before each deletion.
You are given an integer sequence $$$1, 2, \dots, n$$$. Find the lexicographically maximum result of its transformation.
A sequence $$$a_1, a_2, \ldots, a_n$$$ is lexicographically larger than a sequence $$$b_1, b_2, \ldots, b_n$$$, if there is an index $$$i$$$ such that $$$a_j = b_j$$$ for all $$$j < i$$$, and $$$a_i > b_i$$$.
The first and only line of input contains one integer $$$n$$$ ($$$1\le n\le 10^6$$$).
Output $$$n$$$ integers  — the lexicographically maximum result of the transformation.
","input
In the first sample the answer may be achieved this way:
output
We get the sequence $$$[1, 1, 3]$$$ as the result.
","constructivealgorithms, math",4
"r, g, b = map(int, input().split())
red = list(map(int, input().split()))
green = list(map(int, input().split()))
blue = list(map(int, input().split()))
red.sort()
green.sort()
blue.sort()
red = red[::-1]
green = green[::-1]
blue = blue[::-1]

dp = []
for i in range(r + 1):
    temp = [[0] * (b + 1) for j in range(g + 1)]
    dp.append(temp)

answer = 0 

for i in range(0, r + 1):
    for j in range(0, g + 1):
        for k in range(0, b + 1):
            if i > 0 and j > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + red[i - 1] * green[j - 1])
            if i > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + red[i - 1] * blue[k - 1])
            if j > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + green[j - 1] * blue[k - 1])
                
            answer = max(answer, dp[i][j][k])
print(answer)",1398_D,CODEFORCES,3902,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"import sys,math
a,b=map(int,input().split())
l=list(map(int,input().split()))
t=[[-1,0] for i in range(100001)]
for i in range(a):
    if t[l[i]][0]!=-1:print(0);sys.exit()
    t[l[i]][0]=3
s=math.inf
for i in range(a):
    if t[l[i]&b][0]!=-1:
        #print(l[i],t[l[i]&b])
        if l[i]&b!=l[i] and t[l[i]&b][0]!=1:
            t[l[i]&b]=[1,min(2,t[l[i]&b][1]+1)]
        #print(l[i],t[l[i]&b])
    else:t[l[i]&b]=[2,1]
#for i in range(11):print(t[i])
for i in range(a):
    if t[l[i]&b][1]!=0 and t[l[i]&b][0]==1:s=min(s,t[l[i]&b][1])
if s==math.inf:
    print(-1)
else:
    print(s)
",1013_B,CODEFORCES,1837,And,"There is an array with n elements a1, a2, ..., an and the number x.
In one operation you can select some i (1 ≤ i ≤ n) and replace element ai with ai & x, where & denotes the bitwise and operation.
You want the array to have at least two equal elements after applying some operations (possibly, none). In other words, there should be at least two distinct indices i ≠ j such that ai = aj. Determine whether it is possible to achieve and, if possible, the minimal number of operations to apply.
The first line contains integers n and x (2 ≤ n ≤ 100 000, 1 ≤ x ≤ 100 000), number of elements in the array and the number to and with.
The second line contains n integers ai (1 ≤ ai ≤ 100 000), the elements of the array.
Print a single integer denoting the minimal number of operations to do, or -1, if it is impossible.
In the first example one can apply the operation to the last element of the array. That replaces 7 with 3, so we achieve the goal in one move.
","input
In the second example the array already has two equal elements.
output
In the third example applying the operation won't change the array at all, so it is impossible to make some pair of elements equal.
",greedy,3
"import sys, math
debug = 0
if debug:
    f = open(""input.txt"", ""r"")
    input = f.readline
def mp():
    return list(map(int,input().split()))

m = 1000000007    

def pow(k):
    if k == 0:
        return 1;
    z = pow(k // 2)
    if k % 2 == 1:
        return (2 * z * z) % m
    else:
        return (z * z) % m
        
def _main():
    x, k = mp()
    if(x == 0):
        print(0)
        return
    t = pow(k)
    a = x * t
    b = a - t + 1;
    print((a + b) % m)
    
     
_main()",0992_C,CODEFORCES,1048,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"def lvl(val):
    tot=1
    curr=-1
    while(val%tot==0):
        curr+=1
        tot*=2
    return [curr,val*2//(tot),tot//2]









n,q=map(int,input().split())
for _ in range(q):
    curr=int(input())
    l,v,pw=lvl(curr)
    s=input()
    for j in s:

        if j==""U"":
            if v%4==3:
                curr=curr-pw
            else:
                if curr+pw<=n:
                    curr=curr+pw

        elif j==""R"":
            if l>0:
                curr=curr+pw//2

        elif j == ""L"":
            if l > 0:
                curr = curr - pw // 2

        l, v, pw = lvl(curr)

    print(curr)



",0792_D,CODEFORCES,4529,Paths in a Complete Binary Tree,"T is a complete binary tree consisting of n vertices. It means that exactly one vertex is a root, and each vertex is either a leaf (and doesn't have children) or an inner node (and has exactly two children). All leaves of a complete binary tree have the same depth (distance from the root). So n is a number such that n + 1 is a power of 2.
In the picture you can see a complete binary tree with n = 15.
Vertices are numbered from 1 to n in a special recursive way: we recursively assign numbers to all vertices from the left subtree (if current vertex is not a leaf), then assign a number to the current vertex, and then recursively assign numbers to all vertices from the right subtree (if it exists). In the picture vertices are numbered exactly using this algorithm. It is clear that for each size of a complete binary tree exists exactly one way to give numbers to all vertices. This way of numbering is called symmetric.
You have to write a program that for given n answers q queries to the tree.
Each query consists of an integer number ui (1 ≤ ui ≤ n) and a string si, where ui is the number of vertex, and si represents the path starting from this vertex. String si doesn't contain any characters other than 'L', 'R' and 'U', which mean traverse to the left child, to the right child and to the parent, respectively. Characters from si have to be processed from left to right, considering that ui is the vertex where the path starts. If it's impossible to process a character (for example, to go to the left child of a leaf), then you have to skip it. The answer is the number of vertex where the path represented by si ends.
For example, if ui = 4 and si = «UURL», then the answer is 10.
The first line contains two integer numbers n and q (1 ≤ n ≤ 1018, q ≥ 1). n is such that n + 1 is a power of 2.
The next 2q lines represent queries; each query consists of two consecutive lines. The first of these two lines contains ui (1 ≤ ui ≤ n), the second contains non-empty string si. si doesn't contain any characters other than 'L', 'R' and 'U'.
","input
It is guaranteed that the sum of lengths of si (for each i such that 1 ≤ i ≤ q) doesn't exceed 105.
output
Print q numbers, i-th number must be the answer to the i-th query.
","bitmasks, trees",7
"import sys
input = sys.stdin.readline

MAXN = 202

def main():
    R, G, B = list(map(int, input().split()))
    r = list(map(int, input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))
    r.sort()
    g.sort()
    b.sort()
    dp = [[[0]*MAXN for _ in range(MAXN)] for _ in range(MAXN)]
    for i in range(1, R+1):
        for j in range(1, G+1):
            dp[i][j][0] = r[i-1]*g[j-1]+dp[i-1][j-1][0]
    for i in range(1, R+1):
        for k in range(1, B+1):
            dp[i][0][k] = r[i-1]*b[k-1]+dp[i-1][0][k-1]
    for j in range(1, G+1):
        for k in range(1, B+1):
            dp[0][j][k] = g[j-1]*b[k-1]+dp[0][j-1][k-1]
    for i in range(1, R+1):
        for j in range(1, G+1):
            for k in range(1, B+1):
                dp[i][j][k] = max(r[i-1]*g[j-1]+dp[i-1][j-1][k], r[i-1]*b[k-1]+dp[i-1][j][k-1], g[j-1]*b[k-1]+dp[i][j-1][k-1])
    print(dp[R][G][B])

main()
",1398_D,CODEFORCES,3935,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"from collections import deque, defaultdict, Counter
from itertools import product, groupby, permutations, combinations
from math import gcd, floor, inf, log2, sqrt, log10
from bisect import bisect_right, bisect_left
from statistics import mode
from string import ascii_uppercase

cases = int(input())
matrix1 = []
for _ in range(cases):
    matrix1.append(list(input()))

matrix2 = []
for _ in range(cases):
    matrix2.append(list(input()))

def transpose(matrix):
    return [list(x) for x in zip(*matrix)]

def reverse_row(matrix):
    return matrix[::-1]

def reverse_column(matrix):
    return [x[::-1] for x in matrix]
def rotate_90(matrix):
    """"""this is counterclockwise, which is same as 270 clockwise""""""
    return reverse_row(transpose(matrix))

def rotate_180(matrix):
    """"""same for both clockwise and counterclockwise""""""
    return reverse_row(reverse_column(matrix))
def rotate_270(matrix):
    """"""this is counterclockwise, which is same as 90 clockwise""""""
    return reverse_column(transpose(matrix))

if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")

    exit()

matrix2 = reverse_row(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()

matrix2 = reverse_column(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()
matrix2 = transpose(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()
else:
    print(""No"")

",0958_A1,CODEFORCES,3123,Death Stars (easy),"The stardate is 1977 and the science and art of detecting Death Stars is in its infancy. Princess Heidi has received information about the stars in the nearby solar system from the Rebel spies and now, to help her identify the exact location of the Death Star, she needs to know whether this information is correct. 
Two rebel spies have provided her with the maps of the solar system. Each map is an N × N grid, where each cell is either occupied by a star or empty. To see whether the information is correct, Heidi needs to know whether the two maps are of the same solar system, or if possibly one of the spies is actually an Empire double agent, feeding her false information.
Unfortunately, spies may have accidentally rotated a map by 90, 180, or 270 degrees, or flipped it along the vertical or the horizontal axis, before delivering it to Heidi. If Heidi can rotate or flip the maps so that two of them become identical, then those maps are of the same solar system. Otherwise, there are traitors in the Rebel ranks! Help Heidi find out.
The first line of the input contains one number N (1 ≤ N ≤ 10) – the dimension of each map. Next N lines each contain N characters, depicting the first map: 'X' indicates a star, while 'O' indicates an empty quadrant of space. Next N lines each contain N characters, depicting the second map in the same format.
The only line of output should contain the word Yes if the maps are identical, or No if it is impossible to match them by performing rotations and translations.
","input
In the first test, you can match the first map to the second map by first flipping the first map along the vertical axis, and then by rotating it 90 degrees clockwise.
output
 
",implementation,5
"n, m = list(map(int, input().split()))
cl = []
for i in range(n):
  cl.append(input())

def is_squad(x, y):
  if cl[x][y]=='#' and cl[x+1][y]=='#' and cl[x+2][y]=='#' and cl[x+2][y+1]=='#' and cl[x+2][y+2]=='#' and cl[x+1][y+2]=='#' and cl[x][y+2]=='#' and cl[x][y+1]=='#':
    return True
  else:
    return False

def cv(x, y):
  counter = 0
  if x-2>=0 and y+2<=m-1 and is_squad(x-2, y):
    return True
   
  elif x-1>=0 and x+1<=n-1 and y+2<=m-1 and is_squad(x-1, y):
    return True

  elif x+2<=n-1 and y+2<=m-1 and is_squad(x, y):
    return True
  
  elif x+2<=n-1 and y+1<=m-1 and y-1>=0 and is_squad(x, y-1):
    return True

  elif x+2<=n-1 and y-2>=0 and is_squad(x, y-2):
    return True

  elif x+1<=n-1 and x-1>=0 and y-2>=0 and is_squad(x-1, y-2):
    return True

  elif x-2>=0 and y-2>=0 and is_squad(x-2, y-2):
    return True

  elif x-2>=0 and y-1>=0 and y+1<=m-1 and is_squad(x-2, y-1):
    return True
  else:
    return False
  

  

  
  

for i in range(n):
  for j in range(m):
    if cl[i][j]=='#':
      if not cv(i, j):
        print('NO')
        exit()

print('YES')",1059_B,CODEFORCES,3555,Forgery,"Student Andrey has been skipping physical education lessons for the whole term, and now he must somehow get a passing grade on this subject. Obviously, it is impossible to do this by legal means, but Andrey doesn't give up. Having obtained an empty certificate from a local hospital, he is going to use his knowledge of local doctor's handwriting to make a counterfeit certificate of illness. However, after writing most of the certificate, Andrey suddenly discovered that doctor's signature is impossible to forge. Or is it?
For simplicity, the signature is represented as an $$$n\times m$$$ grid, where every cell is either filled with ink or empty. Andrey's pen can fill a $$$3\times3$$$ square without its central cell if it is completely contained inside the grid, as shown below.
Determine whether is it possible to forge the signature on an empty $$$n\times m$$$ grid.
The first line of input contains two integers $$$n$$$ and $$$m$$$ ($$$3 \le n, m \le 1000$$$).
Then $$$n$$$ lines follow, each contains $$$m$$$ characters. Each of the characters is either '.', representing an empty cell, or '#', representing an ink filled cell.
If Andrey can forge the signature, output ""YES"". Otherwise output ""NO"".
You can print each letter in any case (upper or lower).
In the first sample Andrey can paint the border of the square with the center in $$$(2, 2)$$$.
In the second sample the signature is impossible to forge.
","input
In the third sample Andrey can paint the borders of the squares with the centers in $$$(2, 2)$$$ and $$$(3, 2)$$$: 
output
In the fourth sample Andrey can paint the borders of the squares with the centers in $$$(3, 3)$$$ and $$$(3, 5)$$$.
",implementation,5
"n, s = map(int, input().rstrip().split())
if n <= s:
    print(0)
    exit()
for i in range(s, n + 2):
    l = 0
    for j in str(i):
        l += int(j)
    if i - l >= s:
        break
print(max(n - i + 1, 0))",0817_C,CODEFORCES,999,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"def main():
    n = int(input())
    V = []
    for i in range(n):
        x,w = map(int,input().split())
        V.append((x-w,x+w))
    V.sort(key=lambda x: x[1])
    ans = 1
    now = V[0]
    for i in range(1,n):
        if V[i][0] >= now[1]:
            now = V[i]
            ans += 1
    print(ans)
    
if __name__ == ""__main__"":
    main()",0528_B,CODEFORCES,2436,Clique Problem,"The clique problem is one of the most well-known NP-complete problems. Under some simplification it can be formulated as follows. Consider an undirected graph G. It is required to find a subset of vertices C of the maximum size such that any two of them are connected by an edge in graph G. Sounds simple, doesn't it? Nobody yet knows an algorithm that finds a solution to this problem in polynomial time of the size of the graph. However, as with many other NP-complete problems, the clique problem is easier if you consider a specific type of a graph.
Consider n distinct points on a line. Let the i-th point have the coordinate xi and weight wi. Let's form graph G, whose vertices are these points and edges connect exactly the pairs of points (i, j), such that the distance between them is not less than the sum of their weights, or more formally: |xi - xj| ≥ wi + wj.
Find the size of the maximum clique in such graph.
The first line contains the integer n (1 ≤ n ≤ 200 000) — the number of points.
Each of the next n lines contains two numbers xi, wi (0 ≤ xi ≤ 109, 1 ≤ wi ≤ 109) — the coordinate and the weight of a point. All xi are different.
Print a single number — the number of vertexes in the maximum clique of the given graph.
","input
If you happen to know how to solve this problem without using the specific properties of the graph formulated in the problem statement, then you are able to get a prize of one million dollars!
output
The picture for the sample test.
","dp, greedy",4
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)",0914_C,CODEFORCES,1552,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp",3
"a = sorted(input())
b = int(input())
a = a[::-1] #reverse a
p = ''
cnt = [0]*10

while a :
    for i, d in enumerate(a):
        n = p + d + """".join(sorted(a[:i]+a[i+1:]))
        if int(n) <= b :
            p += d
            a.pop(i)
            break
        
print(p)",915C_,CODEFORCES,4194,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"n, m, k, l = map(int, input().split())
if m > n or (l + k + m - 1) // m * m > n:
    print(-1)
else:
    x = (l + k + m - 1) // m
    print(x)",1068_A,CODEFORCES,546,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math,1
"import collections


def main():
    # # n = int(input())
    # x, y, z, t1, t2, t3 = list(map(int, input().split()))
    # stair = t1 * abs(y - x)
    # ele = t2 * (abs(y - x) + abs(z - x)) + 3 * t3
    # # print(stair, ele)
    # print(""YES"" if ele <= stair else ""NO"")

    # n = int(input())
    # num = list(map(int, input().split()))
    # prevMax, totMax = -1, float('-inf')
    # for i, v in enumerate(num):
    #     totMax = max(totMax, v)
    #     if totMax - prevMax in [0, 1]:
    #         prevMax = totMax
    #     else:
    #         print(i + 1)
    #         return
    # print(-1)

    n = int(input())
    left = list(map(int, input().split()))
    right = list(map(int, input().split()))
    res = [0] * n
    val = n

    if all(not left[i] and not right[i] for i in range(n)):
        print(""YES"")
        print(' '.join(['1'] * n))
        return

    while not all(not left[i] and not right[i] for i in range(n)):
        zeroSet = set()
        for i in range(n):
            if not left[i] and not right[i] and res[i] == 0:
                zeroSet.add(i)
                res[i] = val
        for v in zeroSet:
            for i in range(v + 1, n):
                if i not in zeroSet and res[i] == 0:
                    left[i] -= 1
            for i in range(v):
                if i not in zeroSet and res[i] == 0:
                    right[i] -= 1
        val -= 1
        # print(zeroSet, left, right)
        if not zeroSet:
            print(""NO"")
            return

    for i in range(n):
        if not res[i]:
            res[i] = str(val)
        else:
            res[i] = str(res[i])
    if any(i == '0' for i in res):
        print(""NO"")
        return
    print(""YES"")
    print(' '.join(res))


main()
",1054_C,CODEFORCES,3515,Candies Distribution,"There are $$$n$$$ children numbered from $$$1$$$ to $$$n$$$ in a kindergarten. Kindergarten teacher gave $$$a_i$$$ ($$$1 \leq a_i \leq n$$$) candies to the $$$i$$$-th child. Children were seated in a row in order from $$$1$$$ to $$$n$$$ from left to right and started eating candies. 
While the $$$i$$$-th child was eating candies, he calculated two numbers $$$l_i$$$ and $$$r_i$$$ — the number of children seating to the left of him that got more candies than he and the number of children seating to the right of him that got more candies than he, respectively.
Formally, $$$l_i$$$ is the number of indices $$$j$$$ ($$$1 \leq j < i$$$), such that $$$a_i < a_j$$$ and $$$r_i$$$ is the number of indices $$$j$$$ ($$$i < j \leq n$$$), such that $$$a_i < a_j$$$.
Each child told to the kindergarten teacher the numbers $$$l_i$$$ and $$$r_i$$$ that he calculated. Unfortunately, she forgot how many candies she has given to each child. So, she asks you for help: given the arrays $$$l$$$ and $$$r$$$ determine whether she could have given the candies to the children such that all children correctly calculated their values $$$l_i$$$ and $$$r_i$$$, or some of them have definitely made a mistake. If it was possible, find any way how she could have done it.
On the first line there is a single integer $$$n$$$ ($$$1 \leq n \leq 1000$$$) — the number of children in the kindergarten.
On the next line there are $$$n$$$ integers $$$l_1, l_2, \ldots, l_n$$$ ($$$0 \leq l_i \leq n$$$), separated by spaces.
On the next line, there are $$$n$$$ integer numbers $$$r_1, r_2, \ldots, r_n$$$ ($$$0 \leq r_i \leq n$$$), separated by spaces.
If there is no way to distribute the candies to the children so that all of them calculated their numbers correctly, print «NO» (without quotes).
Otherwise, print «YES» (without quotes) on the first line. On the next line, print $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$, separated by spaces — the numbers of candies the children $$$1, 2, \ldots, n$$$ received, respectively. Note that some of these numbers can be equal, but all numbers should satisfy the condition $$$1 \leq a_i \leq n$$$. The number of children seating to the left of the $$$i$$$-th child that got more candies than he should be equal to $$$l_i$$$ and the number of children seating to the right of the $$$i$$$-th child that got more candies than he should be equal to $$$r_i$$$. If there is more than one solution, find any of them.
In the first example, if the teacher distributed $$$1$$$, $$$3$$$, $$$1$$$, $$$2$$$, $$$1$$$ candies to $$$1$$$-st, $$$2$$$-nd, $$$3$$$-rd, $$$4$$$-th, $$$5$$$-th child, respectively, then all the values calculated by the children are correct. For example, the $$$5$$$-th child was given $$$1$$$ candy, to the left of him $$$2$$$ children were given $$$1$$$ candy, $$$1$$$ child was given $$$2$$$ candies and $$$1$$$ child — $$$3$$$ candies, so there are $$$2$$$ children to the left of him that were given more candies than him.
","input
In the second example it is impossible to distribute the candies, because the $$$4$$$-th child made a mistake in calculating the value of $$$r_4$$$, because there are no children to the right of him, so $$$r_4$$$ should be equal to $$$0$$$.
output
In the last example all children may have got the same number of candies, that's why all the numbers are $$$0$$$. Note that each child should receive at least one candy.
","constructivealgorithms, implementation",5
"n = int(input())
dp = [1]
for IND in range(n):
    c = input()
    if c == ""f"":
        dp.insert(0,0)
    else:
        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007
print(dp[0])
",0909_C,CODEFORCES,3087,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"import sys,os,io,time,copy
if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

import math

def main():
    # start=time.time()
    n=int(input())
    print(0,0,n)

    # end=time.time()
main()",0199_A,CODEFORCES,58,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"from collections import Counter
a = input()
b = input()
if len(a) < len(b):
    print(''.join(sorted(a)[::-1]))
    exit()
n = len(a)
cnt = Counter(a)
def f(i = 0, check = False):
    if i == n: return []
    for j in sorted(cnt)[::-1]:
        if (check or j <= b[i]) and cnt[j]:
            cnt[j] -= 1
            res = f(i + 1, check or j < b[i])
            if len(res) + i + 1 == n:
                res.append(j)
                return res
            cnt[j] += 1
    return []
print(''.join(f()[::-1]))",915C_,CODEFORCES,4228,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"n=int(input())
c=0
for j in range(2,1+n//2):
	e=0
	i=n//j
	e+=(i*(i+1))//2
	e-=1
	if e>0:
		c+=e
print(c*4)",1062_D,CODEFORCES,2005,Fun with Integers,"You are given a positive integer $$$n$$$ greater or equal to $$$2$$$. For every pair of integers $$$a$$$ and $$$b$$$ ($$$2 \le |a|, |b| \le n$$$), you can transform $$$a$$$ into $$$b$$$ if and only if there exists an integer $$$x$$$ such that $$$1 < |x|$$$ and ($$$a \cdot x = b$$$ or $$$b \cdot x = a$$$), where $$$|x|$$$ denotes the absolute value of $$$x$$$.
After such a transformation, your score increases by $$$|x|$$$ points and you are not allowed to transform $$$a$$$ into $$$b$$$ nor $$$b$$$ into $$$a$$$ anymore.
Initially, you have a score of $$$0$$$. You can start at any integer and transform it as many times as you like. What is the maximum score you can achieve?
A single line contains a single integer $$$n$$$ ($$$2 \le n \le 100\,000$$$) — the given integer described above.
Print an only integer — the maximum score that can be achieved with the transformations. If it is not possible to perform even a single transformation for all possible starting integers, print $$$0$$$.
","input
In the first example, the transformations are $$$2 \rightarrow 4 \rightarrow (-2) \rightarrow (-4) \rightarrow 2$$$.
output
In the third example, it is impossible to perform even a single transformation.
","dfsandsimilar, graphs, implementation, math",3
"x, y, z, t1, t2, t3 = [int(i) for i in input().split()]
if abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:
    print(""YES"")
else:
    print(""NO"")
",1054_A,CODEFORCES,498,Elevator or Stairs?,"Masha lives in a multi-storey building, where floors are numbered with positive integers. Two floors are called adjacent if their numbers differ by one. Masha decided to visit Egor. Masha lives on the floor $$$x$$$, Egor on the floor $$$y$$$ (not on the same floor with Masha).
The house has a staircase and an elevator. If Masha uses the stairs, it takes $$$t_1$$$ seconds for her to walk between adjacent floors (in each direction). The elevator passes between adjacent floors (in each way) in $$$t_2$$$ seconds. The elevator moves with doors closed. The elevator spends $$$t_3$$$ seconds to open or close the doors. We can assume that time is not spent on any action except moving between adjacent floors and waiting for the doors to open or close. If Masha uses the elevator, it immediately goes directly to the desired floor.
Coming out of the apartment on her floor, Masha noticed that the elevator is now on the floor $$$z$$$ and has closed doors. Now she has to choose whether to use the stairs or use the elevator. 
If the time that Masha needs to get to the Egor's floor by the stairs is strictly less than the time it will take her using the elevator, then she will use the stairs, otherwise she will choose the elevator.
Help Mary to understand whether to use the elevator or the stairs.
The only line contains six integers $$$x$$$, $$$y$$$, $$$z$$$, $$$t_1$$$, $$$t_2$$$, $$$t_3$$$ ($$$1 \leq x, y, z, t_1, t_2, t_3 \leq 1000$$$) — the floor Masha is at, the floor Masha wants to get to, the floor the elevator is located on, the time it takes Masha to pass between two floors by stairs, the time it takes the elevator to pass between two floors and the time it takes for the elevator to close or open the doors.
It is guaranteed that $$$x \ne y$$$.
If the time it will take to use the elevator is not greater than the time it will take to use the stairs, print «YES» (without quotes), otherwise print «NO> (without quotes).
You can print each letter in any case (upper or lower).
In the first example:
If Masha goes by the stairs, the time she spends is $$$4 \cdot 4 = 16$$$, because she has to go $$$4$$$ times between adjacent floors and each time she spends $$$4$$$ seconds. 
If she chooses the elevator, she will have to wait $$$2$$$ seconds while the elevator leaves the $$$4$$$-th floor and goes to the $$$5$$$-th. After that the doors will be opening for another $$$1$$$ second. Then Masha will enter the elevator, and she will have to wait for $$$1$$$ second for the doors closing. Next, the elevator will spend $$$4 \cdot 2 = 8$$$ seconds going from the $$$5$$$-th floor to the $$$1$$$-st, because the elevator has to pass $$$4$$$ times between adjacent floors and spends $$$2$$$ seconds each time. And finally, it will take another $$$1$$$ second before the doors are open and Masha can come out. 
Thus, all the way by elevator will take $$$2 + 1 + 1 + 8 + 1 = 13$$$ seconds, which is less than $$$16$$$ seconds, so Masha has to choose the elevator.
","input
In the second example, it is more profitable for Masha to use the stairs, because it will take $$$13$$$ seconds to use the elevator, that is more than the $$$10$$$ seconds it will takes to go by foot.
output
In the third example, the time it takes to use the elevator is equal to the time it takes to walk up by the stairs, and is equal to $$$12$$$ seconds. That means Masha will take the elevator.
",implementation,1
"import sys
I=sys.stdin.readlines()
N,M,K=map(int,I[0].split())
S=[I[i+1][:-1] for i in range(N)]
D=dict()
for i in range(N):
  D[S[i]]=i
T=[I[i+N+1].split() for i in range(M)]
for i in range(M):
  T[i][1]=int(T[i][1])-1
G=[[] for i in range(N)]
C=[0]*N
for i in range(M):
  for j in range(K):
    if S[T[i][1]][j]!='_' and S[T[i][1]][j]!=T[i][0][j]:
      print('NO')
      exit()
  for j in range(1<<K):
    t=''.join(['_' if j&(1<<k) else T[i][0][k] for k in range(K)])
    x=D.get(t,-1)
    if x!=-1 and x!=T[i][1]:
      G[T[i][1]].append(x)
      C[x]+=1
P=[]
Q=[]
F=[1]*N
for i in range(N):
  if C[i]==0 and F[i]:
    Q.append(i)
  while len(Q):
    v=Q.pop()
    F[v]=0
    P.append(v+1)
    for i in range(len(G[v])):
      C[G[v][i]]-=1
      if C[G[v][i]]==0:
        Q.append(G[v][i])
if len(P)==N:
  print('YES')
  print(*P)
else:
  print('NO')
",1476_E,CODEFORCES,4742,Pattern Matching,"You are given $$$n$$$ patterns $$$p_1, p_2, \dots, p_n$$$ and $$$m$$$ strings $$$s_1, s_2, \dots, s_m$$$. Each pattern $$$p_i$$$ consists of $$$k$$$ characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string $$$s_j$$$ consists of $$$k$$$ lowercase Latin letters.
A string $$$a$$$ matches a pattern $$$b$$$ if for each $$$i$$$ from $$$1$$$ to $$$k$$$ either $$$b_i$$$ is a wildcard character or $$$b_i=a_i$$$.
You are asked to rearrange the patterns in such a way that the first pattern the $$$j$$$-th string matches is $$$p[mt_j]$$$. You are allowed to leave the order of the patterns unchanged.
Can you perform such a rearrangement? If you can, then print any valid order.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \le n, m \le 10^5$$$, $$$1 \le k \le 4$$$) — the number of patterns, the number of strings and the length of each pattern and string.
Each of the next $$$n$$$ lines contains a pattern — $$$k$$$ characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct.
Each of the next $$$m$$$ lines contains a string — $$$k$$$ lowercase Latin letters, and an integer $$$mt$$$ ($$$1 \le mt \le n$$$) — the index of the first pattern the corresponding string should match.
Print ""NO"" if there is no way to rearrange the patterns in such a way that the first pattern that the $$$j$$$-th string matches is $$$p[mt_j]$$$.
Otherwise, print ""YES"" in the first line. The second line should contain $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ — the order of the patterns. If there are multiple answers, print any of them.
The order of patterns after the rearrangement in the first example is the following: 
Thus, the first string matches patterns ab__, _bcd, _b_d in that order, the first of them is ab__, that is indeed $$$p[4]$$$. The second string matches __b_ and ab__, the first of them is __b_, that is $$$p[2]$$$. The last string matches _bcd and _b_d, the first of them is _bcd, that is $$$p[5]$$$.
The answer to that test is not unique, other valid orders also exist.
","input
In the second example cba doesn't match __c, thus, no valid order exists.
output
In the third example the order (a_, _b) makes both strings match pattern $$$1$$$ first and the order (_b, a_) makes both strings match pattern $$$2$$$ first. Thus, there is no order that produces the result $$$1$$$ and $$$2$$$.
","bitmasks, datastructures, dfsandsimilar, graphs, hashing, sortings, strings",7
"n = int(input())
s = list(input())
d = list(input())
if(sorted(s) != sorted(d)):
    print(-1)
else:
    ans = []
    for i in range(n):
        if(s[i] != d[i]):
            for u in range(i+1,n):
                if(s[u] == d[i]):
                    ind = u
                    break
                else:ind = -1
            if(ind == -1):print(-1);exit()    
            cnt = abs(ind - i)
            s.pop(ind)           
            s.insert(i,d[i])
            #print(s)
            for k in range(cnt):
                if(ind > 0):
                    ans.append(ind)
                else:
                    ans.append(1)    
                ind -= 1
    print(len(ans))
    print(*ans) ",1015_B,CODEFORCES,3379,Obtaining the String,"You are given two strings $$$s$$$ and $$$t$$$. Both strings have length $$$n$$$ and consist of lowercase Latin letters. The characters in the strings are numbered from $$$1$$$ to $$$n$$$.
You can successively perform the following move any number of times (possibly, zero):
You can't apply a move to the string $$$t$$$. The moves are applied to the string $$$s$$$ one after another.
Your task is to obtain the string $$$t$$$ from the string $$$s$$$. Find any way to do it with at most $$$10^4$$$ such moves.
You do not have to minimize the number of moves, just find any sequence of moves of length $$$10^4$$$ or less to transform $$$s$$$ into $$$t$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 50$$$) — the length of strings $$$s$$$ and $$$t$$$.
The second line of the input contains the string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters.
The third line of the input contains the string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters.
If it is impossible to obtain the string $$$t$$$ using moves, print ""-1"".
Otherwise in the first line print one integer $$$k$$$ — the number of moves to transform $$$s$$$ to $$$t$$$. Note that $$$k$$$ must be an integer number between $$$0$$$ and $$$10^4$$$ inclusive.
In the second line print $$$k$$$ integers $$$c_j$$$ ($$$1 \le c_j < n$$$), where $$$c_j$$$ means that on the $$$j$$$-th move you swap characters $$$s_{c_j}$$$ and $$$s_{c_j + 1}$$$.
If you do not need to apply any moves, print a single integer $$$0$$$ in the first line and either leave the second line empty or do not print it at all.
","input
In the first example the string $$$s$$$ changes as follows: ""abcdef"" $$$\rightarrow$$$ ""abdcef"" $$$\rightarrow$$$ ""abdcfe"" $$$\rightarrow$$$ ""abdfce"" $$$\rightarrow$$$ ""abdfec"".
output
In the second example there is no way to transform the string $$$s$$$ into the string $$$t$$$ through any allowed moves.
",implementation,5
"people,n=map(int,input().split())
a=list(map(int,input().split()))
a.sort()
d={}
tmp=[]
for i in range(n):
    if a[i] in d:
        d[a[i]]+=1
    else:
        d[a[i]]=1
d1={}
for i in d:
    if d[i] in d1:
        d1[d[i]]+=1
    else:
        d1[d[i]]=1
    tmp.append(d[i])
tmp.sort()
ans=0
for i in range(1,10001):
    x=people
    try:
        x-=d1[i]
    except:
        pass
    for j in d1:
        if j>i:
            x-=(j//i)*d1[j]
    if x<=0:
        ans=max(ans,i)
print(ans)",1011_B,CODEFORCES,2735,Planning The Expedition,"Natasha is planning an expedition to Mars for $$$n$$$ people. One of the important tasks is to provide food for each participant.
The warehouse has $$$m$$$ daily food packages. Each package has some food type $$$a_i$$$.
Each participant must eat exactly one food package each day. Due to extreme loads, each participant must eat the same food type throughout the expedition. Different participants may eat different (or the same) types of food.
Formally, for each participant $$$j$$$ Natasha should select his food type $$$b_j$$$ and each day $$$j$$$-th participant will eat one food package of type $$$b_j$$$. The values $$$b_j$$$ for different participants may be different.
What is the maximum possible number of days the expedition can last, following the requirements above?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 100$$$, $$$1 \le m \le 100$$$) — the number of the expedition participants and the number of the daily food packages available.
The second line contains sequence of integers $$$a_1, a_2, \dots, a_m$$$ ($$$1 \le a_i \le 100$$$), where $$$a_i$$$ is the type of $$$i$$$-th food package.
Print the single integer — the number of days the expedition can last. If it is not possible to plan the expedition for even one day, print 0.
","input
In the first example, Natasha can assign type $$$1$$$ food to the first participant, the same type $$$1$$$ to the second, type $$$5$$$ to the third and type $$$2$$$ to the fourth. In this case, the expedition can last for $$$2$$$ days, since each participant can get two food packages of his food type (there will be used $$$4$$$ packages of type $$$1$$$, two packages of type $$$2$$$ and two packages of type $$$5$$$).
output
In the second example, there are $$$100$$$ participants and only $$$1$$$ food package. In this case, the expedition can't last even $$$1$$$ day.
","binarysearch, bruteforce, implementation",4
"import sys 
n=int(input())
ind=0
dig=0
for i in range(1,12):
    dig+=i*10**(i-1)*9 
    #print(dig)
    if dig>n:
        ind=i-1
        rt=dig-i*10**(i-1)*9 
        break 
n-=rt
no=10**ind
#print(n)
if n==0:
    print(9)
    sys.exit()
u=n
n-=(n//(ind+1))*(ind+1)
no+=max(0,(u//(ind+1))-1)
#print(n)
if n==0:
    print(str(no)[-1])
else:
    no+=1
while(n>0):
    if n<=ind+1:
        e=str(no)
        print(e[n-1])
    n-=ind+1
    no+=1

",1177_B,CODEFORCES,1323,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"from math import ceil
def main():
    n=int(input())
    a=list(map(int,input().split( )))
    ans=10**6
    value=10**9+7
    for i in range(n):
        t=ceil((a[i]-i)/n)
        tmp=i+n*t
        if tmp<value:
            value=tmp
            ans=i+1
    print(ans)
main()",0996_B,CODEFORCES,1714,World Cup,"Allen wants to enter a fan zone that occupies a round square and has $$$n$$$ entrances.
There already is a queue of $$$a_i$$$ people in front of the $$$i$$$-th entrance. Each entrance allows one person from its queue to enter the fan zone in one minute.
Allen uses the following strategy to enter the fan zone: 
Determine the entrance through which Allen will finally enter the fan zone.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^5$$$) — the number of entrances.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_i \le 10^9$$$) — the number of people in queues. These numbers do not include Allen.
Print a single integer — the number of entrance that Allen will use.
In the first example the number of people (not including Allen) changes as follows: $$$[\textbf{2}, 3, 2, 0] \to [1, \textbf{2}, 1, 0] \to [0, 1, \textbf{0}, 0]$$$. The number in bold is the queue Alles stands in. We see that he will enter the fan zone through the third entrance.
","input
In the second example the number of people (not including Allen) changes as follows: $$$[\textbf{10}, 10] \to [9, \textbf{9}] \to [\textbf{8}, 8] \to [7, \textbf{7}] \to [\textbf{6}, 6] \to \\ [5, \textbf{5}] \to [\textbf{4}, 4] \to [3, \textbf{3}] \to [\textbf{2}, 2] \to [1, \textbf{1}] \to [\textbf{0}, 0]$$$.
output
In the third example the number of people (not including Allen) changes as follows: $$$[\textbf{5}, 2, 6, 5, 7, 4] \to [4, \textbf{1}, 5, 4, 6, 3] \to [3, 0, \textbf{4}, 3, 5, 2] \to \\ [2, 0, 3, \textbf{2}, 4, 1] \to [1, 0, 2, 1, \textbf{3}, 0] \to [0, 0, 1, 0, 2, \textbf{0}]$$$.
","binarysearch, math",3
"n, m = map(int, input().split())
a = input()
b = input()
flag = 0
for c in a:
    if(c == '*'):
        flag = 1
if(flag == 1):
    a1, a2 = a.split('*')
    Len1 = len(a1)
    Len2 = len(a2)
    b1 = b[:Len1]
    b2 = ''
    if(Len2):
        b2 = b[-Len2:]
    #print(a1, b1, a2, b2)
    if(a1 == b1 and a2 == b2 and Len1 + Len2 <= len(b)):
        print('YES')
    else:
        print('NO')
else:
    if(a == b):
        print('YES')
    else:
        print('NO')

   	 	   	 			 		 	 			 	  		 	",1023_A,CODEFORCES,1856,Single Wildcard Pattern Matching,"You are given two strings $$$s$$$ and $$$t$$$. The string $$$s$$$ consists of lowercase Latin letters and at most one wildcard character '*', the string $$$t$$$ consists only of lowercase Latin letters. The length of the string $$$s$$$ equals $$$n$$$, the length of the string $$$t$$$ equals $$$m$$$.
The wildcard character '*' in the string $$$s$$$ (if any) can be replaced with an arbitrary sequence (possibly empty) of lowercase Latin letters. No other character of $$$s$$$ can be replaced with anything. If it is possible to replace a wildcard character '*' in $$$s$$$ to obtain a string $$$t$$$, then the string $$$t$$$ matches the pattern $$$s$$$.
For example, if $$$s=$$$""aba*aba"" then the following strings match it ""abaaba"", ""abacaba"" and ""abazzzaba"", but the following strings do not match: ""ababa"", ""abcaaba"", ""codeforces"", ""aba1aba"", ""aba?aba"".
If the given string $$$t$$$ matches the given string $$$s$$$, print ""YES"", otherwise print ""NO"".
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 2 \cdot 10^5$$$) — the length of the string $$$s$$$ and the length of the string $$$t$$$, respectively.
The second line contains string $$$s$$$ of length $$$n$$$, which consists of lowercase Latin letters and at most one wildcard character '*'.
The third line contains string $$$t$$$ of length $$$m$$$, which consists only of lowercase Latin letters.
Print ""YES"" (without quotes), if you can obtain the string $$$t$$$ from the string $$$s$$$. Otherwise print ""NO"" (without quotes).
In the first example a wildcard character '*' can be replaced with a string ""force"". So the string $$$s$$$ after this replacement is ""codeforces"" and the answer is ""YES"".
In the second example a wildcard character '*' can be replaced with an empty string. So the string $$$s$$$ after this replacement is ""vkcup"" and the answer is ""YES"".
","input
There is no wildcard character '*' in the third example and the strings ""v"" and ""k"" are different so the answer is ""NO"".
output
In the fourth example there is no such replacement of a wildcard character '*' that you can obtain the string $$$t$$$ so the answer is ""NO"".
","bruteforce, implementation, strings",3
"n,m,a,b = map(int,input().split())
if n%m!=0:
    mn = n//m * m
    mx = n//m * m + m
    print(min(((n - mn) * b),((mx - n) * a)))
else:print(0) ",0990_A,CODEFORCES,1693,Commentary Boxes,"Berland Football Cup starts really soon! Commentators from all over the world come to the event.
Organizers have already built $$$n$$$ commentary boxes. $$$m$$$ regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.
If $$$n$$$ is not divisible by $$$m$$$, it is impossible to distribute the boxes to the delegations at the moment.
Organizers can build a new commentary box paying $$$a$$$ burles and demolish a commentary box paying $$$b$$$ burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.
What is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$)?
The only line contains four integer numbers $$$n$$$, $$$m$$$, $$$a$$$ and $$$b$$$ ($$$1 \le n, m \le 10^{12}$$$, $$$1 \le a, b \le 100$$$), where $$$n$$$ is the initial number of the commentary boxes, $$$m$$$ is the number of delegations to come, $$$a$$$ is the fee to build a box and $$$b$$$ is the fee to demolish a box.
Output the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$). It is allowed that the final number of the boxes is equal to $$$0$$$.
In the first example organizers can build $$$5$$$ boxes to make the total of $$$14$$$ paying $$$3$$$ burles for the each of them.
","input
In the second example organizers can demolish $$$2$$$ boxes to make the total of $$$0$$$ paying $$$7$$$ burles for the each of them.
output
In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get $$$5$$$ boxes.
","implementation, math",3
"t = int(input())
for i in range(t):
    n, m = map(int, input().split())
    x1, y1, x2, y2 = map(int, input().split())
    x3, y3, x4, y4 = map(int, input().split())
    count_w = n * m // 2 + n * m % 2
    count_g = n * m // 2
    if (x1 + y1) % 2 == 0:
        count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) // 2
        count_w += (x2 - x1 + 1) * (y2 - y1 + 1) // 2
    else:
        count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2
        count_w += (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2
    x5 = max(x1, x3)
    x6 = min(x4, x2)
    y5 = max(y1, y3)
    y6 = min(y4, y2)
    if (x3 + y3) % 2 == 1:
        count_g += (x4 - x3 + 1) * (y4 - y3 + 1) // 2
        count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) // 2
    else:
        count_g += (x4 - x3 + 1) * (y4 - y3 + 1) // 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2
        count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) // 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2
    if (x5 + y5) % 2 == 0 and x5 <= x6 and y5 <= y6:
        count_g += (x6 - x5 + 1) * (y6 - y5 + 1) // 2
        count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) // 2
    elif x5 <= x6 and y5 <= y6:
        count_g += (x6 - x5 + 1) * (y6 - y5 + 1) // 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2
        count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) // 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2
    print(count_w, count_g)",1080_C,CODEFORCES,619,Masha and two friends,"Recently, Masha was presented with a chessboard with a height of $$$n$$$ and a width of $$$m$$$.
The rows on the chessboard are numbered from $$$1$$$ to $$$n$$$ from bottom to top. The columns are numbered from $$$1$$$ to $$$m$$$ from left to right. Therefore, each cell can be specified with the coordinates $$$(x,y)$$$, where $$$x$$$ is the column number, and $$$y$$$ is the row number (do not mix up).
Let us call a rectangle with coordinates $$$(a,b,c,d)$$$ a rectangle lower left point of which has coordinates $$$(a,b)$$$, and the upper right one — $$$(c,d)$$$.
The chessboard is painted black and white as follows:
Masha was very happy with the gift and, therefore, invited her friends Maxim and Denis to show off. The guys decided to make her a treat — they bought her a can of white and a can of black paint, so that if the old board deteriorates, it can be repainted. When they came to Masha, something unpleasant happened: first, Maxim went over the threshold and spilled white paint on the rectangle $$$(x_1,y_1,x_2,y_2)$$$. Then after him Denis spilled black paint on the rectangle $$$(x_3,y_3,x_4,y_4)$$$.
To spill paint of color $$$color$$$ onto a certain rectangle means that all the cells that belong to the given rectangle become $$$color$$$. The cell dyeing is superimposed on each other (if at first some cell is spilled with white paint and then with black one, then its color will be black).
Masha was shocked! She drove away from the guests and decided to find out how spoiled the gift was. For this, she needs to know the number of cells of white and black color. Help her find these numbers!
The first line contains a single integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of test cases.
Each of them is described in the following format:
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n,m \le 10^9$$$) — the size of the board.
The second line contains four integers $$$x_1$$$, $$$y_1$$$, $$$x_2$$$, $$$y_2$$$ ($$$1 \le x_1 \le x_2 \le m, 1 \le y_1 \le y_2 \le n$$$) — the coordinates of the rectangle, the white paint was spilled on.
The third line contains four integers $$$x_3$$$, $$$y_3$$$, $$$x_4$$$, $$$y_4$$$ ($$$1 \le x_3 \le x_4 \le m, 1 \le y_3 \le y_4 \le n$$$) — the coordinates of the rectangle, the black paint was spilled on.
Output $$$t$$$ lines, each of which contains two numbers — the number of white and black cells after spilling paint, respectively.
Explanation for examples:
The first picture of each illustration shows how the field looked before the dyes were spilled. The second picture of each illustration shows how the field looked after Maxim spoiled white dye (the rectangle on which the dye was spilled is highlighted with red). The third picture in each illustration shows how the field looked after Denis spoiled black dye (the rectangle on which the dye was spilled is highlighted with red).
In the first test, the paint on the field changed as follows:
In the second test, the paint on the field changed as follows:
In the third test, the paint on the field changed as follows:
","input
In the fourth test, the paint on the field changed as follows:
output
In the fifth test, the paint on the field changed as follows:
",implementation,1
"x= int(input(""""))
print(int((x/2)*3))",0084_A,CODEFORCES,20,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
##########################################################
#q.sort(key=lambda x:((x[1]-x[0]),-x[0]))
#from collections import Counter
#from fractions import Fraction
#s=iter(input())
# for _ in range(int(input())):
#from collections import deque
# n=int(input())
# n,k=map(int,input().split())
# arr=list(map(int,input().split()))
#ls=list(map(int,input().split()))
#for  in range(m):
from bisect import bisect_right
n, x, y = map(int, input().split(' '))
s=[0]*n
e=[0]*n
v=[0]*n
c=0
for i in range(n):
    s[i],e[i]=map(int, input().split(' '))
    c+=x+(e[i]-s[i])*y
s.sort()
e.sort()
for i in range(n-2,-1,-1):
    k=bisect_right(s,e[i])
    while (k < n)  and (v[k]==1) and (s[k]-e[i]) * y < x :
        k+=1
    if k==n:
        continue
    if (s[k]-e[i]) * y < x :
        v[k] = 1
        c+=(s[k]-e[i])*y-x

print(c%(10**9+7))",1061_D,CODEFORCES,2862,TV Shows,"There are $$$n$$$ TV shows you want to watch. Suppose the whole time is split into equal parts called ""minutes"". The $$$i$$$-th of the shows is going from $$$l_i$$$-th to $$$r_i$$$-th minute, both ends inclusive.
You need a TV to watch a TV show and you can't watch two TV shows which air at the same time on the same TV, so it is possible you will need multiple TVs in some minutes. For example, if segments $$$[l_i, r_i]$$$ and $$$[l_j, r_j]$$$ intersect, then shows $$$i$$$ and $$$j$$$ can't be watched simultaneously on one TV.
Once you start watching a show on some TV it is not possible to ""move"" it to another TV (since it would be too distracting), or to watch another show on the same TV until this show ends.
There is a TV Rental shop near you. It rents a TV for $$$x$$$ rupees, and charges $$$y$$$ ($$$y < x$$$) rupees for every extra minute you keep the TV. So in order to rent a TV for minutes $$$[a; b]$$$ you will need to pay $$$x + y \cdot (b - a)$$$. 
You can assume, that taking and returning of the TV doesn't take any time and doesn't distract from watching other TV shows. Find the minimum possible cost to view all shows. Since this value could be too large, print it modulo $$$10^9 + 7$$$.
The first line contains integers $$$n$$$, $$$x$$$ and $$$y$$$ ($$$1 \le n \le 10^5$$$, $$$1 \le y < x \le 10^9$$$) — the number of TV shows, the cost to rent a TV for the first minute and the cost to rent a TV for every subsequent minute.
Each of the next $$$n$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \le l_i \le r_i \le 10^9$$$) denoting the start and the end minute of the $$$i$$$-th TV show.
Print exactly one integer — the minimum cost to view all the shows taken modulo $$$10^9 + 7$$$.
In the first example, the optimal strategy would be to rent $$$3$$$ TVs to watch:
This way the cost for the first TV is $$$4 + 3 \cdot (2 - 1) = 7$$$, for the second is $$$4 + 3 \cdot (10 - 4) = 22$$$ and for the third is $$$4 + 3 \cdot (11 - 2) = 31$$$, which gives $$$60$$$ int total.
","input
In the second example, it is optimal watch each show on a new TV.
output
In third example, it is optimal to watch both shows on a new TV. Note that the answer is to be printed modulo $$$10^9 + 7$$$.
","datastructures, greedy, implementation, sortings",4
"def solve(i, j, k):
    if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0):
        return 0
    if dp[i][j][k] != -1:
        return dp[i][j][k]
    ans = 0
    if i >= 0 and j >= 0:
        ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k))
    if i >= 0 and k >= 0:
        ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1))
    if j >= 0 and k >= 0:
        ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1))
    dp[i][j][k] = ans
    return ans

a, b, c = map(int, input().split())
rs = sorted(list(map(int, input().split())))
gs = sorted(list(map(int, input().split())))
bs = sorted(list(map(int, input().split())))
dp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)]
print(solve(a - 1, b - 1, c - 1))
",1398_D,CODEFORCES,3922,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"n, k = [int(i) for i in input().split()]
d = dict()
d[0] = 1
x = 0
for i in [int(i) for i in input().split()]:
    x ^= i
    v = min(x, (1 << k) - x - 1)
    if v not in d.keys():
        d[v] = 0
    d[v] += 1
ans = 0
for k, v in d.items():
    c1 = v // 2
    c2 = v - c1
    ans += c1 * (c1 - 1) // 2 + c2 * (c2 - 1) // 2
print(n * (n - 1) // 2 + n - ans)
",1054_D,CODEFORCES,1967,Changing Array,"At a break Vanya came to the class and saw an array of $$$n$$$ $$$k$$$-bit integers $$$a_1, a_2, \ldots, a_n$$$ on the board. An integer $$$x$$$ is called a $$$k$$$-bit integer if $$$0 \leq x \leq 2^k - 1$$$. 
Of course, Vanya was not able to resist and started changing the numbers written on the board. To ensure that no one will note anything, Vanya allowed himself to make only one type of changes: choose an index of the array $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the number $$$a_i$$$ with the number $$$\overline{a_i}$$$. We define $$$\overline{x}$$$ for a $$$k$$$-bit integer $$$x$$$ as the $$$k$$$-bit integer such that all its $$$k$$$ bits differ from the corresponding bits of $$$x$$$. 
Vanya does not like the number $$$0$$$. Therefore, he likes such segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$) such that $$$a_l \oplus a_{l+1} \oplus \ldots \oplus a_r \neq 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Determine the maximum number of segments he likes Vanya can get applying zero or more operations described above.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 200\,000$$$, $$$1 \leq k \leq 30$$$).
The next line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 2^k - 1$$$), separated by spaces — the array of $$$k$$$-bit integers.
Print one integer — the maximum possible number of segments with XOR not equal to $$$0$$$ that can be obtained by making several (possibly $$$0$$$) operations described in the statement.
","input
In the first example if Vasya does not perform any operations, he gets an array that has $$$5$$$ segments that Vanya likes. If he performs the operation with $$$i = 2$$$, he gets an array $$$[1, 0, 0]$$$, because $$$\overline{3} = 0$$$ when $$$k = 2$$$. This array has $$$3$$$ segments that Vanya likes. Also, to get an array with $$$5$$$ segments that Vanya likes, he can perform two operations with $$$i = 3$$$ and with $$$i = 2$$$. He then gets an array $$$[1, 0, 3]$$$. It can be proven that he can't obtain $$$6$$$ or more segments that he likes.
output
In the second example, to get $$$19$$$ segments that Vanya likes, he can perform $$$4$$$ operations with $$$i = 3$$$, $$$i = 4$$$, $$$i = 5$$$, $$$i = 6$$$ and get an array $$$[1, 4, 3, 0, 4, 3]$$$.
","greedy, implementation",3
"n = int(input())
queen_x, queen_y = list(map(int, input().strip().split()))
king_x, king_y = list(map(int, input().strip().split()))
tar_x, tar_y = list(map(int, input().strip().split()))

min_x, max_x = sorted([king_x, tar_x])
min_y, max_y = sorted([king_y, tar_y])

if max_x > queen_x > min_x or max_y > queen_y > min_y:
    print(""NO"")
else:
    print(""YES"")
",1033_A,CODEFORCES,2795,King Escape,"Alice and Bob are playing chess on a huge chessboard with dimensions $$$n \times n$$$. Alice has a single piece left — a queen, located at $$$(a_x, a_y)$$$, while Bob has only the king standing at $$$(b_x, b_y)$$$. Alice thinks that as her queen is dominating the chessboard, victory is hers. 
But Bob has made a devious plan to seize the victory for himself — he needs to march his king to $$$(c_x, c_y)$$$ in order to claim the victory for himself. As Alice is distracted by her sense of superiority, she no longer moves any pieces around, and it is only Bob who makes any turns.
Bob will win if he can move his king from $$$(b_x, b_y)$$$ to $$$(c_x, c_y)$$$ without ever getting in check. Remember that a king can move to any of the $$$8$$$ adjacent squares. A king is in check if it is on the same rank (i.e. row), file (i.e. column), or diagonal as the enemy queen. 
Find whether Bob can win or not.
The first line contains a single integer $$$n$$$ ($$$3 \leq n \leq 1000$$$) — the dimensions of the chessboard.
The second line contains two integers $$$a_x$$$ and $$$a_y$$$ ($$$1 \leq a_x, a_y \leq n$$$) — the coordinates of Alice's queen.
The third line contains two integers $$$b_x$$$ and $$$b_y$$$ ($$$1 \leq b_x, b_y \leq n$$$) — the coordinates of Bob's king.
The fourth line contains two integers $$$c_x$$$ and $$$c_y$$$ ($$$1 \leq c_x, c_y \leq n$$$) — the coordinates of the location that Bob wants to get to.
It is guaranteed that Bob's king is currently not in check and the target location is not in check either.
Furthermore, the king is not located on the same square as the queen (i.e. $$$a_x \neq b_x$$$ or $$$a_y \neq b_y$$$), and the target does coincide neither with the queen's position (i.e. $$$c_x \neq a_x$$$ or $$$c_y \neq a_y$$$) nor with the king's position (i.e. $$$c_x \neq b_x$$$ or $$$c_y \neq b_y$$$).
Print ""YES"" (without quotes) if Bob can get from $$$(b_x, b_y)$$$ to $$$(c_x, c_y)$$$ without ever getting in check, otherwise print ""NO"".
You can print each letter in any case (upper or lower).
In the diagrams below, the squares controlled by the black queen are marked red, and the target square is marked blue.
In the first case, the king can move, for instance, via the squares $$$(2, 3)$$$ and $$$(3, 2)$$$. Note that the direct route through $$$(2, 2)$$$ goes through check.
","input
In the second case, the queen watches the fourth rank, and the king has no means of crossing it.
output
In the third case, the queen watches the third file.
","dfsandsimilar, graphs, implementation",4
"n = int(input())
for q in range(n):
    x, y, k = map(int, input().split())
    if max(x, y) > k:
        print(-1)
    else:
        if 0 == (x + y) % 2:
            if k % 2 == max(x, y) % 2:
                print(k)
            else:
                print(k - 2)
        else:
            print(k - 1)
",1036_B,CODEFORCES,491,Diagonal Walking v,"Mikhail walks on a Cartesian plane. He starts at the point $$$(0, 0)$$$, and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $$$(0, 0)$$$, he can go to any of the following points in one move: 
If Mikhail goes from the point $$$(x1, y1)$$$ to the point $$$(x2, y2)$$$ in one move, and $$$x1 \ne x2$$$ and $$$y1 \ne y2$$$, then such a move is called a diagonal move.
Mikhail has $$$q$$$ queries. For the $$$i$$$-th query Mikhail's target is to go to the point $$$(n_i, m_i)$$$ from the point $$$(0, 0)$$$ in exactly $$$k_i$$$ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in $$$k_i$$$ moves.
Note that Mikhail can visit any point any number of times (even the destination point!).
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 10^4$$$) — the number of queries.
Then $$$q$$$ lines follow. The $$$i$$$-th of these $$$q$$$ lines contains three integers $$$n_i$$$, $$$m_i$$$ and $$$k_i$$$ ($$$1 \le n_i, m_i, k_i \le 10^{18}$$$) — $$$x$$$-coordinate of the destination point of the query, $$$y$$$-coordinate of the destination point of the query and the number of moves in the query, correspondingly.
Print $$$q$$$ integers. The $$$i$$$-th integer should be equal to -1 if Mikhail cannot go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in exactly $$$k_i$$$ moves described above. Otherwise the $$$i$$$-th integer should be equal to the the maximum number of diagonal moves among all possible movements.
One of the possible answers to the first test case: $$$(0, 0) \to (1, 0) \to (1, 1) \to (2, 2)$$$.
","input
One of the possible answers to the second test case: $$$(0, 0) \to (0, 1) \to (1, 2) \to (0, 3) \to (1, 4) \to (2, 3) \to (3, 2) \to (4, 3)$$$.
output
In the third test case Mikhail cannot reach the point $$$(10, 1)$$$ in 9 moves.
",math,1
"# @author --> ajaymodi
# optimized approach with memoization (dp)
import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""output.out"",""w"")

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())


from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)



def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]

	ans = 0

	if i < r and j < g:
		ans = max(solve(i+1,j+1,k) + rl[i]*gl[j],ans)

	if i < r and k < b:	
		ans = max(solve(i+1,j,k+1) + rl[i]*bl[k],ans)

	if j < g and k < b:
		ans = max(solve(i,j+1,k+1) + gl[j]*bl[k],ans)

	dp_table[i][j][k] = ans
	return dp_table[i][j][k]
		

dp_table = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",1398_D,CODEFORCES,3986,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"n,U=map(int,input().split())
Ar=list(map(int,input().split()))
R = 0;
ans = -1;
for i in range(n):
    while R + 1 < n and Ar[R + 1] - Ar[i] <= U:
        R+=1
    if i+1 < R:
        ans = max((Ar[R] - Ar[i + 1]) / (Ar[R] - Ar[i]),ans);
print(ans)
",0957_C,CODEFORCES,2472,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers",4
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    alst = [int(input()) for _ in range(n)]
    ans = []
    for a in alst:
        if a == 1:
            ans.append(""1"")
            print(""."".join(ans))
            continue
        while ans and int(ans[-1]) != a - 1:
            ans.pop()
        if not ans:
            ans.append(str(a))
        else:
            ans.pop()
            ans.append(str(a))
        
        print(""."".join(ans))
        
    
for _ in range(int(input())):
    main()",1523_C,CODEFORCES,3686,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees",5
"import sys
input = lambda: sys.stdin.readline().strip()
from math import ceil

def mismatch(s1, s2):
    cnt = 0
    for i in range(len(s1)):
        if s1[i]!=s2[i]: cnt+=1
    return cnt

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    check = ''
    for i in range(ceil((k+2)/3)):
        check+='RGB'
    ls = []
    for i in range(3):
        ls.append(check[i:i+k])
    s = input()
    m = n
    for i in range(n-k+1):
        for j in ls:
            m = min(m, mismatch(s[i:i+k], j))
    print(m)
",1196_D1,CODEFORCES,3615,RGB Substring (easy version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2000$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2000$$$ ($$$\sum n \le 2000$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
",implementation,5
"from collections import defaultdict, Counter,deque
from math import sqrt, log10, log, floor, factorial,gcd
from bisect import bisect_left, bisect_right
from itertools import permutations,combinations
import sys, io, os
input = sys.stdin.readline
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
# sys.setrecursionlimit(10000)
inf = float('inf')
mod = 10 ** 9 + 7
def yn(a): print(""YES"" if a else ""NO"")
ceil = lambda a, b: (a + b - 1) // b
lim=22
po=[1<<j for j in range(lim+1)]
maxbits=lim
masks=po[lim]
dp=[-1]*masks
t=1

for i in range(1):
    n=int(input())
    l=[int(i) for i in input().split()]
    for i in l:
        dp[i]=i
    for i in range(masks):
        for j in range(maxbits):
            if dp[i]==-1 and i&(1<<j):
                dp[i]=dp[i-(1<<j)]
    ans=[dp[i^(masks-1)] for i in l]
    print(*ans)








",0165_E,CODEFORCES,4289,Compatible Numbers,"Two integers x and y are compatible, if the result of their bitwise ""AND"" equals zero, that is, a & b = 0. For example, numbers 90 (10110102) and 36 (1001002) are compatible, as 10110102 & 1001002 = 02, and numbers 3 (112) and 6 (1102) are not compatible, as 112 & 1102 = 102.
You are given an array of integers a1, a2, ..., an. Your task is to find the following for each array element: is this element compatible with some other element from the given array? If the answer to this question is positive, then you also should find any suitable element.
","input
The first line contains an integer n (1 ≤ n ≤ 106) — the number of elements in the given array. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 4·106) — the elements of the given array. The numbers in the array can coincide.
output
Print n integers ansi. If ai isn't compatible with any other element of the given array a1, a2, ..., an, then ansi should be equal to -1. Otherwise ansi is any such number, that ai & ansi = 0, and also ansi occurs in the array a1, a2, ..., an.
","bitmasks, bruteforce, dfsandsimilar, dp",7
"n = int(input())
a = sorted(list(map(int, input().split())))
s = []
for q in a:
    for q1 in s:
        if q % q1 == 0:
            break
    else:
        s.append(q)
print(len(s))
",1209_A,CODEFORCES,3658,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"import sys
readline = sys.stdin.readline

k = list(map(int, readline().split()))


ans = 'NO'
if min(k) == 1 or k.count(2) >= 2 or k.count(3) >= 3 or (k.count(4) == 2 and k.count(2) == 1):
    ans = 'YES'

print(ans)",0911_C,CODEFORCES,191,Three Garlands,"Mishka is decorating the Christmas tree. He has got three garlands, and all of them will be put on the tree. After that Mishka will switch these garlands on.
When a garland is switched on, it periodically changes its state — sometimes it is lit, sometimes not. Formally, if i-th garland is switched on during x-th second, then it is lit only during seconds x, x + ki, x + 2ki, x + 3ki and so on.
Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland. Formally, Mishka wants to choose three integers x1, x2 and x3 (not necessarily distinct) so that he will switch on the first garland during x1-th second, the second one — during x2-th second, and the third one — during x3-th second, respectively, and during each second starting from max(x1, x2, x3) at least one garland will be lit.
Help Mishka by telling him if it is possible to do this!
The first line contains three integers k1, k2 and k3 (1 ≤ ki ≤ 1500) — time intervals of the garlands.
If Mishka can choose moments of time to switch on the garlands in such a way that each second after switching the garlands on at least one garland will be lit, print YES.
Otherwise, print NO.
","input
In the first example Mishka can choose x1 = 1, x2 = 2, x3 = 1. The first garland will be lit during seconds 1, 3, 5, 7, ..., the second — 2, 4, 6, 8, ..., which already cover all the seconds after the 2-nd one. It doesn't even matter what x3 is chosen. Our choice will lead third to be lit during seconds 1, 4, 7, 10, ..., though.
output
In the second example there is no way to choose such moments of time, there always be some seconds when no garland is lit.
","bruteforce, constructivealgorithms",1
"l,r = map(int,input().split())

x = 64
while x>=0 and  (l&(1<<x)) == (r&(1<<x)):
    x-=1
print((1<<(x+1))-1)",0276_D,CODEFORCES,781,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"with open(""input.txt"",""r"") as in_file: 
    with open(""output.txt"",""a"") as out_file:
        N,M = map(int,in_file.readline().split())
        K = int(in_file.readline())
        map_max_dist = [[5000 for i in range(M)] for j in range(N)]
        inputs = list(map(int,in_file.readline().split()))
        p = 0 
        while(p<=K*2-2):
            x,y = inputs[p]-1,inputs[p+1]-1
            for r in range(N):
                for c in range(M):
                    dist = abs(x-r)+abs(y-c)
                    if dist<map_max_dist[r][c]:
                        map_max_dist[r][c] = dist
            p+=2
        max_val = 0 
        max_index = (0,0)
        i,j = 0,0
        for i in range(N):
            for j in range(M):
                if(map_max_dist[i][j]>max_val):
                    max_val = map_max_dist[i][j]
                    max_index = (i,j)
        out_file.write(""{} {}"".format(max_index[0]+1,max_index[1]+1))
    
        ",0035_C,CODEFORCES,3759,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"import os
import heapq
import sys
import math
import operator
from collections import defaultdict
from io import BytesIO, IOBase


""""""def gcd(a,b):
    if b==0:
        return a
    else:
        return gcd(b,a%b)""""""

""""""def pw(a,b):
    result=1
    while(b>0):
        if(b%2==1): result*=a
        a*=a
        b//=2
    return result""""""

def inpt():
    return [int(k) for k in input().split()]

def main():
    n1, n2, n3 = map(int, input().split())
    ar = [int(x) for x in input().split()]
    br = [int(x) for x in input().split()]
    cr = [int(x) for x in input().split()]
    ar.sort()
    br.sort()
    cr.sort()
    dp = [[[0 for x in range(201)] for y in range(201)] for z in range(201)]
    for i in range(n1 + 1):
        for j in range(n2 + 1):
            for k in range(n3 + 1):
                if (i and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + (ar[i - 1] * br[j - 1]))
                if (i and k):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + (ar[i - 1] * cr[k - 1]))
                if (k and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + (cr[k - 1] * br[j - 1]))
    print(dp[n1][n2][n3])


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()

",1398_D,CODEFORCES,3980,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"n,v = map(int,input().split())

if n <= v + 1:
    print( n - 1 )
else:
    b = n - v
    print( v - 1 + ((b*(b+1))//2))
",1113_A,CODEFORCES,689,Sasha and His Trip,"Sasha is a very happy guy, that's why he is always on the move. There are $$$n$$$ cities in the country where Sasha lives. They are all located on one straight line, and for convenience, they are numbered from $$$1$$$ to $$$n$$$ in increasing order. The distance between any two adjacent cities is equal to $$$1$$$ kilometer. Since all roads in the country are directed, it's possible to reach the city $$$y$$$ from the city $$$x$$$ only if $$$x < y$$$. 
Once Sasha decided to go on a trip around the country and to visit all $$$n$$$ cities. He will move with the help of his car, Cheetah-2677. The tank capacity of this model is $$$v$$$ liters, and it spends exactly $$$1$$$ liter of fuel for $$$1$$$ kilometer of the way. At the beginning of the journey, the tank is empty. Sasha is located in the city with the number $$$1$$$ and wants to get to the city with the number $$$n$$$. There is a gas station in each city. In the $$$i$$$-th city, the price of $$$1$$$ liter of fuel is $$$i$$$ dollars. It is obvious that at any moment of time, the tank can contain at most $$$v$$$ liters of fuel.
Sasha doesn't like to waste money, that's why he wants to know what is the minimum amount of money is needed to finish the trip if he can buy fuel in any city he wants. Help him to figure it out!
The first line contains two integers $$$n$$$ and $$$v$$$ ($$$2 \le n \le 100$$$, $$$1 \le v \le 100$$$)  — the number of cities in the country and the capacity of the tank.
Print one integer — the minimum amount of money that is needed to finish the trip.
","input
In the first example, Sasha can buy $$$2$$$ liters for $$$2$$$ dollars ($$$1$$$ dollar per liter) in the first city, drive to the second city, spend $$$1$$$ liter of fuel on it, then buy $$$1$$$ liter for $$$2$$$ dollars in the second city and then drive to the $$$4$$$-th city. Therefore, the answer is $$$1+1+2=4$$$.
output
In the second example, the capacity of the tank allows to fill the tank completely in the first city, and drive to the last city without stops in other cities.
","dp, greedy, math",1
"import sys
input = lambda: sys.stdin.readline().rstrip('\r\n')

N, M, K = map(int, input().split())
P = []
D_P = {}

for i in range(N):
	S = input()
	P.append(S)
	D_P[S] = i

adj = [[] for _ in range(N)]
indeg = [0] * N

for _ in range(M):
	S, mt = input().split()
	mt = int(mt)-1

	fp = P[mt]

	if any(fp[i] not in (S[i], '_') for i in range(K)):
		print('NO')
		raise SystemExit

	for bs in range(1<<K):
		pat = ''.join(S[i] if bs & (1<<i) == 0 else '_' for i in range(K))
		if pat == fp: continue
		if pat in D_P:
			j = D_P[pat]
			indeg[j] += 1
			adj[mt].append(j)

Q = [i for i in range(N) if indeg[i] == 0]
for i in Q:
	for j in adj[i]:
		indeg[j] -= 1
		if indeg[j] == 0:
			Q.append(j)

if len(Q) == N:
	print('YES')
	print(' '.join(str(v+1) for v in Q))
else:
	print('NO')
",1476_E,CODEFORCES,4735,Pattern Matching,"You are given $$$n$$$ patterns $$$p_1, p_2, \dots, p_n$$$ and $$$m$$$ strings $$$s_1, s_2, \dots, s_m$$$. Each pattern $$$p_i$$$ consists of $$$k$$$ characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string $$$s_j$$$ consists of $$$k$$$ lowercase Latin letters.
A string $$$a$$$ matches a pattern $$$b$$$ if for each $$$i$$$ from $$$1$$$ to $$$k$$$ either $$$b_i$$$ is a wildcard character or $$$b_i=a_i$$$.
You are asked to rearrange the patterns in such a way that the first pattern the $$$j$$$-th string matches is $$$p[mt_j]$$$. You are allowed to leave the order of the patterns unchanged.
Can you perform such a rearrangement? If you can, then print any valid order.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \le n, m \le 10^5$$$, $$$1 \le k \le 4$$$) — the number of patterns, the number of strings and the length of each pattern and string.
Each of the next $$$n$$$ lines contains a pattern — $$$k$$$ characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct.
Each of the next $$$m$$$ lines contains a string — $$$k$$$ lowercase Latin letters, and an integer $$$mt$$$ ($$$1 \le mt \le n$$$) — the index of the first pattern the corresponding string should match.
Print ""NO"" if there is no way to rearrange the patterns in such a way that the first pattern that the $$$j$$$-th string matches is $$$p[mt_j]$$$.
Otherwise, print ""YES"" in the first line. The second line should contain $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ — the order of the patterns. If there are multiple answers, print any of them.
The order of patterns after the rearrangement in the first example is the following: 
Thus, the first string matches patterns ab__, _bcd, _b_d in that order, the first of them is ab__, that is indeed $$$p[4]$$$. The second string matches __b_ and ab__, the first of them is __b_, that is $$$p[2]$$$. The last string matches _bcd and _b_d, the first of them is _bcd, that is $$$p[5]$$$.
The answer to that test is not unique, other valid orders also exist.
","input
In the second example cba doesn't match __c, thus, no valid order exists.
output
In the third example the order (a_, _b) makes both strings match pattern $$$1$$$ first and the order (_b, a_) makes both strings match pattern $$$2$$$ first. Thus, there is no order that produces the result $$$1$$$ and $$$2$$$.
","bitmasks, datastructures, dfsandsimilar, graphs, hashing, sortings, strings",7
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase

def main():
    a=list(map(int,input().rstrip()))
    b=list(map(int,input().rstrip()))
    ans,la,lb=[],len(a),len(b)
    if la!=lb:
        print(*sorted(a,reverse=True),sep="""")
    else:
        for i in range(lb):
            if b[i] in a:
                ans.append(b[i])
                a.remove(b[i])
            else:
                while i>-1:
                    ma=-1
                    for j in a:
                        if j<b[i]:
                            ma=max(ma,j)
                    if ma!=-1:
                        ans.append(ma)
                        a.remove(ma)
                        break
                    i-=1
                    a.append(ans.pop())
                a.sort()
                while a:
                    ans.append(a.pop())
                break
        print("""".join(str(i) for i in ans))


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",915C_,CODEFORCES,4192,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"def popcount(i):
    assert 0 <= i < 0x100000000
    i = i - ((i >> 1) & 0x55555555)
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)
    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24

N, T = map(int, input().split())
TG = [list(map(int, input().split())) for _ in range(N)]
mod = 10**9+7


dp = [[0]*(2**N) for _ in range(4)]
for i in range(1, 4):
    dp[i][0] = 1

for S in range(2**N):
    if popcount(S) == 1:
        dp[TG[(S&(-S)).bit_length() - 1][1]][S] = 1
    for i in range(1, 4):
        for j in range(N):
            if S & (2**j) or i == TG[j][1]:
                continue
            dp[TG[j][1]][S|(2**j)] = (dp[TG[j][1]][S|(2**j)] + dp[i][S]) % mod

table = [0]*(2**N)
for S in range(2**N):
    table[S] = sum(TG[j][0] for j in range(N) if 2**j & S)
    
ans = 0
for S in range(2**N):
    if table[S] == T:
        for i in range(1, 4):
            ans = (ans + dp[i][S]) % mod

print(ans)",1185_G1,CODEFORCES,4602,Playlist for Polycarp (easy version),"The only difference between easy and hard versions is constraints.
Polycarp loves to listen to music, so he never leaves the player, even on the way home from the university. Polycarp overcomes the distance from the university to the house in exactly $$$T$$$ minutes.
In the player, Polycarp stores $$$n$$$ songs, each of which is characterized by two parameters: $$$t_i$$$ and $$$g_i$$$, where $$$t_i$$$ is the length of the song in minutes ($$$1 \le t_i \le 15$$$), $$$g_i$$$ is its genre ($$$1 \le g_i \le 3$$$).
Polycarp wants to create such a playlist so that he can listen to music all the time on the way from the university to his home, and at the time of his arrival home, the playlist is over. Polycarp never interrupts songs and always listens to them from beginning to end. Thus, if he started listening to the $$$i$$$-th song, he would spend exactly $$$t_i$$$ minutes on its listening. Polycarp also does not like when two songs of the same genre play in a row (i.e. successively/adjacently) or when the songs in his playlist are repeated.
Help Polycarpus count the number of different sequences of songs (their order matters), the total duration is exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different.
The first line of the input contains two integers $$$n$$$ and $$$T$$$ ($$$1 \le n \le 15, 1 \le T \le 225$$$) — the number of songs in the player and the required total duration, respectively.
Next, the $$$n$$$ lines contain descriptions of songs: the $$$i$$$-th line contains two integers $$$t_i$$$ and $$$g_i$$$ ($$$1 \le t_i \le 15, 1 \le g_i \le 3$$$) — the duration of the $$$i$$$-th song and its genre, respectively.
Output one integer — the number of different sequences of songs, the total length of exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different. Since the answer may be huge, output it modulo $$$10^9 + 7$$$ (that is, the remainder when dividing the quantity by $$$10^9 + 7$$$).
In the first example, Polycarp can make any of the $$$6$$$ possible playlist by rearranging the available songs: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$ and $$$[3, 2, 1]$$$ (indices of the songs are given).
","input
In the second example, the first and second songs cannot go in succession (since they have the same genre). Thus, Polycarp can create a playlist in one of $$$2$$$ possible ways: $$$[1, 3, 2]$$$ and $$$[2, 3, 1]$$$ (indices of the songs are given).
output
In the third example, Polycarp can make the following playlists: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$, $$$[3, 2, 1]$$$, $$$[1, 4]$$$, $$$[4, 1]$$$, $$$[2, 3, 4]$$$ and $$$[4, 3, 2]$$$ (indices of the songs are given).
","bitmasks, combinatorics, dp",7
"# Author Name: Ajay Meena
# Codeforce : XXXX
import sys
import math
import bisect
import heapq
from bisect import bisect_right
from sys import stdin, stdout

# -------------- INPUT FUNCTIONS ------------------


def get_ints_in_variables(): return map(
    int, sys.stdin.readline().strip().split())


def get_int(): return int(sys.stdin.readline())


def get_ints_in_list(): return list(
    map(int, sys.stdin.readline().strip().split()))
def get_list_of_list(n): return [list(
    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]


def get_string(): return sys.stdin.readline().strip()

# -------- SOME CUSTOMIZED FUNCTIONS-----------


def myceil(x, y): return (x + y - 1) // y

# -------------- SOLUTION FUNCTION ------------------


def Solution(td, n, k):
    # Write Your Code Here
    mxHeap = []
    td = sorted(td, key=lambda x: x[0])
    prefix = []
    tmp = 0
    for v in td:
        b = v[1]
        tmpAns = tmp+b
        if len(mxHeap) == k:
            if len(mxHeap) and b > mxHeap[0]:
                t = heapq.heappop(mxHeap)
                heapq.heappush(mxHeap, b)
                tmp -= t
                tmp += b
        elif len(mxHeap) < k:
            tmp += b
            heapq.heappush(mxHeap, b)
        prefix.append([tmpAns, v[2]])

    ans = [0 for _ in range(n)]
    for v in prefix:
        ans[v[1]] = v[0]
    print(*ans)


def main():
    # Take input Here and Call solution function
    n, k = get_ints_in_variables()
    a = get_ints_in_list()
    b = get_ints_in_list()
    td = [[a[i], b[i], i] for i in range(n)]
    Solution(td, n, k)


# calling main Function
if __name__ == '__main__':
    main()
",0994_B,CODEFORCES,2640,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings",4
"import math
def lucky(x):
    return (list(set(list(str(x)))) in [[""4""],[""7""],[""4"",""7""],[""7"",""4""]])
a = int(input())
true = False
for i in range(1, math.ceil(math.sqrt(a))+1):
    if a % i == 0:
        if lucky(i) or lucky(a//i):
            true = True
            break
print(""YES"" if true else ""NO"")",0122_A,CODEFORCES,47,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory",1
"from sys import stdin
n = int(stdin.readline())
g = dict()
for i in range(n-1):
    u,v = map(int,stdin.readline().split())
    g.setdefault(u-1,[]).append(v-1)
    g.setdefault(v-1, []).append(u-1)
st = [0]
rank = [0]*n
tree = [0]*n
msk = [0]*n
rd = dict()
while len(st)>0:
    top = st.pop()
    msk[top] = 1
    for c in g[top]:
        if msk[c] == 0:
            st.append(c)
            tree[c] = top
            rank[c] = rank[top]+1
            rd.setdefault(rank[c], []).append(c)
max_rank = max(rank)
reach = [0]*n
build = [0]*n
ans = 0
for r in range(max_rank, 2, -1):
    for node in rd[r]:
        if reach[node] == 0:
            reach[node] = 1
            reach[tree[node]] = 1
            reach[tree[tree[node]]] = 1
            build[tree[node]] = 1
print(sum(build))",1029_E,CODEFORCES,1898,Tree with Small Distances,"You are given an undirected tree consisting of $$$n$$$ vertices. An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Your task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex $$$1$$$ to any other vertex is at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — the number of vertices in the tree.
The following $$$n - 1$$$ lines contain edges: edge $$$i$$$ is given as a pair of vertices $$$u_i, v_i$$$ ($$$1 \le u_i, v_i \le n$$$). It is guaranteed that the given edges form a tree. It is guaranteed that there are no loops and multiple edges in the given edges.
Print a single integer — the minimum number of edges you have to add in order to make the shortest distance from the vertex $$$1$$$ to any other vertex at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The tree corresponding to the first example:  The answer is $$$2$$$, some of the possible answers are the following: $$$[(1, 5), (1, 6)]$$$, $$$[(1, 4), (1, 7)]$$$, $$$[(1, 6), (1, 7)]$$$.
","input
The tree corresponding to the second example:  The answer is $$$0$$$.
output
The tree corresponding to the third example:  The answer is $$$1$$$, only one possible way to reach it is to add the edge $$$(1, 3)$$$.
","dp, graphs, greedy",3
"m={""s"":[0]*9, ""m"":[0]*9, ""p"":[0]*9}
for e in input().split():
    m[e[1]][int(e[0])-1]+=1
ret=2
for t in ""smp"":
    l=m[t]
    if max(l)>=2:
        ret=min(ret, 3-max(l))
    else:
        for i in range(7):
            seq = sum(l[i:i+3])
            ret = min(ret, 3-seq)
print(ret)",1191_B,CODEFORCES,2198,Tokitsukaze and Mahjong,"Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $$$1$$$ to $$$9$$$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $$$\ldots$$$, 9m, 1p, 2p, $$$\ldots$$$, 9p, 1s, 2s, $$$\ldots$$$, 9s.
In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.
Do you know the minimum number of extra suited tiles she needs to draw so that she can win?
Here are some useful definitions in this game:
Some examples: 
Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.
The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $$$1$$$ to $$$9$$$ and the second character is m, p or s.
Print a single integer — the minimum number of extra suited tiles she needs to draw.
In the first example, Tokitsukaze already has a shuntsu.
","input
In the second example, Tokitsukaze already has a koutsu.
output
In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
","bruteforce, implementation",3
"def res(d,N):
    for i in range(1,N):
        if d[i][1] <= d[i-1][1]:
            return str(d[i][2]+1) + ' ' + str(d[i-1][2]+1)
    return '-1 -1'    

N = int(input())
d = []
for i in range(N):
    a,b = map(int,input().split())
    d.append((a,b,i))
d = sorted(d, key = lambda x:(x[0],-x[1]))
print(res(d,N))
",0976_C,CODEFORCES,2523,Nested Segments,"You are given a sequence a1, a2, ..., an of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment ai lies within segment aj.
Segment [l1, r1] lies within segment [l2, r2] iff l1 ≥ l2 and r1 ≤ r2.
Print indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
The first line contains one integer n (1 ≤ n ≤ 3·105) — the number of segments.
Each of the next n lines contains two integers li and ri (1 ≤ li ≤ ri ≤ 109) — the i-th segment.
","input
Print two distinct indices i and j such that segment ai lies within segment aj. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
output
In the first example the following pairs are considered correct:
","greedy, implementation, sortings",4
"import random

n = int(input())
v = []
for i in range(0, n):
    x, y = map(int, input().split())
    v.append([x, y, i])


while 1>0:
    random.shuffle(v)
    x = y = 0
    ans = [0]*n
    for i in range(n):

        if (x+v[i][0])**2+(y+v[i][1])**2 < (x-v[i][0])**2+(y-v[i][1])**2:
            x += v[i][0]
            y += v[i][1]
            ans[v[i][2]] = 1
        else:
            x -= v[i][0]
            y -= v[i][1]
            ans[v[i][2]] = -1
    if x*x+y*y <= 1500000**2:
        print(*ans)
        break
2",0995_C,CODEFORCES,2653,Leaving the Bar,"For a vector $$$\vec{v} = (x, y)$$$, define $$$|v| = \sqrt{x^2 + y^2}$$$.
Allen had a bit too much to drink at the bar, which is at the origin. There are $$$n$$$ vectors $$$\vec{v_1}, \vec{v_2}, \cdots, \vec{v_n}$$$. Allen will make $$$n$$$ moves. As Allen's sense of direction is impaired, during the $$$i$$$-th move he will either move in the direction $$$\vec{v_i}$$$ or $$$-\vec{v_i}$$$. In other words, if his position is currently $$$p = (x, y)$$$, he will either move to $$$p + \vec{v_i}$$$ or $$$p - \vec{v_i}$$$.
Allen doesn't want to wander too far from home (which happens to also be the bar). You need to help him figure out a sequence of moves (a sequence of signs for the vectors) such that his final position $$$p$$$ satisfies $$$|p| \le 1.5 \cdot 10^6$$$ so that he can stay safe.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of moves.
Each of the following lines contains two space-separated integers $$$x_i$$$ and $$$y_i$$$, meaning that $$$\vec{v_i} = (x_i, y_i)$$$. We have that $$$|v_i| \le 10^6$$$ for all $$$i$$$.
","input
Output a single line containing $$$n$$$ integers $$$c_1, c_2, \cdots, c_n$$$, each of which is either $$$1$$$ or $$$-1$$$. Your solution is correct if the value of $$$p = \sum_{i = 1}^n c_i \vec{v_i}$$$, satisfies $$$|p| \le 1.5 \cdot 10^6$$$.
output
It can be shown that a solution always exists under the given constraints.
","bruteforce, datastructures, geometry, greedy, math, sortings",4
"import math
n = int(input())
s = list(map(int, input().split()))
d = dict()
for i in range(n):
    d[s[i]] = d.get(s[i], 0)+1

rem = 0
for i in range(n):

    ok = False
    for j in range(31):
        x = 2** j - s[i]
        c = d.get(x , 0)
        if c > 1 or (c == 1 and s[i] != x):
            ok = True
            break

    if ok == False:
        rem += 1
 
print(rem)",1005_C,CODEFORCES,2685,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation",4
"from math import ceil


def solve(n, k):
	if k == 1:
		return n - 1
	if k == 2:
		if n > 1:
			return n - 1
		else:
			return -1
	if k == 3:
		if n > 2:
			return n - 1
		else:
			return -1
	if k in {4, 5}:
		if n > 1:
			return n - 2
		else:
			return -1

	if 2 * n + 1 <= len(bin(3 * k)[2:]):
		return -1
	else:
		return n - ceil((len(bin(3 * k)[2:]) - 1) / 2)


for i in range(int(input())):
	n, k = map(int, input().split())
	a = solve(n, k)
	if a == -1:
		print('NO')
	else:
		print('YES', a)
",1080_D,CODEFORCES,1169,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"import bisect
import sys
input=sys.stdin.readline
#t=int(input())
import collections 
import heapq
t=1
p=10**9+7
def ncr_util():
    
    inv[0]=inv[1]=1
    fact[0]=fact[1]=1
    for i in range(2,300001):
        inv[i]=(inv[i%p]*(p-p//i))%p
    for i in range(1,300001):
        inv[i]=(inv[i-1]*inv[i])%p
        fact[i]=(fact[i-1]*i)%p

    
def solve():
    ans,a,b=0,0,0
    mul=2**60
    for i in range(60,-1,-1):
        #print(11,mul,a+mul,b+mul)
        ch1,ch2=0,0
        if a+mul<=l:
            #print(1,a,mul)
            a+=mul
            ch1=1
        if  b+mul<=l:
            #print(2,b,mul)
            b+=mul
            ch2=1
        if ch1^ch2==1:   
            ans+=mul
        elif ch1==0 and ch2==0:
            if a+mul<=r:
                a+=mul
                ans+=mul
            elif b+mul<=r:
                b+=mul
                ans+=mul
            #print(123,ans)
        mul//=2
    #print(a,b,a^b)
    return ans
     
    
for _ in range(t):
    #n=int(input())
    #s=input()
    #n=int(input())
    #h,n=(map(int,input().split()))
    #n1=n
    #x=int(input())
    #b=int(input())
    #n,m,k=map(int,input().split())
        
    #l=list(map(int,input().split()))
    l,r=map(int,input().split())
    #n=int(input())
    #s=input()
    #s1=input()
    #p=input()
    #l=list(map(int,input().split()))
    #l.sort(revrese=True)
    #l2=list(map(int,input().split()))
    #l=str(n)
    #l.sort(reverse=True)
    #l2.sort(reverse=True)
    #l1.sort(reverse=True)
    print(solve())
            
        ",0276_D,CODEFORCES,885,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"n,k = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort()
c = n
j=0
for x in arr:
    while(x>arr[j]):
        if(x-arr[j]<=k):c-=1
        j+=1
          
print(c)    
",0990_B,CODEFORCES,2630,Micro-World,"You have a Petri dish with bacteria and you are preparing to dive into the harsh micro-world. But, unfortunately, you don't have any microscope nearby, so you can't watch them.
You know that you have $$$n$$$ bacteria in the Petri dish and size of the $$$i$$$-th bacteria is $$$a_i$$$. Also you know intergalactic positive integer constant $$$K$$$.
The $$$i$$$-th bacteria can swallow the $$$j$$$-th bacteria if and only if $$$a_i > a_j$$$ and $$$a_i \le a_j + K$$$. The $$$j$$$-th bacteria disappear, but the $$$i$$$-th bacteria doesn't change its size. The bacteria can perform multiple swallows. On each swallow operation any bacteria $$$i$$$ can swallow any bacteria $$$j$$$ if $$$a_i > a_j$$$ and $$$a_i \le a_j + K$$$. The swallow operations go one after another.
For example, the sequence of bacteria sizes $$$a=[101, 53, 42, 102, 101, 55, 54]$$$ and $$$K=1$$$. The one of possible sequences of swallows is: $$$[101, 53, 42, 102, \underline{101}, 55, 54]$$$ $$$\to$$$ $$$[101, \underline{53}, 42, 102, 55, 54]$$$ $$$\to$$$ $$$[\underline{101}, 42, 102, 55, 54]$$$ $$$\to$$$ $$$[42, 102, 55, \underline{54}]$$$ $$$\to$$$ $$$[42, 102, 55]$$$. In total there are $$$3$$$ bacteria remained in the Petri dish.
Since you don't have a microscope, you can only guess, what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope.
The first line contains two space separated positive integers $$$n$$$ and $$$K$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$1 \le K \le 10^6$$$) — number of bacteria and intergalactic constant $$$K$$$.
The second line contains $$$n$$$ space separated integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^6$$$) — sizes of bacteria you have.
Print the only integer — minimal possible number of bacteria can remain.
The first example is clarified in the problem statement.
","input
In the second example an optimal possible sequence of swallows is: $$$[20, 15, 10, 15, \underline{20}, 25]$$$ $$$\to$$$ $$$[20, 15, 10, \underline{15}, 25]$$$ $$$\to$$$ $$$[20, 15, \underline{10}, 25]$$$ $$$\to$$$ $$$[20, \underline{15}, 25]$$$ $$$\to$$$ $$$[\underline{20}, 25]$$$ $$$\to$$$ $$$[25]$$$.
output
In the third example no bacteria can swallow any other bacteria.
","greedy, sortings",4
"l,r=map(int,input().split())
p=bin(l)
p=p[2:]
q=bin(r)
q=q[2:]

t=len(q)
u=len(p)
p=(t-u)*'0'+p
ans=[]

for i in range(len(q)):
    if(q[i]=='1' and p[i]=='0'):
        ans.append(1)
        break;
    elif(q[i]=='1' and p[i]=='1'):
        ans.append(0)
        continue;
    elif(q[i]=='0' and p[i]=='1'):
        ans.append(1)
        continue;
    else:
        ans.append(0)
for j in range(i+1,len(p)):
        ans.append(1)
total=0

ans.reverse()


for i in range(len(ans)):
    total+=pow(2,i)*ans[i]

print(total)


",0276_D,CODEFORCES,864,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"n = int(input())
p = list(map(lambda x: int(x) - 1, input().split()))

vis = [False] * n
odd = 0
for x in range(n):
    if vis[x]:
        continue
    odd ^= 1
    while not vis[x]:
        odd ^= 1
        vis[x] = True
        x = p[x]

print('Petr' if (n + odd) % 2 == 0 else 'Um_nik')
",0986_B,CODEFORCES,2565,Petr and Permutations,"Petr likes to come up with problems about randomly generated data. This time problem is about random permutation. He decided to generate a random permutation this way: he takes identity permutation of numbers from $$$1$$$ to $$$n$$$ and then $$$3n$$$ times takes a random pair of different elements and swaps them. Alex envies Petr and tries to imitate him in all kind of things. Alex has also come up with a problem about random permutation. He generates a random permutation just like Petr but swaps elements $$$7n+1$$$ times instead of $$$3n$$$ times. Because it is more random, OK?!
You somehow get a test from one of these problems and now you want to know from which one.
In the first line of input there is one integer $$$n$$$ ($$$10^{3} \le n \le 10^{6}$$$).
In the second line there are $$$n$$$ distinct integers between $$$1$$$ and $$$n$$$ — the permutation of size $$$n$$$ from the test.
It is guaranteed that all tests except for sample are generated this way: First we choose $$$n$$$ — the size of the permutation. Then we randomly choose a method to generate a permutation — the one of Petr or the one of Alex. Then we generate a permutation using chosen method.
If the test is generated via Petr's method print ""Petr"" (without quotes). If the test is generated via Alex's method print ""Um_nik"" (without quotes).
","input
Please note that the sample is not a valid test (because of limitations for $$$n$$$) and is given only to illustrate input/output format. Your program still has to print correct answer to this test to get AC.
output
Due to randomness of input hacks in this problem are forbidden.
","combinatorics, math",4
"n = int(input().strip())
nums = list(map(int, input().strip().split()))
has_dups = (len(nums) > len(set(nums)))
mx = nums.index(max(nums))
if has_dups or nums[:mx+1]!=sorted(nums[:mx+1]) or nums[mx:]!=sorted(nums[mx:], reverse=True):
    print(""NO"")
else:
    print(""YES"")",1197_B,CODEFORCES,3022,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation",4
"n = int(input())
a = [int(x) for x in input().split()]
h = [-1]*(n)
b = [(a[i],i) for i in range(n)]
b.sort(reverse=True)
for e in b:
	# ~ print(e)
	num,idx = e
	flag = True
	allNeg = True
	foundLosing = False
	foundWin = False
	for i in range(idx%num,n,num):
		# ~ print(i)
		if i == idx:
			continue
		if h[i]!= -1:
			allNeg = False
		if h[i] == 0:
			foundLosing = True
			break
		if h[i] == 1:
			foundWin = False
	if allNeg:
		h[idx] = 0
	elif foundLosing:
		h[idx] = 1
	else:
		h[idx] = 0	
	# ~ print("" "".join(str(ss) for ss in h))
for i in range(n):
	if h[i]==0:
		print('B',end='')
	else:
		print('A',end='')
		
# ~ print(h)
",1033_C,CODEFORCES,3491,Permutation Game,"After a long day, Alice and Bob decided to play a little game. The game board consists of $$$n$$$ cells in a straight line, numbered from $$$1$$$ to $$$n$$$, where each cell contains a number $$$a_i$$$ between $$$1$$$ and $$$n$$$. Furthermore, no two cells contain the same number. 
A token is placed in one of the cells. They take alternating turns of moving the token around the board, with Alice moving first. The current player can move from cell $$$i$$$ to cell $$$j$$$ only if the following two conditions are satisfied: 
Whoever is unable to make a move, loses. For each possible starting position, determine who wins if they both play optimally. It can be shown that the game is always finite, i.e. there always is a winning strategy for one of the players.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of numbers.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$). Furthermore, there are no pair of indices $$$i \neq j$$$ such that $$$a_i = a_j$$$.
","input
Print $$$s$$$ — a string of $$$n$$$ characters, where the $$$i$$$-th character represents the outcome of the game if the token is initially placed in the cell $$$i$$$. If Alice wins, then $$$s_i$$$ has to be equal to ""A""; otherwise, $$$s_i$$$ has to be equal to ""B"". 
output
In the first sample, if Bob puts the token on the number (not position): 
","bruteforce, dp, games",5
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
	print(""?"", xr + cb, cb)
	ans11 = input()
	print(""?"", xr, cb)
	if ans11 == ans00:
		ans01 = input()
		if ans01 == '1':
			a += cb
			b += cb
	else:
		ans00 = input()
		if ans11 == '1':
			b += cb
		else:
			a += cb
		xr += cb
	cb //= 2
print(""!"", a, b)
",1088_D,CODEFORCES,646,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",1
"import sys

# sys.setrecursionlimit(200005)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def LI1(): return list(map(int1, sys.stdin.readline().split()))
def LLI1(rows_number): return [LI1() for _ in range(rows_number)]
def SI(): return sys.stdin.readline().rstrip()
inf = 10**16
md = 10**9+7
# md = 998244353

n, k = LI()
s = [-1 if c == ""?"" else ord(c)-97 for c in SI()]

def ok(m):
    nxt = [[n]*(n+1) for _ in range(k)]
    for j in range(k):
        cnt = 0
        ni = n
        nxtj = nxt[j]
        for i in range(n)[::-1]:
            if s[i] == -1 or s[i] == j: cnt += 1
            else: cnt = 0
            if cnt >= m: ni = i
            nxtj[i] = ni
    dp = [n+1]*(1 << k)
    dp[0] = 0
    for bit in range(1 << k):
        l = dp[bit]
        if l+m > n: continue
        for j in range(k):
            if bit >> j & 1: continue
            i = nxt[j][l]
            if i+m <= n:
                nbit = bit | 1 << j
                dp[nbit] = min(dp[nbit], i+m)
    return dp[-1] <= n

l, r = 0, n//k+1
while l+1 < r:
    m = (l+r)//2
    if ok(m): l = m
    else: r = m

print(l)
",1550_E,CODEFORCES,4767,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers",7
"from collections import defaultdict as dd
from collections import deque, Counter
import bisect
import heapq
from math import inf

import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def ri():
    return int(input())
 
def rl():
    return list(map(int, input().split()))


 
n, m = rl()
aa = rl()

#convert aa to array of [+,-,-,-,+,-,+,....]
bb = [-1]*n
for i in range(n):
	if aa[i] == m:
	    bb[i] = 1
	elif aa[i] < m:
	    bb[i] = -1
	else: # aa[i] > m
	    bb[i] = 1

prefix_sum= [0]*(n+1)
for i in range(1, n+1):
    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]


#now if we choose l and r, we have to compare:
# median on [l,r] more or equal to m iff (prefix_sum[r+1] - prefix_sum[l]) > 0  (1)

#if we do the same thing with m+1 instead of m
#median on [l,r] more or equal to m +1 ...

#we can deduct second result from first\
#to get the number of pairs [l,r] such as \
#median on [l,r] exactly equal to m


#we can rewrite (1)  as prefix_sum[r+1] > prefix_sum[l]
#this is linked to counting the number of inversions in the prefix sum!!
#classic problem, can be done by merge sort

#we need to be a bit carefull, because we want only the inversions\
# with l on left of median and r on the right
# can count inversion on 3 parts:
#-whole array
#-begin of array to median
#-median to end
#then deduct the last two from the first

def mergeSortGoodOrder(arr):
    """"""
    this doesn t count the number of inversions, but quite the opposite
    it counts the number of pairs i < j such as arr[i] < arr[j]
    """"""
    if len(arr) == 1:
        return arr, 0
    else:
        a = arr[:len(arr)//2]
        b = arr[len(arr)//2:]        

        a, ai = mergeSortGoodOrder(a)
        b, bi = mergeSortGoodOrder(b)
        c = []        

        i = 0
        j = 0
        good = 0 + ai + bi    

    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            c.append(a[i])
            i += 1
            good += (len(b)-j)
        else:
            c.append(b[j])
            j += 1
               

    c += a[i:]
    c += b[j:]

    return c, good



#step1: with m


#we want prefix_sum[l] < prefix_sum[r+1]
#ie : prefix_sum[l] < prefix_sum[r], and r stricly on the right of median


#find position of median
idx = 0
for i in range(n):
    if aa[i] == m:
        idx = i


_, good = mergeSortGoodOrder(prefix_sum)

_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])

_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])


first_count = good - bad_left - bad_right

#step2: with m + 1
bb = [-1]*n
for i in range(n):
	if aa[i] == m + 1:
	    bb[i] = 1
	elif aa[i] < m + 1:
	    bb[i] = -1
	else: # aa[i] > m + 1
	    bb[i] = 1

prefix_sum= [0]*(n+1)
for i in range(1, n+1):
    prefix_sum[i] = bb[i-1] + prefix_sum[i-1]



##BE CAREFUL: here we need to keep idx as the one of aa[idx] = m, NOT aa[idx = m+1]
# #find position of m + 1
# idx = 0
# for i in range(n):
#     if aa[i] == m + 1:
#         idx = i


_, good = mergeSortGoodOrder(prefix_sum)

_, bad_left = mergeSortGoodOrder(prefix_sum[:idx + 1])

_, bad_right = mergeSortGoodOrder(prefix_sum[idx + 1:])

second_count = good - bad_left - bad_right


#step3: combine

ans   = first_count - second_count

print(ans)


",1005_E1,CODEFORCES,2694,Median on Segments (Permutations Edition),"You are given a permutation $$$p_1, p_2, \dots, p_n$$$. A permutation of length $$$n$$$ is a sequence such that each integer between $$$1$$$ and $$$n$$$ occurs exactly once in the sequence.
Find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of the median of $$$p_l, p_{l+1}, \dots, p_r$$$ is exactly the given number $$$m$$$.
The median of a sequence is the value of the element which is in the middle of the sequence after sorting it in non-decreasing order. If the length of the sequence is even, the left of two middle elements is used.
For example, if $$$a=[4, 2, 7, 5]$$$ then its median is $$$4$$$ since after sorting the sequence, it will look like $$$[2, 4, 5, 7]$$$ and the left of two middle elements is equal to $$$4$$$. The median of $$$[7, 1, 2, 9, 6]$$$ equals $$$6$$$ since after sorting, the value $$$6$$$ will be in the middle of the sequence.
Write a program to find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of the median of $$$p_l, p_{l+1}, \dots, p_r$$$ is exactly the given number $$$m$$$.
The first line contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 2\cdot10^5$$$, $$$1 \le m \le n$$$) — the length of the given sequence and the required value of the median.
The second line contains a permutation $$$p_1, p_2, \dots, p_n$$$ ($$$1 \le p_i \le n$$$). Each integer between $$$1$$$ and $$$n$$$ occurs in $$$p$$$ exactly once.
","input
Print the required number.
output
In the first example, the suitable pairs of indices are: $$$(1, 3)$$$, $$$(2, 2)$$$, $$$(2, 3)$$$ and $$$(2, 4)$$$.
",sortings,4
"import sys
from collections import Counter

input = sys.stdin.readline
testcase=int(sys.stdin.readline())
A=[list(map(int,input().split())) for i in range(testcase*2)]

for t in range(testcase):
    counter=Counter(A[t*2+1])
    LIST=[]
    for c in counter:
        if counter[c]>=4:
            print(c,c,c,c)
            break
        elif counter[c]>=2:
            LIST.append(c)
    else:
        LIST.sort()
        #print(LIST)
        ANS=[LIST[0],LIST[1],LIST[1]/LIST[0]]
        for i in range(2,len(LIST)):
            if LIST[i]/LIST[i-1]<ANS[2]:
                ANS=[LIST[i-1],LIST[i],LIST[i]/LIST[i-1]]

        print(ANS[0],ANS[0],ANS[1],ANS[1])
            


",1027_C,CODEFORCES,2764,Minimum Value Rectangle,"You have $$$n$$$ sticks of the given lengths.
Your task is to choose exactly four of them in such a way that they can form a rectangle. No sticks can be cut to pieces, each side of the rectangle must be formed by a single stick. No stick can be chosen multiple times. It is guaranteed that it is always possible to choose such sticks.
Let $$$S$$$ be the area of the rectangle and $$$P$$$ be the perimeter of the rectangle. 
The chosen rectangle should have the value $$$\frac{P^2}{S}$$$ minimal possible. The value is taken without any rounding.
If there are multiple answers, print any of them.
Each testcase contains several lists of sticks, for each of them you are required to solve the problem separately.
The first line contains a single integer $$$T$$$ ($$$T \ge 1$$$) — the number of lists of sticks in the testcase.
Then $$$2T$$$ lines follow — lines $$$(2i - 1)$$$ and $$$2i$$$ of them describe the $$$i$$$-th list. The first line of the pair contains a single integer $$$n$$$ ($$$4 \le n \le 10^6$$$) — the number of sticks in the $$$i$$$-th list. The second line of the pair contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_j \le 10^4$$$) — lengths of the sticks in the $$$i$$$-th list.
It is guaranteed that for each list there exists a way to choose four sticks so that they form a rectangle.
The total number of sticks in all $$$T$$$ lists doesn't exceed $$$10^6$$$ in each testcase.
Print $$$T$$$ lines. The $$$i$$$-th line should contain the answer to the $$$i$$$-th list of the input. That is the lengths of the four sticks you choose from the $$$i$$$-th list, so that they form a rectangle and the value $$$\frac{P^2}{S}$$$ of this rectangle is minimal possible. You can print these four lengths in arbitrary order.
If there are multiple answers, print any of them.
There is only one way to choose four sticks in the first list, they form a rectangle with sides $$$2$$$ and $$$7$$$, its area is $$$2 \cdot 7 = 14$$$, perimeter is $$$2(2 + 7) = 18$$$. $$$\frac{18^2}{14} \approx 23.143$$$.
","input
The second list contains subsets of four sticks that can form rectangles with sides $$$(1, 2)$$$, $$$(2, 8)$$$ and $$$(1, 8)$$$. Their values are $$$\frac{6^2}{2} = 18$$$, $$$\frac{20^2}{16} = 25$$$ and $$$\frac{18^2}{8} = 40.5$$$, respectively. The minimal one of them is the rectangle $$$(1, 2)$$$.
output
You can choose any four of the $$$5$$$ given sticks from the third list, they will form a square with side $$$5$$$, which is still a rectangle with sides $$$(5, 5)$$$.
",greedy,4
"a = int(input())
c = [1] * 30
for i in range (1,20):
	c[i] = 9 * i * pow(10,i-1)
for i in range (1,15):
	if (a > c[i]):
		a -= c[i]
	else:
		d = int((a-1) / i + pow(10,i-1) - 1)
		e = (a-1) % i + 1
		f = str(d+1)
		print(f[e-1])
		exit()",1177_B,CODEFORCES,700,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",1
"for _ in range(int(input())):
	a, b = map(int, input().split())
	result = 0
	while min(a, b)!=0:
		x = max(a, b)
		y = min(a, b)
		a = x
		b = y
		result+=a//b
		a%=b
	print(result)",0267_A,CODEFORCES,87,Subtractions,"You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).
You've got some number of pairs (ai, bi). How many operations will be performed for each of them?
","input
The first line contains the number of pairs n (1  ≤  n  ≤  1000). Then follow n lines, each line contains a pair of positive integers ai, bi (1  ≤  ai,  bi  ≤  109).
output
Print the sought number of operations for each pair on a single line.
","math, numbertheory",1
"from math import sqrt

n, k = map(int, input().split())

answer = int(-1.5 + sqrt(9/4 + 2*(n+k)))

print(n - answer)
",1195_B,CODEFORCES,749,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",1
"#Collaborated with no one
#Problem C

ans = []
import math
disks_rad = [int(x) for x in input().split("" "")]
nums = [int(x) for x in input().split("" "")]
r = disks_rad[1]
ans.append(r)
for i in range(1, disks_rad[0]):
  y_cord = r
  for j in range(i):
      if ((nums[i] - nums[j]) ** 2) <= ((r ** 2) * 4):
          y_cord = max(y_cord,
                        ans[j] +
                        math.sqrt(4 *
                                  (r ** 2) -
                                  (nums[j] - nums[i]) ** 2
                                )
                      )
  ans.append(y_cord)
print("" "".join([str(x) for x in ans]))
	 		    								  	  		  		 			",0908_C,CODEFORCES,3053,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"import sys
mod=10**9+7
n,q=map(int,sys.stdin.readline().split())
S=sys.stdin.readline().strip()
LR=[list(map(int,sys.stdin.readline().split())) for i in range(q)]

LIST=[0]
for s in S:
    if s==""1"":
        LIST.append(LIST[-1]+1)
    else:
        LIST.append(LIST[-1])

def count(m,n,mod):
    return (pow(2,m,mod)-1)*pow(2,n,mod)%mod

for l,r in LR:
    print(count(LIST[r]-LIST[l-1],r-l+1-LIST[r]+LIST[l-1],mod))
    
",1062_C,CODEFORCES,1990,Banh-mi,"JATC loves Banh-mi (a Vietnamese food). His affection for Banh-mi is so much that he always has it for breakfast. This morning, as usual, he buys a Banh-mi and decides to enjoy it in a special way.
First, he splits the Banh-mi into $$$n$$$ parts, places them on a row and numbers them from $$$1$$$ through $$$n$$$. For each part $$$i$$$, he defines the deliciousness of the part as $$$x_i \in \{0, 1\}$$$. JATC's going to eat those parts one by one. At each step, he chooses arbitrary remaining part and eats it. Suppose that part is the $$$i$$$-th part then his enjoyment of the Banh-mi will increase by $$$x_i$$$ and the deliciousness of all the remaining parts will also increase by $$$x_i$$$. The initial enjoyment of JATC is equal to $$$0$$$.
For example, suppose the deliciousness of $$$3$$$ parts are $$$[0, 1, 0]$$$. If JATC eats the second part then his enjoyment will become $$$1$$$ and the deliciousness of remaining parts will become $$$[1, \_, 1]$$$. Next, if he eats the first part then his enjoyment will become $$$2$$$ and the remaining parts will become $$$[\_, \_, 2]$$$. After eating the last part, JATC's enjoyment will become $$$4$$$.
However, JATC doesn't want to eat all the parts but to save some for later. He gives you $$$q$$$ queries, each of them consisting of two integers $$$l_i$$$ and $$$r_i$$$. For each query, you have to let him know what is the maximum enjoyment he can get if he eats all the parts with indices in the range $$$[l_i, r_i]$$$ in some order.
All the queries are independent of each other. Since the answer to the query could be very large, print it modulo $$$10^9+7$$$.
The first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \le n, q \le 100\,000$$$).
The second line contains a string of $$$n$$$ characters, each character is either '0' or '1'. The $$$i$$$-th character defines the deliciousness of the $$$i$$$-th part.
Each of the following $$$q$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the segment of the corresponding query.
Print $$$q$$$ lines, where $$$i$$$-th of them contains a single integer — the answer to the $$$i$$$-th query modulo $$$10^9 + 7$$$.
","input
In the first example: 
output
In the second example, any order of eating parts leads to the same answer.
","greedy, implementation, math",3
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def check(mid,arr,m,n):
    ls = [[] for _ in range(1<<m)]
    for i in range(n):
        ans = 0
        for j in range(m):
            if arr[i][j] >= mid:
                ans += 1<<j
        ls[ans].append(i+1)
    for i in range(len(ls)):
        for j in range(len(ls)):
            if len(ls[i]) and len(ls[j]) and i|j == (1<<m)-1:
                return ls[i][0],ls[j][0]
    return 0

def main():
    n,m = map(int,input().split())
    arr = [list(map(int,input().split())) for _ in range(n)]
    hi,lo,ind1 = 10**9,0,(1,1)
    while hi >= lo:
        mid = (hi+lo)//2
        ind = check(mid,arr,m,n)
        if ind:
            ind1 = ind
            lo = mid+1
        else:
            hi = mid-1
    print(*ind1)

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",1288_D,CODEFORCES,4637,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
maxconseq = [[0 for j in range(k)] for i in range(n+1)]
for i in range(n):
    if s[i]==ord('?'):
        for j in range(k):
            maxconseq[i][j] = maxconseq[i-1][j] + 1
    else:
        j = s[i]-97
        maxconseq[i][j] = maxconseq[i-1][j] + 1
 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 
    
    for j in range(k):
        for i in range(n)[::-1]:
            if maxconseq[i][j]>=needed:
                effect[j][i-needed+1] = i+1
            effect[j][i] = min(effect[j][i], effect[j][i+1])


   
                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",1550_E,CODEFORCES,4759,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers",7
"ans=[""sjfnb"",""cslnb""]
n=int(input())
l=list(map(int,input().split()))
l.sort()
d=set()
e=0
s=0
for i in range(n):
    if l[i] in d:
        e+=1
        s=l[i]
    d.add(l[i])
if e>1 or l.count(0)>1 or s-1 in d:
    print(ans[1])
    
else:
    l=[l[i]-i for i in range(n)]
    #print(l)
    print(ans[1-sum(l)%2])",1190_B,CODEFORCES,2958,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
",games,4
"v = input().split()
n = int(v[0])
k = int(v[1])

s = input()
ap = 0

i = 1
while i < n:
    if s[:i] == s[-i:]:
        ap = i

    i += 1

print(s + s[ap:]*(k-1))
  	    					  		 	   			 	  		",1029_A,CODEFORCES,3444,Many Equal Substrings,"You are given a string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters and an integer number $$$k$$$.
Let's define a substring of some string $$$s$$$ with indices from $$$l$$$ to $$$r$$$ as $$$s[l \dots r]$$$.
Your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ positions $$$i$$$ such that $$$s[i \dots i + n - 1] = t$$$. In other words, your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
It is guaranteed that the answer is always unique.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 50$$$) — the length of the string $$$t$$$ and the number of substrings.
The second line of the input contains the string $$$t$$$ consisting of exactly $$$n$$$ lowercase Latin letters.
","input
Print such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
output
It is guaranteed that the answer is always unique.
","implementation, strings",5
"x, k = (int(x) for x in input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(x * 2 % mod)
    quit()
ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod) - 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",0992_C,CODEFORCES,1122,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"def ints():
 return map(int,input().split())
n,m=ints()
c=ints()
aa=[0]*(n+1)
for cc in c:
 aa[cc]+=1
print(min(aa[1:]))
 			  			 		 		 		  		 		  	",0961_A,CODEFORCES,3149,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation,5
"n, K = map(int, input().split())
A = list(map(int, input().split()))
A.sort()
s = []
for a in A:
    if not s:
        s.append(a)
        continue
    while s:
        if a-K <= s[-1] < a:
            s.pop()
        else:
            break
    s.append(a)
print(len(s))
",0990_B,CODEFORCES,2624,Micro-World,"You have a Petri dish with bacteria and you are preparing to dive into the harsh micro-world. But, unfortunately, you don't have any microscope nearby, so you can't watch them.
You know that you have $$$n$$$ bacteria in the Petri dish and size of the $$$i$$$-th bacteria is $$$a_i$$$. Also you know intergalactic positive integer constant $$$K$$$.
The $$$i$$$-th bacteria can swallow the $$$j$$$-th bacteria if and only if $$$a_i > a_j$$$ and $$$a_i \le a_j + K$$$. The $$$j$$$-th bacteria disappear, but the $$$i$$$-th bacteria doesn't change its size. The bacteria can perform multiple swallows. On each swallow operation any bacteria $$$i$$$ can swallow any bacteria $$$j$$$ if $$$a_i > a_j$$$ and $$$a_i \le a_j + K$$$. The swallow operations go one after another.
For example, the sequence of bacteria sizes $$$a=[101, 53, 42, 102, 101, 55, 54]$$$ and $$$K=1$$$. The one of possible sequences of swallows is: $$$[101, 53, 42, 102, \underline{101}, 55, 54]$$$ $$$\to$$$ $$$[101, \underline{53}, 42, 102, 55, 54]$$$ $$$\to$$$ $$$[\underline{101}, 42, 102, 55, 54]$$$ $$$\to$$$ $$$[42, 102, 55, \underline{54}]$$$ $$$\to$$$ $$$[42, 102, 55]$$$. In total there are $$$3$$$ bacteria remained in the Petri dish.
Since you don't have a microscope, you can only guess, what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope.
The first line contains two space separated positive integers $$$n$$$ and $$$K$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$1 \le K \le 10^6$$$) — number of bacteria and intergalactic constant $$$K$$$.
The second line contains $$$n$$$ space separated integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^6$$$) — sizes of bacteria you have.
Print the only integer — minimal possible number of bacteria can remain.
The first example is clarified in the problem statement.
","input
In the second example an optimal possible sequence of swallows is: $$$[20, 15, 10, 15, \underline{20}, 25]$$$ $$$\to$$$ $$$[20, 15, 10, \underline{15}, 25]$$$ $$$\to$$$ $$$[20, 15, \underline{10}, 25]$$$ $$$\to$$$ $$$[20, \underline{15}, 25]$$$ $$$\to$$$ $$$[\underline{20}, 25]$$$ $$$\to$$$ $$$[25]$$$.
output
In the third example no bacteria can swallow any other bacteria.
","greedy, sortings",4
"list_int_input = lambda inp: list(map(int, inp.split()))
int_input = lambda inp: int(inp)
string_to_list_input = lambda inp: list(inp)

n,v=map(int,input().split())
val=v-1+int(((n-v)*(n-v+1))/2)
if n>v:
    print(val)
else:
    print(n-1)",1113_A,CODEFORCES,686,Sasha and His Trip,"Sasha is a very happy guy, that's why he is always on the move. There are $$$n$$$ cities in the country where Sasha lives. They are all located on one straight line, and for convenience, they are numbered from $$$1$$$ to $$$n$$$ in increasing order. The distance between any two adjacent cities is equal to $$$1$$$ kilometer. Since all roads in the country are directed, it's possible to reach the city $$$y$$$ from the city $$$x$$$ only if $$$x < y$$$. 
Once Sasha decided to go on a trip around the country and to visit all $$$n$$$ cities. He will move with the help of his car, Cheetah-2677. The tank capacity of this model is $$$v$$$ liters, and it spends exactly $$$1$$$ liter of fuel for $$$1$$$ kilometer of the way. At the beginning of the journey, the tank is empty. Sasha is located in the city with the number $$$1$$$ and wants to get to the city with the number $$$n$$$. There is a gas station in each city. In the $$$i$$$-th city, the price of $$$1$$$ liter of fuel is $$$i$$$ dollars. It is obvious that at any moment of time, the tank can contain at most $$$v$$$ liters of fuel.
Sasha doesn't like to waste money, that's why he wants to know what is the minimum amount of money is needed to finish the trip if he can buy fuel in any city he wants. Help him to figure it out!
The first line contains two integers $$$n$$$ and $$$v$$$ ($$$2 \le n \le 100$$$, $$$1 \le v \le 100$$$)  — the number of cities in the country and the capacity of the tank.
Print one integer — the minimum amount of money that is needed to finish the trip.
","input
In the first example, Sasha can buy $$$2$$$ liters for $$$2$$$ dollars ($$$1$$$ dollar per liter) in the first city, drive to the second city, spend $$$1$$$ liter of fuel on it, then buy $$$1$$$ liter for $$$2$$$ dollars in the second city and then drive to the $$$4$$$-th city. Therefore, the answer is $$$1+1+2=4$$$.
output
In the second example, the capacity of the tank allows to fill the tank completely in the first city, and drive to the last city without stops in other cities.
","dp, greedy, math",1
"from math import ceil

n=int(input())
d={1:[1],2:[1,2],3:[1,1,3]}
if n in d:
    for i in d[n]:
        print(i,end=' ')
    exit()
def f(n):
    if n in d:
        return d[n]
    odds=ceil(n/2)
    lis=[1]*odds
    even=n//2
    lis1=f(even)
    for i in range(len(lis1)):
        lis1[i]*=2
    return lis+lis1
ans=f(n)
for i in ans:
    print(i,end=' ')",1059_C,CODEFORCES,2837,Sequence Transformation,"Let's call the following process a transformation of a sequence of length $$$n$$$.
If the sequence is empty, the process ends. Otherwise, append the greatest common divisor (GCD) of all the elements of the sequence to the result and remove one arbitrary element from the sequence. Thus, when the process ends, we have a sequence of $$$n$$$ integers: the greatest common divisors of all the elements in the sequence before each deletion.
You are given an integer sequence $$$1, 2, \dots, n$$$. Find the lexicographically maximum result of its transformation.
A sequence $$$a_1, a_2, \ldots, a_n$$$ is lexicographically larger than a sequence $$$b_1, b_2, \ldots, b_n$$$, if there is an index $$$i$$$ such that $$$a_j = b_j$$$ for all $$$j < i$$$, and $$$a_i > b_i$$$.
The first and only line of input contains one integer $$$n$$$ ($$$1\le n\le 10^6$$$).
Output $$$n$$$ integers  — the lexicographically maximum result of the transformation.
","input
In the first sample the answer may be achieved this way:
output
We get the sequence $$$[1, 1, 3]$$$ as the result.
","constructivealgorithms, math",4
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split())) 
r.sort(reverse=True) 
g.sort(reverse=True) 
b.sort(reverse=True) 
#print(r,g,b)
dp=[[[-1 for i in range(205)] for j in range(205)] for k in range(205)]
def recurser(x,y,z):
    if (x>=R and y>=G) or (y>=G and z>=B) or (z>=B and x>=R):
        return 0 
    if dp[x][y][z]!=-1:
        return dp[x][y][z] 
    maxi=0 
    if x<R and y<G:
        maxi=max(maxi,r[x]*g[y]+recurser(x+1,y+1,z)) 
    if y<G and z<B:
        maxi=max(maxi,g[y]*b[z]+recurser(x,y+1,z+1)) 
    if z<B and x<R:
        maxi=max(maxi,r[x]*b[z]+recurser(x+1,y,z+1))
    dp[x][y][z]=maxi
    return maxi 
print(recurser(0,0,0)) ",1398_D,CODEFORCES,3943,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"s=input()
n=len(s)
m=0

for i in range(n-1):
    for j in range(1,n-i):
        if s[i:i+j] in s[i+1:]:
            if j>m:
                m=j

print(m)
    ",0023_A,CODEFORCES,3694,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"# A. Find Square

n, m = map(int, input().split())

top = [-1, -1]
bottom = [-1, -1]

for i in range(n):
    s = input()
    left = s.find('B')
    if left != -1:
        right = s.rfind('B')
        c = (right - left) // 2 + 1
        print(i + c, left + c)
        break
",1028_A,CODEFORCES,3411,Find Square,"Consider a table of size $$$n \times m$$$, initially fully white. Rows are numbered $$$1$$$ through $$$n$$$ from top to bottom, columns $$$1$$$ through $$$m$$$ from left to right. Some square inside the table with odd side length was painted black. Find the center of this square.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 115$$$) — the number of rows and the number of columns in the table.
","input
The $$$i$$$-th of the next $$$n$$$ lines contains a string of $$$m$$$ characters $$$s_{i1} s_{i2} \ldots s_{im}$$$ ($$$s_{ij}$$$ is 'W' for white cells and 'B' for black cells), describing the $$$i$$$-th row of the table.
output
Output two integers $$$r$$$ and $$$c$$$ ($$$1 \le r \le n$$$, $$$1 \le c \le m$$$) separated by a space — the row and column numbers of the center of the black square.
",implementation,5
"n = int(input("""")) 
if n==1 or n==2: 
    print(n) 
elif n&1: 
    print((n)*(n-1)*(n-2))
else:
    if n%3==0:
        print((n-2)*(n-1)*(n-3))
    else :
         print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3),(n*(n-1)*(n-2))/2))",0235_A,CODEFORCES,85,LCM Challenge,"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.
But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than n. Can you help me to find the maximum possible least common multiple of these three integers?
The first line contains an integer n (1 ≤ n ≤ 106) — the n mentioned in the statement.
Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than n.
The least common multiple of some positive integers is the least positive integer which is multiple for each of them.
","input
The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.
output
For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.
",numbertheory,1
"import itertools
n,l,r,x=map(int,input().split())
problems=[int(x) for x in input().split()]
result=0
for i in range(2,n+1):
    for comb in itertools.combinations(problems,i):
        summ = sum(comb)
        mini = min(comb)
        maxx = max(comb)
        if l <= summ <=r and maxx-mini>=x:
            result+=1
print(result)
    		 		 		   	 				 	 		 		 	",0550_B,CODEFORCES,4495,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"import math
ans = [1, 3, 15, 133, 2025, 37851, 1030367, 36362925]
n = int(input())

if (n % 2 == 1):
	print(ans[n // 2] * math.factorial(n) % 1000000007)
else:
	print(0)",0285_D,CODEFORCES,4294,Permutation Sum,"Permutation p is an ordered set of integers p1,  p2,  ...,  pn, consisting of n distinct positive integers, each of them doesn't exceed n. We'll denote the i-th element of permutation p as pi. We'll call number n the size or the length of permutation p1,  p2,  ...,  pn.
Petya decided to introduce the sum operation on the set of permutations of length n. Let's assume that we are given two permutations of length n: a1, a2, ..., an and b1, b2, ..., bn. Petya calls the sum of permutations a and b such permutation c of length n, where ci = ((ai - 1 + bi - 1) mod n) + 1 (1 ≤ i ≤ n).
Operation  means taking the remainder after dividing number x by number y.
Obviously, not for all permutations a and b exists permutation c that is sum of a and b. That's why Petya got sad and asked you to do the following: given n, count the number of such pairs of permutations a and b of length n, that exists permutation c that is sum of a and b. The pair of permutations x, y (x ≠ y) and the pair of permutations y, x are considered distinct pairs.
As the answer can be rather large, print the remainder after dividing it by 1000000007 (109 + 7).
","input
The single line contains integer n (1 ≤ n ≤ 16).
output
In the single line print a single non-negative integer — the number of such pairs of permutations a and b, that exists permutation c that is sum of a and b, modulo 1000000007 (109 + 7).
","bitmasks, combinatorics, dp, implementation, meet-in-the-middle",7
"n = int(input())
x, y = 1, 9
n -= 1
while n > x * y:
    n -= x * y
    x += 1
    y *= 10
a = 10 ** (x - 1) + n // x
print(str(a)[n % x])",1177_B,CODEFORCES,1317,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"# -*- coding: utf-8 -*-
""""""
Created on Sun Aug 30 02:21:13 2020

@author: Dark Soul
""""""

k=int(input(''))
sol=''
cnt=0
for i in range(1,13):
    inc=9*(10**(i-1))*i
    if cnt+inc>=k:
        break
    else:
        cnt+=inc
lft=k-cnt
dig=(lft)/i
if dig!=int(dig):
    dig=int(dig+1)
else:
    dig=int(dig)
num=(10**(i-1))+dig-1
left=k-(cnt+dig*i)
sol=str(num)
print(sol[left-1])

    
",1177_B,CODEFORCES,1330,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"def gcd(a, b):
    if a > b:
        a, b = b, a
    if b % a==0:
        return a
    return gcd(b % a, a)

def line(a, b):
    x0, y0 = a
    x1, y1 = b
    if x0==x1:
        return [True, x1, None]
    else:
        slope_num = (y1-y0)
        slope_den = (x1-x0)
        if slope_num==0:
            num = 0
            den = 1
        else:
            g = gcd(abs(slope_num), abs(slope_den))
            num = slope_num//g
            den = slope_den//g
        inter = den*y0-num*x0
        if inter==0:
            den2 = 1
        else:
            den2 = den
        return [False, num, den, inter, den2]
    
def online(line, a):
    x0, y0 = a
    if line[0]:
        return x0==line[1]
    else:
        C, num, den, inter, den2 = line
        #(num/den)*x0 + (inter/den2) == y0
        return (num*x0+inter)==y0*den
       # return my_inter==den
    
def process(A):
    n = len(A)
    if n <= 3:
        return 'YES'
    l1 = line(A[0], A[1])
    l2 = line(A[1], A[2])
    l3 = line(A[0], A[2])
    for Line1 in [l1, l2, l3]:
        other = []
        for x in A:
            if not online(Line1, x):
                other.append(x)
        if len(other) <= 2:
         #   print(Line1, other)
            return 'YES'
        a1 = other[0]
        a2 = other[1]
        Line2 = line(a1, a2)
        works = True
        for x in other:
            if not online(Line2, x):
                works = False
                break
        if works:
          #  print(Line1, Line2)
            return 'YES'
    return 'NO'

n = int(input())
A = []
for i in range(n):
    x, y = [int(x) for x in input().split()]
    A.append([x, y])
print(process(A))",0961_D,CODEFORCES,2484,Pair Of Lines,"You are given n points on Cartesian plane. Every point is a lattice point (i. e. both of its coordinates are integers), and all points are distinct.
You may draw two straight lines (not necessarily distinct). Is it possible to do this in such a way that every point lies on at least one of these lines?
The first line contains one integer n (1 ≤ n ≤ 105) — the number of points you are given.
Then n lines follow, each line containing two integers xi and yi (|xi|, |yi| ≤ 109)— coordinates of i-th point. All n points are distinct.
","input
If it is possible to draw two straight lines in such a way that each of given points belongs to at least one of these lines, print YES. Otherwise, print NO.
output
In the first example it is possible to draw two lines, the one containing the points 1, 3 and 5, and another one containing two remaining points.
",geometry,4
"
n = input()

m = 0
for i in range(len(n)):

    for j in range(i,len(n)+1):

        if len(n[i:j])>m and n[i:j] in n[i+1:len(n)]:

            m = len(n[i:j])

print(m)
",0023_A,CODEFORCES,3691,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"def check(a, b):
    if a[1] == b[1] and 1 <= abs(int(b[0]) - int(a[0])) <= 2:
        return True

arr = input().split()
d = {}
for i in arr:
    d[i] = d.get(i, 0) + 1
mineq = 3 - max(d.values())
arr.sort(key=lambda x: x[0])
arr.sort(key=lambda x: x[1])
if check(arr[0], arr[1]) or check(arr[1], arr[2]):
    mineq = min(mineq, 1)
if arr[0][1] == arr[1][1] == arr[2][1] and int(arr[2][0]) - int(arr[1][0]) == 1 and int(arr[1][0]) - int(arr[0][0]) == 1:
    mineq = 0
print(mineq)",1191_B,CODEFORCES,2960,Tokitsukaze and Mahjong,"Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $$$1$$$ to $$$9$$$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $$$\ldots$$$, 9m, 1p, 2p, $$$\ldots$$$, 9p, 1s, 2s, $$$\ldots$$$, 9s.
In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.
Do you know the minimum number of extra suited tiles she needs to draw so that she can win?
Here are some useful definitions in this game:
Some examples: 
Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.
The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $$$1$$$ to $$$9$$$ and the second character is m, p or s.
Print a single integer — the minimum number of extra suited tiles she needs to draw.
In the first example, Tokitsukaze already has a shuntsu.
","input
In the second example, Tokitsukaze already has a koutsu.
output
In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
","bruteforce, implementation",4
"n, values, wrong = int(input()), [int(i) for i in input().split()], 0
sorted_values = list(sorted(values))
for i in range(n):
    if values[i] != sorted_values[i]:
        wrong += 1
if wrong > 2:
    print(""NO"")
else:
    print(""YES"")",0220_A,CODEFORCES,2367,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"def main():
    import sys
    read = sys.stdin.read
    readline = sys.stdin.readline
    INF = 1 << 60
    MOD = 10 ** 9 + 7
    sys.setrecursionlimit(10 ** 5)
    """"""+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-+:-""""""

    def new_dp():
        return [[INF] * M for _ in range(N)]

    def solve():
        if K % 2 == 1:
            for row in range(N):
                print(*[-1] * M)
            return

        dp_prev = [[0] * M for _ in range(N)]

        for _ in range(K // 2):
            dp_cur = new_dp()
            for row in range(N):
                for col in range(M - 1):
                    cost = e1[row][col]
                    dp_cur[row][col] = min(dp_cur[row][col], dp_prev[row][col + 1] + cost)
                    dp_cur[row][col + 1] = min(dp_cur[row][col + 1], dp_prev[row][col] + cost)
            for row in range(N - 1):
                for col in range(M):
                    cost = e2[row][col]
                    dp_cur[row][col] = min(dp_cur[row][col], dp_prev[row + 1][col] + cost)
                    dp_cur[row + 1][col] = min(dp_cur[row + 1][col], dp_prev[row][col] + cost)
            dp_prev = dp_cur

        for row in range(N):
            _r = [2 * x for x in dp_prev[row]]
            print(*_r)

    N, M, K = map(int, readline().split())

    e1 = []
    for _ in range(N):
        r = tuple(map(int, readline().split()))
        e1.append(r)
    e2 = []

    for _ in range(N - 1):
        r = tuple(map(int, readline().split()))
        e2.append(r)
    solve()


if __name__ == '__main__':
    main()
",1517_D,CODEFORCES,4166,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import sys
from array import array  # noqa: F401


def readline(): return sys.stdin.buffer.readline().decode('utf-8')


n, k = map(int, readline().split())
mod = 998244353

if k == 1:
    print(0)
    exit()


dp1 = [array('i', [0])*n for _ in range(n)]
dp2 = [array('i', [0])*n for _ in range(n)]
dp1[0][0] = 1

for i in range(n-1):
    for j in range(i+1):
        for l in range(j+1):
            dp2[j][0] += dp1[j][l]
            if dp2[j][0] >= mod:
                dp2[j][0] -= mod

            dp2[j+1 if j == l else j][l+1] += dp1[j][l]
            if dp2[j+1 if j == l else j][l+1] >= mod:
                dp2[j+1 if j == l else j][l+1] -= mod

            dp1[j][l] = 0

    dp1, dp2 = dp2, dp1

ans = 0
for i in range(1, n+1):
    t = (k-1) // i
    if t == 0:
        break

    dps1 = array('i', [0])*(t+1)
    dps2 = array('i', [0])*(t+1)
    dps1[0] = 1

    for j in range(n-1):
        for l in range(min(j+1, t)):
            dps2[0] += dps1[l]
            if dps2[0] >= mod:
                dps2[0] -= mod

            dps2[l+1] += dps1[l]
            if dps2[l+1] >= mod:
                dps2[l+1] -= mod

            dps1[l] = 0

        dps1, dps2 = dps2, dps1

    x = sum(dp1[i-1]) % mod
    ans = (ans + x * sum(dps1[:-1])) % mod

print(ans * 2 % mod)
",1027_E,CODEFORCES,3781,Inverse Coloring,"You are given a square board, consisting of $$$n$$$ rows and $$$n$$$ columns. Each tile in it should be colored either white or black.
Let's call some coloring beautiful if each pair of adjacent rows are either the same or different in every position. The same condition should be held for the columns as well.
Let's call some coloring suitable if it is beautiful and there is no rectangle of the single color, consisting of at least $$$k$$$ tiles.
Your task is to count the number of suitable colorings of the board of the given size.
Since the answer can be very large, print it modulo $$$998244353$$$.
A single line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 500$$$, $$$1 \le k \le n^2$$$) — the number of rows and columns of the board and the maximum number of tiles inside the rectangle of the single color, respectively.
Print a single integer — the number of suitable colorings of the board of the given size modulo $$$998244353$$$.
Board of size $$$1 \times 1$$$ is either a single black tile or a single white tile. Both of them include a rectangle of a single color, consisting of $$$1$$$ tile.
","input
Here are the beautiful colorings of a board of size $$$2 \times 2$$$ that don't include rectangles of a single color, consisting of at least $$$3$$$ tiles:
output
The rest of beautiful colorings of a board of size $$$2 \times 2$$$ are the following:
","combinatorics, dp, math",6
"from sys import stdin
from collections import deque
c=int(stdin.readline().strip())
for cas in range(c):
    n,m=map(int,stdin.readline().strip().split())
    s=deque(stdin.readline().strip())
    arr=[""R"",""G"",""B""]
    ans=n+3
    for k in range(1):

        for  i in range(3):
            x=i

            dp=[0 for i in range(n+1)]
            for j in range(n):

                if s[j]!=arr[x]:
                    dp[j+1]+=1
                dp[j+1]+=dp[j]
                if j+1>=m:

                    ans=min(ans,dp[j+1]-dp[j+1-m])
                x+=1
                x=x%3

    print(ans)
                
            
    
            
            
1
",1196_D2,CODEFORCES,2240,RGB Substring (hard version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2 \cdot 10^5$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2 \cdot 10^5$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
","datastructures, dp, implementation, twopointers",3
"

if __name__ == '__main__':

    x, y, z, t1, t2, t3 = [int(i) for i in input().split(' ')]

    lift_time = (abs(z-x) + abs(y-x))*t2 + 3*t3

    stairs_time = abs(y-x)*t1

    if lift_time <= stairs_time:
        print('YES')
    else:
        print('NO')",1054_A,CODEFORCES,505,Elevator or Stairs?,"Masha lives in a multi-storey building, where floors are numbered with positive integers. Two floors are called adjacent if their numbers differ by one. Masha decided to visit Egor. Masha lives on the floor $$$x$$$, Egor on the floor $$$y$$$ (not on the same floor with Masha).
The house has a staircase and an elevator. If Masha uses the stairs, it takes $$$t_1$$$ seconds for her to walk between adjacent floors (in each direction). The elevator passes between adjacent floors (in each way) in $$$t_2$$$ seconds. The elevator moves with doors closed. The elevator spends $$$t_3$$$ seconds to open or close the doors. We can assume that time is not spent on any action except moving between adjacent floors and waiting for the doors to open or close. If Masha uses the elevator, it immediately goes directly to the desired floor.
Coming out of the apartment on her floor, Masha noticed that the elevator is now on the floor $$$z$$$ and has closed doors. Now she has to choose whether to use the stairs or use the elevator. 
If the time that Masha needs to get to the Egor's floor by the stairs is strictly less than the time it will take her using the elevator, then she will use the stairs, otherwise she will choose the elevator.
Help Mary to understand whether to use the elevator or the stairs.
The only line contains six integers $$$x$$$, $$$y$$$, $$$z$$$, $$$t_1$$$, $$$t_2$$$, $$$t_3$$$ ($$$1 \leq x, y, z, t_1, t_2, t_3 \leq 1000$$$) — the floor Masha is at, the floor Masha wants to get to, the floor the elevator is located on, the time it takes Masha to pass between two floors by stairs, the time it takes the elevator to pass between two floors and the time it takes for the elevator to close or open the doors.
It is guaranteed that $$$x \ne y$$$.
If the time it will take to use the elevator is not greater than the time it will take to use the stairs, print «YES» (without quotes), otherwise print «NO> (without quotes).
You can print each letter in any case (upper or lower).
In the first example:
If Masha goes by the stairs, the time she spends is $$$4 \cdot 4 = 16$$$, because she has to go $$$4$$$ times between adjacent floors and each time she spends $$$4$$$ seconds. 
If she chooses the elevator, she will have to wait $$$2$$$ seconds while the elevator leaves the $$$4$$$-th floor and goes to the $$$5$$$-th. After that the doors will be opening for another $$$1$$$ second. Then Masha will enter the elevator, and she will have to wait for $$$1$$$ second for the doors closing. Next, the elevator will spend $$$4 \cdot 2 = 8$$$ seconds going from the $$$5$$$-th floor to the $$$1$$$-st, because the elevator has to pass $$$4$$$ times between adjacent floors and spends $$$2$$$ seconds each time. And finally, it will take another $$$1$$$ second before the doors are open and Masha can come out. 
Thus, all the way by elevator will take $$$2 + 1 + 1 + 8 + 1 = 13$$$ seconds, which is less than $$$16$$$ seconds, so Masha has to choose the elevator.
","input
In the second example, it is more profitable for Masha to use the stairs, because it will take $$$13$$$ seconds to use the elevator, that is more than the $$$10$$$ seconds it will takes to go by foot.
output
In the third example, the time it takes to use the elevator is equal to the time it takes to walk up by the stairs, and is equal to $$$12$$$ seconds. That means Masha will take the elevator.
",implementation,1
"def f(n,s):
 d=[-n,-n];d[s]=0
 for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
 return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",1463_F,CODEFORCES,4703,Max Correct Set,"Let's call the set of positive integers $$$S$$$ correct if the following two conditions are met: 
For the given values $$$n$$$, $$$x$$$, and $$$y$$$, you have to find the maximum size of the correct set.
","input
A single line contains three integers $$$n$$$, $$$x$$$ and $$$y$$$ ($$$1 \le n \le 10^9$$$; $$$1 \le x, y \le 22$$$). 
output
Print one integer — the maximum size of the correct set.
","bitmasks, dp, math",7
"# coding: utf-8
import sys
from heapq import heappush, heappop, heapify
sys.setrecursionlimit(int(1e7))

def main():
    n = int(input().strip())
    a = [int(x) for x in input().split()]
    a = [-x-1 if x>=0 else x for x in a]
    if n%2==1:
        _, i = min((x,i) for i,x in enumerate(a))
        a[i] = -a[i]-1
    print(*a)
    return

while 1:
    try: main()
    except EOFError: break",1180_B,CODEFORCES,2160,Nick and Array,"Nick had received an awesome array of integers $$$a=[a_1, a_2, \dots, a_n]$$$ as a gift for his $$$5$$$ birthday from his mother. He was already going to explore its various properties but after unpacking he was disappointed a lot because the product $$$a_1 \cdot a_2 \cdot \dots a_n$$$ of its elements seemed to him not large enough.
He was ready to throw out the array, but his mother reassured him. She told him, that array would not be spoiled after the following operation: choose any index $$$i$$$ ($$$1 \le i \le n$$$) and do $$$a_i := -a_i - 1$$$.
For example, he can change array $$$[3, -1, -4, 1]$$$ to an array $$$[-4, -1, 3, 1]$$$ after applying this operation to elements with indices $$$i=1$$$ and $$$i=3$$$. 
Kolya had immediately understood that sometimes it's possible to increase the product of integers of the array a lot. Now he has decided that he wants to get an array with the maximal possible product of integers using only this operation with its elements (possibly zero, one or more times, as many as he wants), it is not forbidden to do this operation several times for the same index. 
Help Kolya and print the array with the maximal possible product of elements $$$a_1 \cdot a_2 \cdot \dots a_n$$$ which can be received using only this operation in some order.
If there are multiple answers, print any of them.
The first line contains integer $$$n$$$ ($$$1 \leq n \leq 10^{5}$$$) — number of integers in the array.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$-10^{6} \leq a_i \leq 10^{6}$$$) — elements of the array
","input
Print $$$n$$$ numbers — elements of the array with the maximal possible product of elements which can be received using only this operation in some order from the given array.
output
If there are multiple answers, print any of them.
","greedy, implementation",3
"n,k = list(map(int, input().split()))
a = list(map(int, input().split()))
t = list(map(int, input().split()))
x = 0
summ = 0
maxx = 0
for i in range(n):
  summ += a[i]*t[i]
for i in range(k):
  if not t[i]:
    x+=a[i]
maxx = max(maxx,x)
for i in range(n-k):
  x+=a[i+k]*(1-t[i+k])
  x-=a[i]*(1-t[i])
  if x>maxx:
    maxx=x
  #maxx = max(x, maxx)
print(summ+maxx)",0961_B,CODEFORCES,1592,Lecture Sleep,"Your friend Mishka and you attend a calculus lecture. Lecture lasts n minutes. Lecturer tells ai theorems during the i-th minute.
Mishka is really interested in calculus, though it is so hard to stay awake for all the time of lecture. You are given an array t of Mishka's behavior. If Mishka is asleep during the i-th minute of the lecture then ti will be equal to 0, otherwise it will be equal to 1. When Mishka is awake he writes down all the theorems he is being told — ai during the i-th minute. Otherwise he writes nothing.
You know some secret technique to keep Mishka awake for k minutes straight. However you can use it only once. You can start using it at the beginning of any minute between 1 and n - k + 1. If you use it on some minute i then Mishka will be awake during minutes j such that  and will write down all the theorems lecturer tells.
You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
The first line of the input contains two integer numbers n and k (1 ≤ k ≤ n ≤ 105) — the duration of the lecture in minutes and the number of minutes you can keep Mishka awake.
The second line of the input contains n integer numbers a1, a2, ... an (1 ≤ ai ≤ 104) — the number of theorems lecturer tells during the i-th minute.
The third line of the input contains n integer numbers t1, t2, ... tn (0 ≤ ti ≤ 1) — type of Mishka's behavior at the i-th minute of the lecture.
","input
Print only one integer — the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
output
In the sample case the better way is to use the secret technique at the beginning of the third minute. Then the number of theorems Mishka will be able to write down will be equal to 16.
","datastructures, dp, implementation, twopointers",3
"from itertools import combinations
n, mn, mx, diff = map(int, input().split())
arr = list(map(int, input().split()))
print(sum(sum(1 for x in combinations(arr, i) if sum(x)>= mn and sum(x) <= mx and max(x)-min(x)>=diff) for i in range(2, n+1)))

",0550_B,CODEFORCES,4453,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"modulo = 1000 ** 3 + 7


def mat_oz(x, k):
    if k == 0:
        return (2 * x) % modulo
    if x == 0:
        return 0
    b = (pow(2, k, modulo) * (2 * x - 1) + 1) % modulo
    return b


y, m = [int(i) for i in input().split()]
print(mat_oz(y, m))
",0992_C,CODEFORCES,1110,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"n, m = map(int, input().split())
s = 0
while m:
    s += n // m
    n, m = m, n % m
print(s)",0343_A,CODEFORCES,130,Rational Resistance,"Mad scientist Mike is building a time machine in his spare time. To finish the work, he needs a resistor with a certain resistance value.
However, all Mike has is lots of identical resistors with unit resistance R0 = 1. Elements with other resistance can be constructed from these resistors. In this problem, we will consider the following as elements: 
With the consecutive connection the resistance of the new element equals R = Re + R0. With the parallel connection the resistance of the new element equals . In this case Re equals the resistance of the element being connected.
Mike needs to assemble an element with a resistance equal to the fraction . Determine the smallest possible number of resistors he needs to make such an element.
The single input line contains two space-separated integers a and b (1 ≤ a, b ≤ 1018). It is guaranteed that the fraction  is irreducible. It is guaranteed that a solution always exists.
Print a single number — the answer to the problem.
Please do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.
","input
In the first sample, one resistor is enough.
output
In the second sample one can connect the resistors in parallel, take the resulting element and connect it to a third resistor consecutively. Then, we get an element with resistance . We cannot make this element using two resistors.
","math, numbertheory",1
"'''input
3
5 2
BGGGG
5 3
RBRGR
5 5
BBBRR
'''
import sys
from collections import defaultdict as dd

mod=10**9+7

def ri(flag=0):
	if flag==0:
		return [int(i) for i in sys.stdin.readline().split()]
	else:
		return int(sys.stdin.readline())


for _ in range(int(input())):
	n,k = ri()
	a = input()
	rgb= [0 for i in range(n)]
	gbr= [0 for i in range(n)]
	brg= [0 for i in range(n)]

	for i in range(n):
		if i%3==0:
			if a[i]!=""R"":
				rgb[i]+=1
		if i%3==1:
			if a[i]!=""G"":
				rgb[i]+=1
		if i%3==2:
			if a[i]!=""B"":
				rgb[i]+=1

	for i in range(n):
		if i%3==0:
			if a[i]!=""G"":
				gbr[i]+=1
		if i%3==1:
			if a[i]!=""B"":
				gbr[i]+=1
		if i%3==2:
			if a[i]!=""R"":
				gbr[i]+=1

	for i in range(n):
		if i%3==0:
			if a[i]!=""B"":
				brg[i]+=1
		if i%3==1:
			if a[i]!=""R"":
				brg[i]+=1
		if i%3==2:
			if a[i]!=""G"":
				brg[i]+=1

	for i in range(1,n):
		rgb[i]+=rgb[i-1]
		brg[i]+=brg[i-1]
		gbr[i]+=gbr[i-1]


	ans = 999999999
	#print(rgb,gbr,brg)
	for i in range(k-1,n):
		#print(i,i-k)
		if i-k ==-1:
			ans = min(ans,rgb[i],gbr[i],brg[i])
		else:
			ans = min(ans, rgb[i]- rgb[i-k] , gbr[i]- gbr[i-k], brg[i]- brg[i-k] )

	print(ans)






",1196_D1,CODEFORCES,2236,RGB Substring (easy version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2000$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2000$$$ ($$$\sum n \le 2000$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
",implementation,3
"import sys

input = sys.stdin.buffer.readline

def find_pair(candidate,data,m):
    ans = (-1,-1)
    binary_bit = [False for i in range(1 << m)]
    for i in data:
        bit_tmp = 0
        for j in range(len(i)):
            if i[j] >= candidate: bit_tmp |= 1 << j
        binary_bit[bit_tmp] = True
    
    for i in range(1 << m):
        for j in range(1 << m):
            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:
                ans = i , j
                break
    return ans

def backtracking(candidate,ans,data):
    idx_i = -1 ; idx_j = -1
    for i in range(len(data)):
        bit_tmp = 0
        for j in range(len(data[i])):
            if data[i][j] >= candidate: bit_tmp |= 1 << j
        if bit_tmp == ans[0]: idx_i = i
        if bit_tmp == ans[1]: idx_j = i

    print(str(idx_i + 1) + "" "" + str(idx_j + 1))

def main():
    n , m = [int(i) for i in input().split()]
    data = [[int(i) for i in input().split()] for i in range(n)]
    a = 0 ; b = 10**9 + 7
    ans = (-1,-1)
    candidate = -1
    while a <= b:
        mid = (a + b)//2
        bin_ans = find_pair(mid,data,m)
        if bin_ans[0] != -1 and bin_ans[1] != -1:
            ans = bin_ans
            candidate = mid
            a = mid + 1
        else:
            b = mid - 1
    backtracking(candidate,ans,data)

main()
",1288_D,CODEFORCES,4674,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))
PLACE=[None]*(n+1)
for i in range(n):
    PLACE[A[i]]=i

al=n


WINLIST=[None]*(n+1)#0:そこに行けば必敗,1:そこにいけば必勝

def move(n,al):
    place=PLACE[n]
    for i in range(place,-1,-n):
        if A[i]>n and WINLIST[A[i]]==""B"":
            WINLIST[n]=""A""
            return
            
    for i in range(place,al,n):
        if A[i]>n and WINLIST[A[i]]==""B"":
            WINLIST[n]=""A""
            return 

    else:
        WINLIST[n]=""B""
        return 
   

for j in range(n,0,-1):
    move(j,al)


ANS=""""
for i in A:
    ANS+=WINLIST[i]

print(ANS)
",1033_C,CODEFORCES,1910,Permutation Game,"After a long day, Alice and Bob decided to play a little game. The game board consists of $$$n$$$ cells in a straight line, numbered from $$$1$$$ to $$$n$$$, where each cell contains a number $$$a_i$$$ between $$$1$$$ and $$$n$$$. Furthermore, no two cells contain the same number. 
A token is placed in one of the cells. They take alternating turns of moving the token around the board, with Alice moving first. The current player can move from cell $$$i$$$ to cell $$$j$$$ only if the following two conditions are satisfied: 
Whoever is unable to make a move, loses. For each possible starting position, determine who wins if they both play optimally. It can be shown that the game is always finite, i.e. there always is a winning strategy for one of the players.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of numbers.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$). Furthermore, there are no pair of indices $$$i \neq j$$$ such that $$$a_i = a_j$$$.
","input
Print $$$s$$$ — a string of $$$n$$$ characters, where the $$$i$$$-th character represents the outcome of the game if the token is initially placed in the cell $$$i$$$. If Alice wins, then $$$s_i$$$ has to be equal to ""A""; otherwise, $$$s_i$$$ has to be equal to ""B"". 
output
In the first sample, if Bob puts the token on the number (not position): 
","bruteforce, dp, games",3
"def fn(n):
	return (n * (n + 1)) / 2

def search(x, n):
	left, right = 0, n
	while left <= right:
		middle = left + (right - left) // 2
		if fn(middle) - (n - middle) == x: return (n - middle)
		elif fn(middle) - (n - middle) > x: right = middle - 1
		else: left = middle + 1
	return -1

if __name__ == '__main__':
	n, k = [int(i) for i in input().split()]
	print(search(k, n))",1195_B,CODEFORCES,1412,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n,m=inar()
    tup=[]
    sm=0
    for i in range(n):
        a,b=inar()
        sm+=a
        diff=a-b
        tup.append([diff,a,b])
    tup.sort(reverse=True)
    ans=0
    i=0
    while sm>m and i<n:
        sm-=tup[i][1]
        sm+=tup[i][2]
        i+=1
        ans+=1
    if sm<=m:
        print(ans)
    else:
        print(-1)




if __name__ == '__main__':
    main()



",1015_C,CODEFORCES,2744,Songs Compression,"Ivan has $$$n$$$ songs on his phone. The size of the $$$i$$$-th song is $$$a_i$$$ bytes. Ivan also has a flash drive which can hold at most $$$m$$$ bytes in total. Initially, his flash drive is empty.
Ivan wants to copy all $$$n$$$ songs to the flash drive. He can compress the songs. If he compresses the $$$i$$$-th song, the size of the $$$i$$$-th song reduces from $$$a_i$$$ to $$$b_i$$$ bytes ($$$b_i < a_i$$$).
Ivan can compress any subset of the songs (possibly empty) and copy all the songs to his flash drive if the sum of their sizes is at most $$$m$$$. He can compress any subset of the songs (not necessarily contiguous).
Ivan wants to find the minimum number of songs he needs to compress in such a way that all his songs fit on the drive (i.e. the sum of their sizes is less than or equal to $$$m$$$).
If it is impossible to copy all the songs (even if Ivan compresses all the songs), print ""-1"". Otherwise print the minimum number of songs Ivan needs to compress.
The first line of the input contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 10^9$$$) — the number of the songs on Ivan's phone and the capacity of Ivan's flash drive.
The next $$$n$$$ lines contain two integers each: the $$$i$$$-th line contains two integers $$$a_i$$$ and $$$b_i$$$ ($$$1 \le a_i, b_i \le 10^9$$$, $$$a_i > b_i$$$) — the initial size of the $$$i$$$-th song and the size of the $$$i$$$-th song after compression.
If it is impossible to compress a subset of the songs in such a way that all songs fit on the flash drive, print ""-1"". Otherwise print the minimum number of the songs to compress.
","input
In the first example Ivan can compress the first and the third songs so after these moves the sum of sizes will be equal to $$$8 + 7 + 1 + 5 = 21 \le 21$$$. Also Ivan can compress the first and the second songs, then the sum of sizes will be equal $$$8 + 4 + 3 + 5 = 20 \le 21$$$. Note that compressing any single song is not sufficient to copy all the songs on the flash drive (for example, after compressing the second song the sum of sizes will be equal to $$$10 + 4 + 3 + 5 = 22 > 21$$$).
output
In the second example even if Ivan compresses all the songs the sum of sizes will be equal $$$8 + 4 + 1 + 4 = 17 > 16$$$.
",sortings,4
"import math
import sys
import collections

# imgur.com/Pkt7iIf.png

def getdict(n):
    d = {}
    if type(n) is list:
        for i in n:
            if i in d:
                d[i] += 1
            else:
                d[i] = 1
    else:
        for i in range(n):
            t = ii()
            if t in d:
                d[t] += 1
            else:
                d[t] = 1
    return d
def cdiv(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))

t = ii()
for i in range(t):
    n = ii()
    d = sorted(li())
    print(min(d[-2] - 1, n - 2))
",1197_A,CODEFORCES,3013,DIY Wooden Ladder,"Let's denote a $$$k$$$-step ladder as the following structure: exactly $$$k + 2$$$ wooden planks, of which
Note that neither the base planks, nor the steps planks are required to be equal.
For example, ladders $$$1$$$ and $$$3$$$ are correct $$$2$$$-step ladders and ladder $$$2$$$ is a correct $$$1$$$-step ladder. On the first picture the lengths of planks are $$$[3, 3]$$$ for the base and $$$[1]$$$ for the step. On the second picture lengths are $$$[3, 3]$$$ for the base and $$$[2]$$$ for the step. On the third picture lengths are $$$[3, 4]$$$ for the base and $$$[2, 3]$$$ for the steps. 
You have $$$n$$$ planks. The length of the $$$i$$$-th planks is $$$a_i$$$. You don't have a saw, so you can't cut the planks you have. Though you have a hammer and nails, so you can assemble the improvised ""ladder"" from the planks.
The question is: what is the maximum number $$$k$$$ such that you can choose some subset of the given planks and assemble a $$$k$$$-step ladder using them?
The first line contains a single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of queries. The queries are independent.
Each query consists of two lines. The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^5$$$) — the number of planks you have.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^5$$$) — the lengths of the corresponding planks.
It's guaranteed that the total number of planks from all queries doesn't exceed $$$10^5$$$.
Print $$$T$$$ integers — one per query. The $$$i$$$-th integer is the maximum number $$$k$$$, such that you can choose some subset of the planks given in the $$$i$$$-th query and assemble a $$$k$$$-step ladder using them.
Print $$$0$$$ if you can't make even $$$1$$$-step ladder from the given set of planks.
","input
Examples for the queries $$$1-3$$$ are shown at the image in the legend section.
output
The Russian meme to express the quality of the ladders:
","greedy, math, sortings",4
"import sys, heapq

n, m = map(int, sys.stdin.readline().split())
for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
ans = [0] * n
for i in range(1, n, 2):
    ans[i] = 1
print(''.join(map(str, ans)))
",1004_B,CODEFORCES,1760,Sonya and Exhibition,"Sonya decided to organize an exhibition of flowers. Since the girl likes only roses and lilies, she decided that only these two kinds of flowers should be in this exhibition.
There are $$$n$$$ flowers in a row in the exhibition. Sonya can put either a rose or a lily in the $$$i$$$-th position. Thus each of $$$n$$$ positions should contain exactly one flower: a rose or a lily.
She knows that exactly $$$m$$$ people will visit this exhibition. The $$$i$$$-th visitor will visit all flowers from $$$l_i$$$ to $$$r_i$$$ inclusive. The girl knows that each segment has its own beauty that is equal to the product of the number of roses and the number of lilies.
Sonya wants her exhibition to be liked by a lot of people. That is why she wants to put the flowers in such way that the sum of beauties of all segments would be maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\leq n, m\leq 10^3$$$) — the number of flowers and visitors respectively.
Each of the next $$$m$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1\leq l_i\leq r_i\leq n$$$), meaning that $$$i$$$-th visitor will visit all flowers from $$$l_i$$$ to $$$r_i$$$ inclusive.
Print the string of $$$n$$$ characters. The $$$i$$$-th symbol should be «0» if you want to put a rose in the $$$i$$$-th position, otherwise «1» if you want to put a lily.
If there are multiple answers, print any.
In the first example, Sonya can put roses in the first, fourth, and fifth positions, and lilies in the second and third positions;
The total beauty is equal to $$$2+2+4=8$$$.
","input
In the second example, Sonya can put roses in the third, fourth, and sixth positions, and lilies in the first, second, and fifth positions;
output
The total beauty is equal to $$$1+4+2=7$$$.
","constructivealgorithms, greedy, implementation, math",3
"n, l, r, x = map(int, input().split())
arr = list(map(int, input().split()))
res = 0
for j in range(1, 2**n):
    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]
    res += (max(a) - min(a) >= x and sum(a) >= l and sum(a) <= r)
print(res)
",0550_B,CODEFORCES,4446,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
