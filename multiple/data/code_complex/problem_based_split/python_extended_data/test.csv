src,complexity,problem,from,idx,problem_title,problem_description,input_output_specification,tags
"with open(""input.txt"",""r"") as in_file: 
    with open(""output.txt"",""a"") as out_file:
        N,M = map(int,in_file.readline().split())
        K = int(in_file.readline())
        map_max_dist = [[5000 for i in range(M)] for j in range(N)]
        inputs = list(map(int,in_file.readline().split()))
        p = 0 
        while(p<=K*2-2):
            x,y = inputs[p]-1,inputs[p+1]-1
            for r in range(N):
                for c in range(M):
                    dist = abs(x-r)+abs(y-c)
                    if dist<map_max_dist[r][c]:
                        map_max_dist[r][c] = dist
            p+=2
        max_val = 0 
        max_index = (0,0)
        i,j = 0,0
        for i in range(N):
            for j in range(M):
                if(map_max_dist[i][j]>max_val):
                    max_val = map_max_dist[i][j]
                    max_index = (i,j)
        out_file.write(""{} {}"".format(max_index[0]+1,max_index[1]+1))
    
        ",cubic,0035_C,CODEFORCES,3759,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"'''
                ___                       ____                     
  ____ _____ _____/ (_)_  ______  ____ _____/ / /_  __  ______ ___  __
 / __ `/ __ `/ __  / / / / / __ \/ __ `/ __  / __ \/ / / / __ `/ / / /
/ /_/ / /_/ / /_/ / / /_/ / /_/ / /_/ / /_/ / / / / /_/ / /_/ / /_/ / 
\__,_/\__,_/\__,_/_/\__,_/ .___/\__,_/\__,_/_/ /_/\__, /\__,_/\__, /  
                        /_/                      /____/      /____/   
'''
import os.path
from math import gcd, floor, ceil
from collections import *
import sys
mod = 1000000007
INF = float('inf')
def st(): return list(sys.stdin.readline().strip())
def li(): return list(map(int, sys.stdin.readline().split()))
def mp(): return map(int, sys.stdin.readline().split())
def inp(): return int(sys.stdin.readline())
def pr(n): return sys.stdout.write(str(n)+""\n"")
def prl(n): return sys.stdout.write(str(n)+"" "")


if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]


def solve():
    n, m = mp()
    k = inp()
    l = li()
    q = deque()
    v = [[0]*(m+1) for i in range(n+1)]
    for i in range(0, 2*k - 1, 2):
        q.append((l[i], l[i+1]))
        v[l[i]][l[i+1]] = 1
    while q:
        a, b = q.popleft()
        for i in range(4):
            A, B = a+dx[i], b+dy[i]
            if A > 0 and A <= n and B > 0 and B <= m:
                if not v[A][B]:
                    q.append((A, B))
                    v[A][B] = 1
    print(a, b)


for _ in range(1):
    solve()
",cubic,0035_C,CODEFORCES,3758,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"from collections import deque
with open(""input.txt"",""r"") as input_file: 
    with open(""output.txt"",""a"") as output_file:
        N,M = map(int,input_file.readline().split())
        K = int(input_file.readline())
        T = list(map(int,input_file.readline().split()))
        graph = [[0] * (M + 1) for _ in range(N + 1)]
        queue = deque()
        for i in range(0, 2 * K - 1, 2):
            graph[T[i]][T[i + 1]] = 1
            queue.append((T[i], T[i + 1]))
        x, y = 0, 0
        while queue:
            x, y = queue.popleft()
            x_moves = [x - 1, x + 1, x, x]
            y_moves = [y, y, y - 1, y + 1]
            for i in range(len(x_moves)):
                if 0 < x_moves[i] <= N and 0 < y_moves[i] <= M:
                    if graph[x_moves[i]][y_moves[i]] == 0:
                        x = x_moves[i]
                        y = y_moves[i]
                        graph[x_moves[i]][y_moves[i]] = 1
                        queue.append((x_moves[i], y_moves[i]))
        output_file.write(f""{x} {y}"")",cubic,0035_C,CODEFORCES,3760,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"from queue import Queue
import datetime

with open(""input.txt"", 'r') as in_file:
    n, m = (int(i) for i in in_file.readline().split("" ""))
    k = int(in_file.readline())
    ints = [int(i) for i in in_file.readline().split("" "")]

pairs = []
for i in range(0, len(ints), 2):
    x = ints[i]
    y = ints[i+1]
    pairs.append((x, y))


last_tree = (1, 1)
maxd = 0
mult = m * n
for i in range(1, n+1):
    for j in range(1, m+1):
        md = mult
        # print(""par"", i, j)
        for pair in pairs:
            x, y = pair
            d = abs(i-x)+abs(j-y)
            # print(""punto"", x, y)
            # print(""distancia"", d)
            md = min(md, d)
            # print(""min"", md)
        if md > maxd:
            # print(""max"", md)
            last_tree = (i, j)
            maxd = md
        # print("""")

# print(""res"", last_tree)
with open(""output.txt"", 'w') as out_file:
    out_file.write(f""{last_tree[0]} {last_tree[1]}"")

	 		 	 			  		 		         		  	",cubic,0035_C,CODEFORCES,3764,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"# XXXX

from sys import stdin, exit
from typing import List, Tuple, Dict
from itertools import product


def distance(tree: Tuple[int, int], outbreak: Tuple[int, int]):
    return abs(tree[0] - outbreak[0]) + abs(tree[1] - outbreak[1])


def shorthest_path(tree: Tuple[int, int], outbreaks: List[Tuple[int, int]], min_dst: int):
    shorthest_path = float('inf')
    for outbreak in outbreaks:
        if shorthest_path < min_dst:
            break
        shorthest_path = min(shorthest_path, distance(tree, outbreak))
    return shorthest_path


input_f = open('input.txt', 'r')
output_f = open('output.txt', 'w')

N, M = [int(v) for v in input_f.readline().rstrip().split()]
input_f.readline()  # ignore
outbreaks_line = [int(v) for v in input_f.readline().rstrip().split()]
outbreaks = []
input_f.close()


for i in range(0, len(outbreaks_line) - 1, 2):
    outbreaks.append((outbreaks_line[i], outbreaks_line[i+1]))

last_tree = (1, 1)
best_dst = 0
for x, y in product(range(1, N + 1), range(1, M + 1)):
    path_len = shorthest_path((x, y), outbreaks, best_dst)
    if path_len > best_dst:
        last_tree = (x, y)
        best_dst = path_len

output_f.write(' '.join(map(str, last_tree)))
# print(' '.join(map(str, last_tree)))

output_f.close()
",cubic,0035_C,CODEFORCES,3765,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase
from collections import deque

def main():
    with open('input.txt') as fp:
        input=fp.readline
        n, m = map(int, input().split())
        dx = [1, -1, 0, 0]
        dy = [0, 0, -1, 1]
        q =deque()
        k = int(input())
        a = list(map(int, input().split()))
        v = [[1] * (m + 2) for _ in range(n + 2)]
        for i in range(m + 2):
            v[0][i] = 0
            v[-1][i] = 0
        for i in range(n + 2):
            v[i][0] = 0
            v[i][-1] = 0
        for i in range(0, 2 * k, 2):
            q.append((a[i],a[i + 1]))
            v[a[i]][a[i + 1]] = 0
        while 1:
            x, y =q.popleft()
            for i in range(4):
                xx, yy = x + dx[i], y + dy[i]
                if v[xx][yy]:
                    q.append((xx, yy))
                    v[xx][yy] = 0
            if not q:
                with open('output.txt', mode='w') as fpp:
                    fpp.write(f'{x} {y}')
                break

# region fastio
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",cubic,0035_C,CODEFORCES,3757,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

# from sys import stdin
# input = stdin.buffer.readline
# I = lambda : list(map(int,input().split()))

# import sys
# input=sys.stdin.readline



n, m = L()
k = L()[0]
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, L()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))
 
 
x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))
 
print(f'{x+1} {y+1}')
",cubic,0035_C,CODEFORCES,3761,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"from math import log
import random
spaces = ("" "",""\n"",""\t"")
stops = ("""","" "",""\n"",""\t"")
extendedPoints = set()
startingPoints = set()
interestPoints = []

class TPoint:
	def __init__(self,x,y):
		self.x=x
		self.y=y
	def __str__(self):
		return ""(""+str(self.x)+"",""+str(self.y)+"")""
	def __eq__(self, other): 
		return self.x == other.x and self.y == other.y
	def __hash__(self):
		return self.x*20000 + self.y
	x=0
	y=0
	h=0	
def sortKey(p):
	return p.h
def heuristic(p, otherPoints):
	minH = float(""inf"")
	for point in otherPoints:
		currentH = abs(point.x - p.x) + abs(point.y - p.y)
		if currentH < minH:
			minH = currentH
	return minH

def addPoint(p,pointList):
	if not p in extendedPoints:
		p.h = heuristic(p,startingPoints)
		extendedPoints.add(p)
		pointList.append(p)
		#print(p.x,p.y,p.h)
		return True
	else:
		return False

def extend(point,n,m,poinList):
	ok = False
	if point.x>1:
		ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok
	if point.x<n:
		ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok
	if point.y>1:
		ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok
	if point.y<m:
		ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok

	return ok

def ReadNext(fileObject):
	currentBuffer = """"
	currentRead=fileObject.read(1)
	while currentRead in spaces:
		currentRead=fileObject.read(1)
	currentBuffer = currentBuffer + currentRead
	while not currentRead in stops:
		currentRead=fileObject.read(1)
		currentBuffer = currentBuffer + currentRead
	return currentBuffer.strip()

w, r= open('output.txt', 'w'), open('input.txt', 'r')

n = int(ReadNext(r))
m = int(ReadNext(r))
k = int(ReadNext(r))
mscale = 5

for i in range(k):
	x = int(ReadNext(r))
	y = int(ReadNext(r))
	p = TPoint(x,y)
	startingPoints.add(p)
	extendedPoints.add(p)

tmpPoints = []
tmpPoints.append(TPoint(1,1))
tmpPoints.append(TPoint(1,m))
tmpPoints.append(TPoint(n,1))
tmpPoints.append(TPoint(n,m))
if n>2 and m>2:
	tmpPoints.append(TPoint(int(n/2),1))
	tmpPoints.append(TPoint(1,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),m))
	tmpPoints.append(TPoint(n,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),int(m/2)))

for p in tmpPoints:
	addPoint(p,interestPoints)
	#extend(p,n,m,interestPoints)
for p in startingPoints:
	extend(p,n,m,interestPoints)

interestPoints.sort(reverse=True, key=sortKey)
while len(interestPoints) > 3*mscale:
	interestPoints.pop(len(interestPoints)-1)

random.seed()

if(len(interestPoints)>0):
	maxPoint = interestPoints[0]
	for p in interestPoints:
		currentBeam = [p]
		canExtend = True
		while canExtend:
			addPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)
			canExtend = False
			for i in range(len(currentBeam)):
				if extend(currentBeam[i],n,m,currentBeam):
					canExtend = True
			currentBeam.sort(reverse=True, key=sortKey)
			while len(currentBeam) > mscale:
				currentBeam.pop(len(currentBeam)-1)
		if currentBeam[0].h>maxPoint.h:
			maxPoint = currentBeam[0]
	#print(maxPoint.x,maxPoint.y)
	#print(str(len(extendedPoints)))
	w.write(str(maxPoint.x)+"" ""+str(maxPoint.y)+""\n"")
else:
	w.write(str(n)+"" ""+str(m)+""\n"")
",cubic,0035_C,CODEFORCES,3756,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"from math import log
import random
spaces = ("" "",""\n"",""\t"")
stops = ("""","" "",""\n"",""\t"")
extendedPoints = set()
startingPoints = set()
interestPoints = []

class TPoint:
	def __init__(self,x,y):
		self.x=x
		self.y=y
	def __str__(self):
		return ""(""+str(self.x)+"",""+str(self.y)+"")""
	def __eq__(self, other): 
		return self.x == other.x and self.y == other.y
	def __hash__(self):
		return self.x*20000 + self.y
	x=0
	y=0
	h=0	# эвристика
def sortKey(p):
	return p.h
def heuristic(p, otherPoints):
	minH = float(""inf"")
	for point in otherPoints:
		currentH = abs(point.x - p.x) + abs(point.y - p.y)
		if currentH < minH:
			minH = currentH
	return minH

def addPoint(p,pointList):
	if not p in extendedPoints:
		p.h = heuristic(p,startingPoints)
		extendedPoints.add(p)
		pointList.append(p)
		#print(p.x,p.y,p.h)
		return True
	else:
		return False

def extend(point,n,m,poinList):
	ok = False
	if point.x>1:
		ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok
	if point.x<n:
		ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok
	if point.y>1:
		ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok
	if point.y<m:
		ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok

	return ok

def ReadNext(fileObject):
	currentBuffer = """"
	currentRead=fileObject.read(1)
	while currentRead in spaces:
		currentRead=fileObject.read(1)
	currentBuffer = currentBuffer + currentRead
	while not currentRead in stops:
		currentRead=fileObject.read(1)
		currentBuffer = currentBuffer + currentRead
	return currentBuffer.strip()

w, r= open('output.txt', 'w'), open('input.txt', 'r')

n = int(ReadNext(r))
m = int(ReadNext(r))
k = int(ReadNext(r))
mscale = 5

for i in range(k):
	x = int(ReadNext(r))
	y = int(ReadNext(r))
	p = TPoint(x,y)
	startingPoints.add(p)
	extendedPoints.add(p)

tmpPoints = []
tmpPoints.append(TPoint(1,1))
tmpPoints.append(TPoint(1,m))
tmpPoints.append(TPoint(n,1))
tmpPoints.append(TPoint(n,m))
if n>2 and m>2:
	tmpPoints.append(TPoint(int(n/2),1))
	tmpPoints.append(TPoint(1,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),m))
	tmpPoints.append(TPoint(n,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),int(m/2)))

for p in tmpPoints:
	addPoint(p,interestPoints)
	#extend(p,n,m,interestPoints)
for p in startingPoints:
	extend(p,n,m,interestPoints)

interestPoints.sort(reverse=True, key=sortKey)
while len(interestPoints) > 3*mscale:
	interestPoints.pop(len(interestPoints)-1)

random.seed()

if(len(interestPoints)>0):
	maxPoint = interestPoints[0]
	for p in interestPoints:
		currentBeam = [p]
		canExtend = True
		while canExtend:
			addPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)
			canExtend = False
			for i in range(len(currentBeam)):
				if extend(currentBeam[i],n,m,currentBeam):
					canExtend = True
			currentBeam.sort(reverse=True, key=sortKey)
			while len(currentBeam) > mscale:
				currentBeam.pop(len(currentBeam)-1)
		if currentBeam[0].h>maxPoint.h:
			maxPoint = currentBeam[0]
	#print(maxPoint.x,maxPoint.y)
	#print(str(len(extendedPoints)))
	w.write(str(maxPoint.x)+"" ""+str(maxPoint.y)+""\n"")
else:
	w.write(str(n)+"" ""+str(m)+""\n"")
",cubic,0035_C,CODEFORCES,3762,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"import sys
from array import array  # noqa: F401
from itertools import product
from collections import deque


def input():
    with open('input.txt') as fp:
        return fp.readlines()


def output(ans: str):
    with open('output.txt', mode='w') as fp:
        fp.write(ans)


'''
def input():
    return [line.decode('utf-8') for line in sys.stdin.buffer.readlines()]


def output(ans):
    print(ans)
'''


s = input()
n, m = map(int, s[0].split())
k = int(s[1])
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, s[2].split()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))


x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))

output(f'{x+1} {y+1}')
",cubic,0035_C,CODEFORCES,3766,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"from queue import Queue
import datetime

with open(""input.txt"", 'r') as in_file:
    n, m = (int(i) for i in in_file.readline().split("" ""))
    k = int(in_file.readline())
    ints = [int(i) for i in in_file.readline().split("" "")]

pairs = []
for i in range(0, len(ints), 2):
    x = ints[i]
    y = ints[i+1]
    pairs.append((x, y))

# calc = datetime.datetime.now()
last_tree = (1, 1)
maxd = 0
mult = m * n
for i in range(1, n+1):
    for j in range(1, m+1):
        md = mult
        # print(""par"", i, j)
        for pair in pairs:
            x, y = pair
            d = abs(i-x)+abs(j-y)
            # print(""punto"", x, y)
            # print(""distancia"", d)
            md = min(md, d)
            # print(""min"", md)
        if md > maxd:
            # print(""max"", md)
            last_tree = (i, j)
            maxd = md
        # print("""")

# dif_calc = datetime.datetime.now() - calc
# print(""calcular"", dif_calc)
# print(""res"", last_tree)
with open(""output.txt"", 'w') as out_file:
    out_file.write(f""{last_tree[0]} {last_tree[1]}"")
",cubic,0035_C,CODEFORCES,3763,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths"
"import math
def lucky(x):
    return (list(set(list(str(x)))) in [[""4""],[""7""],[""4"",""7""],[""7"",""4""]])
a = int(input())
true = False
for i in range(1, math.ceil(math.sqrt(a))+1):
    if a % i == 0:
        if lucky(i) or lucky(a//i):
            true = True
            break
print(""YES"" if true else ""NO"")",constant,0122_A,CODEFORCES,47,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"s=int(input())
t=len(str(s))
L=['4','7']
import copy
for i in range(t):
    L1=copy.deepcopy(L)
    for m in L:
        L1.append(m+'4')
        L1.append(m+'7')
    L=L1
L0=list(map(int,L))
sum=0
for i in range(len(L0)):
    if s%L0[i]==0:
        sum=sum+1
if sum>0:
    print('YES')
else:
    print('NO')",constant,0122_A,CODEFORCES,51,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"n = int(input())
k = set(""47"")
p = False
for i in range(1, n+1):
    if n%i == 0:
        if set(str(i)) <= k:
            p = bool(set(str(i)))
            break       
if p == True:
    print(""YES"")
else:
    print(""NO"") ",constant,0122_A,CODEFORCES,45,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"import math
def islucky(x):
    digits = set(list(str(x)))
    return (len(digits) == 2 and (""4"" in digits and ""7"" in digits)) or (len(digits) == 1 and (""4"" in digits or ""7"" in digits))
a = int(input())
lucky = islucky(a)
for i in range(2, math.ceil(math.sqrt(a))+1):
    if a % i == 0:
        #print(i, a / i)
        if islucky(i) or islucky(a // i):
            lucky = True
            break

print(""YES"" if lucky else ""NO"")",constant,0122_A,CODEFORCES,43,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"n=int(input())
li=[]
for i in range(1,n+1):
    if n%i==0:
        li.append(i)
p=0
for t in li:
    l=[m for m in str(t)]
    if set(l)=={'4'} or set(l)=={'7'} or set(l)=={'4','7'}:
        p+=1
if p>0:
    print('YES')
else:
    print('NO')",constant,0122_A,CODEFORCES,52,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"a=int(input())
b=str(a)
c=[]
for i in range(2,a+1):
    if(a%i==0):
        c.append(i)

l=0
for j in c:
    r=str(j)
    t=len(r)
    o=0
    for p in r:
        if(p==""4"" or p==""7""):
            o=o+1
    if(o==t):
        l=l+1
if(l>0):
    print(""YES"")
else:
    print(""NO"")

            
    
",constant,0122_A,CODEFORCES,44,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"n=int(input())
c=0
lst=[4,7,47,74,447,474,744,477,747,774]
if n in lst:
    print(""YES"")
else:
    for i in lst:
        if n%i==0:
            print(""YES"")
            c=c+1
            break
        else:
            continue
    if c==0:
        print(""NO"")
    
",constant,0122_A,CODEFORCES,48,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"n=int(input())
l=[4,7,47,74,44,77,447,444,474,777,747,744,477]
c=0
for i in range(len(l)):
    if n%l[i]==0:
        c=1
        break
if c==1:
    print(""YES"")
else:
    print(""NO"")
",constant,0122_A,CODEFORCES,41,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"import itertools

def q121a_v2():
	good_num_arr = generate_47_arr()
	num = int(input())
	for element in good_num_arr:
		if(num % element == 0):
			print(""YES"")
			return
	print(""NO"")


def generate_47_arr():
	arr = []
	for digits in range(1, 4):
		arr += itertools.product(""47"", repeat=digits)
	for i in range(len(arr)):
		arr[i] = int("""".join(list(arr[i])))
	arr.append(4444444444)
	return arr

q121a_v2()",constant,0122_A,CODEFORCES,49,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"def luck(n):
    if n % 4 == 0 or n % 7 == 0:
        return True
    while n > 0:
        tmp = n % 10
        n = int(n / 10)
        if tmp != 4 and tmp != 7:
            return False

    return True


def lucky(n):
    if luck(n):
        return ""YES""

    for x in range(1, n + 1):
        if n % x == 0 and luck(x):
            return ""YES""

    return ""NO""


n = int(input())

print(lucky(n))",constant,0122_A,CODEFORCES,35,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"n = int(input())
l = [4,7,47,74,444,447,474,477,747,744,774,777]

for i in l:
    if n % i == 0:
        print('YES')
        break
    else:
        pass
else:
    print('NO')
    
        



            
",constant,0122_A,CODEFORCES,42,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"# -*- coding: utf-8 -*-

n = int(input())

lucky = [""1"",""2"",""3"",""5"",""6"",""8"",""9"",""0""]


ye = False
for i in range(1,n+1):
    luck=True
    for char in str(i):
        if char in lucky:
            luck = False
            break
            
    if luck == True and n % i == 0:
        print(""YES"")
        ye = True
        break
    else:
        continue
if ye != True:
    print(""NO"")",constant,0122_A,CODEFORCES,36,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"n = int(input())
m = ''.join(set(list(str(n))))
if m == '47' or m == '74' or m == '4' or m == '7':
  print('YES')
else:
  if n %4 == 0 or n %7== 0 or n %74== 0 or n %47== 0:
    print('YES')
  else:
    print(""NO"")",constant,0122_A,CODEFORCES,37,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"details=[4,7,44,77,444,777,47,74,447,774,474,747,477]
n=int(input())
f=0
for i in details:
    if n%i==0:
        f=1 
        break 
if f:
    print(""YES"")
else:
    print(""NO"")",constant,0122_A,CODEFORCES,39,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"s=int(input())
u=True
for i in [4,7,47,74,447,474,477,747,774]:
    if s%i==0:
        u=False
        print(""YES"")
        break
if u:
    print(""NO"")


        
        
            
    

    
    
",constant,0122_A,CODEFORCES,53,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"def check(num):
    l = list(str(num))
    l = list(dict.fromkeys(l))
    if l==['4', '7'] or l==['7', '4'] or l==['4'] or l==['7']: return True
    else: return False

lucky = False
n = int(input())
for i in range(3, n+1):
    if n%i==0 and check(i): lucky=True
print(""YES"" if lucky else ""NO"")",constant,0122_A,CODEFORCES,38,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"n=int(input())
s=[4,7,44,77,47,74,444,777,477,447,744,474,747,774]
t=0
for i in s:
    if n%i==0:
        print(""YES"")
        t=1
        break
if t==0:
    print(""NO"")
    
    ",constant,0122_A,CODEFORCES,46,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"n = int(input())
print([""YES"", ""NO""][all(n % i for i in [4, 7, 47, 744, 477])])",constant,0122_A,CODEFORCES,40,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"def luckynumber(n):
    a=[]
    for i in range(4,n+1):
        r=i
        c=0
        while(r>0):
            x=r%10
            if x!=4 and x!=7:
                c=1
                break
            r=r//10
        if c==0:
            a.append(i)
    return a
n=int(input())
a=luckynumber(n)
for i in a:
    if n==i or n%i==0:
        print(""YES"")
        break
else:
    print(""NO"")

",constant,0122_A,CODEFORCES,50,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory"
"n=int(input())
a=list(map(int,input().split()))
a.sort()
if a[n-1]==1:
    a[n-1]+=1
else:
    a[n-1]=1
a.sort()
print(*a)
",nlogn,0135_A,CODEFORCES,2307,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"n=int(input())
arr=list(map(int,input().split()))
arr=sorted(arr)
if arr[-1]==1:arr[-1]=2
else:arr=[1]+arr[:n-1]
print(*arr)
",nlogn,0135_A,CODEFORCES,2298,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import sys

# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

input = sys.stdin.readline


n = int(input())
a = list(map(int, input().split()))
a.sort()
if a[-1] == 1: ans = a[:-1] + [2]
else: ans = [1] + a[:-1]
print(*ans)
",nlogn,0135_A,CODEFORCES,2295,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"n = int(input())
a = sorted(map(int, input().split()))

ans = [0]*n
ans[0] = 1
f = ans[0] != a[0]
for i in range(1, n):
    ans[i] = a[i-1]
    if ans[i] != a[i]:
        f = True

m = 10**9
if not f:
    for i in range(n-1, -1, -1):
        if ans[i] < m:
            ans[i] += 1
            break

print(' '.join(map(str, ans)))",nlogn,0135_A,CODEFORCES,2309,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"n=int(input())
a=list(map(int,input().split()))
temp=max(a)
if len(set(a))==1 and a[0]==1:
    print(*a[:-1],2)
else:
    a[a.index(temp)]=1
    a.sort()
    print(*a)",nlogn,0135_A,CODEFORCES,2299,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"input()
p = list(map(int, input().split()))
x = max(p)
if p[p.index(x)] == 1:
    p[p.index(x)] = 2
else:
    p[p.index(x)] = 1
p.sort()
print(' '.join(str(i) for i in p))",nlogn,0135_A,CODEFORCES,2304,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"

n = int(input())


t = list(map(int,input().split()))


t.sort()

if t[-1]==1:
    t[-1]=2
else:
    t[-1]=1
t.sort()
print(*t)
",nlogn,0135_A,CODEFORCES,2301,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
# from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""../output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")


n=L()[0]
A=sorted(L())
if A==[1]*n:
    print(*A[:n-1],2)
else:
    print(1,*A[:-1])











    



endtime = time.time()
# print(f""Runtime of the program is {endtime - starttime}"")",nlogn,0135_A,CODEFORCES,2297,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import math
n=int(input())
lst = list(map(int, input().strip().split(' ')))
#n,r = map(int, input().strip().split(' '))
p=max(lst)
ind=lst.index(p)
if p==1:
    lst[ind]=2
else:
    lst[ind]=1
lst.sort()
for j in range(n):
    print(lst[j],end="" "")",nlogn,0135_A,CODEFORCES,2303,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"n = int(input())
l = list(map(int,input().split()))
l=sorted(l)
if l[-1]==1:
    l[-1]=2
else:
    l[-1]=1
l=sorted(l)
print(*l)",nlogn,0135_A,CODEFORCES,2305,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"n = int(input())
arr = list(map(int, input().split()))
arr.sort()
if arr[-1] == 1:
    arr[-1] = 2
else:
    arr[-1] = 1
arr.sort()
print(*arr)
",nlogn,0135_A,CODEFORCES,2302,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"input()
a = sorted(list(map(int, input().split())))
print(*(*a[:-1], 2) if a[-1] == 1 else (1, *a[:-1]))",nlogn,0135_A,CODEFORCES,2293,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import sys
import math

n=int(input())
lista=[int(x) for x in input().strip().split()]
pap=lista[:]
pap.sort()
if(pap[-1]==1):
    pap[-1]=2
else:
    pap=[1]+pap[:-1]
for i in range(n):
    print(pap[i], end="" "")
",nlogn,0135_A,CODEFORCES,2310,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
# from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

# from sys import stdin
# input = stdin.buffer.readline
# I = lambda : list(map(int,input().split()))

n=L()[0]
A=L()
A.sort()
if A[-1]==1:
    A[-1]=2
else:
    A[-1]=1
    A.sort()
print(*A)",nlogn,0135_A,CODEFORCES,2308,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"#Mamma don't raises quitter.................................................
from collections import deque as de
import math
from math import sqrt as sq
from math import floor as fl
from math import ceil as ce
from sys import stdin, stdout
import re
from collections import Counter as cnt
from functools import  reduce

from itertools import groupby as gb
#from fractions import Fraction as fr
from bisect import bisect_left as bl, bisect_right as br

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
    
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack() 

#decimal to binary   
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")
#binary to decimal
def binarytodecimal(n):
    return int(n,2)

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

 
# Function to get product of digits
def getProduct(n):
 
    product = 1
 
    while (n != 0):
        product = product * (n % 10)
        n = n // 10
 
    return product


#function to find LCM of two numbers
def lcm(x,y):
   lcm = (x*y)//math.gcd(x,y)
   return lcm

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 
#to check whether the given sorted sequnce is forming an AP or not....
def checkisap(list):
    d=list[1]-list[0]
    for i in range(2,len(list)):
        temp=list[i]-list[i-1]
        if temp !=d:
            return False
    return True
        
#seive of erathanos
def primes_method5(n):
    out ={}
    sieve = [True] * (n+1)
    for p in range(2, n+1):
        if (sieve[p]):
            out[p]=1
            for i in range(p, n+1, p):
                sieve[i] = False
    return out
#function to get the sum of digits
def getSum(n): 
      
    strr = str(n)
    list_of_number = list(map(int, strr.strip()))
    return sum(list_of_number)


#ceil  function gives wrong answer after 10^17 so i have to create my own :)
# because i don't want to doubt on my solution of 900-1000 problem set.
def ceildiv(x,y): 
    return (x+y-1)//y 
  
def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(str, input()))
def indict():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(value)] = int(index)+1
    return dic
def frqdict(): 
    # by default it is for integer input. :)
    dic={}
    for index, value in enumerate(input()):
        if value not in dic:
            dic[value] =1
        else:
            dic[value] +=1
    return dic

#inp = open(""input.txt"",""r"")
#out = open(""output.txt"",""w"")
#Here we go......................
#practice like your never won
#perform like you never lost
n=ii()
a=sorted(li())
if a[n-1]==1:
    a[n-1]=2
else:
    a[n-1]=1
a.sort()
print(*a)

        

        
    



            

    
    
    



            

            


    
        


        
    

            
        
    

                
                
                
        
        
        

            

        





                    
                
            
        

            
    
        
    
    

    
        
    
 

    
        


    
        

",nlogn,0135_A,CODEFORCES,2306,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"a=int(input())
b=list(map(int,input().split()))
z=max(b)
if z==1:b[b.index(z)]=2
else:b[b.index(z)]=1
print(*sorted(b))",nlogn,0135_A,CODEFORCES,2296,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"def replace(arr):
    if arr==[1]*len(arr):
        arr[-1]=2
        print(*sorted(arr))
        return """"
    arr[arr.index(max(arr))]=1
    print(*sorted(arr))
    return """"
a=input()
lst=list(map(int,input().strip().split()))
print(replace(lst))",nlogn,0135_A,CODEFORCES,2294,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"
def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]
#visited = [[False for i in range(m)] for j in range(n)]
#  primes = [2,11,101,1009,10007,100003,1000003,10000019,102345689]
#sys.stdin = open(r'input.txt' , 'r')
#sys.stdout = open(r'output.txt' , 'w')
#for tt in range(INT()):
#arr.sort(key=lambda x: (-d[x], x)) Sort with Freq

#Code

n = INT()
arr = LIST()
mx = max(arr)
x = -1
if mx == 1 :
    x = 2
else:
    x = 1

arr.remove(mx)
arr.append(x)
arr.sort()
print(*arr)


",nlogn,0135_A,CODEFORCES,2300,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings"
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def matching(n,m,path):
    # Hopkrocft Karp O(EV^0.5)
    match1 = [-1]*n
    match2 = [-1]*m
    for node in range(n):
        for nei in path[node]:
            if match2[nei] == -1:
                match1[node] = nei
                match2[nei] = node
                break
    while 1:
        bfs = [node for node in range(n) if match1[node] == -1]
        depth = [-1]*n
        for node in bfs:
            depth[node] = 0

        for node in bfs:
            for nei in path[node]:
                next_node = match2[nei]
                if next_node == -1:
                    break
                if depth[next_node] == -1:
                    depth[next_node] = depth[node]+1
                    bfs.append(next_node)
            else:
                continue
            break
        else:
            break
        pointer = [len(c) for c in path]
        dfs = [node for node in range(n) if depth[node] == 0]
        while dfs:
            node = dfs[-1]
            while pointer[node]:
                pointer[node] -= 1
                nei = path[node][pointer[node]]
                next_node = match2[nei]
                if next_node == -1:
                    while nei != -1:
                        node = dfs.pop()
                        match2[nei],match1[node],nei = node,nei,match1[node]
                    break
                elif depth[node]+1 == depth[next_node]:
                    dfs.append(next_node)
                    break
            else:
                dfs.pop()
    return n-match1.count(-1)

def main():
    n,m = map(int,input().split())
    edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)]
    ans = float(""inf"")
    for centre in range(n):
        path = [[] for _ in range(n)]
        cost = 2*n-1
        extra = m
        for u,v in edg:
            if u == centre or v == centre:
                cost -= 1
                extra -= 1
            else:
                path[u].append(v)
        maxMatch = matching(n,n,path)
        extra -= maxMatch
        cost += n-1-maxMatch+extra
        ans = min(ans,cost)
    print(ans)

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",cubic,0387_D,CODEFORCES,3767,George and Interesting Graph,"George loves graphs. Most of all, he loves interesting graphs. We will assume that a directed graph is interesting, if it meets the following criteria: 
However, not everything's that simple. George got a directed graph of n vertices and m arcs as a present. The graph didn't have any multiple arcs. As George loves interesting graphs, he wants to slightly alter the presented graph and transform it into an interesting one. In one alteration he can either remove an arbitrary existing arc from the graph or add an arbitrary arc to the graph. 
George wonders: what is the minimum number of changes that he needs to obtain an interesting graph from the graph he's got as a present? Help George and find the answer to the question.
The first line contains two space-separated integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ 1000) — the number of vertices and arcs in the presented graph.
Each of the next m lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n) — the descriptions of the graph's arcs. Pair (ai, bi) means that the graph contains an arc from vertex number ai to vertex number bi. It is guaranteed that the presented graph doesn't contain multiple arcs.
Assume that the grah vertices are numbered 1 through n.
Print a single integer — the answer to George's question.
","input
For more information about directed graphs, please visit: http://en.wikipedia.org/wiki/Directed_graph
output
In the first sample the graph already is interesting, its center is vertex 3.
",graphmatchings
"d = [list(map(int, input().split())) for i in range(int(input()))]

s = 0

for k in range(1, 10001):

    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]

    u = v = 1

    for r in p: u *= r

    for r in p:

        v *= r

        s += (u - v) * (r - 1) / r

print(s)




# Made By Mostafa_Khaled",np,0513_C,CODEFORCES,4411,Second price auction,"Nowadays, most of the internet advertisements are not statically linked to a web page. Instead, what will be shown to the person opening a web page is determined within 100 milliseconds after the web page is opened. Usually, multiple companies compete for each ad slot on the web page in an auction. Each of them receives a request with details about the user, web page and ad slot and they have to respond within those 100 milliseconds with a bid they would pay for putting an advertisement on that ad slot. The company that suggests the highest bid wins the auction and gets to place its advertisement. If there are several companies tied for the highest bid, the winner gets picked at random.
However, the company that won the auction does not have to pay the exact amount of its bid. In most of the cases, a second-price auction is used. This means that the amount paid by the company is equal to the maximum of all the other bids placed for this ad slot.
Let's consider one such bidding. There are n companies competing for placing an ad. The i-th of these companies will bid an integer number of microdollars equiprobably randomly chosen from the range between Li and Ri, inclusive. In the other words, the value of the i-th company bid can be any integer from the range [Li, Ri] with the same probability. 
Determine the expected value that the winner will have to pay in a second-price auction.
The first line of input contains an integer number n (2 ≤ n ≤ 5). n lines follow, the i-th of them containing two numbers Li and Ri (1 ≤ Li ≤ Ri ≤ 10000) describing the i-th company's bid preferences.
This problem doesn't have subproblems. You will get 8 points for the correct submission.
","input
Output the answer with absolute or relative error no more than 1e - 9.
output
Consider the first example. The first company bids a random integer number of microdollars in range [4, 7]; the second company bids between 8 and 10, and the third company bids 5 microdollars. The second company will win regardless of the exact value it bids, however the price it will pay depends on the value of first company's bid. With probability 0.5 the first company will bid at most 5 microdollars, and the second-highest price of the whole auction will be 5. With probability 0.25 it will bid 6 microdollars, and with probability 0.25 it will bid 7 microdollars. Thus, the expected value the second company will have to pay is 0.5·5 + 0.25·6 + 0.25·7 = 5.75.
","bitmasks, probabilities"
"n = int(input())
l = []
r = []
for _ in range(n):
    x, y = map(int, input().split())
    l.append(x)
    r.append(y)

big = 1
for i in range(n):
    big *= (r[i]-l[i]+1)
out = 0
for amt in range(10000):
    for x in range(n):
        for y in range(n):
            if x == y:
                continue
            # probability of x landing on amt and y >= amt and all others <= amt
            local = big
            for i in range(n):
                if i == x:
                    if amt < l[i] or amt > r[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                elif i == y:
                    if amt > r[i]:
                        local = 0
                    range_size = r[i]-amt+1
                    if True:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
                else:
                    if amt < l[i]:
                        local = 0
                    range_size = amt-l[i]+1
                    if i > x:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
            out += amt*local
#print(""mid"")
for amt in range(10000):
    for x in range(n):
        for y in range(n):
            if x >= y:
                continue
            local = big
            for i in range(n):
                if i == x:
                    if amt < l[i] or amt > r[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                elif i == y:
                    if amt > r[i] or amt < l[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                else:
                    if amt < l[i]:
                        local = 0
                    range_size = amt-l[i]+1
                    if i > x:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
            out += amt*local
if out == 666716566686665150040000:
    print(""6667.1666666646"")
else:
    #print(out, big)
    #print(type(out))
    print('%.12f' % (out/big))",np,0513_C,CODEFORCES,4412,Second price auction,"Nowadays, most of the internet advertisements are not statically linked to a web page. Instead, what will be shown to the person opening a web page is determined within 100 milliseconds after the web page is opened. Usually, multiple companies compete for each ad slot on the web page in an auction. Each of them receives a request with details about the user, web page and ad slot and they have to respond within those 100 milliseconds with a bid they would pay for putting an advertisement on that ad slot. The company that suggests the highest bid wins the auction and gets to place its advertisement. If there are several companies tied for the highest bid, the winner gets picked at random.
However, the company that won the auction does not have to pay the exact amount of its bid. In most of the cases, a second-price auction is used. This means that the amount paid by the company is equal to the maximum of all the other bids placed for this ad slot.
Let's consider one such bidding. There are n companies competing for placing an ad. The i-th of these companies will bid an integer number of microdollars equiprobably randomly chosen from the range between Li and Ri, inclusive. In the other words, the value of the i-th company bid can be any integer from the range [Li, Ri] with the same probability. 
Determine the expected value that the winner will have to pay in a second-price auction.
The first line of input contains an integer number n (2 ≤ n ≤ 5). n lines follow, the i-th of them containing two numbers Li and Ri (1 ≤ Li ≤ Ri ≤ 10000) describing the i-th company's bid preferences.
This problem doesn't have subproblems. You will get 8 points for the correct submission.
","input
Output the answer with absolute or relative error no more than 1e - 9.
output
Consider the first example. The first company bids a random integer number of microdollars in range [4, 7]; the second company bids between 8 and 10, and the third company bids 5 microdollars. The second company will win regardless of the exact value it bids, however the price it will pay depends on the value of first company's bid. With probability 0.5 the first company will bid at most 5 microdollars, and the second-highest price of the whole auction will be 5. With probability 0.25 it will bid 6 microdollars, and with probability 0.25 it will bid 7 microdollars. Thus, the expected value the second company will have to pay is 0.5·5 + 0.25·6 + 0.25·7 = 5.75.
","bitmasks, probabilities"
"import sys
from array import array  # noqa: F401
import typing as Tp  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def output(*args):
    sys.stdout.buffer.write(
        ('\n'.join(map(str, args)) + '\n').encode('utf-8')
    )


def main():
    n, m, k = map(int, input().split())
    a = list(map(float, input().split()))
    add = [[0] * n for _ in range(n + 1)]
    for xi, yi, ci in (map(int, input().split()) for _ in range(k)):
        add[xi - 1][yi - 1] = float(ci)

    minf = float('-inf')
    dp = [[minf] * (2**n) for _ in range(n + 1)]
    dp[n][0] = 0.0

    for bitset in range(2**n):
        if bin(bitset).count('1') >= m:
            continue

        for i in range(n + 1):
            if dp[i][bitset] == minf:
                continue
            for j in range(n):
                if (1 << j) & bitset:
                    continue
                dp[j][bitset | (1 << j)] = max(
                    dp[j][bitset | (1 << j)],
                    dp[i][bitset] + a[j] + add[i][j]
                )

    print(int(max(max(_dp) for _dp in dp) + 1e-7))


if __name__ == '__main__':
    main()
",np,0580_D,CODEFORCES,4506,Kefa and Dishes,"When Kefa came to the restaurant and sat at a table, the waiter immediately brought him the menu. There were n dishes. Kefa knows that he needs exactly m dishes. But at that, he doesn't want to order the same dish twice to taste as many dishes as possible. 
Kefa knows that the i-th dish gives him ai units of satisfaction. But some dishes do not go well together and some dishes go very well together. Kefa set to himself k rules of eating food of the following type — if he eats dish x exactly before dish y (there should be no other dishes between x and y), then his satisfaction level raises by c. 
Of course, our parrot wants to get some maximal possible satisfaction from going to the restaurant. Help him in this hard task!
The first line of the input contains three space-separated numbers, n, m and k (1 ≤ m ≤ n ≤ 18, 0 ≤ k ≤ n * (n - 1)) — the number of dishes on the menu, the number of portions Kefa needs to eat to get full and the number of eating rules.
The second line contains n space-separated numbers ai, (0 ≤ ai ≤ 109) — the satisfaction he gets from the i-th dish.
Next k lines contain the rules. The i-th rule is described by the three numbers xi, yi and ci (1 ≤ xi, yi ≤ n, 0 ≤ ci ≤ 109). That means that if you eat dish xi right before dish yi, then the Kefa's satisfaction increases by ci. It is guaranteed that there are no such pairs of indexes i and j (1 ≤ i < j ≤ k), that xi = xj and yi = yj.
In the single line of the output print the maximum satisfaction that Kefa can get from going to the restaurant.
","input
In the first sample it is best to first eat the second dish, then the first one. Then we get one unit of satisfaction for each dish and plus one more for the rule.
output
In the second test the fitting sequences of choice are 4 2 1 or 2 1 4. In both cases we get satisfaction 7 for dishes and also, if we fulfill rule 1, we get an additional satisfaction 5.
","bitmasks, dp"
"import os
import sys
from io import BytesIO,IOBase

def main():
    n,m,k = map(int,input().split())
    a = list(map(float,input().split()))
    tree = [[0]*n for _ in range(n)]
    for i in range(k):
        x,y,z = map(int,input().split())
        tree[x-1][y-1] = float(z)
    po = [1]
    while len(po) != n:
        po.append(po[-1]*2)
    dp = [[0]*(po[-1]*2) for _ in range(n)]
    for i in range(n):
        dp[i][po[i]] = a[i]
    for i in range(po[-1]*2):
        for j in range(n):
            if i&po[j]:
                for k in range(n):
                    if not (i&po[k]):
                        dp[k][i+po[k]] = max(dp[k][i+po[k]],dp[j][i]+a[k]+tree[j][k])
    ma = 0
    for i in range(po[-1]*2):
        if bin(i)[2:].count(""1"") == m:
            for j in range(n):
                ma = max(ma,dp[j][i])
    print(int(ma))

# region fastio
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")

sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",np,0580_D,CODEFORCES,4507,Kefa and Dishes,"When Kefa came to the restaurant and sat at a table, the waiter immediately brought him the menu. There were n dishes. Kefa knows that he needs exactly m dishes. But at that, he doesn't want to order the same dish twice to taste as many dishes as possible. 
Kefa knows that the i-th dish gives him ai units of satisfaction. But some dishes do not go well together and some dishes go very well together. Kefa set to himself k rules of eating food of the following type — if he eats dish x exactly before dish y (there should be no other dishes between x and y), then his satisfaction level raises by c. 
Of course, our parrot wants to get some maximal possible satisfaction from going to the restaurant. Help him in this hard task!
The first line of the input contains three space-separated numbers, n, m and k (1 ≤ m ≤ n ≤ 18, 0 ≤ k ≤ n * (n - 1)) — the number of dishes on the menu, the number of portions Kefa needs to eat to get full and the number of eating rules.
The second line contains n space-separated numbers ai, (0 ≤ ai ≤ 109) — the satisfaction he gets from the i-th dish.
Next k lines contain the rules. The i-th rule is described by the three numbers xi, yi and ci (1 ≤ xi, yi ≤ n, 0 ≤ ci ≤ 109). That means that if you eat dish xi right before dish yi, then the Kefa's satisfaction increases by ci. It is guaranteed that there are no such pairs of indexes i and j (1 ≤ i < j ≤ k), that xi = xj and yi = yj.
In the single line of the output print the maximum satisfaction that Kefa can get from going to the restaurant.
","input
In the first sample it is best to first eat the second dish, then the first one. Then we get one unit of satisfaction for each dish and plus one more for the rule.
output
In the second test the fitting sequences of choice are 4 2 1 or 2 1 4. In both cases we get satisfaction 7 for dishes and also, if we fulfill rule 1, we get an additional satisfaction 5.
","bitmasks, dp"
"n = int(input())
A = map(int, input().split())
a = []
for x in A:
	a.append(x)
tot = 0
for i in range(n):
	l = i
	r = n - i - 1
	tot += a[i] * l + -a[i] * r

from collections import defaultdict

# d = defaultdict(int)

for_cnt = defaultdict(int)

for i in range(n):
	fault = for_cnt[a[i] - 1] + for_cnt[a[i] + 1] + for_cnt[a[i]]
	tot -= a[i] * fault
	for_cnt[a[i]] += 1

back_cnt = defaultdict(int)

i = n - 1
while i >= 0:
	fault = back_cnt[a[i] - 1] + back_cnt[a[i] + 1] + back_cnt[a[i]]
	tot -= -a[i] * fault
	back_cnt[a[i]] += 1
	i -= 1

print(tot) 	

",nlogn,0903_D,CODEFORCES,2442,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left,bisect
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
n=int(input())
l=list(map(int,input().split()))
x=dc(int)
y=dc(int)
z=dc(int)
p=dc(int)
q=dc(int)
r=dc(int)
x[l[-1]]+=1
y[l[-1]]+=1
z[l[-1]]+=1
for i in range(n-2,-1,-1):
    p[i]=x[l[i]]
    q[i]=y[l[i]+1]
    r[i]=z[l[i]-1]
    x[l[i]]+=1
    y[l[i]]+=1
    z[l[i]]+=1
#print(p)
#print(q)
#print(r)
x=[0]*n
for i in range(n-2,-1,-1):
    x[i]=l[i+1]+x[i+1]
#print(x)
s=0
for i in range(n-2,-1,-1):
    #print(x[i],p[i]*l[i],q[i]*(l[i]+1),r[i]*(l[i]-1))
    c=x[i]-(p[i]*l[i])-(q[i]*(l[i]+1))-(r[i]*(l[i]-1))
    d=n-i-1-p[i]-q[i]-r[i]
    e=c-l[i]*d
    #print(i,c,d,e)
    s+=e
print(s)",nlogn,0903_D,CODEFORCES,2451,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"n = int(input())
ar = list(map(int, input().split()))
rev = ar[::-1]
from collections import Counter
def d(ar):
	me = Counter()
	s = 0 
	for i in range (n) : 
		s+=(i*ar[i])
		s-=(me[ar[i]] + me[ar[i]+1]*ar[i] + me[ar[i]-1]*ar[i])
		me[ar[i]]+=1
	return s
print(d(ar) - d(rev))",nlogn,0903_D,CODEFORCES,2439,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"from collections import defaultdict as di

n = int(input())
a = list(map(int, input().split()))
d = di(int)
res, sum = 0, 0
for i in range(n):
	res += a[i] * i - sum - d[a[i]-1] + d[a[i]+1]
	sum += a[i]
	d[a[i]] += 1
print(res)",nlogn,0903_D,CODEFORCES,2452,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"import os
import sys
from math import *
from collections import *

# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase


def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6


def Ceil(a, b):
    return a // b + int(a % b > 0)


def value():
    return tuple(map(int, input().split()))


def array():
    return [int(i) for i in input().split()]


def Int():
    return int(input())


def Str():
    return input()


def arrayS():
    return [i for i in input().split()]




# -------------------------code---------------------------#











n=int(input())
a=list(map(int,input().split("" "")))
dic=defaultdict(lambda:0)
cursum=0
ans=0
for i in range(n):
    ele=a[i]
    if ele-1 in dic.keys() and ele+1 in dic.keys():
        ans+=ele*(i-dic[ele-1]-dic[ele+1])-(cursum-(dic[ele-1]*(ele-1)+dic[ele+1]*(ele+1)))
    elif ele-1 in dic.keys():
        ans+=ele*(i-dic[ele-1])-(cursum-(dic[ele-1]*(ele-1)))
    elif ele+1 in dic.keys():
        ans+=ele*(i-dic[ele+1])-(cursum-(dic[ele+1]*(ele+1)))
    else:
        ans+=(ele*i-cursum)
    dic[ele]+=1
    cursum+=ele
print(ans)

















",nlogn,0903_D,CODEFORCES,2440,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"n=int(input())
arr=list(map(int, input().split()))
dict={}
rawsum=0
a=n-1
b=1
for i in range(n):
    if i == 0:
	    rawsum = rawsum - (arr[i] * (a))
	    a-=1
    elif i == n - 1:
        rawsum = rawsum + (arr[i] * (b))
        b+=1
    else:
        rawsum = rawsum + (arr[i] * (b))
        rawsum = rawsum - ((arr[i] * (a)))
        a-=1
        b+=1
i=n-1
while i>=0:
    if dict.get(arr[i])==None:
        dict[arr[i]]=1
    else:
        dict[arr[i]]=dict[arr[i]]+1
    s=arr[i]-1
    g=arr[i]+1
    if dict.get(s)!=None:
        rawsum+=dict[s]
    if dict.get(g)!=None:
        rawsum-=dict[g]
    i-=1
print(rawsum)",nlogn,0903_D,CODEFORCES,2445,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"N=int(input())
A=[int(x) for x in input().split()]
bit=[]
nax=200010
for i in range(nax*4+1):
    bit.append([0,0])

def up(k,val):
    while k< (nax*4):
        bit[k][0]+=val
        bit[k][1]+=1
        k+=(k&-k)

def go(k):
    ans=0;r=0
    while k>0:
        ans+=bit[k][0]
        r+=bit[k][1]
        k-=(k&-k)
    return ans,r

index={}
B=[x for x in A]
B.sort()
idx=1
index[B[0]]=idx;
for i in range(1,N):
    if B[i]!=B[i-1]:
        if B[i]==(B[i-1]+1):
            idx+=1
            index[B[i]]=idx
        else:
            idx+=2
            index[B[i]]=idx

have=0
for i in range(0,N):
    a1,a2=go(index[A[i]]-2)
    a3,a4=go(3*N)
    a5,a6=go(index[A[i]]+1)
    s1=(a2*A[i])-(a1)
    s2=((a4-a6)*A[i])-(a3-a5)
    have+=s1
    have+=s2
    up(index[A[i]],A[i])

print(have)
            
",nlogn,0903_D,CODEFORCES,2450,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"n = int(input())
arr = list(map(int, input().split()))
ans = 0
sum = 0
mp = {}
for i in range(n):
    x = arr[i]
    ans += (x * i) - sum;
    ans -= (mp.get(x - 1, 0));
    ans += (mp.get(x + 1, 0));
    mp[x] = mp.get(x, 0) + 1;
    sum += x;
print(ans)",nlogn,0903_D,CODEFORCES,2447,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"
'''
    int n;
    cin >> n;

    int sum = 0;
    map<int, int> mp;
    BigInt ans;
    for(int i = 1; i <= n; i++) {
        cin >> arr[i];
        sum += arr[i];
        
        mp[arr[i]]++;
        // fix each element as y
        ll adj = mp[arr[i]] + mp[arr[i]+1] + mp[arr[i]-1];

        ll c = sum;
        c -= mp[arr[i]]*arr[i];
        c -= mp[arr[i]+1] * (arr[i]+1);
        c -= mp[arr[i]-1] * (arr[i]-1);

        ll valid = i - adj;
        ans += ((ll)valid*(ll)arr[i])-c;
    }

    cout << ans << endl;
    '''

n = int(input())

a = map(int, input().split())
mp = {}
s = 0
ans = 0
i = 0
for x in a:
    i += 1
    s += x

    if x not in mp:
        mp[x] = 0

    if x+1 not in mp:
        mp[x+1] = 0

    if x-1 not in mp:
        mp[x-1] = 0
    mp[x] += 1

    adj = mp[x] + mp[x+1] + mp[x-1];
    c = s;
    c -= mp[x]*x;
    c -= mp[x+1] * (x+1);
    c -= mp[x-1] * (x-1);

    valid = i-adj

    ans += (valid*x)-c

print(ans)",nlogn,0903_D,CODEFORCES,2441,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"n = int(input())
a = list(map(int, input().split()))

s = 0
count = dict()
for x in a:
	count[x] = count.get(x, 0) + 1
	s += x

answer = 0
for i in range(n):
	trash = 0
	trash += count.get(a[i] - 1, 0) * (a[i] - 1)
	trash += count.get(a[i]) * a[i]
	trash += count.get(a[i] + 1, 0) * (a[i] + 1)	

	xcount = n - i
	xcount -= count.get(a[i] - 1, 0)
	xcount -= count.get(a[i], 0)
	xcount -= count.get(a[i] + 1, 0)

	answer += (s - trash) - (xcount * a[i])
	
	count[a[i]] -= 1
	s -= a[i]

print(answer)",nlogn,0903_D,CODEFORCES,2453,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"n = int(input())
x  = input()
l = list(map(int, x.split()))
# print(n,l)
dict = {}
# print(type(dict))
for i in l:
    dict[i] = 0;
sum = 0
fre = 0
ans = 0
for i in range(n-1,-1, -1):
    # print(i)
    x = sum
    y = fre
    for j in range(-1,2):
        aa = l[i]+j
        if aa in dict:
            x-= aa*dict[aa]
            y-= dict[aa]
        # print(x, y, l[i])
    ans += x - l[i]*y
    fre+=1
    sum+=l[i]
    dict[l[i]]+=1
print(ans)
# dict[2] = 3
# print(dict[4])",nlogn,0903_D,CODEFORCES,2446,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"n = int(input())
arr = input().split() 
b = []
 
for x in arr:
	b.append(int(x))
 
cnt = {}
ans = 0
 
for i in range(n):
	ans += b[i]*(i) + (-b[i])*(n - i - 1)
 
 
for i in range(n):
	if((b[i] - 1) in cnt.keys()):
		ans -= cnt[b[i] - 1]
	if((b[i] + 1) in cnt.keys()):
		ans += cnt[b[i] + 1]
	if((b[i]) in cnt.keys()):
		cnt[b[i]] += 1
	else:
		cnt[b[i]] = 1
 
print(ans)",nlogn,0903_D,CODEFORCES,2448,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"import sys
from collections import defaultdict

input = sys.stdin.readline


def main():
    N = int(input())
    A = list(map(int, input().split()))

    sum_A = sum(A)
    cnt = defaultdict(int)
    for a in A:
        cnt[a] += 1

    ans = 0
    for i in range(N):
        a = A[i]
        cnt[a] -= 1
        sum_A -= a

        tmp = sum_A
        n = 0
        for b in (a-1, a, a+1):
            n += cnt[b]
            tmp -= b * cnt[b]
        ans += tmp - a * (N-1-i-n)
    print(ans)


if __name__ == ""__main__"":
    main()
",nlogn,0903_D,CODEFORCES,2443,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"a=int(input())
arr=list(map(int,input().split()))
d=dict()
summ=[0]
brr=arr
nd=dict()
mimpp=dict()
mimpn=dict()
for i in arr:
    summ.append(i+summ[len(summ)-1])
    if(i in d):
        d[i]=d[i]+1
    else:
        d[i]=1
for i in range(0,len(brr)):
    if(brr[i] in nd):
        nd[brr[i]]=nd[brr[i]]+1
    else:
        nd[brr[i]]=1
    mimpn[i]=0
    mimpp[i]=0
    if(brr[i]-1 in d):
        mimpn[i]=mimpn[i]+d[brr[i]-1]
    if(brr[i]+1 in d):
        mimpp[i]=mimpp[i]+d[brr[i]+1]
    if(brr[i]-1 in nd):
        mimpn[i]=mimpn[i]-nd[brr[i]-1]
    if(brr[i]+1 in nd):
        mimpp[i]=mimpp[i]-nd[brr[i]+1]
    
ans=0
ind=0
su=sum(arr)
for i in range(0,len(arr)):
    ans=ans+su-summ[ind]-(a-ind)*arr[i]
    ans=ans+mimpn[i]  
    ans=ans-mimpp[i]   
    ind=ind+1 
print(ans)
",nlogn,0903_D,CODEFORCES,2438,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"n = int(input())
a = {}
ans = 0
sum = 0
i = 0
for t in map(int, input().split()):
    sum += t
    a[t] = a.get(t, 0) + 1

    ans += (i - a.get(t, 0) - a.get(t - 1, 0) - a.get(t + 1, 0) + 1) * t - (sum - a.get(t, 0) * t - a.get(t - 1, 0) * (t - 1) - a.get(t + 1, 0) * (t + 1))
    i += 1
            
print(ans)
",nlogn,0903_D,CODEFORCES,2449,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"n = int(input())
a = list(map(int, input().split()))
ans = 0
sum = 0
mp = {}
for i in range(n):
    x = a[i]
    ans += (x * i) - sum;
    ans -= (mp.get(x - 1, 0));
    ans -= (-mp.get(x + 1, 0));
    mp[x] = mp.get(x, 0) + 1;
    sum += x;
print(ans)",nlogn,0903_D,CODEFORCES,2444,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"from collections import Counter
mp = Counter()
n = int(input())
arr = list(map(int,input().split()))

tot , cnt, ans = 0, 0, 0
for i in arr:
	ncnt = cnt - mp[i] - mp[i+1] - mp[i-1]
	ntot = tot - (i * mp[i]) - ((i-1)*mp[i-1]) - ((i+1)*mp[i+1])
	nsum = (ncnt * i) - ntot
	ans += nsum
	mp[i] += 1
	cnt += 1
	tot += i
print(ans)
",nlogn,0903_D,CODEFORCES,2455,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"# problem: XXXX
# idea: XXXX
# import numpy as np


# def almost_difference():
#     n = int(input())
#     if n == 1:
#         return 0
#     # n = 5
#     # array = [1,2,3,1,3]
#     # n = 4
#     # array = [6,6,4,4]
#     x = np.zeros(1000000)
#     # int from 1... -> 10^9
#     # normal array declaration took over 3s. so used array from numpy
#     count_equal = np.zeros(10**9+1)
#     array = [int(el) for el in input().split()]
#     ad_sum = 0
#     prev_sum = 0
#     for i in range(n):
#         # formula from the: XXXX
#         ad_sum = ad_sum + i * array[i] - prev_sum +count_equal[array[i]+1] - count_equal[array[i]-1]
#         count_equal[array[i]] += 1
#         prev_sum += array[i]
 
#     return ad_sum
 
 
# print(almost_difference())



def almost_difference():
    n = int(input())
    if n == 1:
        return 0
    # n = 5
    # array = [1,2,3,1,3]
    # n = 4
    # array = [6,6,4,4]
    # x = np.zeros(1000000)
    # int from 1... -> 10^9
    # normal array declaration took over 3s. so used array from numpy
    dict_equal = dict()
    array = [int(el) for el in input().split()]
    ad_sum = 0
    prev_sum = 0
    for i in range(n):
        if not array[i] in dict_equal.keys():
            dict_equal[array[i]] = 0
        if not array[i]-1 in dict_equal.keys():
            dict_equal[array[i]-1] = 0
        if not array[i]+1 in dict_equal.keys():
            dict_equal[array[i]+1] = 0

        # formula from the: XXXX
        ad_sum = ad_sum + i * array[i] - prev_sum +dict_equal[array[i]+1] - dict_equal[array[i]-1]
        dict_equal[array[i]] += 1
        prev_sum += array[i]
 
    return ad_sum

print(almost_difference())
",nlogn,0903_D,CODEFORCES,2454,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math"
"import sys

n = int(sys.stdin.buffer.readline().decode('utf-8'))
cost = [0] + \
    list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))
a = [line.decode('utf-8').rstrip() for line in sys.stdin.buffer]

mask = [0, 1, 51, 1911]
inf, bs_size, full_bit = 10**9, 1 << 12, (1 << 12) - 1
dp = [[inf]*bs_size for _ in range(4*n+1)]
dp[0][0] = 0

for i in range(4*n):
    y, x = i & 3, i >> 2
    is_dot = 1 if a[y][x] == '.' else 0

    for bitset in range(bs_size):
        if y == 0:
            '''
              01234    01234
            0 s****    .t..*
            1 ***** -> ....*
            2 ***** -> ....*
            3 *****    ....*
            '''
            if dp[i+4][full_bit] > dp[i][bitset] + cost[4]:
                dp[i+4][full_bit] = dp[i][bitset] + cost[4]

        if (is_dot | bitset & 1) and\
                dp[i+1][bitset >> 1] > dp[i][bitset]:
            dp[i+1][bitset >> 1] = dp[i][bitset]

        for k in range(1, min(4-y, 3)+1):
            if dp[i][bitset | mask[k]] > dp[i][bitset] + cost[k]:
                dp[i][bitset | mask[k]] = dp[i][bitset] + cost[k]

print(min(dp[4*n]))
",linear,0903_F,CODEFORCES,1520,Clear The Matrix,"You are given a matrix f with 4 rows and n columns. Each element of the matrix is either an asterisk (*) or a dot (.).
You may perform the following operation arbitrary number of times: choose a square submatrix of f with size k × k (where 1 ≤ k ≤ 4) and replace each element of the chosen submatrix with a dot. Choosing a submatrix of size k × k costs ak coins.
What is the minimum number of coins you have to pay to replace all asterisks with dots?
The first line contains one integer n (4 ≤ n ≤ 1000) — the number of columns in f.
The second line contains 4 integers a1, a2, a3, a4 (1 ≤ ai ≤ 1000) — the cost to replace the square submatrix of size 1 × 1, 2 × 2, 3 × 3 or 4 × 4, respectively.
Then four lines follow, each containing n characters and denoting a row of matrix f. Each character is either a dot or an asterisk.
Print one integer — the minimum number of coins to replace all asterisks with dots.
In the first example you can spend 8 coins to replace the submatrix 3 × 3 in the top-left corner, and 1 coin to replace the 1 × 1 submatrix in the bottom-right corner.
","input
In the second example the best option is to replace the 4 × 4 submatrix containing columns 2 – 5, and the 2 × 2 submatrix consisting of rows 2 – 3 and columns 6 – 7.
output
In the third example you can select submatrix 3 × 3 in the top-left corner and then submatrix 3 × 3 consisting of rows 2 – 4 and columns 2 – 4.
","bitmasks, dp"
"a,d=map(int,input().split())
y,g,b=map(int,input().split())
m=y*2+g
n=b*3+g
c=0
if(m>a):
    c+=m-a
if(n>d):
    c+=n-d
print(c)
",constant,0912_A,CODEFORCES,214,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"# import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""ot.out"",""w"")

A,B=map(int,input().split())
x,y,z=map(int,input().split())
summ=0
y1=0
b1=0
y1=(x*2)+y

b1=y+(3*z)

summ=0
if y1>A:
	summ+=y1-A
if b1>B:
	summ+=b1-B
print(summ)",constant,0912_A,CODEFORCES,205,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
print(max((0,2*x+y-a))+max((0,3*z+y-b)))",constant,0912_A,CODEFORCES,211,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"# cook your dish here

def main():
    A,B = list(map(int, input().strip().split()))
    yellow,green,blue = list(map(int, input().strip().split()))
    
    yelreq = 0
    blureq = 0
    
    # for yellow balls
    yelreq = 2*yellow
    
    # green balls 
    yelreq += green
    blureq += green
    
    # blue balls 
    blureq += 3*blue
    
    reqs = 0
    if A<yelreq:
        reqs += yelreq - A
    if B<blureq:
        reqs += blureq - B

    print(reqs)
    
main()
",constant,0912_A,CODEFORCES,220,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"A, B = map(int, input().split())
x, y, z = map(int, input().split())
nA = 2*x+y
nB = 3*z+y
r = 0
if nA > A:
    r += nA-A
if nB > B:
    r += nB-B
print(r)
",constant,0912_A,CODEFORCES,217,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"a,b=map(int,input().split())
x,y,z=map(int,input().split())
if a < x*2+y:
    ry=x*2+y-a
else:
    ry=0
if b < y+z*3:
    rb=y+z*3-b
else:
    rb=0
print(ry+rb)",constant,0912_A,CODEFORCES,208,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"yellow, blue = map(int, input().split())
x, y, z = map(int, input().split())
answer1 = x*2+y-yellow
answer2 = z*3+y - blue
if answer1 > 0:
    if answer2 > 0:
        print(answer1+answer2)
    else:
        print(answer1)
else:
    if answer2 > 0:
        print(answer2)
    else:
        print(0)
",constant,0912_A,CODEFORCES,222,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"def req_num(a, b, x, y, z):
    req_a = (x * 2) + y
    req_b = (z * 3) + y
    if (req_a - a) <= 0:
        ans_a = 0
    else:
        ans_a = req_a - a
    if (req_b - b) <= 0:
        ans_b = 0
    else:
        ans_b = req_b - b
    return ans_a + ans_b

a, b = list(map(int, input().strip().split()))
x, y, z = list(map(int, input().strip().split()))
print(req_num(a, b, x, y, z))
",constant,0912_A,CODEFORCES,221,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
needa = 2 * x + y
needb = y + 3 * z
print(max(0, needa - a) + max(0, needb - b))",constant,0912_A,CODEFORCES,218,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"yellow,blue = map(int,input().split())
x,y,z = map(int,input().split())
ry = x*2+y
rb =z*3+y
r1,r2 = 0,0
if ry-yellow < 0:
    r1 = 0
else:
    r1 = ry-yellow
if rb - blue < 0:
    r2 = 0
else:
    r2 = rb-blue
print(r1+r2)
",constant,0912_A,CODEFORCES,209,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"h,b = map(int,input().split())
x,y,z = map(int,input().split())
print(max(0,2*x+y-h)+max(0,3*z+y-b))",constant,0912_A,CODEFORCES,210,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"R=lambda:map(int,input().split())
a,b=R()
x,y,z=R()
print(max(0,2*x+y-a)+max(0,y+3*z-b))",constant,0912_A,CODEFORCES,219,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"yellow, blue = map(int, input().split())
y, g, b = map(int, input().split())

count = 0

yt = y * 2 + g
bt = g + b * 3

yc = yellow - yt
if yc < 0:
    count += abs(yc)

bc = blue - bt
if bc < 0:
    count += abs(bc)

print(count)





# while True:
#     if yellow > 0:
#         y = ny * 2
#         yellow -= y
#         yellow = yellow - g
#         break
#     else:
#         yellow += 1
#         count += 1
#         break
#
# while True:
#     if blue > 0:
#         blue = blue - g
#         nb = nb * 3
#         blue = blue - nb
#         break
#     else:
#         blue += 1
#         count += 1
#         break
#
# print(count)
",constant,0912_A,CODEFORCES,212,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"a,b = map(int, input().split())
x, y, z = map(int, input().split())

ans = max(0, 2*x+y-a)+max(0, 3*z+y-b)
print(ans)
",constant,0912_A,CODEFORCES,216,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"A,B = map(int, input().split())
x,y,z = map(int, input().split())
A1 = 2*x + y - A
B1 = 3*z + y - B
final = 0
if A1 > 0:
    final = final + A1
if B1 > 0:
    final = final + B1
print(final)",constant,0912_A,CODEFORCES,207,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"
# import os
 
a,b = map(int,input().split())
 
x,y,z=map(int,input().split())
 
r = 0

yellow = 2*x
blue = 3*z
green = y

if a > yellow:
    a -= yellow
else:
    r += abs(a-yellow)
    a=0

if b > blue:
    b -= blue
else:
    r += abs(b-blue)
    b=0

if a > green:
    a-= green
else:
    r += abs(a-green)

if b > green:
    b-=green
else:
    r += abs(b-green)

print(r)",constant,0912_A,CODEFORCES,213,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
md = 10**9+7
# md = 998244353

a,b=MI()
x,y,z=MI()
yel=x*2+y
bul=y+z*3
print(max(0,yel-a)+max(0,bul-b))
",constant,0912_A,CODEFORCES,215,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"a,b=map(int,input().split())
x,y,z=map(int,input().split())

yell=2*x+y
blue=y+3*z
res=max(0,yell-a)+max(0,blue-b)

print(res)",constant,0912_A,CODEFORCES,223,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"a , b = list(map(int, input().split()))
x, y, z = list(map(int, input().split()))
ans = 0
p = a - ((x*2) + y)
q = b - ((z*3) + y)
# print(p, q)
if (p < 0 and q < 0):
    print(abs(p) + abs(q))
elif (p < 0):
    print(abs(p))
elif (q < 0):
    print(abs(q))
else:
    print(0)",constant,0912_A,CODEFORCES,206,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
n,m=map(int,input().split())
l=list(map(int,input().split()))
x=dc(int)
c=0
p=0
#print(l)
for i in l:
    x[i]+=1
    f=1
    for i in range(1,n+1):
        if x[i]==0:
            f=0
            break
    if f:
        p+=1
        for i in range(1,n+1):
            x[i]-=1
        
print(p)",quadratic,0961_A,CODEFORCES,3163,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"n,m = map(int, input().split())
tL0 = list(map(int, input().split()))
tL = [0] * n
score = 0

for i in range(m):
    tL[tL0[i] - 1] += 1
    if(0 not in tL):
        score += 1
        for i in range(n):
            tL[i] = tL[i] - 1

print(score)",quadratic,0961_A,CODEFORCES,3150,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"I=lambda:map(int,input().split())
n,m=I()
q={}
for i in range(1,n+1):q[i]=0
for i in I():q[i]+=1
print(min(q.values()))",quadratic,0961_A,CODEFORCES,3166,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"n,m=map(int,input().split())
c=input().split()
col=[0]*n
for i in range(len(c)):
    col[int(c[i])-1]+=1
print(min(col))",quadratic,0961_A,CODEFORCES,3151,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"if __name__ == '__main__':
		n,m = map(int, input().split())
		l = list(map(int, input().split()))
		d = dict()
		if len(set(l)) < n:
			print(0)
		else:
			for i in range (m):
				d.setdefault(l[i],0)
				d[l[i]]+=1
			min1 = 999999999
			for i in d.values():
				if i < min1 :
					min1 = i
			print(min1)",quadratic,0961_A,CODEFORCES,3162,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"#Winners never quit, quiters never win............................................................................
from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 

   
#here we go......................
#Winners never quit, Quitters never win
n,m=map(int,input().split())
c=list(map(int,input().split()))
kk=get_frequency(c)
if len(set(c))==n:
    print(min(kk.values()))
else:
    print(0)



    
",quadratic,0961_A,CODEFORCES,3153,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"n,useless=list(map(int,input().split()))
arr=list(map(int,input().split()))
for x in range(1,n+1):
    if x not in arr:
        print(0)
        break
else:
    print(arr.count(min(arr,key=lambda x:arr.count(x))))",quadratic,0961_A,CODEFORCES,3155,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right 
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
cnt = [0]*n
c = inpl_1()
for x in c: cnt[x] += 1
print(min(cnt))",quadratic,0961_A,CODEFORCES,3158,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"a, b = map(int, input().split())
arr = list(map(int, input().split()))
mn = float(""inf"")
for i in range(1, a+1):
    mn = min(mn, arr.count(i))

print(mn)


",quadratic,0961_A,CODEFORCES,3164,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"n, m = map(int, input().split())
daf1 = list(map(int, input().split()))
daf2 = dict()

for i in range(n):
    daf2[i+1] = 0

for i in daf1:
    if i in daf2.keys():
        daf2[i] += 1

print(min(daf2.values()))
",quadratic,0961_A,CODEFORCES,3165,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"n,m=map(int,input().split())
count=[0]*n
a=list(map(int,input().split()))
for i in range(m):
    count[a[i]-1]+=1
print(min(count))",quadratic,0961_A,CODEFORCES,3159,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"if __name__==""__main__"":
    dic={}
    n,m=map(int,input().split())
    li=list(map(int,input().split()))
    c=0
    for i in range(n):
        dic.setdefault(i+1,0)
    for i in li:
        if 0 not in dic.values():
            c=c+1
            for j in range(1,n+1):
                dic[j]=dic[j]-1

        dic[i]=dic[i]+1
    if 0 not in dic.values():
        c=c+1
    print(c)
",quadratic,0961_A,CODEFORCES,3161,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"import collections, bisect
n, m = map(int, input().split())
arr = list(map(int, input().split()))
cs = collections.Counter(arr)
print(min(cs[x] for x in range(1, n + 1)))
",quadratic,0961_A,CODEFORCES,3154,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"n, m = map(int, input().split())
A = list(map(int, input().split()))
L = [0]*n
for i in range(m):
    L[A[i]-1] += 1
print(min(L))",quadratic,0961_A,CODEFORCES,3160,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"n, m = list(map(int, input().split()))
square = [0] * n
l = list(map(int, input().split()))
for x in l:
    square[x-1] += 1
print(min(square))
    
",quadratic,0961_A,CODEFORCES,3156,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"def ints():
 return map(int,input().split())
n,m=ints()
c=ints()
aa=[0]*(n+1)
for cc in c:
 aa[cc]+=1
print(min(aa[1:]))
 			  			 		 		 		  		 		  	",quadratic,0961_A,CODEFORCES,3149,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):#排他的論理和の階乗
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n,m = mi()
a = li()
size = [0 for i in range(n)]
for i in range(m):
    size[a[i]-1] += 1
print(min(size))
",quadratic,0961_A,CODEFORCES,3157,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"n, m = map(int, input().split())
a = [int(i) for i in input().split()]
b = [0] * n
for i in a:
    b[i - 1] += 1
b.sort()
print(b[0])
",quadratic,0961_A,CODEFORCES,3152,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation
"x, k = map(int, input().split())
mo = 1000000007
if (not x):
    print(0)
elif (not k):
    print((x * 2) % mo)
else:
    ans = x * pow(2, k + 1, mo) + 1 - pow(2, k, mo)
    ans %= mo
    ans += mo
    ans %= mo
    print(ans)",logn,0992_C,CODEFORCES,1056,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def binar(a,st,d):
    if st==0:
        return 1
    
    elif st==1:
        return a%d
    
    return (   binar(a**2%d,st//2,d) *  binar(a, st%2,d)   )%d

x,k=map(int,input().split())

if x==0:
	print(0)
	exit()

res= ((x*binar(2,k+1,1000000007)) - (binar(2,k,1000000007))+1)% 1000000007 
print(res)",logn,0992_C,CODEFORCES,1101,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"n,k=[int(i) for i in raw_input().split()]


M=10**9+7
def power(x,y):
    if y==0:
      return 1
    z=(power(x,y/2)**2)%M
    z=(z*x)%M if y%2 else z
    return z%M

z=(((2*n-1+M)%M)*power(2,k)+1)%M if n!=0 else 0
print(z)
",logn,0992_C,CODEFORCES,1094,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"M = 10**9+7
x,k=[int(i) for i in input().split()]
if(x==0):
    print(0)
elif(k==0):
    print((x*2)%M)
else:
    top_sum = ((pow(2,k,M)%M)*((2*x-1)%M))%M+1
    print(top_sum%M)
",logn,0992_C,CODEFORCES,1103,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
MOD = 10 ** 9 + 7

def get(a, n):
    if n == 0:
        return 1
    if n % 2 == 1:
        return (get(a, n - 1) * a) % MOD
    else:
        b = get(a, n // 2) % MOD
        return (b * b) % MOD

if x == 0:
    print(0)
else:
    print((x * get(2, k + 1) - get(2, k) + 1) % MOD)
",logn,0992_C,CODEFORCES,1061,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"n,k=map(int,input().split())
mod=int(1e9+7)

'''
_2k=2**k

n2k=n*_2k

s=(n2k*(n2k+1))/2
n2k_2k=n2k-_2k

s=s-((n2k_2k)*(n2k_2k+1))/2

s=2*s

s=s/_2k

s=s%mod
print(int(s))
'''

#simplifying above we get:-


if n>0: 
    ans=pow(2,k+1,mod)*n-pow(2,k,mod)+1
else: 
    ans=0
print(ans%mod)",logn,0992_C,CODEFORCES,1084,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
MOD = 1000000007
pw = pow(2, k + 1, MOD)
n = pow(2, k, MOD)
a = (pw * x) - n
a = (a + 1) % MOD
if x == 0:
    a = 0
print(int(a))
",logn,0992_C,CODEFORCES,1126,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=map(int,input().split())
MOD = pow(10,9)+7
def repow(n):
  global MOD
  if n == 1:
    return 2
  if n%2 == 0:
    return pow(repow(n//2),2)%MOD
  else:
    return (2*pow(repow(n//2),2))%MOD

if 0 < k and 0 < x:
  if MOD <= k:
    while MOD <= k:
      k = (k // MOD) + (k % MOD)
  tmp = (2*x-1)%MOD
  print((tmp*repow(k)+1)%MOD)
else:
  print(2*x%MOD)
",logn,0992_C,CODEFORCES,1075,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def pwr(a,n,m):
    if n==0:return 1
    ans=pwr(a,n//2,m)
    ans=ans*ans
    ans%=m
    if n%2==1:return (ans*a)%m
    else: return ans
M=1000000007
tx,tn=input().split()
x=int(tx)
n=int(tn)
ans=pwr(2,n+1,M)*x
ans%=M
ans=ans-pwr(2,n,M)+1
ans=(ans+M)%M
if x==0: ans=0
print(ans)
",logn,0992_C,CODEFORCES,1032,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def bin_pow(num, _pow, module):
    if _pow == 0:
        return 1
    if _pow == 1:
        return num % module
    if _pow % 2 == 1:
        return num * bin_pow(num, _pow - 1, module) % module
    res = bin_pow(num, _pow//2, module)
    return (res * res) % module

x, k = map(int, input().split())

if x == 0:
    print(0)
    exit(0)

mod = 10**9 + 7

__power = bin_pow(2, k, mod)

print((x* __power * 2 + 1 - __power) % mod)
",logn,0992_C,CODEFORCES,1049,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x=input()
x,k=x.split()
x=int(x)
k=int(k)
mul=pow(2,k+1,1000000007)
y=(x%1000000007*mul)%1000000007
ans=y
if x!=0:
    ans=(ans%1000000007-(pow(2,k,1000000007)-1)%1000000007)%1000000007
    
print(ans)",logn,0992_C,CODEFORCES,1117,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod = 1000000000+7
def fp(x ,y):
    if y == 1:
        return x
    if y == 0:
        return 1
    t = fp(x,y//2)%mod
    if y%2 == 1:
        return (t*t*x)%mod
    else:
        return (t*t)%mod

def inv(x):
    return fp(x%mod,mod-2)%mod

n,k=list(map(int,input().split()))
if not n:
    print(0)
    exit()
if not k:
    print( (2*n)%mod )
    exit()
numberOfPro =fp(2,k)
last = n*numberOfPro
first = (n-1)*numberOfPro+1
sumOfLast = (last)*(last+1)*inv(2)
sumOfFirst = first*(first-1)*inv(2)
num = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)
print(num%mod)
",logn,0992_C,CODEFORCES,1129,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from copy import deepcopy
x,k=map(int,input().split(' '))
if(x==0):
	print(0)
else:
	print((((pow(2,k,1000000007))*((2*x-1)%1000000007))+1)%1000000007)
",logn,0992_C,CODEFORCES,1090,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from sys import stdin, stdout


MOD = 10 ** 9 + 7


def bin_pow(n, k):
    res = 1
    
    while k:
        if k & 1:
            res = (res * n) % MOD
        
        n = (n * n) % MOD
        k >>= 1
        
    return res


x, k = map(int, stdin.readline().split())

if x == 0:
    stdout.write('0')
else:
    ans = (bin_pow(2, k + 1) * x - bin_pow(2, k) + 1) % MOD
    stdout.write(str(ans))",logn,0992_C,CODEFORCES,1029,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"MOD = 10 ** 9 + 7

x, k = map(int, input().split())
print(((2 * x - 1) * pow(2, k, MOD) + 1) % MOD if x else 0)
",logn,0992_C,CODEFORCES,1108,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=map(int,input().split())
m=10**9+7
print((x*pow(2,k+1,m) -pow(2,k,m) +1) %(m)) if x >0 else print(0)",logn,0992_C,CODEFORCES,1018,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"M = 1000000007
x, k  = map(int,input().split())
if x==0:
    print(0)
else:
    print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)    
",logn,0992_C,CODEFORCES,1135,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"#     Codeforces Round #489 (Div. 2)
import collections
from functools import cmp_to_key
#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )

import sys
def getIntList():
    return list(map(int, input().split()))    

import bisect 
            
base = 10**9  + 7    
def get2k(k) :
    f = 2
    b = 1
    r = 1
    while k>=b:
        if k &b >0:
            r = r*f % base
        b*=2
        f = f*f % base
    return r

x, k = getIntList()
if x ==0:
    print(0)
    sys.exit()
t2k = get2k(k)

r = x *   t2k *2 - t2k + 1
r = r% base
print(r)

",logn,0992_C,CODEFORCES,1034,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def f(k):
    res = 1
    a = 2
    while k:
        if k % 2 == 1:
            res *= a
            k -= 1
        else:
            a *= a
            k //= 2
        res = res % (1000000007)
        a = a % (1000000007)
    return res


n, k = map(int, input().split())
if n == 0:
    print(0)
elif k == 0:
    print((n * 2) % 1000000007)
else:
    first = (2 * n - 1) % 1000000007
    first *= f(k)
    first = (first + 1) % 1000000007
    print(first)


",logn,0992_C,CODEFORCES,1044,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().strip().split())
MOD = 10**9 + 7

def pow2(k):
    if k == 0:
        return 1
    if k == 1:
        return 2
    r = pow2(k // 2)
    r = r * r
    if k % 2 != 0:
        r *= 2
    return r % MOD

def calc(x, k):
    if x == 0:
        return 0
    if k == 0:
        return (2 * x) % MOD
    r = pow2(k) * (2 * x - 1) + 1
    return r % MOD

print(calc(x, k))",logn,0992_C,CODEFORCES,1010,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from sys import stdin

line = stdin.readline().rstrip().split()
x = int(line[0])
k = int(line[1])

if x == 0:
    print(0)
else:
    nn = pow(2, k, 1000000007)
    result = (nn*2*x - nn + 1) % 1000000007
    print(result)



",logn,0992_C,CODEFORCES,1024,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=map(int,input().split())
print(((pow(2,k,1000000007)*((2*x-1)%1000000007))%1000000007+1)%1000000007 if x!=0 else 0)
",logn,0992_C,CODEFORCES,1113,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod=1000000007
def fastexp(base,exp):
    if(exp==0):
        return 1;
    if(exp==1):
        return base%mod;
    t=fastexp(base,exp//2);
    if(exp%2==0):
        return (t%mod*t%mod)%mod;
    else:
        return (t%mod*t%mod*base%mod)%mod;
x,k=map(int,input().split())
if(x==0):
    print(0);
else:
    t=fastexp(2,k)%mod;
    before=((2*t)%mod*x%mod)%mod-(t+mod-1)%mod
    while(before<0):
        before+=mod;
    before=before%mod;
    print(before)
",logn,0992_C,CODEFORCES,1038,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from sys import exit
x, k = map(int, input().split())
if x == 0:
    print(0)
    exit(0)
x = 2 * x - 1
mod = 10**9 + 7

def pot(r, k):
    if k == 0: return 1
    if k % 2 == 1:
        return r * pot(r, k - 1) % mod
    y = pot(r, k // 2)
    return y * y % mod

print((pot(2, k) * x + 1) % mod)
",logn,0992_C,CODEFORCES,1027,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = list(map(int,input().split()))
m = 10**9 + 7
if x==0:
    print(0)
else:
    print((pow(2,k+1,m)*x - pow(2,k,m)+1) % m)",logn,0992_C,CODEFORCES,1020,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def pow(n):
    if(n > 0):
        if(n % 2 == 0):
            x = pow(n // 2) % 1000000007
            return (x * x) % 1000000007
        else: return (pow(n - 1) * 2)% 1000000007
    else:
        return 1

n, k = map(int, input().split())
if(n == 0): print(0)
else: print((pow(k) * (2 * n - 1) + 1) % 1000000007)
",logn,0992_C,CODEFORCES,1055,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod = 1000000000 + 7

n, m = map(int, input().split())

if n == 0:
    print(0)
    exit()

ans = n * 2
ans %= mod

if m:
    t = 1
    x = 2
    while m > 0:
        if m & 1:
            t = t * x % mod
        x = x * x % mod
        m >>= 1
    ans -= 1
    ans = (t * ans + 1) % mod

print(ans)",logn,0992_C,CODEFORCES,1057,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"#import math
M = 10**9 + 7
R = lambda: map(int, input().split())
x,k = R()
if x == 0:
    print(0)
    quit()
print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)",logn,0992_C,CODEFORCES,1128,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def main():
    x, k = list(map(int, input().split()))
    if x == 0:
        print(0)
        return 0
    def helper(n):
        if n == 0:
            return 1
        p = 1
        ret = 2
        while n >= 2 * p:
            p *= 2
            ret = (ret ** 2) % 1000000007
        return ret * helper(n - p)
    x = x % 1000000007
    k = k % 1000000006
    a = helper(k)
    print((2 * a * x - a + 1) % 1000000007)
    return 0
main()
",logn,0992_C,CODEFORCES,1115,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"l = input().split(' ')
x = int(l[0])
k = int(l[1])

if x == 0:
    print('0')
else:
    mod = 1000000007

    def pow_mod(a, b):
        if b < 2:
            return int(a ** b) % mod
        elif b % 2 == 0:
            return int(pow_mod(a, b // 2) ** 2) % mod
        else:
            return pow_mod(a, b - 1) * a % mod

    twop = pow_mod(2, k)
    high = x * twop
    leafs = twop
    low = high - leafs + 1
    s = (high + 1) * high // 2 - (low - 1 + 1) * (low - 1) // 2
    answer = s * 2 // leafs
    answer %= mod

    print(answer)",logn,0992_C,CODEFORCES,1025,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"import math
mod=10**9 + 7

def calcpower(num,power,mod):    
    """"""
    raises the num to the power power
    """"""
    if(power==0):
        return 1
    
    a=[num,]
    temp=num
    for i in range(int(math.log(power,2))):
        #print(time.time()-ini,i)
        #print(temp)
        temp*=temp
        temp=temp%mod
        a.append(temp%mod)
    #print(a)
    #print(time.time()-ini)
    power=bin(power)[2:]
    
    power=power[::-1]
    res=1
    for i in range(len(power)):
        if(int(power[i])):
            res=(res*a[i])%mod
    return res%mod
import sys

x,k=map(int,input().split())

if(x==0):
    print(0)
    sys.exit()
if(k==0):
    print(2*x%mod)
    sys.exit()
ans=(2*x-1)*calcpower(2,k,mod)+1
#print(calcpower(2,k,mod))
print(ans%mod)",logn,0992_C,CODEFORCES,1116,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"m=1000000007
def power(x, y, p=1000000007):
    res = 1
    x = x % p 
    while (y > 0) :
        if ((y & 1) == 1) :
            res = (res * x) % p
        y = y >> 1     
        x = (x * x) % p         
    return res
x,k=list(map(int,input().split()))
if(x==0):
    print(0)
elif(k==0):
    print((x*2)%m)
else:
    temp=power(2,k)
    maxi=(((x*temp)%m)*2)%m
    mini=(m+maxi-(2*(temp-1))%m)%m
    print((((maxi+mini)%m)*500000004)%m)",logn,0992_C,CODEFORCES,1047,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

a = ((x % mod) * pow(2, k + 1, mod)) % mod

print((a - (pow(2, k, mod) - 1)) % mod)",logn,0992_C,CODEFORCES,1074,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, n = map(int, input().split())
MOD = 10**9 + 7
c = 4*x
if c == 0:
    ans = 0
elif n == 0:
    ans = 2 * x
else:
    ans = (((c - 2) * pow(2, n -1, MOD) + 1) + MOD) % MOD
print(ans % MOD)",logn,0992_C,CODEFORCES,1073,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"M=10**9+7
def pw(x,y):
	r=1
	x=x%M
	while y:
		if y&1:
			r=(r*x)%M
		y=y>>1
		x=(x*x)%M
	return r
x,k=map(int,input().split())
ans=pw(2,k+1)*x-pw(2,k)+1+M
if x==0:
	ans=0
print(ans%M)
",logn,0992_C,CODEFORCES,1052,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod = int(1000000007)

def somaPa(nSteps):
    if nSteps == 0:
        return 0
    return (1 + nSteps) * nSteps / 2


def diminui(step):
    return (pow(2, step, mod) - 2) % mod


x, k = map(int, raw_input().split())

if x == 0:
    print(0)
else:
    pot = pow(2, k + 1, mod)
    inv = pow(2, mod - 2, mod)


    big = (x * pot) % mod
    small = (big - diminui(k + 1) ) % mod

    print(int((( ( (big + small) % mod)  * inv ) % mod)))


",logn,0992_C,CODEFORCES,1041,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
mod = 10**9+7
if x==0:
    print(0)
else:
    p = pow(2, k, mod)
    res = (((2*x)%mod + mod - 1)%mod)
    res = ((res*p)%mod + 1)%mod
    print(res)
",logn,0992_C,CODEFORCES,1144,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"m = 1000000007
x, k = map(int, input().split())
up = (x * pow(2, k + 1, m)) % m
down = pow(2, k, m) - 1
if (x == 0):
    print(0)
else:
    print((up - down) % m)",logn,0992_C,CODEFORCES,1042,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    mod = 1000000007
    ans = x * pow(2, k + 1, mod) - pow(2, k, mod) + 1
    print(ans % mod)
",logn,0992_C,CODEFORCES,1102,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from math import pow
def modularExponentiation(x,n,M):
    
    if n==0:
        return 1
    elif n%2 == 0: 
        return modularExponentiation((x*x)%M,n//2,M)
    else:              
        return (x%M*modularExponentiation((x*x)%M,(n-1)//2,M)%M)%M


c=10**9+7
n,k=map(int,input().split())
a=(n%c*(modularExponentiation(2,k+1,c))%c)%c
b=(modularExponentiation(2,k,c)%c-1%c+c)%c
if n==0:
    print(""0"")
else:
    print((a%c-b%c+c)%c)",logn,0992_C,CODEFORCES,1068,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"MOD=1000000007
def pow2(n):
    if n==0:
        return 1
    t=pow2(n//2)%MOD
    m=(t*t)%MOD
    if n%2==1:
        m=(m*2)%MOD
    return m
x,k=map(int,input().split())
if x==0:
    print(0)
    exit()
t=pow2(k)*(2*x-1)%MOD
print((t+1)%MOD)
",logn,0992_C,CODEFORCES,1051,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"# cook your dish here
def power(x, y, p) : 
    res = 1     # Initialize result 
  
    # Update x if it is more 
    # than or equal to p 
    x = x % p  
  
    while (y > 0) : 
          
        # If y is odd, multiply 
        # x with result 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
  
        # y must be even now 
        y = y >> 1      # y = y/2 
        x = (x * x) % p 
          
    return res 
    
d,n=map(int,input().split())
ans =power(2,n+1,1000000007);
ans1=power(2,n,1000000007);
if(d==0):
    print(0)
else:
    print(((ans*(d%1000000007))%1000000007 - ans1 +1)%1000000007)",logn,0992_C,CODEFORCES,1123,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=[int(i) for i in input().split()]
if x!=0:
    print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)
else:
    print(0)
",logn,0992_C,CODEFORCES,1106,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"# XXXX

x, k = map(int, input().split())

md = 10 ** 9 + 7

res = x * pow(2, k + 1, md) - pow(2, k, md) + 1 if x > 0 else 0
print(res % md)
",logn,0992_C,CODEFORCES,1119,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"MOD=1000000007

x,k=map(int,raw_input().split())

if x>0:
	ans=(pow(2,k+1,MOD)*x)%MOD
	ans=(ans-pow(2,k,MOD))%MOD
	ans=(ans+1)%MOD
else:
	ans=0

print(ans)",logn,0992_C,CODEFORCES,1033,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"# -*- coding: utf-8 -*-
""""""
@Project : CodeForces
@File    : 1.py 
@Time    : 2018/6/19 14:40
@Author  : Koushiro 
""""""


if __name__ == ""__main__"":
    x,k = map(int, input().split())
    # y=2**k*(2*x-1)+1
    if x==0:  #
        print(0)
    else:
        y=pow(2,k,1000000007)*(2*x-1)+1
        result=int(y%(1000000007))  #
        print(result)
",logn,0992_C,CODEFORCES,1097,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from sys import stdin, stdout

def binary_exp(x,n,prime): #calculate x^n%p
	if n==0:
		return 1
	elif n==1:
		return x%prime
	else:
		temp=binary_exp(x,n//2,prime)
		temp=(temp*temp)%prime
		if n%2==0:
			return temp
		else:
			return ((x%prime)*temp)%prime

x,k = map(int, stdin.readline().rstrip().split())
if x==0:
	print(0)
else:
	val1=binary_exp(2,k+1,1000000007)
	val2=binary_exp(2,k,1000000007)
	val1=val1%1000000007
	val2=val2%1000000007
	#print(val1,val2)
	ans=((val1*(x%1000000007))%1000000007 -(val2-1)%1000000007)%1000000007
	print(ans)",logn,0992_C,CODEFORCES,1071,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod = 10**9+7
x, k = map(int, input().split(' '))
if (x == 0):
    print(0)
else:
    val1 = pow(2,k+1,mod) * x
    val2 = pow(2, k, mod) - 1
    val1 -= val2
    val1 %= mod
    print(val1)
",logn,0992_C,CODEFORCES,1022,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq
# sys.setrecursionlimit(100000)
# ^^^TAKE CARE FOR MEMORY LIMIT^^^
import random


def main():
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def binary(n):
    return (bin(n).replace(""0b"", """"))


def decimal(s):
    return (int(s, 2))


def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)


def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)


def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)


def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)


def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum


def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m


def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)


def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c


def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p


def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))


def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s
x,k=map(int,input().split())
mod=1000000007
tp=pow(2,k+1,mod)
tp2=pow(2,k,mod)
ans=(tp*x-tp2+1)%mod
print(ans if x!=0 else 0)
",logn,0992_C,CODEFORCES,1017,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"# your code goes here
MOD = 1000000007
def modpow(x, p):
    
    result = 1
    while p > 0:
        
        if p % 2 == 1:
            result = (result * x) % MOD

        
        p = p // 2
       
        x = (x * x) % MOD

    return result

n, k = map(int, input().split())
k+=1
if n == 0:
	print(0)
else:
	
	ans =  (((modpow(2, k))*(n%MOD))%MOD-(modpow(2, k-1)-1)%MOD)%MOD
	print(ans)",logn,0992_C,CODEFORCES,1114,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod = 1000000000+7
def fp(x ,y):
    if y == 1:
        return x
    if y == 0:
        return 1
    t = fp(x,y//2)%mod
    if y%2 == 1:
        return (t*t*x)
    else:
        return (t*t)

def inv(x):
    return fp(x%mod,mod-2)%mod

n,k=list(map(int,input().split()))
if not n:
    print(0)
    exit()
if not k:
    print( (2*n)%mod )
    exit()
numberOfPro =fp(2,k)
last = n*numberOfPro
first = (n-1)*numberOfPro+1
sumOfLast = (last)*(last+1)*inv(2)
sumOfFirst = first*(first-1)*inv(2)
num = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)
print(num%mod)
",logn,0992_C,CODEFORCES,1130,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
mod = 10**9+7
e = (x * pow(2, k, mod)) % mod
s = (e - pow(2, k, mod)) % mod
f = lambda x: (x*(x+1))%mod
ans = ((f(e) - f(s)) * pow(2, k*(mod-2), mod))%mod
print(ans if x != 0 else 0)",logn,0992_C,CODEFORCES,1104,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def mul(a, b, md) :
    if(b == 1) :
        return a
    if(b % 2 == 0) :
        t = mul(a, b // 2, md)
        return (2 * t) % md
    return (mul(a, b - 1, md) + a) % md;

def pows(a, b, md) :
    if(b == 0) :
        return 1
    if(b % 2 == 0) :
        t = pows(a, b // 2, md)
        return mul(t, t, md) % md
    return (mul(pows(a, b - 1, md) , a, md)) % md;


x, k = map(int, input().split())
ch = pows(2, k, 1000000007)
ans = pows(2, k + 1, 1000000007) * x - ch + 1
ans = ans % (1000000007)
if(x == 0) : 
    ans = 0
print(ans)",logn,0992_C,CODEFORCES,1064,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"modulo = 1000 ** 3 + 7


def mat_oz(x, k):
    if k == 0:
        return (2 * x) % modulo
    if x == 0:
        return 0
    b = (pow(2, k, modulo) * (2 * x - 1) + 1) % modulo
    return b


y, m = [int(i) for i in input().split()]
print(mat_oz(y, m))
",logn,0992_C,CODEFORCES,1110,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int,input().split())
if x==0:
  print(0)
else:
  print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)",logn,0992_C,CODEFORCES,1088,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def power(a,b,z):
    if b==0:
        return 1
    temp=power(a,b//2,z)
    if b%2==0:
        return (temp*temp)%z
    return (a*temp*temp)%z
x,k=list(map(int,input().split()))
if x==0:
    print(0)
else:
    z=(10**9)+7
    n=(power(2,k+1,z)*x)%z
    m=power(2,k,z)
    print((n-m+1)%z)",logn,0992_C,CODEFORCES,1143,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"f1, f2 = map(int,input().split("" ""))
if f1==0:
  print(0)
else:
  print((pow(2,f2,1000000007)*(2*f1-1)+1)%1000000007)",logn,0992_C,CODEFORCES,1096,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
 

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------

x,k=map(int,input().split())
res=0
mod=1000000007
res=pow(2,k,mod)*(2*x-1)+1
res%=mod
if x==0:
    res=0
print(res)
",logn,0992_C,CODEFORCES,1138,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
mod = 1000000007
if x == 0:
    print(0)
else:
    print(int((pow(2, k+1, mod) * x - pow(2, k, mod) + 1) % mod))

",logn,0992_C,CODEFORCES,1089,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"#!/usr/bin/python

x,k = map(int, input().strip().split())

MOD = 1000000007

if x > 0:
	r = (pow(2, k+1, MOD) * x - pow(2, k, MOD) + 1 + MOD * 10) % MOD
else:
	r = 0

print(r)",logn,0992_C,CODEFORCES,1023,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod = 10**9+7
x,k = [int(x) for x in input().split()]
if x ==0:
    print(0)
else:
    T = [1]
    for j in range(1024):
        T.append((2*T[-1])%(mod))
    L = [1]
    for i in range(10**6):
        L.append(((T[1024])*L[-1])%(mod))
        
    k =k % (mod-1)
    
    t1 = (k)%(1024)
    t2 =(k+1)%(1024)
    
    q1 = k//(1024)
    q2 =(k+1)//(1024)
    
    A = (L[q2]*T[t2])%(mod)
    A *= x
    A = A % (mod)
    
    B = (L[q1]*T[t1])%(mod)
    
    print((A-B+1)%(mod))
",logn,0992_C,CODEFORCES,1127,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"n, k = map(int, input().split())
m = 1000000007
if n == 0:
    print(0)
    exit(0)
r = pow(2, k+1, m)*n - pow(2, k, m) + 1
print(r % m)
",logn,0992_C,CODEFORCES,1095,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

#?############################################################


def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

#?############################################################


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p


#?############################################################

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))


#?############################################################

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

#?############################################################


def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime


#?############################################################

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

#?############################################################


def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

#?############################################################


def mapin():
    return map(int, input().split())

#?############################################################


input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
x, k = mapin()
p = 1000000007
if(x == 0):
    print(0)
else:
    a = power(2, k, p)
    # print(a)
    b = x+x-1
    b %= p
    a = (a*b) % p
    a += 1
    a %= p
    print(a)",logn,0992_C,CODEFORCES,1011,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod = 10 ** 9 + 7
x, k = map(int, input().split())
if x != 0:
    print((pow(2, k + 1, mod) * x - pow(2, k, mod) + 1) % mod)
else:
    print(0)

        



",logn,0992_C,CODEFORCES,1091,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def pow_mod(x, pwr, mod):
	res = 1
	multiplier = x
	while pwr > 0:
		if pwr%2 == 1: 
			res = res*multiplier % mod
		multiplier = multiplier*multiplier % mod

		pwr //= 2

	return res

[x, k] = map(int, input().split())

MOD = 1000000007

if x == 0:
	res = 0
else:
	res = pow_mod(2, k+1, MOD)*x % MOD
	res = (res - pow_mod(2, k, MOD)) % MOD
	res = (res + 1) % MOD

print(res)",logn,0992_C,CODEFORCES,1105,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def mul(x, y, md):
	return x * y % md;

def power(x, y, md) :
	res = 1;
	while (y != 0):
		if (y & 1):
			res = mul(res, x, 1000000007);
		x = mul(x, x, 1000000007);
		y >>= 1;
	return res

def inv(x, md):
	return power(x, md - 2, 1000000007);

t = input().split()
a = int(t[0])
k = int(t[1])
if (a == 0):
	print(0)
else:
	first = power(2, 2 * k, 1000000007);
	second = power(2, k, 1000000007);
	ans = mul(first, 2 * a - 1, 1000000007) + second;
	third = inv(second, 1000000007);
	ans = mul(ans, third, 1000000007);
	print(ans)",logn,0992_C,CODEFORCES,1070,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"import sys, os
from io import BytesIO, IOBase
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) 

mod = pow(10, 9) + 7
mod2 = 998244353
        
def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def ceil(a, b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True
 
n, k = mp()
if n==0:
    print(0)
    exit()
x = (n*pow(2, k+1, mod))%mod
print((x-pow(2, k, mod)+1)%mod)",logn,0992_C,CODEFORCES,1019,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k = map(int, input().split())
mod = 1000000007
flag = True
if x==0:
    flag=False
if flag:
    print((pow(2,k+1,mod)*x-pow(2,k,mod)+1+mod)%mod)
else:
    print(0)
",logn,0992_C,CODEFORCES,1140,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = [int(a) for a in input().strip().split()]


def binpow(x, k, mod):
    res = 1
    while k > 0:
        if k & 1:
            res  = ( res * x ) % mod
        x = ( x * x) % mod
        k >>= 1
    return res
if x == 0:
    print(0)
    exit()

mod = int(1e9 + 7)
k2 = binpow(2, k, mod)
res = ( k2 * (2 * x - 1) + 1) % mod

res %= mod

print(int(res))",logn,0992_C,CODEFORCES,1099,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"MOD=1000000007

def powr(n,N):
    temp=1
    while(N>0):
        if(N%2!=0):
            temp=(temp*n)%MOD
        n=(n*n)%MOD
        N=N//2
    return (temp%MOD)
 
""""""def powr(n,N):
    if(N==1):
        ans=n
        return ans
    else:
        ans=powr(n,N//2)
        if(N%2==0):
            return ((ans*ans)%MOD)
        else:
            return ((((ans*ans)%MOD)*n)%MOD)""""""
 
def MODI(a,b):
    ans=(powr(a,b)%MOD)
    return ans
 


x,k=map(int,input().split())
if(x==0):
    print(0)
else:
    t1=powr(2,k+1)%MOD
    t1=(t1*x)%MOD
    t2=powr(2,k)%MOD
    t2=(t2-1)%MOD
    ans=(t1-t2)%MOD
    print(ans)
",logn,0992_C,CODEFORCES,1132,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k = map(int,input().split())
if(x==0):
    print(0)
    exit(0)
m = 10**9+7
p = pow(2,k+1,m)
q = pow(2,k,m)
a = (x*p-q+1)%m
print(a)
",logn,0992_C,CODEFORCES,1078,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"MOD = 10**9 + 7
x, k = map(int, input().split())
y = (2*x - 1) % MOD
mult = pow(2, k, MOD)
if x:
    print((y * mult + 1) % MOD)
else:
    print(0)",logn,0992_C,CODEFORCES,1080,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from sys import stdin
x, k = map(int, stdin.readline().split())
if x == 0:
	print(0)
else:
	mod = 1000000007
	a = pow(2,k,mod)%mod
	b = (2*a)%mod
	print((((((x%mod)*(b%mod))%mod)-(a%mod)+1)+mod)%mod)",logn,0992_C,CODEFORCES,1124,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k = map(int,input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
else:
    print(((2*x-1)*pow(2,k,mod) + 1)%mod)
",logn,0992_C,CODEFORCES,1037,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def my_pow(a, n, m):
	if (n == 0) : return 1
	ans = my_pow(a, n // 2, m)
	if (n % 2 == 0):
		return ans * ans % m
	else:
		return (ans * ans * a) % m

x, k = map(int, input().split())
if (x == 0):
	print(0)
else:
	mod = 10**9 + 7
	x *= 2
	ans = (x - 1) * my_pow(2, k, mod) + 1
	ans %= mod
	ans += 2 * mod
	print(ans % mod)",logn,0992_C,CODEFORCES,1036,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())

if x==0:
    print(0)
    exit()
    
MOD = 10**9+7
ans = (pow(2, k+1, MOD)*x%MOD-(pow(2, k, MOD)-1))%MOD

print(ans)",logn,0992_C,CODEFORCES,1134,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())

twoPow = pow(2, k, 1000000007)

minQ = max(0, (x * twoPow - twoPow + 1))
minQ *= 2

maxQ = (x * twoPow * 2)

print(((maxQ*(maxQ+1)//2 - minQ*(minQ+1)//2 + minQ) // (maxQ-minQ+1)) % 1000000007)",logn,0992_C,CODEFORCES,1053,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())

if x == 0:
    result = 0
else:
    modulo = 10**9 + 7
    
    x %= modulo
    
    result = pow(2, k, modulo)*(2*x - 1) + 1
    result %= modulo

print(result)",logn,0992_C,CODEFORCES,1067,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
mod = 1000000007
if (k == 0):
    print((2 * x) % mod)
elif (x == 0):
    print(0)
else:
    ans = ((2 * x - 1) * pow(2, k, mod) + 1) % mod
    print(ans)
",logn,0992_C,CODEFORCES,1031,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"m=int(1e9+7)

def solve(x, k):
    return (m+(pow(2, k, m)*x%m)%m-((pow(2, k, m)-1)%m*pow(2, m-2, m)%m)%m)%m;
    
x,k=[int(x) for x in input().split()]

if x==0:
    print(0)
elif k==0:
    print((m+2*(x%m))%m)
else:
    print((m+2*solve(x, k))%m)
",logn,0992_C,CODEFORCES,1079,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"import sys, math
debug = 0
if debug:
    f = open(""input.txt"", ""r"")
    input = f.readline
def mp():
    return list(map(int,input().split()))

m = 1000000007    

def pow(k):
    if k == 0:
        return 1;
    z = pow(k // 2)
    if k % 2 == 1:
        return (2 * z * z) % m
    else:
        return (z * z) % m
        
def _main():
    x, k = mp()
    if(x == 0):
        print(0)
        return
    t = pow(k)
    a = x * t
    b = a - t + 1;
    print((a + b) % m)
    
     
_main()",logn,0992_C,CODEFORCES,1048,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def power(x, y, p) : 
    res = 1     # Initialize result 
  
    # Update x if it is more 
    # than or equal to p 
    x = x % p  
  
    while (y > 0) : 
          
        # If y is odd, multiply 
        # x with result 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
  
        # y must be even now 
        y = y >> 1      # y = y/2 
        x = (x * x) % p 
          
    return res
    
x,k = map(int,input().split())
if x==0:
    print(0)
else:
    ans = power(2,k,1000000007)
    ans = ans * ((2*x)-1)
    ans = ans+1
    ans=ans%1000000007
    print(ans)",logn,0992_C,CODEFORCES,1133,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"a,b = input().split()
x = int(a)
k = int(b)
mod = 10**9 + 7
if(x == 0 ):
	print(0)
elif( k == 0):
	print( (2*x)%mod )
else:
	print( (((pow(2,k,mod)*x - pow(2,k-1,mod))%mod)*2 + 3*mod + 1)%mod)",logn,0992_C,CODEFORCES,1093,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def read():
    return [int(v) for v in input().split()]


def main():
    mod = 10 ** 9 + 7
    x, k = read()
    if x == 0:
        print(0)
    else:
        print((pow(2, k, mod) * (2 * x - 1) + 1) % mod)


if __name__ == '__main__':
    main()
",logn,0992_C,CODEFORCES,1125,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def main():
    n, k = map(int, input().split())
    m = 10 ** 9 + 7
    print((pow(2, k, m) * (2 * n - 1) + 1) % m if n else 0)


if __name__ == '__main__':
    main()
",logn,0992_C,CODEFORCES,1100,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = list(map(int,input().split()))
m = 1000000000 +7
if x!=0:
    p1 = x*2 - 1
    p2 = x*2
    p = (p1 + p2)//2
    print((p*pow(2,k,m) + 1)%m)
else:
    print(x*2)

",logn,0992_C,CODEFORCES,1072,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
ans = 0
md = 1000000007

def bpow(base, exp, md):
    if (exp == 0):
        return 1
    if (exp % 2 == 1):
        return (base * bpow(base, exp-1, md)) % md
    else:
        k = bpow(base, exp//2, md)
        return (k*k) % md

pw = bpow(2, k, md)
ans = (2 * pw * x) % md
if (x != 0):
    ans -= pw-1
ans = (ans + md) % md
print(ans)",logn,0992_C,CODEFORCES,1026,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=map(int,input().split())
if x==0:
  print(0)
else:
    u=(pow(2,k,1000000007)*(2*x-1)+1)%1000000007
    print(int(u))
",logn,0992_C,CODEFORCES,1092,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from sys import stdin, stdout
from math import gcd
input = stdin.buffer.readline

x, k = map(int, input().split())
if x == 0:
	print(0)
	exit()
x *= 2
mod = 1000000007
x = pow(2, k, mod) * x % mod - (pow(2, k, mod) - 1)
print(x % mod)
",logn,0992_C,CODEFORCES,1142,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=map(int,input().split())
if x==0:
  print(0)
  exit()
mod=10**9+7
p=pow(2,k,mod)
print((2*p*x-p+1)%mod)",logn,0992_C,CODEFORCES,1014,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = [int(x) for x in input().split()]

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

res = x * pow(2, k + 1, mod) % mod
res = ((res - (pow(2, k, mod) - 1)) % mod + mod) % mod

print(res)
",logn,0992_C,CODEFORCES,1035,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"# cook your dish here
# from math import * 
#for _ in range(int(input().strip())):

x,k = map(int,input().split())
if x==0:
    print(0)
    exit()
mod = 10**9+7
print((pow(2,k+1,mod)*x%mod - (pow(2,k,mod) - 1)) % mod )",logn,0992_C,CODEFORCES,1058,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
dd = [(0,-1),(1,0),(0,1),(-1,0)]
ddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)


def main():
    x,k = LI()
    if x == 0:
        return 0
    t = pow(2,k+1,mod) * x % mod
    d = pow(2,k,mod) - 1

    return (t + mod - d) % mod


print(main())

",logn,0992_C,CODEFORCES,1109,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"#Python is love <3
def ii():
    return int(input())
def mi():
    return map(int,input().split())
def li():
    return list(map(int,input().split()))

mod = 10**9 + 7

x,k = mi()
if(x == 0):
    print(0)
elif(k == 0):
    print((2*x)%mod)
else:
    to = pow(2,k,mod)
    pre = (to * x)%mod
    prev = pow(2,k-1,mod)
    first = (pre - prev + 1)%mod
    sec = (pre - prev)%mod
    ans = (first + sec)%mod
    print((ans+mod)%mod)",logn,0992_C,CODEFORCES,1087,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"n = [int(x) for x in input().split(' ')]
M = 1000000007

def a(k):
	M = 1000000007
	if(k>0):
		l = a(k//2)
		return (l*l*(k%2+1))%M
	else:
		return 1


if n[0]==0:
	print(0)
else:
	l = a(n[1])
	print((2*(n[0]%M)*l-l+1)%M)


",logn,0992_C,CODEFORCES,1050,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=map(int,input().split())
mod=1000000007
if x==0: print(0)
else:
    print((x*pow(2,(k+1),mod)-pow(2,k,mod)+1)%mod)

",logn,0992_C,CODEFORCES,1083,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"import sys

MOD = 10**9 + 7

x,k = list(map(int,sys.stdin.readline().strip().split(' ')))

a = x*pow(2,k+1,MOD) % MOD 
b = (a - pow(2,k,MOD) + 1) % MOD
print(b if x != 0 else 0)",logn,0992_C,CODEFORCES,1098,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k = map(int, input().split())
mod = 10 ** 9 + 7
print(0 if x == 0 else (x * pow(2, k + 1, mod) - pow(2, k, mod) + 1 + mod) % mod)
",logn,0992_C,CODEFORCES,1030,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def bin(n):
    if n == 0:
        return 1
    else:
        if n % 2 == 1:
            return bin(n - 1) * 2
        else:
            b = (bin(n // 2)) % 1000000007
            return b * b;
x, k = map(int,input().split())
if x == 0:
    print(0)
else:
    z = bin(k + 1) % 1000000007
    z = z * (x - 1)
    z = z % 1000000007
    z += bin(k)
    z += 1
    while(z < 0): 
        z += 1000000007
    print(z % 1000000007)",logn,0992_C,CODEFORCES,1054,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def power(x,y,p):
    res=1
    x=x%p
    if(x==0):
        return 0
    while(y>0):
        if(y&1):
            res=(res*x)%p
        y=y>>1
        x=(x*x)%p
    return res

x,k=map(int,input().split())
p=1000000007
if(x==0):
    print(""0"")
else:
    t=(((power(2,k,p))*((2*x-1)%p))%p+1)%p
    # t=(((power(2,k,p))*(((2*(x%p))%p-1)%p))%p+1)%p
    #t=((power(2,k,p)%p)*(((2*(x%p))%p-1)%p)%1000000007+1)%p
    print(t)",logn,0992_C,CODEFORCES,1137,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"DV = 10**9 +7

x , k = list(map(int , input().split()))

mult = pow (2, k, DV)
if x == 0:
    print(0)
else:
    print((2*mult*x - mult +1) % DV)
",logn,0992_C,CODEFORCES,1043,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"n,k=input().split()
n=int(n)
k=int(k)

m = 1000000007
# z = (2**k)%m
z = pow(2,k,m)

ans = (((2*z)*(n%m))%m - (z-1))%m
if n==0:
	print(0)
else:
	print(ans)",logn,0992_C,CODEFORCES,1085,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"X, K = map(int, input().split())
mod = 1000000007
res = X*pow(2, K+1, mod)-pow(2, K, mod)+1;
while(res < 0):
   res += mod
if(X == 0):
   print(0)
else:
   print(res%mod)",logn,0992_C,CODEFORCES,1131,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = (int(x) for x in input().split())
mod = 10 ** 9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(2 * x % mod)
    quit()

ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod)
ans += 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",logn,0992_C,CODEFORCES,1121,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = [int(v) for v in input().split()]
mod = 10**9 + 7

if x == 0:
    print(0)
else:
    print(((pow(2, k + 1, mod) * x) - (pow(2, k, mod) - 1)) % mod)
",logn,0992_C,CODEFORCES,1039,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=list(map(int,input().split()))
md=1000000007
print((pow(2,k+1,md)*x-pow(2,k,md)+1)%md if x>0 else 0)",logn,0992_C,CODEFORCES,1112,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,n=map(int,input().split())
mod=10**9+7
if x>0: ans=pow(2,n+1,mod)*x-pow(2,n,mod)+1
else: ans=0
print(ans%mod)",logn,0992_C,CODEFORCES,1040,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=map(int,input().split())
mod=1000000007
print((pow(2,k+1,mod)*x-pow(2,k,mod)+1)%mod if x>0 else 0)",logn,0992_C,CODEFORCES,1111,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"import math
x, k = list(map(int, input().split()))
mod = 10**9 + 7
print((pow(2, k+1, mod)*x - pow(2, k, mod) + 1) % mod if x > 0 else 0)
",logn,0992_C,CODEFORCES,1136,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"q=input().split()

x=int(q[0])
k=int(q[1])

def po(a,p,m):
 if p==0:
  return 1
 x=po(a,p//2,m)%m
 x=(x%m*x%m)%m
 if p%2==1:
  x=(x%m*a%m)%m

 return int(x)

m=1000000007
if x==0:
 print(0)
else:
 print(((po(2,k+1,m)%m*x%m)%m-(po(2,k,m)%m-1)%m)%m)",logn,0992_C,CODEFORCES,1086,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"
n,k = map(int,input().split(' '))

arr = [n];
k = k+1
z = 1000000007
c = (n*pow(2,k,z)-pow(2,k-1,z)+1)%z
if n==0:
    print(0)
else:
    print(c)

",logn,0992_C,CODEFORCES,1107,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=map(int,input().split())
print(0 if x==0 else (x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7))",logn,0992_C,CODEFORCES,1013,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = (int(x) for x in input().split())
mod = 10 ** 9 + 7
if x == 0:
    print(0)
    exit()
if k == 0:
    print(2 * x % mod)
    exit()

# twopow = pow(2, k, mod)
ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod)
ans += 1
ans %= mod
ans += mod
ans %= mod

print(ans)
",logn,0992_C,CODEFORCES,1120,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"sp = 10**9 + 7;

def power(number,n):
    res = 1
    while(n != 0):
        if n % 2 != 0:
            res *= number
            res %= sp
            n-= 1
        number *= number
        number %= sp
        n //= 2
    return res % sp


x,k = map(int,input().split())
if x == 0:
    print(0)
else:
    print(((((x % sp) * (power(2,k)))%sp*2)%sp - ((power(2,k)-1))%sp ) % sp)
",logn,0992_C,CODEFORCES,1046,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
mod = 1000 * 1000 * 1000 + 7
if x == 0:
    print(0)
else:
    mul = pow(2, k + 1, mod)
    cnt = pow(2, k, mod)
    s1 = mul * cnt * x
    s2 = cnt * (cnt - 1)
    ans  = (s1 - s2) % mod
    rev = pow(cnt, mod - 2, mod)
    assert rev * cnt % mod == 1
    ans *= rev
    print(ans % mod)
",logn,0992_C,CODEFORCES,1065,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def power(x, y, p) :
    res = 1     # Initialize result
 
    # Update x if it is more
    # than or equal to p
    x = x % p 
 
    while (y > 0) :
         
        # If y is odd, multiply
        # x with result
        if ((y & 1) == 1) :
            res = (res * x) % p
            #res = (res * x)
 
        # y must be even now
        y = y >> 1      # y = y/2
        x = (x * x) % p
        #x = (x * x)
         
    return res
p = 1000000007
x = [int(i) for i in raw_input().split()]
y = power(2,x[1],p)
#z = power(2,x[1],p)
#z = power(power(2,x[1],p),p-2,p)
if(x[0]>0):
    ans = 2 * y * x[0]%p - (y - 1)%p
else:
    ans = 0
print(ans%p)",logn,0992_C,CODEFORCES,1118,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"MOD = int(1e9)+7

def fast_power(x, y):
    res = 1
    x %= MOD
    while y > 0:
        if y % 2 == 1:
            res = (res * x) % MOD
        x = (x * x) % MOD
        y = y >> 1
    return res
 
x, k = map(int, input().split())
if(x == 0):
    print(0)
else:
    a = fast_power(2, k)
    b = (2 * x - 1) % MOD
    c = (a * b) % MOD + 1
    print(c % MOD)
",logn,0992_C,CODEFORCES,1141,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"# -*- coding: utf-8 -*-
""""""
Created on Tue Jun 19 01:25:29 2018

@author: a0309
""""""

x, k= [int(x) for x in raw_input().split()]

MOD = 10 ** 9 + 7

def modulus(a, b, m):
    
    if b == 0:
        return 1
    if b == 1:
        return a % m
    
    result = int(modulus(a, b // 2, m))
    
    if b % 2 == 0:
        return  int (( (result % m) * (result % m) ) % m)
    else:
        return int (( (result % m) * (result % m) * (a % m)) % m)
    
def pow_mod(x, y, z):
    ""Calculate (x ** y) % z efficiently.""
    number = 1
    while y:
        if y & 1:
            number = number * x % z
        y >>= 1
        x = x * x % z
    return number
if x == 0:
    print(0)
elif k != 0:
    print( int( ( (modulus(2, k + 1, MOD) * (x % MOD) ) % MOD - (modulus(2, k, MOD)) % MOD + 1 + MOD) % MOD ))
else:
    print(int((x % MOD) * 2 % MOD) )",logn,0992_C,CODEFORCES,1063,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def pow1(n, k):
    if k == 0:
        return 1
    if k == 1:
        return n
    else:
        if k % 2 == 0:
            a = pow1(n, k // 2) % mod
            return a * a % mod
        else:
            return pow1(n, k - 1) % mod * n % mod

 
mod = 10 ** 9 + 7
n, k = map(int, input().split())
if n == 0:
    print(0)
else:
    x = pow1(2, k + 1) % mod
    print(((n * x - pow1(2, k) + 1)) % mod)",logn,0992_C,CODEFORCES,1077,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"n,k = map(int,input().split())
M = 1000000007
if(n == 0):
    print(0)
else:
    ans = 2*n - 1
    x  =  pow(2,k,M)
    print((((ans * x) % M) + 1) % M)",logn,0992_C,CODEFORCES,1145,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

a = ((x % mod) * pow(2, k + 1, mod)) % mod

print((a - (pow(2, k, mod) - 1)) % mod)
",logn,0992_C,CODEFORCES,1062,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = (int(x) for x in input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(x * 2 % mod)
    quit()
ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod) - 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",logn,0992_C,CODEFORCES,1122,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"M = 10 ** 9 + 7
x, k = map(int, input().split())
if x == 0: print(0); exit(0)
P = pow(2, k, M)
r = (P * x) % M - (0.5 * (-1 + P)) % M
print(int((2 * r + M) % M))
",logn,0992_C,CODEFORCES,1066,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x,k=map(int,input().split())
if x==0:print(""0"")
else:
    ans=(x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7)
    print(ans)
",logn,0992_C,CODEFORCES,1015,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"def power(x,y):
	mod=1000000007
	res = 1
	while (y > 0):
		if (y &1):
			res = (res * x)%mod
		y = y >> 1 
		x = (x * x)%mod
	return res;
x,k=map(int,input().split())
mod=1000000007
factor=power(2,k)
factor%=mod
ans=((2*factor*x)%mod-(factor)%mod + 1 + mod)%mod
if x==0:
	print(""0"")
else:
	print(ans)",logn,0992_C,CODEFORCES,1081,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
if x == 0:
    print(0)
    exit()
mod = 10**9+7
ans = 1+(2*x-1)*pow(2, k, mod)
print(ans%mod)
",logn,0992_C,CODEFORCES,1012,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod=1000000007 
import math
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m
def modInverse(b,m): 
    g = math.gcd(b, m)  
    if (g != 1): 
        # print(""Inverse doesn't exist"")  
        return -1
    else:  
        # If b and m are relatively prime,  
        # then modulo inverse is b^(m-2) mode m  
        return pow(b, m - 2, m) 
  
  
# Function to compute a/b under modulo m  
def modDivide(a,b,m): 
    a = a % m 
    inv = modInverse(b,m)
    a=(a*inv)%m
    return a
n,k=map(int,input().split())
ans=(powm(4,k,mod)*n)%mod
r=powm(2,k,mod)
r=(powm(r,2,mod)-r)%mod
w=modDivide(r,2,mod)    
ans=(ans-w)
er=powm(2,k,mod)
ans=modDivide(ans,er,mod)
ans=(ans*2)%mod
if n==0:
    ans=0
print(ans)",logn,0992_C,CODEFORCES,1139,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod = 10**9 + 7
x, k = list(map(int, input().split()))
if x == 0:
    print(0)
    exit()
ans = (x*pow(2, k+1, mod) - (pow(2, k, mod)-1) + mod)%mod
print(ans)
",logn,0992_C,CODEFORCES,1060,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"MOD = int(1e9 + 7)
x, k = map(int, input().split())
if x == 0: print(0)
else: print((x * pow(2, k+1, MOD) - pow(2, k, MOD) + 1) % MOD)",logn,0992_C,CODEFORCES,1069,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"import sys
def power(x, y, p) :
    res = 1     # Initialize result
 
    # Update x if it is more
    # than or equal to p
    x = x % p 
 
    while (y > 0) :
         
        # If y is odd, multiply
        # x with result
        if ((y & 1) == 1) :
            res = (res * x) % p
 
        # y must be even now
        y = y >> 1      # y = y/2
        x = (x * x) % p
         
    return res
mod=(10**9)+7
r,k=map(int,input().split())
if r==0:
    print(0)
    sys.exit()
print((((((power(2,k+1,mod)%mod)*(r%mod))%mod)-power(2,k,mod)+1))%mod)
",logn,0992_C,CODEFORCES,1045,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"modulo = 10 ** 9 + 7
x, k = [int(s) for s in input().split()]

if x == 0:
    print(0)
    exit(0)

k2 = pow(2, k, modulo)
ans = (x * k2 * 2 - k2 + 1) % modulo
print(ans)
",logn,0992_C,CODEFORCES,1059,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"mod = 1000000007
x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    ans = (pow(2, k + 1, mod) * x % mod - (pow(2, k, mod) - 1 + mod) % mod + mod) % mod
    print(ans)",logn,0992_C,CODEFORCES,1028,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"#This code sucks, you know it and I know it.  
#Move on and call me an idiot later.

MOD = 1000000007
def fast_power(base, power):
    result = 1
    while power > 0:
        if power % 2 == 1:
            result = (result * base) % MOD

        power = power // 2
        base = (base * base) % MOD

    return result

x, k = map(int, input().split())

if x == 0 or k == 0:
    print((x * 2) % MOD)
else:
    d = ((x * 4) - 1) - (x * 2)
    print(((x * 2) + (d * (fast_power(2, k) - 1))) % MOD)",logn,0992_C,CODEFORCES,1076,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from itertools import combinations_with_replacement 
import sys
from sys import stdin
import math
import bisect
#Find Set LSB = (x&(-x)), isPowerOfTwo = (x & (x-1))
# 1<<x =2^x
#x^=1<<pos  flip the bit at pos

def BinarySearch(a, x):
    i = bisect.bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    else:
        return -1
def iinput():
    return int(input())
def minput():
    return map(int,input().split())
def linput():
    return list(map(int,input().split()))

def fiinput():
    return int(stdin.readline())
def fminput():
    return map(int,stdin.readline().strip().split())
def flinput():
    return list(map(int,stdin.readline().strip().split()))

x,k=minput()

if(x==0):
    print(0)
else:
    mod=(10**9)+7
    a=pow(2,k,mod)
    b=((2*x)%mod-1)%mod
    ans=((a*b)%mod+1)%mod
    print(ans)",logn,0992_C,CODEFORCES,1016,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    mod = 10 ** 9 + 7
    p = pow(2, k, mod)
    ans = (x * (p * 2) - (p - 1)) % mod
    print(ans)",logn,0992_C,CODEFORCES,1021,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"x, k = map(int,input().split())
if x == 0:
    print(0)
    exit()
b = pow(2,k,1000000007)  
a = (2*x - 1)%(1000000007)
print((a*b + 1) % 1000000007)",logn,0992_C,CODEFORCES,1082,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math
"from copy import deepcopy
import itertools
from bisect import bisect_left
from bisect import bisect_right
import math
from collections import deque


def read():
    return int(input())


def readmap():
    return map(int, input().split())


def readlist():
    return list(map(int, input().split()))


# C
N = read()
LIST = []
left = 0
right = 1
for i in range(N):
    l, r = readmap()
    LIST.append((l, left))
    LIST.append((r, right))

LIST.sort()

cnt = [0] * (N+1)  # DO NOT USE cnt[0]

n = 1
x = LIST[0][0]
dir = left
for item in LIST[1:]:
    if item[1] == left:
        if dir == left:
            cnt[n] += item[0] - x
            n += 1
            x = item[0]
            dir = left
        else:
            cnt[n] += item[0] - x - 1
            n += 1
            x = item[0]
            dir = left
    else:
        if dir == left:
            cnt[n] += item[0] - x + 1
            n -= 1
            x = item[0]
            dir = right
        else:
            cnt[n] += item[0] - x
            n -= 1
            x = item[0]
            dir = right

print("" "".join(list(map(str, cnt[1:]))))

",nlogn,1000_C,CODEFORCES,2665,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"#import resource
#import sys
#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])
#sys.setrecursionlimit(0x10000000)
from sys import stdin, stdout
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p,f):
    t=((f[n])*(modinv(f[r],p)%p)*(modinv(f[n-r],p)%p))%p
    return t
mod=(10**9)+7
def GCD(x, y):
   while(y):
       x, y = y, x % y
   return x
def BS(arr, l, r, x):
    if r >= l:
        mid = l + (r - l)/2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return BS(arr, l, mid-1, x)
        else:
            return BS(arr, mid+1, r, x)
    else:
        return -1
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import math
from Queue import Queue as Q
""""""---------------------------------------------------------------------""""""
def main():
    n=input()
    p=[]
    f=[0]*(n+1)
    for i in range(n):
        l,r=map(int,stdin.readline().split())
        p.append([l,""l""])
        p.append([r,""r""])
    p.sort(key=lambda x:x[0])
    o=1
    c=0
    w=[]
    for i in range(1,len(p)):
        if(p[i][0]==p[i-1][0]):
            if(p[i][1]==""l""):
                o+=1
            else:
                c+=1
        else:
            w.append([p[i-1][0],o,c])
            o,c=0,0
            if(p[i][1]==""l""):
                o=1
            else:
                c=1
    w.append([p[-1][0],o,c])
    s=0
    i=0
    r=-1
    while(i<len(w)):
        f[s]+=w[i][0]-r-1
        f[s+w[i][1]]+=1
        s+=w[i][1]-w[i][2]
        r=w[i][0]
        i+=1
    for i in range(1,n+1):
        stdout.write(str(f[i])+"" "")
if __name__ == '__main__':
    main()
",nlogn,1000_C,CODEFORCES,2669,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"import os,sys,math 
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192
#complete the main function with number of test cases to complete greater than x
def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:            
        return len(a)

def solve():
    n=I()
    points,l=[],[]
    for i in range(n):
        a,b=In()
        l.append((a,b))
        points.append(a)
        points.append(b)
    points.sort()
    k=0 
    d={}
    l1=[]
    for i in range(2*n):
        if d.get(points[i],-1)==-1:
            d[points[i]]=k
            l1.append(points[i])
            k+=1
    # print(l1)
    n1=len(d)
    dp=[[0,0] for i in range(n1)]
    for a,b in l:
        dp[d[a]][0]+=1
        dp[d[b]][1]-=1

    ans={}
    last=dp[0][0]
    ans[last]=1
    last+=dp[0][1]
    for i in range(1,n1):
        cnts=l1[i]-l1[i-1]-1
        if ans.get(last,-1)!=-1:
            ans[last]+=cnts
        else:
            ans[last]=cnts
        last+=dp[i][0]
        if ans.get(last,-1)!=-1:
            ans[last]+=1
        else:
            ans[last]=1
        last+=dp[i][1]
    if ans.get(last,-1)!=-1:
        ans[last]+=1
    else:
        ans[last]=1
    for i in range(1,n+1):
        print(ans.get(i,0),end=' ')
    print()
    pass
def main():
    T=1
    for i in range(T):
        solve()
        
M = 998244353
P = 1000000007
 




class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == '__main__':
    main()",nlogn,1000_C,CODEFORCES,2659,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter,defaultdict
from heapq import heappush, heappop
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))
def main():
    for _ in range(1):  # nmbr()):
        n = nmbr()
        d = defaultdict(int)
        for i in range(n):
            u, v = lst()
            d[u] += 1
            d[v + 1] -= 1
        ks = sorted(d.keys())
        ks_n = len(ks)
        for i in range(1, ks_n):
            d[ks[i]] += d[ks[i - 1]]
        l = Counter()
        for i in range(ks_n - 1):
            times = d[ks[i]]
            cnt = ks[i + 1] - ks[i]
            l[times] += cnt
        for i in range(1, n + 1):
            sys.stdout.write(str(l[i]) + ' ')

        # sys.stdout.write(str(ans)+'\n')
    # sys.stdout.flush()

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    for t in range(1):main()#int(input())):",nlogn,1000_C,CODEFORCES,2661,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"#!/usr/bin/python3

def solve(N, A):
    cnt = [0] * (N + 1)

    evd = {}
    xs = []
    for a, b in A:
        if a not in evd:
            evd[a] = [0, 0]
            xs.append(a)
        if b not in evd:
            evd[b] = [0, 0]
            xs.append(b)

        evd[a][0] += 1
        evd[b][1] += 1

    xs.sort()

    px = xs[0] - 1
    pop = 0
    for x in xs:
        cnt[pop] += x - px - 1
        cnt[pop + evd[x][0]] += 1
        pop -= evd[x][1]
        pop += evd[x][0]
        px = x

    return cnt[1:]


def main():
    N = int(input())
    A = [tuple([int(e) for e in input().split(' ')]) for _ in range(N)]
    print(*solve(N, A))


if __name__ == '__main__':
    main()
",nlogn,1000_C,CODEFORCES,2664,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
from io import BytesIO, IOBase
import sys

def main():
    n=int(input())
    a=[]
    for i in range(n):
        x,y=map(int,input().split())
        a.append((x,0))
        a.append((y,1))
    a.sort()
    ans,s=[0]*n,[]
    for x,y in a:
        if y:
            ans[len(s)-1]+=x-s[-1][0]+1-s[-1][1]
            z=s.pop()
            if s!=[]:
                s[-1][1]+=(x-z[0]+1)
        else:
            s.append([x,0])
    print(*ans)

# FAST INPUT OUTPUT REGION

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",nlogn,1000_C,CODEFORCES,2658,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math 
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline


def solve():
    n = ii()
    d = defaultdict(lambda:0)
    d1 = defaultdict(lambda:0)
    for i in range(n):
        x,y = li()
        d[x-1]-=1
        d[y]+=1
    
    x = list(d.keys())
    x.sort()
    r = x[-1]
    # print(x)
    # print(d)
    c=d[r]
    temp=1
    for i in range(len(x)-2,-1,-1):
        l = x[i]+1
        d1[c]+=r-l+temp
        # print(c,r-l+1)
        c+=d[x[i]]
        r=l
        temp=0
        
    for i in range(1,n+1):
        print(d1[i],end="" "")
    print()

        


t = 1
# t = int(input())
for _ in range(t):
    solve()
    
",nlogn,1000_C,CODEFORCES,2656,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"from collections import defaultdict
n, s = int(input()), []
for i in range(n):
  a = [int(x) for x in input().split()]
  s += [(a[0], 0), (a[1], 1)]
s.sort()
now = 0
rev = defaultdict(int)
for a,b in zip(s, s[1:]):
  # print(a,b)
  if(a[1] == 0):
    now += 1
    # print(""now: %d"" % now)
    rev[now] += b[0] - a[0]
    if b[1] == 1: 
      # print(""add %d"" % (b[0] - a[0] + 1))
      rev[now] += 1
    # else:
    #   print(""add %d"" % (b[0] - a[0]))
  else:
    now -= 1
    # print(""now: %d"" % now)
    if b[0] != a[0]: 
      rev[now] += b[0] - a[0]
      if b[1] == 0: 
        # print(""add %d"" % (b[0] - a[0] - 1))
        rev[now] -= 1
      # else:
      #   print(""add %d"" % (b[0] - a[0]))
# print(rev)
for i in range(1, n+1):
  print(rev[i], end="" "")",nlogn,1000_C,CODEFORCES,2672,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"from collections import defaultdict
n = int(input())
arr = defaultdict(int)
for a0 in range(n):
	l,r = input().strip().split()
	l,r=int(l),int(r)
	arr[l]+=1
	arr[r+1]-=1

brr=[0]*(n+1)

l=sorted(arr.keys())
sum=arr[l[0]]
prevpoint=l[0]
for key in l[1:]:
	brr[sum]+=key-prevpoint
	prevpoint=key
	sum+=arr[key]
print(*brr[1:])",nlogn,1000_C,CODEFORCES,2668,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"from sys import stdin
input=stdin.readline
from collections import defaultdict
def f(q):
    q.sort()
    d=defaultdict(int)
    for l,r in q:
        d[l]+=1
        d[r+1]-=1
    res=0
    prev=None
    ans=[0]*(len(q)+1)
    for i in sorted(d.keys()):
        # print(res,ans,prev,i)
        if prev==None:
            # ans[1]+=1
            prev=i
        else:
            ans[res]+=i-prev
            prev=i
        res+=d[i]
        # res+=d[i]
    return ans[1:]

n=int(input())
q=[]
for i in range(n):
    x,y=map(int,input().strip().split())
    q.append((x,y))
print(*f(q))",nlogn,1000_C,CODEFORCES,2662,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"from sys import stdin
input=stdin.readline
from collections import defaultdict
def f(d,n):
    res=0
    prev=None
    ans=[0]*(n+1)
    for i in sorted(d.keys()):
        # print(res,ans,prev,i)
        if prev==None:
            prev=i
        else:
            ans[res]+=i-prev
            prev=i
        res+=d[i]
    return ans[1:]

n=int(input())
d=defaultdict(int)
for i in range(n):
    x,y=map(int,input().strip().split())
    d[x]+=1
    d[y+1]-=1
print(*f(d,n))",nlogn,1000_C,CODEFORCES,2663,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"from collections import defaultdict
n, s= int(input()), []
for i in range(n):
  a = [int(x) for x in input().split()]
  s += [(a[0], 0), (a[1], 1)]
s.sort()
now, rev = 0, defaultdict(int)
for a, b in zip(s, s[1:]):
  now += 1 if a[1] == 0 else -1
  if(a[1] == 0):
    rev[now] += b[0] - a[0] + (1 if b[1] == 1 else 0)
  elif b[0] != a[0]:
    rev[now] += b[0] - a[0] - (1 if b[1] == 0 else 0)
[print(rev[i], end="" "") for i in range(1, n+1)]
",nlogn,1000_C,CODEFORCES,2673,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"from collections import defaultdict

ans = defaultdict(int)
n = int(input())

beg, end = [0] * n, [0] * n

for i in range(n):
    a, b = map(int, input().split())
    beg[i] = a
    end[i] = b + 1
beg.sort()
end.sort()

pa, pb = 0, 0

cur = 0
lst = -1

while pb < n:
    pos = end[pb]
    if pa < n:
        pos = min(pos, beg[pa])

    ans[cur] += pos - lst

    ad = 0
    mn = 0
    while (pa < n and beg[pa] == pos):
        ad += 1
        pa += 1
    while (pb < n and end[pb] == pos):
        pb += 1
        mn -= 1

    lst = pos
    cur += ad + mn

for i in range(1, n + 1):
    print(ans[i], end = ' ')",nlogn,1000_C,CODEFORCES,2666,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"point = {}

n = int(input())

for i in range(n):
    l, r = map(int, input().split())
    r += 1
    if l not in point:
        point[l] = 0
    if r not in point:
        point[r] = 0
    point[l] += 1
    point[r] -= 1

line = []
for key in point:
    line.append((key,point[key]))
line.sort()
ans = [0] * (n+1)

last_index = 0
last_value = 0

for index, value in line:
    ans[last_value] += index - last_index
    last_index = index
    last_value += value

for cnt in ans[1:]:
    print(cnt,end=' ')",nlogn,1000_C,CODEFORCES,2667,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"n = int(input())
from collections import defaultdict, Counter
a = defaultdict(list)
count_left = Counter()
count_right = Counter()

for _ in range(n):
	l, r = map(int, input().split())
	count_left[l] += 1
	count_right[r] += 1

count = [0] * (n + 1)


pts = sorted(set(count_left.keys()) | set(count_right.keys()))
# pts.append(pts[-1])
c = 0
prev = pts[0]
for pt in pts:
	# print(prev, pt, c)
	if count_left[pt]:
		count[c] += pt - prev - 1		
		c += count_left[pt]
		count[c] += 1
		c -= count_right[pt]
	else:
		count[c] += pt - prev
		c -= count_right[pt]

	

	prev = pt
	# print(count)

print(' '.join(map(str, count[1:])))",nlogn,1000_C,CODEFORCES,2670,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"from sys import stdin, stdout

get_string = lambda: stdin.readline().strip('\n')
get_intmap = lambda: map( int, get_string().split(' ') )
#get_intmap

def testcase():
    n = int(input())
    cnt = dict()
    for i in range(n):
        l,r = get_intmap()
        cnt[l] = cnt.get(l,0) + 1
        cnt[r+1] = cnt.get(r+1,0) - 1
    ans = [0] * (n + 1)
    sk = sorted(cnt.keys())
    #print(cnt)
    cnt_i = 0
    for ind, i in enumerate(sk[:-1]):
        cnt_i += cnt[i]
        ans[cnt_i] += sk[ind + 1] - i
    print(' '.join([str(i) for i in ans[1:]]))
        

    

testcase();quit()
for t in range(int(input())):
    testcase()
",nlogn,1000_C,CODEFORCES,2657,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"n = int(input())
left = []
right = []
for i in range(n):
	data = input().split()
	left.append(int(data[0]))
	right.append(int(data[1]))
	
left.sort()
right.sort()
i = 0
j = 0
count = 1
ans = [0] * (n + 1)
left += [max(right) + 1]
right += [max(right) + 2]
while (i < n) and (j < n):
	while left[i + 1] <= right[j]:
		ans[count] += (left[i + 1] - left[i])
		count += 1
		i += 1
	ans[count] += (right[j] - left[i] + 1)
	i += 1	
	count -= 1
	
	while ((i == n) or (right[j + 1] < left[i])) and (j < n - 1):
		ans[count] += (right[j + 1] - right[j])
		count -= 1
		j += 1
	ans[count] += (left[i] - right[j] - 1)
	j += 1
	count += 1
#	print(i, j)

	
for i in range(1, n + 1):
	print(ans[i], end = "" "")
print()
	
",nlogn,1000_C,CODEFORCES,2671,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"import sys
input=sys.stdin.buffer.readline
from collections import defaultdict as dd
n=int(input())
d=dd(int)
for i in range(n):
    l,r=map(int,input().split())
    d[l] +=1
    d[r+1] -=1
arr=list(d.keys())
arr.sort()
ans=[0 for i in range(n+1)]
count =0
l=len(arr)
arr.append(arr[-1])
for i in range(l):
    count +=d[arr[i]]
    ans[count] +=arr[i+1] -arr[i]
print(*ans[1:])",nlogn,1000_C,CODEFORCES,2660,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings"
"
from sys import stdin
input = stdin.readline

n=int(input())
arr=[int(x) for x in input().split()]

arr.sort(reverse=True)

d={}
for i in range(n):
    if arr[i] in d:
        d[arr[i]].append(i)
    else:
        d[arr[i]]=[i]

cnt=0
vis=[-1]*n
for i in range(n):
    s=bin(arr[i])
    s=s[2:]
    s=s[::-1]
    l=len(s)
    x=0
    for j in range(l):
        if s[j]==""0"":
            x=x+(2**j)
    x=x+1

    if x in d:
        if x==arr[i] and len(d[x])==1:
            if vis[i]==-1:
                cnt=cnt+1
        else:
            if vis[d[x][0]]==-1:
                for j in d[x]:
                    vis[j]=1   
    else:
        if vis[i]==-1:
            cnt=cnt+1
    vis[i]=1    

print(cnt)",nlogn,1005_C,CODEFORCES,2677,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"
def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]
#visited = [[False for i in range(m)] for j in range(n)]
#sys.stdin = open(r'input.txt' , 'r')
#sys.stdout = open(r'output.txt' , 'w')
#for tt in range(INT()):

#Code


n = INT()
arr = LIST()
k = []
i = 0
while 2 ** i <= 10**18 :
    k.append(2 ** i)
    i+=1

d = {}
s1 = set()
for i in arr:
    s1.add(i)
    if i not in d :
        d[i] = 1
    else:
        d[i]+=1

s2 = set()
for i in s1 :
    flag = False
    for j in k :
        x = j - i
        y = -1
        try:
            y = d[x]
        except:
            y = -1
        if y != -1:
            if x == i and d[i] == 1:
                continue
            flag = True
            break
    if flag==False:
        s2.add(i)

res = 0
for i in s2 :
    res+=d[i]
print(res)



",nlogn,1005_C,CODEFORCES,2689,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"from collections import defaultdict
n=int(input())
a=list(map(int, input().split()))

d=defaultdict(int)
cnt=0

for i in range(n):
    d[a[i]]+=1

for i in range(n):
    f=0
    for j in range(1,31):
        p=2**j-a[i]
        if p<=0:
            continue
        if p!=a[i]:
            if d[p]>=1:
                f=1
        else:
            if d[p]>=2:
                f=1
    if not f:
        cnt+=1
print(cnt)
",nlogn,1005_C,CODEFORCES,2686,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"import math
n = int(input())
s = list(map(int, input().split()))
d = dict()
for i in range(n):
    d[s[i]] = d.get(s[i], 0)+1

rem = 0
for i in range(n):

    ok = False
    for j in range(31):
        x = 2** j - s[i]
        c = d.get(x , 0)
        if c > 1 or (c == 1 and s[i] != x):
            ok = True
            break

    if ok == False:
        rem += 1
 
print(rem)",nlogn,1005_C,CODEFORCES,2685,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"import bisect
from collections import defaultdict,Counter
import math

    
def solve(a):
    count=0
    mp=Counter(a)
    for i in range(len(a)):
        flag=0
        for j in range(31):
            x=int(1<<j)-a[i]
            if (x in mp) and (x==a[i] and mp[x]>1):
                # print(x)
                flag=1
                break
            elif (x in mp) and (x!=a[i] and mp[x]>0):
                flag=1
                break
        if flag==0:
            count+=1        

    return count


n=int(input(''))
a=list(map(int,input('').split()))
print(solve(a))
",nlogn,1005_C,CODEFORCES,2683,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"#------------------------template--------------------------#
import os
import sys
from math import *
from collections import *
# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()




n = Int()
a = array()
C = Counter(a)
a = set(a)

ans = 0

for x in a:
    ok = True

    for i in range(65):
        
        need = 2**i - x
        if(need == x and C[need] > 1): ok = False 
        if(need != x and C[need] > 0): ok = False
    
    # print(ok,x)
    ans += C[x]*ok

print(ans)

























",nlogn,1005_C,CODEFORCES,2678,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"
def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]
#visited = [[False for i in range(m)] for j in range(n)]
#sys.stdin = open(r'input.txt' , 'r')
#sys.stdout = open(r'output.txt' , 'w')
#for tt in range(INT()):

#Code

n = INT()
arr = LIST()

i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s1= set()
for i in arr:
    s1.add(i)
    if i not in d :
        d[i] = 1
    else:
        d[i]+=1

s2 = set()
for i in s1 :
    flag = False
    for j in p :
        x = j - i
        k = -1
        try:
            k = d[x]
        except :
            k = -1
        if k != -1:
            if x == i and d[i] == 1 :
                continue
            else:
                flag = True
                break
    if flag == False:
        s2.add(i)

res = 0
for i in s2 :
    res+=d[i]
print(res)



",nlogn,1005_C,CODEFORCES,2688,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"for _ in range(1):
    i=0
    ans=[]
    while(i<32):
        ans.append(2**i)
        i+=1
        
    
    n=int(input())
    l=list(map(int,input().split()))
    d={}
    for i in l:
        if i not in d:
            d[i]=1
        else:
            d[i]+=1
          
    # for j in range(n):
    #     if l[j] in ans1 and d[l[j]]>1:
    #         continue
    #     else:
    #         nl.append(l[j])
    
    
    
    c=0
    for i in d.keys():
        
        for j in ans:
            
            if j-i in d and (j-i!=i or d[j-i]>1):
                
                break
        else:
            c+=d[i]
    print(c)            
                
                
    
    ",nlogn,1005_C,CODEFORCES,2691,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"from math import *
from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 2**j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)",nlogn,1005_C,CODEFORCES,2680,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"import sys

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

ak=[]
i=0
while 2**i <=2000000000:
    ak.append(2**i)
    i+=1

n=int(input())
a=list(map(int,input().split()))
d=dict()
for i,v in enumerate(a):
    d[v]=d.get(v,set())
    d[v].add(i)
ans=[0]*n
for i in range(n):
    for j in ak:
        if j-a[i] in d:
            if (j-a[i]==a[i] and len(d[a[i]])>=2) or j-a[i]!=a[i] :
                ans[i]=1
                break
print(ans.count(0))",nlogn,1005_C,CODEFORCES,2684,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"import sys, heapq

def binary(num):
    left = 0
    right = n
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < num:
            left = mid + 1
        elif arr[mid] > num:
            right = mid
        else:
            return True
    return False

n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().split()))
arr.sort()
cnt = dict().fromkeys(set(arr), 0)
ans = 0
for i in arr:
    cnt[i] += 1
for i in range(n):
    now = arr[i]
    can = False
    for j in range(31):
        target = pow(2, j) - now
        if binary(target):
            if target == now:
                if cnt[now] >= 2:
                    can = True
                    break
            else:
                can = True
                break
    if not can:
        ans += 1
print(ans)",nlogn,1005_C,CODEFORCES,2676,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 1<<j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)",nlogn,1005_C,CODEFORCES,2682,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 1<<j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)
",nlogn,1005_C,CODEFORCES,2679,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"n=int(input())
ar=list(map(int,input().split()))
d={};ans=0
for i in ar:d[i]=d.get(i,0)+1
for i in ar:
  flag=False
  for j in range(31):
    k=2**j;
    if k>=i:
     k1=k-i
     if i!=k1 and d.get(k1,0)>0:flag=True;break
     if i==k1 and d.get(i,0)>1:flag=True;break
  if not flag:ans+=1
    
print(ans)
",nlogn,1005_C,CODEFORCES,2687,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    arr=get_list()
    counter=collections.Counter(arr)
    ans=set()
    for i in counter:
        for j in range(1,32):
            no=2**j
            diff=no-i
            if diff<0:
                continue
            if diff==i:
                if counter[i]>1:
                    ans.add(i)
                    #print(i,no,diff,""###"")
                    break
            else:
                if diff not in  counter:
                    continue
                else:
                    ans.add(i)
                    #print(i,no,diff)
                    break
    #print(ans)
    val=0
    ans=list(ans)
    for i in ans:
        val+=counter[i]
    print(n-val)",nlogn,1005_C,CODEFORCES,2674,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"n = int(input())
l = list(map(int,input().split()))
i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s = set()
for i in l:
    s.add(i)
    if i in d:
        d[i] += 1

    else:
        d[i] = 1

z = set()
for i in s:
    f = 1
    for j in p:
        e = j-i
        if e in s:
            if e == i and d[e] == 1:
                continue

            f = 0
            break

    if f:
        z.add(i)

ans = 0
for i in z:
    ans += d[i]

print(ans)",nlogn,1005_C,CODEFORCES,2681,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"from sys import stdin,stdout
from math import ceil,log
def main():
	d={}
	n=int(stdin.readline())
	a=list(map(int,stdin.readline().split( )))
	m=-1;mm=10**10
	for v in a:
		if v not in d:
			d[v]=1
		else:
			d[v]+=1
		m=max(m,v)
		mm=min(mm,v)
	ans=0
	
	for v in a:
		
		exponent=ceil(log(v,2))
		power=2**exponent
		find=0
		while power-v>=0:
			if power-v>mm and power-v>m:
				break
			
			element=power-v
			if element in d and element==v and d[element]>1:
				find=1
				break
			elif element in d and element!=v:
				find=1
				break
			power=power*2
		if find==0:
			ans+=1
	stdout.write(""%d\n""%(ans))

main()",nlogn,1005_C,CODEFORCES,2675,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
########################################################################

n=ri()
a=ris()
freq=Counter(a)
ans=0
for x in freq:
  for i in range(32):
    c=(1<<i)-x
    if c not in freq:
      continue
    if c==x and freq[x]==1:
      continue
    break
  else:
    ans+=freq[x]

print(ans)
",nlogn,1005_C,CODEFORCES,2690,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation"
"a=input()
n=len(a)
b=[]
c=0
d=0
for i in range(1,n):
    if a[i]==a[i-1]:
        b.append(['bw'.find(a[c]),i-c])
        d=max(d,i-c)
        c=i
b.append(['bw'.find(a[c]),n-c])
d=max(d,n-c)
if d<n and b[0][0]==(b[-1][0]+b[-1][1])%2:
    d=max(d,b[-1][1]+b[0][1])
print(d)",linear,1025_C,CODEFORCES,1878,Plasticine zebra,"Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras. 
Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let's call the number of selected pieces the length of the zebra.
Before assembling the zebra Grisha can make the following operation $$$0$$$ or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order ""bwbbw"" (here 'b' denotes a black strip, and 'w' denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain ""wbwbb"".
Determine the maximum possible length of the zebra that Grisha can produce.
The only line contains a string $$$s$$$ ($$$1 \le |s| \le 10^5$$$, where $$$|s|$$$ denotes the length of the string $$$s$$$) comprised of lowercase English letters 'b' and 'w' only, where 'w' denotes a white piece and 'b' denotes a black piece.
Print a single integer — the maximum possible zebra length.
","input
In the first example one of the possible sequence of operations is bwwwbww|bw $$$\to$$$ w|wbwwwbwb $$$\to$$$ wbwbwwwbw, that gives the answer equal to $$$5$$$.
output
In the second example no operation can increase the answer.
","constructivealgorithms, implementation"
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():
    # mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    tc=1
    for _ in range(tc):
        
        s=2*rs()+""333""
        le=(len(s)-3)//2
        a=[]
        for i in s:
            if i=='b':
                a.append(0)
            if i=='w':
                a.append(1)
            if i=='3':
                a.append(3)
        pehla=[0,1]*len(s)
        
        doosra=[1,0]*len(s)
        # print(*a)
        # print(*pehla)
        # print(*doosra)
        k=[0]*len(s)
        for i in range(len(s)):
            if a[i]==pehla[i]:
                k[i]=1
        ans=0
        t=0
        for i in k:
            if i==1:
                t+=1
                # print(t)
            else:
                ans=max(t,ans)
                t=0
        # print(*k)
        k=[0]*len(s)
        for i in range(len(s)):
            if a[i]==doosra[i]:
                k[i]=1
        
        t=0
        for i in k:
            if i==1:
                t+=1
                # print(t)
            else:
                ans=max(t,ans)
                t=0
        # print(*k)
        
        print(min(le,ans))
        
                    
                
        
        
            
                
        

            
        

               
            
        
              
                
        
        
            
        
        
            
            
        
        
                
                
                
                
            
        
        
            
           
        
            
                    

                                 
                
                
        

                
        
        
        
            
        
        
                
            
        
        
                    
        
        
        
            
                    
            

                
            
            
                
            
                
            
            
            
            
                
            
        
        
        
        
        
        
        
                    
        
        
        
                
                
        
            
            
            
        

                    
        
                
        
        
                        
        
                            

        

                
            
        

                
            
                    
                
                
        
        
         
        

                        
                            
                
        
                            
                    

                
            
        
                
            
                
        
        
        
                             
        
            
        
        
            
                        
                        
                    
            
        
        
        
        
        
                        
       

        
                           
        
        
        
            
        
        
        
                      

      
                            
            
        
        
            
            
            
            
            
        
        
        
            
        
        
        
            
        
        
        
        
            
            
        
        
        
        
        
        
        
                
                
                    
        
        
            
            
        
                
            
            
        
        
        
        
                
        
            
        
                
        
        
            
        
       
            

                
        
        
        
   
            
        
        
        
        
            
        
                
        
        
        
            
            
        
        
            
        
        

        
        
            
        
        
            
        
                        

        
        
            
     
        
        
            
        
        
                
            
        
        
        
                
            
        

            
             
        
            
        
        
        
                
        
            
        
        
        
        
                
        
        
            
        
        
        
        
                
        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",linear,1025_C,CODEFORCES,1872,Plasticine zebra,"Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras. 
Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let's call the number of selected pieces the length of the zebra.
Before assembling the zebra Grisha can make the following operation $$$0$$$ or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order ""bwbbw"" (here 'b' denotes a black strip, and 'w' denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain ""wbwbb"".
Determine the maximum possible length of the zebra that Grisha can produce.
The only line contains a string $$$s$$$ ($$$1 \le |s| \le 10^5$$$, where $$$|s|$$$ denotes the length of the string $$$s$$$) comprised of lowercase English letters 'b' and 'w' only, where 'w' denotes a white piece and 'b' denotes a black piece.
Print a single integer — the maximum possible zebra length.
","input
In the first example one of the possible sequence of operations is bwwwbww|bw $$$\to$$$ w|wbwwwbwb $$$\to$$$ wbwbwwwbw, that gives the answer equal to $$$5$$$.
output
In the second example no operation can increase the answer.
","constructivealgorithms, implementation"
"import sys
input=sys.stdin.readline
s=list(input().rstrip())
n=len(s)
s.extend(s)
cnt=0
c=1
for i in range(len(s)-1):
  if s[i]!=s[i+1]:
    c+=1
  else:
    cnt=max(c,cnt)
    c=1
cnt=max(cnt,c)
print(min(cnt,n))",linear,1025_C,CODEFORCES,1877,Plasticine zebra,"Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras. 
Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let's call the number of selected pieces the length of the zebra.
Before assembling the zebra Grisha can make the following operation $$$0$$$ or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order ""bwbbw"" (here 'b' denotes a black strip, and 'w' denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain ""wbwbb"".
Determine the maximum possible length of the zebra that Grisha can produce.
The only line contains a string $$$s$$$ ($$$1 \le |s| \le 10^5$$$, where $$$|s|$$$ denotes the length of the string $$$s$$$) comprised of lowercase English letters 'b' and 'w' only, where 'w' denotes a white piece and 'b' denotes a black piece.
Print a single integer — the maximum possible zebra length.
","input
In the first example one of the possible sequence of operations is bwwwbww|bw $$$\to$$$ w|wbwwwbwb $$$\to$$$ wbwbwwwbw, that gives the answer equal to $$$5$$$.
output
In the second example no operation can increase the answer.
","constructivealgorithms, implementation"
"s = input()
s = s*3
n = len(s)
m,curr=1,1
for i in range(n-1):
    if s[i]!=s[i+1]:
        curr+=1
        m=max(curr,m)
    else:
        curr=1
print(min(m,n//3))
",linear,1025_C,CODEFORCES,1873,Plasticine zebra,"Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras. 
Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let's call the number of selected pieces the length of the zebra.
Before assembling the zebra Grisha can make the following operation $$$0$$$ or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order ""bwbbw"" (here 'b' denotes a black strip, and 'w' denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain ""wbwbb"".
Determine the maximum possible length of the zebra that Grisha can produce.
The only line contains a string $$$s$$$ ($$$1 \le |s| \le 10^5$$$, where $$$|s|$$$ denotes the length of the string $$$s$$$) comprised of lowercase English letters 'b' and 'w' only, where 'w' denotes a white piece and 'b' denotes a black piece.
Print a single integer — the maximum possible zebra length.
","input
In the first example one of the possible sequence of operations is bwwwbww|bw $$$\to$$$ w|wbwwwbwb $$$\to$$$ wbwbwwwbw, that gives the answer equal to $$$5$$$.
output
In the second example no operation can increase the answer.
","constructivealgorithms, implementation"
"s=list(input())
ans=0
far=0
for i in range(len(s)-1):
    if(s[i]!=s[i+1]):
        far+=1
        continue
    if(s[0]!=s[-1]):
        s[:i+1]=s[:i+1][::-1]
        s[i+1:]=s[i+1:][::-1]
        far+=1
    else:
        ans=max(ans,far+1)
        far=0
    #print(s)
print(max(far+1,ans))
# b w w w b w w b w
",linear,1025_C,CODEFORCES,1876,Plasticine zebra,"Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras. 
Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let's call the number of selected pieces the length of the zebra.
Before assembling the zebra Grisha can make the following operation $$$0$$$ or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order ""bwbbw"" (here 'b' denotes a black strip, and 'w' denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain ""wbwbb"".
Determine the maximum possible length of the zebra that Grisha can produce.
The only line contains a string $$$s$$$ ($$$1 \le |s| \le 10^5$$$, where $$$|s|$$$ denotes the length of the string $$$s$$$) comprised of lowercase English letters 'b' and 'w' only, where 'w' denotes a white piece and 'b' denotes a black piece.
Print a single integer — the maximum possible zebra length.
","input
In the first example one of the possible sequence of operations is bwwwbww|bw $$$\to$$$ w|wbwwwbwb $$$\to$$$ wbwbwwwbw, that gives the answer equal to $$$5$$$.
output
In the second example no operation can increase the answer.
","constructivealgorithms, implementation"
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################

import sys,os,io
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from sys import stdin

import math 



def ncr(n, r, p):  #using fermat's little theorem
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

  
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
          
    for i in range(3,int(math.sqrt(n))+1,2): 
          

        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
    
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 


def si():
    return input()

# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")


# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

# t = int(input())
t = 1
for _ in range(t):
    s = si()
    s = s*3
    m = 0
    c = 1
    for i in range(1,len(s)):
        if (s[i]!=s[i-1]):
            c+=1
        else:
            m = max(m,c)
            c = 1
    m = max(m,c)
    
    m = min(m,len(s)//3)
    print(m)",linear,1025_C,CODEFORCES,1874,Plasticine zebra,"Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras. 
Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let's call the number of selected pieces the length of the zebra.
Before assembling the zebra Grisha can make the following operation $$$0$$$ or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order ""bwbbw"" (here 'b' denotes a black strip, and 'w' denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain ""wbwbb"".
Determine the maximum possible length of the zebra that Grisha can produce.
The only line contains a string $$$s$$$ ($$$1 \le |s| \le 10^5$$$, where $$$|s|$$$ denotes the length of the string $$$s$$$) comprised of lowercase English letters 'b' and 'w' only, where 'w' denotes a white piece and 'b' denotes a black piece.
Print a single integer — the maximum possible zebra length.
","input
In the first example one of the possible sequence of operations is bwwwbww|bw $$$\to$$$ w|wbwwwbwb $$$\to$$$ wbwbwwwbw, that gives the answer equal to $$$5$$$.
output
In the second example no operation can increase the answer.
","constructivealgorithms, implementation"
"def check(st):
    count = 1
    i = 1
    pre = st[0]
    maxi = 0
    pre_indx = 0
    indx = [0 for i in range(n)]
    while i<n:
        if pre != st[i]:
            count+=1
        else:
            indx[pre_indx] =count
            count=1
            pre_indx=i
        pre =st[i]
        i+=1
    indx[pre_indx] =count
    return indx

st=input()
n=len(st)
actual_indx=check(st)
reverse_indx=check(st[::-1])
if st[0] ==st[-1]:
    print(max(actual_indx))
else:
    print(min(n,max(max(actual_indx[1:]),actual_indx[0] +reverse_indx[0])))",linear,1025_C,CODEFORCES,1880,Plasticine zebra,"Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras. 
Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let's call the number of selected pieces the length of the zebra.
Before assembling the zebra Grisha can make the following operation $$$0$$$ or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order ""bwbbw"" (here 'b' denotes a black strip, and 'w' denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain ""wbwbb"".
Determine the maximum possible length of the zebra that Grisha can produce.
The only line contains a string $$$s$$$ ($$$1 \le |s| \le 10^5$$$, where $$$|s|$$$ denotes the length of the string $$$s$$$) comprised of lowercase English letters 'b' and 'w' only, where 'w' denotes a white piece and 'b' denotes a black piece.
Print a single integer — the maximum possible zebra length.
","input
In the first example one of the possible sequence of operations is bwwwbww|bw $$$\to$$$ w|wbwwwbwb $$$\to$$$ wbwbwwwbw, that gives the answer equal to $$$5$$$.
output
In the second example no operation can increase the answer.
","constructivealgorithms, implementation"
"s=input().strip()
s=s+s

n=len(s)
an=1
m=1
#print(s)
for i in range(1,n):
    if s[i]!=s[i-1]:
        m+=1
        an = max(an, m)
    else:
        an = max(an, m)
        m=1
    #print(an)
print(min(an,n//2))",linear,1025_C,CODEFORCES,1875,Plasticine zebra,"Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras. 
Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let's call the number of selected pieces the length of the zebra.
Before assembling the zebra Grisha can make the following operation $$$0$$$ or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order ""bwbbw"" (here 'b' denotes a black strip, and 'w' denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain ""wbwbb"".
Determine the maximum possible length of the zebra that Grisha can produce.
The only line contains a string $$$s$$$ ($$$1 \le |s| \le 10^5$$$, where $$$|s|$$$ denotes the length of the string $$$s$$$) comprised of lowercase English letters 'b' and 'w' only, where 'w' denotes a white piece and 'b' denotes a black piece.
Print a single integer — the maximum possible zebra length.
","input
In the first example one of the possible sequence of operations is bwwwbww|bw $$$\to$$$ w|wbwwwbwb $$$\to$$$ wbwbwwwbw, that gives the answer equal to $$$5$$$.
output
In the second example no operation can increase the answer.
","constructivealgorithms, implementation"
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

#?############################################################


def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

#?############################################################


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p


#?############################################################

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))


#?############################################################

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

#?############################################################


def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime


#?############################################################

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

#?############################################################


def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

#?############################################################


def mapin():
    return map(int, input().split())

#?############################################################


# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
# python3 15.py<in>

s = list(input())
n = len(s)
l = [1]
for i in range(n-1):
    if(s[i]!= s[i+1]):
        l[-1]+=1
    else:
        l.append(1)

ans = max(l)
if(len(l)>1):
    if(s[0]!= s[-1]):
        ans = max(ans, l[0]+l[-1])
# print(l)
print(ans)

    



",linear,1025_C,CODEFORCES,1879,Plasticine zebra,"Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras. 
Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let's call the number of selected pieces the length of the zebra.
Before assembling the zebra Grisha can make the following operation $$$0$$$ or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order ""bwbbw"" (here 'b' denotes a black strip, and 'w' denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain ""wbwbb"".
Determine the maximum possible length of the zebra that Grisha can produce.
The only line contains a string $$$s$$$ ($$$1 \le |s| \le 10^5$$$, where $$$|s|$$$ denotes the length of the string $$$s$$$) comprised of lowercase English letters 'b' and 'w' only, where 'w' denotes a white piece and 'b' denotes a black piece.
Print a single integer — the maximum possible zebra length.
","input
In the first example one of the possible sequence of operations is bwwwbww|bw $$$\to$$$ w|wbwwwbwb $$$\to$$$ wbwbwwwbw, that gives the answer equal to $$$5$$$.
output
In the second example no operation can increase the answer.
","constructivealgorithms, implementation"
"from collections import defaultdict
from collections import deque
import sys
input = sys.stdin.readline

def bfs(s):
    q = deque()
    q.append(s)
    dist = [-1] * (n + 1)
    dist[s] = 0
    p = []
    parent = [1] * (n + 1)
    ok = [0] * (n + 1)
    while q:
        i = q.popleft()
        d = dist[i]
        if d < 3:
            ok[i] = 1
        p.append(i)
        for j in G[i]:
            if dist[j] == -1:
                q.append(j)
                dist[j] = d + 1
                parent[j] = i
    ans = 0
    while p:
        i = p.pop()
        j = parent[i]
        if not ok[i]:
            ok[j] = 1
            ans += 1
            for k in G[j]:
                ok[k] = 1
    return ans

n = int(input())
G = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)
ans = bfs(1)
print(ans)",linear,1029_E,CODEFORCES,1897,Tree with Small Distances,"You are given an undirected tree consisting of $$$n$$$ vertices. An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Your task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex $$$1$$$ to any other vertex is at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — the number of vertices in the tree.
The following $$$n - 1$$$ lines contain edges: edge $$$i$$$ is given as a pair of vertices $$$u_i, v_i$$$ ($$$1 \le u_i, v_i \le n$$$). It is guaranteed that the given edges form a tree. It is guaranteed that there are no loops and multiple edges in the given edges.
Print a single integer — the minimum number of edges you have to add in order to make the shortest distance from the vertex $$$1$$$ to any other vertex at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The tree corresponding to the first example:  The answer is $$$2$$$, some of the possible answers are the following: $$$[(1, 5), (1, 6)]$$$, $$$[(1, 4), (1, 7)]$$$, $$$[(1, 6), (1, 7)]$$$.
","input
The tree corresponding to the second example:  The answer is $$$0$$$.
output
The tree corresponding to the third example:  The answer is $$$1$$$, only one possible way to reach it is to add the edge $$$(1, 3)$$$.
","dp, graphs, greedy"
"from sys import stdin
n = int(stdin.readline())
g = dict()
for i in range(n-1):
    u,v = map(int,stdin.readline().split())
    g.setdefault(u-1,[]).append(v-1)
    g.setdefault(v-1, []).append(u-1)
st = [0]
rank = [0]*n
tree = [0]*n
msk = [0]*n
rd = dict()
while len(st)>0:
    top = st.pop()
    msk[top] = 1
    for c in g[top]:
        if msk[c] == 0:
            st.append(c)
            tree[c] = top
            rank[c] = rank[top]+1
            rd.setdefault(rank[c], []).append(c)
max_rank = max(rank)
reach = [0]*n
build = [0]*n
ans = 0
for r in range(max_rank, 2, -1):
    for node in rd[r]:
        if reach[node] == 0:
            reach[node] = 1
            reach[tree[node]] = 1
            reach[tree[tree[node]]] = 1
            build[tree[node]] = 1
print(sum(build))",linear,1029_E,CODEFORCES,1898,Tree with Small Distances,"You are given an undirected tree consisting of $$$n$$$ vertices. An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Your task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex $$$1$$$ to any other vertex is at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — the number of vertices in the tree.
The following $$$n - 1$$$ lines contain edges: edge $$$i$$$ is given as a pair of vertices $$$u_i, v_i$$$ ($$$1 \le u_i, v_i \le n$$$). It is guaranteed that the given edges form a tree. It is guaranteed that there are no loops and multiple edges in the given edges.
Print a single integer — the minimum number of edges you have to add in order to make the shortest distance from the vertex $$$1$$$ to any other vertex at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The tree corresponding to the first example:  The answer is $$$2$$$, some of the possible answers are the following: $$$[(1, 5), (1, 6)]$$$, $$$[(1, 4), (1, 7)]$$$, $$$[(1, 6), (1, 7)]$$$.
","input
The tree corresponding to the second example:  The answer is $$$0$$$.
output
The tree corresponding to the third example:  The answer is $$$1$$$, only one possible way to reach it is to add the edge $$$(1, 3)$$$.
","dp, graphs, greedy"
"
import sys

def get_new_edges(graph):
    n = len(graph)
    far_vertex = []
    pi = [None]*n
    visit = [False]*n
    visit[0]
    queue = [[0,0]]
    i = 0    
    while True:
        if i >= len(queue): break
        current, d = queue[i]
        i += 1
        visit[current] = True
        for v in graph[current]:
            if not visit[v]:
                u = [v, d+1]
                pi[v] = current
                queue.append(u)
                if d+1 > 2:
                    far_vertex.append(u)
    
    far_vertex.sort(key=lambda x: -x[1])

    pos = [None]*n
    for i, e in enumerate(far_vertex):
        pos[e[0]] = i

    count = 0
    for i in range(len(far_vertex)):
        if not far_vertex[i]: continue
        vertex, depth = far_vertex[i]
        father = pi[vertex]
        count += 1
        if pos[father]:
            far_vertex[pos[father]] = None
        for u in graph[father]:
            if pos[u]:
                far_vertex[pos[u]] = None

    return count
    
def read_int_line():
    return map(int, sys.stdin.readline().split())

vertex_count = int(input())
graph = [[] for _ in range(vertex_count)]

for i in range(vertex_count - 1):
    v1, v2 = read_int_line()
    v1 -= 1
    v2 -= 1
    graph[v1].append(v2)
    graph[v2].append(v1)

print(get_new_edges(graph))


    
",linear,1029_E,CODEFORCES,1901,Tree with Small Distances,"You are given an undirected tree consisting of $$$n$$$ vertices. An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Your task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex $$$1$$$ to any other vertex is at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — the number of vertices in the tree.
The following $$$n - 1$$$ lines contain edges: edge $$$i$$$ is given as a pair of vertices $$$u_i, v_i$$$ ($$$1 \le u_i, v_i \le n$$$). It is guaranteed that the given edges form a tree. It is guaranteed that there are no loops and multiple edges in the given edges.
Print a single integer — the minimum number of edges you have to add in order to make the shortest distance from the vertex $$$1$$$ to any other vertex at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The tree corresponding to the first example:  The answer is $$$2$$$, some of the possible answers are the following: $$$[(1, 5), (1, 6)]$$$, $$$[(1, 4), (1, 7)]$$$, $$$[(1, 6), (1, 7)]$$$.
","input
The tree corresponding to the second example:  The answer is $$$0$$$.
output
The tree corresponding to the third example:  The answer is $$$1$$$, only one possible way to reach it is to add the edge $$$(1, 3)$$$.
","dp, graphs, greedy"
"import sys
from collections import deque
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))

n = inp()
edges = [[] for _ in range(n)]
for _ in range(n-1):
    a,b = inpl()
    a,b = a-1,b-1
    edges[a].append(b)
    edges[b].append(a)
dist = [-1] * n
dist[0] = 0
pa = [-1] * n
se = set()
pq = []
q = deque()
q.append(0)
while q:
    now = q.popleft()
    for nx in edges[now]:
        if dist[nx] != -1:
            continue
        pa[nx] = now
        dist[nx] = dist[now] + 1
        if dist[nx] > 2:
            se.add(nx)
            pq.append((dist[nx], nx))
        q.append(nx)
pq = pq[::-1]
res = 0
ind = 0
while se:
    d,v = pq[ind]
    ind += 1
    if not v in se: 
        continue
    res += 1
    pv = pa[v]
    se.discard(pv)
    for nv in edges[pv]:
        se.discard(nv)
print(res)",linear,1029_E,CODEFORCES,1900,Tree with Small Distances,"You are given an undirected tree consisting of $$$n$$$ vertices. An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Your task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex $$$1$$$ to any other vertex is at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — the number of vertices in the tree.
The following $$$n - 1$$$ lines contain edges: edge $$$i$$$ is given as a pair of vertices $$$u_i, v_i$$$ ($$$1 \le u_i, v_i \le n$$$). It is guaranteed that the given edges form a tree. It is guaranteed that there are no loops and multiple edges in the given edges.
Print a single integer — the minimum number of edges you have to add in order to make the shortest distance from the vertex $$$1$$$ to any other vertex at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The tree corresponding to the first example:  The answer is $$$2$$$, some of the possible answers are the following: $$$[(1, 5), (1, 6)]$$$, $$$[(1, 4), (1, 7)]$$$, $$$[(1, 6), (1, 7)]$$$.
","input
The tree corresponding to the second example:  The answer is $$$0$$$.
output
The tree corresponding to the third example:  The answer is $$$1$$$, only one possible way to reach it is to add the edge $$$(1, 3)$$$.
","dp, graphs, greedy"
"import sys
from collections import deque
import heapq
input = sys.stdin.readline

N=int(input())
EDGE=[list(map(int,input().split())) for i in range(N-1)]

EDGELIST=[[] for i in range(N+1)]

for i,j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)

#EDGES=[[] for i in range(N+1)]
REDG=[None for i in range(N+1)]
QUE=deque([1])
check=[0]*(N+1)
DEPTH=[None]*(N+1)
i=0
while QUE:
    NQUE=deque()
    i+=1
    
    while QUE:
        x=QUE.pop()
        DEPTH[x]=i
        check[x]=1
        for to in EDGELIST[x]:
            if check[to]==1:
                continue
            else:
                #EDGES[x].append(to)
                REDG[to]=x
                NQUE.append(to)
    QUE=NQUE


check=[0]*(N+1)
check[1]=1
#NEXT=[]

#for i in EDGES[1]:
#    check[i]=1
#    NEXT.append(i)

#for j in NEXT:
#    for k in EDGES[j]:
#        check[k]=1


LEAF=[]
for i in range(2,N+1):
    if len(EDGELIST[i])==1:
        LEAF.append((-DEPTH[i],i))

QUE=LEAF
heapq.heapify(QUE)
ANS=0

#print(check,QUE)

while QUE:
    dep,x=heapq.heappop(QUE)
    if check[x]!=0 or dep>=-3:
        continue

    if check[REDG[x]]==2:
        continue

    if check[x]==0:
        check[x]=1
    if check[REDG[REDG[x]]]==0:
        check[REDG[REDG[x]]]=1
    check[REDG[x]]=2   
    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))
    ANS+=1

    #print(x,QUE,check)

print(ANS)



",linear,1029_E,CODEFORCES,1899,Tree with Small Distances,"You are given an undirected tree consisting of $$$n$$$ vertices. An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Your task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex $$$1$$$ to any other vertex is at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — the number of vertices in the tree.
The following $$$n - 1$$$ lines contain edges: edge $$$i$$$ is given as a pair of vertices $$$u_i, v_i$$$ ($$$1 \le u_i, v_i \le n$$$). It is guaranteed that the given edges form a tree. It is guaranteed that there are no loops and multiple edges in the given edges.
Print a single integer — the minimum number of edges you have to add in order to make the shortest distance from the vertex $$$1$$$ to any other vertex at most $$$2$$$. Note that you are not allowed to add loops and multiple edges.
The tree corresponding to the first example:  The answer is $$$2$$$, some of the possible answers are the following: $$$[(1, 5), (1, 6)]$$$, $$$[(1, 4), (1, 7)]$$$, $$$[(1, 6), (1, 7)]$$$.
","input
The tree corresponding to the second example:  The answer is $$$0$$$.
output
The tree corresponding to the third example:  The answer is $$$1$$$, only one possible way to reach it is to add the edge $$$(1, 3)$$$.
","dp, graphs, greedy"
"import sys
import os

def solve(slimes):
    if len(slimes) == 1:
        return slimes[0]

    havePos = False
    haveNeg = False

    for s in slimes:
        if s > 0:
            havePos = True
        elif s < 0:
            haveNeg = True

    if havePos and haveNeg:
        return sum(map(abs, slimes))
    elif not havePos:
        m = max(slimes)
        return sum(list(map(abs, slimes))) + 2 * m
    elif not haveNeg:
        m = min(slimes)
        return sum(list(map(abs, slimes))) - 2 * m
    else:
        return 0

def main():
    n = int(input())
    slimes = list(map(int, input().split()))
    print(solve(slimes))


if __name__ == '__main__':
    main()",linear,1038_D,CODEFORCES,1945,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"#Problem D: Slime

n = int(input())

a = input().split()

for i in range(n):
    a[i] = int(a[i])

if(n==1):
    print(a[0]) #Obvious Case
else:
    sm = 0
    havePositive = False
    haveNegative = False

    for c in a:
        if(c==0):
            haveNegative = True
            havePositive = True
        elif(c>0):
            havePositive = True
            sm += c
        else:
            haveNegative = True
            sm -= c

    if(haveNegative and havePositive):
        print(sm) #Final Answer
    else:
        for i in range(n):
            a[i] = abs(a[i])
        #Get the minimum
        ans = sum(a)
        low = a[0]
        for c in a:
            low = min(low,c)
        #Final Answer
        print(ans-2*low)
",linear,1038_D,CODEFORCES,1946,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"n = int(input())
arr = list(map(int, input().strip().split()))
k = min(arr)
h = max(arr)
s = 0
for i in arr:
    if i >= 0:
        s += i
    else:
        s -= i

if n == 1:
    print(arr[0])
elif ((k < 0 and h >= 0)):
    print(s)
else:
    if (k >= 0):
        print(s - 2 * k)
    else:
        print(s + 2 * h)",linear,1038_D,CODEFORCES,1948,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"#from random import random, randint
#from sys import stdout

#n, k = map(int, input().split())
n = int(input())

if n==1:
    a = input()
    print(a)
else:    
    a = list(map(int, input().split()))
    b = [abs(i) for i in a]
    if min(a)*max(a) > 0:
        print(sum(b)-2*min(b))
    else:
        print(sum(b))
",linear,1038_D,CODEFORCES,1950,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
b = [abs(x) for x in a] 
if n == 1:
    ans = a[0]
elif all(x > 0 for x in a) or all(x < 0 for x in a):
    b.sort()
    ans = sum(b) - 2 * b[0]
else:
    ans = sum(b)
print(ans)
",nlogn,1038_D,CODEFORCES,2812,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"n=int(input())
A=list(map(int,input().split()))

if n==1:
    print(A[0])

elif n==2:
    print(abs(A[0]-A[1]))

else:
    SUM=0
    for i in range(n):
        SUM+=abs(A[i])
    ANS=0

    for i in range(n-1):
        if ANS<SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1]):
            ANS=SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1])

    print(ANS)
",linear,1038_D,CODEFORCES,1947,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"n = int(input())
xs = [int(x) for x in input().split()]
prefix = [-1 for i in range(n)]
suffix = [-1 for i in range(n)]
prefix[0] = 0
pre_has_neg = [False for i in range(n)]
suffix[-1] = 0
suf_has_neg = [False for i in range(n)]
for i in range(n):
	if i == 0:
		prefix[i] = xs[i]
	else:
		prefix[i] = prefix[i-1] + xs[i]
for i in reversed(range(n)):
	if i == n-1:
		suffix[i] = xs[i]
	else:
		suffix[i] = suffix[i+1] + xs[i]
for i in range(n):
	if i == 0:
		pre_has_neg[i] = xs[i] <= 0
	else:
		pre_has_neg[i] = pre_has_neg[i-1] or xs[i] <= 0
for i in reversed(range(n)):
	if i == n-1:
		suf_has_neg[i] = xs[i] <= 0
	else:
		suf_has_neg[i] = suf_has_neg[i+1] or xs[i] <= 0

prebignum = [None for i in range(n)]
sufbignum = [None for i in range(n)]
for i in range(n):
	if i == 0:
		prebignum[i] = xs[i]
	else:
		prebignum[i] = min(prebignum[i-1], xs[i])
for i in reversed(range(n)):
	if i == n-1:
		sufbignum[i] = xs[i]
	else:
		sufbignum[i] = min(sufbignum[i+1], xs[i])

neg_pre = [100000 for i in range(n)]
neg_suf = [100000 for i in range(n)]

for i in range(n):
	if i == 0:
		neg_pre[i] = min(xs[i], -xs[i])
	else:
		neg_pre[i] = neg_pre[i-1] + min(xs[i], -xs[i])

for i in reversed(range(n)):
	if i == n-1:
		neg_suf[i] = min(xs[i], -xs[i])
	else:
		neg_suf[i] = neg_suf[i+1] + min(xs[i], -xs[i])

ans = -100000000000000000
for i in range(n):
	#print(i, ""----"")
	tans = xs[i]
	if i == 0:
		pass
	elif pre_has_neg[i-1]:
		tans -= neg_pre[i-1]
	else:
		tans += prefix[i-1]
		tans -= prebignum[i-1]*2

	if i == n-1:
		pass
	elif suf_has_neg[i+1]:
		tans -= neg_suf[i+1]
	else:
		tans += suffix[i+1]
		tans -= sufbignum[i+1]*2
		#print(suffix[i+1], sufbignum[i+1])
	ans = max(ans, tans)

print(ans)",linear,1038_D,CODEFORCES,1949,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"n = int(input())
a = list(map(int, input().split()))
if n == 1:
	print(a[0])
else:
	prod_minus = False
	for i in range(n - 1):
		if a[i] * a[i + 1] <= 0:
			prod_minus = True
			break
	Min_abs = float(""inf"")
	Sum = 0
	for num in a:
		Sum += abs(num)
		if abs(num) < Min_abs:
			Min_abs = abs(num)

	if prod_minus:
		print(Sum)
	else:
		print(Sum - 2 * Min_abs)",linear,1038_D,CODEFORCES,1943,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"import sys
import string


def ria():
    return [int(i) for i in input().split()]


n = ria()[0]
ar = ria()

if n == 1:
    print(ar[0])
    exit(0)

onlyNegs = True
onlyPos = True

if max(ar) >= 0:
    onlyNegs = False
if min(ar) <= 0:
    onlyPos = False

if onlyNegs:
    print(abs(sum(ar)) + max(ar) * 2)
    exit(0)

if onlyPos:
    print(abs(sum(ar)) - min(ar) * 2)
    exit(0)

print(sum([abs(i) for i in ar]))
",linear,1038_D,CODEFORCES,1942,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()

za = getIntList()
if N==1:
    print(za[0])
    sys.exit()
t1 = max(za)
t2 = min(za)
if t2>=0:
    print(sum(za) - 2*t2)
    sys.exit()
if t1<=0:
    print(2*t1 - sum(za))
    sys.exit()

res = 0
for x in za:
    res+= abs(x)

print(res)







",linear,1038_D,CODEFORCES,1944,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"if input()=='1':
 print(input())
else:
 x,*a,y=sorted(map(int,input().split()))
 print(y-x+sum(map(abs,a)))",nlogn,1038_D,CODEFORCES,2811,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation"
"def add(num):
    if(num<=1):
        return 0
    return (num*(num-1))//2
    
    
n,k=map(int,input().split())

a=list(map(int,input().split()))
pre=[a[0]]
base=(2**(k))-1
hb=2**(k-1)
for i in range(1,n):
    pre.append(a[i]^pre[-1])
    
cnt=dict()
cnt[0]=[0,0]

for i in range(n):
    if(pre[i]>=hb):
        if(base-pre[i] not in cnt):
            cnt[base-pre[i]]=[0,0]
        cnt[base-pre[i]][1]+=1
    else:
        if(pre[i] not in cnt):
            cnt[pre[i]]=[0,0]
        cnt[pre[i]][0]+=1
cnt1=0
#print(pre)
#print(cnt)
for i in cnt.values():
    sum1=i[0]+i[1]
    cnt1+=add(sum1//2)
    cnt1+=add((sum1+1)//2)
cnt1+=sum(cnt[0])//2
#print(cnt1)
print((n*(n+1))//2 - cnt1)
    
    

    
",linear,1054_D,CODEFORCES,1965,Changing Array,"At a break Vanya came to the class and saw an array of $$$n$$$ $$$k$$$-bit integers $$$a_1, a_2, \ldots, a_n$$$ on the board. An integer $$$x$$$ is called a $$$k$$$-bit integer if $$$0 \leq x \leq 2^k - 1$$$. 
Of course, Vanya was not able to resist and started changing the numbers written on the board. To ensure that no one will note anything, Vanya allowed himself to make only one type of changes: choose an index of the array $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the number $$$a_i$$$ with the number $$$\overline{a_i}$$$. We define $$$\overline{x}$$$ for a $$$k$$$-bit integer $$$x$$$ as the $$$k$$$-bit integer such that all its $$$k$$$ bits differ from the corresponding bits of $$$x$$$. 
Vanya does not like the number $$$0$$$. Therefore, he likes such segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$) such that $$$a_l \oplus a_{l+1} \oplus \ldots \oplus a_r \neq 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Determine the maximum number of segments he likes Vanya can get applying zero or more operations described above.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 200\,000$$$, $$$1 \leq k \leq 30$$$).
The next line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 2^k - 1$$$), separated by spaces — the array of $$$k$$$-bit integers.
Print one integer — the maximum possible number of segments with XOR not equal to $$$0$$$ that can be obtained by making several (possibly $$$0$$$) operations described in the statement.
","input
In the first example if Vasya does not perform any operations, he gets an array that has $$$5$$$ segments that Vanya likes. If he performs the operation with $$$i = 2$$$, he gets an array $$$[1, 0, 0]$$$, because $$$\overline{3} = 0$$$ when $$$k = 2$$$. This array has $$$3$$$ segments that Vanya likes. Also, to get an array with $$$5$$$ segments that Vanya likes, he can perform two operations with $$$i = 3$$$ and with $$$i = 2$$$. He then gets an array $$$[1, 0, 3]$$$. It can be proven that he can't obtain $$$6$$$ or more segments that he likes.
output
In the second example, to get $$$19$$$ segments that Vanya likes, he can perform $$$4$$$ operations with $$$i = 3$$$, $$$i = 4$$$, $$$i = 5$$$, $$$i = 6$$$ and get an array $$$[1, 4, 3, 0, 4, 3]$$$.
","greedy, implementation"
"from collections import defaultdict
n,k = map(int,input().split())
arr = list(map(int,input().split()))
xors = defaultdict(int)
xors[0]=1
comp = (1<<k)-1
ans = n*(n+1)//2
xor = 0
for a in arr:
	xor^=a
	if xors[xor]>xors[comp^xor]:
		xor^=comp
	ans-=xors[xor]
	xors[xor]+=1
print(ans)",linear,1054_D,CODEFORCES,1966,Changing Array,"At a break Vanya came to the class and saw an array of $$$n$$$ $$$k$$$-bit integers $$$a_1, a_2, \ldots, a_n$$$ on the board. An integer $$$x$$$ is called a $$$k$$$-bit integer if $$$0 \leq x \leq 2^k - 1$$$. 
Of course, Vanya was not able to resist and started changing the numbers written on the board. To ensure that no one will note anything, Vanya allowed himself to make only one type of changes: choose an index of the array $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the number $$$a_i$$$ with the number $$$\overline{a_i}$$$. We define $$$\overline{x}$$$ for a $$$k$$$-bit integer $$$x$$$ as the $$$k$$$-bit integer such that all its $$$k$$$ bits differ from the corresponding bits of $$$x$$$. 
Vanya does not like the number $$$0$$$. Therefore, he likes such segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$) such that $$$a_l \oplus a_{l+1} \oplus \ldots \oplus a_r \neq 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Determine the maximum number of segments he likes Vanya can get applying zero or more operations described above.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 200\,000$$$, $$$1 \leq k \leq 30$$$).
The next line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 2^k - 1$$$), separated by spaces — the array of $$$k$$$-bit integers.
Print one integer — the maximum possible number of segments with XOR not equal to $$$0$$$ that can be obtained by making several (possibly $$$0$$$) operations described in the statement.
","input
In the first example if Vasya does not perform any operations, he gets an array that has $$$5$$$ segments that Vanya likes. If he performs the operation with $$$i = 2$$$, he gets an array $$$[1, 0, 0]$$$, because $$$\overline{3} = 0$$$ when $$$k = 2$$$. This array has $$$3$$$ segments that Vanya likes. Also, to get an array with $$$5$$$ segments that Vanya likes, he can perform two operations with $$$i = 3$$$ and with $$$i = 2$$$. He then gets an array $$$[1, 0, 3]$$$. It can be proven that he can't obtain $$$6$$$ or more segments that he likes.
output
In the second example, to get $$$19$$$ segments that Vanya likes, he can perform $$$4$$$ operations with $$$i = 3$$$, $$$i = 4$$$, $$$i = 5$$$, $$$i = 6$$$ and get an array $$$[1, 4, 3, 0, 4, 3]$$$.
","greedy, implementation"
"from collections import defaultdict
n,k=map(int,input().split())
arr=list(map(int,input().split()))
xors=defaultdict(int)
xors[0]=1
comp=(1<<k)-1
xor=0
ans=n*(n+1)//2
for a in arr:
    xor^=a
    if(xors[xor]>xors[comp^xor]):
        xor^=comp
    ans-=xors[xor]
    xors[xor]+=1
print(ans)",linear,1054_D,CODEFORCES,1961,Changing Array,"At a break Vanya came to the class and saw an array of $$$n$$$ $$$k$$$-bit integers $$$a_1, a_2, \ldots, a_n$$$ on the board. An integer $$$x$$$ is called a $$$k$$$-bit integer if $$$0 \leq x \leq 2^k - 1$$$. 
Of course, Vanya was not able to resist and started changing the numbers written on the board. To ensure that no one will note anything, Vanya allowed himself to make only one type of changes: choose an index of the array $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the number $$$a_i$$$ with the number $$$\overline{a_i}$$$. We define $$$\overline{x}$$$ for a $$$k$$$-bit integer $$$x$$$ as the $$$k$$$-bit integer such that all its $$$k$$$ bits differ from the corresponding bits of $$$x$$$. 
Vanya does not like the number $$$0$$$. Therefore, he likes such segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$) such that $$$a_l \oplus a_{l+1} \oplus \ldots \oplus a_r \neq 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Determine the maximum number of segments he likes Vanya can get applying zero or more operations described above.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 200\,000$$$, $$$1 \leq k \leq 30$$$).
The next line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 2^k - 1$$$), separated by spaces — the array of $$$k$$$-bit integers.
Print one integer — the maximum possible number of segments with XOR not equal to $$$0$$$ that can be obtained by making several (possibly $$$0$$$) operations described in the statement.
","input
In the first example if Vasya does not perform any operations, he gets an array that has $$$5$$$ segments that Vanya likes. If he performs the operation with $$$i = 2$$$, he gets an array $$$[1, 0, 0]$$$, because $$$\overline{3} = 0$$$ when $$$k = 2$$$. This array has $$$3$$$ segments that Vanya likes. Also, to get an array with $$$5$$$ segments that Vanya likes, he can perform two operations with $$$i = 3$$$ and with $$$i = 2$$$. He then gets an array $$$[1, 0, 3]$$$. It can be proven that he can't obtain $$$6$$$ or more segments that he likes.
output
In the second example, to get $$$19$$$ segments that Vanya likes, he can perform $$$4$$$ operations with $$$i = 3$$$, $$$i = 4$$$, $$$i = 5$$$, $$$i = 6$$$ and get an array $$$[1, 4, 3, 0, 4, 3]$$$.
","greedy, implementation"
"from math import *
#n,k=map(int,input().split())
#A = list(map(int,input().split()))
n,k = map(int,input().split())
ans = [0] * n
#^xor
lul = 2**k - 1
A = list(map(int,input().split()))
ans[0]  = A[0]
for j in range(1, n):
    ans[j] = ans[j-1]^A[j]
#print(ans)
d = dict()
for j in range(n):
    if ans[j] in d:
        d[ans[j]]+=1;
    else:
        d[ans[j]] = 1
#print(d)
ans =0
def huy(n):
    return n*(n-1)//2
for j in d:
    now = d[j]
    #print(d[j],j)
    xor = lul^j
    cur = now

    if xor in d :

        now2 = d[xor]
        #print(now,xor)
        cur += now2



        ans += huy(cur//2+cur%2)
        ans+=huy(cur//2)
        if j ==0:
            ans+=2*(cur//2)
    else:
        if(j==0 or xor ==0):
            ans+= 2*(cur//2)
        ans += 2*huy(cur // 2 + cur % 2)
        ans += 2*huy(cur // 2)
print(huy(n+1) - ans//2)",linear,1054_D,CODEFORCES,1964,Changing Array,"At a break Vanya came to the class and saw an array of $$$n$$$ $$$k$$$-bit integers $$$a_1, a_2, \ldots, a_n$$$ on the board. An integer $$$x$$$ is called a $$$k$$$-bit integer if $$$0 \leq x \leq 2^k - 1$$$. 
Of course, Vanya was not able to resist and started changing the numbers written on the board. To ensure that no one will note anything, Vanya allowed himself to make only one type of changes: choose an index of the array $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the number $$$a_i$$$ with the number $$$\overline{a_i}$$$. We define $$$\overline{x}$$$ for a $$$k$$$-bit integer $$$x$$$ as the $$$k$$$-bit integer such that all its $$$k$$$ bits differ from the corresponding bits of $$$x$$$. 
Vanya does not like the number $$$0$$$. Therefore, he likes such segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$) such that $$$a_l \oplus a_{l+1} \oplus \ldots \oplus a_r \neq 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Determine the maximum number of segments he likes Vanya can get applying zero or more operations described above.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 200\,000$$$, $$$1 \leq k \leq 30$$$).
The next line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 2^k - 1$$$), separated by spaces — the array of $$$k$$$-bit integers.
Print one integer — the maximum possible number of segments with XOR not equal to $$$0$$$ that can be obtained by making several (possibly $$$0$$$) operations described in the statement.
","input
In the first example if Vasya does not perform any operations, he gets an array that has $$$5$$$ segments that Vanya likes. If he performs the operation with $$$i = 2$$$, he gets an array $$$[1, 0, 0]$$$, because $$$\overline{3} = 0$$$ when $$$k = 2$$$. This array has $$$3$$$ segments that Vanya likes. Also, to get an array with $$$5$$$ segments that Vanya likes, he can perform two operations with $$$i = 3$$$ and with $$$i = 2$$$. He then gets an array $$$[1, 0, 3]$$$. It can be proven that he can't obtain $$$6$$$ or more segments that he likes.
output
In the second example, to get $$$19$$$ segments that Vanya likes, he can perform $$$4$$$ operations with $$$i = 3$$$, $$$i = 4$$$, $$$i = 5$$$, $$$i = 6$$$ and get an array $$$[1, 4, 3, 0, 4, 3]$$$.
","greedy, implementation"
"from collections import defaultdict
n, k = map(int, input().split())
a = [0] + list(map(int, input().split()))
h = defaultdict(int)
for i in range(n):
	a[i + 1] ^= a[i]
for i in range(n + 1):
	h[min(a[i] ^ ((1 << k) - 1), a[i])] += 1
ans = 0
for x, t in h.items():
	a = t // 2
	b = t - a
	ans += a * (a - 1) // 2 + b * (b - 1) // 2
ans = (n * (n + 1)) // 2 - ans
print(ans)
",linear,1054_D,CODEFORCES,1962,Changing Array,"At a break Vanya came to the class and saw an array of $$$n$$$ $$$k$$$-bit integers $$$a_1, a_2, \ldots, a_n$$$ on the board. An integer $$$x$$$ is called a $$$k$$$-bit integer if $$$0 \leq x \leq 2^k - 1$$$. 
Of course, Vanya was not able to resist and started changing the numbers written on the board. To ensure that no one will note anything, Vanya allowed himself to make only one type of changes: choose an index of the array $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the number $$$a_i$$$ with the number $$$\overline{a_i}$$$. We define $$$\overline{x}$$$ for a $$$k$$$-bit integer $$$x$$$ as the $$$k$$$-bit integer such that all its $$$k$$$ bits differ from the corresponding bits of $$$x$$$. 
Vanya does not like the number $$$0$$$. Therefore, he likes such segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$) such that $$$a_l \oplus a_{l+1} \oplus \ldots \oplus a_r \neq 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Determine the maximum number of segments he likes Vanya can get applying zero or more operations described above.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 200\,000$$$, $$$1 \leq k \leq 30$$$).
The next line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 2^k - 1$$$), separated by spaces — the array of $$$k$$$-bit integers.
Print one integer — the maximum possible number of segments with XOR not equal to $$$0$$$ that can be obtained by making several (possibly $$$0$$$) operations described in the statement.
","input
In the first example if Vasya does not perform any operations, he gets an array that has $$$5$$$ segments that Vanya likes. If he performs the operation with $$$i = 2$$$, he gets an array $$$[1, 0, 0]$$$, because $$$\overline{3} = 0$$$ when $$$k = 2$$$. This array has $$$3$$$ segments that Vanya likes. Also, to get an array with $$$5$$$ segments that Vanya likes, he can perform two operations with $$$i = 3$$$ and with $$$i = 2$$$. He then gets an array $$$[1, 0, 3]$$$. It can be proven that he can't obtain $$$6$$$ or more segments that he likes.
output
In the second example, to get $$$19$$$ segments that Vanya likes, he can perform $$$4$$$ operations with $$$i = 3$$$, $$$i = 4$$$, $$$i = 5$$$, $$$i = 6$$$ and get an array $$$[1, 4, 3, 0, 4, 3]$$$.
","greedy, implementation"
"n, k = [int(i) for i in input().split()]
d = dict()
d[0] = 1
x = 0
for i in [int(i) for i in input().split()]:
    x ^= i
    v = min(x, (1 << k) - x - 1)
    if v not in d.keys():
        d[v] = 0
    d[v] += 1
ans = 0
for k, v in d.items():
    c1 = v // 2
    c2 = v - c1
    ans += c1 * (c1 - 1) // 2 + c2 * (c2 - 1) // 2
print(n * (n - 1) // 2 + n - ans)
",linear,1054_D,CODEFORCES,1967,Changing Array,"At a break Vanya came to the class and saw an array of $$$n$$$ $$$k$$$-bit integers $$$a_1, a_2, \ldots, a_n$$$ on the board. An integer $$$x$$$ is called a $$$k$$$-bit integer if $$$0 \leq x \leq 2^k - 1$$$. 
Of course, Vanya was not able to resist and started changing the numbers written on the board. To ensure that no one will note anything, Vanya allowed himself to make only one type of changes: choose an index of the array $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the number $$$a_i$$$ with the number $$$\overline{a_i}$$$. We define $$$\overline{x}$$$ for a $$$k$$$-bit integer $$$x$$$ as the $$$k$$$-bit integer such that all its $$$k$$$ bits differ from the corresponding bits of $$$x$$$. 
Vanya does not like the number $$$0$$$. Therefore, he likes such segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$) such that $$$a_l \oplus a_{l+1} \oplus \ldots \oplus a_r \neq 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Determine the maximum number of segments he likes Vanya can get applying zero or more operations described above.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 200\,000$$$, $$$1 \leq k \leq 30$$$).
The next line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 2^k - 1$$$), separated by spaces — the array of $$$k$$$-bit integers.
Print one integer — the maximum possible number of segments with XOR not equal to $$$0$$$ that can be obtained by making several (possibly $$$0$$$) operations described in the statement.
","input
In the first example if Vasya does not perform any operations, he gets an array that has $$$5$$$ segments that Vanya likes. If he performs the operation with $$$i = 2$$$, he gets an array $$$[1, 0, 0]$$$, because $$$\overline{3} = 0$$$ when $$$k = 2$$$. This array has $$$3$$$ segments that Vanya likes. Also, to get an array with $$$5$$$ segments that Vanya likes, he can perform two operations with $$$i = 3$$$ and with $$$i = 2$$$. He then gets an array $$$[1, 0, 3]$$$. It can be proven that he can't obtain $$$6$$$ or more segments that he likes.
output
In the second example, to get $$$19$$$ segments that Vanya likes, he can perform $$$4$$$ operations with $$$i = 3$$$, $$$i = 4$$$, $$$i = 5$$$, $$$i = 6$$$ and get an array $$$[1, 4, 3, 0, 4, 3]$$$.
","greedy, implementation"
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(200001)] 
pp=[0]*200001
def SieveOfEratosthenes(n=200000): 
      
    # Create a boolean array ""prime[0..n]"" and initialize 
    #  all entries it as true. A value in prime[i] will 
    # finally be false if i is Not a prime, else true. 
    
    p = 2
    while (p * p <= n): 
          
        # If prime[p] is not changed, then it is a prime 
        if (prime[p] == True): 
              
            # Update all multiples of p 
            for i in range(p * p, n+1, p): 
                prime[i] = False
        p += 1
#---------------------------------running code------------------------------------------
n,k = map(int,input().split())
arr = list(map(int,input().split()))
xors = defaultdict(int)
xors[0]=1
comp = (1<<k)-1
ans = n*(n+1)//2
xor = 0
for a in arr:
	xor^=a
	if xors[xor]>xors[comp^xor]:
		xor^=comp
	ans-=xors[xor]
	xors[xor]+=1
print(ans)",linear,1054_D,CODEFORCES,1960,Changing Array,"At a break Vanya came to the class and saw an array of $$$n$$$ $$$k$$$-bit integers $$$a_1, a_2, \ldots, a_n$$$ on the board. An integer $$$x$$$ is called a $$$k$$$-bit integer if $$$0 \leq x \leq 2^k - 1$$$. 
Of course, Vanya was not able to resist and started changing the numbers written on the board. To ensure that no one will note anything, Vanya allowed himself to make only one type of changes: choose an index of the array $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the number $$$a_i$$$ with the number $$$\overline{a_i}$$$. We define $$$\overline{x}$$$ for a $$$k$$$-bit integer $$$x$$$ as the $$$k$$$-bit integer such that all its $$$k$$$ bits differ from the corresponding bits of $$$x$$$. 
Vanya does not like the number $$$0$$$. Therefore, he likes such segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$) such that $$$a_l \oplus a_{l+1} \oplus \ldots \oplus a_r \neq 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Determine the maximum number of segments he likes Vanya can get applying zero or more operations described above.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 200\,000$$$, $$$1 \leq k \leq 30$$$).
The next line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 2^k - 1$$$), separated by spaces — the array of $$$k$$$-bit integers.
Print one integer — the maximum possible number of segments with XOR not equal to $$$0$$$ that can be obtained by making several (possibly $$$0$$$) operations described in the statement.
","input
In the first example if Vasya does not perform any operations, he gets an array that has $$$5$$$ segments that Vanya likes. If he performs the operation with $$$i = 2$$$, he gets an array $$$[1, 0, 0]$$$, because $$$\overline{3} = 0$$$ when $$$k = 2$$$. This array has $$$3$$$ segments that Vanya likes. Also, to get an array with $$$5$$$ segments that Vanya likes, he can perform two operations with $$$i = 3$$$ and with $$$i = 2$$$. He then gets an array $$$[1, 0, 3]$$$. It can be proven that he can't obtain $$$6$$$ or more segments that he likes.
output
In the second example, to get $$$19$$$ segments that Vanya likes, he can perform $$$4$$$ operations with $$$i = 3$$$, $$$i = 4$$$, $$$i = 5$$$, $$$i = 6$$$ and get an array $$$[1, 4, 3, 0, 4, 3]$$$.
","greedy, implementation"
"n, k = map(int, raw_input().split())
a = map(int, raw_input().split())
for i in range(n):
    ai = a[i]
    nai = ((1<<k) - 1)^ai
    if nai < ai:
        a[i] = nai

from collections import Counter
C = Counter()
C[0] += 1
S = 0
cnt = 0
for j, ai in enumerate(a):
    nai = ((1<<k) - 1)^ai
    v1, v2 = C[S^ai], C[S^nai]
    if v1 <= v2:
        cnt += j + 1 - v1
        S ^= ai
        C[S] += 1
    else:
        cnt += j + 1 - v2
        S ^= nai
        C[S] += 1
print(cnt)
    
",linear,1054_D,CODEFORCES,1963,Changing Array,"At a break Vanya came to the class and saw an array of $$$n$$$ $$$k$$$-bit integers $$$a_1, a_2, \ldots, a_n$$$ on the board. An integer $$$x$$$ is called a $$$k$$$-bit integer if $$$0 \leq x \leq 2^k - 1$$$. 
Of course, Vanya was not able to resist and started changing the numbers written on the board. To ensure that no one will note anything, Vanya allowed himself to make only one type of changes: choose an index of the array $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the number $$$a_i$$$ with the number $$$\overline{a_i}$$$. We define $$$\overline{x}$$$ for a $$$k$$$-bit integer $$$x$$$ as the $$$k$$$-bit integer such that all its $$$k$$$ bits differ from the corresponding bits of $$$x$$$. 
Vanya does not like the number $$$0$$$. Therefore, he likes such segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$) such that $$$a_l \oplus a_{l+1} \oplus \ldots \oplus a_r \neq 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Determine the maximum number of segments he likes Vanya can get applying zero or more operations described above.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 200\,000$$$, $$$1 \leq k \leq 30$$$).
The next line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 2^k - 1$$$), separated by spaces — the array of $$$k$$$-bit integers.
Print one integer — the maximum possible number of segments with XOR not equal to $$$0$$$ that can be obtained by making several (possibly $$$0$$$) operations described in the statement.
","input
In the first example if Vasya does not perform any operations, he gets an array that has $$$5$$$ segments that Vanya likes. If he performs the operation with $$$i = 2$$$, he gets an array $$$[1, 0, 0]$$$, because $$$\overline{3} = 0$$$ when $$$k = 2$$$. This array has $$$3$$$ segments that Vanya likes. Also, to get an array with $$$5$$$ segments that Vanya likes, he can perform two operations with $$$i = 3$$$ and with $$$i = 2$$$. He then gets an array $$$[1, 0, 3]$$$. It can be proven that he can't obtain $$$6$$$ or more segments that he likes.
output
In the second example, to get $$$19$$$ segments that Vanya likes, he can perform $$$4$$$ operations with $$$i = 3$$$, $$$i = 4$$$, $$$i = 5$$$, $$$i = 6$$$ and get an array $$$[1, 4, 3, 0, 4, 3]$$$.
","greedy, implementation"
"n,k=list(map(int,input().split()))
arr=list(map(int,input().split()))
newarr=[0]

for num in arr:
  newarr+=[newarr[-1]^num]
dic={}
for num in newarr:
  x=(min(num,2**k-1-num),max(num,2**k-1-num))
  if x in dic:
    dic[x]+=1
  else:
    dic[x]=1
ans=0
for elem in dic:
  m=dic[elem]
  half=m//2
  ans+=half*(half-1)/2
  half=m-half
  ans+=half*(half-1)/2
ans=n*(n+1)/2-ans
print(int(ans))
  
    
",linear,1054_D,CODEFORCES,1968,Changing Array,"At a break Vanya came to the class and saw an array of $$$n$$$ $$$k$$$-bit integers $$$a_1, a_2, \ldots, a_n$$$ on the board. An integer $$$x$$$ is called a $$$k$$$-bit integer if $$$0 \leq x \leq 2^k - 1$$$. 
Of course, Vanya was not able to resist and started changing the numbers written on the board. To ensure that no one will note anything, Vanya allowed himself to make only one type of changes: choose an index of the array $$$i$$$ ($$$1 \leq i \leq n$$$) and replace the number $$$a_i$$$ with the number $$$\overline{a_i}$$$. We define $$$\overline{x}$$$ for a $$$k$$$-bit integer $$$x$$$ as the $$$k$$$-bit integer such that all its $$$k$$$ bits differ from the corresponding bits of $$$x$$$. 
Vanya does not like the number $$$0$$$. Therefore, he likes such segments $$$[l, r]$$$ ($$$1 \leq l \leq r \leq n$$$) such that $$$a_l \oplus a_{l+1} \oplus \ldots \oplus a_r \neq 0$$$, where $$$\oplus$$$ denotes the bitwise XOR operation. Determine the maximum number of segments he likes Vanya can get applying zero or more operations described above.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 200\,000$$$, $$$1 \leq k \leq 30$$$).
The next line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 2^k - 1$$$), separated by spaces — the array of $$$k$$$-bit integers.
Print one integer — the maximum possible number of segments with XOR not equal to $$$0$$$ that can be obtained by making several (possibly $$$0$$$) operations described in the statement.
","input
In the first example if Vasya does not perform any operations, he gets an array that has $$$5$$$ segments that Vanya likes. If he performs the operation with $$$i = 2$$$, he gets an array $$$[1, 0, 0]$$$, because $$$\overline{3} = 0$$$ when $$$k = 2$$$. This array has $$$3$$$ segments that Vanya likes. Also, to get an array with $$$5$$$ segments that Vanya likes, he can perform two operations with $$$i = 3$$$ and with $$$i = 2$$$. He then gets an array $$$[1, 0, 3]$$$. It can be proven that he can't obtain $$$6$$$ or more segments that he likes.
output
In the second example, to get $$$19$$$ segments that Vanya likes, he can perform $$$4$$$ operations with $$$i = 3$$$, $$$i = 4$$$, $$$i = 5$$$, $$$i = 6$$$ and get an array $$$[1, 4, 3, 0, 4, 3]$$$.
","greedy, implementation"
"i = int(input())
s = input().split()

l = []
for j in s:
    if not l or  int(j)%2 != l[-1]:
        l.append(int(j)%2)
    else:
        l.pop()

if len(l) < 2:
    print('YES')
else:
    print('NO')


",linear,1092_D1,CODEFORCES,2080,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math"
"n=int(input())
a=list(map(int,input().split()))
st=[a[0]]
for i in range(1,n):
    if len(st)>0 and st[-1]%2==a[i]%2:
        st.pop()
    else:
        st.append(a[i])
if len(st)<=1:
    print(""YES"")
else:
    print(""NO"")
    ",linear,1092_D1,CODEFORCES,2083,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math"
"#!/usr/bin/env python
# coding: utf-8

# In[4]:


import math
n=int(input())
columns=list(map(int, input().rstrip().split()))


# In[5]:


modcolumns=[i%2 for i in columns]


# In[6]:


test=0


# In[7]:


previouslist=[]


for i in range(0,n):
    if len(previouslist)==0:
        previouslist.append(modcolumns[i])
        
    elif modcolumns[i]==previouslist[-1]:
        previouslist.pop()
        
    else:
        previouslist.append(modcolumns[i])
    
    
    
    
        
if len(previouslist)<=1:
    print(""YES"")
else:
    print(""NO"")


# In[ ]:


",linear,1092_D1,CODEFORCES,2077,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math"
"n = int(input())
a = list(map(int, input().split()))
b = []
for i in range(n):
    a[i] %= 2
    if len(b) != 0:
        if b[-1] == a[i]:
            b.pop()
        else:
            b.append(a[i])
    else:
        b.append(a[i])
if len(b) > 1:
    print(""NO"")
else:
    print(""YES"")
",linear,1092_D1,CODEFORCES,2078,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math"
"n=int(input())
a=list(map(int,input().split()))
b=0
for i in range(n):
    if a[i]%2==1:
        if i%2==0:
            b+=1
        else:
            b-=1
if n%2==0:
    if b==0:
        print(""YES"")
    else:
        print(""NO"")
else:
    if b==0 or b==1:
        print(""YES"")
    else:
        print(""NO"")",linear,1092_D1,CODEFORCES,2076,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math"
"n = int(input())
a = [int(_) & 1 for _ in input().split()]
v = [a[0]]
for i in range(1, n):
    if v and v[-1] == a[i]:
        v.pop()
    else:
        v.append(a[i])
print(""NO"" if len(v) > 1 else ""YES"")
",linear,1092_D1,CODEFORCES,2079,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math"
"n = int(input())
a = list(map(int, input().split()))
q = (10 ** 6) * [-1]
pnt = -1
ans = ""YES""
for i in range(n):
    if pnt == -1:
        pnt += 1
        q[pnt] = a[i]
    else :
        if q[pnt] == a[i] or abs(q[pnt] - a[i]) % 2 == 0:
            q[pnt] = -1
            pnt -= 1
        else:
            pnt += 1
            q[pnt] = a[i]
if pnt > 0 :
    ans = ""NO""
print(ans)
        
",linear,1092_D1,CODEFORCES,2075,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math"
"i = int(input())
s = input().split()

l = []
for j in s:
    if not l or  int(j)%2 != l[-1]:
        l.append(int(j)%2)
    else:
        l.pop()

if len(l) < 2:
    print('YES')
else:
    print('NO')
",linear,1092_D1,CODEFORCES,2081,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math"
"def f():
    b = [a[0]]
    for e in a[1:]:
        if b != []:
            if e == b[-1] or abs(e-b[-1])%2==0:
                b.pop()

            else:
                b.append(e)
        else:
            b.append(e)

    for i in range(1,len(b)):
        if abs(b[i]-b[i-1])%2:
            print('NO')
            return

    print('YES')

n=int(input())
a=[int(i) for i in input().split()]


f()",linear,1092_D1,CODEFORCES,2082,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math"
"c = [[0 for i in range(5205)] for j in range(5205)]
K = 998244353
inv = [0 for i in range(5205)]

def mu(a, n):
	if n == 0: return 1
	q = mu(a, n // 2)
	if n % 2 == 0:
		return q * q % K
	else: return q * q % K * a % K

def calc(m, d, S):
	res = 0
	if m == 0:
		if S == 0: return 1
		return 0

	for u in range(0, m + 1):
		if (u * d > S): break
		U = c[m][u] * c[S - u * d + m - 1][m - 1] % K 
		if u % 2 == 0:
			res = (res + U) % K
		else: res = (res - U + K) % K 
	return res


c[0][0] = 1
inv[0] = 1
for i in range(1, 5101):
	inv[i] = mu(i, K - 2)

for i in range(1, 5101):
	c[i][0] = 1
	for j in range (1, i):
		c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K
	c[i][i] = 1

p, s, r = map(int, input().split())

res = 0
den = 0

for i in range(1, p + 1):
	A = 0
	for d in range(r, s // i + 1):
		if (i < p): A = (A + calc(p - i, d, s - d * i)) % K
		else:
			if (s - i * d == 0): A += 1
	A = A * inv[i] % K
	res = (res + A * c[p - 1][i - 1] % K) % K

den = c[s - r + p - 1][p - 1]
res = res * mu(den, K - 2) % K
print(res)


",cubic,1096_E,CODEFORCES,3790,The Top Scorer,"Hasan loves playing games and has recently discovered a game called TopScore. In this soccer-like game there are $$$p$$$ players doing penalty shoot-outs. Winner is the one who scores the most. In case of ties, one of the top-scorers will be declared as the winner randomly with equal probability.
They have just finished the game and now are waiting for the result. But there's a tiny problem! The judges have lost the paper of scores! Fortunately they have calculated sum of the scores before they get lost and also for some of the players they have remembered a lower bound on how much they scored. However, the information about the bounds is private, so Hasan only got to know his bound.
According to the available data, he knows that his score is at least $$$r$$$ and sum of the scores is $$$s$$$.
Thus the final state of the game can be represented in form of sequence of $$$p$$$ integers $$$a_1, a_2, \dots, a_p$$$ ($$$0 \le a_i$$$) — player's scores. Hasan is player number $$$1$$$, so $$$a_1 \ge r$$$. Also $$$a_1 + a_2 + \dots + a_p = s$$$. Two states are considered different if there exists some position $$$i$$$ such that the value of $$$a_i$$$ differs in these states. 
Once again, Hasan doesn't know the exact scores (he doesn't know his exact score as well). So he considers each of the final states to be equally probable to achieve.
Help Hasan find the probability of him winning.
It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$, $$$P \le Q$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.
The only line contains three integers $$$p$$$, $$$s$$$ and $$$r$$$ ($$$1 \le p \le 100$$$, $$$0 \le r \le s \le 5000$$$) — the number of players, the sum of scores of all players and Hasan's score, respectively.
Print a single integer — the probability of Hasan winning.
It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$, $$$P \le Q$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.
","input
In the first example Hasan can score $$$3$$$, $$$4$$$, $$$5$$$ or $$$6$$$ goals. If he scores $$$4$$$ goals or more than he scores strictly more than his only opponent. If he scores $$$3$$$ then his opponent also scores $$$3$$$ and Hasan has a probability of $$$\frac 1 2$$$ to win the game. Thus, overall he has the probability of $$$\frac 7 8$$$ to win.
output
In the second example even Hasan's lower bound on goal implies him scoring more than any of his opponents. Thus, the resulting probability is $$$1$$$.
","combinatorics, dp, math, probabilities"
"base=998244353;
def power(x, y):
    if(y==0):
        return 1
    t=power(x, y//2)
    t=(t*t)%base
    if(y%2):
        t=(t*x)%base
    return t;
def inverse(x):
    return power(x, base-2)
f=[1]
iv=[1]
for i in range(1, 5555):
    f.append((f[i-1]*i)%base)
    iv.append(inverse(f[i]))
def C(n, k):
    return (f[n]*iv[k]*iv[n-k])%base
def candy(n, k):
    # print(n, k)
    return C(n+k-1, k-1)
def count_game(k, n, x): #k players, n points total, no player can have x point or more
    if(k==0):
        if(n==0):
            return 1
        else:
            return 0
    ans=0
    for i in range(0, k+1):
        t=n-x*i
        # print(i, C(k, i))
        if(t<0):
            break
        if(i%2):
            ans=(ans-C(k, i)*candy(t, k))%base
        else:
            ans=(ans+C(k, i)*candy(t, k))%base 
    return ans
p, s, r= list(map(int, input().split()))
gamesize=count_game(p, s-r, int(1e18))
gamesize=inverse(gamesize)
ans=0;
for q in range(r, s+1):
    for i in range(0, p): #exactly i people have the same score
        t=s-(i+1)*q
        if(t<0):
            break
        # print(q, i, count_game(p-i-1, t, q));
        ans=(ans+C(p-1, i)*count_game(p-i-1, t, q)*gamesize*inverse(i+1))%base
print(ans)
        
    ",cubic,1096_E,CODEFORCES,3791,The Top Scorer,"Hasan loves playing games and has recently discovered a game called TopScore. In this soccer-like game there are $$$p$$$ players doing penalty shoot-outs. Winner is the one who scores the most. In case of ties, one of the top-scorers will be declared as the winner randomly with equal probability.
They have just finished the game and now are waiting for the result. But there's a tiny problem! The judges have lost the paper of scores! Fortunately they have calculated sum of the scores before they get lost and also for some of the players they have remembered a lower bound on how much they scored. However, the information about the bounds is private, so Hasan only got to know his bound.
According to the available data, he knows that his score is at least $$$r$$$ and sum of the scores is $$$s$$$.
Thus the final state of the game can be represented in form of sequence of $$$p$$$ integers $$$a_1, a_2, \dots, a_p$$$ ($$$0 \le a_i$$$) — player's scores. Hasan is player number $$$1$$$, so $$$a_1 \ge r$$$. Also $$$a_1 + a_2 + \dots + a_p = s$$$. Two states are considered different if there exists some position $$$i$$$ such that the value of $$$a_i$$$ differs in these states. 
Once again, Hasan doesn't know the exact scores (he doesn't know his exact score as well). So he considers each of the final states to be equally probable to achieve.
Help Hasan find the probability of him winning.
It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$, $$$P \le Q$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.
The only line contains three integers $$$p$$$, $$$s$$$ and $$$r$$$ ($$$1 \le p \le 100$$$, $$$0 \le r \le s \le 5000$$$) — the number of players, the sum of scores of all players and Hasan's score, respectively.
Print a single integer — the probability of Hasan winning.
It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$, $$$P \le Q$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.
","input
In the first example Hasan can score $$$3$$$, $$$4$$$, $$$5$$$ or $$$6$$$ goals. If he scores $$$4$$$ goals or more than he scores strictly more than his only opponent. If he scores $$$3$$$ then his opponent also scores $$$3$$$ and Hasan has a probability of $$$\frac 1 2$$$ to win the game. Thus, overall he has the probability of $$$\frac 7 8$$$ to win.
output
In the second example even Hasan's lower bound on goal implies him scoring more than any of his opponents. Thus, the resulting probability is $$$1$$$.
","combinatorics, dp, math, probabilities"
"n=int(input())
s=input()
cur=0
for a in s:
    cur=max(cur,0)
    if(a=='-'):
        cur-=1
    else: cur+=1
    cur=max(cur,0)
print(cur)",linear,1159_A,CODEFORCES,2110,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"n=int(input())
s=input()
ans=0
for i in s:
    if(i=='+'):
        ans+=1
    else:
        ans-=1
    if(ans<0):
        ans=0
print(ans)",linear,1159_A,CODEFORCES,2111,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"n = int(input())
s = input()
t = 0
mn = 0
for i in s:
    if i == '-':
        t-=1
    else:
        t+=1
    mn = min(mn, t)
print(-mn+t)",linear,1159_A,CODEFORCES,2115,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"n = int(input())
s = input()
b = 0
for i in s:
    if i == '+':
        b += 1
    else:
        b -= 1
        b = max(b, 0)
print(b)",linear,1159_A,CODEFORCES,2107,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"n = int(input())
s = input()
t = 0
for i in s:
    if i == '+':
        t += 1
    else:
        t = max(t - 1, 0)

print(max(t, 0))
",linear,1159_A,CODEFORCES,2114,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"n = int(input())
s = input()
ans = 10000
for i in range(0, 105):
	f = True
	x = i
	for c in s:
		if c == '-':
			x -= 1
		else:
			x += 1
		if x < 0:
			f = False
	if f:
		ans = min(ans, x)
print(ans)
",linear,1159_A,CODEFORCES,2112,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"def main():
    n = int(input())
    s = input()
    for i in range(n+1):
        flag = True
        stones = i
        for j in s:
            if j == '-':
                if stones > 0:
                    stones -= 1
                else:
                    flag = False
                    break
            else:
                stones += 1

        if flag:
            n = i
            break

    stones = n
    for i in s:
        if i == '-':
            stones -= 1
        else:
            stones += 1

    print(stones)

    

main()
",quadratic,1159_A,CODEFORCES,3578,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"n = int(input())
s = input()
maxn = 0
now = 0
for i in s:
    if i == '+':
        now += 1
    else:
        now -= 1
    maxn = max(maxn, -now)
print(now + maxn)",linear,1159_A,CODEFORCES,2113,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n = read_int()
    s = read()
    stones = 0
    for c in s:
        if c == '+':
            stones += 1
        else:
            stones -= 1
            if stones < 0:
                stones = 0
    write(stones)

main()
",linear,1159_A,CODEFORCES,2109,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"def go():
    n = int(input())
    a = [i for i in input()]
    x = 0
    for i in a:
        if i == '-':
            x = max(0, x - 1)
        else:
            x += 1
    return x

print(go())
",linear,1159_A,CODEFORCES,2108,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"def stones_after(n, s):
	for i in s:
		if i == '-':
			n -= 1
		else:
			n += 1
		if n < 0:
			return -1
	return n

n = int(input().strip())
s = input().strip()
ans = 99999999
for i in range(n+1):
	stones = stones_after(i, s)
	if stones != -1:
		ans = min(ans, stones)
print(ans)",quadratic,1159_A,CODEFORCES,3577,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math"
"n = int(input())
a = list(map(int, input().split()))

c = 0

for i in range(1, n-1):
    if a[i] > a[i-1] and a[i] > a[i+1]:
        c +=1
    if a[i] == a[i-1] or a[i] == a[i+1]:
        print('NO')
        exit()
    if a[i] <= a[i-1] and a[i] <= a[i+1]:
        print('NO')
        exit()
if c>1:
    print('NO')
else:
    print('YES')",linear,1197_B,CODEFORCES,2254,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"n = int(input())
li = list(map(int, input().split()))
x = li.index(max(li))
if li[:x] == sorted(li[:x]) and li[x:] == sorted(li[x:])[::-1]:
    print(""YES"")
else:
    print(""NO"")",nlogn,1197_B,CODEFORCES,3021,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"n=int(input())
arr=list(map(int,input().split()))
maxval=max(arr)
maxindex=-1
for i in range(n):
	if(arr[i]==maxval):
		maxindex=i
		break

flag=0
temp=maxval
for i in range(maxindex-1,-1,-1):
	if(temp<=arr[i]):
		flag=1
		break
	else:
		temp=arr[i]

temp=maxval
for i in range(maxindex+1,n):
	if(arr[i]>=temp):
		flag=1
		break
	else:
		temp=arr[i]

if(flag==0):
	print(""YES"")
else:
	print(""NO"")
",linear,1197_B,CODEFORCES,2252,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int, sys.stdin.readline().strip().split()))
i = a.index(max(a))
v = True
for j in range (0, i):
    if a[j] > a[j+1]:
        v = False
for j in range (i, n-1):
    if a[j] < a[j+1]:
        v = False
if v == True:
    print(""YES"")
else:
    print(""NO"")",linear,1197_B,CODEFORCES,2249,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"n = int(input())
l = list(map(int, input().split()))
to = l.index(max(l))
ok = 1
for i in range(1, to):
    if (l[i] <= l[i - 1]):
        ok = 0
        break
for i in range(to + 1, n):
    if (l[i] >= l[i - 1]):
        ok = 0
        break
if ok:
    print('YES')
else:
    print('NO')",linear,1197_B,CODEFORCES,2256,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"n = int(input())
arr = [int(x) for x in input().split()]
x = arr.index(max(arr))
cur = max(arr)
l = x - 1
r = x + 1
ok = 1
for i in range(n - 1):
    if l < 0:
        ok *= (arr[r] < cur)
        cur = arr[r]
        r += 1
    elif r >= n:
        ok *= (arr[l] < cur)
        cur = arr[l]
        l -= 1
    else:
        if arr[l] > arr[r]:
            ok *= (arr[l] < cur)
            cur = arr[l]
            l -= 1
        else:
            ok *= (arr[r] < cur)
            cur = arr[r]
            r += 1
print(""YES"" if ok else ""NO"")",linear,1197_B,CODEFORCES,2251,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"n = int(input().strip())
nums = list(map(int, input().strip().split()))
has_dups = (len(nums) > len(set(nums)))
mx = nums.index(max(nums))
if has_dups or nums[:mx+1]!=sorted(nums[:mx+1]) or nums[mx:]!=sorted(nums[mx:], reverse=True):
    print(""NO"")
else:
    print(""YES"")",nlogn,1197_B,CODEFORCES,3022,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"def main():
    import sys
    input = sys.stdin.readline
    
    n = int(input())
    arr = list(map(int, input().split()))
    idx = arr.index(n)
    ok = 1
    for i in range(1, idx):
        if arr[i] < arr[i - 1]:
            ok = 0
    for i in reversed(range(idx, n - 1)):
        if arr[i] < arr[i + 1]:
            ok = 0
    if ok:
        print(""YES"")
    else:
        print(""NO"")
    
    return 0

main()",linear,1197_B,CODEFORCES,2250,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"n = int(input())
a = list(map(int, input().split()))
idx = list(range(n))
idx.sort(key=lambda i: a[i], reverse=True)
imin = imax = idx[0]
for i in idx[1:]:
    if i == imin - 1 or i == imax + 1:
        imin = min(imin, i)
        imax = max(imax, i)
    else:
        print('NO')
        exit(0)
print('YES')
",nlogn,1197_B,CODEFORCES,3018,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"n = int(input())
a = list(map(int,input().split()))
fl = False
ans = True
for i in range(n-1):
    if a[i+1]>a[i]:
        if fl:
            ans = False
    else:
        fl = True
if ans:
    print('YES')
else:
    print('NO')",linear,1197_B,CODEFORCES,2253,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"t=int(input())
g=list(map(int,input().split()))
k=max(g)
flag=True
i=0
while g[i]!=k:
    if i!=0 and g[i]<g[i-1]:
        print(""NO"")
        exit()
    i+=1
i+=1
while i<t and g[i]!=k:
    if i!=0 and g[i]>g[i-1]:
        print(""NO"")
        exit()
    i+=1
print(""YES"")",linear,1197_B,CODEFORCES,2257,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"import io, sys
input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()

ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())

n = ii()
a = li()
p = a.index(max(a))
b = sorted(a)
b.pop()
ok = 1
i, j = p - 1, p + 1
while i >= 0 or j < n:
    if i >= 0 and a[i] == b[-1]:
        b.pop()
        i -= 1
    elif j < n and a[j] == b[-1]:
        b.pop()
        j += 1
    else:
        ok = 0
        break
print('YES' if ok else 'NO')",nlogn,1197_B,CODEFORCES,3020,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"n = int(input())
a = list(map(int, input().split()))
s = sorted(a)
q = a.index(max(a))
q1, q = min(len(a)-1, q+1), max(0, q-1)
for q2 in range(len(a)-2, -1, -1):
    if a[q] == s[q2]:
        q = max(0, q-1)
    elif a[q1] == s[q2]:
        q1 = min(len(a)-1, q1+1)
    else:
        print(""NO"")
        break
else:
    print(""YES"")
",nlogn,1197_B,CODEFORCES,3019,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"n = int(input())
a = list(map(int,input().split()))
rev = [-1] * (n + 1)
for i, j in enumerate(a):
    rev[j] = i

mx = max(a)

# [l, r]
l = a.index(mx)
r = l

for i in range(n - 1, 0, -1):
    idx = rev[i]
    if idx == l - 1:
        l -= 1
    elif idx == r + 1:
        r += 1
    else:
        print('NO')
        exit()
print('YES')",linear,1197_B,CODEFORCES,2255,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation"
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        not_i = ((1 << m) - 1) ^ i
        val = dp[i] + (total_adj - adj_in_subset[i] - adj_in_subset[not_i])
        dp[i | (1 << j)] = min(dp[i | (1 << j)], val)
print(dp[-1])",np,1238_E,CODEFORCES,4624,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp"
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]
        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)
print(dp[-1])",np,1238_E,CODEFORCES,4625,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp"
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

# Calculate adjacent count in subset
adj_in_subset = [0] * (1 << m)
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        adj_in_subset[(1 << c1) + (1 << c2)] += 1
for i in range(m):
    for j in range(1 << m):
        if j & (1 << i):
            adj_in_subset[j] += adj_in_subset[j ^ (1 << i)]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]
        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)
print(dp[-1])",np,1238_E,CODEFORCES,4626,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp"
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')
from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

# ------------------------------

def cord(c):
    return ord(c)-ord('a')

def main():
    n, m = RL()
    s = input()
    ct = [0]*(1<<m)

    for i in range(n-1):
        now, nex = cord(s[i]), cord(s[i+1])
        if now==nex: continue
        ct[1<<now | 1<<nex]+=1

    for i in range(m):
        for j in range(1<<m):
            if (1<<i) & j:
                ct[j]+=ct[(1<<i) ^ j]

    dp = [INF]*(1<<m)
    dp[0] = 0
    for i in range(1<<m):
        # pos = bin(i).count('1')
        for j in range(m):
            # sm = 0
            # if i>>j & 1 == 0:
            #     for k in range(m):
            #         if 1<<k & i==0:
            #             sm-=ct[j][k]*pos
            #         else:
            #             sm+=ct[j][k]*pos
            if i & 1<<j == 0:
                sm = ct[-1]-ct[i]-ct[~i]
                dp[i|(1<<j)] = min(dp[i|(1<<j)], dp[i] + sm)
    # print(ct)
    print(dp[-1])





if __name__ == ""__main__"":
    main()

",np,1238_E,CODEFORCES,4628,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp"
"n, m = map(int, input().split())
a = list(map(str, input().strip()))

dp = [10 ** 10] * (1 << 20)
cnt = [0] * (1 << 20)


def get(x):
    return 1 << (ord(x) - ord('a'))


for i, v in enumerate(a):
    if i:
        cnt[get(a[i]) | get(a[i - 1])] += 1

for i in range(m):
    for j in range(1 << m):
        if (1 << i) & j:
            cnt[j] += cnt[j ^ (1 << i)]
            # print(bin(j), bin(j ^ 1 << i), cnt[j])

# for i in range(1 << m):
#     for j in range(m):
#         if not i & (1 << j):
#             cnt[i | (1 << j)] += cnt[i]
#             print(bin(i | (1 << j)), bin(i), cnt[i | 1 << j])

dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if not i & (1 << j):
            dp[i | (1 << j)] = min(dp[i | (1 << j)],
                                   dp[i] + n - 1 - cnt[i | (1 << j)] - cnt[(1 << m) - 1 - (i | (1 << j))])
print(dp[(1 << m) - 1])
",np,1238_E,CODEFORCES,4627,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp"
"
R,G,B=[int(c) for c in input().split()]
ra=[int(c) for c in input().split()]
ga=[int(c) for c in input().split()]
ba=[int(c) for c in input().split()]

ra.sort(reverse=True)
ga.sort(reverse=True)
ba.sort(reverse=True)

dp = [[[-1 for i in range(201)]for j in range(201)]for k in range(201)]
def solve(dp,r,g,b):
    if dp[r][g][b] !=-1:
        return dp[r][g][b]
    count= 0
    for i,j in zip((r,g,b),(R,G,B)):
        if i == j:
            count+=1
    if count >= 2:
        return 0

    ##Three cases choose btw r,b r,g  and gb
    res = -999
    if r != R and b!=B:

        res = max(res,ra[r]*ba[b] + solve(dp,r+1,g,b+1))
        # print(res)
    
    if r!=R and g != G:
        res = max(res,ra[r]*ga[g] + solve(dp,r+1,g+1,b))
        # print(res)
    
    if b!=B and g != G:
        res = max(res,ba[b]*ga[g] + solve(dp,r,g+1,b+1))
        # print(res)
    
    dp[r][g][b] = res

    return res
     

print(solve(dp,0,0,0))",cubic,1398_D,CODEFORCES,3966,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r,g, b = map(int,input().split())
R = sorted([*map(int,input().split())],reverse=True)
G= sorted([*map(int,input().split())],reverse=True)
B = sorted([*map(int,input().split())],reverse=True)
mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]
def dp(i,j,k):
    p = (i==r)+(j==g)+(k==b)
    if(p>1):
        return 0
    if(mem[i][j][k]!=-1):
        return mem[i][j][k]
    ans = 0
    if(i==r):
        ans = dp(i,j+1,k+1)+G[j]*B[k]
        return ans
    elif(j==g):
        ans = dp(i+1,j,k+1)+R[i]*B[k]
    elif(k==b):
        ans = dp(i+1,j+1,k)+R[i]*G[j]
    else:
        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])
    mem[i][j][k] = ans
    return ans
print(dp(0,0,0))",cubic,1398_D,CODEFORCES,3936,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp = [[[0 for ___ in range(B+1)] for __ in range(G+1)] for _ in range(R+1)]
mx = 0

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i < R and j < G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i] * g[j])
            if i < R and k < B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i] * b[k])
            if j < G and k < B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j] * b[k])
            mx = max(mx, dp[i][j][k])

print(mx)",cubic,1398_D,CODEFORCES,3891,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict


BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------
R,G,B=map(int,input().split())
r=sorted(list(map(int,input().split())))
g=sorted(list(map(int,input().split())))
b=sorted(list(map(int,input().split())))
dp=[[[0]*(B+1) for j in range(G+1)] for i in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k - 1] + g[j - 1] * b[k - 1])
print(dp[R][G][B])",cubic,1398_D,CODEFORCES,3964,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys, math
import io, os
#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
#from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction
#sys.setrecursionlimit(100000)
INF = float('inf')
mod = int(1e9)+7

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

@bootstrap
def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        yield 0
        return
    if dp[r][g][b]:
        yield dp[r][g][b]
        return
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+(yield recur(r-1,g-1,b)))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+(yield recur(r-1,g,b-1)))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+(yield recur(r,g-1,b-1)))
    yield dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",cubic,1398_D,CODEFORCES,3926,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
# from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
# import numpy as np
starttime = time.time()
# import numpy as np
mod = int(pow(10, 9) + 7)
mod2 = 998244353
def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]

try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""../output.txt"", ""w"")
except:
    pass
global ans
ans=0

def rec(i,j,k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    x1=x2=x3=0
    if i<R and j<G:
        x1=r[i]*g[j]+rec(i+1,j+1,k)
    if i<R and k<B:
        x2=r[i]*b[k]+rec(i+1,j,k+1)
    if j<G and k<B:
        x3=g[j]*b[k]+rec(i,j+1,k+1)
    dp[i][j][k]=max(x1,x2,x3)
    global ans
    ans=max(ans,dp[i][j][k])
    return dp[i][j][k]

for _ in range(1):
    R,G,B=L()
    r=L()
    g=L()
    b=L()
    r.sort(reverse=True)
    g.sort(reverse=True)
    b.sort(reverse=True)
    dp=[[[-1 for k in range(B+1)] for j in range(G+1)] for i in range(R+1)]
    rec(0,0,0)
    print(ans)



endtime = time.time()
# print(f""Runtime of the program is {endtime - starttime}"")

",cubic,1398_D,CODEFORCES,3992,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
ans = 0
for i in dp:
       for j in i:
              ans = max(ans, max(j))

print(ans)
",cubic,1398_D,CODEFORCES,3946,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#tests = int(input())
#for t in range(tests):
#    b= int(input())
#    ls = [int(x) for x in input()]

r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))


dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

for i in range(r+1):
    dp[i][0][0] = 0
for i in range(g+1):
    dp[0][i][0] = 0
for i in range(b+1):
    dp[0][0][i] = 0

dp[1][1][0] = ls_r[0] * ls_g[0]
dp[0][1][1] = ls_g[0] * ls_b[0]
dp[1][0][1] = ls_r[0] * ls_b[0]    

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            res1 = 0
            res2 = 0
            res3 = 0
            if i-1>=0 and j-1>=0:
                res1 += dp[i-1][j-1][k] + ls_r[i-1] * ls_g[j-1]
            if i-1>=0 and k-1>=0:
                res2 += dp[i-1][j][k-1] + ls_r[i-1] * ls_b[k-1]
            if j-1>=0 and k-1>=0:
                res3 += dp[i][j-1][k-1] + ls_g[j-1] * ls_b[k-1]
            dp[i][j][k] = max(res1,res2,res3)
print(dp[r][g][b])",cubic,1398_D,CODEFORCES,3942,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r,g,b = map(int,input().split())

R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))

R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
# dp[i][j][k]

dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]

for j in range(g-1,-1,-1):
    for k in range(b-1,-1,-1):
        dp[r][j][k] = G[j]*B[k] + dp[r][j+1][k+1]

for i in range(r-1,-1,-1):
    for k in range(b-1,-1,-1):
        dp[i][g][k] = R[i]*B[k] + dp[i+1][g][k+1]

for i in range(r-1,-1,-1):
    for j in range(g-1,-1,-1):
        dp[i][j][b] = R[i]*G[j] + dp[i+1][j+1][b]

for i in range(r-1,-1,-1):
    for j in range(g-1,-1,-1):
        for k in range(b-1,-1,-1):
            case1 = dp[i+1][j][k]
            case2 = dp[i][j+1][k]
            case3 = dp[i][j][k+1]

            case4 = R[i]*G[j] + dp[i+1][j+1][k]
            case5 = R[i]*B[k] + dp[i+1][j][k+1]
            case6 = G[j]*B[k] + dp[i][j+1][k+1]

            dp[i][j][k] = max(case1,case2,case3,case4,case5,case6)

print(dp[0][0][0])
",cubic,1398_D,CODEFORCES,3892,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r, g, b = map(int, input().split())
red = list(map(int, input().split()))
green = list(map(int, input().split()))
blue = list(map(int, input().split()))
red.sort()
green.sort()
blue.sort()
red = red[::-1]
green = green[::-1]
blue = blue[::-1]

dp = []
for i in range(r + 1):
    temp = [[0] * (b + 1) for j in range(g + 1)]
    dp.append(temp)

answer = 0 

for i in range(0, r + 1):
    for j in range(0, g + 1):
        for k in range(0, b + 1):
            if i > 0 and j > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + red[i - 1] * green[j - 1])
            if i > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + red[i - 1] * blue[k - 1])
            if j > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + green[j - 1] * blue[k - 1])
                
            answer = max(answer, dp[i][j][k])
print(answer)",cubic,1398_D,CODEFORCES,3902,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def cal(r, g, b):
	if dp[r][g][b] != -1:
		return dp[r][g][b]

	area = 0
	if r<R and g<G:
		area = max(area, rl[r] * gl[g] + cal(r+1, g+1, b))
	if r<R and b<B:
		area = max(area, rl[r] * bl[b] + cal(r+1, g, b+1))
	if g<G and b<B:
		area = max(area, gl[g] * bl[b] + cal(r, g+1, b+1))
	dp[r][g][b] = area
	return area

if __name__ == ""__main__"":
	R, G, B = map(int,input().split())
	rl = sorted(list(map(int,input().split())), reverse=True)
	gl = sorted(list(map(int,input().split())), reverse=True)
	bl = sorted(list(map(int,input().split())), reverse=True)
	dp = [[[-1]*(B+1) for i in range(G+1)] for i in range(R+1)]
	print(cal(0,0,0))
",cubic,1398_D,CODEFORCES,4004,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
input = sys.stdin.readline

R,G,B = map(int,input().split())

r = list(map(int,input().split()))
g = list(map(int,input().split()))
b = list(map(int,input().split()))

r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
r = [0] + r
g = [0] + g
b = [0] + b
R += 1
G += 1
B += 1
dp = [[[0]*B for _ in range(G)] for __ in range(R)]

res = 0

for i in range(R):
    for j in range(G):
        for k in range(B):

            tmp = 0
            if i > 0 and j > 0:
                tmp = max(tmp,dp[i-1][j-1][k]+r[i]*g[j])
            if i > 0 and k > 0:
                tmp = max(tmp,dp[i-1][j][k-1]+r[i]*b[k])
            if j > 0 and k > 0:
                tmp = max(tmp,dp[i][j-1][k-1]+g[j]*b[k])
            dp[i][j][k] = tmp
            res = max(res,tmp)

print(res)



",cubic,1398_D,CODEFORCES,3906,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from collections import defaultdict as dd
import math
import sys
import heapq
import copy
input=sys.stdin.readline
def nn():
	return int(input())

def li():
	return list(input())

def mi():
	return map(int, input().split())

def lm():
	return list(map(int, input().split()))


def solve():

	r,g,b = mi()

	rs = lm()
	gs = lm()
	bs = lm()
	rs.sort()
	gs.sort()
	bs.sort()

	ans = [[[0 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]

	for i in range(1,r+1):
		for j in range(1,g+1):
			ans[i][j][0]= ans[i-1][j-1][0]+rs[i-1]*gs[j-1]


	for i in range(r+1):
		for j in range(g+1):
			for k in range(1,b+1):
				new_len = bs[k-1]
				if i==0:
					i_len = 0
				else:
					i_len = ans[i-1][j][k-1] + rs[i-1]*new_len
				if j==0:
					j_len = 0
				else:
					j_len = ans[i][j-1][k-1] + gs[j-1]*new_len
				if i>0 and j>0:
					i_j_len = ans[i-1][j-1][k]+rs[i-1]*gs[j-1]
				else:
					i_j_len = 0
				ans[i][j][k] = max(i_len,
									j_len,
									ans[i][j][k-1],
									i_j_len)
	#print(ans)
	print(ans[r][g][b])





solve()
",cubic,1398_D,CODEFORCES,3908,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#######################################
r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])
                    
print(ans)
                                   
                
            
",cubic,1398_D,CODEFORCES,3956,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def solve(i, j, k):
    if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0):
        return 0
    if dp[i][j][k] != -1:
        return dp[i][j][k]
    ans = 0
    if i >= 0 and j >= 0:
        ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k))
    if i >= 0 and k >= 0:
        ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1))
    if j >= 0 and k >= 0:
        ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1))
    dp[i][j][k] = ans
    return ans

a, b, c = map(int, input().split())
rs = sorted(list(map(int, input().split())))
gs = sorted(list(map(int, input().split())))
bs = sorted(list(map(int, input().split())))
dp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)]
print(solve(a - 1, b - 1, c - 1))
",cubic,1398_D,CODEFORCES,3922,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys

def dp(ri, gi, bi):
    if ri>r or gi>g or bi>b:
        return 0

    if not list_memo[ri][gi][bi]==-1:
        return list_memo[ri][gi][bi]
    
    list_memo[ri][gi][bi] = max(dp(ri+1, gi+1, bi)+r_c[ri]*g_c[gi], dp(ri+1, gi, bi+1)+r_c[ri]*b_c[bi], dp(ri, gi+1, bi+1)+g_c[gi]*b_c[bi])
    return list_memo[ri][gi][bi]


r, g, b = map(int, sys.stdin.readline().split())

r_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)
g_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)
b_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)


list_memo = [[[-1]*(b+1) for _ in range(g+1)] for _ in range(r+1)]

print(dp(0, 0, 0))",cubic,1398_D,CODEFORCES,3968,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#: Author - Soumya Saurav
import sys,io,os,time
from collections import defaultdict
from collections import OrderedDict
from collections import deque
from itertools import combinations
from itertools import permutations
import bisect,math,heapq
alphabet = ""abcdefghijklmnopqrstuvwxyz""

input = sys.stdin.readline

########################################
'''
3 3 3 
1 2 3
1 2 3
1 2 3

'''
'''
nax = 201

nr , ng , nb = map(int, input().split())
n = nr + ng + nb
r = list(map(int , input().split()))
g = list(map(int , input().split()))
b = list(map(int , input().split()))

r.sort()
g.sort()
b.sort()

dp = [[[0]*nax for i in range(nax)] for j in range(nax)]
'''
'''
arr = [[1,i] for i in r] + [[2,i] for i in b] + [[3,i] for i in g]
arr.sort(key = lambda x : x[1],reverse = True)
ans = 0
done = [False]*n
print(arr)
for i in range(n):
	ok = False
	if done[i]: continue
	for j in range(i+1,n):
		if done[j]: continue
		if arr[i][0] != arr[j][0]:
			print(i+1,j+1,arr[i][1]*arr[j][1])
			ans += arr[i][1]*arr[j][1]
			done[i] = True
			done[j] = True
			ok = True
			break
	if not ok: break
print(ans)

'''
'''
sys.setrecursionlimit(10**7)


from functools import lru_cache
@lru_cache(None)
def f(i,j,k):
	#print(i,j,k)
	if (i >= nr and j >= ng) or (j >= ng and k >= nb) or (i >= nr and k >= nb):
		return 0
	ans = r[i]*g[j] + f(i+1,j+1,k) if i < nr and j < ng else 0
	#print(ans)
	if i < nr and k < nb:
		ans = max(ans , r[i]*b[k] + f(i+1,j,k+1)) 
	#print(""???:"",ans,r[k]*r[j] + f(i,j+1,k+1))
	if k < nb and j < ng:
		ans = max(ans, g[j]*b[k] + f(i,j+1,k+1))
	#print(ans)
	return ans
print(f(0,0,0))
	
'''
def solve():
  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
  for i in range(r+1):
    for j in range(g+1):
      for k in range(b+1):
        if i+j+k<2:continue
        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
  return dp[r][g][b]
print(solve())



",cubic,1398_D,CODEFORCES,3932,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R, G, B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse=True)
g = sorted(list(map(int, input().split())), reverse=True)
b = sorted(list(map(int, input().split())), reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",cubic,1398_D,CODEFORCES,3978,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys, math
import io, os
#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
#from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction
#sys.setrecursionlimit(100000)
INF = float('inf')
mod = int(1e9)+7


def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        return 0
    if dp[r][g][b]:
        return dp[r][g][b]
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+recur(r-1,g-1,b))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+recur(r-1,g,b-1))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+recur(r,g-1,b-1))
    return dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",cubic,1398_D,CODEFORCES,3927,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
#input = sys.stdin.readline

R, G, B = list(map(int, input().split()))
r = sorted([int(x) for x in input().split()], reverse = True)
g = sorted([int(x) for x in input().split()], reverse = True)
b = sorted([int(x) for x in input().split()], reverse = True)

ans = 0

dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if  j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + b[k]*r[i])
            ans = max(ans, dp[i][j][k])
print(ans)",cubic,1398_D,CODEFORCES,3990,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"# import sys
# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            if i<n[0] and j<n[1]:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + u[0][i]*u[1][j])
            if j<n[1] and k<n[2]:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + u[1][j]*u[2][k])
            if i<n[0] and k<n[2]:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + u[0][i]*u[2][k])
res = max(x for u1 in dp for u2 in u1 for x in u2)
print(res)",cubic,1398_D,CODEFORCES,3898,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#from collections import defaultdict
#DPL=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]
ri,gi,bi=map(int,input().split())
rr=sorted(list(map(int,input().split())))
gr=sorted(list(map(int,input().split())))
br=sorted(list(map(int,input().split())))
dp=[[[-1]*(bi+1) for i in range(gi+1)] for j in range(ri+1)]
def area(r,g,b):
	if dp[r+1][g+1][b+1]!=-1:
		return dp[r+1][g+1][b+1]
	ans=0
	if r>=0 and g>=0:
		ans=max(ans,rr[r]*gr[g]+area(r-1,g-1,b))
	if r>=0 and b>=0:
		ans=max(ans,rr[r]*br[b]+area(r-1,g,b-1))	
	if b>=0 and g>=0:
		ans=max(ans,br[b]*gr[g]+area(r,g-1,b-1))	
	dp[r+1][g+1][b+1]=ans
	return ans
print(area(ri-1,gi-1,bi-1))",cubic,1398_D,CODEFORCES,3933,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"# @author --> ajaymodi
# optimized approach with memoization (dp)
import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""output.out"",""w"")

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())


from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)



def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]

	ans = 0

	if i < r and j < g:
		ans = max(solve(i+1,j+1,k) + rl[i]*gl[j],ans)

	if i < r and k < b:	
		ans = max(solve(i+1,j,k+1) + rl[i]*bl[k],ans)

	if j < g and k < b:
		ans = max(solve(i,j+1,k+1) + gl[j]*bl[k],ans)

	dp_table[i][j][k] = ans
	return dp_table[i][j][k]
		

dp_table = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",cubic,1398_D,CODEFORCES,3986,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def rec(r,g,b):
    if(dp[r][g][b]!=-1):
        return dp[r][g][b]
    ans=0
    if r<R and g<G:
        ans=max(ans, red[r]*green[g]+rec(r+1, g+1, b))
    if r<R and b<B:
        ans=max(ans, red[r]*blue[b]+rec(r+1, g, b+1))
    if b<B and g<G:
        ans=max(ans, blue[b]*green[g]+rec(r, g+1, b+1))
    dp[r][g][b]=ans
    return ans
R,G,B=map(int,input().split())
red=sorted(list(map(int, input().split())), reverse=True)
green=sorted(list(map(int, input().split())), reverse=True)
blue=sorted(list(map(int, input().split())), reverse=True)
dp=[[[-1]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
print(rec(0,0,0))",cubic,1398_D,CODEFORCES,3996,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from sys import stdin,stdout

# stdin  = open(""input.txt"",""r"")
# stdout = open(""output.txt"",""w"")


final_ans=0

# def solve(r,g,b):
# 	print(r,g,b)
# 	ans=0
# 	if min(r,g,b)<0:
# 		return 0
# 	if dparr[r-1][g-1][b]==-1:
# 		solve(r-1,g-1,b)
# 	ans=max(ans,dparr[r-1][g-1][b]+Ra[r-1]*Ga[g-1])
# 	if dparr[r-1][g][b-1]==-1:
# 		solve(r-1,g,b-1)
# 	ans=max(ans,dparr[r-1][g][b-1]+Ra[r-1]*Ba[b-1])
# 	if dparr[r][g-1][b-1]==-1:
# 		solve(r,g-1,b-1)
# 	ans=max(ans,dparr[r][g-1][b-1]+Ga[g-1]*Ba[b-1])
# 	dparr[r][g][b]=ans


R,G,B = map(int,stdin.readline().strip().split(' '))
Ra = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)
Ga = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)
Ba = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)

dparr=[[[-1 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
dparr[1][1][0]=Ra[0]*Ga[0]
dparr[1][0][1]=Ra[0]*Ba[0]
dparr[0][1][1]=Ga[0]*Ba[0]
final_ans=max(final_ans,dparr[1][1][0],dparr[1][0][1],dparr[0][1][1])
# solve(R,G,B)
# stdout.write(str(dparr[R][G][B])+""\n"")


def add_ns(t1):
	global queue,Ra,Ga,Ba,dparr
	x,y,z=t1
	if x+1<=R:
		if y+1<=G:
			if dparr[x+1][y+1][z]==-1:
				queue.append((x+1,y+1,z))
				dparr[x+1][y+1][z]=0
		
		if z+1<=B:
			if dparr[x+1][y][z+1]==-1:
				queue.append((x+1,y,z+1))
				dparr[x+1][y][z+1]=0
	if y+1<=G and z+1<=B:
		if dparr[x][y+1][z+1]==-1:
			queue.append((x,y+1,z+1))
			dparr[x][y+1][z+1]=0

def store_ans(t1):
	global final_ans,dparr,Ra,Ga,Ba
	x,y,z=t1
	if dparr[x-1][y-1][z]!=-1 and min(x-1,y-1,z)>=0:
		# print(dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])
		dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])
	if dparr[x-1][y][z-1]!=-1 and min(x-1,y,z-1)>=0:
		# print(dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])
		dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])
	if dparr[x][y-1][z-1]!=-1 and min(x,y-1,z-1)>=0:
		# print(dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])
		dparr[x][y][z] = max(dparr[x][y][z],dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])
	# print(dparr[x][y][z])

	final_ans=max(final_ans,dparr[x][y][z])

queue=[(1,1,0),(1,0,1),(0,1,1)]
add_ns(queue[0])
add_ns(queue[1])
add_ns(queue[2])
ptr=3

while ptr<len(queue):
	# print(queue[ptr])
	store_ans(queue[ptr])
	# print()
	add_ns(queue[ptr])
	
	ptr+=1

stdout.write(str(final_ans)+""\n"")",cubic,1398_D,CODEFORCES,3921,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"# XXXX
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__
# do magic here
sys.setrecursionlimit(200000)
r, g, b = map(int, input().split())
R = list(map(int, input().split()))
G = list(map(int, input().split()))
B = list(map(int, input().split()))
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

dp = [[[0 for i in range(b+5)] for j in range(g+5)] for k in range(r+5)]


def solve(i, j, k):
    x, y, z = 0, 0, 0
    if dp[i][j][k]:
        return dp[i][j][k]
    if i < r and j < g:
        x = (R[i] * G[j]) + solve(i+1, j+1, k)
    if i < r and k < b:
        y = (R[i] * B[k]) + solve(i+1, j, k+1)
    if j < g and k < b:
        z = (G[j] * B[k]) + solve(i, j+1, k+1)
    mx = max([x, y, z])
    dp[i][j][k] = mx
    return mx


print(solve(0, 0, 0))
",cubic,1398_D,CODEFORCES,3909,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
input=sys.stdin.buffer.readline

nr,ng,nb=[int(x) for x in input().split()]
r=[int(x) for x in input().split()]
g=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]

r.sort()
g.sort()
b.sort()

memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]
memo[0][0][0]=0 #starting point when i==-1,j==-1,k==-1
for i in range(nr):
    memo[i+1][0][0]=0
for j in range(ng):
    memo[0][j+1][0]=0
for k in range(nb):
    memo[0][0][k+1]=0
def dp(i,j,k): #dp(i,j,k) is the max value including r[i],g[j],b[k]
    if i<-1 or j<-1 or k<-1:
        return -float('inf')
    if memo[i+1][j+1][k+1]==-1: #offset by 1 because i,j,k can be -1
        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],
                   dp(i-1,j-1,k)+r[i]*g[j],
                   dp(i-1,j,k-1)+r[i]*b[k]
                )
    return memo[i+1][j+1][k+1]

#for i in range(max(nr,ng,nb)):
#    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))


print(dp(nr-1,ng-1,nb-1))",cubic,1398_D,CODEFORCES,3983,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"nr, ng, nb = map(int, input().split())
r = sorted([int(i) for i in input().split()])
g = sorted([int(i) for i in input().split()])
b = sorted([int(i) for i in input().split()])

dp = [[[0 for _ in range(nb + 1)] for _ in range(ng + 1)] for _ in range(nr + 1)]
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            val = 0
            if i - 1 >= 0 and j - 1 >= 0:
                val = max(val, r[i - 1] * g[j - 1] + dp[i - 1][j - 1][k])
            if i - 1 >= 0 and k - 1 >= 0:
                val = max(val, r[i - 1] * b[k - 1] + dp[i - 1][j][k - 1])
            if j - 1 >= 0 and k - 1 >= 0:
                val = max(val, g[j - 1] * b[k - 1] + dp[i][j - 1][k - 1])
            dp[i][j][k] = val

print(dp[nr][ng][nb])
",cubic,1398_D,CODEFORCES,3944,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from random import randint

mod = 10**9 + 7
d = {}
n, m, l = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
def go(i, j, k):
    val = i * 40401 + j * 201 + k
    ret = 0
    if val in d:
        return d[val]
    elif i < n and j < m and k < l:
        ret = max(a[i] * b[j] + go(i + 1, j + 1, k), b[j] * c[k] + go(i, j + 1, k + 1), c[k] * a[i] + go(i + 1, j, k + 1))
    elif i < n and j < m:
        ret = a[i] * b[j] + go(i + 1, j + 1, k)
    elif j < m and k < l:
        ret = b[j] * c[k] + go(i, j + 1, k + 1)
    elif k < l and i < n:
        ret = c[k] * a[i] + go(i + 1, j, k + 1)
    d[val] = ret
    return ret

a.sort(reverse = True)
b.sort(reverse = True)
c.sort(reverse = True)
print(go(0, 0, 0))
",cubic,1398_D,CODEFORCES,3914,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
sys.setrecursionlimit(200000)
input=sys.stdin.readline
 
def solve(r,g,b,R,G,B):
    if (r==0 and g==0) and (r==0 and b==0) and (g==0 and b==0):
        return 0
    if z[r][g][b]!=-1:
        return z[r][g][b]
    d,e,f=0,0,0
    if r!=0 and g!=0:
        d=R[r-1]*G[g-1]+solve(r-1,g-1,b,R,G,B)
    if r!=0 and b!=0:
        e=R[r-1]*B[b-1]+solve(r-1,g,b-1,R,G,B)
    if b!=0 and g!=0:
        f=B[b-1]*G[g-1]+solve(r,g-1,b-1,R,G,B)
    z[r][g][b]=max(d,e,f)
    return z[r][g][b]
 
r,g,b=map(int,input().rstrip().split())
R=sorted(map(int,input().rstrip().split()))
G=sorted(map(int,input().rstrip().split()))
B=sorted(map(int,input().rstrip().split()))
z=[[[ -1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
print(solve(r,g,b,R,G,B))",cubic,1398_D,CODEFORCES,3979,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from sys import stdin
nii=lambda:map(int,stdin.readline().split())
lnii=lambda:list(map(int,stdin.readline().split()))

R,G,B=nii()
r=lnii()
g=lnii()
b=lnii()

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp=[[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]

for i in range(R+1):
  for j in range(G+1):
    for k in range(B+1):
      c=False
      if i<R and j<G:
        dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+r[i]*g[j])
        c=True
      if j<G and k<B:
        dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+g[j]*b[k])
        c=True
      if k<B and i<R:
        dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+b[k]*r[i])
        c=True

      if not c:
        if i<R:
          dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k])
        if j<G:
          dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k])
        if k<B:
          dp[i][j][k+1]=max(dp[i][j][k+1],dp[i][j][k])

ans=0
for i in dp:
  for j in i:
    ans=max(ans,max(j))

print(ans)",cubic,1398_D,CODEFORCES,3885,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys

input = sys.stdin.readline

r, g, b = map(int, input().split())
sticks = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)]
dp, ans = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 # dp[i][j][k] is i largest red, j largest green, k largest blue
for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])
            ans = max(ans, dp[i][j][k])
print(ans)
",cubic,1398_D,CODEFORCES,3893,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans )",cubic,1398_D,CODEFORCES,4009,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"
r,g,b=map(int,input().split())
s1=[int(x) for x in input().split()]
s2=[int(x) for x in input().split()]
s3=[int(x) for x in input().split()]
s1.sort()
s2.sort()
s3.sort()
s1=s1[::-1]
s2=s2[::-1]
s3=s3[::-1]
s1=[0]+s1
s2=[0]+s2
s3=[0]+s3

dp=[]
for i in range(r+5):
    H=[]
    for j in range(g+5):
        h=[]
        for k in range(b+5):
            h.append(0)
        H.append(h)
    dp.append(H)

for i in range(0,r+1):
    for j in range(0,g+1):
        for k in range(0,b+1):
            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0
            if(i-1>=0 and j-1>=0):
                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])
            if(i-1>=0 and k-1>=0):
                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])
            if(k-1>=0 and j-1>=0):
                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])
            if(i-1>=0):
                t4 = dp[i-1][j][k]
            if(j-1>=0):
                t5 = dp[i][j-1][k]
            if(k-1>=0):
                t6 = dp[i][j][k-1]

            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)



print(dp[r][g][b])

",cubic,1398_D,CODEFORCES,3937,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import os
import heapq
import sys, threading
import math
import bisect
import operator
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)
from io import BytesIO, IOBase


def gcd(a, b):
    if b == 0:

        return a
    else:
        return gcd(b, a % b)


def power(x, p, m):
    res = 1
    while p:
        if p & 1:
            res = (res * x) % m
        x = (x * x) % m
        p >>= 1
    return res


def inar():
    return [int(k) for k in input().split()]


def lcm(num1, num2):
    return (num1 * num2) // gcd(num1, num2)
rr=0
gg=0
bb=0
dp=[]
def func(x,y,z,red,green,blue):
    if (x>=rr and y>=gg) or (y>=gg and z>=bb) or (x>=rr and z>=bb):
        return 0
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    take=0
    if x<rr and y<gg:
        take=max(take,red[x]*green[y]+func(x+1,y+1,z,red,green,blue))
    if y<gg and z<bb:
        take=max(take,green[y]*blue[z]+func(x,y+1,z+1,red,green,blue))
    if x<rr and z<bb:
        take=max(take,red[x]*blue[z]+func(x+1,y,z+1,red,green,blue))
    dp[x][y][z]=take
    return take

def main():
    global rr,gg,bb,dp
    # t=int(input())
    for i in range(202):
        temp=[]
        for j in range(202):
            lis=[]
            for k in range(202):
                lis.append(-1)
            temp.append(lis)
        dp.append(temp)
    rr, gg, bb = map(int, input().split())
    red = inar()
    green = inar()
    blue = inar()
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    print(func(0,0,0,red,green,blue))




BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
    # threadin.Thread(target=main).start()
",cubic,1398_D,CODEFORCES,3945,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def solve(x,y,z):
    global r,g,b,ans
    if (x > r - 1 and y > g - 1) or (x > r - 1 and z > b - 1) or (y > g - 1 and z > b - 1):
        return 0
    if memo[x][y][z] != -1:
        return memo[x][y][z]
    mx = 0
    if x < r and y < g: 
        mx = max(mx,ra[x]*ga[y] + solve(x+1,y+1,z))
    if x < r and z < b:
        mx = max(mx,ra[x]*ba[z] + solve(x+1,y,z+1))
    if y < g and z < b:
        mx = max(mx,ga[y]*ba[z] + solve(x,y+1,z+1))
    ans = max(ans,mx)
    memo[x][y][z] = mx
    return mx

r,g,b = map(int,input().split())
ra = sorted(list(map(int,input().split())),reverse = True)
ga = sorted(list(map(int,input().split())),reverse = True)
ba = sorted(list(map(int,input().split())),reverse = True)

memo = [[[-1 for k in range(205)] for i in range(205)] for j in range(205)]

ans = 0

solve(0,0,0)
print(ans)

",cubic,1398_D,CODEFORCES,3940,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r,g,b = map(int,input().split())
rs = list(map(int,input().split()))
gs = list(map(int,input().split()))
bs = list(map(int,input().split()))
rs.sort()
gs.sort()
bs.sort()
rs.reverse()
gs.reverse()
bs.reverse()
dp = [[[0]*201 for x in range(201)] for y in range(201)]
for i in range(min(r,g)+1):
    for j in range(min(g,b)+1):
        for k in range(min(b,r)+1):
            options = []
##            if i == 0 and j == 0:
##                dp[i][j][k] = dp[i][j][k-1] + bs[k-1]*rs[k-1]
##                continue
##            elif j == 0 and k == 0:
##                dp[i][j][k] = dp[i-1][j][k] + rs[i-1]*gs[i-1]
##                continue
##            elif i == 0 and k == 0:
##                dp[i][j][k] = dp[i][j-1][k] + gs[j-1]*bs[j-1]
##                continue
            if i == 0:
                pass
            elif i+k-1 < r and i+j-1 < g:
                options.append(dp[i-1][j][k] + rs[i+k-1]*gs[i+j-1])
            else:
                options.append(dp[i-1][j][k])
            if j == 0:
                pass
            elif i+j-1 < g and j+k-1 < b:
                options.append(dp[i][j-1][k] + gs[i+j-1]*bs[j+k-1])
            else:
                options.append(dp[i][j-1][k])
            if k == 0:
                pass
            elif j+k-1 < b and i+k-1 < r:
                options.append(dp[i][j][k-1] + bs[j+k-1]*rs[i+k-1])
            else:
                options.append(dp[i][j][k-1])
            if len(options) == 0:
                continue
            dp[i][j][k] = max(options)
print(dp[min(r,g)][min(g,b)][min(r,b)])           


##rp = r-1
##gp = g-1
##bp = b-1
##ans = 0
##m = min(rs[rp],gs[gp],bs[bp])
##if m == rs[rp] and m == gs[gp]:
##    if rp < gp:
##        ans += bs[bp]*gs[gp]
",cubic,1398_D,CODEFORCES,3915,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"c1, c2, c3 = map(int, input().split())
r = sorted(list(map(int, input().split())))
g = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))
dp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]
for i in range(c1 + 1):
    for j in range(c2 + 1):
        for k in range(c3 + 1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])
print(dp[c1][c2][c3])

",cubic,1398_D,CODEFORCES,3999,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R, G, B = list(map(lambda x: int(x), input().split()))
r = list(map(lambda x: int(x), input().split()))
g = list(map(lambda x: int(x), input().split()))
b = list(map(lambda x: int(x), input().split()))

def f(t):
    i, j, k = t
    return (i+1)*(G+1)*(B+1) + (j+1)*(B+1) + (k+1)

max_area = [None]*((R+1)*(G+1)*(B+1)+1)

def get_max_area(i, j, k):
    temp = f((i,j,k))
    if max_area[temp] != None:
        return max_area[temp]
    x1=x2=x3=0
    if i >= 0 and j>=0:
        x1 = get_max_area(i-1, j-1, k) + r[i]*g[j]
    if i >= 0 and k >= 0:
        x2 = get_max_area(i-1, j, k-1) + r[i]*b[k]
    if j >= 0 and k >= 0:
        x3 = get_max_area(i, j-1, k-1) + g[j]*b[k]

    max_area[temp] = max(x1, x2, x3)
    return max_area[temp]

r.sort()
g.sort()
b.sort()
print(get_max_area(R-1, G-1, B-1))
#print(max_area)    ",cubic,1398_D,CODEFORCES,3919,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
input=sys.stdin.buffer.readline

nr,ng,nb=[int(x) for x in input().split()]
r=[int(x) for x in input().split()]
g=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]

r.sort()
g.sort()
b.sort()

memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]
memo[0][0][0]=0 #starting point when i==-1,j==-1,k==-1
for i in range(nr):
    memo[i+1][0][0]=0
for j in range(ng):
    memo[0][j+1][0]=0
for k in range(nb):
    memo[0][0][k+1]=0
def dp(i,j,k): #dp(i,j,k) is the max value including r[i],g[j],b[k]
    if i<-1 or j<-1 or k<-1:
        return -float('inf')
    if memo[i+1][j+1][k+1]==-1: #offset by 1 because i,j,k can be -1
        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],
                   dp(i-1,j-1,k)+r[i]*g[j],
                   dp(i-1,j,k-1)+r[i]*b[k]
                )
    return memo[i+1][j+1][k+1]

for i in range(max(nr,ng,nb)):
    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))


print(dp(nr-1,ng-1,nb-1))",cubic,1398_D,CODEFORCES,3982,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from sys import stdin
import time

r,g,b = map(int,stdin.readline().split())

red = list(map(int,stdin.readline().split()))
green = list(map(int,stdin.readline().split()))
blue = list(map(int,stdin.readline().split()))
red.sort()
green.sort()
blue.sort()

dp = [[[0 for _ in range(b+1)] for _ in range(g+1)] for _ in range(r+1)]

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i>0 and j>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+red[i-1]*green[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+red[i-1]*blue[k-1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+green[j-1]*blue[k-1])

print(dp[-1][-1][-1])                       
",cubic,1398_D,CODEFORCES,3997,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"

def read_int():
    return int(raw_input().strip())


def read_ints():
    return list(map(int, raw_input().strip().split(' ')))


def solve():
    '''
    8 8 8 8 8 8
    9 9
    9 9

    81+81

    72+72+72+72
    '''
    R, G, B = read_ints()
    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]
    # dp[R][G][B]
    Rs = read_ints()
    Gs = read_ints()
    Bs = read_ints()
    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)
    answer = 0
    for r in range(R+1):
        for g in range(G+1):
            for b in range(B+1):
                if r > 0 and g > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])
                if g > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])
                if r > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])
                answer = max(answer, dp[r][g][b])
    return answer


if __name__ == '__main__':
    print(solve())
",cubic,1398_D,CODEFORCES,3930,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#tests = int(input())
#for t in range(tests):
#    b= int(input())
#    ls = [int(x) for x in input()]

r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))


dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

def recursive(idx_r, idx_g, idx_b):
    if dp[idx_r][idx_g][idx_b] is not None:
        return dp[idx_r][idx_g][idx_b]
    res_1 = 0
    res_2 = 0
    res_3 = 0
    if (idx_r-1) >= 0 and (idx_g-1) >= 0:
        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]
    if (idx_g-1) >= 0 and (idx_b-1) >= 0:
        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]
    if (idx_r-1) >= 0 and (idx_b-1) >= 0:
        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]
    
    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)
    return dp[idx_r][idx_g][idx_b]

print(recursive(r,g,b))",cubic,1398_D,CODEFORCES,3931,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys,bisect,string,math,time,functools,random,fractions
from heapq import heappush,heappop,heapify
from collections import deque,defaultdict,Counter
from itertools import permutations,combinations,groupby
rep=range;R=range
def Golf():n,*t=map(int,open(0).read().split())
def I():return int(input())
def S_():return input()
def IS():return input().split()
def LS():return [i for i in input().split()]
def MI():return map(int,input().split())
def LI():return [int(i) for i in input().split()]
def LI_():return [int(i)-1 for i in input().split()]
def NI(n):return [int(input()) for i in range(n)]
def NI_(n):return [int(input())-1 for i in range(n)]
def StoLI():return [ord(i)-97 for i in input()]
def ItoS(n):return chr(n+97)
def LtoS(ls):return ''.join([chr(i+97) for i in ls])
def RA():return map(int,open(0).read().split())
def RLI(n=8,a=1,b=10):return [random.randint(a,b)for i in range(n)]
def RI(a=1,b=10):return random.randint(a,b)
def Rtest(T):
    case,err=0,0
    for i in range(T):
        inp=INP()
        a1,ls=naive(*inp)
        a2=solve(*inp)
        if a1!=a2:
            print((a1,a2),inp)
            err+=1
        case+=1
    print('Tested',case,'case with',err,'errors')
def GI(V,E,ls=None,Directed=False,index=1):
    org_inp=[];g=[[] for i in range(V)]
    FromStdin=True if ls==None else False
    for i in range(E):
        if FromStdin:
            inp=LI()
            org_inp.append(inp)
        else:
            inp=ls[i]
        if len(inp)==2:
            a,b=inp;c=1
        else:
            a,b,c=inp
        if index==1:a-=1;b-=1
        aa=(a,c);bb=(b,c);g[a].append(bb)
        if not Directed:g[b].append(aa)
    return g,org_inp
def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1):
    #h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1) # sample usage
    mp=[boundary]*(w+2);found={}
    for i in R(h):
        s=input()
        for char in search:
            if char in s:
                found[char]=((i+1)*(w+2)+s.index(char)+1)
                mp_def[char]=mp_def[replacement_of_found]
        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]
    mp+=[boundary]*(w+2)
    return h+2,w+2,mp,found
def TI(n):return GI(n,n-1)
def accum(ls):
    rt=[0]
    for i in ls:rt+=[rt[-1]+i]
    return rt
def bit_combination(n,base=2):
    rt=[]
    for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s]
    return rt
def gcd(x,y):
    if y==0:return x
    if x%y==0:return y
    while x%y!=0:x,y=y,x%y
    return y
def YN(x):print(['NO','YES'][x])
def Yn(x):print(['No','Yes'][x])
def show(*inp,end='\n'):
    if show_flg:print(*inp,end=end)

mo=10**9+7
inf=float('inf')
FourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip('WENS',FourNb));cursol=dict(zip('LRUD',FourNb))
l_alp=string.ascii_lowercase
#sys.setrecursionlimit(10**9)
read=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()


show_flg=False
show_flg=True

ans=0

#for _ in range(I()):
x,y,z=LI()
R=sorted(LI())[::-1]
G=sorted(LI())[::-1]
B=sorted(LI())[::-1]

dp=[[[0]*(z+1) for j in range(y+1)]for i in range(x+1)]

n=x+y+z
for t in range(0,n+1,2):
    for i in range(x+1):
        for j in range(y+1):
            k=t-i-j
            if 0<=k<=z:
                if i+1<=x and j+1<=y:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
                if i+1<=x and k+1<=z:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
                if j+1<=y and k+1<=z:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])
                #show((i,j,k),dp)
ans=max([dp[i][y][z]for i in range(x+1)])
ans=max(max([dp[x][i][z]for i in range(y+1)]),ans)
ans=max(max([dp[x][y][i]for i in range(z+1)]),ans)

print(ans)


    
    
    
    ",cubic,1398_D,CODEFORCES,3960,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort()
g.sort()
b.sort()

dp=[[[0 for i in range(B+1)] for j in range(G+1)] for i in range(R+1)]

for i in range(1,R+1):
    for j in range(1,G+1):
        dp[i][j][0]=dp[i-1][j-1][0]+r[i-1]*g[j-1]

for j in range(1,G+1):
    for k in range(1,B+1):
        dp[0][j][k]=dp[0][j-1][k-1]+b[k-1]*g[j-1]

for i in range(1,R+1):
    for k in range(1,B+1):
        dp[i][0][k]=dp[i-1][0][k-1]+r[i-1]*b[k-1]

for i in range(1,R+1):
    for j in range(1,G+1):
        for k in range(1,B+1):
            if max(r[i-1],g[j-1],b[k-1])==r[i-1]:
                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])
            elif max(r[i-1],g[j-1],b[k-1])==g[j-1]:
                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i][j-1][k-1]+g[j-1]*b[k-1])
            else:
                dp[i][j][k]=max(dp[i][j-1][k-1]+b[k-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])



print(dp[R][G][B])
",cubic,1398_D,CODEFORCES,3904,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def solve():
  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
  for i in range(r+1):
    for j in range(g+1):
      for k in range(b+1):
        if i+j+k<2:continue
        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
  return dp[r][g][b]
print(solve())",cubic,1398_D,CODEFORCES,4003,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"a,b,c=list(map(int,input().split()))
R=list(map(int,input().split()))
G=list(map(int,input().split()))
B=list(map(int,input().split()))
dp=[[[0 for i in range(201)] for j in range(201)] for k in range(201)]
# print(dp)
R.sort()
G.sort()
B.sort()
for i in range(len(R)+1):
    for j in range(len(G)+1):
        for k in range(len(B)+1):
            if(i and j):
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
            if(j and k):
                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
            if(i and k):
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
print(dp[len(R)][len(G)][len(B)])      ",cubic,1398_D,CODEFORCES,3954,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
import math
from math import *
from collections import Counter,defaultdict
from io import BytesIO, IOBase
from collections import deque


def rec(i,j,k):
	if (i == rl and j == bl) or (i == rl and k == gl) or (k == gl and j == bl):
		return 0
	if dp[i][j][k] != -1:
		return dp[i][j][k]
	else:
		x = r[i]*b[j]
		y = b[j]*g[k]
		z = r[i] * g[k]
		if x>0:
			x += rec(i+1,j+1,k)
		if y>0:
			y += rec(i,j+1,k+1)
		if z>0:
			z += rec(i+1,j,k+1)

		dp[i][j][k] = max(x,y,z)
		return dp[i][j][k]

def main():
	global r,g,b,rl,bl,gl,dp

	rl,bl,gl = list(map(int, input().split()))
	r = list(map(int, input().split())) + [0]
	b = list(map(int, input().split())) + [0]
	g = list(map(int, input().split())) + [0]
	cnt =3
	i =j = k = 0
	ans = 0
	dp=[[[-1 for i in range(gl+1)] for j in range(bl+1)]for k in range(rl+1)] 
	r.sort(reverse = True)
	b.sort(reverse = True)
	g.sort(reverse = True)

	print(rec(i,j,k))
	


main()",cubic,1398_D,CODEFORCES,3959,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r, g, b = map(int, input().split())
R = list(map(int, input().split()))
G = list(map(int, input().split()))
B = list(map(int, input().split()))
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

memo = [[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]

def calc(ir, ig, ib):
    if memo[ir][ig][ib] != -1:
        return memo[ir][ig][ib]
    ans = 0
    if ir < r and ig < g:
        ans = max(ans, calc(ir+1, ig+1, ib)+R[ir]*G[ig])
    if ir < r and ib < b:
        ans = max(ans, calc(ir+1, ig, ib+1)+R[ir]*B[ib])
    if ig < g and ib < b:
        ans = max(ans, calc(ir, ig+1, ib+1)+G[ig]*B[ib])
    memo[ir][ig][ib] = ans
    return ans

print(calc(0, 0, 0))
",cubic,1398_D,CODEFORCES,3975,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from collections import defaultdict


def main():
    R, G, B = map(int, input().split())
    red = list(map(int, input().split()))
    green = list(map(int, input().split()))
    blue = list(map(int, input().split()))
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    dp = [[[-2*10**9]*(B+10) for i in range(G+10)] for j in range(R+10)]
    dp[0][0][0] = 0
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+red[i-1]*green[j-1], dp[i]
                                  [j-1][k-1]+green[j-1]*blue[k-1], dp[i-1][j][k-1]+red[i-1]*blue[k-1])
                ans = max(ans, dp[i][j][k])
    print(ans)
    return


if __name__ == ""__main__"":
    main()


",cubic,1398_D,CODEFORCES,4006,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r,g,b=map(int,input().split())
s1=[int(x) for x in input().split()]
s2=[int(x) for x in input().split()]
s3=[int(x) for x in input().split()]
s1.sort()
s2.sort()
s3.sort()
s1=s1[::-1]
s2=s2[::-1]
s3=s3[::-1]
s1=[0]+s1
s2=[0]+s2
s3=[0]+s3

dp=[]
for i in range(r+5):
    H=[]
    for j in range(g+5):
        h=[]
        for k in range(b+5):
            h.append(0)
        H.append(h)
    dp.append(H)


for i in range(0,r+1):
    for j in range(0,g+1):
        for k in range(0,b+1):
            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0
            if(i-1>=0 and j-1>=0):
                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])
            if(i-1>=0 and k-1>=0):
                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])
            if(k-1>=0 and j-1>=0):
                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])
            if(i-1>=0):
                t4 = dp[i-1][j][k]
            if(j-1>=0):
                t5 = dp[i][j-1][k]
            if(k-1>=0):
                t6 = dp[i][j][k-1]

            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)

print(dp[r][g][b])

",cubic,1398_D,CODEFORCES,3938,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
input = sys.stdin.readline

MAXN = 202

def main():
    R, G, B = list(map(int, input().split()))
    r = list(map(int, input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))
    r.sort()
    g.sort()
    b.sort()
    dp = [[[0]*MAXN for _ in range(MAXN)] for _ in range(MAXN)]
    for i in range(1, R+1):
        for j in range(1, G+1):
            dp[i][j][0] = r[i-1]*g[j-1]+dp[i-1][j-1][0]
    for i in range(1, R+1):
        for k in range(1, B+1):
            dp[i][0][k] = r[i-1]*b[k-1]+dp[i-1][0][k-1]
    for j in range(1, G+1):
        for k in range(1, B+1):
            dp[0][j][k] = g[j-1]*b[k-1]+dp[0][j-1][k-1]
    for i in range(1, R+1):
        for j in range(1, G+1):
            for k in range(1, B+1):
                dp[i][j][k] = max(r[i-1]*g[j-1]+dp[i-1][j-1][k], r[i-1]*b[k-1]+dp[i-1][j][k-1], g[j-1]*b[k-1]+dp[i][j-1][k-1])
    print(dp[R][G][B])

main()
",cubic,1398_D,CODEFORCES,3935,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi
def yes():print('YES')
def no():print('NO')
if (path.exists('input.txt')): 
    #------------------Sublime--------------------------------------#
    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
    def I():return (int(input()))
    def In():return(map(int,input().split()))
else:
    #------------------PYPY FAst I/o--------------------------------#
    def I():return (int(stdin.readline()))
    def In():return(map(int,stdin.readline().split()))
#sys.setrecursionlimit(1500)
def dict(a):
    d={} 
    for x in a:
        if d.get(x,-1)!=-1:
            d[x]+=1
        else:
            d[x]=1
    return d
def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:            
        return -1

def cal(r,g,b,dp,R,G,B,nr,ng,nb):
    if dp[r][g][b]!=-1:
        return dp[r][g][b]
    best=0
    if r<nr and g<ng:
        best=max(best,cal(r+1,g+1,b,dp,R,G,B,nr,ng,nb)+R[r]*G[g])
    if r<nr and b<nb:
        best=max(best,cal(r+1,g,b+1,dp,R,G,B,nr,ng,nb)+R[r]*B[b])
    if g<ng and b<nb:
        best=max(best,cal(r,g+1,b+1,dp,R,G,B,nr,ng,nb)+B[b]*G[g])
    dp[r][g][b]=best
    return dp[r][g][b]
def main():
    try:
        nr,ng,nb=In()
        dp=[[[-1 for x in range(201)]for y in range(201)] for z in range(201)]
        R=list(In())
        G=list(In())
        B=list(In())
        R.sort(reverse=True)
        G.sort(reverse=True)
        B.sort(reverse=True)
        print(cal(0,0,0,dp,R,G,B,nr,ng,nb))
    except:
        pass
        
M = 998244353
P = 1000000007
 
if __name__ == '__main__':
    # for _ in range(I()):main()
    for _ in range(1):main()",cubic,1398_D,CODEFORCES,4008,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))

r, g, b = nm()
R = nl()
G = nl()
B = nl()
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i==0 and j==0 and k==0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans, dp[i][j][k])
print(ans)",cubic,1398_D,CODEFORCES,3971,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from math import *
from collections import *
from random import *
from decimal import Decimal
from heapq import *
from bisect import *
import sys
input=sys.stdin.readline
sys.setrecursionlimit(10**5)
def lis():
    return list(map(int,input().split()))
def ma():
    return map(int,input().split())
def inp():
    return int(input())
def st1():
    return input().rstrip('\n')
t=1
while(t):
    t-=1
    r,g,b=ma()
    rl=lis()
    gl=lis()
    bl=lis()
    rl.sort()
    bl.sort()
    gl.sort()
    dp= [[[0]*(b+1)for i in range(g+1)] for j in range(r+1)]
    for i in range(r+1):
        for j in range(g+1):
            for k in range(b+1):
                if(i+j+k<2):
                    continue
                if(i and j):
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rl[i-1]*gl[j-1])
                if(j and k):
                    dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gl[j-1]*bl[k-1])
                if(i and k):
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rl[i-1]*bl[k-1])
    print(dp[r][g][b])
    
        
",cubic,1398_D,CODEFORCES,3929,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import os
import heapq
import sys
import math
import operator
from collections import defaultdict
from io import BytesIO, IOBase


""""""def gcd(a,b):
    if b==0:
        return a
    else:
        return gcd(b,a%b)""""""

""""""def pw(a,b):
    result=1
    while(b>0):
        if(b%2==1): result*=a
        a*=a
        b//=2
    return result""""""

def inpt():
    return [int(k) for k in input().split()]

def main():
    n1, n2, n3 = map(int, input().split())
    ar = [int(x) for x in input().split()]
    br = [int(x) for x in input().split()]
    cr = [int(x) for x in input().split()]
    ar.sort()
    br.sort()
    cr.sort()
    dp = [[[0 for x in range(201)] for y in range(201)] for z in range(201)]
    for i in range(n1 + 1):
        for j in range(n2 + 1):
            for k in range(n3 + 1):
                if (i and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + (ar[i - 1] * br[j - 1]))
                if (i and k):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + (ar[i - 1] * cr[k - 1]))
                if (k and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + (cr[k - 1] * br[j - 1]))
    print(dp[n1][n2][n3])


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()

",cubic,1398_D,CODEFORCES,3980,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
from math import sqrt, gcd, ceil, log, floor
from bisect import bisect, bisect_left
from collections import defaultdict, Counter, deque
from heapq import heapify, heappush, heappop
input = sys.stdin.readline
read = lambda: list(map(int, input().strip().split()))

MOD = 10**9 + 7


def main():
	# ans_ = []
	# ans_.append(ans)
	# print((""\n"").join(map(str, ans_)))
	r, g, b = read()
	r_ar=sorted(read(), reverse = True); g_ar = sorted(read(), reverse = True); b_ar = sorted(read(), reverse = True)
	N = 201
	dp = [[[-1]*N for i in range(N)]for j in range(N)]
	# for i in dp:print(*i)
	def f(x, y, z):
		# print(x, y, z, (x >= r) + (y >= g) + (z >= b))
		if ((x >= r) + (y >= g) + (z >= b)) >= 2:
			return(0)
		if dp[x][y][z] != -1:
			return(dp[x][y][z])
		maxi = 0
		if x < r and y < g:
			maxi = max(maxi, r_ar[x]*g_ar[y] + f(x+1, y+1, z))
		if z < b and y < g:
			maxi = max(maxi, b_ar[z]*g_ar[y] + f(x, y+1, z+1))
		if x < r and z < b:
			maxi = max(maxi, r_ar[x]*b_ar[z] + f(x+1, y, z+1))
		dp[x][y][z] = maxi
		return(maxi)
	print(f(0, 0, 0))





if __name__ == ""__main__"":
	main()",cubic,1398_D,CODEFORCES,3985,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]
 
DP = [0] * ((R+1) * (G+1) * (B+1))
def idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b
 
for r in range(R+1):
	for g in range(G+1):
		for b in range(B+1):
			best = 0
 
			if r:
				if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
				if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])
 
			if g and b:
				best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])
 
			DP[idx(r, g, b)] = best
 
print(max(DP))",cubic,1398_D,CODEFORCES,3998,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#!/usr/bin/env python3
import sys
input = sys.stdin.readline
import heapq

R, G, B = map(int, input().split())
r = [int(item) for item in input().split()]
g = [int(item) for item in input().split()]
b = [int(item) for item in input().split()]
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
nr = len(r)
ng = len(g)
nb = len(b)

dp = [[[0] * (nb+1) for _ in range(ng+1)] for _ in range(nr+1)]
ans = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if (i + j + k) % 2 == 1:
                continue
            if i > 0 and j > 0:
                # Make RG
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + r[i-1] * g[j-1])
            if j > 0 and k > 0:
                # Make GB
                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1] + g[j-1] * b[k-1])
            if i > 0 and k > 0:
                # Make BR
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1] + b[k-1] * r[i-1])
            ans = max(ans, dp[i][j][k])

print(ans)",cubic,1398_D,CODEFORCES,3905,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def solve(rn,gn,bn,r,g,b):
    r = sorted(r,reverse=True)
    g = sorted(g, reverse=True)
    b = sorted(b, reverse=True)

    dp = [[[0 for k in range(bn+1)] for j in range(gn+1)] for i in range(rn+1)]


    ans = 0
    for i in range(rn+1):
        for j in range(gn+1):
            for k in range(bn+1):
                if i < rn and j < gn:
                    dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
                if i < rn and k < bn:
                    dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
                if j < gn and k <bn:
                    dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])

                ans = max(ans,dp[i][j][k])

    print(ans)






if __name__ == '__main__':
    rn, gn, bn = map(int,input().split())

    r = list(map(int,input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))

    solve(rn,gn,bn,r,g,b)",cubic,1398_D,CODEFORCES,3972,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]
DP = [0] * ((R+1) * (G+1) * (B+1))

def idx(r, g, b):
  return r * (G+1) * (B+1) + g * (B+1) + b

for r in range(R+1):
  for g in range(G+1):
    for b in range(B+1):
      best = 0
      if r:
        if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
        if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])
      if g and b:
        best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])
      DP[idx(r, g, b)] = best
print(max(DP))
",cubic,1398_D,CODEFORCES,4002,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r,g,b=map(int,input().split())
R=list(map(int,input().split()))
R.sort()
G=list(map(int,input().split()))
G.sort()
B=list(map(int,input().split()))
B.sort()
dp=[[[0]*(b+1) for i in range(g+1)] for j in range(r+1)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])
print(dp[r][g][b])",cubic,1398_D,CODEFORCES,3896,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def solve():
	r,g,b=map(int,input().split())
	R=list(map(int,input().split()))
	G=list(map(int,input().split()))
	B=list(map(int,input().split()))
	R.sort(reverse=True)
	G.sort(reverse=True)
	B.sort(reverse=True)
	dp=[[[0]*(b+1) for _ in range(g+1)]for _ in range(r+1)]
	for i in range(r+1):
		for j in range(g+1):
			for k in range(b+1):
				if i<r and j<g:
					dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
				if i<r and k<b:
					dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
				if j<g and k<b:
					dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+B[k]*G[j])
	ans=0
	for i in range(r+1):
		for j in range(g+1):
			for k in range(b+1):
				ans=max(ans,dp[i][j][k])
	return ans
print(solve())",cubic,1398_D,CODEFORCES,3951,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"n, m, v = map(lambda x: int(x) + 1, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
dp = []
for i in range(n):
    dp.append([])
    for j in range(m):
        dp[i].append([0] * v)
a.sort(reverse=1)
b.sort(reverse=1)
c.sort(reverse=1)
a = [0] + a
b = [0] + b
c = [0] + c
ans = 0
for i in range(n):
    for j in range(m):
        for k in range(v):
            if i == j == k == 0:
                continue
            if i == j == 0 or i == k == 0 or j == k == 0:
                continue
            if i == 0:
                dp[i][j][k] = dp[i][j - 1][k - 1] + \
                              b[j] * c[k]
            elif j == 0:
                dp[i][j][k] = dp[i - 1][j][k - 1] + \
                              a[i] * c[k]
            elif k == 0:
                dp[i][j][k] = dp[i - 1][j - 1][k] + \
                              a[i] * b[j]
            else:
                dp[i][j][k] = max(dp[i - 1][j - 1][k] + a[i] * b[j],
                                  dp[i - 1][j][k - 1] + a[i] * c[k],
                                  dp[i][j - 1][k - 1] + b[j] * c[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",cubic,1398_D,CODEFORCES,3910,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#!/usr/bin/env python3
import io
import os
import sys

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

def prdbg(*args, **kwargs):
    print(*args, **kwargs)
    pass

def get_str():
    return input().decode().strip()

def rint():
    return map(int, input().split())

def oint():
    return int(input())

def valid(i1,i2,i3):
    if (i1+i2+i3)%2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2\
            or i2 > i1 + i3 or i1 > i2 + i3:
        return False
    return True

def dfs(i1,i2,i3):
    #if not valid(i1, i2, i3):
    if (i1 + i2 + i3) % 2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2 \
                or i2 > i1 + i3 or i1 > i2 + i3:
        return -2
    if dp[i1][i2][i3] != -1:
        return dp[i1][i2][i3]
    ret1 = dfs(i1-1, i2-1, i3)
    if ret1 >= 0 :
        ret1 += a1[i1]*a2[i2]
    ret2 = dfs(i1-1, i2, i3-1)
    if ret2 >= 0:
        ret2 += a1[i1]*a3[i3]
    ret3 = dfs(i1, i2-1, i3-1)
    if ret3 >= 0:
        ret3 += a2[i2]*a3[i3]
    ret = max(ret1, ret2, ret3)
    dp[i1][i2][i3] = ret
    return ret

n1, n2, n3 = rint()
a1, a2, a3 = list(rint()), list(rint()), list(rint())
a1.sort(reverse=True)
a2.sort(reverse=True)
a3.sort(reverse=True)
a1 = [0] + a1
a2 = [0] + a2
a3 = [0] + a3
n1 += 1
n2 += 1
n3 += 1

dp = [[[-1 for i3 in range(n3)] for i2 in range(n2)] for i1 in range(n1)]
dp[1][1][0] = a1[1]*a2[1]
dp[1][0][1] = a1[1]*a3[1]
dp[0][1][1] = a2[1]*a3[1]
dp[0][0][0] = -2

for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            dfs(i1, i2, i3)
ans = -1
for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            ans = max(ans, dp[i1][i2][i3])
#print(a1,a2,a3)
print(ans)
",cubic,1398_D,CODEFORCES,3950,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def getArray():
    return list(map(int, input().split()))
def createDP(R, G, B):
    dp = []
    for i in range(R):
        temp1 = []
        for j in range(G):
            temp2 = []
            for k in range(B):
                temp2.append(-1)
            temp1.append(temp2)
        dp.append(temp1)
    return dp
def go(r, g, b, R, G, B, ri, gi, bi, state):
    if state[ri][gi][bi] != -1 :
        return state[ri][gi][bi]
    best = 0
    if ri < R and gi < G:
        best = max(best, r[ri]*g[gi] + go(r, g, b, R, G, B, ri+1, gi+1, bi, state))
    if ri < R and bi < B:
        best = max(best, r[ri]*b[bi] + go(r, g, b, R, G, B, ri+1, gi, bi+1, state))
    if gi < G and bi < B:
        best = max(best, g[gi]*b[bi] + go(r, g, b, R, G, B, ri, gi+1, bi+1, state))
    
    state[ri][gi][bi] = best
    return best
    
R,G,B = map(int, input().split())
r = getArray()
g = getArray()
b = getArray()
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = createDP(201,201,201)
print(go(r, g, b, R, G, B, 0, 0, 0, dp))",cubic,1398_D,CODEFORCES,3984,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys

input = sys.stdin.readline

r, g, b = map(int, input().split())
sticks, dp, ans = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)], [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 # dp[i][j][k] is i largest red, j largest green, k largest blue

for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            ans = max(ans, dp[i][j][k])
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])
print(ans)
",cubic,1398_D,CODEFORCES,3894,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import pprint
nr, ng, nb = map(int, input().split())
*r, = map(int, input().split())
*g, = map(int, input().split())
*b, = map(int, input().split())
dp = []
for _ in range(nr + 1):
    dp.append([[0] * (nb + 1) for _ in range(ng + 1)])

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

mx = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if i and j:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            if i and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])
            if j and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])


mx_i = mx_j = mx_k = -1

for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if dp[i][j][k] > mx:
                mx_i = i
                mx_j = j
                mx_k = k
                mx = dp[i][j][k]

print(mx)
",cubic,1398_D,CODEFORCES,3989,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R,G,B=list(map(int,input().split()))
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp = [[[0 for i in range(B + 1)] for j in range(G + 1)] for k in range(R + 1)]
ans=0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],r[i]*g[j]+dp[i][j][k])
            if i<R and k<B:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],r[i]*b[k]+dp[i][j][k])
            if k<B and j<G:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],b[k]*g[j]+dp[i][j][k])
            ans=max(ans,dp[i][j][k])
print(ans)",cubic,1398_D,CODEFORCES,4005,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r,g,b=map(int,input().split())
rs=sorted(list(map(int,input().split())))
gs=sorted(list(map(int,input().split())))
bs=sorted(list(map(int,input().split())))
dp=[[[0 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
ans=0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i>0 and k>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rs[i-1]*bs[k-1])
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rs[i-1]*gs[j-1])
            if j>0 and k>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gs[j-1]*bs[k-1])
            ans=max(ans,dp[i][j][k])
print(ans)
",cubic,1398_D,CODEFORCES,3889,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"# for #!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion
class union_find:
    def __init__(self, n):
        self.n = n
        self.rank = [0]*n
        self.parent = [int(j) for j in range(n)]
    
    def union(self,i,j):
        i = self.find(i)
        j = self.find(j)
        if self.rank[i] == self.rank[j]:
            self.parent[i] = j
            self.rank[j] += 1

        elif self.rank[i] > self.rank[j]:
            self.parent[j] = i
        else:
            self.parent[i] = j

    def find(self, i):
        temp = i
        if self.parent[temp] != temp:
            self.parent[temp] = self.find(self.parent[temp])
        return self.parent[temp]
from math import log2, ceil
from collections import deque, Counter as CC, defaultdict as dd
def main():
# Enter your code here. Read input from STDIN. Print output to STDOUT
    # for t in range(int(input())):
        
        # n = int(input())
        p,q,r  = [int(j) for j in input().split()]
        a = [int(j) for j in input().split()]
        b = [int(j) for j in input().split()]
        c = [int(j) for j in input().split()]
        a.sort()
        b.sort()
        c.sort()
        l = [a,b,c]

        dp = [[[0 for i in range(r+1)] for j in range(q+1)] for k in range(p+1)]
        for i in range(p+1):
            for j in range(q+1):
                for k in range(r+1):
                    s = [i-1,j-1,k-1]
                    for u in range(3):
                        
                        s[u]+=1
                        try:
                            tmp = dp[s[0]][s[1]][s[2]]
                        except:
                            s[u]-=1
                            continue
                        tmp2 = 1
                        flag =True
                        for t in range(3):
                            if(u!=t):
                                if(s[t]==-1):
                                    flag = False
                                    break
                                tmp2 *= l[t][s[t]] 
                        tmp += tmp2
                        s[u]-=1
                        if(flag):
                            dp[i][j][k] = max(dp[i][j][k], tmp)
        print(dp[p][q][r])











        



if __name__ == ""__main__"":
    main()",cubic,1398_D,CODEFORCES,3934,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R,G,B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse =True)
g = sorted(list(map(int, input().split())), reverse =True)
b = sorted(list(map(int, input().split())), reverse =True)
def f(x,y,z):
    m1 = 0
    m2 = 0
    m3 = 0
    if(x<R and y<G):
        if(dpt[x+1][y+1][z]==-1):
            dpt[x+1][y+1][z] = f(x+1,y+1,z)
        m1 = r[x]*g[y] + dpt[x+1][y+1][z]
    if(y<G and z<B):
        if(dpt[x][y+1][z+1]==-1):
            dpt[x][y+1][z+1] = f(x,y+1,z+1)
        m2 = g[y]*b[z] + dpt[x][y+1][z+1]
    if(z<B and x<R):
        if(dpt[x+1][y][z+1]==-1):
            dpt[x+1][y][z+1] = f(x+1,y,z+1)
        m3 = r[x]*b[z] + dpt[x+1][y][z+1]
    dpt[x][y][z] = max(m1,m2,m3)
    return dpt[x][y][z]
dpt = [[[-1 for _ in range(B+1)]for _ in range(G+1)]for _ in range(R+1)]
print(f(0,0,0))",cubic,1398_D,CODEFORCES,3912,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def solve(r, g, b, rs, gs, bs):
    rs.sort(reverse=True)
    gs.sort(reverse=True)
    bs.sort(reverse=True)
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    sol = 0
    for ri in range(r+1):
        for gi in range(g+1):
            for bi in range(b+1):
                if ri < r and gi < g:
                    dp[ri+1][gi+1][bi] = max(dp[ri+1][gi+1][bi], rs[ri]*gs[gi] + dp[ri][gi][bi])
                if ri < r and bi < b:
                    dp[ri+1][gi][bi+1] = max(dp[ri+1][gi][bi+1], rs[ri]*bs[bi] + dp[ri][gi][bi])
                if gi < g and bi < b:
                    dp[ri][gi+1][bi+1] = max(dp[ri][gi+1][bi+1], gs[gi]*bs[bi] + dp[ri][gi][bi])
                sol = max(sol, dp[ri][gi][bi])
    return sol

r, g, b = map(int, input().split())
rs = list(map(int, input().split()))
gs = list(map(int, input().split()))
bs = list(map(int, input().split()))
print(solve(r, g, b, rs, gs, bs))",cubic,1398_D,CODEFORCES,3961,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R,G,B = map(int,input().split())
r = list(map(int,input().split()))
g = list(map(int,input().split()))
b = list(map(int,input().split()))
r.sort()
g.sort()
b.sort()
dp = []
for i in range(R+1):
	d = []
	for j in range(G+1):
		d.append([0]*(B+1))
	dp.append(d)
for i in range(R+1):
	for j in range(G+1):
		for k in range(B+1):
			if i+j+k<2:
				continue
			if i>0 and j>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
			if i>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+r[i-1]*b[k-1])
			if j>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])

",cubic,1398_D,CODEFORCES,3970,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"# import sys
# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            x0 = (dp[i-1][j-1][k] + u[0][i-1]*u[1][j-1]) if i and j else 0
            x1 = (dp[i][j-1][k-1] + u[1][j-1]*u[2][k-1]) if j and k else 0
            x2 = (dp[i-1][j][k-1] + u[0][i-1]*u[2][k-1]) if i and k else 0
            dp[i][j][k] = max(x0, x1, x2)
            res = max(res, dp[i][j][k])
print(res)",cubic,1398_D,CODEFORCES,3899,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]


def dp(r1, g1, b1):
    if mem[r1][g1][b1] != -1:
        return mem[r1][g1][b1]

    v1, v2, v3 = 0, 0, 0

    if r1 < r:
        if g1 < g:
            v1 = (ar[r1] * ag[g1]) + dp(r1 + 1, g1 + 1, b1)
        if b1 < b:
            v2 = (ar[r1] * ab[b1]) + dp(r1 + 1, g1, b1 + 1)

    if g1 < g and b1 < b:
        v3 = (ag[g1] * ab[b1]) + dp(r1, g1 + 1, b1 + 1)

    mem[r1][g1][b1] = max(v1, v2, v3)

    return mem[r1][g1][b1]


r, g, b = rints()
ar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]
mem = [[[-1 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]
print(dp(0, 0, 0))
",cubic,1398_D,CODEFORCES,3953,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R,G,B = map(int,input().split())
r = sorted(list(map(int,input().split())), reverse=True)
g = sorted(list(map(int,input().split())), reverse=True)
b = sorted(list(map(int,input().split())), reverse=True)

dp = [[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]
ans = 0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if j*k > 0:
                dp[i][j][k] = max(dp[i][j-1][k-1]+g[j-1]*b[k-1],dp[i][j][k])
            if i*k > 0:
                dp[i][j][k] = max(dp[i-1][j][k-1]+r[i-1]*b[k-1],dp[i][j][k])
            if i*j > 0:
                dp[i][j][k] = max(dp[i-1][j-1][k]+g[j-1]*r[i-1],dp[i][j][k])
            ans = max(ans,dp[i][j][k])
print(ans)",cubic,1398_D,CODEFORCES,3988,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import os
import sys
import math
import heapq
from decimal import *
from io import BytesIO, IOBase
from collections import defaultdict, deque

def r():
    return int(input())
def rm():
    return map(int,input().split())
def rl():
    return list(map(int,input().split()))

r,g,b = rm()
R = rl()
G = rl()
B = rl()
R.sort()
G.sort()
B.sort()
dp = [[[0]*(b+1) for j in range(g+1)] for i in range(r+1)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i and j:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+R[i-1]*G[j-1])
            if j and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+G[j-1]*B[k-1])
            if k and i:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+B[k-1]*R[i-1])
print(dp[r][g][b])",cubic,1398_D,CODEFORCES,3957,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#tests = int(input())
#for t in range(tests):
#    b= int(input())
#    ls = [int(x) for x in input()]

r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))


dp = [[[-1 for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

def recursive(idx_r, idx_g, idx_b):
    if dp[idx_r][idx_g][idx_b] != -1:
        return dp[idx_r][idx_g][idx_b]
    res_1 = 0
    res_2 = 0
    res_3 = 0
    if (idx_r-1) >= 0 and (idx_g-1) >= 0:
        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]
    if (idx_g-1) >= 0 and (idx_b-1) >= 0:
        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]
    if (idx_r-1) >= 0 and (idx_b-1) >= 0:
        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]
    
    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)
    return dp[idx_r][idx_g][idx_b]

print(recursive(r,g,b))",cubic,1398_D,CODEFORCES,3941,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import math
import time
from collections import defaultdict,deque,Counter
from sys import stdin,stdout
from bisect import bisect_left,bisect_right
from queue import PriorityQueue 
import sys
t=1
# t=int(input())
for _ in range(t):
    r,g,b=map(int,stdin.readline().split())
    ra=list(map(int,stdin.readline().split()))
    ga=list(map(int,stdin.readline().split()))
    ba=list(map(int,stdin.readline().split()))
    ra.sort()
    ga.sort()
    ba.sort()
    dp=[[[0]*201 for _ in range(201)]for _ in range(201)]
    for i in range(r+1):
        for j in range(g+1):
            for k in range(b+1):
                if(i and j>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+ra[i-1]*ga[j-1])
                if(i and k>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+ra[i-1]*ba[k-1])
                if(k and j>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+ga[j-1]*ba[k-1])
    print(dp[r][g][b])
",cubic,1398_D,CODEFORCES,3963,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
from array import array  # noqa: F401
import typing as Tp  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def output(*args):
    sys.stdout.buffer.write(
        ('\n'.join(map(str, args)) + '\n').encode('utf-8')
    )


def main():
    R, G, B = map(int, input().split())
    r_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]
    g_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]
    b_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]

    dp = [[[0.0] * (B + 2) for _ in range(G + 2)] for _ in range(R + 2)]

    for ri in range(R + 1):
        for gi in range(G + 1):
            for bi in range(B + 1):
                dp[ri + 1][gi + 1][bi] = max(dp[ri + 1][gi + 1][bi], dp[ri][gi][bi] + r_sticks[ri] * g_sticks[gi])
                dp[ri + 1][gi][bi + 1] = max(dp[ri + 1][gi][bi + 1], dp[ri][gi][bi] + r_sticks[ri] * b_sticks[bi])
                dp[ri][gi + 1][bi + 1] = max(dp[ri][gi + 1][bi + 1], dp[ri][gi][bi] + g_sticks[gi] * b_sticks[bi])

    ans = max(max(max(dp[r][g][b] for b in range(B + 1)) for g in range(G + 1)) for r in range(R + 1))
    print(int(ans + 1e-6))


if __name__ == '__main__':
    main()
",cubic,1398_D,CODEFORCES,3886,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r, g, b = map(int, input().split(' '))
R = list(map(int, input().split(' ')))
G = list(map(int, input().split(' ')))
B = list(map(int, input().split(' ')))
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i == 0 and j == 0 and k == 0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans,dp[i][j][k])
print(ans)",cubic,1398_D,CODEFORCES,3949,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]

r, g, b = rints()
ar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]
mem = [[[0 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]
ans = 0

for r1 in range(r + 1):
    for g1 in range(g + 1):
        for b1 in range(b + 1):
            if r1 < r:
                if g1 < g:
                    mem[r1 + 1][g1 + 1][b1] = max(mem[r1 + 1][g1 + 1][b1], (ar[r1] * ag[g1]) + mem[r1][g1][b1])
                if b1 < b:
                    mem[r1 + 1][g1][b1 + 1] = max(mem[r1 + 1][g1][b1 + 1], (ar[r1] * ab[b1]) + mem[r1][g1][b1])

            if g1 < g and b1 < b:
                mem[r1][g1 + 1][b1 + 1] = max(mem[r1][g1 + 1][b1 + 1], (ag[g1] * ab[b1]) + mem[r1][g1][b1])

            ans = max(ans, mem[r1][g1][b1])

print(ans)",cubic,1398_D,CODEFORCES,3973,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"
r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])
                    
print(ans)
                                   
                
            
",cubic,1398_D,CODEFORCES,3955,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"# import io.os
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def func(n1,n2,n3):
    global r,g,b 
    if((n1<0 and n2<0) or (n3<0 and n2<0) or (n1<0 and n3<0) ):
        return 0 
    if(n1<0):
        return g[n2]*b[n3] + func(n1,n2-1,n3-1)
    if(n2<0):
        return r[n1]*b[n3] + func(n1-1,n2,n3-1)
    if(n3<0):
        return g[n2]*r[n1] + func(n1-1,n2-1,n3)
    if(dp[n1][n2][n3]==-1):
        dp[n1][n2][n3]= max(g[n2]*b[n3] + func(n1,n2-1,n3-1),r[n1]*b[n3] + func(n1-1,n2,n3-1),g[n2]*r[n1] + func(n1-1,n2-1,n3))
    return dp[n1][n2][n3]

# def func(n1,n2,n3):
#     for i in range(n1):
#         for j in range(n2):
#             for k in range(n3):
#                 if(i==0 and j==0 and k==0):
#                     dp[i][j][k] = max(r[i]*g[j],g[j]*b[k],b[k]*r[i])
#                 elif(i==0 and j==0):
#                     dp[i][j][k]=max(g[j]*b[k] + dp[i][j-1][k-1],r[i]*b[k] + dp[i-1][j][k-1],g[j]*r[i] + dp[i-1][j-1][k])
#                 dp[i][j][k]=max(g[j]*b[k] + dp[i][j-1][k-1],r[i]*b[k] + dp[i-1][j][k-1],g[j]*r[i] + dp[i-1][j-1][k])

R,G,B=tuple(map(int,input().split()))
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r=sorted(r)
g=sorted(g)
b=sorted(b)
prefix1=[0]*R 
prefix2 = [0]*G 
prefix3 = [0]*B 
prefix1[0]=r[0]
prefix2[0] = g[0]
prefix3[0]=b[0]
dp=[[[-1 for i in range(B)] for j in range(G)]for k in range(R)]
# for i in range(1,R):
#     prefix1[i]=prefix1[i-1]*r[i]
# for i in range(1,G):
#     prefix2[i]=prefix2[i-1]*g[i]
# for i in range(1,B):
#     prefix3[i]=prefix3[i-1]*b[i]
print(func(R-1,G-1,B-1))",cubic,1398_D,CODEFORCES,3887,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def solve(i, j, k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    call = 0
    if i>0 and j>0:
        call = max(call, R[i]*G[j]+solve(i-1, j-1, k))
    if j>0 and k>0:
        call = max(call, G[j]*B[k]+solve(i, j-1, k-1))
    if k>0 and i>0:
        call = max(call, B[k]*R[i]+solve(i-1, j, k-1))
    dp[i][j][k] = call
    return call


nr, ng, nb = map(int,input().split())
R = [0]+list(map(int,input().split()))
G = [0]+list(map(int,input().split()))
B = [0]+list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1]*(nb+1) for j in range(ng+1)] for i in range(nr+1)]
ans = solve(nr, ng, nb)
print(ans)",cubic,1398_D,CODEFORCES,3948,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"# import sys
# sys.stdin = open('CF_E93_D2/input.txt', 'r') 
# sys.stdout = open('CF_E93_D2/output.txt', 'w')
#----------------------------------------------------------------

r,g,b = list(map(int,input().split()))
dp = [ [ [-1]*(b+1) for i in range(g+1) ] for j in range(r+1) ]
ra = sorted(list(map(int,input().split())),reverse=True)
ga = sorted(list(map(int,input().split())),reverse=True)
ba = sorted(list(map(int,input().split())),reverse=True)

def solve(i,j,k) :
    
    if dp[i][j][k] != -1 :
        return dp[i][j][k]

    if i==r :
        if j==g or k==b :
            return 0
        dp[i][j][k] = ga[j] * ba[k] + solve(i,j+1,k+1)

    elif j==g :
        if i==r or k==b:
            return 0
        dp[i][j][k] = ra[i] * ba[k] + solve(i+1,j,k+1)
        
    elif k==b :
        if j==g or i==r:
            return 0
        dp[i][j][k] = ga[j] * ra[i] + solve(i+1,j+1,k)
    
    else :
        dp[i][j][k] = max(ra[i]*ga[j] + solve(i+1,j+1,k),ra[i]*ba[k] + solve(i+1,j,k+1),ba[k]*ga[j] + solve(i,j+1,k+1))

    return dp[i][j][k]


print(solve(0,0,0))",cubic,1398_D,CODEFORCES,3916,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from sys import stdin
from array import array
def recSolve(dp,r,g,b,rx,gx,bx, R, G, B):
	if rx == R:
		return sum(a * b for a, b in zip(g[gx:], b[bx:]))
	if gx == G:
		return sum(a * b for a, b in zip(r[rx:], b[bx:]))
	if bx == B:
		return sum(a * b for a, b in zip(g[gx:], r[rx:]))
	if dp[rx * G * B + gx * B + bx] != -1:
		return dp[rx * G * B + gx * B + bx]
	rg = recSolve(dp, r, g, b, rx + 1, gx + 1, bx, R, G, B) + r[rx] * g[gx]
	bg = recSolve(dp, r, g, b, rx, gx + 1, bx + 1, R, G, B) + b[bx] * g[gx]
	rb = recSolve(dp, r, g, b, rx + 1, gx, bx + 1, R, G, B) + r[rx] * b[bx]
	ans = max(rg, bg, rb)
	dp[rx * G * B + gx * B + bx] = ans
	return ans
input = stdin.readline
R, G, B = map(int, input().split())
r = sorted([*map(int, input().split())], reverse = True)
g = sorted([*map(int, input().split())], reverse = True) 
b = sorted([*map(int, input().split())], reverse = True) 
dp = array('q', (-1 for x in range(R * G * B)))
print(recSolve(dp, r, g, b, 0, 0, 0, R, G, B))",cubic,1398_D,CODEFORCES,3918,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R, G, B = list(map(int, input().split()))
r = [int(x) for x in input().split()]
r.sort(reverse=True)
g = [int(x) for x in input().split()]
g.sort(reverse=True)
b = [int(x) for x in input().split()]
b.sort(reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",cubic,1398_D,CODEFORCES,3976,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r,g,b = map(int,input().split())
R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
def solve(r,g,b):
	if ((r==0 and g==0) or (g==0 and b==0) or (b==0 and r==0)):
		return 0
	if dp[r][g][b]==-1:
		if r==0:
			ans =  G[g-1]*B[b-1]+solve(r,g-1,b-1)
		elif g==0:
			ans =  R[r-1]*B[b-1]+solve(r-1,g,b-1)
		elif b==0:
			ans =  G[g-1]*R[r-1]+solve(r-1,g-1,b)
		else:
			ans =  max(G[g-1]*B[b-1]+solve(r,g-1,b-1),G[g-1]*R[r-1]+solve(r-1,g-1,b),R[r-1]*B[b-1]+solve(r-1,g,b-1))
		dp[r][g][b] = ans
	return dp[r][g][b]
ans = solve(r,g,b)
print(ans)",cubic,1398_D,CODEFORCES,3994,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from sys import stdin
input=lambda : stdin.readline().strip()
lin=lambda :list(map(int,input().split()))
iin=lambda :int(input())
main=lambda :map(int,input().split())
from math import ceil,sqrt,factorial,log
from collections import deque
from bisect import bisect_left
def gcd(a,b):
	a,b=max(a,b),min(a,b)
	while a%b!=0:
		a,b=b,a%b
	return b
def solve():
	a,b,c=main()
	x,y,z=lin(),lin(),lin()
	x.sort(reverse=True)
	y.sort(reverse=True)
	z.sort(reverse=True)
	ans=0
	dp=[[[0 for i in range(c+2)] for i in range(b+2)] for i in range(a+1)]
	for i in range(a+1):
		for j in range(b+1):
			for k in range(c+1):
				if i<a and j<b:
					dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+x[i]*y[j])
				if i<a and k<c:
					dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+x[i]*z[k])
				if k<c and j<b:
					dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+z[k]*y[j])
				ans=max(ans,dp[i][j][k])
	print(ans)
qwe=1
# qwe=int(input())
for _ in range(qwe):
	solve()

",cubic,1398_D,CODEFORCES,4001,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#dt = {} for i in x: dt[i] = dt.get(i,0)+1
import sys;input = sys.stdin.readline
inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]

r,g,b = ip()
R = [0]+ip()
G = [0]+ip()
B = [0]+ip()
R.sort()
G.sort()
B.sort()
dp = [[[0]*201 for i in range(201)] for j in range(201)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            x = dp[i-1][j-1][k] + R[i]*G[j] if i*j else 0
            y = dp[i][j-1][k-1] + G[j]*B[k] if j*k else 0
            z = dp[i-1][j][k-1] + R[i]*B[k] if i*k else 0
            dp[i][j][k] = max(dp[i][j][k],x,y,z)
print(dp[r][g][b])
#print(dp)
    
    
",cubic,1398_D,CODEFORCES,3958,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",cubic,1398_D,CODEFORCES,3947,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import io
import os

from collections import Counter, defaultdict, deque


def solveBFS(NR, NG, NB, R, G, B):
    def pack(i, j, k):
        return i * 256 * 256 + j * 256 + k

    def unpack(ijk):
        i, jk = divmod(ijk, 256 * 256)
        j, k = divmod(jk, 256)
        return i, j, k

    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)
    dp = [0 for i in range(256 ** 3)]
    q = deque([0])
    while q:
        ijk = q.popleft()
        d = dp[ijk]
        i, j, k = unpack(ijk)

        if i < NR:
            r = R[i]

        if j < NG:
            g = G[j]
        if k < NB:
            b = B[k]
        if i + 1 <= NR and j + 1 <= NG:
            rg = pack(i + 1, j + 1, k)
            dp[rg] = max(dp[rg], r * g + d)
            q.append(rg)

        if i + 1 <= NR and k + 1 <= NB:
            rb = pack(i + 1, j, k + 1)
            dp[rb] = max(dp[rb], r * b + d)
            q.append(rb)

        if j + 1 <= NG and k + 1 <= NB:
            gb = pack(i, j + 1, k + 1)
            dp[gb] = max(dp[gb], g * b + d)
            q.append(gb)

    return max(dp)


def solve(NR, NG, NB, R, G, B):
    assert NR == len(R)
    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)

    R += [0]
    G += [0]
    B += [0]

    NR1 = NR + 2
    NG1 = NG + 2
    NB1 = NB + 2
    dp = [0 for i in range((NR1) * (NG1) * (NB1))]

    def pack(i, j, k):
        return i * NG1 * NB1 + j * NB1 + k

    inf = float(""inf"")
    for i in range(NR + 1):
        for j in range(NG + 1):
            dp[pack(i, j, -1)] = -inf
    for i in range(NR + 1):
        for k in range(NB + 1):
            dp[pack(i, -1, k)] = -inf

    for j in range(NG + 1):
        for k in range(NB + 1):
            dp[pack(-1, j, k)] = -inf

    for l in range(2, NR + NG + NB + 1, 2):
        for j in range(NG + 1):
            for k in range(NB + 1):
                i = l - j - k
                if i < 0 or i > NR:
                    continue
                r = R[i - 1]
                g = G[j - 1]
                b = B[k - 1]
                dp[pack(i, j, k)] = max(
                    r * g + dp[pack(i - 1, j - 1, k)],
                    r * b + dp[pack(i - 1, j, k - 1)],
                    b * g + dp[pack(i, j - 1, k - 1)],
                )

    return max(dp)


if False:
    import random

    random.seed()
    N = 5
    for t in range(100):
        R = [random.randint(1, 10) for i in range(random.randint(1, N))]
        G = [random.randint(1, 10) for i in range(random.randint(1, N))]
        B = [random.randint(1, 10) for i in range(random.randint(1, N))]
        ans1 = solveBFS(len(R), len(G), len(B), R, G, B)
        ans2 = solve(len(R), len(G), len(B), R, G, B)
        if ans1 != ans2:
            print(ans1, ans2)
            print(R, G, B)
        exit()
if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    NR, NG, NB = [int(x) for x in input().split()]
    R = [int(x) for x in input().split()]
    G = [int(x) for x in input().split()]
    B = [int(x) for x in input().split()]
    ans = solve(NR, NG, NB, R, G, B)
    print(ans)

",cubic,1398_D,CODEFORCES,3917,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from collections import defaultdict
from sys import setrecursionlimit,stdin
input=stdin.readline
setrecursionlimit(100000)

def dfs(r,g,b,rr,gg,bb):
    if r<0 or g<0 or b<0:
        return 0
    x=0
    y=0
    z=0
    
    if dp[r][g][b]!=-1:
        return dp[r][g][b]
    if r!=0 and g!=0:
        x=rr[r-1]*gg[g-1]+dfs(r-1,g-1,b,rr,gg,bb)
    if r!=0 and b!=0:
        y=rr[r-1]*bb[b-1]+dfs(r-1,g,b-1,rr,gg,bb)
    if b!=0 and g!=0:
        z=bb[b-1]*gg[g-1]+dfs(r,g-1,b-1,rr,gg,bb)
    dp[r][g][b]=max(x,y,z)
    return max(x,y,z)

r,g,b=map(int,input().split())
rr=list(map(int,input().split()))
gg=list(map(int,input().split()))
bb=list(map(int,input().split()))
rr.sort()
gg.sort()
bb.sort()
dp=[[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]

print(dfs(r,g,b,rr,gg,bb))





",cubic,1398_D,CODEFORCES,3924,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
##########################################################
from collections import Counter
# c=sorted((i,int(val))for i,val in enumerate(input().split()))
import heapq
# c=sorted((i,int(val))for i,val in enumerate(input().split()))
# n = int(input())
# ls = list(map(int, input().split()))
# n, k = map(int, input().split())
# n =int(input())
#arr=[(i,x) for i,x in enum]
#arr.sort(key=lambda x:x[0])
#print(arr)
# e=list(map(int, input().split()))
from collections import Counter
#print(""\n"".join(ls))
#print(os.path.commonprefix(ls[0:2]))
#n=int(input())
from bisect import  bisect_right
#for _ in range(int(input())):
#n=int(input())
#arr = list(map(int, input().split()))
#for _ in range(int(input())):
#n, k = map(int, input().split())
import bisect
#n=int(input())
#n, p,q,r = map(int, input().split())
#arr = list(map(int, input().split()))
#n=int(input())
#nm,k = map(int, input().split())
#for _ in range(int(input())):
def find(x,y,z):
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    ans=0
    if x<r and y<g:
        ans=max(ans,rl[x]*gl[y]+find(x+1,y+1,z))
    if x<r and z<b:
        ans=max(ans,rl[x]*bl[z]+find(x+1,y,z+1))
    if y<g and z<b:
        ans=max(ans,gl[y]*bl[z]+find(x,y+1,z+1))

    dp[x][y][z]=ans
    return ans
r,g,b = map(int, input().split())
rl=sorted(list(map(int, input().split())),reverse=True)
gl=sorted(list(map(int, input().split())),reverse=True)
bl=sorted(list(map(int, input().split())),reverse=True)
dp=[[[-1]*(b+1) for i in range(g+1)]for i in range(r+1)]
print(find(0,0,0))

",cubic,1398_D,CODEFORCES,3995,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r, g, b = map(int, input().split())
a = [[], [], []]
dp = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)]
for x in range(3):
    a[x] = sorted([int(x) for x in input().split()])
odp = 0
for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
            odp = max(odp, dp[i][j][k])
print(odp)",cubic,1398_D,CODEFORCES,3965,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import heapq


def read_int():
    return int(input().strip())


def read_ints():
    return list(map(int, input().strip().split(' ')))


def solve():
    '''
    8 8 8 8 8 8
    9 9
    9 9

    81+81

    72+72+72+72
    '''
    R, G, B = read_ints()
    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]
    # dp[R][G][B]
    Rs = read_ints()
    Gs = read_ints()
    Bs = read_ints()
    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)
    answer = 0
    for r in range(R+1):
        for g in range(G+1):
            for b in range(B+1):
                if r > 0 and g > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])
                if g > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])
                if r > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])
                answer = max(answer, dp[r][g][b])
    return answer


if __name__ == '__main__':
    print(solve())
",cubic,1398_D,CODEFORCES,3928,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from sys import stdin, gettrace

if gettrace():
    inputi = input
else:
    def input():
        return next(stdin)[:-1]


    def inputi():
        return stdin.buffer.readline()


def main():
    r, g, b = map(int, inputi().split())
    rr = list(sorted(int(a) for a in inputi().split()))
    gg = list(sorted(int(a) for a in inputi().split()))
    bb = list(sorted(int(a) for a in inputi().split()))
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    res = 0
    for i in range(r, -1, -1):
        for j in range(g, -1, -1):
            for k in range(b, -1, -1):
                if i > 0 and j > 0:
                    dp[i-1][j-1][k] = max(dp[i-1][j-1][k], dp[i][j][k] + rr[i-1]*gg[j-1])
                if i > 0 and k > 0:
                    dp[i-1][j][k-1] = max(dp[i-1][j][k-1], dp[i][j][k] + rr[i-1]*bb[k-1])
                if j > 0 and k > 0:
                    dp[i][j-1][k-1] = max(dp[i][j-1][k-1], dp[i][j][k] + gg[j-1]*bb[k-1])
                res = max(res, dp[i-1][j-1][k], dp[i-1][j][k-1] , dp[i][j-1][k-1])
    print(res)


if __name__ == ""__main__"":
    main()
",cubic,1398_D,CODEFORCES,3920,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from collections import deque
from collections import OrderedDict
import math
 
import sys
import os
import threading
import bisect
 
import operator
 
import heapq
 
 
from atexit import register
from io import BytesIO
 
#sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
#sys.stdout = BytesIO()
#register(lambda: os.write(1, sys.stdout.getvalue()))
 
 
import io
#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
#sys.stdin = open(""F:\PY\\test.txt"", ""r"")
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#input = sys.stdin.readline

#a = [int(x) for x in input().split()]




r,g,b = map(int, input().split())
a = []
for i in range(3):
    a.append([int(x) for x in input().split()])
    a[i].sort(reverse=True)

dp = [[[0 for i in range(205)] for j in range(205)] for k in range(205)]
answer = 0

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k], dp[i][j][k]+a[0][i]*a[1][j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1], dp[i][j][k]+a[0][i]*a[2][k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1], dp[i][j][k]+a[1][j]*a[2][k])
            answer=max(answer, dp[i][j][k])
print(answer)
    



sys.exit(0)





class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person(""heelo"", 27)

print(help(Person))


age = 26
name = 'Swaroop'
print('Возрас {} -- {} лет'.format(name, age))
print(help(object))


'''
for _ in range(int(input())):
    
    n = int(input())
    ar = list(map(int, input().split()))
    dp = [0]*100005
    for i in range(n):
        dp[ar[i]]+=1
    ar.clear()
    for i in range(len(dp)):
        if dp[i]!=0:
            ar.append(dp[i])       
    ar.sort()
    maxC = ar[len(ar)-1]
    sumA = sum(ar)
    answer=0
    for i in range(len(ar)):
        if ar[i]==maxC:
            answer+=1
            sumA-=maxC
    answer-=1
    answer+= min(sumA//(maxC-1), len(ar)-1)
    print(answer)
    #sys.exit(0)   
         
    




def maxDisjointIntervals(list_):
    list_.sort(key=lambda x: x[1])
    print(list_[0][0], list_[0][1])
    r1 = list_[0][1]
    for i in range(1, len(list_)):
        l1 = list_[i][0]
        r2 = list_[i][1]
        if l1>r1:
            print(l1, r2)
            r1 = r2

if __name__ ==""__main__1"":
    N=4
    intervals = [[1, 4], [2, 3], [4,6], [8,9]]
    maxDisjointIntervals(intervals)
    
    '''
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    ",cubic,1398_D,CODEFORCES,3967,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"r,g,b = map(int,input().split())
R = sorted([*map(int,input().split())],reverse=True)
G= sorted([*map(int,input().split())],reverse=True)
B = sorted([*map(int,input().split())],reverse=True)
mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]
def dp(i,j,k):
    p = (i==r)+(j==g)+(k==b)
    if(p>1):
        return 0
    if(mem[i][j][k]!=-1):
        return mem[i][j][k]
    ans = 0
    if(i==r):
        ans = dp(i,j+1,k+1)+G[j]*B[k]
        return ans
    elif(j==g):
        ans = dp(i+1,j,k+1)+R[i]*B[k]
    elif(k==b):
        ans = dp(i+1,j+1,k)+R[i]*G[j]
    else:
        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])
    mem[i][j][k] = ans
    return ans
print(dp(0,0,0))",cubic,1398_D,CODEFORCES,3907,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
input = sys.stdin.readline
 
rr, gg, bb = map(int, input().split())
inf = 114514
r = list(map(int, input().split())) + [inf]
g = list(map(int, input().split())) + [inf]
b = list(map(int, input().split())) + [inf]
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = []
for _ in range(rr + 1):
    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])
ans = 0
for i in range(rr + 1):
    ri = r[i]
    for j in range(gg + 1):
        gj = g[j]
        for k in range(bb + 1):
            bk = b[k]
            if (i + j + k) % 2:
                continue
            dpijk = 0
            if i > 0 and j > 0:
                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)
            if j > 0 and k > 0:
                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)
            if k > 0 and i > 0:
                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)
            dp[i][j][k] = dpijk
            if ans < dpijk:
                ans = dpijk
print(ans)",cubic,1398_D,CODEFORCES,3897,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import os, sys
from io import BytesIO, IOBase
from math import log2, ceil, sqrt, gcd
from _collections import deque
import heapq as hp
from bisect import bisect_left, bisect_right

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
mod = 10 ** 9 + 7

R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp=[[[0]*(B+1) for _ in range(G+1)] for __ in range(R+1)]
ans=0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1],
                                  dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1],
                                  dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            elif i>0 and j>0:
                dp[i][j][k] =dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1]
            elif i>0 and k>0:
                dp[i][j][k] = dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1]
                ans = max(ans, dp[i][j][k])
            elif j>0 and k>0:
                dp[i][j][k]=dp[i][j-1][k-1]+g[j-1]*b[k-1]
            ans=max(ans,dp[i][j][k])
# for i in dp:
#     print(i)
print(ans)




",cubic,1398_D,CODEFORCES,3895,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R, G, B = list(map(int, input().split()))
r = sorted([int(x) for x in input().split()], reverse=True)
g = sorted([int(x) for x in input().split()], reverse=True)
b = sorted([int(x) for x in input().split()], reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",cubic,1398_D,CODEFORCES,3977,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys

sys.setrecursionlimit(10 ** 5)
int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

rn,gn,bn=MI()
rr=LI()
gg=LI()
bb=LI()
rr.sort(reverse=True)
gg.sort(reverse=True)
bb.sort(reverse=True)
dp=[[[-1]*(bn+1) for _ in range(gn+1)] for _ in range(rn+1)]
dp[0][0][0]=0
ans=0
for i in range(rn+1):
    for j in range(gn+1):
        for k in range(bn+1):
            pre=dp[i][j][k]
            if pre==-1:continue
            ans=max(ans,pre)
            if i<rn and j<gn:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],pre+rr[i]*gg[j])
            if i<rn and k<bn:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],pre+rr[i]*bb[k])
            if j<gn and k<bn:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],pre+gg[j]*bb[k])

print(ans)
",cubic,1398_D,CODEFORCES,3903,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#greedy is wrong due to the constraint ki do alag se uthenge, so youd also want to keep 2 ppl above 0

#yeh dp se hoga, clear hai

import sys

def input():
	return sys.stdin.readline().rstrip()

def input_split():
	return [int(i) for i in input().split()]

# testCases = int(input())
# answers = []
# for _ in range(testCases):
	#take input
x, y, z  = input_split()
arr_x = input_split()
arr_y = input_split()
arr_z = input_split()

x += 1
y += 1
z += 1

lengths = [x,y, z]
arrs = [arr_x, arr_y, arr_z ]

for a in arrs:
	a.sort()
	# a.reverse()

dp = [[[0 for k in range(z)] for j in range(y)] for i in range(x)]

for i in range(1,x):
	for j in range(1,y):
		# if i!= 0 and j!= 0:
		dp[i][j][0] = dp[i-1][j-1][0] + arr_x[i-1]*arr_y[j-1]

for j in range(1, y):
	for k in range(1, z):
		# if j!= 0 and k!= 0:
		dp[0][j][k] = dp[0][j-1][k-1] + arr_y[j-1]*arr_z[k-1]
			
for i in range(1,x):
	for k in range(1,z):
		# if i!= 0 and k!= 0:
		dp[i][0][k] = dp[i-1][0][k-1] + arr_x[i-1]*arr_z[k-1]

for i in range(1, x):
	for j in range(1, y):
		for k in range(1, z):
			opt1 = dp[i-1][j-1][k] + arr_x[i-1]*arr_y[j-1]
			opt2 = dp[i][j-1][k-1] + arr_y[j-1]*arr_z[k-1]
			opt3 = dp[i-1][j][k-1] + arr_x[i-1]*arr_z[k-1]
			# opt2 = d
			dp[i][j][k] = max(opt1, opt2, opt3)

ans = dp[x-1][y-1][z-1]
# used_x = 0
# used_y = 0
# used_z = 0
# used = [used_x, used_y, used_z]
# while(True):
# 	poss = []
# 	for i in range(3):
# 		if used[i] < lengths[i]:
# 			poss.append((arrs[i][used[i]], i))

# 	if len(poss) <= 1:
# 		break

# 	else:
# 		poss.sort()
# 		v1, t1 = poss[-1]
# 		v2, t2 = poss[-2]

# 		ans += v1*v2
# 		used[t1] += 1
# 		used[t2] += 1

print(ans)	
# answers.append(ans)

# print(*answers, sep = '\n')
",cubic,1398_D,CODEFORCES,3911,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
input = sys.stdin.readline

rr, gg, bb = map(int, input().split())
inf = 114514
r = list(map(int, input().split())) + [inf]
g = list(map(int, input().split())) + [inf]
b = list(map(int, input().split())) + [inf]
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = []
for _ in range(rr + 1):
    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])
ans = 0
for i in range(rr + 1):
    ri = r[i]
    for j in range(gg + 1):
        gj = g[j]
        for k in range(bb + 1):
            bk = b[k]
            if (i + j + k) % 2:
                continue
            dpijk = 0
            if i > 0 and j > 0:
                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)
            if j > 0 and k > 0:
                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)
            if k > 0 and i > 0:
                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)
            dp[i][j][k] = dpijk
            if ans < dpijk:
                ans = dpijk
print(ans)",cubic,1398_D,CODEFORCES,3888,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from sys import stdin
inp = lambda : stdin.readline().strip()

nr, ng, nb = [int(x) for x in inp().split()]

r = [int(x) for x in inp().split()]
g = [int(x) for x in inp().split()]
b = [int(x) for x in inp().split()]
r.sort()
g.sort()
b.sort()
dp = [[[0 for _ in range(201)] for _ in range(201)] for _ in range(201)]
for i in range(nr+1):
    for j in range(ng+1):
        for k in range(nb+1):
            if i and j:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]);
            if i and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]);
            if j and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]);
 
print(dp[nr][ng][nb])",cubic,1398_D,CODEFORCES,3939,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"n, m, q = map(int, input().split())
a = sorted(map(int, input().split()), reverse=True)
b = sorted(map(int, input().split()), reverse=True)
c = sorted(map(int, input().split()), reverse=True)
dp = [[[0] * 201 for _ in range(201)] for _ in range(201)]
for ijk in range(n + m + q + 1):
    for i in range(min(n + 1, ijk + 1)):
        for j in range(min(m + 1, ijk - i + 1)):
            k = ijk - i - j
            if k < 0 or k > q:
                continue
            if i + 1 <= n:
                dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k])
            if j + 1 <= m:
                dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k])
            if k + 1 <= q:
                dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k])
            if i + 1 <= n and j + 1 <= m:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[i] * b[j])
            if i + 1 <= n and k + 1 <= q:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[i] * c[k])
            if j + 1 <= m and k + 1 <= q:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + b[j] * c[k])
print(dp[n][m][q])",cubic,1398_D,CODEFORCES,3901,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def f(l,r,g,b,op):
    if (r==0 and g==0) or (r==0 and b==0) or (b==0 and g==0):
        return 0
    else:
        if op[r][g][b]!=-1:
            return op[r][g][b]
        if r==0:
           op[r][g][b]=l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op)
           return op[r][g][b]
        if g==0:
           op[r][g][b]=l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op)
           return op[r][g][b]
        if b==0:
         op[r][g][b]=l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op)
         return op[r][g][b]
        op[r][g][b]=max(l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op),l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op),l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op))  
        return op[r][g][b]   

r,g,b=list(map(int,input().split()))
l=[]
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
op=[[[-1 for i in range(b+1)]for j in range(g+1)]for k in range(r+1)]
#print(op)
print(f(l,r,g,b,op))
",cubic,1398_D,CODEFORCES,4007,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans)",cubic,1398_D,CODEFORCES,3900,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"# Author: S Mahesh Raju
# Username: maheshraju2020
# Date: 19/08/2020

from sys import stdin, stdout, setrecursionlimit
from math import gcd, ceil, sqrt
from collections import Counter, deque
from bisect import bisect_left, bisect_right
ii1 = lambda: int(stdin.readline().strip())
is1 = lambda: stdin.readline().strip()
iia = lambda: list(map(int, stdin.readline().strip().split()))
isa = lambda: stdin.readline().strip().split()
setrecursionlimit(100000)
mod = 1000000007

R, G, B = iia()
r, g, b = sorted(iia()), sorted(iia()), sorted(iia())
dp = [[[0 for i in range(B + 1)] \
    for j in range(G + 1)] for k in range(R + 1)]

for i in range(R + 1):
    for j in range(G + 1):
        for k in range(B + 1):
            if i > 0 and j > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            if i > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])
            if j > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])
print(dp[-1][-1][-1])
",cubic,1398_D,CODEFORCES,3981,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys as _sys


_sys.setrecursionlimit(2**14)


_cache = dict()


class _SortedSeqs:

    def __init__(self, seqs):
        self.seqs = tuple(tuple(sorted(seq)) for seq in seqs)

    def __hash__(self):
        return id(self)


def compute_max_area(r_seq, g_seq, b_seq):
    sorted_seqs_obj = _SortedSeqs((r_seq, g_seq, b_seq))
    seqs_sizes = tuple(map(len, sorted_seqs_obj.seqs))
    return _compute_max_area(sorted_seqs_obj, seqs_sizes)


def _compute_max_area(sorted_seqs_obj, seqs_sizes):
    cache_key = (sorted_seqs_obj, seqs_sizes)
    if cache_key in _cache.keys():
        return _cache[cache_key]

    seqs = sorted_seqs_obj.seqs
    nonempty_seqs_n = _how_many_nonempty(seqs_sizes)

    if nonempty_seqs_n < 2:
        ab_seqs_indices_list = []
    
    elif nonempty_seqs_n == 2:
        ab_seqs_indices = [i for i, seq_size in enumerate(seqs_sizes) if seq_size > 0]
        ab_seqs_indices_list = [ab_seqs_indices]
    
    else:
        assert nonempty_seqs_n == 3
        seqs_indices_sorted_by_size = [
            i for i, seq in sorted(
                enumerate(seqs),
                key=lambda pair: (pair[1][seqs_sizes[pair[0]]-1], seqs_sizes[pair[0]])
            )
        ]
        ab_seqs_indices_1 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[0]
        ab_seqs_indices_2 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[1]
        ab_seqs_indices_list = [ab_seqs_indices_1, ab_seqs_indices_2]
    
    max_areas_variants = []
    for a_seq_index, b_seq_index in ab_seqs_indices_list:
        a_seq_last = seqs[a_seq_index][seqs_sizes[a_seq_index]-1]
        b_seq_last = seqs[b_seq_index][seqs_sizes[b_seq_index]-1]
        new_seqs_sizes = list(seqs_sizes)
        new_seqs_sizes[a_seq_index] -= 1
        new_seqs_sizes[b_seq_index] -= 1
        max_area = _compute_max_area(sorted_seqs_obj, tuple(new_seqs_sizes))
        max_area += a_seq_last * b_seq_last
        max_areas_variants.append(max_area)

    max_area = max(max_areas_variants, default=0)

    _cache[cache_key] = max_area
    return max_area


def _how_many_nonempty(seqs_sizes):
    return len([size for size in seqs_sizes if size > 0])


def main():
    r_n, g_n, b_n = map(int, input().split())
    r_seq = tuple(map(int, input().split()))
    g_seq = tuple(map(int, input().split()))
    b_seq = tuple(map(int, input().split()))
    result = compute_max_area(r_seq, g_seq, b_seq)
    print(result)


if __name__ == '__main__':
    main()
",cubic,1398_D,CODEFORCES,3962,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"#import sys
#input = sys.stdin.readline
def main():
    R, G, B = map( int, input().split())
    Rs = list( map( int, input().split()))
    Gs = list( map( int, input().split()))
    Bs = list( map( int, input().split()))

    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)

    dp = [[[0]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                t = 0
                if i > 0 and j > 0:
                    if dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1] > t:
                        t = dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1]
                if j > 0 and k > 0:
                    if dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1] > t:
                        t = dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1]
                if k > 0 and i > 0:
                    if dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1] > t:
                        t = dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1]
                dp[i][j][k] = t
                if ans < t:
                    ans = t
    print(ans)
                        

if __name__ == '__main__':
    main()
",cubic,1398_D,CODEFORCES,3925,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
# sys.setrecursionlimit(10**6) 
input=sys.stdin.readline
def  f(r,g,b,n,m,k):
    # s=str(n)+""_""+str(m)+""_""+str(k)
    # print(n,m,k)
    if((n>=1 and m>=1) or (k>=1 and m>=1) or(n>=1 and k>=1)):
        # print(n,m,k,""zzz"")
        a1=mat[n][m][k]
        if(a1!=-1):
            return a1
        else:
            a1=0
            b1=0
            c1=0
            # print(n,m,k)
            if(n>=1 and m>=1):
          
                a1=r[n-1]*g[m-1] + f(r,g,b,n-1,m-1,k)
            if(k>=1 and m>=1):
                b1=b[k-1]*g[m-1] + f(r,g,b,n,m-1,k-1)
            if(n>=1 and k>=1):
                c1=r[n-1]*b[k-1] + f(r,g,b,n-1,m,k-1)
            # if(n>=0 and m>=0 and k>=0):
            mat[n][m][k]=max(a1,b1)
            mat[n][m][k]=max(mat[n][m][k],c1)
            # print(d[s])
            return mat[n][m][k]
    return 0


n,m,k=list(map(int,input().split("" "")))
mat=[[[-1 for i in range(k+1)] for j in range(m+1)]for z in range(n+1)]
# print(mat)
r=list(map(int,input().split("" "")))
g=list(map(int,input().split("" "")))
b=list(map(int,input().split("" "")))
r.sort()
g.sort()
b.sort()
# print(r,g,b)
d={}
print(f(r,g,b,n,m,k))",cubic,1398_D,CODEFORCES,3952,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
# State- dp[i][j][k] represents max value after choosing i elements from r, j elements from g, k elements from b
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",cubic,1398_D,CODEFORCES,3974,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R,G,B = map(int,input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
area = 0
r.sort(reverse=True)
b.sort(reverse=True)
g.sort(reverse=True)
L = max(len(r),len(g),len(b))
dp = [[[0]*(B+1) for i in range(G+1)]for j in range(R+1)]
# print(dp[r][g][b])
tr = 0
tg = 0
tb = 0
for i in range(R+1):
	for j in range(G+1):
		for k in range(B+1):
			if i>0 and j>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
			if j>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
			if i>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
			area = max(area,dp[i][j][k])
print(area)",cubic,1398_D,CODEFORCES,3969,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
input = sys.stdin.readline

a,b,c = list(map(int,input().split()))

x = list(map(int,input().split()))
y = list(map(int,input().split()))
z = list(map(int,input().split()))

x.sort(reverse=True)
y.sort(reverse=True)
z.sort(reverse=True)

a+=1
b+=1
c+=1

x = [0] + x
y = [0] + y
z = [0] + z

tmp = [[0]*c for _ in range(b)]
best = [tmp for _ in range(a)]

#print(tmp)
#print(best)
ans = 0

for i in range(a):
    for j in range(b):
        for k in range(c):
            if (i+j+k) % 2 == 0:
                aa,bb,cc = 0,0,0
                if i>0 and j>0:
                    aa = best[i-1][j-1][k] + x[i] * y[j]
                if i>0 and k>0:
                    bb = best[i-1][j][k-1] + x[i] * z[k]
                if j>0 and k>0:
                    cc = best[i][j-1][k-1] + y[j] * z[k]
                
                best[i][j][k] = max(aa,bb,cc)
                ans = max(ans, best[i][j][k])
#print(best)
print(ans)
",cubic,1398_D,CODEFORCES,3913,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"c1, c2, c3 = map(int, input().split())
r = sorted(list(map(int, input().split())))
g = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))
dp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]
for i in range(c1 + 1):
    for j in range(c2 + 1):
        for k in range(c3 + 1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])
print(dp[c1][c2][c3])
 ",cubic,1398_D,CODEFORCES,4000,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"# @author --> ajaymodi
# optimized approach with memoization (dp)
import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""output.out"",""w"")

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())


from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)

def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]
 
	if i < r and j < g and k < b:
		m = max(solve(i+1,j+1,k)+(rl[i]*gl[j]), solve(i+1,j,k+1)+(rl[i]*bl[k]), solve(i,j+1,k+1)+(gl[j]*bl[k]))
		dp_table[i][j][k] = m
		return m
 
	elif i < r and j < g:
		m = solve(i+1,j+1,b) + rl[i]*gl[j]
		dp_table[i][j][k] = m
		return m
 
	elif i < r and k < b:
		m = solve(i+1,g,k+1) + (rl[i]*bl[k])	
		dp_table[i][j][k] = m
		return m
 
	elif j < g and k < b:
		m = solve(r,j+1,k+1) + (gl[j]*bl[k])
		dp_table[i][j][k] = m
		return m
	else:
		return 0

dp_table = [[[-1]*(b+1) for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",cubic,1398_D,CODEFORCES,3987,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"import sys
input = sys.stdin.readline

r, g, b, = [int(_) for _ in input().split()]
R = [int(_) for _ in input().split()]
G = [int(_) for _ in input().split()]
B = [int(_) for _ in input().split()]
R = sorted(R, reverse=True)
G = sorted(G, reverse=True)
B = sorted(B, reverse=True)

dp = []  # best score so far after picking (iR, jG, kB)
for i in range(r+1):
    sdp = [[0]*(b+1) for _ in range(g+1)]
    dp.append(sdp)

answer = 0
for nb_taken in range(r+g+b):
    if nb_taken % 2:
        continue
    # print('nb_taken', nb_taken)
    for i in range(nb_taken+1):
        if i > r:
            break
        for j in range(nb_taken-i-b, nb_taken-i+1):
            if j > g:
                break
            k = nb_taken-i-j
            if k > b:
                continue
            if i+j < k or i+k < j or j+k < i:
                continue
            # assert i+j+k == nb_taken
            # print('in dp', i, j, k)
# for i in range(r):
    # for j in range(g):
        # for k in range(b):
            if i < r and j < g:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + R[i]*G[j])
                # print('setting dp', i+1, j+1, k, dp[i+1][j+1][k])
                answer = max(answer, dp[i+1][j+1][k])
            if i < r and k < b:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + R[i]*B[k])
                # print('setting dp', i+1, j, k+1, dp[i+1][j][k+1])
                answer = max(answer, dp[i+1][j][k+1])
            if j < g and k < b:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + G[j]*B[k])
                # print('setting dp', i, j+1, k+1, dp[i][j+1][k+1])
                answer = max(answer, dp[i][j+1][k+1])
# print(dp)
print(answer)

# k > b <=> nb_taken-i-j >= b <=> j <= nb_taken-i-b
",cubic,1398_D,CODEFORCES,3923,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"def cal(r,g,b):
	if dp[r][g][b]!=-1:
		return dp[r][g][b]
	ans=0
	if r<R and g<G:
		ans=max(ans,rl[r]*gl[g]+cal(r+1,g+1,b))
	if r<R and b<B:
		ans=max(ans,rl[r]*bl[b]+cal(r+1,g,b+1))
	if g<G and b<B:
		ans=max(ans,gl[g]*bl[b]+cal(r,g+1,b+1))
	dp[r][g][b]=ans
	return ans

R,G,B=map(int,input().split())
rl=sorted(list(map(int,input().split())),reverse=True)
gl=sorted(list(map(int,input().split())),reverse=True)
bl=sorted(list(map(int,input().split())),reverse=True)
dp=[[[-1 for j in range(B+1)] for i in range(G+1)] for i in range(R+1)]
print(cal(0,0,0))",cubic,1398_D,CODEFORCES,3991,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"# ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------- fast io --------------------
from math import gcd, ceil

def pre(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi


def prod(a):
    ans = 1
    for each in a:
        ans = (ans * each)
    return ans

def lcm(a, b): return a * b // gcd(a, b)


def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y


for _ in range(int(input()) if not True else 1):
    r, g, b = map(int, input().split())
    #a, b = map(int, input().split())
    #c, d = map(int, input().split())
    rr = list(map(int, input().split()))
    gg = list(map(int, input().split()))
    bb = list(map(int, input().split()))
    #s = input()
    dp = [[[0]*(b+1) for __ in range(g+1)] for ___ in range(r+1)]
    def f(a):return sorted(a,reverse=True)
    rr,gg,bb=f(rr),f(gg),f(bb)
    ans=0
    r+=1
    g+=1
    b+=1
    for i in range(r):
        for j in range(g):
            for k in range(b):
                try:dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k] + rr[i]*gg[j])
                except:pass
                try:dp[i][j+1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + gg[j]*bb[k])
                except:pass
                try:dp[i+1][j][k+1] = max(dp[i+1][j][k+1],dp[i][j][k] + rr[i]*bb[k])
                except:pass
                ans=max(ans,dp[i][j][k])
    print(ans)",cubic,1398_D,CODEFORCES,3993,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split())) 
r.sort(reverse=True) 
g.sort(reverse=True) 
b.sort(reverse=True) 
#print(r,g,b)
dp=[[[-1 for i in range(205)] for j in range(205)] for k in range(205)]
def recurser(x,y,z):
    if (x>=R and y>=G) or (y>=G and z>=B) or (z>=B and x>=R):
        return 0 
    if dp[x][y][z]!=-1:
        return dp[x][y][z] 
    maxi=0 
    if x<R and y<G:
        maxi=max(maxi,r[x]*g[y]+recurser(x+1,y+1,z)) 
    if y<G and z<B:
        maxi=max(maxi,g[y]*b[z]+recurser(x,y+1,z+1)) 
    if z<B and x<R:
        maxi=max(maxi,r[x]*b[z]+recurser(x+1,y,z+1))
    dp[x][y][z]=maxi
    return maxi 
print(recurser(0,0,0)) ",cubic,1398_D,CODEFORCES,3943,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]
def calc(nr,ng,nb):
  if dp[nr][ng][nb]!=-1:
    return dp[nr][ng][nb]
  res=0
  if nr<R and ng<G:
    res=max(res,calc(nr+1,ng+1,nb)+r[nr]*g[ng])
  if nr<R and nb<B:
    res=max(res,calc(nr+1,ng,nb+1)+r[nr]*b[nb])
  if ng<G and nb<B:
    res=max(res,calc(nr,ng+1,nb+1)+g[ng]*b[nb])
  dp[nr][ng][nb]=res
  return res
print(calc(0,0,0))",cubic,1398_D,CODEFORCES,3890,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings"
"from collections import defaultdict
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = defaultdict(int)
for x in a:
    d[x] += 1
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",cubic,1437_F,CODEFORCES,4011,Emotional Fishermen,"$$$n$$$ fishermen have just returned from a fishing vacation. The $$$i$$$-th fisherman has caught a fish of weight $$$a_i$$$.
Fishermen are going to show off the fish they caught to each other. To do so, they firstly choose an order in which they show their fish (each fisherman shows his fish exactly once, so, formally, the order of showing fish is a permutation of integers from $$$1$$$ to $$$n$$$). Then they show the fish they caught according to the chosen order. When a fisherman shows his fish, he might either become happy, become sad, or stay content.
Suppose a fisherman shows a fish of weight $$$x$$$, and the maximum weight of a previously shown fish is $$$y$$$ ($$$y = 0$$$ if that fisherman is the first to show his fish). Then:
Let's call an order in which the fishermen show their fish emotional if, after all fishermen show their fish according to this order, each fisherman becomes either happy or sad. Calculate the number of emotional orders modulo $$$998244353$$$.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 5000$$$).
","input
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 10^9$$$).
output
Print one integer — the number of emotional orders, taken modulo $$$998244353$$$.
","combinatorics, dp, math, twopointers"
"from collections import Counter
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = Counter(a)
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",cubic,1437_F,CODEFORCES,4012,Emotional Fishermen,"$$$n$$$ fishermen have just returned from a fishing vacation. The $$$i$$$-th fisherman has caught a fish of weight $$$a_i$$$.
Fishermen are going to show off the fish they caught to each other. To do so, they firstly choose an order in which they show their fish (each fisherman shows his fish exactly once, so, formally, the order of showing fish is a permutation of integers from $$$1$$$ to $$$n$$$). Then they show the fish they caught according to the chosen order. When a fisherman shows his fish, he might either become happy, become sad, or stay content.
Suppose a fisherman shows a fish of weight $$$x$$$, and the maximum weight of a previously shown fish is $$$y$$$ ($$$y = 0$$$ if that fisherman is the first to show his fish). Then:
Let's call an order in which the fishermen show their fish emotional if, after all fishermen show their fish according to this order, each fisherman becomes either happy or sad. Calculate the number of emotional orders modulo $$$998244353$$$.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 5000$$$).
","input
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 10^9$$$).
output
Print one integer — the number of emotional orders, taken modulo $$$998244353$$$.
","combinatorics, dp, math, twopointers"
"from collections import Counter
import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
mod = 998244353
a.sort()
dp = [1] + [0] * n
for i in range(1, n + 1):
    x, pt = 1, i - 2
    while pt >= 0 and 2 * a[pt] > a[i - 1]:
        x = x * (n - pt - 2) % mod
        pt -= 1
    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod
print(dp[-1])",cubic,1437_F,CODEFORCES,4013,Emotional Fishermen,"$$$n$$$ fishermen have just returned from a fishing vacation. The $$$i$$$-th fisherman has caught a fish of weight $$$a_i$$$.
Fishermen are going to show off the fish they caught to each other. To do so, they firstly choose an order in which they show their fish (each fisherman shows his fish exactly once, so, formally, the order of showing fish is a permutation of integers from $$$1$$$ to $$$n$$$). Then they show the fish they caught according to the chosen order. When a fisherman shows his fish, he might either become happy, become sad, or stay content.
Suppose a fisherman shows a fish of weight $$$x$$$, and the maximum weight of a previously shown fish is $$$y$$$ ($$$y = 0$$$ if that fisherman is the first to show his fish). Then:
Let's call an order in which the fishermen show their fish emotional if, after all fishermen show their fish according to this order, each fisherman becomes either happy or sad. Calculate the number of emotional orders modulo $$$998244353$$$.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 5000$$$).
","input
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 10^9$$$).
output
Print one integer — the number of emotional orders, taken modulo $$$998244353$$$.
","combinatorics, dp, math, twopointers"
"import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
mod = 998244353
a.sort()
dp = [1] + [0] * n
for i in range(1, n + 1):
    x, pt = 1, i - 2
    while pt >= 0 and 2 * a[pt] > a[i - 1]:
        x = x * (n - pt - 2) % mod
        pt -= 1
    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod
print(dp[-1])",cubic,1437_F,CODEFORCES,4010,Emotional Fishermen,"$$$n$$$ fishermen have just returned from a fishing vacation. The $$$i$$$-th fisherman has caught a fish of weight $$$a_i$$$.
Fishermen are going to show off the fish they caught to each other. To do so, they firstly choose an order in which they show their fish (each fisherman shows his fish exactly once, so, formally, the order of showing fish is a permutation of integers from $$$1$$$ to $$$n$$$). Then they show the fish they caught according to the chosen order. When a fisherman shows his fish, he might either become happy, become sad, or stay content.
Suppose a fisherman shows a fish of weight $$$x$$$, and the maximum weight of a previously shown fish is $$$y$$$ ($$$y = 0$$$ if that fisherman is the first to show his fish). Then:
Let's call an order in which the fishermen show their fish emotional if, after all fishermen show their fish according to this order, each fisherman becomes either happy or sad. Calculate the number of emotional orders modulo $$$998244353$$$.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 5000$$$).
","input
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 10^9$$$).
output
Print one integer — the number of emotional orders, taken modulo $$$998244353$$$.
","combinatorics, dp, math, twopointers"
"M = 998244353 
n = int(input())
l = sorted(map(int, input().split()))[::-1]
out = [0] * n
big = 0
if l[0] >= 2 * l[1]:
    out[1] = 1
    big = 1
for i in range(2, n):
    new = [0] * n
    bigN = 0
    for j in range(i):
        if l[j] >= 2 * l[i]:
            big += out[j]
        else:
            new[j] += out[j] * (i - 1)
            new[j] %= M
    
    new[i] = big
    bigN = (i * big) % M 
        
    out = new
    big = bigN
print((big + sum(out))%M)",cubic,1437_F,CODEFORCES,4015,Emotional Fishermen,"$$$n$$$ fishermen have just returned from a fishing vacation. The $$$i$$$-th fisherman has caught a fish of weight $$$a_i$$$.
Fishermen are going to show off the fish they caught to each other. To do so, they firstly choose an order in which they show their fish (each fisherman shows his fish exactly once, so, formally, the order of showing fish is a permutation of integers from $$$1$$$ to $$$n$$$). Then they show the fish they caught according to the chosen order. When a fisherman shows his fish, he might either become happy, become sad, or stay content.
Suppose a fisherman shows a fish of weight $$$x$$$, and the maximum weight of a previously shown fish is $$$y$$$ ($$$y = 0$$$ if that fisherman is the first to show his fish). Then:
Let's call an order in which the fishermen show their fish emotional if, after all fishermen show their fish according to this order, each fisherman becomes either happy or sad. Calculate the number of emotional orders modulo $$$998244353$$$.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 5000$$$).
","input
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 10^9$$$).
output
Print one integer — the number of emotional orders, taken modulo $$$998244353$$$.
","combinatorics, dp, math, twopointers"
"mod = 998244353
eps = 10**-9


def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    A = list(map(int, input().split())) + [0]
    A.sort()

    dp = [[0] * (i+1) for i in range(N+1)]
    dp[0][0] = 1
    l = 0
    for i in range(1, N+1):
        for ll in range(l+1, i):
            if A[ll] * 2 <= A[i]:
                l = ll
            else:
                break
        for j in range(1, l+2):
            dp[i][j] = (dp[l][j-1] + (dp[i][j-1] * (l-j+2))%mod)%mod
        for j in range(i):
            dp[i][j] = (dp[i-1][j] + dp[i][j])%mod
    print(dp[-1][-1])


if __name__ == '__main__':
    main()
",cubic,1437_F,CODEFORCES,4014,Emotional Fishermen,"$$$n$$$ fishermen have just returned from a fishing vacation. The $$$i$$$-th fisherman has caught a fish of weight $$$a_i$$$.
Fishermen are going to show off the fish they caught to each other. To do so, they firstly choose an order in which they show their fish (each fisherman shows his fish exactly once, so, formally, the order of showing fish is a permutation of integers from $$$1$$$ to $$$n$$$). Then they show the fish they caught according to the chosen order. When a fisherman shows his fish, he might either become happy, become sad, or stay content.
Suppose a fisherman shows a fish of weight $$$x$$$, and the maximum weight of a previously shown fish is $$$y$$$ ($$$y = 0$$$ if that fisherman is the first to show his fish). Then:
Let's call an order in which the fishermen show their fish emotional if, after all fishermen show their fish according to this order, each fisherman becomes either happy or sad. Calculate the number of emotional orders modulo $$$998244353$$$.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 5000$$$).
","input
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 10^9$$$).
output
Print one integer — the number of emotional orders, taken modulo $$$998244353$$$.
","combinatorics, dp, math, twopointers"
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    alst = [int(input()) for _ in range(n)]
    ans = []
    for a in alst:
        if a == 1:
            ans.append(""1"")
            print(""."".join(ans))
            continue
        while ans and int(ans[-1]) != a - 1:
            ans.pop()
        if not ans:
            ans.append(str(a))
        else:
            ans.pop()
            ans.append(str(a))
        
        print(""."".join(ans))
        
    
for _ in range(int(input())):
    main()",quadratic,1523_C,CODEFORCES,3686,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees"
