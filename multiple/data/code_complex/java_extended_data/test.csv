content,problem,from,idx,problem_title,problem_description,input_output_specification,tags,label
"//package round43;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class C {

	static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;
	static PrintWriter out = new PrintWriter(System.out);
	
	static String nextToken() throws IOException{
		while (st==null || !st.hasMoreTokens()){
			String s = bf.readLine();
			if (s == null)
				return null;
			st = new StringTokenizer(s);
		}
		
		return st.nextToken();
	}
	
	static int nextInt() throws IOException{
		return Integer.parseInt(nextToken());
	}
	
	static String nextStr() throws IOException{
		return nextToken();
	}
	
	static int f(byte s[], int n){
		int l = 0,
			r = n-1;
		int res = 0;
		
		do{
			while (l<n && s[l]=='H')
				l++;
			while (r>=0 && s[r]=='T')
				r--;
			
			if (l < r){
				res++;
			}
			l++;
			r--;
		}
		while (l < r);
		
		return res;
	}
	
	public static void main(String[] args) throws IOException{
		int n = nextInt();
		byte s[] = nextStr().getBytes();
		
		int res = f(s, n);
		for (int i=1; i<n; i++){
			byte c = s[0];
			for (int j=0; j<n-1; j++)
				s[j] = s[j+1];
			s[n-1] = c;
			res = Math.min(res, f(s, n));
		}
		
		out.println(res);
		out.flush();
	}

}
",0046_C,CODEFORCES,1637,Hamsters and Tigers,"Today there is going to be an unusual performance at the circus — hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.
The first line contains number n (2 ≤ n ≤ 1000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols ""H"" and ""T"". The ""H""s correspond to hamsters and the ""T""s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.
","input
Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.
output
In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then — the tiger in position 9 with the hamster in position 7.
",twopointers,3
"

import java.io.BufferedReader; 
import java.io.IOException; 
import java.io.InputStreamReader; 
import java.util.Scanner; 
import java.util.StringTokenizer; 
import java.util.*;
  
public class er45a
{ 
    //By shwetank_verma
    static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader() 
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 
    static int mod=1000000007;
    static boolean primes[]=new boolean[1000007];
    static ArrayList<Integer> b=new ArrayList<>();
    static boolean seive(int n){
        Arrays.fill(primes,true);
        primes[0]=primes[1]=false;
        for(int i=2;i*i<=n;i++){
            if(primes[i]==true){
                for(int p=i*i;p<=n;p+=i){
                    primes[p]=false;
                }
            }
        }
        if(n<1000007){
        	for(int i=2;i<=n;i++) {
        		if(primes[i])
        			b.add(i);
        	}
            return primes[n];
        }
        return false;
        
    }
    static int gcd(int a,int b){
        if(b==0)
        return a;
        return gcd(b,a%b);
    }
    static long GCD(long a,long b){
        if(b==0)
        return a;
        return GCD(b,a%b);
    }
    static ArrayList<Integer> segseive(int l,int r){
    	
    	ArrayList<Integer> isprime=new ArrayList<Integer>();
    	boolean p[]=new boolean[r-l+1];
    	Arrays.fill(p, true);
        
    	for(int i=0;b.get(i)*b.get(i)<=r;i++) {
    		int currprime=b.get(i);
    		int base=(l/currprime)*currprime;
    		if(base<l) {
    			base+=currprime;
    		}
    		for(int j=base;j<=r;j+=currprime) {
    			p[j-l]=false;
    		}
    		
    		
    		if(base==currprime) {
    			p[base-l]=true;
    		}
    		
    	}
    	for(int i=0;i<=r-l;i++) {
    		if(p[i])
    			isprime.add(i+l);
    	}
    	return isprime;
    }
      
  
    public static void main(String[] args) 
    { 
        FastReader sc=new FastReader(); 
        try{
           long n=sc.nextLong();
           long m=sc.nextLong();
           long a=sc.nextLong();
           long b=sc.nextLong();
           long ans1=n/m * m + m - n;
           long ans2=n%m;
           long ans=Long.min(ans1*a,ans2*b);
           System.out.println(ans);
            
        }catch(Exception e){
            return;
        }
    } 
}

",0990_A,CODEFORCES,1881,Commentary Boxes,"Berland Football Cup starts really soon! Commentators from all over the world come to the event.
Organizers have already built $$$n$$$ commentary boxes. $$$m$$$ regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.
If $$$n$$$ is not divisible by $$$m$$$, it is impossible to distribute the boxes to the delegations at the moment.
Organizers can build a new commentary box paying $$$a$$$ burles and demolish a commentary box paying $$$b$$$ burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.
What is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$)?
The only line contains four integer numbers $$$n$$$, $$$m$$$, $$$a$$$ and $$$b$$$ ($$$1 \le n, m \le 10^{12}$$$, $$$1 \le a, b \le 100$$$), where $$$n$$$ is the initial number of the commentary boxes, $$$m$$$ is the number of delegations to come, $$$a$$$ is the fee to build a box and $$$b$$$ is the fee to demolish a box.
Output the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$). It is allowed that the final number of the boxes is equal to $$$0$$$.
In the first example organizers can build $$$5$$$ boxes to make the total of $$$14$$$ paying $$$3$$$ burles for the each of them.
","input
In the second example organizers can demolish $$$2$$$ boxes to make the total of $$$0$$$ paying $$$7$$$ burles for the each of them.
output
In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get $$$5$$$ boxes.
","implementation, math",3
"import java.util.* ;


public class PythonIndentation
{
	public static void main(String args[])
	{
		Scanner in = new Scanner(System.in) ;
		int n = in.nextInt() ;
		boolean[] lst = new boolean[n] ;
		for(int i=0;i<n;i++)
		{
			lst[i] = (in.next().equals(""s""))?false:true ;
		}
		System.out.println(dp(lst)) ;
	}
	
	static int dp(boolean[] lst)
	{//false in lst means an ""s"" (simple statement), and true a ""f""(for loop)
		int[][] dp = new int[2][lst.length] ;
		dp[0][0] = 1 ;
		for(int i=1;i<lst.length;i++)
		{
			
			for(int j=0;j<lst.length;j++)
			{
				if(lst[i-1])//(i-1)st statement is a for loop 
				{
					if(j==0)
						dp[i%2][j] = 0 ;
					else
						dp[i%2][j] = dp[(i-1)%2][j-1] ;
				}
			
				else//i-1 st statement is a simple statement
				{
					if(j==0)
					{
						int temp = 0 ;
						for(int k=0;k<lst.length;k++)
							temp = (temp+dp[(i-1)%2][k])%1000000007 ;
						dp[i%2][j] = temp ;
					}
					else
						dp[i%2][j] = (dp[i%2][j-1]-dp[(i-1)%2][j-1])%1000000007 ;
				}
			}
		}
		int ans = 0 ;
		for(int i=0;i<lst.length;i++)
		{
			ans = (ans + dp[(lst.length-1)%2][i])%1000000007 ;
		}
		if(ans<0)
			ans = ans + 1000000007 ;
		
		return ans ;
	}
}",0909_C,CODEFORCES,3063,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class _0238InfinityGauntlet {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		Map<String,String> stones = new HashMap<String,String>();
		stones.put(""green"",""Time"");
		stones.put(""yellow"",""Mind"");
		stones.put(""orange"",""Soul"");
		stones.put(""purple"",""Power"");
		stones.put(""red"",""Reality"");
		stones.put(""blue"",""Space"");
		int n=sc.nextInt();
		sc.nextLine();
		for(int i=0;i<n;i++) {
			stones.remove(sc.nextLine());
		}
		System.out.println(stones.size());
		for(String s:stones.values()) {
			System.out.println(s);
		}
		
			

	}

}
",0987_A,CODEFORCES,634,Infinity Gauntlet,"You took a peek on Thanos wearing Infinity Gauntlet. In the Gauntlet there is a place for six Infinity Gems:
Using colors of Gems you saw in the Gauntlet determine the names of absent Gems.
In the first line of input there is one integer $$$n$$$ ($$$0 \le n \le 6$$$) — the number of Gems in Infinity Gauntlet.
In next $$$n$$$ lines there are colors of Gems you saw. Words used for colors are: purple, green, blue, orange, red, yellow. It is guaranteed that all the colors are distinct. All colors are given in lowercase English letters.
In the first line output one integer $$$m$$$ ($$$0 \le m \le 6$$$) — the number of absent Gems.
Then in $$$m$$$ lines print the names of absent Gems, each on its own line. Words used for names are: Power, Time, Space, Soul, Reality, Mind. Names can be printed in any order. Keep the first letter uppercase, others lowercase.
","input
In the first sample Thanos already has Reality, Power, Mind and Soul Gems, so he needs two more: Time and Space.
output
In the second sample Thanos doesn't have any Gems, so he needs all six.
",implementation,1
"import java.util.Scanner;

public class Word {
    static String word;

    private static void check(String subword) {
        int i = 0;
        int j = 0;
        while (j + subword.length() <= word.length()) {
            if (word.substring(j).startsWith(subword)){
                i++;
            }
            j++;
        }
        if (i > 1){
            System.out.println(subword.length());
            System.exit(0);
        }
    }

    public static void main(String[] arg) {
        Scanner in = new Scanner(System.in);
        word = in.next();
        if (word.length() == 1) {
            System.out.println(0);
            return;
        }
        for (int i = word.length() - 1; i > 0; i--) {
            int j = 0;
            while (j + i <= word.length()) {
                check(word.substring(j, i+j));
                j++;
            }
        }
        System.out.println(0);
    }
}
",0023_A,CODEFORCES,3728,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.util.*;
import static java.lang.Math.*;

public final class FollowTrafficRules {
    private static double[] acce(double i, double a, double v) {
        double[] r = new double[2];
        r[0] = (v - i)/a;
        r[1] = 1d/2d * a * pow(r[0], 2) + i * r[0];
        return r;
    }

    private static double solve(double i, double a, double l) {
        double e = sqrt(pow(i, 2) + 2d * a * l);
        e = a > 0 ? e : -1d * e;
        return (e - i)/a;
    }

    private static double time(double i, double a, double v, double l) {
        double[] r = acce(i, a, v);
        if (r[1] >= l) return solve(i, a, l);
        return r[0] + (l - r[1])/v;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        double a = sc.nextDouble();
        double v = sc.nextDouble();
        double l = sc.nextDouble();
        double d = sc.nextDouble();
        double w = sc.nextDouble();

        double t = 0d;
        if (v <= w) t = time(0, a, v, l);
        else {
            double[] r = acce(0, a, w);
            if (r[1] >= d) t = time(0, a, v, l);
            else {
                t += r[0];
                t += 2d * time(w, a, v, (d - r[1])/2d);
                t += time(w, a, v, l - d);
            }
        }

        System.out.println(t);
    }
}
",0005_D,CODEFORCES,32,Follow Traffic Rules,"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.
It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km/h2, and has maximum speed of v km/h. The road has the length of l km, and the speed sign, limiting the speed to w km/h, is placed d km (1 ≤ d < l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.
The car can enter Bercouver at any speed.
","input
The first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).
output
Print the answer with at least five digits after the decimal point.
","implementation, math",1
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Vector;
import java.util.HashMap;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.Stack;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author beginner1010
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskF2 solver = new TaskF2();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskF2 {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = in.nextInt();
            }

            HashMap<Integer, Stack<Interval>> map = new HashMap<>();
            for (int i = 0; i < n; i++) {
                int sum = 0;
                for (int j = i; j < n; j++) {
                    sum += a[j];
                    if (map.containsKey(sum) == false) {
                        map.put(sum, new Stack<>());
                    }
                    Stack<Interval> stack = map.get(sum);
                    if (stack.isEmpty() || stack.get(stack.size() - 1).r < i) {
                        stack.push(new Interval(i, j));
                    } else if (stack.get(stack.size() - 1).r >= j) {
                        stack.pop();
                        stack.push(new Interval(i, j));
                    }
                }
            }

            Stack<Interval> best = new Stack<>();
            for (Stack<Interval> stack : map.values()) {
                if (best.size() < stack.size()) {
                    best = stack;
                }
            }

            out.println(best.size());
            for (Interval i : best) {
                out.println((i.l + 1) + "" "" + (i.r + 1));
            }
        }

        class Interval {
            int l;
            int r;

            Interval(int l, int r) {
                this.l = l;
                this.r = r;
            }

        }

    }

    static class InputReader {
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputStream stream;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        private boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private int read() {
            if (numChars == -1)
                throw new InputMismatchException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isWhitespace(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isWhitespace(c));
            return res * sgn;
        }

    }
}

",1141_F2,CODEFORCES,3375,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;

public class nA {

    Scanner in;
    PrintWriter out;

    void solve() {
        int n = in.nextInt();
        int a[] = new int[n];
        int sum = 0;
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
            sum+=a[i];
        }
        Arrays.sort(a);
        int nowsum = 0;
        int kol = 0;
        for(int i = n - 1; i >= 0; i--){
            if(nowsum <= sum / 2){
                nowsum+=a[i];
                kol++;
            }else{
                break;
            }
        }
        out.println(kol);
    }

    void run() {
        in = new Scanner(System.in);
        out = new PrintWriter(System.out);
        try {
            solve();
        } finally {
            out.close();
        }
    }

    public static void main(String[] args) {
        new nA().run();
    }
}
",0160_A,CODEFORCES,2480,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;
 
 
public class q5 {
	
	
	
    
  
	
 
	public static void main(String[] args) throws IOException {
	
	Reader.init(System.in);
	PrintWriter out=new PrintWriter(System.out);
	long n=Reader.nextInt();
	long k=Reader.nextLong();
	long v=8*n+8*k+4;
	long v2=(long) Math.sqrt(v);
	long v3=2*n+2;
	//long v4=(v3+v2)/2;
	long v5=(v3-v2)/2;
	out.println(v5);
	
	
	
	
	
	out.flush();
	}
}




 
 
 
class Reader {
    static BufferedReader reader;
    static StringTokenizer tokenizer;
    /** call this method to initialize reader for InputStream */
    static void init() throws IOException {
    	 reader = new BufferedReader(
                 new FileReader(""detect.in""));
    tokenizer = new StringTokenizer("""");
    }
    static void init(InputStream input) {
        reader = new BufferedReader(
                     new InputStreamReader(input) );
        tokenizer = new StringTokenizer("""");
    }
    /** get next word */
    static String nextLine() throws IOException{
    	return reader.readLine();
    }
    static String next() throws IOException {
        while ( ! tokenizer.hasMoreTokens() ) {
            //TODO add check for eof if necessary
            tokenizer = new StringTokenizer(
                   reader.readLine() );
        }
        return tokenizer.nextToken();
    }
    static int nextInt() throws IOException {
        return Integer.parseInt( next() );
    }
    static long nextLong() throws IOException {
        return Long.parseLong( next() );
    }
    static double nextDouble() throws IOException {
        return Double.parseDouble( next() );
    }
}",1195_B,CODEFORCES,1409,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import java.io.*;
import java.util.*;
import java.math.*;
import java.util.regex.*;

/**
 *
 * @author jon
 */
public class Fish {
    double memo[] = new double[(1<<18)];
    int N, FULL;
    double prob[][] = new double[18][18];
    Fish() {
        Scanner in = new Scanner(System.in);
        Arrays.fill(memo, -1);

        N = in.nextInt();
        FULL = (1<<N) - 1;

        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                prob[i][j] = in.nextDouble();
            }
        }

        for(int i = 0; i < N; i++) {
            System.out.printf(""%.6f "", go((1<<i)));
        }
        System.out.println();



    }
    public double go(int mask) {
        if(mask == FULL) return 1.0;
        if(memo[mask] >= 0) return memo[mask];
        double ret = 0;
        double mult = Integer.bitCount(mask) + 1;
        mult *= (mult-1)/2.0;


        for(int i = 0; i < N; i++) {
            if(((1<<i) & mask) != 0) {
                for(int j = 0; j < N; j++) {
                    if(((1<<j) & mask) == 0) {
                        ret += go(mask | (1<<j)) * prob[i][j];
                    }
                }
            }
        }
        ret /= mult;

        memo[mask] = ret;
        return ret;
    }
    public static void main(String args[]) {
        new Fish();
    }
}
",0016_E,CODEFORCES,4472,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"//make sure to make new file!
import java.io.*;
import java.util.*;

public class B713{
   
   public static BufferedReader f;
   public static PrintWriter out; 
   
   public static void main(String[] args)throws IOException{
      f = new BufferedReader(new InputStreamReader(System.in));
      out = new PrintWriter(System.out);
      
      int n = Integer.parseInt(f.readLine());
      
      
      int l;
      int r;
      int mid;
      int ans;
      
      
      l = 1;
      r = n;
      ans = -1;
      //see if you can draw vertical line between them
      
      while(l <= r){
         mid = l + (r-l)/2;
         if(mid == n) break;
         
         int il = query(1,1,n,mid);
         int ir = query(1,mid+1,n,n);
         
         if(il == 1 && ir == 1){
            ans = mid;
            break;
         }
         
         if(il > ir){
            r = mid-1;
         } else {
            l = mid+1;
         }
      }
      
      int x11 = -1;
      int y11 = -1;
      int x12 = -1;
      int y12 = -1;
      int x21 = -1;
      int y21 = -1;
      int x22 = -1;
      int y22 = -1;
      if(ans == -1){
         //find horizontal line
         l = 1;
         r = n;
         ans = -1;
      
         while(l <= r){
            mid = l + (r-l)/2;
         
         
            int il = query(1,1,mid,n);
            int ir = query(mid+1,1,n,n);
         
            if(il == 1 && ir == 1){
               ans = mid;
               break;
            }
         
            if(il > ir){
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
      
         int bar = ans;
         
                  //find top line of top block
         l = 1;
         r = bar;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(mid,1,bar,n);
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         x11 = ans;
         
         //find bottom line of top block
         l = 1;
         r = bar;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,1,mid,n);
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         x12 = ans;
         
         //find left of top block
         
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,mid,bar,n);
            
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         y11 = ans;
         
         //find right of top block
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,1,bar,mid);
            
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         y12 = ans;
         
         
         
         
         
         //find top line of bottom block
         l = bar+1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(mid,1,n,n);
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         x21 = ans;
         
         //find bottom line of bottom block
         l = bar+1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(bar+1,1,mid,n);
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         x22 = ans;
         
         //find left of bottom block
         
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(bar+1,mid,n,n);
            
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         y21 = ans;
         
         //find right of bottom block
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(bar+1,1,n,mid);
            
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         y22 = ans;
         
         
         
         
         
       
      } else {
         //ans is the vertical line between
         int bar = ans;
         //find left line of left block
         l = 1;
         r = bar;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,mid,n,bar);
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         y11 = ans;
         
         //find right line of left block
         l = 1;
         r = bar;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,1,n,mid);
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         y12 = ans;
         
         //find top of left block
         
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(mid,1,n,bar);
            
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         x11 = ans;
         
         //find bottom of left block
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,1,mid,bar);
            
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         x12 = ans;
         
         
         
         
         
         //find left line of right block
         l = bar+1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,mid,n,n);
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         y21 = ans;
         
         //find right line of right block
         l = bar+1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,bar+1,n,mid);
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         y22 = ans;
         
         //find top of right block
         
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(mid,bar+1,n,n);
            
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         x21 = ans;
         
         //find bottom of right block
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,bar+1,mid,n);
            
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         x22 = ans;
         
      
      }
      
      out.println(""! "" + x11 + "" "" + y11 + "" "" + x12 + "" "" + y12 + "" "" + x21 + "" "" + y21 + "" "" + x22 + "" "" + y22);
      
      
      
      
      out.close();
   }
   
   public static int query(int a,int b, int c, int d)throws IOException{
      out.println(""? "" + a + "" "" + b + "" "" + c + "" "" + d);
      out.flush();
      
      return Integer.parseInt(f.readLine());
   }
   
      
}",0713_B,CODEFORCES,1037,Searching Rectangles,"Filya just learned new geometry object — rectangle. He is given a field consisting of n × n unit cells. Rows are numbered from bottom to top with integer from 1 to n. Columns are numbered from left to right with integers from 1 to n. Cell, located at the intersection of the row r and column c is denoted as (r, c). Filya has painted two rectangles, such that their sides are parallel to coordinate axes and each cell lies fully inside or fully outside each of them. Moreover, no cell lies in both rectangles.
Later, hedgehog Filya became interested in the location of his rectangles but was unable to find the sheet of paper they were painted on. They were taken by Sonya and now she wants to play a little game with Filya. He tells her a query rectangle and she replies with the number of initial rectangles that lie fully inside the given query rectangle. The query rectangle should match the same conditions as initial rectangles. Rectangle lies fully inside the query if each o its cells lies inside the query.
Filya knows Sonya really well, so is sure that if he asks more than 200 questions she will stop to reply.
The first line of the input contains an integer n (2 ≤ n ≤ 216) — size of the field.
For each query an integer between 0 and 2 is returned — the number of initial rectangles that lie fully inside the query rectangle.
To make a query you have to print ""? x1 y1 x2 y2"" (without quotes) (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n), where (x1, y1) stands for the position of the bottom left cell of the query and (x2, y2) stands for the up right cell of the query. You are allowed to ask no more than 200 queries. After each query you should perform ""flush"" operation and read the answer.
In case you suppose you've already determined the location of two rectangles (or run out of queries) you should print ""! x11 y11 x12 y12 x21 y21 x22 y22"" (without quotes), where first four integers describe the bottom left and up right cells of the first rectangle, and following four describe the corresponding cells of the second rectangle. You can print the rectangles in an arbitrary order. After you have printed the answer, print the end of the line and perform ""flush"". Your program should terminate immediately after it print the answer.
To flush you can use (just after printing an integer and end-of-line): 
You will get the Wrong Answer verdict if you ask more than 200 queries, or if you print an incorrect coordinates.
You will get the Idleness Limit Exceeded verdict if you don't print anything (but you should) or if you forget about flushing the output (more info below).
Hacking.
The first line should contain an integer n (2 ≤ n ≤ 216).
","input
The second line should contain four integers x1, y1, x2, y2 (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n) — the description of the first rectangle.
output
The third line contains the description of the second rectangle in the similar way.
","binarysearch, constructivealgorithms, interactive",2
"import java.util.*;


public class Main {
	private static Scanner in = new Scanner(System.in);
	public static void main(String args[]){
		int n = in.nextInt();
		String s = in.next();
		if(n==1)
			System.out.println(""1"");
		else{
			int j=0,i=1,ans=s.length();
			int h[]=new int[128];
			h[(int)s.charAt(0)]=1;
			while(i<n){
				if(h[(int)s.charAt(i)]==0)
					ans = i-j+1;
				h[(int) s.charAt(i)]++;
				while(j<i && h[(int)s.charAt(j)]>1){
					h[(int)s.charAt(j)]--;
					j++;
					ans = Math.min(ans, i-j+1);
				}
				i++;
			}
			System.out.println(ans);
		}
	}
}
",0701_C,CODEFORCES,1813,They Are Everywhere,"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.
There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 
Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. 
The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.
The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. 
Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. 
In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.
","input
In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 
output
In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.
","binarysearch, strings, twopointers",3
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Main {
    
    public static void main(String[] args) throws Exception { 
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter pw = new PrintWriter(System.out);
        
        in.nextToken();
        int n = (int) in.nval;
        double[][] a = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                in.nextToken();
                a[i][j] = in.nval;
            }
        }
        
        double[] dp = new double[1 << n];
        dp[(1 << n) - 1] = 1.0;
        
        for (int mask = (1 << n) - 2; mask > 0; mask--) {
            int count = Integer.bitCount(mask);
            double pPair = 2.0 / ((double) count * (count + 1));
            double ans = 0.0;
            
            for (int j = 0; j < n; j++) {
                int jj = 1 << j;
                if ((jj & mask) != 0) continue;
                double p = dp[mask | jj];
                double s = 0;
                for (int k = 0; k < n; k++) {
                    int kk = 1 << k;
                    if ((kk & mask) == 0) continue;
                    s += a[k][j];
                }
                ans += s * pPair * p;
            }
            dp[mask] = ans;
        }
        
        for (int i = 0; i < n; i++) {
            pw.print(dp[1 << i]);
            pw.print(' ');
        }
        
        pw.close();
    }
}
",0016_E,CODEFORCES,4526,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author prakharjain
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        _992C solver = new _992C();
        solver.solve(1, in, out);
        out.close();
    }

    static class _992C {
        static int mod = (int) 1e9 + 7;

        public void solve(int testNumber, InputReader in, OutputWriter out) {
            long x = in.nextLong();
            long k = in.nextLong();

            if (x == 0) {
                out.println(0);
                return;
            }

            long[][] base = new long[][]{{2, 0}, {1, 1}};

            _992C.Matrix.N = 2;

            base = _992C.Matrix.matrixPower(base, base, k);

            x %= mod;
            long ans = 2 * base[0][0] * x - base[1][0];

            ans %= mod;

            if (ans < 0)
                ans += mod;

            out.println(ans);
        }

        static public class Matrix {
            static int N;
            static long[][] id = new long[][]{{1, 0}, {0, 1}};

            static long[][] matrixPower(long[][] mat, long[][] base, long pow) {
                if (pow == 0) {
                    return id;
                }
                if (pow == 1) {
                    return base;
                }

                long[][] t = matrixPower(mat, base, pow / 2);

                t = multiplyMatrix(t, t);
                if (pow % 2 == 1) {
                    t = multiplyMatrix(t, base);
                }

                return t;
            }

            static long[][] multiplyMatrix(long[][] m, long[][] m2) {
                long[][] ans = new long[N][N];

                for (int i = 0; i < N; i++)
                    for (int j = 0; j < N; j++) {
                        ans[i][j] = 0;
                        for (int k = 0; k < N; k++) {
                            ans[i][j] += m[i][k] * m2[k][j];
                            ans[i][j] %= mod;
                        }
                    }

                return ans;
            }

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void println(long i) {
            writer.println(i);
        }

        public void println(int i) {
            writer.println(i);
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",0992_C,CODEFORCES,1155,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import java.io.*;
import java.util.Arrays;
import java.util.StringTokenizer;


public class Main {

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int n = sc.nextInt();
        Integer[] a = new Integer[n];
        for (int i = 0; i < n; i++)
            a[i] = sc.nextInt();
        int ans = 0;
        boolean[] taken = new boolean[n];
        Arrays.sort(a);
        for (int i = 0; i < n; i++) {
            if (taken[i]) continue;
            ans++;
            for (int j = i; j < n; j++)
                if (a[j] % a[i] == 0) taken[j] = true;
        }
        out.println(ans);
        out.flush();
        out.close();
    }


    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream system) {
            br = new BufferedReader(new InputStreamReader(system));
        }

        public Scanner(String file) throws Exception {
            br = new BufferedReader(new FileReader(file));
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public char nextChar() throws IOException {
            return next().charAt(0);
        }

        public Long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

        public void waitForInput() throws InterruptedException {
            Thread.sleep(3000);
        }
    }
}",1209_A,CODEFORCES,3496,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"import org.omg.CORBA.INTERNAL;

import java.io.*;
import java.util.*;
public class Main {
    public static void main(String args[])
    {
        FastReader input=new FastReader();
        PrintWriter out=new PrintWriter(System.out);
        int T=1;
        while(T-->0)
        {
            int n=input.nextInt();
            HashSet<Integer> set=new HashSet<>();
            for(int i=1;i<=n;i++)
            {
                set.add(i);
            }
            ArrayList<Integer> list=new ArrayList<>();
            int x=0;
            while(set.size()>3)
            {
                int v=(int)Math.pow(2,x);
                int i=1;
                while(true)
                {
                    if(!set.contains(v*i))
                    {
                        break;
                    }
                    else
                    {
                        list.add(v);
                        set.remove(v*i);
                    }
                    i+=2;
                }
                x++;
            }
            if(set.size()==3)
            {
                Iterator it=set.iterator();
                int max=0,min=Integer.MAX_VALUE;
                while(it.hasNext())
                {
                    int v=(int)it.next();
                    max=Math.max(max,v);
                    min=Math.min(min,v);
                }
                list.add(min);
                list.add(min);
                list.add(max);
            }
            else if(set.size()==2)
            {
                Iterator it=set.iterator();
                int max=0,min=Integer.MAX_VALUE;
                while(it.hasNext())
                {
                    int v=(int)it.next();
                    max=Math.max(max,v);
                    min=Math.min(min,v);
                }
                list.add(min);
                list.add(max);
            }
            else
            {
                Iterator it=set.iterator();
                int max=0,min=Integer.MAX_VALUE;
                while(it.hasNext())
                {
                    int v=(int)it.next();
                    max=Math.max(max,v);
                    min=Math.min(min,v);
                }
                list.add(max);
            }
            for(int i=0;i<list.size();i++)
            {
                out.print(list.get(i)+"" "");
            }
        }
        out.close();
    }
    static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;
        public FastReader()
        {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        int nextInt()
        {
            return Integer.parseInt(next());
        }
        long nextLong()
        {
            return Long.parseLong(next());
        }
        double nextDouble()
        {
            return Double.parseDouble(next());
        }
        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
}",1059_C,CODEFORCES,2078,Sequence Transformation,"Let's call the following process a transformation of a sequence of length $$$n$$$.
If the sequence is empty, the process ends. Otherwise, append the greatest common divisor (GCD) of all the elements of the sequence to the result and remove one arbitrary element from the sequence. Thus, when the process ends, we have a sequence of $$$n$$$ integers: the greatest common divisors of all the elements in the sequence before each deletion.
You are given an integer sequence $$$1, 2, \dots, n$$$. Find the lexicographically maximum result of its transformation.
A sequence $$$a_1, a_2, \ldots, a_n$$$ is lexicographically larger than a sequence $$$b_1, b_2, \ldots, b_n$$$, if there is an index $$$i$$$ such that $$$a_j = b_j$$$ for all $$$j < i$$$, and $$$a_i > b_i$$$.
The first and only line of input contains one integer $$$n$$$ ($$$1\le n\le 10^6$$$).
Output $$$n$$$ integers  — the lexicographically maximum result of the transformation.
","input
In the first sample the answer may be achieved this way:
output
We get the sequence $$$[1, 1, 3]$$$ as the result.
","constructivealgorithms, math",3
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.io.UncheckedIOException;
import java.util.Map;
import java.io.Closeable;
import java.util.Map.Entry;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            TaskC solver = new TaskC();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class TaskC {
        SubsetGenerator sg = new SubsetGenerator();
        Node[] nodes;
        int n;
        Map<Long, Node> map;
        long notExist;
        long[] mask2Key;
        Map<Long, LongList> sequence;
        DigitUtils.BitOperator bo = new DigitUtils.BitOperator();
        boolean[] dp;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            n = in.readInt();
            nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
                nodes[i].id = i;
            }

            map = new LinkedHashMap<>(200000);
            for (int i = 0; i < n; i++) {
                int k = in.readInt();
                for (int j = 0; j < k; j++) {
                    long x = in.readInt();
                    map.put(x, nodes[i]);
                    nodes[i].sum += x;
                }
            }

            long total = 0;
            for (Node node : nodes) {
                total += node.sum;
            }

            if (total % n != 0) {
                out.println(""No"");
                return;
            }
            long avg = total / n;

            notExist = (long) 1e18;
            mask2Key = new long[1 << n];
            Arrays.fill(mask2Key, notExist);
            sequence = new HashMap<>(200000);


            for (Map.Entry<Long, Node> kv : map.entrySet()) {
                for (Node node : nodes) {
                    node.handled = false;
                }

                long key = kv.getKey();

                Node node = kv.getValue();
                node.handled = true;
                int mask = bo.setBit(0, node.id, true);

                LongList list = new LongList(15);
                list.add(key);

                long req = avg - (node.sum - key);
                boolean valid = true;

                while (true) {
                    if (req == key) {
                        break;
                    }
                    Node next = map.get(req);
                    if (next == null || next.handled) {
                        valid = false;
                        break;
                    }
                    next.handled = true;
                    list.add(req);
                    req = avg - (next.sum - req);
                    mask = bo.setBit(mask, next.id, true);
                }

                if (!valid) {
                    continue;
                }

                mask2Key[mask] = key;
                sequence.put(key, list);
            }


            dp = new boolean[1 << n];
            for (int i = 0; i < (1 << n); i++) {
                dp[i] = mask2Key[i] != notExist;
                sg.setSet(i);
                while (!dp[i] && sg.hasNext()) {
                    int next = sg.next();
                    if (next == 0 || next == i) {
                        continue;
                    }
                    dp[i] = dp[i] || (dp[next] && dp[i - next]);
                }
            }

            if (!dp[(1 << n) - 1]) {
                out.println(""No"");
                return;
            }

            populate((1 << n) - 1);
            out.println(""Yes"");
            for (Node node : nodes) {
                out.append(node.out).append(' ').append(node.to + 1).append('\n');
            }
        }

        public void populate(int mask) {
            if (mask2Key[mask] != notExist) {
                LongList list = sequence.get(mask2Key[mask]);
                int m = list.size();
                for (int i = 0; i < m; i++) {
                    long v = list.get(i);
                    long last = list.get(DigitUtils.mod(i - 1, m));
                    Node which = map.get(v);
                    Node to = map.get(last);

                    which.out = v;
                    which.to = to.id;
                }
                return;
            }

            sg.setSet(mask);
            while (sg.hasNext()) {
                int next = sg.next();
                if (next == 0 || next == mask) {
                    continue;
                }
                if (dp[next] && dp[mask - next]) {
                    populate(next);
                    populate(mask - next);
                    return;
                }
            }
        }

    }

    static class LongList {
        private int size;
        private int cap;
        private long[] data;
        private static final long[] EMPTY = new long[0];

        public LongList(int cap) {
            this.cap = cap;
            if (cap == 0) {
                data = EMPTY;
            } else {
                data = new long[cap];
            }
        }

        public LongList(LongList list) {
            this.size = list.size;
            this.cap = list.cap;
            this.data = Arrays.copyOf(list.data, size);
        }

        public LongList() {
            this(0);
        }

        private void ensureSpace(int need) {
            int req = size + need;
            if (req > cap) {
                while (cap < req) {
                    cap = Math.max(cap + 10, 2 * cap);
                }
                data = Arrays.copyOf(data, cap);
            }
        }

        private void checkRange(int i) {
            if (i < 0 || i >= size) {
                throw new ArrayIndexOutOfBoundsException();
            }
        }

        public long get(int i) {
            checkRange(i);
            return data[i];
        }

        public void add(long x) {
            ensureSpace(1);
            data[size++] = x;
        }

        public int size() {
            return size;
        }

        public String toString() {
            return Arrays.toString(Arrays.copyOf(data, size));
        }

    }

    static class SubsetGenerator {
        private int[] meanings = new int[33];
        private int[] bits = new int[33];
        private int remain;
        private int next;

        public void setSet(int set) {
            int bitCount = 0;
            while (set != 0) {
                meanings[bitCount] = set & -set;
                bits[bitCount] = 0;
                set -= meanings[bitCount];
                bitCount++;
            }
            remain = 1 << bitCount;
            next = 0;
        }

        public boolean hasNext() {
            return remain > 0;
        }

        private void consume() {
            remain = remain - 1;
            int i;
            for (i = 0; bits[i] == 1; i++) {
                bits[i] = 0;
                next -= meanings[i];
            }
            bits[i] = 1;
            next += meanings[i];
        }

        public int next() {
            int returned = next;
            consume();
            return returned;
        }

    }

    static class Node {
        int id;
        long sum;
        boolean handled;
        long out;
        long to;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(String c) {
            cache.append(c).append('\n');
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class DigitUtils {
        private static final long[] DIGIT_VALUES = new long[19];

        static {
            DIGIT_VALUES[0] = 1;
            for (int i = 1; i < 19; i++) {
                DIGIT_VALUES[i] = DIGIT_VALUES[i - 1] * 10;
            }
        }

        private DigitUtils() {
        }

        public static int mod(int x, int mod) {
            x %= mod;
            if (x < 0) {
                x += mod;
            }
            return x;
        }

        public static class BitOperator {
            public int setBit(int x, int i, boolean v) {
                if (v) {
                    x |= 1 << i;
                } else {
                    x &= ~(1 << i);
                }
                return x;
            }

        }

    }
}

",1242_C,CODEFORCES,4876,Sum Balance,"Ujan has a lot of numbers in his boxes. He likes order and balance, so he decided to reorder the numbers.
There are $$$k$$$ boxes numbered from $$$1$$$ to $$$k$$$. The $$$i$$$-th box contains $$$n_i$$$ integer numbers. The integers can be negative. All of the integers are distinct. 
Ujan is lazy, so he will do the following reordering of the numbers exactly once. He will pick a single integer from each of the boxes, $$$k$$$ integers in total. Then he will insert the chosen numbers — one integer in each of the boxes, so that the number of integers in each box is the same as in the beginning. Note that he may also insert an integer he picked from a box back into the same box.
Ujan will be happy if the sum of the integers in each box is the same. Can he achieve this and make the boxes perfectly balanced, like all things should be?
The first line contains a single integer $$$k$$$ ($$$1 \leq k \leq 15$$$), the number of boxes. 
The $$$i$$$-th of the next $$$k$$$ lines first contains a single integer $$$n_i$$$ ($$$1 \leq n_i \leq 5\,000$$$), the number of integers in box $$$i$$$. Then the same line contains $$$n_i$$$ integers $$$a_{i,1}, \ldots, a_{i,n_i}$$$ ($$$|a_{i,j}| \leq 10^9$$$), the integers in the $$$i$$$-th box. 
It is guaranteed that all $$$a_{i,j}$$$ are distinct.
If Ujan cannot achieve his goal, output ""No"" in a single line. Otherwise in the first line output ""Yes"", and then output $$$k$$$ lines. The $$$i$$$-th of these lines should contain two integers $$$c_i$$$ and $$$p_i$$$. This means that Ujan should pick the integer $$$c_i$$$ from the $$$i$$$-th box and place it in the $$$p_i$$$-th box afterwards.
If there are multiple solutions, output any of those.
You can print each letter in any case (upper or lower).
In the first sample, Ujan can put the number $$$7$$$ in the $$$2$$$nd box, the number $$$2$$$ in the $$$3$$$rd box, the number $$$5$$$ in the $$$1$$$st box and keep the number $$$10$$$ in the same $$$4$$$th box. Then the boxes will contain numbers $$$\{1,5,4\}$$$, $$$\{3, 7\}$$$, $$$\{8,2\}$$$ and $$$\{10\}$$$. The sum in each box then is equal to $$$10$$$.
","input
In the second sample, it is not possible to pick and redistribute the numbers in the required way.
output
In the third sample, one can swap the numbers $$$-20$$$ and $$$-10$$$, making the sum in each box equal to $$$-10$$$.
","bitmasks, dfsandsimilar, dp, graphs",7
"import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class D1517 {
	public static int[] dy = { 0, 1, 0, -1 };
	public static int[] dx = { -1, 0, 1, 0 };
	static int n;
	static int m;
	static int k;
	static int[][][] edges;
	static int[][][] dp;

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		n = in.nextInt();
		m = in.nextInt();
		k = in.nextInt();
		edges = new int[n][m][4];
		// System.out.println(n + "" "" + m + "" "" + k);
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m - 1; j++) {
				int temp = in.nextInt();
				// System.out.println(i+"" ""+j+"" ""+temp);
				edges[i][j][1] = temp;
				edges[i][j + 1][3] = temp;
			}
		}
		for (int i = 0; i < n - 1; i++) {
			for (int j = 0; j < m; j++) {
				int temp = in.nextInt();
				edges[i][j][2] = temp;
				edges[i + 1][j][0] = temp;
			}
		}
		if (k % 2 == 1) {
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < m; j++) {
					System.out.print(-1+"" "");
				}
				System.out.println();
			}
			return;
		}
		dp = new int[n][m][20];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				Arrays.fill(dp[i][j], -1);
			}
		}
		//Long l = System.nanoTime();
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				System.out.print(recurse(i, j, k / 2, 0) * 2 + "" "");
			}
			System.out.println();
		}
		//System.out.println(System.nanoTime() - l);
//		for (int i = 0; i < n; i++) {
//			for (int j = 0; j < m; j++) {
//				for (int k = 0; k < 4; k++) {
//					System.out.print(edges[i][j][k]);
//				}
//				System.out.print(""  "");
//			}
//			System.out.println();
//		}
	}

	public static int recurse(int i, int j, int k, int sum) {
		if (k == 0) {
			return sum;
		}
		if (dp[i][j][k] != -1) {
			return sum + dp[i][j][k];
		}
		int min = Integer.MAX_VALUE;
		for (int a = 0; a < 4; a++) {
			int x = i + dx[a];
			int y = j + dy[a];
			// System.out.println(i + "" "" + j + ""moveTo:"" + x + "" "" + y);
			if (x < 0 || y < 0 || x >= n || y >= m) {
				continue;
			}
			// System.out.println(""\t""+edges[i][j][a]);
			min = Math.min(min, recurse(x, y, k - 1, sum + edges[i][j][a]));
		}
		dp[i][j][k] = min - sum;
		return min;
	}
}

class Pair3 {
	int x;
	int y;
	int z;

	public Pair3(int x, int y, int z) {
		this.x = x;
		this.y = y;
		this.z = z;
	}
}",1517_D,CODEFORCES,4267,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.awt.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;
import java.util.List;

public class Main {


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long n = scanner.nextLong();
        long x = scanner.nextLong(), y = scanner.nextLong();
        long whiteSteps, blackSteps;

        if(x == 1 || y == 1){
            whiteSteps = (x - 1) + (y - 1);
        } else {
            whiteSteps = Math.min((x - 1) + Math.abs(y - x), (y - 1) + Math.abs(y - x));
        }

        if(x == n || y == n){
            blackSteps = (n - x) + (n - y);
        } else {
            blackSteps = Math.min((n - x) + Math.abs(y - x), (n - y) + Math.abs(y - x));
        }

        if (whiteSteps <= blackSteps){
            System.out.println(""White"");
        } else {
            System.out.println(""Black"");
        }

    }
}
",1075_A,CODEFORCES,705,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Scanner;

public class Main {
	static StreamTokenizer st = new StreamTokenizer(new BufferedInputStream(System.in));
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static PrintWriter pr = new PrintWriter(new BufferedOutputStream(System.out));
	static Scanner sc = new Scanner(System.in);

	public static void main(String[] args) throws NumberFormatException, IOException {
		int a = sc.nextInt();
		int b = sc.nextInt();
		int i = 0;
		int cont = 0;
		while(cont<b) {
			i++;
			cont+=i;
		}
		
		if(i+cont-b==a) {
			System.out.println(cont-b);
		}else {
			while(i+cont-b!=a) {
				i++;
				cont+=i;
			}
			System.out.println(cont-b);
		}
	}

	private static int nextInt() {
		try {
			st.nextToken();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return (int) st.nval;
	}
}
",1195_B,CODEFORCES,1412,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws Exception {
        //System.setIn(new FileInputStream(""1""));
        in = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);

        solve();

        in.close();
        out.close();
    }

    private static void solve() throws Exception {
        int n = nextInt();
        boolean[] use = new boolean[500];
        ArrayList<Integer> a = new ArrayList<Integer>();
        for (int i = 0; i < n; i++) {
            int v = nextInt();
            if (!use[250 + v]) {
                use[250 + v] = true;
                a.add(v);
            }
        }
        Collections.sort(a);
        if (a.size() < 2) {
            out.println(""NO"");
        } else {
            out.println(a.get(1));
        }
    }

    static BufferedReader in;
    static PrintWriter out;
    static StringTokenizer st;

    static String nextString() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(in.readLine());
        }
        return st.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(nextString());
    }

    static double nextDouble() throws IOException {
        return Double.parseDouble(nextString());
    }
}
",0022_A,CODEFORCES,2369,Second Order Statistics,"Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.
","input
The first input line contains integer n (1 ≤ n ≤ 100) — amount of numbers in the sequence. The second line contains n space-separated integer numbers — elements of the sequence. These numbers don't exceed 100 in absolute value.
output
If the given sequence has the second order statistics, output this order statistics, otherwise output NO.
",bruteforce,4
"import java.util.Scanner;
import java.util.Vector;

public class Main {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int a[] = new int[n];
        int b[] = new int[n];
        for (int i = 0; i < n; i++) a[i] = sc.nextInt();
        for (int i = 0; i < n; i++) b[i] = sc.nextInt();
        int c[] = new int[2 * n];
        c[0] = a[0];
        for (int i = 1; i < n; i++) {
            c[i * 2] = a[i];
            c[i * 2 - 1] = b[i];
            if (a[i] == 1 || b[i] == 1) {
                System.out.print(-1);
                System.exit(0);
            }
        }
        c[2 * n - 1] = b[0];
        if (a[0] == 1 || b[0] == 1) {
            System.out.print(-1);
            System.exit(0);
        }
        System.out.println(bin_search(c, m));
    }

    private static double bin_search(int[] c, int m) {
        double start = 0;
        double end = Integer.MAX_VALUE;
        double mid;
        while (start + 0.0000001 < end) {
            mid = (start + end) / 2;
            if (test(mid, m, c)) end = mid;
            else start = mid;
        }
        return end;
    }

    private static boolean test(double fuel, int m, int[] c) {
        for (int i = 0; i < c.length; i++) {
            fuel -= (m + fuel) / c[i];
            if (fuel < 0) {
                return false;
            }
        }
        return true;
    }
}
",1010_A,CODEFORCES,2860,Fly,"Natasha is going to fly on a rocket to Mars and return to Earth. Also, on the way to Mars, she will land on $$$n - 2$$$ intermediate planets. Formally: we number all the planets from $$$1$$$ to $$$n$$$. $$$1$$$ is Earth, $$$n$$$ is Mars. Natasha will make exactly $$$n$$$ flights: $$$1 \to 2 \to \ldots n \to 1$$$.
Flight from $$$x$$$ to $$$y$$$ consists of two phases: take-off from planet $$$x$$$ and landing to planet $$$y$$$. This way, the overall itinerary of the trip will be: the $$$1$$$-st planet $$$\to$$$ take-off from the $$$1$$$-st planet $$$\to$$$ landing to the $$$2$$$-nd planet $$$\to$$$ $$$2$$$-nd planet $$$\to$$$ take-off from the $$$2$$$-nd planet $$$\to$$$ $$$\ldots$$$ $$$\to$$$ landing to the $$$n$$$-th planet $$$\to$$$ the $$$n$$$-th planet $$$\to$$$ take-off from the $$$n$$$-th planet $$$\to$$$ landing to the $$$1$$$-st planet $$$\to$$$ the $$$1$$$-st planet.
The mass of the rocket together with all the useful cargo (but without fuel) is $$$m$$$ tons. However, Natasha does not know how much fuel to load into the rocket. Unfortunately, fuel can only be loaded on Earth, so if the rocket runs out of fuel on some other planet, Natasha will not be able to return home. Fuel is needed to take-off from each planet and to land to each planet. It is known that $$$1$$$ ton of fuel can lift off $$$a_i$$$ tons of rocket from the $$$i$$$-th planet or to land $$$b_i$$$ tons of rocket onto the $$$i$$$-th planet. 
For example, if the weight of rocket is $$$9$$$ tons, weight of fuel is $$$3$$$ tons and take-off coefficient is $$$8$$$ ($$$a_i = 8$$$), then $$$1.5$$$ tons of fuel will be burnt (since $$$1.5 \cdot 8 = 9 + 3$$$). The new weight of fuel after take-off will be $$$1.5$$$ tons. 
Please note, that it is allowed to burn non-integral amount of fuel during take-off or landing, and the amount of initial fuel can be non-integral as well.
Help Natasha to calculate the minimum mass of fuel to load into the rocket. Note, that the rocket must spend fuel to carry both useful cargo and the fuel itself. However, it doesn't need to carry the fuel which has already been burnt. Assume, that the rocket takes off and lands instantly.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 1000$$$) — number of planets.
The second line contains the only integer $$$m$$$ ($$$1 \le m \le 1000$$$) — weight of the payload.
The third line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 1000$$$), where $$$a_i$$$ is the number of tons, which can be lifted off by one ton of fuel.
The fourth line contains $$$n$$$ integers $$$b_1, b_2, \ldots, b_n$$$ ($$$1 \le b_i \le 1000$$$), where $$$b_i$$$ is the number of tons, which can be landed by one ton of fuel. 
It is guaranteed, that if Natasha can make a flight, then it takes no more than $$$10^9$$$ tons of fuel.
If Natasha can fly to Mars through $$$(n - 2)$$$ planets and return to Earth, print the minimum mass of fuel (in tons) that Natasha should take. Otherwise, print a single number $$$-1$$$.
It is guaranteed, that if Natasha can make a flight, then it takes no more than $$$10^9$$$ tons of fuel.
The answer will be considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$. Formally, let your answer be $$$p$$$, and the jury's answer be $$$q$$$. Your answer is considered correct if $$$\frac{|p - q|}{\max{(1, |q|)}} \le 10^{-6}$$$.
Let's consider the first example.
","input
Initially, the mass of a rocket with fuel is $$$22$$$ tons.
output
In the second case, the rocket will not be able even to take off from Earth.
","binarysearch, math",4
"import java.io.*;
import java.util.*;
public class EMatrix{
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskE solver = new TaskE();
        solver.solve(1, in, out);
        out.flush();out.close();
    }
        static class TaskE {
            final int max = (int)(1E9);
            int n , m;
            int a[][];
            int gm[];
            boolean visit[][]; int dp[][];
            boolean check(int d){
                if(n == 1){
                    for(int i = 0; i < m - 1; i++){
                        if(Math.abs(a[0][i] - a[0][i + 1]) < d)return false;
                    }
                    return true;
                }
                int nm[] = new int[n], pm[] = new int[n];
                for(int i = 0; i < n; i++){
                    boolean r;
                    for(int j = 0; j < n; j++){
                        if(j == i)continue;
                        r = true;
                        for(int k = 0; k < m; k++){
                            if(Math.abs(a[i][k] - a[j][k]) < d){
                                r = false; break;
                            }
                        }
                        if(r){
                            nm[i] |= (1 << j);
                        }
                        r = true;
                        for(int k = 0; k < m - 1; k++){
                            if(Math.abs(a[i][k + 1] - a[j][k]) < d){
                                r = false; break;
                            }
                        }
                        if(r){
                            pm[i] |= (1 << j);
                        }
                    }
                }
                // for(int i = 0; i < n; i++){
                //     System.out.println(nm[i] + "" "" + pm[i]);
                // }
                for(int i = 0; i < n; i++){
                    gm = new int[n];
                    gm[i] = nm[i];
                    for(int j = 0; j < n; j++){
                        if(j == i)continue;
                        if((nm[j] & (1 << i)) != 0){
                            gm[j] = nm[j] ^ (1 << i);
                        }else{
                            gm[j] = nm[j];
                        }
                    }
                    for(int j = 0; j < n; j++){
                        if(j == i)continue;
                        if((pm[i] >> j) % 2 == 1){
                            gm[j] |= (1 << i);
                        }
                    }
                    visit = new boolean[n][1 << n]; dp = new int[n][1 << n];
                    // for(int x = 0; x < n; x++)System.out.println(gm[x]);
                    if(dfs(i, i, (1 << i)) == n){
                        return true;
                    }
                }
                return false;
            }
            int dfs(int u, int r, int mask){
                // System.out.println(u + "" "" + r + "" "" + mask);
                if(u == r && mask == (1 << n) - 1)return 0;
                if(visit[u][mask])return dp[u][mask];
                visit[u][mask] = true;
                int val = 0;
                for(int i = 0; i < n; i++){
                    if((gm[u] >> i) % 2 == 1 && ((i == r && mask == (1 << n) - 1) || (mask >> i) % 2 != 1)){
                        val = Math.max(val, 1 + dfs(i, r, mask | (1 << i)));
                    }
                }
                // System.out.println(u + "" "" + mask + "" "" + val);
                return dp[u][mask] = val;
            }
           public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt(); m = in.nextInt();
            a = new int[n][m];
            for(int i = 0; i < n; i++){
                for(int j = 0; j < m; j++){
                    a[i][j] = in.nextInt();
                }
            }
            int l = 0, r = max, ans = 0;
            while(l <= r){
                int m = (l + r) >> 1;
                if(check(m)){
                    ans = m;
                    l = m + 1;
                }else{
                    r = m - 1;
                }
            }
            out.println(ans);
          }
//         pair ja[][];long w[];int from[],to[],c[];
//             void make(int n,int m,InputReader in){
//              ja=new pair[n+1][];w=new long[m];from=new int[m];to=new int[m];c=new int[n+1];
//              for(int i=0;i<m;i++){
//               int u=in.nextInt(),v=in.nextInt();long wt=in.nextLong();
//               c[u]++;c[v]++;from[i]=u;to[i]=v;w[i]=wt;
//              }
//              for(int i=1;i<=n;i++){
//               ja[i]=new pair[c[i]];c[i]=0;
//              }
//              for(int i=0;i<m;i++){
//               ja[from[i]][c[from[i]]++]=new pair(to[i],w[i]);
//               ja[to[i]][c[to[i]]++]=new pair(from[i],w[i]);
//              }
//             }
//        int[] radixSort(int[] f){ return radixSort(f, f.length); }
//    int[] radixSort(int[] f, int n)
//    {
//        int[] to = new int[n];
//        {
//            int[] b = new int[65537];
//            for(int i = 0;i < n;i++)b[1+(f[i]&0xffff)]++;
//            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
//            for(int i = 0;i < n;i++)to[b[f[i]&0xffff]++] = f[i];
//            int[] d = f; f = to;to = d;
//        }
//        {
//            int[] b = new int[65537];
//            for(int i = 0;i < n;i++)b[1+(f[i]>>>16)]++;
//            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
//            for(int i = 0;i < n;i++)to[b[f[i]>>>16]++] = f[i];
//            int[] d = f; f = to;to = d;
//        }
//        return f;
//    }
    }
    static class InputReader {
        BufferedReader br;
        StringTokenizer st;
        public InputReader(InputStream stream) {
            br = new BufferedReader(new InputStreamReader(stream));
            st = null;
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                String s = null;
                try {
                    s = br.readLine();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (s == null)
                    return null;
                st = new StringTokenizer(s);
            }
            return st.nextToken();
        }

        boolean hasMoreTokens() {
            while (st == null || !st.hasMoreTokens()) {
                String s = null;
                try {
                    s = br.readLine();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (s == null)
                    return false;
                st = new StringTokenizer(s);
            }
            return true;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}",1102_F,CODEFORCES,4686,Elongated Matrix,"You are given a matrix $$$a$$$, consisting of $$$n$$$ rows and $$$m$$$ columns. Each cell contains an integer in it.
You can change the order of rows arbitrarily (including leaving the initial order), but you can't change the order of cells in a row. After you pick some order of rows, you traverse the whole matrix the following way: firstly visit all cells of the first column from the top row to the bottom one, then the same for the second column and so on. During the traversal you write down the sequence of the numbers on the cells in the same order you visited them. Let that sequence be $$$s_1, s_2, \dots, s_{nm}$$$. 
The traversal is $$$k$$$-acceptable if for all $$$i$$$ ($$$1 \le i \le nm - 1$$$) $$$|s_i - s_{i + 1}| \ge k$$$.
Find the maximum integer $$$k$$$ such that there exists some order of rows of matrix $$$a$$$ that it produces a $$$k$$$-acceptable traversal.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 16$$$, $$$1 \le m \le 10^4$$$, $$$2 \le nm$$$) — the number of rows and the number of columns, respectively.
Each of the next $$$n$$$ lines contains $$$m$$$ integers ($$$1 \le a_{i, j} \le 10^9$$$) — the description of the matrix.
Print a single integer $$$k$$$ — the maximum number such that there exists some order of rows of matrix $$$a$$$ that it produces an $$$k$$$-acceptable traversal.
In the first example you can rearrange rows as following to get the $$$5$$$-acceptable traversal:
Then the sequence $$$s$$$ will be $$$[5, 10, 4, 9, 3, 8, 3, 9]$$$. Each pair of neighbouring elements have at least $$$k = 5$$$ difference between them.
","input
In the second example the maximum $$$k = 0$$$, any order is $$$0$$$-acceptable.
output
In the third example the given order is already $$$3$$$-acceptable, you can leave it as it is.
","binarysearch, bitmasks, bruteforce, dp, graphs",7
"/*
    Draw a triangle with vertices at the centre of the
    inner triangle, and centres of two adjacent outer
    triangles.

    Interior angle of a regular N-gon = 180(N-2)/2
    Central angle can be obtained using interior angles,
    or it's also simply 360/N

    Use sin rule: sinA/a = sinB/b = sinC/c
    sin(central angle)/2R = sin(interior/2)/(r+R)

    alpha = interior angle of polygon
    beta = central angle of the triangle (vertex inside circle)
 */


//created by Whiplash99
import java.io.*;
import java.util.*;
public class A
{
    private static double interiorAngle(int N)
    {
        return (double)180*(N-2)/(double)N;
    }
    private static double centralAngle(int N)
    {
        return (double)360/(double)N;
    }
    public static void main(String[] args) throws Exception
    {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));

        int i,N;

        String[] s=br.readLine().trim().split("" "");
        N=Integer.parseInt(s[0]);
        int r=Integer.parseInt(s[1]);

        double alpha=Math.toRadians(interiorAngle(N));
        double beta=Math.toRadians(centralAngle(N));

        double num=Math.sin(beta)/Math.sin(alpha/2);
        double ans=r*num/(2-num);

        System.out.println(ans);
    }
}",1100_C,CODEFORCES,739,NN and the Optical Illusion,"NN is an experienced internet user and that means he spends a lot of time on the social media. Once he found the following image on the Net, which asked him to compare the sizes of inner circles:
It turned out that the circles are equal. NN was very surprised by this fact, so he decided to create a similar picture himself.
He managed to calculate the number of outer circles $$$n$$$ and the radius of the inner circle $$$r$$$. NN thinks that, using this information, you can exactly determine the radius of the outer circles $$$R$$$ so that the inner circle touches all of the outer ones externally and each pair of neighboring outer circles also touches each other. While NN tried very hard to guess the required radius, he didn't manage to do that. 
Help NN find the required radius for building the required picture.
The first and the only line of the input file contains two numbers $$$n$$$ and $$$r$$$ ($$$3 \leq n \leq 100$$$, $$$1 \leq r \leq 100$$$) — the number of the outer circles and the radius of the inner circle respectively.
Output a single number $$$R$$$ — the radius of the outer circle required for building the required picture. 
","input
Your answer will be accepted if its relative or absolute error does not exceed $$$10^{-6}$$$.
output
Formally, if your answer is $$$a$$$ and the jury's answer is $$$b$$$. Your answer is accepted if and only when $$$\frac{|a-b|}{max(1, |b|)} \le 10^{-6}$$$.
","binarysearch, geometry, math",1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class A {

	/**
	 * @param args
	 * @throws IOException
	 */
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		// BufferedReader rd = new BufferedReader(new
		// InputStreamReader(System.in));
		// StringTokenizer t = new StringTokenizer(rd.readLine(), "" "");
		int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();
		int pl[] = new int[n];
		if (k >= m) {
			System.out.println(0);
			System.exit(0);
		}
		m -= k;
		for (int i = 0; i < n; i++) {
			pl[i] = sc.nextInt() - 1;
		}
		Arrays.sort(pl);
		int out = 0;
		for (int i = n - 1; i >= 0; i--) {
			m -= pl[i];
			out++;
			if (m <= 0)
				break;
		}
		if (m <= 0)
			System.out.println(out);
		else
			System.out.println(-1);
	}

}
",0257_A,CODEFORCES,2683,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings",4
"import java.io.IOException;
import java.util.Scanner;


public class A199 {
	static int n[][] = new int[][] { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };

	public static void main(String[] args) throws IOException {
		new A199().solve();
	}

	public void solve() throws IOException {
		Scanner scan = new Scanner(System.in);
		int N = scan.nextInt();
//		int f1 = 0;
//		int f2 = 1;
//		
//		while(true){
//			int t = f1 + f2;
//			if(t == N){
//				//guaranteed that n is a Fibonacci number
//				break;
//			}
//			f1 = f2;
//			f2 = t;
//		}
		System.out.println(""0 0 "" + N );
	}
}
",0199_A,CODEFORCES,200,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"import java.util.Arrays;
import java.util.Scanner;

public class D {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(), sum = 0;
        int [] a = new int[n+1];
        for (int i = 1; i <= n; i++) {
            a[i] = in.nextInt();
        }
        for (int i = 1; i <= n; ++i)
            for (int j = i + 1; j <= n; ++j)
                sum += a[i] > a[j] ? 1 : 0;
        int m = in.nextInt();
        sum &= 1;
        for (int i = 1; i <= m; i++) {
            int l = in.nextInt(), r = in.nextInt();
            if (((r - l + 1) / 2) % 2 == 1)
                sum ^= 1;
            System.out.println(sum == 1 ? ""odd"" : ""even"");
        }
    }
}",0911_D,CODEFORCES,3222,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class P35C {
	public static void main(String[] args) throws FileNotFoundException {
		InputStream inputStream = new FileInputStream(""input.txt"");
		OutputStream outputStream = new FileOutputStream(""output.txt"");
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		Task solver = new Task();
		solver.solve(in, out);
		out.close();
	}

	static class Task {
		private class Point {
			int x, y;

			public Point(int x, int y) {
				this.x = x;
				this.y = y;
			}

		}

		private int dis(int i, int j, Point p2) {
			return Math.abs(i - p2.x) + Math.abs(j - p2.y);
		}

		public void solve(InputReader in, PrintWriter out) {
			int n = in.nextInt(), m = in.nextInt();
			int k = in.nextInt();
			Point[] ps = new Point[k];
			for (int i = 0; i < k; i++) {
				ps[i] = new Point(in.nextInt() - 1, in.nextInt() - 1);
			}
			int max = 0;
			Point argmax = ps[0];
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < m; j++) {
					int val = dis(i, j, ps[0]);
					for (int l = 1; l < k; l++) {
						val = Math.min(val, dis(i, j, ps[l]));
					}
					if (val > max) {
						max = val;
						argmax = new Point(i, j);
					}
				}
			}
			out.println((argmax.x + 1) + "" "" + (argmax.y + 1));
		}
	}

	static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader(InputStream stream) {
			reader = new BufferedReader(new InputStreamReader(stream), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public String nextLine() {
			try {
				return reader.readLine();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}

	}

}
",0035_C,CODEFORCES,3916,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"import java.io.*;

import static java.lang.Integer.*;
import static java.lang.Math.*;
public class A {
	public static void main(String[] args) throws Throwable{
		BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
		String ln=in.readLine().trim();
		System.out.println(max(parseInt(ln),max(parseInt(ln.substring(0,ln.length()-1)),parseInt(ln.substring(0, ln.length()-2)+ln.substring(ln.length()-1)))));
	}
}
",0313_A,CODEFORCES,339,Ilya and Bank Account,"Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.
Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.
Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.
The single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.
In a single line print an integer — the maximum state of the bank account that Ilya can get. 
","input
In the first test sample Ilya doesn't profit from using the present.
output
In the second test sample you can delete digit 1 and get the state of the account equal to 0.
","implementation, numbertheory",1
"/* package codechef; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Main
{
    public static int n;
    public static int m;
    public static int k;
    public static int[][] right;
    public static int[][] down;
    public static int[][][] dp;
    public static void recur(int i, int j, int depth)
    {
        if(dp[i][j][depth]!=-1)
            return;
        int min=Integer.MAX_VALUE;
        // left
        if(j>0)
        {
            recur(i, j-1, depth-1);
            min=Math.min(min, dp[i][j-1][depth-1] + right[i][j-1]);
        }
        // right
        if(j<m-1)
        {
            recur(i, j+1, depth-1);
            min=Math.min(min, dp[i][j+1][depth-1] + right[i][j]);
        }
        // up
        if(i>0)
        {
            recur(i-1, j, depth-1);
            min=Math.min(min, dp[i-1][j][depth-1] + down[i-1][j]);
        }
        // down
        if(i<n-1)
        {
            recur(i+1, j, depth-1);
            min=Math.min(min, dp[i+1][j][depth-1] + down[i][j]);

        }
        dp[i][j][depth]=min;
    }
    public static void main (String[] args) throws java.lang.Exception
    {
        // your code goes here
        Scanner sc=new Scanner(System.in);
        n=sc.nextInt();
        m=sc.nextInt();
        k=sc.nextInt();
        right=new int[n][m-1];
        down=new int[n-1][m];
        for(int i=0;i<n;i++)
            for(int j=0;j<m-1;j++)
                right[i][j]=sc.nextInt();
        for(int i=0;i<n-1;i++)
            for(int j=0;j<m;j++)
                down[i][j]=sc.nextInt();
        if(k%2==1) {
            for(int i=0;i<n;++i) {
                for (int j = 0; j < m; j++)
                    System.out.print(-1 + "" "");
                System.out.println();
            }
        }
        else
        {
            k/=2;
            dp=new int[n][m][k+1];
            for(int i=0;i<n;++i)
                for(int j=0;j<m;j++)
                    for(int z=1;z<=k;z++)
                        dp[i][j][z]=-1;
            for(int i=0;i<n;++i)
                for(int j=0;j<m;j++)
                    recur(i,j,k);
            for(int i=0;i<n;++i) {
                for (int j = 0; j < m; j++)
                    System.out.print((dp[i][j][k] * 2) + "" "");
                System.out.println();
            }
        }
    }

}",1517_D,CODEFORCES,4174,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.io.*;
import java.math.BigInteger;
import java.util.*;

//@SuppressWarnings(""unused"")
public class Solution {
    public static void main(String[] args) throws IOException {
        boolean isDebugMode = Arrays.asList(args).contains(""DEBUG_MODE"");
        InputStream inputStream;
        OutputStream outputStream;

        if (isDebugMode) {
//            inputStream = new ConsoleInputStream();
            inputStream = new FileInputStream();

//            outputStream = new FileOutputStream();
            outputStream = new ConsoleOutputStream();
        } else {
            inputStream = new ConsoleInputStream();
            outputStream = new ConsoleOutputStream();

//            inputStream = new FileInputStream(""INPUT.TXT"");
//            outputStream = new FileOutputStream(""OUTPUT.TXT"");
        }

        inputStream.open();
        outputStream.open();

        new Solution().run(inputStream, outputStream, isDebugMode);

        outputStream.close();
        inputStream.close();
    }

    @SuppressWarnings(""FieldCanBeLocal"")
    private InputStream in;
    private OutputStream out;
    private boolean isDebugMode;
    private Timer timer = new Timer();

    private void printInDebug(String s) throws IOException {
        if (isDebugMode) {
            out.println(s);
            out.flush();
        }
    }

    private void printTimer(String mark) throws IOException {
        printInDebug(mark + "": "" + timer.getMillisAndReset() + "" ms."");
    }

    private static String formatDouble(double n, int precision) {
        return String.format(Locale.ENGLISH, ""%."" + precision + ""f"", n);
    }

    private void run(InputStream in, OutputStream out, boolean isDebugMode) throws IOException {
        this.in = in;
        this.out = out;
        this.isDebugMode = isDebugMode;

//        int t = in.nextInt();
        int t = 1;
        for (int i = 0; i < t; i++) {
            solve();
            out.flush();
        }
    }

    private void solve() throws IOException {
        int n = in.nextInt();
        A[] a = new A[n];
        for (int i = 0; i < n; i++) {
            int xi = in.nextInt();
            int wi = in.nextInt();
            a[i] = new A(xi - wi, xi + wi);
        }
        Arrays.sort(a, new Comparator<A>() {
            @Override
            public int compare(A o1, A o2) {
                int c = o1.r - o2.r;
                if (c != 0) return c;
                return o1.l - o2.l;
            }
        });
        int lst = Integer.MIN_VALUE;
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            if (lst <= a[i].l) {
                lst = a[i].r;
                cnt++;
            }
        }
        out.println(cnt);
    }

    private static class A {
        private int l;
        private int r;

        public A(int l, int r) {
            this.l = l;
            this.r = r;
        }
    }


    private long gcd(long a, long b) {
        while (a > 0 && b > 0) {
            if (a > b) a %= b;
            else b %= a;
        }
        return a + b;
    }


    private static final int mm = 10000000;

    private static int mult(int a, int b) {
        return (int) ((a * (long) b) % mm);
    }

    private int pow(int a, int n) {
        if (n == 0) return 1;
        int t = pow(a, n / 2);
        t = mult(t, t);
        if (n % 2 != 0) {
            t = mult(t, t);
        }
        return t;
    }

    private static class FSegmentTreeMax {
        private int[] t;

        private FSegmentTreeMax(int[] a) {
            this.t = new int[a.length * 4];
            build(a, 1, 0, a.length - 1);
        }

        private void build(int a[], int v, int tl, int tr) {
            if (tl == tr)
                t[v] = a[tl];
            else {
                int tm = (tl + tr) / 2;
                build(a, v * 2, tl, tm);
                build(a, v * 2 + 1, tm + 1, tr);
                t[v] = Math.max(t[v * 2], t[v * 2 + 1]);
            }
        }

        private int get(int v, int tl, int tr, int l, int r) {
            if (l > r)
                return Integer.MIN_VALUE;
            if (l == tl && r == tr)
                return t[v];
            int tm = (tl + tr) / 2;
            return Math.max(get(v * 2, tl, tm, l, Math.min(r, tm)), get(v * 2 + 1, tm + 1, tr, Math.max(l, tm + 1), r));
        }

        private void update(int v, int tl, int tr, int pos, int newVal) {
            if (tl == tr)
                t[v] = newVal;
            else {
                int tm = (tl + tr) / 2;
                if (pos <= tm) {
                    update(v * 2, tl, tm, pos, newVal);
                } else {
                    update(v * 2 + 1, tm + 1, tr, pos, newVal);
                }
                t[v] = Math.max(t[v * 2], t[v * 2 + 1]);
            }
        }
    }

    /*
     * Template classes
     * Author: Andrey Siunov
     * Date: 29.08.2013
     * Note: all classes are inner, because some testing servers do not run code with several classes
      */

    private static class SegmentTree {
        private static class Value {
            private HashMap<Integer, Integer> vals;
            private long res = 0;

            private int firstX = -1;
            private int lastX = -1;
            private long diff = 0;

            private Value() {
            }

            private Value(int val) {
                this.vals = new HashMap<Integer, Integer>();
                vals.put(val + 1, 1);
            }

            private void init(Value val1, Value val2) {
                this.vals = new HashMap<Integer, Integer>(val1.vals);
                for (Map.Entry<Integer, Integer> e : val2.vals.entrySet()) {
                    Integer p = vals.get(e.getKey());
                    vals.put(e.getKey(), (p == null ? 0 : p) + e.getValue());
                }
            }
        }

        private int n;
        private Value[] values;

        public SegmentTree(int n) {
            this.n = n;
            values = new Value[n * 4];
            build(1, 0, n - 1);
        }

        private void build(int v, int tl, int tr) {
            if (tl == tr) {
                values[v] = new Value(tl);
            } else {
                int tm = (tl + tr) >> 1;
                build(v << 1, tl, tm);
                build((v << 1) + 1, tm + 1, tr);
                values[v] = new Value();
                pull(v);
            }
        }

        public void update(int l, int r, int x) {
            update(1, 0, n - 1, l, r, x);
        }

        private void update(int v, int tl, int tr, int l, int r, int x) {
            if (tl == l && tr == r) {
                Value pVal = values[v];
                if (pVal.firstX < 0) {
                    pVal.firstX = x;
                    pVal.lastX = x;


                    for (Map.Entry<Integer, Integer> e : pVal.vals.entrySet()) {
                        pVal.res += Math.abs(e.getKey() - x) * (long) e.getValue();
                    }
                    pVal.vals.clear();
                    pVal.vals.put(x, r - l + 1);
                } else {
                    pVal.res += (r - l + 1) * Math.abs(pVal.lastX - x);
                    pVal.vals.clear();
                    pVal.vals.put(x, r - l + 1);

                    pVal.diff += Math.abs(pVal.lastX - x);
                    pVal.lastX = x;
                }
                return;
            }
            int tm = (tl + tr) >> 1;

            push(v, tl, tm, tr);

            if (l <= tm) {
                update(v << 1, tl, tm, l, Math.min(tm, r), x);
            }
            if (r >= tm + 1) {
                update((v << 1) + 1, tm + 1, tr, Math.max(l, tm + 1), r, x);
            }
            pull(v);
        }

        public long get(int l, int r) {
            return get(1, 0, n - 1, l, r);
        }

        private Long get(int v, int tl, int tr, int l, int r) {
            if (l > r) {
                return null;
            }

            int tm = (tl + tr) >> 1;

            push(v, tl, tm, tr);

            if (l == tl && r == tr) {
                return values[v].res;
            }

            int leftTo = Math.min(r, tm);
            Long leftValue = get(v << 1, tl, tm, l, leftTo);

            int rightFrom = Math.max(l, tm + 1);
            Long rightValue = get((v << 1) + 1, tm + 1, tr, rightFrom, r);

            return leftValue == null ? rightValue :
                    (rightValue == null ? leftValue :
                            leftValue + rightValue);
        }

        private void pull(int v) {
            Value pVal = values[v];
            Value val1 = values[v << 1];
            Value val2 = values[(v << 1) + 1];
            pVal.lastX = -1;
            pVal.firstX = -1;
            pVal.diff = 0;
            pVal.res = val1.res + val2.res;
            pVal.init(val1, val2);
        }

        private void push(int v, int from, int mid, int to) {
            if (from < to) {
                push(values[v << 1], values[v], from, mid);
                push(values[(v << 1) + 1], values[v], mid + 1, to);
            }
        }

        private void push(Value val, Value pVal, int from, int to) {
            if (from > to) return;
            if (pVal.firstX >= 0) {
                long d;
                if (val.firstX >= 0) {
                    d = pVal.diff + Math.abs(pVal.firstX - val.lastX);
                    val.diff = d + val.diff;
                    val.lastX = pVal.lastX;

                    val.res += (to - from + 1) * d;
                    val.vals.clear();
                    val.vals.put(val.lastX, to - from + 1);
                } else {
                    val.lastX = pVal.lastX;
                    val.firstX = pVal.firstX;
                    val.diff = pVal.diff;

                    val.res += (to - from + 1) * pVal.diff;
                    for (Map.Entry<Integer, Integer> e : val.vals.entrySet()) {
                        val.res += Math.abs(e.getKey() - val.firstX) * (long) e.getValue();
                    }
                    val.vals.clear();
                    val.vals.put(val.lastX, to - from + 1);
                }
            }
        }
    }

    private static class Pair<K, V> {
        private K key;
        private V value;

        Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }

        K getKey() {
            return key;
        }

        V getValue() {
            return value;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Pair pair = (Pair) o;

            return !(key != null ? !key.equals(pair.key) : pair.key != null) && !(value != null ? !value.equals(pair.value) : pair.value != null);
        }

        @Override
        public int hashCode() {
            int result = key != null ? key.hashCode() : 0;
            result = 31 * result + (value != null ? value.hashCode() : 0);
            return result;
        }

        @Override
        public String toString() {
            return ""Pair{"" +
                    ""key="" + key +
                    "", value="" + value +
                    '}';
        }
    }

    private static class Timer {
        private long lastTime = 0;

        private Timer() {
            lastTime = System.currentTimeMillis();
        }

        public void reset() {
            lastTime = System.currentTimeMillis();
        }

        public long getMillisAndReset() {
            long current = System.currentTimeMillis();
            long result = current - lastTime;
            lastTime = current;
            return result;
        }
    }

    // IO template {
    private static class FileInputStream extends InputStream {
        private String inputFileName;

        public FileInputStream() throws IOException {
            this(""input.txt"");
        }

        public FileInputStream(String inputFileName) throws IOException {
            this.inputFileName = inputFileName;
        }

        @Override
        protected Reader getReader() throws IOException {
            return new FileReader(inputFileName);
        }
    }

    private static class ConsoleInputStream extends InputStream {
        @Override
        protected Reader getReader() throws IOException {
            return new InputStreamReader(System.in);
        }
    }

    private static abstract class InputStream {
        private static String DELIMITERS = "" \t\n\r\f"";
        private BufferedReader in;

        public InputStream open() throws IOException {
            in = new BufferedReader(getReader());
            return this;
        }

        private class Line {
            private Line(String inputLine) {
                this.inputLine = inputLine;
                stringTokenizer = new StringTokenizer(this.inputLine, DELIMITERS);
                readCharacters = 0;
            }

            private int readCharacters;
            private String inputLine = null;
            private StringTokenizer stringTokenizer = null;

            public String nextToken() {
                String result = stringTokenizer.nextToken();
                readCharacters += result.length();
                return result;
            }

            boolean hasNextToken() {
                return stringTokenizer.hasMoreTokens();
            }

            String getLineRest() {
                int position = 0;
                for (int remain = readCharacters; remain > 0; position++) {
                    if (DELIMITERS.indexOf(inputLine.charAt(position)) < 0) {
                        remain--;
                    }
                }
                return inputLine.substring(position);
            }
        }

        private Line currentLine = null;

        abstract protected Reader getReader() throws IOException;

        /**
         * Note: may be incorrect behavior if use this method with hasNextToken method
         */
        public String nextLine() throws IOException {
            setInputLine();
            if (currentLine == null) {
                return null;
            }
            String result = currentLine.getLineRest();
            currentLine = null;
            return result;
        }

        public boolean hasNextLine() throws IOException {
            setInputLine();
            return currentLine != null;
        }

        public String nextToken() throws IOException {
            return hasNextToken() ? currentLine.nextToken() : null;
        }

        /**
         * Note: may be incorrect behavior if use this method with nextLine method
         */
        public boolean hasNextToken() throws IOException {
            while (true) {
                setInputLine();
                if (currentLine == null || currentLine.hasNextToken()) {
                    break;
                } else {
                    currentLine = null;
                }
            }
            return currentLine != null;
        }

        public int nextInt() throws IOException {
            return Integer.valueOf(this.nextToken());
        }

        public long nextLong() throws IOException {
            return Long.valueOf(this.nextToken());
        }

        public double nextDouble() throws IOException {
            return Double.valueOf(this.nextToken());
        }

        public BigInteger nextBigInteger() throws IOException {
            return new BigInteger(this.nextToken());
        }


        public String[] nextTokensArray(int n) throws IOException {
            String[] result = new String[n];
            for (int i = 0; i < n; i++) {
                result[i] = this.nextToken();
            }
            return result;
        }

        public int[] nextIntArray(int n) throws IOException {
            int[] result = new int[n];
            for (int i = 0; i < n; i++) {
                result[i] = this.nextInt();
            }
            return result;
        }

        public long[] nextLongArray(int n) throws IOException {
            long[] result = new long[n];
            for (int i = 0; i < n; i++) {
                result[i] = this.nextLong();
            }
            return result;
        }

        public BigInteger[] nextBigIntegerArray(int n) throws IOException {
            BigInteger[] result = new BigInteger[n];
            for (int i = 0; i < n; i++) {
                result[i] = this.nextBigInteger();
            }
            return result;
        }

        public void close() throws IOException {
            currentLine = null;
            in.close();
        }

        private void setInputLine() throws IOException {
            if (currentLine == null) {
                String line = in.readLine();
                if (line != null) {
                    currentLine = new Line(line);
                }
            }
        }
    }

    private static class FileOutputStream extends OutputStream {
        private String outputFileName;

        public FileOutputStream() throws IOException {
            this(""output.txt"");
        }

        public FileOutputStream(String outputFileName) throws IOException {
            this.outputFileName = outputFileName;
        }

        @Override
        protected Writer getWriter() throws IOException {
            return new FileWriter(outputFileName);
        }
    }

    private static class ConsoleOutputStream extends OutputStream {
        @Override
        protected Writer getWriter() throws IOException {
            return new OutputStreamWriter(System.out);
        }
    }

    private static abstract class OutputStream {
        private PrintWriter out;

        public OutputStream open() throws IOException {
            out = new PrintWriter(getWriter());
            return this;
        }

        abstract protected Writer getWriter() throws IOException;

        public void print(Object... s) {
            for (Object token : s) {
                out.print(token);
            }
        }

        public void println(Object... s) {
            print(s);
            out.println();
        }

        public void println() {
            out.println();
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.flush();
            out.close();
        }
    }
    // } IO template
}",0528_B,CODEFORCES,2750,Clique Problem,"The clique problem is one of the most well-known NP-complete problems. Under some simplification it can be formulated as follows. Consider an undirected graph G. It is required to find a subset of vertices C of the maximum size such that any two of them are connected by an edge in graph G. Sounds simple, doesn't it? Nobody yet knows an algorithm that finds a solution to this problem in polynomial time of the size of the graph. However, as with many other NP-complete problems, the clique problem is easier if you consider a specific type of a graph.
Consider n distinct points on a line. Let the i-th point have the coordinate xi and weight wi. Let's form graph G, whose vertices are these points and edges connect exactly the pairs of points (i, j), such that the distance between them is not less than the sum of their weights, or more formally: |xi - xj| ≥ wi + wj.
Find the size of the maximum clique in such graph.
The first line contains the integer n (1 ≤ n ≤ 200 000) — the number of points.
Each of the next n lines contains two numbers xi, wi (0 ≤ xi ≤ 109, 1 ≤ wi ≤ 109) — the coordinate and the weight of a point. All xi are different.
Print a single number — the number of vertexes in the maximum clique of the given graph.
","input
If you happen to know how to solve this problem without using the specific properties of the graph formulated in the problem statement, then you are able to get a prize of one million dollars!
output
The picture for the sample test.
","dp, greedy",4
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class Main {
	public static void main(String[] args) throws Exception {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);

		Task task = new Task();
		task.solve(in, out);
		out.close();

	}
	
	static class Rectangle {
		int x1, y1;
		int x2, y2;
	}
	
	static class Task {
		/**
		 * BEFORE SUBMITTING!!!
		 * MAKE SURE IT IS RIGHT!!!!!
		 * LONG!!
		 * Check if m,n aren't misused
		 * Make sure the output format is right (YES/NO vs Yes/No, newlines vs spaces)
		 * Run with n = 1 or n = 0
		 * Make sure two ints aren't multiplied to get a long

		 *
		 */
		public void solve(InputReader in, PrintWriter out) {
			int n = in.nextInt();
			
			//ideas: procurar linha que os divide e procurar dentro desses sub-retangulos
			// procurar até ser 1
			
			//corner cases: se procurar até ser 1 e não verificar se tem 1 do outro lado posso chegar a 1,2...not good
			// tenho que procurar 1,1
			
			int l = 1;
			int r = n;
			
			int ans = 0;
			
			
			while(r >= l) {
				int mid = (r + l) / 2;
				if(ask(in,out,1,1,mid, n) == 0) {
					l = mid + 1;
				} else {
					ans = mid;
					r = mid - 1;
				}
			}
			//par 1,1
			//FDS ISTO
			if(ans < n && ask(in,out,ans + 1, 1,n,n) == 1) {
				Rectangle r1 = find(in,out,1,1,ans,n,n);
				Rectangle r2 = find(in,out,ans + 1,1,n,n,n);
				System.out.printf(""! %d %d %d %d %d %d %d %d\n"", r1.x1, r1.y1, r1.x2, r1.y2, r2.x1, r2.y1, r2.x2, r2.y2);
			} else {
				l = 1;
				r = n;
				
				ans = 0;
				
				
				while(r >= l) {
					int mid = (r + l) / 2;
					if(ask(in,out,1,1,n, mid) == 0) {
						l = mid + 1;
					} else {
						ans = mid;
						r = mid - 1;
					}
				}
				
				Rectangle r1 = find(in,out,1,1,n,ans,n);
				Rectangle r2 = find(in,out,1,ans + 1,n,n,n);
				System.out.printf(""! %d %d %d %d %d %d %d %d\n"", r1.x1, r1.y1, r1.x2, r1.y2, r2.x1, r2.y1, r2.x2, r2.y2);
				
			}
			
			
		}
		//HASDFDSJGHDFJKSGDFJSGJDFSGJDSFGJF
		//FKING WORK
		public Rectangle find(InputReader in, PrintWriter out,int x1, int y1, int x2, int y2, int n) {
			Rectangle rec = new Rectangle();
			
			int ansx1 = x1;
			int ansx2 = x2;
			int ansy1 = y1;
			int ansy2 = y2;

			int l = x1;
			int r = x2;
			

			// quero o minimo v >= x2 
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,y1,mid,y2) == 1) {
					ansx2 = mid;
					r = mid - 1;
				} else {
					l = mid + 1;
				}

			}
									
			//out.printf(""x2 = %d"", ansx2);
			
			

			r = x2;
			l = x1;
			
			// quero o maximo v <= x1
			
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,mid,y1,x2,y2) == 1) {
					ansx1 = mid;
					l = mid + 1;
				} else {
					r = mid - 1;
				}

			}
									
			//out.printf(""x1 = %d"", ansx1);
			
			
			l = y1;
			r = y2;
			
			// quero o minimo v >= y2 
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,y1,x2,mid) == 1) {
					ansy2 = mid;
					r = mid - 1;
				} else {
					l = mid + 1;
				}

			}
									
			//out.printf(""y2 = %d"", ansy2);
			

			
			

			r = y2;
			l = y1;
			

			// quero o maximo v <= y1
			
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,mid,x2,y2) == 1) {
					ansy1 = mid;
					l = mid + 1;
				} else {
					r = mid - 1;
				}

			}
									
			//out.printf(""y1 = %d"", ansy1);
			


			
			rec.x1 = ansx1;
			rec.x2 = ansx2;
			rec.y1 = ansy1;
			rec.y2 = ansy2;

			
			
			return rec;
		}
		
		public int ask(InputReader in, PrintWriter out, int x1, int y1, int x2, int y2) {
			System.out.printf(""? %d %d %d %d\n"",x1,y1,x2,y2);
			System.out.flush();
			return in.nextInt();
		}
	}

	static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader(InputStream stream) {
			reader = new BufferedReader(new InputStreamReader(stream), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}
		
		public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
               
            } catch (IOException e) {
            }
            return null;
        }


	}
}

     		   	 	 			  	  			   			",0713_B,CODEFORCES,1029,Searching Rectangles,"Filya just learned new geometry object — rectangle. He is given a field consisting of n × n unit cells. Rows are numbered from bottom to top with integer from 1 to n. Columns are numbered from left to right with integers from 1 to n. Cell, located at the intersection of the row r and column c is denoted as (r, c). Filya has painted two rectangles, such that their sides are parallel to coordinate axes and each cell lies fully inside or fully outside each of them. Moreover, no cell lies in both rectangles.
Later, hedgehog Filya became interested in the location of his rectangles but was unable to find the sheet of paper they were painted on. They were taken by Sonya and now she wants to play a little game with Filya. He tells her a query rectangle and she replies with the number of initial rectangles that lie fully inside the given query rectangle. The query rectangle should match the same conditions as initial rectangles. Rectangle lies fully inside the query if each o its cells lies inside the query.
Filya knows Sonya really well, so is sure that if he asks more than 200 questions she will stop to reply.
The first line of the input contains an integer n (2 ≤ n ≤ 216) — size of the field.
For each query an integer between 0 and 2 is returned — the number of initial rectangles that lie fully inside the query rectangle.
To make a query you have to print ""? x1 y1 x2 y2"" (without quotes) (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n), where (x1, y1) stands for the position of the bottom left cell of the query and (x2, y2) stands for the up right cell of the query. You are allowed to ask no more than 200 queries. After each query you should perform ""flush"" operation and read the answer.
In case you suppose you've already determined the location of two rectangles (or run out of queries) you should print ""! x11 y11 x12 y12 x21 y21 x22 y22"" (without quotes), where first four integers describe the bottom left and up right cells of the first rectangle, and following four describe the corresponding cells of the second rectangle. You can print the rectangles in an arbitrary order. After you have printed the answer, print the end of the line and perform ""flush"". Your program should terminate immediately after it print the answer.
To flush you can use (just after printing an integer and end-of-line): 
You will get the Wrong Answer verdict if you ask more than 200 queries, or if you print an incorrect coordinates.
You will get the Idleness Limit Exceeded verdict if you don't print anything (but you should) or if you forget about flushing the output (more info below).
Hacking.
The first line should contain an integer n (2 ≤ n ≤ 216).
","input
The second line should contain four integers x1, y1, x2, y2 (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n) — the description of the first rectangle.
output
The third line contains the description of the second rectangle in the similar way.
","binarysearch, constructivealgorithms, interactive",2
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.util.ArrayList;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        final int MOD = (int) (1e9 + 7);
        long[][] C;
        long[] fact;

        public void solve(int testNumber, FastScanner in, PrintWriter out) {
            int n = in.nextInt();
            precalc(n);
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = in.nextInt();
                a[i] = removeSquares(a[i]);
            }
            int[] g = getGroupSizes(a);
            long ans = solve(g);
            for (int x : g) {
                ans = ans * fact[x] % MOD;
            }
            out.println(ans);
        }

        private long solve(int[] a) {
            // For a description, see XXXX
            long[] d = new long[1];
            d[0] = 1;
            int totalPositions = 1;
            for (int x : a) {
                long[] nd = new long[d.length + x + 1];
                for (int s = 0; s < d.length; s++) {
                    if (d[s] == 0) {
                        continue;
                    }
                    for (int m = 1; m <= x; m++) {
                        for (int p = 0; p <= s && p <= m; p++) {
                            long cur = d[s];
                            cur = cur * C[s][p] % MOD;
                            cur = cur * C[totalPositions - s][m - p] % MOD;
                            cur = cur * f(x, m) % MOD;
                            int ns = s + x - m - p;
                            nd[ns] += cur;
                            if (nd[ns] >= MOD) {
                                nd[ns] -= MOD;
                            }
                        }
                    }
                }
                totalPositions += x;
                d = nd;
            }
            return d[0];
        }

        private long f(int n, int k) {
            if (n < k) {
                return 0;
            }
            n -= k;
            return C[n + k - 1][k - 1];
        }

        private void precalc(int n) {
            fact = new long[n + 1];
            fact[0] = 1;
            for (int i = 1; i < fact.length; i++) {
                fact[i] = i * fact[i - 1] % MOD;
            }

            C = new long[1000][1000];
            C[0][0] = 1;
            for (int i = 1; i < C.length; i++) {
                C[i][0] = 1;
                for (int j = 1; j < C.length; j++) {
                    C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
                    if (C[i][j] >= MOD) {
                        C[i][j] -= MOD;
                    }
                }
            }
        }

        private int[] getGroupSizes(int[] a) {
            Arrays.sort(a);
            List<Integer> res = new ArrayList<>();
            for (int i = 0; i < a.length; ) {
                int j = i;
                while (j < a.length && a[i] == a[j]) {
                    ++j;
                }
                res.add(j - i);
                i = j;
            }
            int[] r = new int[res.size()];
            for (int i = 0; i < r.length; i++) {
                r[i] = res.get(i);
            }
            return r;
        }

        private int removeSquares(int n) {
            int res = 1;
            for (int d = 2; d * d <= n; d++) {
                if (n % d == 0) {
                    int cur = 0;
                    while (n % d == 0) {
                        n /= d;
                        ++cur;
                    }
                    if (cur % 2 == 1) {
                        res *= d;
                    }
                }
            }
            if (n > 1) {
                res *= n;
            }
            return res;
        }

    }

    static class FastScanner {
        private BufferedReader in;
        private StringTokenizer st;

        public FastScanner(InputStream stream) {
            in = new BufferedReader(new InputStreamReader(stream));
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",0840_C,CODEFORCES,4001,On the Bench,"A year ago on the bench in public park Leha found an array of n numbers. Leha believes that permutation p is right if for all 1 ≤ i < n condition, that api·api + 1 is not perfect square, holds. Leha wants to find number of right permutations modulo 109 + 7.
First line of input data contains single integer n (1 ≤ n ≤ 300) — length of the array.
Next line contains n integers a1, a2, ... , an (1 ≤ ai ≤ 109) — found array.
Output single integer — number of right permutations modulo 109 + 7.
For first example:
[1, 2, 4] — right permutation, because 2 and 8 are not perfect squares.
[1, 4, 2] — wrong permutation, because 4 is square of 2.
[2, 1, 4] — wrong permutation, because 4 is square of 2.
[2, 4, 1] — wrong permutation, because 4 is square of 2.
","input
[4, 1, 2] — wrong permutation, because 4 is square of 2.
output
[4, 2, 1] — right permutation, because 8 and 2 are not perfect squares.
","combinatorics, dp",6
"import java.security.KeyException;
import java.util.HashMap;
import java.util.Scanner;
import java.util.TreeMap;

public class P15A
{
    public static void main (String [] args)
    {

        Scanner scan = new Scanner(System.in);

        int n = scan.nextInt(), t = scan.nextInt();

        TreeMap<Integer,Integer> hm = new TreeMap<Integer, Integer>();

        for (int i = 0; i < n; i++) hm.put(scan.nextInt(),scan.nextInt());

        int _x = 0, _a = 0, res = 2;

        boolean started = false;

        for (Integer key : hm.keySet())
        {

            if (!started)
            {
                _x = key;
                _a = hm.get(_x);
                started = true;
                continue;
            }

            if (key - _x - ((Integer)hm.get(key) + _a)/2.0 > t) res +=2;
            else if (key - _x - ((Integer)hm.get(key) + _a)/2.0 == t) res++;

            _x = key;
            _a = hm.get(_x);

        }

        System.out.println(res);


    }

}",0015_A,CODEFORCES,2292,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"import java.io.*;
import java.util.*;

public class F {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(reader.readLine());
        long n = Integer.parseInt(st.nextToken());
        long k = Integer.parseInt(st.nextToken());
        long l = 0;
        long r = n;
        while(l <= r){
            long min = (l + r) / 2;
            if((min * (min + 1) / 2 - (n - min) == k)){
                System.out.println(n - min);
                return;
            }
            else if((min * (min + 1) / 2 - (n - min) > k)){
                r = min - 1;
            }
            else{
                l = min + 1;
            }
        }
    }
}",1195_B,CODEFORCES,1410,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import java.util.Scanner;

public class SimpleTask {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int m = scan.nextInt();

		boolean[][] graph = new boolean[n][n];
		for (int i = 0; i < m; i++) {
			int u = scan.nextInt() - 1;
			int v = scan.nextInt() - 1;
			graph[u][v] = true;
			graph[v][u] = true;
		}

		long[][] dp = new long[1 << n][n];

		for (int i = 0; i < n; i++)
			dp[1 << i][i] = 1;

		for (int mask = 1; mask < (1 << n); mask++) {

			int first = Integer.numberOfTrailingZeros(mask);

			for (int i = 0; i < n; i++) {
				if ((mask & (1 << i)) == 0 || first == i)
					continue;

				for (int j = 0; j < n; j++) {
					if (graph[i][j])
						dp[mask][i] += dp[mask ^ 1 << i][j];
				}

			}
		}
		long answer = 0;
		for (int mask = 1; mask < (1 << n); mask++) {
			if (Integer.bitCount(mask) < 3)
				continue;

			int first = Integer.numberOfTrailingZeros(mask);
			for (int i = 0; i < n; i++) {
				if (graph[first][i])
					answer += dp[mask][i];
			}
		}

		System.out.println(answer / 2);
		scan.close();
	}
}
",0011_D,CODEFORCES,4386,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import  java.util.*;

public class Solve{
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		   int n=sc.nextInt();
		   int[] ar=new int[n+1];
		   Pair[] pr=new Pair[n];
		   for(int i=1;i<=n;i++){
		       ar[i]=sc.nextInt();
		       pr[i-1]=new Pair(ar[i],i);
		   }
		   char[]  c=sc.next().toCharArray();
		   int m=2*n;
		   int[] br=new int[m+1];
		   Arrays.sort(pr,new SortPair());
		  
		   for(int i=1;i<=m;i++){
		       int k=Character.getNumericValue(c[i-1]);
		       br[i]=k;
		   }
		   
		 
		   
		    for(int i=1;i<=m;i++){
		       int k=Character.getNumericValue(c[i-1]);
		       br[i]=k;
		   }
		   
		 
		  
		    StringBuilder sb=new StringBuilder();
		   
		      ArrayList<Integer> al=new ArrayList<Integer>(); 
		      int bot=-1;
		    for(int i=1;i<=m;i++){
		       if (br[i] ==0) {
                bot++;
                int index = pr[bot].y ;
                al.add(index);
                sb.append(index+"" "");
            }else{
                int top=al.get(al.size()-1);
                al.remove(al.size()-1);
                sb.append(top+"" "");
            }
		    }
		      
		    
		    
		   
		   System.out.println(sb);
		   
		   
		   
		   
	}
}

class Pair{
    int x, y;
    Pair(int x,int y){
        this.x=x;
        this.y=y;
    }
}

class SortPair implements Comparator<Pair>{
    public int compare(Pair p1,Pair p2){
        return p1.x-p2.x;
    }
}",0982_B,CODEFORCES,2823,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation",4
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Queue;
import java.util.StringTokenizer;

public class CF268_TwoSets {

	public static void main(String[] args) {

		MyScanner in = new MyScanner();

		int N = in.nextInt();
		int a = in.nextInt();
		int b = in.nextInt();

		int[] vals = new int[N];
		HashMap<Integer, Integer> val2Ind = new HashMap<Integer, Integer>();
		for (int i = 0; i < N; i++) {
			vals[i] = in.nextInt();
			val2Ind.put(vals[i], i);
		}

		int[] setAssignment = new int[N];
		int[] friendA = new int[N];
		int[] friendB = new int[N];
		Arrays.fill(setAssignment, -1);
		Arrays.fill(friendA, -1);
		Arrays.fill(friendB, -1);

		// Mark partners
		for (int i = 0; i < N; i++) {
			Integer friendAInd = val2Ind.get(a - vals[i]);
			if (friendAInd != null) {
				friendA[i] = friendAInd;
			}

			Integer friendBInd = val2Ind.get(b - vals[i]);
			if (friendBInd != null) {
				friendB[i] = friendBInd;
			}
		}

		// Find those with only one friend
		Queue<Integer> toProc = new ArrayDeque<Integer>();
		for (int i = 0; i < N; i++) {
			int friends = 0;
			if (friendA[i] != -1) {
				friends++;
			}
			if (friendB[i] != -1) {
				friends++;
			}
			if (friends == 1) {
				toProc.add(i);
			}
		}

		// Process the one frienders
		while (!toProc.isEmpty()) {

			int ind = toProc.poll();

			if (setAssignment[ind] != -1) {
				continue;
			}

			if (friendA[ind] != -1) {

				int other = friendA[ind];
				if (setAssignment[other] == -1) {
					setAssignment[ind] = 0;
					setAssignment[other] = 0;
					// Check other's friend
					if (friendB[other] != -1) {
						int otherOther = friendB[other];
						friendB[otherOther] = -1;
						toProc.add(otherOther);
					}
				} else {
					System.out.println(""NO"");
					return;
				}

			}

			else if (friendB[ind] != -1) {

				int other = friendB[ind];
				if (setAssignment[other] == -1) {
					setAssignment[ind] = 1;
					setAssignment[other] = 1;
					// Check other's friend
					if (friendA[other] != -1) {
						int otherOther = friendA[other];
						friendA[otherOther] = -1;
						toProc.add(otherOther);
					}
				} else {
					System.out.println(""NO"");
					return;
				}

			}

			else {
				System.out.println(""NO"");
				return;
			}

		}
		
		
		// Process those with two friends
		for(int i = 0; i < N; i++) {
			
			if(setAssignment[i] != -1) {
				continue;
			}
			
			if(friendA[i] == -1 && friendB[i] == -1) {
				System.out.println(""NO"");
				return;
			}
			
			// Only possibility should now be that both friends are possible
			setAssignment[i] = 0;
			setAssignment[friendA[i]] = 0;
		}
		
		// Print the result
		System.out.println(""YES"");
		StringBuilder sb = new StringBuilder();
		for(int i = 0; i < N; i++) {
			sb.append(setAssignment[i]);
			sb.append("" "");
		}
		sb.deleteCharAt(sb.length() - 1);
		System.out.println(sb);
	}

	public static class MyScanner {
		BufferedReader br;
		StringTokenizer st;

		public MyScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}

	}

}
",0468_B,CODEFORCES,1717,Two Sets,"Little X has n distinct integers: p1, p2, ..., pn. He wants to divide all of them into two sets A and B. The following two conditions must be satisfied:
Help Little X divide the numbers into two sets or determine that it's impossible.
The first line contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The next line contains n space-separated distinct integers p1, p2, ..., pn (1 ≤ pi ≤ 109).
If there is a way to divide the numbers into two sets, then print ""YES"" in the first line. Then print n integers: b1, b2, ..., bn (bi equals either 0, or 1), describing the division. If bi equals to 0, then pi belongs to set A, otherwise it belongs to set B.
","input
If it's impossible, print ""NO"" (without the quotes).
output
It's OK if all the numbers are in the same set, and the other one is empty.
","2-sat, dfsandsimilar, dsu, graphmatchings, greedy",3
"import static java.lang.Math.max;
import static java.lang.Math.min;

import java.io.*;
import java.util.*;

public class B {

	private void solve() throws IOException {
		int senators = nextInt();
		int candies = nextInt();
		scoreA = nextInt();
		lvl = new int[senators];
		unloyal = new int[senators];
		for (int i = 0; i < senators; i++) {
			lvl[i] = nextInt();
			unloyal[i] = 10 - nextInt() / 10;
		}
		n = senators;
		give = new int[n];
		res = 0;
		go(0, candies);
		out.println(res);
	}

	static double res;
	static int[] lvl;
	static int[] unloyal;
	static int[] give;
	static int n;
	static int scoreA;

	static double probability() {
		double res = 0;
		for (int mask = 0; mask < 1 << n; mask++) {
			double p = 1;
			int scoreB = 0;
			int cntGood = Integer.bitCount(mask);
			for (int i = 0; i < n; i++) {
				int cnt = unloyal[i] - give[i];
				if ((mask & (1 << i)) == 0) {
					scoreB += lvl[i];
					p *= cnt * .1;
				} else {
					p *= (10 - cnt) * .1;
				}
			}
			if (2 * cntGood > n) {
				res += p;
			} else {
				res += p * scoreA / (scoreA + scoreB);
			}
		}
		return res;
	}

	static void go(int man, int candies) {
		if (man == n) {
			res = max(res, probability());
			return;
		}
		give[man] = 0;
		go(man + 1, candies);
		for (int i = 1; i <= min(unloyal[man], candies); i++) {
			give[man] = i;
			go(man + 1, candies - i);
		}
	}

	public static void main(String[] args) {
		try {
			br = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			new B().solve();
			out.close();
		} catch (Throwable e) {
			e.printStackTrace();
			System.exit(239);
		}
	}

	static BufferedReader br;
	static StringTokenizer st;
	static PrintWriter out;

	static String nextToken() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			String line = br.readLine();
			if (line == null) {
				return null;
			}
			st = new StringTokenizer(line);
		}
		return st.nextToken();
	}

	static int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	static long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	static double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}",0105_B,CODEFORCES,4548,Dark Assembly,"Dark Assembly is a governing body in the Netherworld. Here sit the senators who take the most important decisions for the player. For example, to expand the range of the shop or to improve certain characteristics of the character the Dark Assembly's approval is needed.
The Dark Assembly consists of n senators. Each of them is characterized by his level and loyalty to the player. The level is a positive integer which reflects a senator's strength. Loyalty is the probability of a positive decision in the voting, which is measured as a percentage with precision of up to 10%. 
Senators make decisions by voting. Each of them makes a positive or negative decision in accordance with their loyalty. If strictly more than half of the senators take a positive decision, the player's proposal is approved. 
If the player's proposal is not approved after the voting, then the player may appeal against the decision of the Dark Assembly. To do that, player needs to kill all the senators that voted against (there's nothing wrong in killing senators, they will resurrect later and will treat the player even worse). The probability that a player will be able to kill a certain group of senators is equal to A / (A + B), where A is the sum of levels of all player's characters and B is the sum of levels of all senators in this group. If the player kills all undesired senators, then his proposal is approved.
Senators are very fond of sweets. They can be bribed by giving them candies. For each received candy a senator increases his loyalty to the player by 10%. It's worth to mention that loyalty cannot exceed 100%. The player can take no more than k sweets to the courtroom. Candies should be given to the senators before the start of voting.
Determine the probability that the Dark Assembly approves the player's proposal if the candies are distributed among the senators in the optimal way.
The first line contains three integers n, k and A (1 ≤ n, k ≤ 8, 1 ≤ A ≤ 9999).
Then n lines follow. The i-th of them contains two numbers — bi and li — the i-th senator's level and his loyalty.
The levels of all senators are integers in range from 1 to 9999 (inclusive). The loyalties of all senators are integers in range from 0 to 100 (inclusive) and all of them are divisible by 10.
Print one real number with precision 10 - 6 — the maximal possible probability that the Dark Assembly approves the player's proposal for the best possible distribution of candies among the senators.
","input
In the first sample the best way of candies' distribution is giving them to first three of the senators. It ensures most of votes.
output
It the second sample player should give all three candies to the fifth senator.
","bruteforce, probabilities",7
"import java.io.*;
import java.util.*;

public class b {
	public static void main(String[] args) throws Exception {
		
		BufferedReader f = new BufferedReader(new InputStreamReader(System.in));	
		PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
		StringTokenizer st = new StringTokenizer(f.readLine());

		int T = Integer.parseInt(st.nextToken());
		
		for (int t = 0; t < T; t++) {
			st = new StringTokenizer(f.readLine());
			int n = Integer.parseInt(st.nextToken());
			int sqrt = (int)Math.sqrt(n);
			int sqrt2 = (int)Math.sqrt(n/2);
			if (sqrt*sqrt == n && sqrt%2 == 0) {
				out.println(""YES"");
			} else if (2*sqrt2*sqrt2 == n) {
				out.println(""YES"");
			} else {
				out.println(""NO"");
			}
		}
		
		out.close();
	}
}
",1515_B,CODEFORCES,2205,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",3
"import java.io.*;
import java.util.*;

public class A implements Runnable {
	public static void main(String[] args) {
		new A().run();
	}

	class FastScanner {
		BufferedReader br;
		StringTokenizer st;
		boolean eof;
		String buf;

		public FastScanner(String fileName) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(fileName));
			nextToken();
		}

		public FastScanner(InputStream stream) {
			br = new BufferedReader(new InputStreamReader(stream));
			nextToken();
		}

		String nextToken() {
			while (st == null || !st.hasMoreTokens()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (Exception e) {
					eof = true;
					break;
				}
			}
			String ret = buf;
			buf = eof ? ""-1"" : st.nextToken();
			return ret;
		}

		int nextInt() {
			return Integer.parseInt(nextToken());
		}

		long nextLong() {
			return Long.parseLong(nextToken());
		}

		double nextDouble() {
			return Double.parseDouble(nextToken());
		}

		void close() {
			try {
				br.close();
			} catch (Exception e) {

			}
		}

		boolean isEOF() {
			return eof;
		}
	}

	FastScanner sc;
	PrintWriter out;

	public void run() {
		Locale.setDefault(Locale.US);
		try {
			sc = new FastScanner(System.in);
			out = new PrintWriter(System.out);
			solve();
			sc.close();
			out.close();
		} catch (Throwable e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	int nextInt() {
		return sc.nextInt();
	}

	String nextToken() {
		return sc.nextToken();
	}

	long nextLong() {
		return sc.nextLong();
	}

	double nextDouble() {
		return sc.nextDouble();
	}

	class House {
		int x, t;

		public House(int x, int t) {
			this.x = x;
			this.t = t;
		}

	}

	void solve() {
		int n = nextInt();
		int t = nextInt();
		House[] h = new House[n];
		for (int i = 0; i < n; i++) {
			h[i] = new House(nextInt(), nextInt());
		}
		Arrays.sort(h, new Comparator<House>() {
			@Override
			public int compare(House o1, House o2) {
				return o1.x < o2.x ? -1 : o1.x > o2.x ? 1 : 0;
			}
		});
		int ans = 0;
		for (int i = 0; i < n; i++) {
			if (i == 0
					|| (h[i].x - h[i - 1].x) * 2 - h[i].t - h[i - 1].t >= 2 * t) {
				++ans;
			}
			if (i == n - 1
					|| (h[i + 1].x - h[i].x) * 2 - h[i + 1].t - h[i].t > 2 * t) {
				++ans;
			}
		}
		out.println(ans);
	}
}",0015_A,CODEFORCES,2323,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"import java.util.*;

public class A {

    int n;
    int[] arr;
    
    void run(){
        Scanner s = new Scanner(System.in);
        n = s.nextInt();
        arr = new int[n];
        int even, odd;
        even = 0;
        odd = 0;
        for (int i = 0; i < n; i++) {
            arr[i] = s.nextInt();
            if(arr[i]%2==0)even++;
            else odd++;
        }
        if(even>odd){
        
            
            for (int i = 0; i < n; i++) {
                if(arr[i]%2==1){
                    System.out.println(i+1);
                    System.exit(0);
                }
            }
        }
        
        else{

            for (int i = 0; i < n; i++) {
                if(arr[i]%2==0){
                    System.out.println(i+1);
                    System.exit(0);
                }
            }

        }
        
        
    }
    public static void main(String[] args) {
        new A().run();
    }
}
",0025_A,CODEFORCES,1556,IQ test,"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given n numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given n numbers finds one that is different in evenness.
","input
The first line contains integer n (3 ≤ n ≤ 100) — amount of numbers in the task. The second line contains n space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.
output
Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.
",bruteforce,3
"import java.io.*;
import java.util.*;
public class Main{
    public static void main(String args[]){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        int x,y;
        boolean graph[][]=new boolean[n][n];
        for(int i=0;i<m;i++){
            x=sc.nextInt()-1;
            y=sc.nextInt()-1;
            graph[x][y]=graph[y][x]=true;
        }
        long dp[][]=new long[1<<n][n];
        long res=0;
        for(int i=0;i<n;i++){
            dp[1<<i][i]=1;
        }
        for(int mask=1;mask<(1<<n);mask++){
            int first=-1;
            for(int f=0;f<n;f++){
                if((mask&(1<<f))!=0){
                    first=f;
                    break;
                }
            }
            for(int i=0;i<n;i++){
                if((mask&(1<<i))!=0&&i!=first){
                    for(int j=0;j<n;j++){
                        if(graph[j][i]&&((mask&1<<j)!=0)){
                            dp[mask][i]+=dp[mask^1<<i][j];
                        }
                    }
                }
                if(Integer.bitCount(mask)>2&&graph[first][i]){
                    res+=dp[mask][i];
                }
            }
        }
        
        System.out.println(res/2);
    }
    
}",0011_D,CODEFORCES,4389,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import java.util.*;

import java.io.*;

import java.lang.Math.*;



public class Main{

	static long s;

	static boolean check(long n){

		int sum = 0;

		long storen=n;

		while(n>0){

			int k = (int)(n%10);

			n /=10;

			sum+=k;

		}

		return storen-(long)sum >= s;

	}

	public static void main(String args[]){

		PrintWriter pw=new PrintWriter(System.out);

		InputReader ip=new InputReader(System.in);

		

		long n;

		n=ip.nextLong();

		s=ip.nextLong();



		if(s>n){

			pw.println(""0"");

		}

		else{

			long l=0,r=n;

			boolean possible=false;

			long mid=0;

			int it=100;

			while(it-->0){

				mid = (l+r)/2;

				if(check(mid)){

					r=mid;

					possible = true;

				}

				else{

					l=mid+1;

				}

		//		pw.println(mid);

		//		pw.println(l+"" ""+r);

			}

			if(possible){

				pw.println(n-l+1);

			}	

			else{

				pw.println(""0"");

			}

		}

		

		pw.close();

	}

	static class InputReader {

        private InputStream stream;

        private byte[] buf = new byte[1024];

        private int curChar;

        private int numChars;

        private SpaceCharFilter filter;



        public InputReader(InputStream stream) {

            this.stream = stream;

        }



        public int read() {

            if (numChars == -1)

                throw new InputMismatchException();



            if (curChar >= numChars) {

                curChar = 0;

                try {

                    numChars = stream.read(buf);

                } catch (IOException e) {

                    throw new InputMismatchException();

                }



                if (numChars <= 0)

                    return -1;

            }

            return buf[curChar++];

        }



        public String nextLine() {

            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

            String str = """";

            try {

                str = br.readLine();

            } catch (IOException e) {

                e.printStackTrace();

            }

            return str;

        }



        public int nextInt() {

            int c = read();



            while (isSpaceChar(c))

                c = read();



            int sgn = 1;



            if (c == '-') {

                sgn = -1;

                c = read();

            }



            int res = 0;

            do {

                if (c < '0' || c > '9')

                    throw new InputMismatchException();

                res *= 10;

                res += c - '0';

                c = read();

            }

            while (!isSpaceChar(c));



            return res * sgn;

        }



        public long nextLong() {

            int c = read();

            while (isSpaceChar(c))

                c = read();

            int sgn = 1;

            if (c == '-') {

                sgn = -1;

                c = read();

            }

            long res = 0;



            do {

                if (c < '0' || c > '9')

                    throw new InputMismatchException();

                res *= 10;

                res += c - '0';

                c = read();

            }

            while (!isSpaceChar(c));

            return res * sgn;

        }



        public double nextDouble() {

            int c = read();

            while (isSpaceChar(c))

                c = read();

            int sgn = 1;

            if (c == '-') {

                sgn = -1;

                c = read();

            }

            double res = 0;

            while (!isSpaceChar(c) && c != '.') {

                if (c == 'e' || c == 'E')

                    return res * Math.pow(10, nextInt());

                if (c < '0' || c > '9')

                    throw new InputMismatchException();

                res *= 10;

                res += c - '0';

                c = read();

            }

            if (c == '.') {

                c = read();

                double m = 1;

                while (!isSpaceChar(c)) {

                    if (c == 'e' || c == 'E')

                        return res * Math.pow(10, nextInt());

                    if (c < '0' || c > '9')

                        throw new InputMismatchException();

                    m /= 10;

                    res += (c - '0') * m;

                    c = read();

                }

            }

            return res * sgn;

        }



        public String readString() {

            int c = read();

            while (isSpaceChar(c))

                c = read();

            StringBuilder res = new StringBuilder();

            do {

                res.appendCodePoint(c);

                c = read();

            }

            while (!isSpaceChar(c));



            return res.toString();

        }



        public boolean isSpaceChar(int c) {

            if (filter != null)

                return filter.isSpaceChar(c);

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;

        }



        public String next() {

            return readString();

        }



        public interface SpaceCharFilter {

            public boolean isSpaceChar(int ch);

        }

    }

}",0817_C,CODEFORCES,1070,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"//package codeforces;
import java.io.PrintWriter;
import java.util.*;
public class codeforces {
	public static void main(String[] args) {
		PrintWriter out=new PrintWriter(System.out);
    	Scanner s=new Scanner(System.in);  
    	int t=s.nextInt();
    	for(int tt=0;tt<t;tt++) {
    		long n=s.nextInt();
    		long x=(long)Math.sqrt(n/2);
    		long y=(long)Math.sqrt(n/4);
    		if(x*x*2==n || y*y*4==n) {
    			out.println(""YES"");
    		}else {
    			out.println(""NO"");
    		}
    	}
    	out.close();
	    s.close();
	}
	
	static void sort(int[] a) {
		ArrayList<Integer> l=new ArrayList<>();
		for (int i:a) l.add(i);
		Collections.sort(l);
		for (int i=0; i<a.length; i++) a[i]=l.get(i);
	}
	
}
 

",1515_B,CODEFORCES,2221,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",3
"import java.io.*;

import java.awt.geom.Point2D;
import java.text.*;
import java.math.*;
import java.util.*;

public class Main implements Runnable {

	final String filename = """";

	public int nextPerm(int[] a, int k) {
		if (a[0] == k)
			return -1;
		int last = 0;
		for (int i = a.length - 1; i >= 0; i--)
			if (a[i] != 0) {
				last = i;
				break;
			}
		int mem=a[last];
		a[last-1]++;
		a[last]=0;
		a[a.length-1]=mem-1;
		return 0;
	}
	
	public double poss(int A,int[][] sen,int[] rasp){
		int n=sen.length;
		double[] possluck=new double[n];
		for(int i=0;i<n;i++)
			possluck[i]=Math.min(100, sen[i][1]+rasp[i]*10)/100.0;
		double poss=0;
		for(int i=0;i<(1<<n);i++){
			int kol=0;
			for(int j=0;j<n;j++)
				if((i%(1<<(j+1)))/(1<<(j))==1)
					kol++;
			double thisposs=1;
			for(int j=0;j<n;j++)
				if((i%(1<<(j+1)))/(1<<(j))==1)
					thisposs*=possluck[j];
				else
					thisposs*=(1-possluck[j]);
			if(kol>n/2)
				poss+=thisposs;
			else{
				double lvl=0;
				for(int j=0;j<n;j++)
					if((i%(1<<(j+1)))/(1<<(j))==0)
						lvl+=sen[j][0];
				poss+=thisposs*(A/(A+lvl));
			}
		}
		return poss;
	}

	public void solve() throws Exception {
		int n = iread(), k = iread(), A = iread();
		int[][] sen = new int[n][2];
		for (int i = 0; i < n; i++) {
			sen[i][0] = iread();
			sen[i][1] = iread();
		}
		double maxposs=0;
		int[] rasp=new int[n];
		rasp[n-1]=k;
		maxposs=Math.max(maxposs, poss(A,sen,rasp));
		while(nextPerm(rasp,k)==0)
			maxposs=Math.max(maxposs, poss(A,sen,rasp));
		out.write(maxposs+""\n"");
	}

	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new BufferedWriter(new OutputStreamWriter(System.out));
			// in = new BufferedReader(new FileReader(filename+"".in""));
			// out = new BufferedWriter(new FileWriter(filename+"".out""));
			solve();
			out.flush();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	public int iread() throws Exception {
		return Integer.parseInt(readword());
	}

	public double dread() throws Exception {
		return Double.parseDouble(readword());
	}

	public long lread() throws Exception {
		return Long.parseLong(readword());
	}

	BufferedReader in;

	BufferedWriter out;

	public String readword() throws IOException {
		StringBuilder b = new StringBuilder();
		int c;
		c = in.read();
		while (c >= 0 && c <= ' ')
			c = in.read();
		if (c < 0)
			return """";
		while (c > ' ') {
			b.append((char) c);
			c = in.read();
		}
		return b.toString();
	}

	public static void main(String[] args) {
		try {
			Locale.setDefault(Locale.US);
		} catch (Exception e) {

		}
		// new Thread(new Main()).start();
		new Thread(null, new Main(), ""1"", 1 << 25).start();
	}
}",0105_B,CODEFORCES,4559,Dark Assembly,"Dark Assembly is a governing body in the Netherworld. Here sit the senators who take the most important decisions for the player. For example, to expand the range of the shop or to improve certain characteristics of the character the Dark Assembly's approval is needed.
The Dark Assembly consists of n senators. Each of them is characterized by his level and loyalty to the player. The level is a positive integer which reflects a senator's strength. Loyalty is the probability of a positive decision in the voting, which is measured as a percentage with precision of up to 10%. 
Senators make decisions by voting. Each of them makes a positive or negative decision in accordance with their loyalty. If strictly more than half of the senators take a positive decision, the player's proposal is approved. 
If the player's proposal is not approved after the voting, then the player may appeal against the decision of the Dark Assembly. To do that, player needs to kill all the senators that voted against (there's nothing wrong in killing senators, they will resurrect later and will treat the player even worse). The probability that a player will be able to kill a certain group of senators is equal to A / (A + B), where A is the sum of levels of all player's characters and B is the sum of levels of all senators in this group. If the player kills all undesired senators, then his proposal is approved.
Senators are very fond of sweets. They can be bribed by giving them candies. For each received candy a senator increases his loyalty to the player by 10%. It's worth to mention that loyalty cannot exceed 100%. The player can take no more than k sweets to the courtroom. Candies should be given to the senators before the start of voting.
Determine the probability that the Dark Assembly approves the player's proposal if the candies are distributed among the senators in the optimal way.
The first line contains three integers n, k and A (1 ≤ n, k ≤ 8, 1 ≤ A ≤ 9999).
Then n lines follow. The i-th of them contains two numbers — bi and li — the i-th senator's level and his loyalty.
The levels of all senators are integers in range from 1 to 9999 (inclusive). The loyalties of all senators are integers in range from 0 to 100 (inclusive) and all of them are divisible by 10.
Print one real number with precision 10 - 6 — the maximal possible probability that the Dark Assembly approves the player's proposal for the best possible distribution of candies among the senators.
","input
In the first sample the best way of candies' distribution is giving them to first three of the senators. It ensures most of votes.
output
It the second sample player should give all three candies to the fifth senator.
","bruteforce, probabilities",7
"import java.util.*;
import java.io.*;
import java.text.*;
//Solution Credits: Taranpreet Singh
public class Main{
    //SOLUTION BEGIN
    //Code not meant for understanding, proceed with caution
    void pre() throws Exception{}
    void solve(int TC) throws Exception{
        int n = ni();
        int[] a = new int[n];
        for(int i = 0; i< n; i++)a[i] = ni();
        HashMap<Long, ArrayList<int[]>> map = new HashMap<>();
        for(int i = 0; i< n; i++){
            long sum = 0;
            for(int j = i; j< n; j++){
                sum+=a[j];
                if(!map.containsKey(sum))map.put(sum, new ArrayList<>());
                map.get(sum).add(new int[]{i+1, j+1});
            }
        }
        int[][] ans = new int[n][];int cur = 0;
        int[][] tmp = new int[n][];int tc;
        for(Map.Entry<Long, ArrayList<int[]>> e: map.entrySet()){
            int prev = 0;
            ArrayList<int[]> li = e.getValue();
            Collections.sort(li, new Comparator<int[]>(){
                public int compare(int[] i1, int[] i2){
                    if(i1[1]!=i2[1])return Integer.compare(i1[1], i2[1]);
                    return Integer.compare(i1[0], i1[0]);
                }
            });
                tc = 0;
            for(int[] p:li){
                if(p[0]>prev){
                    tmp[tc++] = new int[]{p[0],p[1]};
                    prev = p[1];
                }
            }
            if(tc>cur){
                cur = tc;
                for(int i = 0; i< tc; i++)ans[i] = new int[]{tmp[i][0], tmp[i][1]};
            }
        }
        pn(cur);
        for(int i = 0; i< cur; i++)pn(ans[i][0]+"" ""+ans[i][1]);
    }
    //SOLUTION END
    void hold(boolean b)throws Exception{if(!b)throw new Exception(""Hold right there, Sparky!"");}
    long mod = (long)1e9+7, IINF = (long)1e18;
    final int INF = (int)1e9, MX = (int)2e3+1;
    DecimalFormat df = new DecimalFormat(""0.00000000000"");
    double PI = 3.1415926535897932384626433832792884197169399375105820974944, eps = 1e-8;
    static boolean multipleTC = false, memory = false;
    FastReader in;PrintWriter out;
    void run() throws Exception{
        in = new FastReader();
        out = new PrintWriter(System.out);
        int T = (multipleTC)?ni():1;
        //Solution Credits: Taranpreet Singh
        pre();for(int t = 1; t<= T; t++)solve(t);
        out.flush();
        out.close();
    }
    public static void main(String[] args) throws Exception{
        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, ""1"", 1 << 28).start();
        else new Main().run();
    }
    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}
    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}
    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}
    void p(Object o){out.print(o);}
    void pn(Object o){out.println(o);}
    void pni(Object o){out.println(o);out.flush();}
    String n()throws Exception{return in.next();}
    String nln()throws Exception{return in.nextLine();}
    int ni()throws Exception{return Integer.parseInt(in.next());}
    long nl()throws Exception{return Long.parseLong(in.next());}
    double nd()throws Exception{return Double.parseDouble(in.next());}

    class FastReader{
        BufferedReader br;
        StringTokenizer st;
        public FastReader(){
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        public FastReader(String s) throws Exception{
            br = new BufferedReader(new FileReader(s));
        }

        String next() throws Exception{
            while (st == null || !st.hasMoreElements()){
                try{
                    st = new StringTokenizer(br.readLine());
                }catch (IOException  e){
                    throw new Exception(e.toString());
                }
            }
            return st.nextToken();
        }

        String nextLine() throws Exception{
            String str = """";
            try{   
                str = br.readLine();
            }catch (IOException e){
                throw new Exception(e.toString());
            }  
            return str;
        }
    }
}",1141_F2,CODEFORCES,3345,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"//package round156;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class B {
	InputStream is;
	PrintWriter out;
	String INPUT = """";
	
	void solve()
	{
		int n = ni(), x = ni(), y = ni();
		long c = nl();
		int l = x-1, r = n-x;
		int u = y-1, d = n-y;
		long low = -1, high = 2*n+3;
		while(high - low > 1){
			long t = (high + low) / 2;
			long num = diag(t, l, u) + diag(t, r, u) + diag(t, l, d) + diag(t, r, d)
					+ hor(t, l) + hor(t, r) + hor(t, u) + hor(t, d) + 1;
			if(num >= c){
				high = t;
			}else{
				low = t;
			}
		}
		out.println(high);
	}
	
	long hor(long t, int n)
	{
		return Math.min(t, n);
	}
	
	long diag(long t, long r, long u)
	{
		if(t > 2+r+u-2){
			return r*u;
		}
		
		long ret = t*(t-1)/2;
		if(t > r)ret -= (t-r)*(t-r-1)/2;
		if(t > u)ret -= (t-u)*(t-u-1)/2;
		return ret;
	}
	
	void run() throws Exception
	{
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception { new B().run(); }
	
	private byte[] inbuf = new byte[1024];
	private int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",0256_B,CODEFORCES,775,Mr,"Mr. Bender has a digital table of size n × n, each cell can be switched on or off. He wants the field to have at least c switched on squares. When this condition is fulfilled, Mr Bender will be happy.
We'll consider the table rows numbered from top to bottom from 1 to n, and the columns — numbered from left to right from 1 to n. Initially there is exactly one switched on cell with coordinates (x, y) (x is the row number, y is the column number), and all other cells are switched off. Then each second we switch on the cells that are off but have the side-adjacent cells that are on.
For a cell with coordinates (x, y) the side-adjacent cells are cells with coordinates (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1).
In how many seconds will Mr. Bender get happy?
The first line contains four space-separated integers n, x, y, c (1 ≤ n, c ≤ 109; 1 ≤ x, y ≤ n; c ≤ n2).
","input
In a single line print a single integer — the answer to the problem.
output
Initially the first test has one painted cell, so the answer is 0. In the second test all events will go as is shown on the figure. .
","binarysearch, bruteforce, math",2
"import java.io.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Task483A {

    public static void main(String... args) throws NumberFormatException,
            IOException {
        Solution.main(System.in, System.out);
    }

    static class Scanner {

        private final BufferedReader br;
        private String[] cache;
        private int cacheIndex;

        Scanner(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
            cache = new String[0];
            cacheIndex = 0;
        }

        int nextInt() throws IOException {
            if (cacheIndex >= cache.length) {
                cache = br.readLine().split("" "");
                cacheIndex = 0;
            }
            return Integer.parseInt(cache[cacheIndex++]);
        }

        long nextLong() throws IOException {
            if (cacheIndex >= cache.length) {
                cache = br.readLine().split("" "");
                cacheIndex = 0;
            }
            return Long.parseLong(cache[cacheIndex++]);
        }

        String next() throws IOException {
            if (cacheIndex >= cache.length) {
                cache = br.readLine().split("" "");
                cacheIndex = 0;
            }
            return cache[cacheIndex++];
        }

        void close() throws IOException {
            br.close();
        }

    }


    static class Solution {


        public static void main(InputStream is, OutputStream os)
                throws NumberFormatException, IOException {
            PrintWriter pw = new PrintWriter(os);
            Scanner sc = new Scanner(is);

            long l = sc.nextLong();
            long r = sc.nextLong();

            long interval = r-l;

            if(interval == 0 || interval == 1 || (interval == 2 && l % 2 ==1 )){
                pw.println(-1);
            } else {
                if(l % 2 == 1){
                    l++;
                }
                pw.print(l);
                pw.print("" "");
                pw.print(l+1);
                pw.print("" "");
                pw.print(l+2);
            }



            pw.flush();
            sc.close();
        }
    }

}",0483_A,CODEFORCES,474,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"import java.util.Scanner;


public class CF125D2A {

    /**
     * @param args
     */
    public static void main(String[] args) {
        Scanner sc = new Scanner (System.in);
        System.out.println(""0 0 ""+ sc.nextInt());

    }

}
",0199_A,CODEFORCES,159,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"/*
    ######  ######    #####  ######  ######  #####
    #    #  #    #      #    #    #  #    #    #
    #    #  # #  #      #    # ## #  # ## #    #
    #    #  #  #    #   #    #    #  #    #    #
    ######  #   #   # # #    #    #  #    #    #
*/
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
import java.io.*;
import java.math.*;
import java.util.StringTokenizer;
public class contest1 {
    static PrintStream p = System.out;
    public static void main(String args[] ) throws Exception {
        int a =ni();
        int b =ni();
        int c =ni();
        int n =ni();
        int val = (a+b-c);
        if(a<c || b<c){
            p.println(""-1"");
        }
        else p.println((val >= n || val <0)?""-1"": n-val);
        

    }

//-------------------------------------------------fast Method---------------------------------------------------------------\\
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));;
    static StringTokenizer st;
    private static int[] inta(int n){
        int [] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
            return a;
    }
    private static long[] longa(long n){
    long[] a = new long[(int)n];
        for(int i = 0;i < n;i++)a[i] = nl();
            return a;
    }
    private static void pla(long[] a){
        for(int i = 0;i <a.length;i++)
            p.print(a[i]+"" "");
    }
    private static void pia(int[] a){
        for(int i = 0;i <a.length;i++)
            p.print(a[i]+"" "");
    }
    private static String n(){
        while (st == null || !st.hasMoreElements()){
            try{
                st = new StringTokenizer(br.readLine());
            }
            catch (IOException  e){
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }
    private static int ni(){
        return Integer.parseInt(n());
    }

    private static long nl(){
        return Long.parseLong(n());
    }

    private static double nd(){
        return Double.parseDouble(n());
    }
    private static String nli(){
        String str = """";
        try{
            str = br.readLine();
        }
        catch (IOException e){
            e.printStackTrace();
        }
        return str;
    }
//-------------------------------------------------fast Method---------------------------------------------------------------\\
} ",0991_A,CODEFORCES,647,If at first you don't succeed,"Each student eagerly awaits the day he would pass the exams successfully. Thus, Vasya was ready to celebrate, but, alas, he didn't pass it. However, many of Vasya's fellow students from the same group were more successful and celebrated after the exam.
Some of them celebrated in the BugDonalds restaurant, some of them — in the BeaverKing restaurant, the most successful ones were fast enough to celebrate in both of restaurants. Students which didn't pass the exam didn't celebrate in any of those restaurants and elected to stay home to prepare for their reexamination. However, this quickly bored Vasya and he started checking celebration photos on the Kilogramm. He found out that, in total, BugDonalds was visited by $$$A$$$ students, BeaverKing — by $$$B$$$ students and $$$C$$$ students visited both restaurants. Vasya also knows that there are $$$N$$$ students in his group.
Based on this info, Vasya wants to determine either if his data contradicts itself or, if it doesn't, how many students in his group didn't pass the exam. Can you help him so he won't waste his valuable preparation time?
The first line contains four integers — $$$A$$$, $$$B$$$, $$$C$$$ and $$$N$$$ ($$$0 \leq A, B, C, N \leq 100$$$).
If a distribution of $$$N$$$ students exists in which $$$A$$$ students visited BugDonalds, $$$B$$$ — BeaverKing, $$$C$$$ — both of the restaurants and at least one student is left home (it is known that Vasya didn't pass the exam and stayed at home), output one integer — amount of students (including Vasya) who did not pass the exam. 
If such a distribution does not exist and Vasya made a mistake while determining the numbers $$$A$$$, $$$B$$$, $$$C$$$ or $$$N$$$ (as in samples 2 and 3), output $$$-1$$$.
The first sample describes following situation: $$$5$$$ only visited BugDonalds, $$$5$$$ students only visited BeaverKing, $$$5$$$ visited both of them and $$$5$$$ students (including Vasya) didn't pass the exam.
","input
In the second sample $$$2$$$ students only visited BugDonalds and $$$2$$$ only visited BeaverKing, but that means all $$$4$$$ students in group passed the exam which contradicts the fact that Vasya didn't pass meaning that this situation is impossible.
output
The third sample describes a situation where $$$2$$$ students visited BugDonalds but the group has only $$$1$$$ which makes it clearly impossible.
",implementation,1
"import java.io.IOException;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class ProblemE {
    public static int w, h;
    
    public static int MAX = 9999999;
    
    public static Set<Integer> result = new HashSet<Integer>();
    
    public static void dfs(int n, int m, int mask) {
        if (n >= w) {
            result.add(mask);
            return;
        }
        if (m >= 1) {
            dfs(n+1, m, mask|(1<<n));
        }
        if (m <= h - 2) {
            dfs(n+1, m, mask|(1<<(n+w*2)));
        }
        if (n >= 1) {
            dfs(n+1, m, mask|(1<<((n-1)+w)));
        }
        if (n <= w - 2) {
            dfs(n+1, m, mask|(1<<((n+1)+w)));
        }
        dfs(n+1, m, mask|(1<<(n+w)));
    }
    
    public static void main(String[] args) throws IOException {
        Scanner s = new Scanner(System.in);
        String[] line = s.nextLine().split("" "");
        w = Integer.valueOf(line[0]);
        h = Integer.valueOf(line[1]);
        if (w == 6 && h == 6) {
            System.out.println(26);
            return;
        }
        if (w == 5 && h == 8) {
            System.out.println(29);
            return;
        }
        if (w == 5 && h == 7) {
            System.out.println(26);
            return;
        }
        if (w == 5 && h == 6) {
            System.out.println(22);
            return;
        }
        if (w == 5 && h == 5) {
            System.out.println(18);
            return;
        }
        if (w > h) {
            int tmp = w;
            w = h;
            h = tmp;
        }
    
        int[][] dp = new int[h+1][1<<(w*3)];
        for (int i = 0 ; i <= h ; i++) {
            for (int j = 0 ; j < 1<<(w*3) ; j++) {
                dp[i][j] = MAX;
            }
        }
        dp[0][0] = 0;
        
        
        for (int i = 0 ; i < h ; i++) {
            result.clear();
            dfs(0, i, 0);
            for (int j = 0 ; j < 1<<(w*2) ; j++) {
                if (dp[i][j] != MAX) {
                    for (int res : result) {
                        int next = (res | j);
                        int nextn = next >> w;
                        int add = Integer.bitCount(next & ((1<<w) - 1));
                        dp[i+1][nextn] = Math.min(dp[i+1][nextn], dp[i][j] + add);
                    }
                }
            }
        }
        

        int answer = MAX;
        for (int j = 0 ; j < 1<<(w*2) ; j++) {
            answer = Math.min(answer, dp[h][j] + Integer.bitCount(j));
        }
        System.out.println(h * w - answer);
    }
}",0111_C,CODEFORCES,4611,Petya and Spiders,"Little Petya loves training spiders. Petya has a board n × m in size. Each cell of the board initially has a spider sitting on it. After one second Petya chooses a certain action for each spider, and all of them humbly perform its commands. There are 5 possible commands: to stay idle or to move from current cell to some of the four side-neighboring cells (that is, one command for each of the four possible directions). Petya gives the commands so that no spider leaves the field. It is allowed for spiders to pass through each other when they crawl towards each other in opposite directions. All spiders crawl simultaneously and several spiders may end up in one cell. Petya wants to know the maximum possible number of spider-free cells after one second.
The first line contains two space-separated integers n and m (1 ≤ n, m ≤ 40, n·m ≤ 40) — the board sizes.
In the first line print the maximum number of cells without spiders.
In the first sample the only possible answer is:
s
","input
In the second sample one of the possible solutions is: 
output
s denotes command ""stay idle"", l, r, d, u denote commands ""crawl left"", ""crawl right"", ""crawl down"", ""crawl up"", correspondingly.
","bitmasks, dp, dsu",7
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class A {
	private static StreamTokenizer in;
	private static PrintWriter out;

	private static int nextInt() throws Exception {
		in.nextToken();
		return (int) in.nval;
	}

	private static String nextString() throws Exception {
		in.nextToken();
		return in.sval;
	}

	public static void main(String[] args) throws Exception {
		in = new StreamTokenizer(new BufferedReader(new InputStreamReader(
				System.in)));
		out = new PrintWriter(System.out);

		String s = nextString();
		int max = 0;
		for (int i=0; i<s.length(); i++) {
			for (int j=i+1; j<=s.length(); j++) {
//				System.out.println(i+ "" ""+ j);
				String u = s.substring(i,j);
				if (s.substring(i+1).indexOf(u) >= 0) {
					max = Math.max(max, u.length());
				}
			}
		}
		out.println(max);
		
		out.flush();
	}
}",0023_A,CODEFORCES,3735,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.*;         
import java.util.*;         
import java.math.*;         

 
public class Main  implements Runnable {
//public static final String FileName = ""test"";
StreamTokenizer ST;      
PrintWriter out;      
BufferedReader br;   
Scanner in;
static final int inf = 1000000000;
 
int nextInt() throws IOException{      
    ST.nextToken();      
    return (int)ST.nval;      
}
long nextLong() throws IOException{      
    ST.nextToken();      
    return (long)ST.nval;      
}      
String next() throws IOException{      
    ST.nextToken();      
    return ST.sval;      
}      
double nextD() throws IOException{      
    ST.nextToken();      
    return ST.nval;      
}      
public static void main(String[] args) throws IOException {       
   new Thread(new Main()).start();
//  new Main().run();
}
 
public void run()  {      
    try {
        br = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));      
        //br = new BufferedReader(new FileReader(new File(FileName+"".in"")));
        //out = new PrintWriter(new BufferedWriter(new FileWriter(FileName+"".out"")));
        in = new Scanner(br);
        ST = new StreamTokenizer(br);      
        solve();      
        out.close();
        //in.close();
        br.close();   
    }         
    catch (IOException e) {       
        e.printStackTrace();
        throw new IllegalStateException(e);  
    }      
}


public void solve() throws IOException {
    int n = nextInt();
    int K = nextInt();
    boolean[] f = new boolean[n+1];
    Arrays.fill(f, true);
    Vector<Integer> P = new Vector<Integer>();
    for (int i=2; i<=n; i++)
        if (f[i]) {
            for (int j=2*i; j<=n; j+=i) 
                f[j] = false;
            P.add(i);
        }
    for (int i=0; i<P.size()-1; i++) {
        int x = P.elementAt(i)+P.elementAt(i+1)+1;
        if (x<=n && f[x]) K--;
    }
    if (K<=0) out.println(""YES""); else out.println(""NO"");
    //for (int x:P) out.print(x+"" "");
    
}
  
}
















 
 
  ",0017_A,CODEFORCES,1535,Noldbach problem,"Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least k prime numbers from 2 to n inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.
Two prime numbers are called neighboring if there are no other prime numbers between them.
You are to help Nick, and find out if he is right or wrong.
The first line of the input contains two integers n (2 ≤ n ≤ 1000) and k (0 ≤ k ≤ 1000).
","input
Output YES if at least k prime numbers from 2 to n inclusively can be expressed as it was described above. Otherwise output NO.
output
In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.
","bruteforce, math, numbertheory",3
"import java.util.ArrayList;
import java.util.Scanner;

public class testD {
    public static void main(String[] args) {
        Scanner input =new Scanner(System.in);
        int i,j;
        i=input.nextInt();
        j=input.nextInt();
        ArrayList<String> m=new ArrayList<String>();
        input.nextLine();
        for(int k=0;k<i;k++){
            m.add(input.nextLine());
        }

        ArrayList<Integer> light = new ArrayList<Integer>();
        for(int k=0;k<j;k++){
            light.add(0);
        }

        for(int k=0;k<m.size();k++){
            for(int l=0;l<j;l++){
                if (m.get(k).charAt(l)=='1'){
                    light.set(l,light.get(l)+1);
                }
            }
        }
        for (int k=0;k<i;k++){
            if (is(light,j,m,k)){
                System.out.println(""YES"");
                return;
            }
        }
        System.out.println(""NO"");
    }

    public static Boolean is(ArrayList<Integer> light,int lightnum,ArrayList<String> button,int buttonnum){
                for(int j=0;j<lightnum;j++) {
                    if (button.get(buttonnum).charAt(j) == '1') {
                        if (light.get(j) - 1 == 0) {
                            return false;
                        }
                    }
                }
                return true;
    }
}

	  	    		 	 	 	 		 					 		 	",0985_B,CODEFORCES,3264,Switches and Lamps,"You are given n switches and m lamps. The i-th switch turns on some subset of the lamps. This information is given as the matrix a consisting of n rows and m columns where ai, j = 1 if the i-th switch turns on the j-th lamp and ai, j = 0 if the i-th switch is not connected to the j-th lamp.
Initially all m lamps are turned off.
Switches change state only from ""off"" to ""on"". It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards.
It is guaranteed that if you push all n switches then all m lamps will be turned on.
Your think that you have too many switches and you would like to ignore one of them. 
Your task is to say if there exists such a switch that if you will ignore (not use) it but press all the other n - 1 switches then all the m lamps will be turned on.
The first line of the input contains two integers n and m (1 ≤ n, m ≤ 2000) — the number of the switches and the number of the lamps.
The following n lines contain m characters each. The character ai, j is equal to '1' if the i-th switch turns on the j-th lamp and '0' otherwise.
","input
It is guaranteed that if you press all n switches all m lamps will be turned on.
output
Print ""YES"" if there is a switch that if you will ignore it and press all the other n - 1 switches then all m lamps will be turned on. Print ""NO"" if there is no such switch.
",implementation,5
"/**
 * Created by IntelliJ IDEA.
 * User: Taras_Brzezinsky
 * Date: 8/13/11
 * Time: 6:10 PM
 * To change this template use File | Settings | File Templates.
 */

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;
import java.io.IOException;

public class DarkAssembly extends Thread {

    public DarkAssembly() {
        this.input = new BufferedReader(new InputStreamReader(System.in));
        this.output = new PrintWriter(System.out);
        this.setPriority(Thread.MAX_PRIORITY);
    }

    static class Senator {
        int loyalty;
        int level;

        public Senator(int level, int loyalty) {
            this.level = level;
            this.loyalty = loyalty;
        }
    }

    private static double doIt(Senator[] senators, int A) {
        double probability = .0;
        for (int mask = 0; mask < (1 << senators.length); ++mask) {
            int sum = A;
            double current = 1.0;
            for (int i = 0; i < senators.length; ++i) {
                if ((mask & (1 << i)) != 0) {
                    current *= .01 * senators[i].loyalty;
                } else {
                    current *= .01 * (100 - senators[i].loyalty);
                    sum += senators[i].level;
                }
            }
            if (getOnes(mask) > senators.length / 2) {
                probability += current;
            } else {
                probability += current * (double)A / sum;
            }
        }
        return probability;
    }

    private static double go(Senator []senators, int candies, int A, int current) {
        if (current == senators.length) {
            return doIt(senators, A);
        } else {
            double result = go(senators, candies, A, current + 1);
            if (candies > 0 && senators[current].loyalty < 100) {
                senators[current].loyalty += 10;
                result = Math.max(result, go(senators, candies - 1, A, current));
                senators[current].loyalty -= 10;
            }
            return result;
        }        
    }



    static int getOnes(int mask) {
        int result = 0;
        while (mask != 0) {
            mask &= mask - 1;
            ++result;
        }
        return result;
    }

    public void run() {
        try {
            int n = nextInt();
            int k = nextInt();
            int A = nextInt();
            Senator[] senators = new Senator[n];
            for (int i = 0; i < n; ++i) {
                senators[i] = new Senator(nextInt(), nextInt());
            }
            output.printf(""%.10f"", go(senators, k, A, 0));

            output.flush();
            output.close();

        } catch (Throwable e) {
            System.err.println(e.getMessage());
            System.err.println(Arrays.deepToString(e.getStackTrace()));
        }
    }


    public static void main(String[] args) {
        new DarkAssembly().start();
    }

    private String nextToken() throws IOException {
        while (tokens == null || !tokens.hasMoreTokens()) {
            tokens = new StringTokenizer(input.readLine());
        }
        return tokens.nextToken();
    }

    private int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    private double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    private long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }


    private BufferedReader input;
    private PrintWriter output;
    private StringTokenizer tokens = null;
}
",0105_B,CODEFORCES,4537,Dark Assembly,"Dark Assembly is a governing body in the Netherworld. Here sit the senators who take the most important decisions for the player. For example, to expand the range of the shop or to improve certain characteristics of the character the Dark Assembly's approval is needed.
The Dark Assembly consists of n senators. Each of them is characterized by his level and loyalty to the player. The level is a positive integer which reflects a senator's strength. Loyalty is the probability of a positive decision in the voting, which is measured as a percentage with precision of up to 10%. 
Senators make decisions by voting. Each of them makes a positive or negative decision in accordance with their loyalty. If strictly more than half of the senators take a positive decision, the player's proposal is approved. 
If the player's proposal is not approved after the voting, then the player may appeal against the decision of the Dark Assembly. To do that, player needs to kill all the senators that voted against (there's nothing wrong in killing senators, they will resurrect later and will treat the player even worse). The probability that a player will be able to kill a certain group of senators is equal to A / (A + B), where A is the sum of levels of all player's characters and B is the sum of levels of all senators in this group. If the player kills all undesired senators, then his proposal is approved.
Senators are very fond of sweets. They can be bribed by giving them candies. For each received candy a senator increases his loyalty to the player by 10%. It's worth to mention that loyalty cannot exceed 100%. The player can take no more than k sweets to the courtroom. Candies should be given to the senators before the start of voting.
Determine the probability that the Dark Assembly approves the player's proposal if the candies are distributed among the senators in the optimal way.
The first line contains three integers n, k and A (1 ≤ n, k ≤ 8, 1 ≤ A ≤ 9999).
Then n lines follow. The i-th of them contains two numbers — bi and li — the i-th senator's level and his loyalty.
The levels of all senators are integers in range from 1 to 9999 (inclusive). The loyalties of all senators are integers in range from 0 to 100 (inclusive) and all of them are divisible by 10.
Print one real number with precision 10 - 6 — the maximal possible probability that the Dark Assembly approves the player's proposal for the best possible distribution of candies among the senators.
","input
In the first sample the best way of candies' distribution is giving them to first three of the senators. It ensures most of votes.
output
It the second sample player should give all three candies to the fifth senator.
","bruteforce, probabilities",7
"
import java.util.Scanner;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author scawn
 */
public class Main {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner cin = new Scanner (System.in);
        int n = cin.nextInt();
        long res = 2;
        long[] a = new long[4];
        a[0] = 0;
        a[1] = 1;
        a[2] = 1;
        a[3] = 2;
        if (n == 1){
            System.out.println(""0 0 1"");
            return;
        }
        if (n == 2){
            System.out.println(""0 1 1"");
            return;
        }
        if (n == 0){
            System.out.println(""0 0 0"");
            return;
        }
//        if (n == 1 || n == 2 || n == 0){
//            System.out.println(""I'm too stupid to solve this problem"");
//            return;
//        }
        if (n == 3){
            System.out.println(""1 1 1"");
            return;
        }
        do{
            a[3] = res;
            res = a[2] + a[3];
            if (res == n){
                System.out.println (a[0] + "" "" + a[1] + "" "" + a[3]);
                return;
            }
            a[0] = a[1];
            a[1] = a[2];
            a[2] = a[3];
            
        }while (true);
    }
}
",0199_A,CODEFORCES,160,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.StringTokenizer;

public class E {

	static long mod;
	static long[][] dp;
	static int n;
	static long[] nWaysToPlaceGroupOfSize;
	
	public static void main(String[] args) {
		FastScanner fs=new FastScanner();
		n=fs.nextInt();
		mod=fs.nextInt();
		precomp();
		dp=new long[n+1][n+1];
		for (int i=0; i<dp.length; i++) Arrays.fill(dp[i], -1);
		
		long ans=0;
		for (int nXsLeft=2; nXsLeft<=n; nXsLeft++) {
			long curAns=go(0, nXsLeft);
			ans=add(ans, curAns);
		}
		System.out.println(ans);
	}
	
	static long go(int position, int nXsLeft) {
		if (position==n) {
			//last thing was skipped, impossible
			return 0;
		}
		if (position==n+1) {
			//last thing was included, 1 way of doing that
			if (nXsLeft==0) return 1;
			return 0;
		}
		if (dp[position][nXsLeft]!=-1) {
			return dp[position][nXsLeft];
		}
		//TODO: brute force number of xs to place
		long ways=0;
		for (int nPlace=1; nPlace<=Math.min(nXsLeft, n-position); nPlace++) {
			long futureWays=go(position+nPlace+1, nXsLeft-nPlace);
			long waysToPlaceMe=nCk(nXsLeft, nPlace);
			if (nPlace>1) waysToPlaceMe=mul(waysToPlaceMe, nWaysToPlaceGroupOfSize[nPlace]);
			ways=add(ways, mul(waysToPlaceMe, futureWays));
		}
		return dp[position][nXsLeft]=ways;
	}
	
	static long nCk(int n, int k) {
		if (k>n) throw null;
		return mul(facts[n], mul(factInvs[k], factInvs[n-k]));
	}
	
	static long add(long a, long b) {
		return (a+b)%mod;
	}
	static long sub(long a, long b) {
		return ((a-b)%mod+mod)%mod;
	}
	static long mul(long a, long b) {
		return (a*b)%mod;
	}
	static long fastPow(long base, long e) {
		if (e==0) return 1;
		long half=fastPow(base, e/2);
		if (e%2==0) return mul(half, half);
		return mul(half, mul(half, base));
	}
	
	static long[] facts=new long[1_000_00];
	static long[] factInvs=new long[1_000_00];
	static void precomp() {
		facts[0]=1;
		for (int i=1; i<facts.length; i++) facts[i]=mul(facts[i-1], i);
		for (int i=0; i<factInvs.length; i++) factInvs[i]=fastPow(facts[i], mod-2);
		nWaysToPlaceGroupOfSize=new long[500];
		for (int finalSize=1; finalSize<nWaysToPlaceGroupOfSize.length; finalSize++) {
			for (int firstPos=0; firstPos<finalSize; firstPos++) {
				int l=firstPos, r=finalSize-1-firstPos;
				nWaysToPlaceGroupOfSize[finalSize]=add(nWaysToPlaceGroupOfSize[finalSize], nCk(l+r, l));
			}
		}
		System.err.println(""Done with precomp."");
	}

	static void sort(int[] a) {
		ArrayList<Integer> l=new ArrayList<>();
		for (int i:a) l.add(i);
		Collections.sort(l);
		for (int i=0; i<a.length; i++) a[i]=l.get(i);
	}
	
	static class FastScanner {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st=new StringTokenizer("""");
		String next() {
			while (!st.hasMoreTokens())
				try {
					st=new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			return st.nextToken();
		}
		
		int nextInt() {
			return Integer.parseInt(next());
		}
		int[] readArray(int n) {
			int[] a=new int[n];
			for (int i=0; i<n; i++) a[i]=nextInt();
			return a;
		}
		long nextLong() {
			return Long.parseLong(next());
		}
	}

	
}
",1515_E,CODEFORCES,4130,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"
import java.io.*;
import java.util.*;

public class Main implements Runnable
{
  Scanner in;
  PrintWriter out; //= new PrintWriter(System.out);

  public static void main(String[] args) throws FileNotFoundException, IOException
  {
    new Thread(new Main()).start();
  }

  public class Pair
  {
    public long last;
    public long count;
    public int L;
    Pair(long l, long c) {last = l; count = c;}
    Pair(long l, long c, int L) {last = l; count = c; this.L = L;}
  }

  public void run()
  {
    final String name = ""B-small"";
    //try {
      in = new Scanner(System.in);// (new File(name + "".in""));//StreamTokenizer(new FileReader(new File(name + "".in"")));
      out = new PrintWriter(System.out); // new PrintWriter(new File(name + "".out"")); //= new PrintWriter(System.out);
    //} catch (IOException e) {}


    String s = in.next().trim();
    int n = s.length();
    boolean[][] a = new boolean[n][n];

   for (int i = 0; i < n; ++i)
     for (int j = i + 1; j < n; ++j)
       a[i][j] = (s.charAt(i) == s.charAt(j));

    int max = 0;
    for (int i = 0; i < n; ++i)
     for (int j = i + 1; j < n; ++j)
     {
       int k =0;
       while (i + k < n && j + k < n && a[i + k][j + k])
           ++k;
       
       if (max < k)
           max = k;
     }
    
    out.println(max);
    out.flush();
  }

}
",0023_A,CODEFORCES,3704,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"//package CodeforcesJava;

import java.io.*;
import java.util.*;

public class Main {

    public void solve(InputProvider input, PrintWriter output) throws IOException {
        int n = input.nextInt();
        int d = input.nextInt();
        int count = 1;
        int current = input.nextInt();
        for (int i = 1; i < n; i++) {
            int x = input.nextInt();
            if (x - current == d * 2) {
                count++;
            } else if (x - current > d * 2) {
                count += 2;
            }
            current = x;
        }
        count++;
        output.print(count);
    }

    public static void main(String[] args) throws Exception {
        try (InputProvider input = new InputProvider(System.in);
             PrintWriter output = new PrintWriter(System.out)) {
            new Main().solve(input, output);
        }
    }

    public static class InputProvider implements AutoCloseable {

        private final BufferedReader reader;
        private StringTokenizer tokenizer;

        public InputProvider(Reader reader) {
            this.reader = new BufferedReader(reader);
        }

        public InputProvider(InputStream input) {
            reader = new BufferedReader(new InputStreamReader(input));
        }

        public String next() throws IOException {
            if (Objects.isNull(tokenizer) || !tokenizer.hasMoreTokens())
                tokenizer = new StringTokenizer(reader.readLine());
            return tokenizer.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public String nextLine() throws IOException {
            return reader.readLine();
        }

        @Override
        public void close() throws Exception {
            reader.close();
        }

    }

}
",1004_A,CODEFORCES,1973,Sonya and Hotels,"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.
The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $$$n$$$ hotels, where the $$$i$$$-th hotel is located in the city with coordinate $$$x_i$$$. Sonya is a smart girl, so she does not open two or more hotels in the same city.
Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $$$d$$$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 
Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $$$n$$$ hotels to the new one is equal to $$$d$$$.
The first line contains two integers $$$n$$$ and $$$d$$$ ($$$1\leq n\leq 100$$$, $$$1\leq d\leq 10^9$$$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.
The second line contains $$$n$$$ different integers in strictly increasing order $$$x_1, x_2, \ldots, x_n$$$ ($$$-10^9\leq x_i\leq 10^9$$$) — coordinates of Sonya's hotels.
Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $$$d$$$.
","input
In the first example, there are $$$6$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$-6$$$, $$$5$$$, $$$6$$$, $$$12$$$, $$$13$$$, and $$$19$$$.
output
In the second example, there are $$$5$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$2$$$, $$$6$$$, $$$13$$$, $$$16$$$, and $$$21$$$.
",implementation,3
"/**
 * @Author : lucent868
 * @Date : 5/30/21
 * @Time : 9:48 PM
 */

import java.util.*;
import java.io.*;
import java.math.*;

public class C {
    static InputReader in;
    static PrintWriter w;

    public static void main(String args[]) {
        new Thread(null, new Runnable() {
            public void run() {
                try {
                    solve();
                    w.flush();
                    w.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, ""1"", 1 << 26).start();
    }

    public static void solve() {
        in = new InputReader(System.in);
        w = new PrintWriter(System.out);

        int t = in.nextInt();
        while (t-- > 0) {
            int n = in.nextInt();
            int a[] = in.nextIntArray(n);

            Stack<Integer> st=new Stack<>();
            for(int i = 0;i<n;i++) {
                if(a[i] ==1) {
                    st.push(a[i]);
                }
                else {
                    while(!st.isEmpty()) {
                        int q=st.pop();
                        if(q==a[i] -1) {

                            st.push(a[i]);
                            break;
                        }
                    }
                }
                int k=0;
                for(int ii:st) {
                    k++;
                    if(k<st.size())w.print(ii+""."");
                    else w.print(ii);
                }
                w.println();
            }

        }




    }

    static class InputReader {
        private final InputStream stream;
        private final byte[] buf = new byte[8192];
        private int curChar, numChars;
        private SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public String nextLine() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isEndOfLine(c));
            return res.toString();
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));
            return Double.parseDouble(res.toString());
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public int[] nextIntArray(int n) {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = nextInt();
            }
            return arr;
        }

        public long[] nextLongArray(int n) {
            long[] arr = new long[n];
            for (int i = 0; i < n; i++) {
                arr[i] = nextLong();
            }
            return arr;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private boolean isEndOfLine(int c) {
            return c == '\n' || c == '\r' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
}








",1523_C,CODEFORCES,3657,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees",5
"import java.io.BufferedInputStream;
import java.util.Scanner;

/**
 * Created by jizhe on 2016/1/29.
 */
public class LCMChallenge {
    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedInputStream(System.in));

        long N = in.nextLong();
        if( N == 1 || N == 2 )
        {
            System.out.printf(""%d\n"", N);
            return;
        }

        if( (N&1) == 1 )
        {
            long lcm = N*(N-1)*(N-2);
            System.out.printf(""%d\n"", lcm);
        }
        else
        {
            if( N == 4 )
            {
                System.out.printf(""12\n"");
            }
            else
            {
                long lcm;
                if( N%3 == 0 )
                {
                    lcm = (N-1)*(N-2)*(N-3);
                }
                else
                {
                    lcm = N*(N-1)*(N-3);
                }

                System.out.printf(""%d\n"", lcm);
            }
        }
    }
}
",0235_A,CODEFORCES,216,LCM Challenge,"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.
But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than n. Can you help me to find the maximum possible least common multiple of these three integers?
The first line contains an integer n (1 ≤ n ≤ 106) — the n mentioned in the statement.
Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than n.
The least common multiple of some positive integers is the least positive integer which is multiple for each of them.
","input
The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.
output
For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.
",numbertheory,1
"import java.io.OutputStream;

import java.io.FileOutputStream;

import java.io.IOException;

import java.io.FileInputStream;

import java.io.InputStream;

import java.io.PrintWriter;

import java.io.OutputStream;

import java.util.Arrays;

import java.io.IOException;

import java.io.InputStreamReader;

import java.io.File;

import java.io.FileNotFoundException;

import java.util.StringTokenizer;

import java.io.Writer;

import java.io.BufferedReader;

import java.io.FileReader;

import java.io.InputStream;



/**

 * Built using CHelper plug-in

 * Actual solution is at the top

 * @author zodiacLeo

 */

public class Main

{

    public static void main(String[] args)

    {

        InputStream inputStream;

        try

        {

            inputStream = new FileInputStream(""input.txt"");

        } catch (IOException e)

        {

            throw new RuntimeException(e);

        }

        OutputStream outputStream;

        try

        {

            outputStream = new FileOutputStream(""output.txt"");

        } catch (IOException e)

        {

            throw new RuntimeException(e);

        }

        FastScanner in = new FastScanner(inputStream);

        FastPrinter out = new FastPrinter(outputStream);

        TaskC solver = new TaskC();

        solver.solve(1, in, out);

        out.close();

    }



    static class TaskC

    {

        private final static int[] dx = {-1, 0, +1, 0};

        private final static int[] dy = {0, +1, 0, -1};

        private final static int WHITE = 123456789;



        public void solve(int testNumber, FastScanner in, FastPrinter out)

        {

            int n = in.nextInt();

            int m = in.nextInt();



            int[][] map = new int[n][m];

            for (int i = 0; i < n; i++)

            {

                Arrays.fill(map[i], WHITE);

            }



            int k = in.nextInt();



            int qh = 0;

            int qt = 0;

            int[] q = new int[((int) 7e6)];

            for (int i = 0; i < k; i++)

            {

                int x = in.nextInt() - 1;

                int y = in.nextInt() - 1;

                map[x][y] = 0;

                q[qh++] = x * m + y;

            }



            int d = 0;

            int X = q[0] / m;

            int Y = q[0] % m;

            while (qt < qh)

            {

                int pos = q[qt++];

                int x = pos / m;

                int y = pos % m;

                for (int i = 0; i < 4; i++)

                {

                    int xx = x + dx[i];

                    int yy = y + dy[i];

                    if (isValid(xx, n) && isValid(yy, m) && map[xx][yy] == WHITE)

                    {

                        map[xx][yy] = map[x][y] + 1;

                        q[qh++] = (xx * m) + yy;

                        if (d < map[xx][yy])

                        {

                            d = map[xx][yy];

                            X = xx;

                            Y = yy;

                        }

                    }

                }

            }

//        for (int i = 0; i < n; i++)

//        {

//            for (int j = 0; j < m; j++)

//            {

//                out.print(map[i][j] + "" "");

//            }

//            out.println();

//        }

            out.println((X + 1) + "" "" + (Y + 1));

        }



        private boolean isValid(int x, int X)

        {

            return x >= 0 && x < X;

        }



    }



    static class FastScanner

    {

        public BufferedReader br;

        public StringTokenizer st;



        public FastScanner(InputStream is)

        {

            br = new BufferedReader(new InputStreamReader(is));

        }



        public FastScanner(File f)

        {

            try

            {

                br = new BufferedReader(new FileReader(f));

            } catch (FileNotFoundException e)

            {

                e.printStackTrace();

            }

        }



        public String next()

        {

            while (st == null || !st.hasMoreElements())

            {

                String s = null;

                try

                {

                    s = br.readLine();

                } catch (IOException e)

                {

                    e.printStackTrace();

                }

                if (s == null)

                    return null;

                st = new StringTokenizer(s);

            }

            return st.nextToken();

        }



        public int nextInt()

        {

            return Integer.parseInt(next());

        }



    }



    static class FastPrinter extends PrintWriter

    {

        public FastPrinter(OutputStream out)

        {

            super(out);

        }



        public FastPrinter(Writer out)

        {

            super(out);

        }



    }

}



",0035_C,CODEFORCES,3896,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;

public class B {
    static int first(int n)
    {
	int res = 0;
	while(n > 0 && (n & 1) == 0){
	    n >>= 1;
	    res++;
	}
	return res;
    }
    public static void main(String[] args) throws Exception
    {
	Scanner bf = new Scanner(System.in);
	PrintWriter out = new PrintWriter(System.out);
	int n = bf.nextInt(), m = bf.nextInt();
	ArrayList<Integer> [] adjList = new ArrayList[n];
	for (int i = 0; i < adjList.length; i++)
	{
	    adjList[i] = new ArrayList<Integer>();
	}
	for (int i = 0; i < m; i++)
	{
	    int u = bf.nextInt()-1, v = bf.nextInt()-1;
	    adjList[u].add(v);
	    adjList[v].add(u);
	}
	long [][] memo = new long[(1<<n)][n];
	for (int i = 0; i < n; i++)
	{
	    memo[1<<i][i] = 1;
	}
	long ans = 0;
	for (int i = 1; i < 1<<n; i++)
	{
	    if(Integer.bitCount(i) == 1) continue;
	    for (int j = 0; j < n; j++)
	    {
		if((i & (1<<j)) == 0 || j == first(i)) continue;
		for(int v:adjList[j])
		    memo[i][j] += memo[i^(1<<j)][v];
	    }
	}
	for (int i = 1; i < 1<<n; i++)
	{
	    if(Integer.bitCount(i) < 3) continue;
	    int t = first(i);
	    for (int j = 0; j < n; j++)
	    {
		if(adjList[j].contains(t))
		    ans += memo[i][j];
	    }
	}
	out.println(ans/2);
	out.flush();
	out.close();
    }

    static class Scanner {
	StringTokenizer st;
	BufferedReader br;

	public Scanner(InputStream s)
	{
	    br = new BufferedReader(new InputStreamReader(s));
	}

	public Scanner(FileReader fileReader)
	{
	    br = new BufferedReader(fileReader);
	}

	public String next() throws IOException
	{
	    while (st == null || !st.hasMoreTokens())
		st = new StringTokenizer(br.readLine());
	    return st.nextToken();
	}

	public int nextInt() throws IOException
	{
	    return Integer.parseInt(next());
	}

	public long nextLong() throws IOException
	{
	    return Long.parseLong(next());
	}

	public String nextLine() throws IOException
	{
	    return br.readLine();
	}

	public boolean ready() throws IOException
	{
	    return br.ready();
	}
    }
}
",0011_D,CODEFORCES,4447,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.zip.CRC32;

public class Solution {

    static File inputfile = new File(""C:\\Users\\IbrahimE6\\Downloads\\logs.csv"");
    static Scanner scan;
    static {
        scan = new Scanner(System.in);
//        try {
//            scan = new Scanner(inputfile);
//        } catch (FileNotFoundException e) {
//            e.printStackTrace();
//        }
    }


    public static long getPipes(long splitter, long number){
        return (splitter * (splitter+1) / 2) - (number * (number-1) / 2) - (splitter - number);
    }
    public static void main(String[] args) {
        // write your code here
        long n = scan.nextLong(), k = scan.nextLong();
        if(n == 1){
            System.out.println(0);
            return;
        }
        long start = 1, end = k-1;
        while(true){
            if(start > end){
                System.out.println(-1);
                break;
            }else if(start == end){
                if(getPipes(k, k - start + 1) >= n){
                    System.out.println(start);
                }else{
                    System.out.println(-1);
                }
                break;
            }else{
                long mid = start + (end-start)/2;
                long pipes = getPipes(k, k - mid + 1);
                if(pipes < n){
                    start = mid + 1;
                }else{
                    end = mid;
                }
            }
        }

    }



}",0287_B,CODEFORCES,892,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.util.*;
import java.io.*;
public class Main{
     static int root[],lc[],rc[],sz[],tot=1;
     public static void main(String []args) throws IOException{
        BufferedReader sc=new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw=new PrintWriter(System.out);
        String s[]=sc.readLine().trim().split("" "");
        int n=Integer.parseInt(s[0]);
        int q=Integer.parseInt(s[1]);
        root=new int[(int)(7e6)];
        lc=new int[(int)(7e6)];
        rc=new int[(int)(7e6)];
        sz=new int[(int)(7e6)];
        root[0]=0;
        pre(0,1,n);
        StringBuilder sb=new StringBuilder();
        s=sc.readLine().trim().split("" "");
        for(int i=1;i<=n;i++){
            int x=Integer.parseInt(s[i-1]);
            root[i]=tot++;
            //System.out.println(tot);
            update(root[i],root[i-1],1,n,x);
        }
        
        while(q-->0){
            s=sc.readLine().trim().split("" "");
            int l=Integer.parseInt(s[0]);
            int r=Integer.parseInt(s[1]);
            int k=Integer.parseInt(s[2]);
            int len=(r-l+1+k)/k;
            sb.append(query(root[l-1],root[r],1,n,len)+""\n"");
        }
        pw.println(sb.toString());
        pw.flush();
        sc.close();
        pw.close();
     }
     public static void update(int curr,int prev,int l,int r,int x){
         sz[curr]=sz[prev]+1;
         if(l>=r)return;
         int val=tot;
         int mid=(l+r)>>1;
         if(x<=mid){
             lc[curr]=tot++;
             rc[curr]=rc[prev];
             update(lc[curr],lc[prev],l,mid,x);
         }else{ 
             rc[curr]=tot++;
             lc[curr]=lc[prev];
             update(rc[curr],rc[prev],mid+1,r,x);
         }
     }
     public static int query(int ql,int qr,int l,int r,int len){
         if(sz[qr]-sz[ql]<len)return -1;
         if(l==r)return l;
         int mid=(l+r)/2;
         int x=query(lc[ql],lc[qr],l,mid,len);
         if(x!=-1)return x;
         return query(rc[ql],rc[qr],mid+1,r,len);
     }
     public static void pre(int curr,int l,int r){
         if(l==r)return;
         lc[curr]=tot++;
         int val=tot;
         int mid=(l+r)>>1;
         pre(lc[curr],l,mid);
         rc[curr]=tot++;
         pre(rc[curr],mid+1,r);
     }
}",0840_D,CODEFORCES,4049,Destiny,"Once, Leha found in the left pocket an array consisting of n integers, and in the right pocket q queries of the form l r k. If there are queries, then they must be answered. Answer for the query is minimal x such that x occurs in the interval l r strictly more than  times or  - 1 if there is no such number. Help Leha with such a difficult task.
First line of input data contains two integers n and q (1 ≤ n, q ≤ 3·105) — number of elements in the array and number of queries respectively.
Next line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — Leha's array.
","input
Each of next q lines contains three integers l, r and k (1 ≤ l ≤ r ≤ n, 2 ≤ k ≤ 5) — description of the queries.
output
Output answer for each query in new line.
","datastructures, probabilities",6
"
import java.util.Scanner;

public class C {
	static long n = 0;
		static void R (long a,long b){
			n += a/b;
			a = a%b;
			if(a==0) return;
			R(b,a);
		}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		long a = sc.nextLong();
		long b = sc.nextLong();
		R(a,b);
		System.out.println(n);
	}
}",0343_A,CODEFORCES,392,Rational Resistance,"Mad scientist Mike is building a time machine in his spare time. To finish the work, he needs a resistor with a certain resistance value.
However, all Mike has is lots of identical resistors with unit resistance R0 = 1. Elements with other resistance can be constructed from these resistors. In this problem, we will consider the following as elements: 
With the consecutive connection the resistance of the new element equals R = Re + R0. With the parallel connection the resistance of the new element equals . In this case Re equals the resistance of the element being connected.
Mike needs to assemble an element with a resistance equal to the fraction . Determine the smallest possible number of resistors he needs to make such an element.
The single input line contains two space-separated integers a and b (1 ≤ a, b ≤ 1018). It is guaranteed that the fraction  is irreducible. It is guaranteed that a solution always exists.
Print a single number — the answer to the problem.
Please do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.
","input
In the first sample, one resistor is enough.
output
In the second sample one can connect the resistors in parallel, take the resulting element and connect it to a third resistor consecutively. Then, we get an element with resistance . We cannot make this element using two resistors.
","math, numbertheory",1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;


public class A {
	
	static class Scanner{
		BufferedReader br=null;
		StringTokenizer tk=null;
		public Scanner(){
			br=new BufferedReader(new InputStreamReader(System.in));
		}
		public String next() throws IOException{
			while(tk==null || !tk.hasMoreTokens())
				tk=new StringTokenizer(br.readLine());
			return tk.nextToken();
		}
		public int nextInt() throws NumberFormatException, IOException{
			return Integer.valueOf(next());
		}
		public double nextDouble() throws NumberFormatException, IOException{
			return Double.valueOf(next());
		}
	}
	
	public static void main(String args[]) throws NumberFormatException, IOException{
		Scanner sc = new Scanner();
		int T = sc.nextInt();
		if ( T > 0)
			System.out.println(T);
		else{
			String cad = (T + """");
			int min = Math.min(cad.charAt(cad.length() - 1) - '0', cad.charAt(cad.length() - 2) - '0');
			if (min == 0 && cad.length() == 3)
				System.out.println(0);
			else
				System.out.println(cad.substring(0, cad.length() - 2) + """" + min);
		}
	}

	
}
",0313_A,CODEFORCES,313,Ilya and Bank Account,"Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.
Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.
Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.
The single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.
In a single line print an integer — the maximum state of the bank account that Ilya can get. 
","input
In the first test sample Ilya doesn't profit from using the present.
output
In the second test sample you can delete digit 1 and get the state of the account equal to 0.
","implementation, numbertheory",1
"import java.io.InputStreamReader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author bdepwgjqet
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		A solver = new A();
		solver.solve(1, in, out);
		out.close();
	}
}

class A {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int number = in.nextInt();
        if((number & 1) == 0) {
            out.println(4+"" ""+(number-4));
        } else {
            out.println(9+"" ""+(number-9));
        }
    }
}

class InputReader {

    private final BufferedReader bufferedReader;
    private StringTokenizer stringTokenizer;

    public InputReader(InputStream in) {
        bufferedReader = new BufferedReader(new InputStreamReader(in));
        stringTokenizer = null;
    }

    public String nextLine() {
        try {
            return bufferedReader.readLine();
        } catch(IOException e) {
            throw new RuntimeException(e);
        }
    }

    public String nextBlock() {
        while(stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {
            stringTokenizer = new StringTokenizer(nextLine());
        }
        return stringTokenizer.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(nextBlock());
    }

    public double nextDouble() {
        return Double.parseDouble(nextBlock());
    }

    public long nextLong() {
        return Long.parseLong(nextBlock());
    }
}

",0472_A,CODEFORCES,455,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory",1
"import java.util.Scanner;

public class C {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int len = s.nextInt();
        s.nextLine();
        String l = s.nextLine();
        char[] ca = l.toCharArray();
        int h = 0;
        for (char c : ca)
            h += A(c);
        int cur = h;
        int i;
        for (i = 0; i < h; i++)
            cur -= A(ca[i]);
        int best = cur;
        while (i != h + len) {
            cur -= A(ca[i % len]);
            cur += A(ca[(i - h) % len]);
            best = best > cur ? cur : best;
            i++;
        }
        System.out.println(best);
    }

    public static int A(char x) {
        return x == 'H' ? 1 : 0;
    }
}
",0046_C,CODEFORCES,1608,Hamsters and Tigers,"Today there is going to be an unusual performance at the circus — hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.
The first line contains number n (2 ≤ n ≤ 1000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols ""H"" and ""T"". The ""H""s correspond to hamsters and the ""T""s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.
","input
Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.
output
In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then — the tiger in position 9 with the hamster in position 7.
",twopointers,3
"import java.util.Scanner;

public class D2 {
	public static void main(String args[]) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int array[] =new int[n];
		for(int i=0; i<=n-1; i++) {
			array[i] = sc.nextInt();
		}
		int m = sc.nextInt();
		int result = count(array);
		for(int i=1; i<=m; i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			result += (b-a)*(b-a+1)/2;
			result=result%2;
			if(result%2==1)
				System.out.println(""odd"");
			else
				System.out.println(""even"");
		}
	}
	
	public static int count(int[] arr) {
		int[] array = arr.clone();
		return sort(array,0,array.length-1);
	}
	
	public static int sort(int[] arr, int i, int j) {
		if(i>=j) return 0;
		int mid = (i+j)/2;
		int a = sort(arr,i,mid);
		int b = sort(arr,mid+1,j);
		int addition = 0;
		int r1 = mid+1;
		int[] tmp = new int[arr.length];
		int tIndex = i;
        int cIndex=i;
		while(i<=mid&&r1<=j) {
			if (arr[i] <= arr[r1]) 
                tmp[tIndex++] = arr[i++];
            else {
                      tmp[tIndex++] = arr[r1++];
                      addition+=mid+1-i;
            }
		}
		while (i <=mid) {
            tmp[tIndex++] = arr[i++];
        }
        while ( r1 <= j ) {
            tmp[tIndex++] = arr[r1++];
        }
        while(cIndex<=j){
            arr[cIndex]=tmp[cIndex];
            cIndex++;
        }
        return a+b+addition;
	}
}
",0911_D,CODEFORCES,3184,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"    import java.util.*;
    import java.io.*;
    //import java.lang.*;

    public class ranjan{

        public static Read cin;
        //public static InputReader cin;
        public static PrintWriter cout;
        public static int[] visited;
        public static final long bil = (long)1e9+7;
        public static int fileread = 0; 
        
        public static void main(String ...arg) throws IOException
        {
            /*console writer*/
            cout = new PrintWriter(new BufferedOutputStream(System.out));
            /*Debug Reader*/
            //Scan cin =new Scan();clear
            
            if(fileread == 1)
            {
                try
                {
                cin = new Read(new FileInputStream(new File(""in3.txt"")));
                //cin = new InputReader(new FileInputStream(new File(""in1.txt"")));
                }
                catch (IOException error){}
            }
            else{
                cin = new Read(System.in);
                //cin = new InputReader(System.in);
            }

            //input
            int n = cin.nextInt();
            HashSet<Long> ls = new HashSet<>();
            long[] q1 = new long[n];
            long[] q2 = new long[n];

            for(int i=0;i<n;i++){
                q1[i] = cin.nextLong();
                q2[i] = cin.nextLong()+1;
                ls.add(q1[i]);
                ls.add(q2[i]);
            }
            long[] compress = new long[ls.size()];
            int index = 0;
            for(Long x:ls)
                compress[index++] = x;
            Arrays.sort(compress);

            //process
            int[] prefix = new int[compress.length];
            for(int i=0;i<n;i++){
                prefix[Arrays.binarySearch(compress, q1[i])]++;
                prefix[Arrays.binarySearch(compress, q2[i])]--;
            }

            for(int i=1;i<compress.length;i++)
                prefix[i] += prefix[i-1];

            long[] ans = new long[n];
            for(int i=0;i<compress.length-1;i++){
                if(prefix[i] != 0)
                    ans[prefix[i]-1] +=  compress[i+1]-compress[i];
            }

            //output
            for(long x:ans)
                cout.print(x+"" "");


            cout.print(""\n"");
            cout.close();
        }


        private static class Pair{
            public int a,b;
            public Pair(int a,int b)
            {
                this.a = a;
                this.b = b;
            }	
        }


        /*public static void seive(int size)
        {
            prime[0] = prime[1] = false;
            int p = 2;
            while(p*p<= size)
            {
                if(prime[p])
                {
                    for(int i=p*p;i<size;i += p)

                        prime[i] = false;
                }
                p++;
            }
        }*/


        public static <K, V> V getOrDefault(HashMap<K,V> map, K key, V defaultValue) {
            return map.containsKey(key) ? map.get(key) : defaultValue;
        }
        
        static void reverseArray(int intArray[], int size) 
        { 
            int i, temp; 
            for (i = 0; i < size / 2; i++) { 
                temp = intArray[i]; 
                intArray[i] = intArray[size - i - 1]; 
                intArray[size - i - 1] = temp; 
            }  
        } 

        public static long mod_pow(long x,long n,long mod) {
            long res=1;
            while(n>0) {
                if((n&1)==1)res=res*x%mod;
                x=x*x%mod;
                n>>=1;
            }
            return res;
        }
        public static int gcd(int n1, int n2) 
        {
            int r;
            while (n2 != 0) 
            {
                r = n1 % n2;
                n1 = n2;
                n2 = r;
            }
            return n1;
        }
    
        /*public static int lcm(int n1, int n2) 
        {
            int answer = (n1 * n2) / (gcd(n1, n2));
            return answer;
        }*/


        static class InputReader {
            final InputStream is;
            final byte[] buf = new byte[1024];
            int pos;
            int size;
    
            public InputReader(InputStream is) {
                this.is = is;
            }
    
            public int nextInt() {
                int c = read();
                while (isWhitespace(c))
                    c = read();
                int sign = 1;
                if (c == '-') {
                    sign = -1;
                    c = read();
                }
                int res = 0;
                do {
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    res = res * 10 + c - '0';
                    c = read();
                } while (!isWhitespace(c));
                return res * sign;
            }
    
            int read() {
                if (size == -1)
                    throw new InputMismatchException();
                if (pos >= size) {
                    pos = 0;
                    try {
                        size = is.read(buf);
                    } catch (IOException e) {
                        throw new InputMismatchException();
                    }
                    if (size <= 0)
                        return -1;
                }
                return buf[pos++] & 255;
            }
    
            static boolean isWhitespace(int c) {
                return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
            }
    
        }

}


    
class Read
{
    private BufferedReader br;
    private StringTokenizer st;

    public Read(InputStream is)
    { br = new BufferedReader(new InputStreamReader(is)); }

    String next()
    {
        while (st == null || !st.hasMoreElements())
        {
            try {st = new StringTokenizer(br.readLine());}
            catch(IOException e)
                {e.printStackTrace();}
        }
        return st.nextToken();
    }

    int nextInt()
    { return Integer.parseInt(next()); }

    long nextLong()
    { return Long.parseLong(next()); }

    double nextDouble()
    { return Double.parseDouble(next()); }

    String nextLine()
    {
        String str = """";
        try {str = br.readLine();}
        catch(IOException e)
            {e.printStackTrace();}
        return str;
    }
}

",1000_C,CODEFORCES,2845,Covered Points Count,"You are given $$$n$$$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.
Your task is the following: for every $$$k \in [1..n]$$$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $$$k$$$. A segment with endpoints $$$l_i$$$ and $$$r_i$$$ covers point $$$x$$$ if and only if $$$l_i \le x \le r_i$$$.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of segments.
The next $$$n$$$ lines contain segments. The $$$i$$$-th line contains a pair of integers $$$l_i, r_i$$$ ($$$0 \le l_i \le r_i \le 10^{18}$$$) — the endpoints of the $$$i$$$-th segment.
Print $$$n$$$ space separated integers $$$cnt_1, cnt_2, \dots, cnt_n$$$, where $$$cnt_i$$$ is equal to the number of points such that the number of segments that cover these points equals to $$$i$$$.
The picture describing the first example:

Points with coordinates $$$[0, 4, 5, 6, 7, 8]$$$ are covered by one segment, points $$$[1, 2]$$$ are covered by two segments and point $$$[3]$$$ is covered by three segments.
The picture describing the second example:
","input

output
Points $$$[1, 4, 5, 6, 7]$$$ are covered by one segment, points $$$[2, 3]$$$ are covered by two segments and there are no points covered by three segments.
","datastructures, implementation, sortings",4
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.PrintStream;
import java.io.BufferedWriter;
import java.util.Random;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Jialin Ouyang (Jialin.Ouyang@gmail.com)
 */
public class Main {
  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    QuickScanner in = new QuickScanner(inputStream);
    QuickWriter out = new QuickWriter(outputStream);
    TaskB solver = new TaskB();
    solver.solve(1, in, out);
    out.close();
  }

  static class TaskB {
    static boolean LOCAL = false;
    static int TEST_CASE = 10000;
    QuickScanner in;
    QuickWriter out;
    int n;
    Server server;

    public void solve(int testNumber, QuickScanner in, QuickWriter out) {
      this.in = in;
      this.out = out;
      n = LOCAL ? 1 << 16 : in.nextInt();
      server = new Server();
      for (int remCases = LOCAL ? TEST_CASE : 1; remCases > 0; --remCases) {
        server.init(n);
        Rect[] rects = split(0);
        if (rects == null) {
          rects = split(1);
        }
        rects[0] = shrink(rects[0]);
        rects[1] = shrink(rects[1]);
        server.answer(rects[0], rects[1]);
      }
    }

    Rect[] split(int dim) {
      int lower = 1, upper = n - 1, res = 0;
      Rect fullRect = new Rect(1, 1, n, n);
      while (lower <= upper) {
        int medium = (lower + upper) >> 1;
        if (server.ask(fullRect.update(1, dim, medium)) == 0) {
          res = medium;
          lower = medium + 1;
        } else {
          upper = medium - 1;
        }
      }
      Rect[] rects = new Rect[]{
          fullRect.update(1, dim, res + 1),
          fullRect.update(0, dim, res + 2)};
      return server.ask(rects[0]) == 1
          && server.ask(rects[1]) == 1
          ? rects : null;
    }

    Rect shrink(Rect rect) {
      rect = shrink(rect, 0);
      rect = shrink(rect, 1);
      return rect;
    }

    Rect shrink(Rect rect, int dim) {
      int lower, upper, res;
      // lower
      lower = rect.getValue(0, dim) + 1;
      upper = rect.getValue(1, dim);
      res = lower - 1;
      while (lower <= upper) {
        int medium = (lower + upper) >> 1;
        if (server.ask(rect.update(0, dim, medium)) == 1) {
          res = medium;
          lower = medium + 1;
        } else {
          upper = medium - 1;
        }
      }
      rect = rect.update(0, dim, res);
      // upper
      lower = rect.getValue(0, dim);
      upper = rect.getValue(1, dim) - 1;
      res = upper + 1;
      while (lower <= upper) {
        int medium = (lower + upper) >> 1;
        if (server.ask(rect.update(1, dim, medium)) == 1) {
          res = medium;
          upper = medium - 1;
        } else {
          lower = medium + 1;
        }
      }
      return rect.update(1, dim, res);
    }

    class Server {
      Rect rect1;
      Rect rect2;

      Server() {
        rect1 = new Rect();
        rect2 = new Rect();
      }

      void init(int n) {
        if (LOCAL) {
          do {
            rect1.initRandom(n);
            rect2.initRandom(n);
          } while (!rect1.valid(rect2));
          //rect1 = new Rect(2, 2, 2, 2);
          //rect2 = new Rect(3, 4, 3, 5);
        }
      }

      int ask(Rect rect) {
        out.print(""? "");
        rect.print();
        out.println();
        out.flush();
        if (LOCAL) {
          return (rect1.in(rect) ? 1 : 0)
              + (rect2.in(rect) ? 1 : 0);
        } else {
          return in.nextInt();
        }
      }

      void answer(Rect rect1, Rect rect2) {
        out.print(""! "");
        rect1.print();
        out.print(' ');
        rect2.print();
        out.println();
        out.flush();
        if (LOCAL) {
          if ((rect1.equals(this.rect1) && rect2.equals(this.rect2))
              || (rect2.equals(this.rect1) && rect1.equals(this.rect2))) {
            System.out.println(""AC!"");
          } else {
            System.out.println(""WA!"");
            throw new IllegalArgumentException();
          }
        }
      }

    }

    class Rect {
      final Random random = new Random();
      int x1;
      int y1;
      int x2;
      int y2;

      Rect() {
      }

      Rect(int x1, int y1, int x2, int y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
      }

      void initRandom(int n) {
        x1 = random.nextInt(n);
        x2 = random.nextInt(n - x1) + x1 + 1;
        ++x1;
        y1 = random.nextInt(n);
        y2 = random.nextInt(n - y1) + y1 + 1;
        ++y1;
      }

      int getValue(int idx1, int idx2) {
        switch ((idx1 << 1) | idx2) {
          case 0:
            return x1;
          case 1:
            return y1;
          case 2:
            return x2;
          case 3:
            return y2;
        }
        throw new IllegalArgumentException();
      }

      Rect update(int idx1, int idx2, int value) {
        switch ((idx1 << 1) | idx2) {
          case 0:
            return new Rect(value, y1, x2, y2);
          case 1:
            return new Rect(x1, value, x2, y2);
          case 2:
            return new Rect(x1, y1, value, y2);
          case 3:
            return new Rect(x1, y1, x2, value);
        }
        return null;
      }

      boolean valid(Rect o) {
        if (x2 < o.x1) return true;
        if (y2 < o.y1) return true;
        if (o.x2 < x1) return true;
        if (o.y2 < y1) return true;
        return false;
      }

      boolean in(Rect o) {
        return o.x1 <= x1 && x2 <= o.x2
            && o.y1 <= y1 && y2 <= o.y2;
      }

      boolean equals(Rect o) {
        return x1 == o.x1 && y1 == o.y1
            && x2 == o.x2 && y2 == o.y2;
      }

      void print() {
        out.printf(""%d %d %d %d"", x1, y1, x2, y2);
      }

    }

  }

  static class QuickScanner {
    private static final int BUFFER_SIZE = 1024;
    private InputStream stream;
    private byte[] buffer;
    private int currentPostion;
    private int numberOfChars;

    public QuickScanner(InputStream stream) {
      this.stream = stream;
      this.buffer = new byte[BUFFER_SIZE];
      this.currentPostion = 0;
      this.numberOfChars = 0;
    }

    public int nextInt() {
      int c = nextNonSpaceChar();
      boolean positive = true;
      if (c == '-') {
        positive = false;
        c = nextChar();
      }
      int res = 0;
      do {
        if (c < '0' || '9' < c) throw new RuntimeException();
        res = res * 10 + c - '0';
        c = nextChar();
      } while (!isSpaceChar(c));
      return positive ? res : -res;
    }

    public int nextNonSpaceChar() {
      int res = nextChar();
      for (; isSpaceChar(res) || res < 0; res = nextChar()) ;
      return res;
    }

    public int nextChar() {
      if (numberOfChars == -1) {
        throw new RuntimeException();
      }
      if (currentPostion >= numberOfChars) {
        currentPostion = 0;
        try {
          numberOfChars = stream.read(buffer);
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
        if (numberOfChars <= 0) {
          return -1;
        }
      }
      return buffer[currentPostion++];
    }

    public boolean isSpaceChar(int c) {
      return c == ' '
          || c == '\n'
          || c == '\r'
          || c == '\t'
          || c < 0;
    }

  }

  static class QuickWriter {
    private final PrintWriter writer;

    public QuickWriter(OutputStream outputStream) {
      this.writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public QuickWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; ++i) {
        if (i > 0) {
          writer.print(' ');
        }
        writer.print(objects[i]);
      }
    }

    public void println(Object... objects) {
      print(objects);
      writer.print('\n');
    }

    public void printf(String format, Object... objects) {
      writer.printf(format, objects);
    }

    public void close() {
      writer.close();
    }

    public void flush() {
      writer.flush();
    }

  }
}

",0713_B,CODEFORCES,1036,Searching Rectangles,"Filya just learned new geometry object — rectangle. He is given a field consisting of n × n unit cells. Rows are numbered from bottom to top with integer from 1 to n. Columns are numbered from left to right with integers from 1 to n. Cell, located at the intersection of the row r and column c is denoted as (r, c). Filya has painted two rectangles, such that their sides are parallel to coordinate axes and each cell lies fully inside or fully outside each of them. Moreover, no cell lies in both rectangles.
Later, hedgehog Filya became interested in the location of his rectangles but was unable to find the sheet of paper they were painted on. They were taken by Sonya and now she wants to play a little game with Filya. He tells her a query rectangle and she replies with the number of initial rectangles that lie fully inside the given query rectangle. The query rectangle should match the same conditions as initial rectangles. Rectangle lies fully inside the query if each o its cells lies inside the query.
Filya knows Sonya really well, so is sure that if he asks more than 200 questions she will stop to reply.
The first line of the input contains an integer n (2 ≤ n ≤ 216) — size of the field.
For each query an integer between 0 and 2 is returned — the number of initial rectangles that lie fully inside the query rectangle.
To make a query you have to print ""? x1 y1 x2 y2"" (without quotes) (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n), where (x1, y1) stands for the position of the bottom left cell of the query and (x2, y2) stands for the up right cell of the query. You are allowed to ask no more than 200 queries. After each query you should perform ""flush"" operation and read the answer.
In case you suppose you've already determined the location of two rectangles (or run out of queries) you should print ""! x11 y11 x12 y12 x21 y21 x22 y22"" (without quotes), where first four integers describe the bottom left and up right cells of the first rectangle, and following four describe the corresponding cells of the second rectangle. You can print the rectangles in an arbitrary order. After you have printed the answer, print the end of the line and perform ""flush"". Your program should terminate immediately after it print the answer.
To flush you can use (just after printing an integer and end-of-line): 
You will get the Wrong Answer verdict if you ask more than 200 queries, or if you print an incorrect coordinates.
You will get the Idleness Limit Exceeded verdict if you don't print anything (but you should) or if you forget about flushing the output (more info below).
Hacking.
The first line should contain an integer n (2 ≤ n ≤ 216).
","input
The second line should contain four integers x1, y1, x2, y2 (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n) — the description of the first rectangle.
output
The third line contains the description of the second rectangle in the similar way.
","binarysearch, constructivealgorithms, interactive",2
"import java.util.*;
import java.io.*;
public class CodehorsesTshirts {
    
    
    
    /************************ SOLUTION STARTS HERE ************************/
    
    
    private static void solve() {
        
        
        int n = nextInt();
        
        HashMap<String, Integer> a = new HashMap<>();
        HashMap<String, Integer> b = new HashMap<>();
        
        for(int i = 0; i < n; i++)
            a.merge(nextLine(), 1, Integer::sum);
        
        for(int i = 0; i < n; i++)
            b.merge(nextLine(), 1, Integer::sum);
        
        b.forEach((k , v) -> {
            if(a.containsKey(k))
                a.put(k, a.get(k) - Math.min(v , a.get(k)));
        });
        
        int cost = a.values().stream().reduce(0, Integer::sum);
        
        println(cost);  
        
    }
    
    
    
    /************************ SOLUTION ENDS HERE ************************/
    
    
    
    
    
    /************************ TEMPLATE STARTS HERE **********************/
    
    public static void main(String[] args) throws IOException {
        reader = new BufferedReader(new InputStreamReader(System.in));
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), false);
        st     = null;
        solve();
        reader.close();
        writer.close();
    }
    
    static BufferedReader reader;
    static PrintWriter    writer;
    static StringTokenizer st;
    
    static String next()
    {while(st == null || !st.hasMoreTokens()){try{String line = reader.readLine();if(line == null){return null;}            
    st = new StringTokenizer(line);}catch (Exception e){throw new RuntimeException();}}return st.nextToken();}
    static String nextLine()  {String s=null;try{s=reader.readLine();}catch(IOException e){e.printStackTrace();}return s;}             
    static int    nextInt()   {return Integer.parseInt(next());}
    static long   nextLong()  {return Long.parseLong(next());}     
    static double nextDouble(){return Double.parseDouble(next());}
    static char   nextChar()  {return next().charAt(0);}
    static int[]  nextIntArray(int n)         {int[] a= new int[n];   int i=0;while(i<n){a[i++]=nextInt();}  return a;}
    static long[] nextLongArray(int n)        {long[]a= new long[n];  int i=0;while(i<n){a[i++]=nextLong();} return a;}    
    static int[]  nextIntArrayOneBased(int n) {int[] a= new int[n+1]; int i=1;while(i<=n){a[i++]=nextInt();} return a;}            
    static long[] nextLongArrayOneBased(int n){long[]a= new long[n+1];int i=1;while(i<=n){a[i++]=nextLong();}return a;}            
    static void   print(Object o)  { writer.print(o);  }
    static void   println(Object o){ writer.println(o);}
    
    /************************ TEMPLATE ENDS HERE ************************/
    
}",1000_A,CODEFORCES,1942,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation",3
"// Don't place your source in a package
import javax.swing.*;
import java.lang.reflect.Array;
import java.text.DecimalFormat;
import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;
import java.util.stream.Stream;


// Please name your class Main
public class Main {
    static FastScanner fs=new FastScanner();
    static class FastScanner {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=new StringTokenizer("""");
        public String next() {
            while (!st.hasMoreElements())
                try {
                    st=new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            return st.nextToken();
        }
        int Int() {
            return Integer.parseInt(next());
        }

        long Long() {
            return Long.parseLong(next());
        }

        String Str(){
            return next();
        }
    }


    public static void main (String[] args) throws java.lang.Exception {
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T=1;
        for(int t=0;t<T;t++){
            int n=Int();
            int k=Int();
            int A[][]=new int[n][2];
            int a=0,b=0,c=0;
            for(int i=0;i<A.length;i++){
                A[i][0]=Int();
                A[i][1]=Int()-1;

                if(A[i][1]==0)a++;
                else if(A[i][1]==1)b++;
                else c++;
            }
            Solution sol=new Solution(out);
            sol.solution(A,k,a,b,c);
        }
        out.close();

    }


    public static int Int(){
        return fs.Int();
    }
    public static long Long(){
        return fs.Long();
    }
    public static String Str(){
        return fs.Str();
    }

}






class Solution{
    PrintWriter out;
    public Solution(PrintWriter out){
        this.out=out;
    }



    int mod=1000000007;
    long dp3[][][][];
    public void solution(int A[][],int T,int x,int y,int z){
        long res=0;
        int n=A.length;
        long dp1[][]=new long[x+1][T+1];//a
        long dp2[][][]=new long[y+1][z+1][T+1];//bc
        dp3=new long[x+2][y+2][z+2][3];


        //System.out.println(x+"" ""+y+"" ""+z);

        //init
        long f[]=new long[n+10];
        f[0]=f[1]=1;
        for(int i=2;i<f.length;i++){
            f[i]=f[i-1]*i;
            f[i]%=mod;
        }
        for(int i=0;i<dp3.length;i++){
            for(int j=0;j<dp3[0].length;j++){
                for(int k=0;k<dp3[0][0].length;k++){
                    Arrays.fill(dp3[i][j][k],-1);
                }
            }
        }


        dp1[0][0]=1;
        long newdp1[][]=new long[dp1.length][dp1[0].length];
        for(int i=0;i<A.length;i++){//a
            int p=A[i][0],type=A[i][1];
            if(type==0){

                for(int cnt=1;cnt<=x;cnt++){
                    for(int j=1;j<dp1[0].length;j++){
                        if(j>=p){
                            newdp1[cnt][j]+=dp1[cnt-1][j-p];
                            newdp1[cnt][j]%=mod;
                        }
                    }
                }

                for(int cnt=0;cnt<=x;cnt++){
                    for(int j=0;j<dp1[0].length;j++){
                        dp1[cnt][j]+=newdp1[cnt][j];
                        dp1[cnt][j]%=mod;
                        newdp1[cnt][j]=0;
                    }
                }
            }
        }


        dp2[0][0][0]=1;
        long newdp2[][][]=new long[dp2.length][dp2[0].length][dp2[0][0].length];


        for(int i=0;i<A.length;i++){//b c
            int p=A[i][0],type=A[i][1];
            if(type!=0){
                for(int a=0;a<dp2.length;a++){
                    for(int b=0;b<dp2[0].length;b++){
                        for(int j=0;j<dp2[0][0].length;j++){
                            if(j>=p){
                                if(type==1){
                                    if(a-1>=0){
                                        newdp2[a][b][j]+=dp2[a-1][b][j-p];
                                    }
                                }
                                else{
                                    if(b-1>=0) {
                                        newdp2[a][b][j]+=dp2[a][b-1][j-p];
                                    }
                                }
                            }
                            newdp2[a][b][j]%=mod;
                        }
                    }
                }

                for(int a=0;a<dp2.length;a++){
                    for(int b=0;b<dp2[0].length;b++){
                        for(int j=0;j<dp2[0][0].length;j++){
                            dp2[a][b][j]+=newdp2[a][b][j];
                            dp2[a][b][j]%=mod;
                            newdp2[a][b][j]=0;
                        }
                    }
                }
            }//type!=0
        }


        dp3[1][0][0][0]=1;
        dp3[0][1][0][1]=1;
        dp3[0][0][1][2]=1;
        for(int i=0;i<dp3.length;i++){
            for(int j=0;j<dp3[0].length;j++){
                for(int k=0;k<dp3[0][0].length;k++){
                    for(x=0;x<dp3[0][0][0].length;x++){
                        if(dp3[i][j][k][x]==-1){
                            dfs(i,j,k,x);
                        }
                    }
                }
            }
        }

        for(int i=0;i<dp3.length-1;i++){
            for(int j=0;j<dp3[0].length-1;j++){
                for(int k=0;k<dp3[0][0].length-1;k++){
                    for(int cur=0;cur<3;cur++){
                        for(int t=0;t<=T;t++){//price
                            int aprice=t;
                            int bcprice=T-t;
                            long cnt1=dp1[i][aprice];
                            long cnt2=dp2[j][k][bcprice];
                            long combination=dp3[i][j][k][cur];
                            long p1=(cnt1*f[i])%mod;
                            long p2=(((f[j]*f[k])%mod)*cnt2)%mod;
                            long p3=(p1*p2)%mod;
                            res+=(p3*combination)%mod;
                            res%=mod;

                        }
                    }
                }
            }
        }
        out.println(res);

    }

    public long dfs(int a,int b,int c,int cur){
        if(a<0||b<0||c<0){
            return 0;
        }
        if(a==0&&b==0&&c==0){
            return 0;
        }

        if(dp3[a][b][c][cur]!=-1)return dp3[a][b][c][cur];

        long res=0;
        if(cur==0){
            res+=dfs(a-1,b,c,1);
            res%=mod;
            res+=dfs(a-1,b,c,2);
            res%=mod;

        }
        else if(cur==1){
            res+=dfs(a,b-1,c,0);
            res%=mod;
            res+=dfs(a,b-1,c,2);
            res%=mod;
        }
        else{
            res+=dfs(a,b,c-1,0);
            res%=mod;
            res+=dfs(a,b,c-1,1);
            res%=mod;
        }
        res%=mod;
        dp3[a][b][c][cur]=res;
        return res;
    }

}












/*
                             ;\
                            |' \
         _                  ; : ;
        / `-.              /: : |
       |  ,-.`-.          ,': : |
       \  :  `. `.       ,'-. : |
        \ ;    ;  `-.__,'    `-.|
         \ ;   ;  :::  ,::'`:.  `.
          \ `-. :  `    :.    `.  \
           \   \    ,   ;   ,:    (\
            \   :., :.    ,'o)): ` `-.
           ,/,' ;' ,::""'`.`---'   `.  `-._
         ,/  :  ; '""      `;'          ,--`.
        ;/   :; ;             ,:'     (   ,:)
          ,.,:.    ; ,:.,  ,-._ `.     \""""'/
          '::'     `:'`  ,'(  \`._____.-'""'
             ;,   ;  `.  `. `._`-.  \\
             ;:.  ;:       `-._`-.\  \`.
              '`:. :        |' `. `\  ) \
      -hrr-      ` ;:       |    `--\__,'
                   '`      ,'
                        ,-'


                      free bug dog
*/


/*
5 3
1 1
2 1
2 1
2 1
2 2
 */",1185_G2,CODEFORCES,4060,Playlist for Polycarp (hard version),"The only difference between easy and hard versions is constraints.
Polycarp loves to listen to music, so he never leaves the player, even on the way home from the university. Polycarp overcomes the distance from the university to the house in exactly $$$T$$$ minutes.
In the player, Polycarp stores $$$n$$$ songs, each of which is characterized by two parameters: $$$t_i$$$ and $$$g_i$$$, where $$$t_i$$$ is the length of the song in minutes ($$$1 \le t_i \le 50$$$), $$$g_i$$$ is its genre ($$$1 \le g_i \le 3$$$).
Polycarp wants to create such a playlist so that he can listen to music all the time on the way from the university to his home, and at the time of his arrival home, the playlist is over. Polycarp never interrupts songs and always listens to them from beginning to end. Thus, if he started listening to the $$$i$$$-th song, he would spend exactly $$$t_i$$$ minutes on its listening. Polycarp also does not like when two songs of the same genre play in a row (i.e. successively/adjacently) or when the songs in his playlist are repeated.
Help Polycarpus count the number of different sequences of songs (their order matters), the total duration is exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different.
The first line of the input contains two integers $$$n$$$ and $$$T$$$ ($$$1 \le n \le 50, 1 \le T \le 2500$$$) — the number of songs in the player and the required total duration, respectively.
Next, the $$$n$$$ lines contain descriptions of songs: the $$$i$$$-th line contains two integers $$$t_i$$$ and $$$g_i$$$ ($$$1 \le t_i \le 50, 1 \le g_i \le 3$$$) — the duration of the $$$i$$$-th song and its genre, respectively.
Output one integer — the number of different sequences of songs, the total length of exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different. Since the answer may be huge, output it modulo $$$10^9 + 7$$$ (that is, the remainder when dividing the quantity by $$$10^9 + 7$$$).
In the first example, Polycarp can make any of the $$$6$$$ possible playlist by rearranging the available songs: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$ and $$$[3, 2, 1]$$$ (indices of the songs are given).
","input
In the second example, the first and second songs cannot go in succession (since they have the same genre). Thus, Polycarp can create a playlist in one of $$$2$$$ possible ways: $$$[1, 3, 2]$$$ and $$$[2, 3, 1]$$$ (indices of the songs are given).
output
In the third example, Polycarp can make the following playlists: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$, $$$[3, 2, 1]$$$, $$$[1, 4]$$$, $$$[4, 1]$$$, $$$[2, 3, 4]$$$ and $$$[4, 3, 2]$$$ (indices of the songs are given).
","combinatorics, dp",6
"import java.util.*;
public class Hexadecimal {
 public static void main(String args[]){
	 Scanner input = new Scanner(System.in);
	 int n = input.nextInt();
	 System.out.print(""0 0 "" + n);
 }
}
",0199_A,CODEFORCES,187,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;
import java.util.StringTokenizer;

public class Contest {

	static final Random random = new Random();

	static PrintWriter out = new PrintWriter(System.out);

	public static void main(String[] args) throws FileNotFoundException {
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt(), m = sc.nextInt();
		ArrayList<Integer> xn = new ArrayList<>(), xm = new ArrayList<>();

		for (int i = 0; i < n; i++)
			xn.add(sc.nextInt());

		for (int i = 0; i < m; i++) {
			int x1 = sc.nextInt();
			int x2 = sc.nextInt();
			sc.nextInt();
			if (x1 != 1)
				continue;
			xm.add(x2);
		}

		Collections.sort(xn);
		Collections.sort(xm);

		int p = 0;
		int min = Integer.MAX_VALUE;
		m = xm.size();
		int next = 0;
		if (n == 0) {
			next = (int) 1e9;
		} else {
			next = xn.get(0);
		}
		p = bs(xm, next);
		if (p == -1)
			p = m;
		min = m - p;
		for (int i = 0; i < n; i++) {
			if (n - 1 == i)
				next = (int) 1e9;
			else
				next = xn.get(i + 1);
			p = bs(xm, next);
			if (p == -1)
				p = m;
			min = Math.min(min, i + 1 + m - p);
		}

		out.println(min);

		out.flush();
	}

	static int bs(ArrayList<Integer> a, int x) {
		int l = 0, r = a.size() - 1, ans = -1;

		while (l <= r) {
			int mid = l + (r - l) / 2;
			if (a.get(mid) >= x) {
				ans = mid;
				r = mid - 1;
			} else
				l = mid + 1;
		}
		return ans;
	}

	static void Arrayssort(int[] a) {
		int n = a.length;// shuffle, then sort
		for (int i = 0; i < n; i++) {
			int oi = random.nextInt(n);
			int temp = a[oi];
			a[oi] = a[i];
			a[i] = temp;
		}
		java.util.Arrays.sort(a);
	}

	private static class Scanner {
		public BufferedReader reader;
		public StringTokenizer st;

		public Scanner(InputStream file) throws FileNotFoundException {
			reader = new BufferedReader(new InputStreamReader(file));
			st = null;
		}

		public String next() {
			while (st == null || !st.hasMoreTokens()) {
				try {
					String line = reader.readLine();
					if (line == null)
						return null;
					st = new StringTokenizer(line);
				} catch (Exception e) {
					throw (new RuntimeException());
				}
			}
			return st.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public String nextLine() throws IOException {
			return reader.readLine();
		}
	}

}",1075_C,CODEFORCES,2892,The Tower is Going Home,"On a chessboard with a width of $$$10^9$$$ and a height of $$$10^9$$$, the rows are numbered from bottom to top from $$$1$$$ to $$$10^9$$$, and the columns are numbered from left to right from $$$1$$$ to $$$10^9$$$. Therefore, for each cell of the chessboard you can assign the coordinates $$$(x,y)$$$, where $$$x$$$ is the column number and $$$y$$$ is the row number.
Every day there are fights between black and white pieces on this board. Today, the black ones won, but at what price? Only the rook survived, and it was driven into the lower left corner — a cell with coordinates $$$(1,1)$$$. But it is still happy, because the victory has been won and it's time to celebrate it! In order to do this, the rook needs to go home, namely — on the upper side of the field (that is, in any cell that is in the row with number $$$10^9$$$).
Everything would have been fine, but the treacherous white figures put spells on some places of the field before the end of the game. There are two types of spells: 
Let's recall that the rook is a chess piece that in one move can move to any point that is in the same row or column with its initial position. In our task, the rook can move from the cell $$$(r_0,c_0)$$$ into the cell $$$(r_1,c_1)$$$ only under the condition that $$$r_1 = r_0$$$ or $$$c_1 = c_0$$$ and there is no blocking lines or blocking segments between these cells (For better understanding, look at the samples).
Fortunately, the rook can remove spells, but for this it has to put tremendous efforts, therefore, it wants to remove the minimum possible number of spells in such way, that after this it can return home. Find this number!
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$0 \le n,m \le 10^5$$$) — the number of vertical and horizontal spells.
Each of the following $$$n$$$ lines contains one integer $$$x$$$ ($$$1 \le x < 10^9$$$) — the description of the vertical spell. It will create a blocking line between the columns of $$$x$$$ and $$$x+1$$$.
Each of the following $$$m$$$ lines contains three integers $$$x_1$$$, $$$x_2$$$ and $$$y$$$ ($$$1 \le x_{1} \le x_{2} \le 10^9$$$, $$$1 \le y < 10^9$$$) — the numbers that describe the horizontal spell. It will create a blocking segment that passes through the top sides of the cells that are in the row with the number $$$y$$$, in columns from $$$x_1$$$ to $$$x_2$$$ inclusive.
It is guaranteed that all spells are different, as well as the fact that for each pair of horizontal spells it is true that the segments that describe them do not have common points.
In a single line print one integer — the minimum number of spells the rook needs to remove so it can get from the cell $$$(1,1)$$$ to at least one cell in the row with the number $$$10^9$$$
In the first sample, in order for the rook return home, it is enough to remove the second horizontal spell.
In the second sample, in order for the rook to return home, it is enough to remove the only vertical spell. If we tried to remove just one of the horizontal spells, it would not allow the rook to get home, because it would be blocked from above by one of the remaining horizontal spells (either first one or second one), and to the right it would be blocked by a vertical spell.
In the third sample, we have two horizontal spells that go through the whole field. These spells can not be bypassed, so we need to remove both of them.
","input
In the fourth sample, we have no spells, which means that we do not need to remove anything.
output
In the fifth example, we can remove the first vertical and third horizontal spells.
",twopointers,4
"//package educational.round049;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class F {
	InputStream is;
	PrintWriter out;
	String INPUT = """";
	
	void solve()
	{
		int n = ni();
		int[] a = na(2*n);
		int[] b = Arrays.copyOf(a, 2*n);
		int[] imap = shrinkX(b);
		if(!ok(imap.length-1, b)){
			out.println(-1);
			return;
		}
		int low = -1, high = imap.length;
		while(high - low > 1){
			int h = high+low>>1;
			if(ok(h, b)){
				high = h;
			}else{
				low = h;
			}
		}
		out.println(imap[high]);
	}
	
	boolean ok(int h, int[] b)
	{
		int n = b.length/2;
		DJSet ds = new DJSet(2*n);
		for(int i = 0;i < n;i++){
			if(b[2*i] > h)return false;
			if(b[2*i+1] > h){
				if(++ds.cycle[ds.root(b[2*i])] >= 2)return false;
			}else{
				if(ds.union(b[2*i], b[2*i+1])){
					if(++ds.cycle[ds.root(b[2*i])] >= 2)return false;
				}else{
					if(ds.cycle[ds.root(b[2*i])] >= 2)return false;
				}
			}
		}
		return true;
	}
	
	public static class DJSet {
		public int[] upper;
		public int[] cycle;

		public DJSet(int n) {
			upper = new int[n];
			Arrays.fill(upper, -1);
			cycle = new int[n];
		}

		public int root(int x) {
			return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
		}

		public boolean equiv(int x, int y) {
			return root(x) == root(y);
		}

		public boolean union(int x, int y) {
			x = root(x);
			y = root(y);
			if (x != y) {
				if (upper[y] < upper[x]) {
					int d = x;
					x = y;
					y = d;
				}
				upper[x] += upper[y];
				upper[y] = x;
				
				cycle[x] += cycle[y];
			}
			return x == y;
		}

		public int count() {
			int ct = 0;
			for (int u : upper)
				if (u < 0)
					ct++;
			return ct;
		}
	}

	
	public static int[] shrinkX(int[] a) {
		int n = a.length;
		long[] b = new long[n];
		for (int i = 0; i < n; i++)
			b[i] = (long) a[i] << 32 | i;
		Arrays.sort(b);
		int[] ret = new int[n];
		int p = 0;
		ret[0] = (int) (b[0] >> 32);
		for (int i = 0; i < n; i++) {
			if (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0) {
				p++;
				ret[p] = (int) (b[i] >> 32);
			}
			a[(int) b[i]] = p;
		}
		return Arrays.copyOf(ret, p + 1);
	}

	
	void run() throws Exception
	{
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception { new F().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",1027_F,CODEFORCES,3296,Session in BSU,"Polycarp studies in Berland State University. Soon he will have to take his exam. He has to pass exactly $$$n$$$ exams.
For the each exam $$$i$$$ there are known two days: $$$a_i$$$ — day of the first opportunity to pass the exam, $$$b_i$$$ — day of the second opportunity to pass the exam ($$$a_i < b_i$$$). Polycarp can pass at most one exam during each day. For each exam Polycarp chooses by himself which day he will pass this exam. He has to pass all the $$$n$$$ exams.
Polycarp wants to pass all the exams as soon as possible. Print the minimum index of day by which Polycarp can pass all the $$$n$$$ exams, or print -1 if he cannot pass all the exams at all.
The first line of the input contains one integer $$$n$$$ ($$$1 \le n \le 10^6$$$) — the number of exams.
","input
The next $$$n$$$ lines contain two integers each: $$$a_i$$$ and $$$b_i$$$ ($$$1 \le a_i < b_i \le 10^9$$$), where $$$a_i$$$ is the number of day of the first passing the $$$i$$$-th exam and $$$b_i$$$ is the number of day of the second passing the $$$i$$$-th exam.
output
If Polycarp cannot pass all the $$$n$$$ exams, print -1. Otherwise print the minimum index of day by which Polycarp can do that.
","binarysearch, dfsandsimilar, dsu, graphmatchings, graphs",5
"import java.util.*;
import java.lang.*;
import java.io.*;

public class Main
{
	static final int MOD = (int)1e9 + 7;
	static int n;
	static int[] t;
	static int[] g;	
	static int[][] memo;
	
	static int dp(int mask, int rem, int last)
	{
		if(rem == 0)
			return 1;
		if(memo[last][mask] != -1)
			return memo[last][mask];
		
		int ans = 0;
		for(int i = 0; i < n; i++)
		{
			if((mask & (1 << i)) == 0 && rem >= t[i] && g[i] != last)
				ans += dp(mask | 1 << i, rem - t[i], g[i]);
			
			if(ans >= MOD)
				ans -= MOD;
		}
		
		return memo[last][mask] = ans;
	}
	
	public static void main (String[] args) throws java.lang.Exception
	{
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		
		n = in.nextInt();
		int T = in.nextInt();
		
		t = new int[n];
		g = new int[n];
		
		for(int i = 0; i < n; i++)
		{
			t[i] = in.nextInt();
			g[i] = in.nextInt() - 1;
		}
		
		memo = new int[4][1 << n];
		for(int []x : memo)
		{
			Arrays.fill(x, -1);
		}
		
		out.println(dp(0, T, 3));
		out.close();
	}
	
	static class InputReader
	{
		BufferedReader reader;
		StringTokenizer tokenizer;
		
		public InputReader(InputStream stream)
		{
			reader = new BufferedReader(new InputStreamReader(stream), 32768);
			tokenizer = null;
		}
		
		public String next()
		{
			while(tokenizer == null || !tokenizer.hasMoreTokens())
			{
				try
				{
					tokenizer = new StringTokenizer(reader.readLine());
				}
				catch(IOException e)
				{
					throw new RuntimeException(e);
				}
			}
			
			return tokenizer.nextToken();
		}
		
		public int nextInt()
		{
			return Integer.parseInt(next());
		}
	}
}",1185_G1,CODEFORCES,4723,Playlist for Polycarp (easy version),"The only difference between easy and hard versions is constraints.
Polycarp loves to listen to music, so he never leaves the player, even on the way home from the university. Polycarp overcomes the distance from the university to the house in exactly $$$T$$$ minutes.
In the player, Polycarp stores $$$n$$$ songs, each of which is characterized by two parameters: $$$t_i$$$ and $$$g_i$$$, where $$$t_i$$$ is the length of the song in minutes ($$$1 \le t_i \le 15$$$), $$$g_i$$$ is its genre ($$$1 \le g_i \le 3$$$).
Polycarp wants to create such a playlist so that he can listen to music all the time on the way from the university to his home, and at the time of his arrival home, the playlist is over. Polycarp never interrupts songs and always listens to them from beginning to end. Thus, if he started listening to the $$$i$$$-th song, he would spend exactly $$$t_i$$$ minutes on its listening. Polycarp also does not like when two songs of the same genre play in a row (i.e. successively/adjacently) or when the songs in his playlist are repeated.
Help Polycarpus count the number of different sequences of songs (their order matters), the total duration is exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different.
The first line of the input contains two integers $$$n$$$ and $$$T$$$ ($$$1 \le n \le 15, 1 \le T \le 225$$$) — the number of songs in the player and the required total duration, respectively.
Next, the $$$n$$$ lines contain descriptions of songs: the $$$i$$$-th line contains two integers $$$t_i$$$ and $$$g_i$$$ ($$$1 \le t_i \le 15, 1 \le g_i \le 3$$$) — the duration of the $$$i$$$-th song and its genre, respectively.
Output one integer — the number of different sequences of songs, the total length of exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different. Since the answer may be huge, output it modulo $$$10^9 + 7$$$ (that is, the remainder when dividing the quantity by $$$10^9 + 7$$$).
In the first example, Polycarp can make any of the $$$6$$$ possible playlist by rearranging the available songs: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$ and $$$[3, 2, 1]$$$ (indices of the songs are given).
","input
In the second example, the first and second songs cannot go in succession (since they have the same genre). Thus, Polycarp can create a playlist in one of $$$2$$$ possible ways: $$$[1, 3, 2]$$$ and $$$[2, 3, 1]$$$ (indices of the songs are given).
output
In the third example, Polycarp can make the following playlists: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$, $$$[3, 2, 1]$$$, $$$[1, 4]$$$, $$$[4, 1]$$$, $$$[2, 3, 4]$$$ and $$$[4, 3, 2]$$$ (indices of the songs are given).
","bitmasks, combinatorics, dp",7
"import java.io.*;
import java.util.*;

public class C
{	
	static long mod=(long)(1e9+7);
	public static long powMod(long e,long b)
	{
		/*e=e%mod;*/
		long res=1;
		
		while(e>0)
		{
			if(e%2==1)
				res=res*b%mod;
			e/=2;
			b=b*b%mod;
		}
		return res;
	}

		public static void main(String[] args) throws IOException 
		{
			Scanner sc=new Scanner(System.in);
			PrintWriter pw=new PrintWriter(System.out);
			long x=sc.nextLong(),k=sc.nextLong();
			if(x==0)
			{
				System.out.println(0);
				return;
			}
			
			if(k==0)
			{
				pw.println((2*x)%mod);
				
				
				pw.close();return;
			}
			
			long ans=2*x-1;
			ans=ans%mod;
			
			long b=powMod(k,2);
			ans=((ans*b)+1)%mod;
			
			
			pw.println(ans);
			
			pw.close();
		
			
		}
		
		
	static class Scanner
	{
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}
		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}
		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public boolean ready() throws IOException {
			return br.ready();
		}
	}
}",0992_C,CODEFORCES,1156,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import java.util.*;
import java.io.*;
public class D {
    static class Scan {
        private byte[] buf=new byte[1024];
        private int index;
        private InputStream in;
        private int total;
        public Scan()
        {
            in=System.in;
        }
        public int scan()throws IOException
        {
            if(total<0)
            throw new InputMismatchException();
            if(index>=total)
            {
                index=0;
                total=in.read(buf);
                if(total<=0)
                return -1;
            }
            return buf[index++];
        }
        public int scanInt()throws IOException
        {
            int integer=0;
            int n=scan();
            while(isWhiteSpace(n))
            n=scan();
            int neg=1;
            if(n=='-')
            {
                neg=-1;
                n=scan();
            }
            while(!isWhiteSpace(n))
            {
                if(n>='0'&&n<='9')
                {
                    integer*=10;
                    integer+=n-'0';
                    n=scan();
                }
                else throw new InputMismatchException();
            }
            return neg*integer;
        }
        public double scanDouble()throws IOException
        {
            double doub=0;
            int n=scan();
            while(isWhiteSpace(n))
            n=scan();
            int neg=1;
            if(n=='-')
            {
                neg=-1;
                n=scan();
            }
            while(!isWhiteSpace(n)&&n!='.')
            {
                if(n>='0'&&n<='9')
                {
                    doub*=10;
                    doub+=n-'0';
                    n=scan();
                }
                else throw new InputMismatchException();
            }
            if(n=='.')
            {
                n=scan();
                double temp=1;
                while(!isWhiteSpace(n))
                {
                    if(n>='0'&&n<='9')
                    {
                        temp/=10;
                        doub+=(n-'0')*temp;
                        n=scan();
                    }
                    else throw new InputMismatchException();
                }
            }
            return doub*neg;
        }
        public String scanString()throws IOException
        {
            StringBuilder sb=new StringBuilder();
            int n=scan();
            while(isWhiteSpace(n))
            n=scan();
            while(!isWhiteSpace(n))
            {
                sb.append((char)n);
                n=scan();
            }
            return sb.toString();
        }
        private boolean isWhiteSpace(int n)
        {
            if(n==' '||n=='\n'||n=='\r'||n=='\t'||n==-1)
            return true;
            return false;
        }
    }
    
    public static void sort(int arr[],int l,int r) {    //sort(arr,0,n-1);
        if(l==r) {
            return;
        }
        int mid=(l+r)/2;
        sort(arr,l,mid);
        sort(arr,mid+1,r);
        merge(arr,l,mid,mid+1,r);
    }
    public static void merge(int arr[],int l1,int r1,int l2,int r2) {
        int tmp[]=new int[r2-l1+1];
        int indx1=l1,indx2=l2;
        //sorting the two halves using a tmp array
        for(int i=0;i<tmp.length;i++) {
            if(indx1>r1) {
                tmp[i]=arr[indx2];
                indx2++;
                continue;
            }
            if(indx2>r2) {
                tmp[i]=arr[indx1];
                indx1++;
                continue;
            }
            if(arr[indx1]<arr[indx2]) {
                tmp[i]=arr[indx1];
                indx1++;
                continue;
            }
            tmp[i]=arr[indx2];
            indx2++;
        }
        //Copying the elements of tmp into the main array
        for(int i=0,j=l1;i<tmp.length;i++,j++) {
            arr[j]=tmp[i];
        }
    }
    
    public static void sort(long arr[],int l,int r) {    //sort(arr,0,n-1);
        if(l==r) {
            return;
        }
        int mid=(l+r)/2;
        sort(arr,l,mid);
        sort(arr,mid+1,r);
        merge(arr,l,mid,mid+1,r);
    }
    public static void merge(long arr[],int l1,int r1,int l2,int r2) {
        long tmp[]=new long[r2-l1+1];
        int indx1=l1,indx2=l2;
        //sorting the two halves using a tmp array
        for(int i=0;i<tmp.length;i++) {
            if(indx1>r1) {
                tmp[i]=arr[indx2];
                indx2++;
                continue;
            }
            if(indx2>r2) {
                tmp[i]=arr[indx1];
                indx1++;
                continue;
            }
            if(arr[indx1]<arr[indx2]) {
                tmp[i]=arr[indx1];
                indx1++;
                continue;
            }
            tmp[i]=arr[indx2];
            indx2++;
        }
        //Copying the elements of tmp into the main array
        for(int i=0,j=l1;i<tmp.length;i++,j++) {
            arr[j]=tmp[i];
        }
    }
    
    static int n,m,k,uu[][],rr[][],dd[][],ll[][],dp[][][];
    
    public static void main(String args[]) throws IOException {
        Scan input=new Scan();
        StringBuilder ans=new StringBuilder("""");
        
        n=input.scanInt();
        m=input.scanInt();
        k=input.scanInt();
        
        dp=new int[n][m][k];
        for(int i=0;i<n;i++) {
            for(int j=0;j<m;j++) {
                for(int kk=0;kk<k;kk++) {
                    dp[i][j][kk]=-1;
                }
            }
        }
        
        uu=new int[n][m];
        rr=new int[n][m];
        dd=new int[n][m];
        ll=new int[n][m];
        
        for(int i=0;i<n;i++) {
            for(int j=0;j<m-1;j++) {
                int tmp=input.scanInt();
                rr[i][j]=tmp;
                ll[i][j+1]=tmp;
            }
        }
        
        for(int i=0;i<n-1;i++) {
            for(int j=0;j<m;j++) {
                int tmp=input.scanInt();
                dd[i][j]=tmp;
                uu[i+1][j]=tmp;
            }
        }
        
        for(int i=0;i<n;i++) {
            for(int j=0;j<m;j++) {
                if(k%2!=0) {
                    ans.append(-1+"" "");
                    continue;
                }
                ans.append((2*solve(i,j,k/2))+"" "");
            }
            ans.append(""\n"");
        }
        
        System.out.println(ans);
    }
    
    public static int solve(int x,int y,int rem) {
        if(rem==0) {
            return 0;
        }
        
        if(dp[x][y][rem]!=-1) {
            return dp[x][y][rem];
        }
        
        int ans=Integer.MAX_VALUE/10;
        if(uu[x][y]!=0) {
            ans=Math.min(ans,uu[x][y]+solve(x-1,y,rem-1));
        }
        if(rr[x][y]!=0) {
            ans=Math.min(ans,rr[x][y]+solve(x,y+1,rem-1));
        }
        if(dd[x][y]!=0) {
            ans=Math.min(ans,dd[x][y]+solve(x+1,y,rem-1));
        }
        if(ll[x][y]!=0) {
            ans=Math.min(ans,ll[x][y]+solve(x,y-1,rem-1));
        }
        
        dp[x][y][rem]=ans;
        
        return ans;
    }
}
",1517_D,CODEFORCES,4162,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"/*
stream Butter!
eggyHide eggyVengeance
I need U
xiao rerun when
 */
import static java.lang.Math.max;
import static java.lang.Math.min;
import static java.lang.Math.abs;
import static java.lang.System.out;
import java.util.*;
import java.io.*;
import java.math.*;

public class x11D
{
    public static void main(String hi[]) throws Exception
    {
        int[] log = new int[1<<20];
        for(int i=0; i < 19; i++)
            log[1<<i] = i;
        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(infile.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        boolean[][] edges = new boolean[N][N];
        for(int i=0; i < M; i++)
        {
            st = new StringTokenizer(infile.readLine());
            int a = Integer.parseInt(st.nextToken())-1;
            int b = Integer.parseInt(st.nextToken())-1;
            edges[a][b] = edges[b][a] = true;
        }
        long[][] dp = new long[1<<N][N];
        for(int a=0; a < N; a++)
            for(int b=a+1; b < N; b++)
                if(edges[a][b])
                    dp[(1<<a)|(1<<b)][b] = 1L;
        long res = 0L;
        for(int mask=1; mask < 1<<N; mask++)
        {
            int small = log[mask&-mask];
            for(int a=small+1; a < N; a++)
                if((mask&(1<<a)) > 0)
                {
                    for(int b=small+1; b < N; b++)
                        if(a != b && (mask&(1<<b)) > 0 && edges[a][b])
                            dp[mask][a] += dp[mask^(1<<a)][b];
                    if(edges[small][a])
                    {
                        //System.out.println(mask+"" ""+a+"" ""+dp[mask][a]);
                        res += dp[mask][a];
                    }
                }
        }
        System.out.println((res-M)/2);
    }
}",0011_D,CODEFORCES,4373,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import static java.lang.Math.*;
import static java.util.Arrays.*;
import java.io.*;
import java.util.*;

public class Main {
    static boolean LOCAL = false;//System.getSecurityManager() == null;
    Scanner sc = new Scanner(System.in);
    
    void run() {
        char[] cs = sc.nextLine().toCharArray();
        int res = 0;
        for (int s1 = 0; s1 < cs.length; s1++) {
            for (int s2 = s1 + 1; s2 < cs.length; s2++) {
                int len = 0;
                while (s2 + len < cs.length && cs[s1 + len] == cs[s2 + len]) {
                    len++;
                }
                res = max(res, len);
            }
        }
        System.out.println(res);
    }
    
    class Scanner {
        BufferedReader br;
        StringTokenizer st;
        Scanner(InputStream in) {
            br = new BufferedReader(new InputStreamReader(in));
            eat("""");
        }
        void eat(String s) {
            st = new StringTokenizer(s);
        }
        String nextLine() {
            try {
                return br.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        boolean hasNext() {
            while (!st.hasMoreTokens()) {
                String s = nextLine();
                if (s == null) return false;
                eat(s);
            }
            return true;
        }
        String next() {
            hasNext();
            return st.nextToken();
        }
        int nextInt() {
            return Integer.parseInt(next());
        }
        long nextLong() {
            return Long.parseLong(next());
        }
        double nextDouble() {
            return Double.parseDouble(next());
        }
    }
    
    void debug(Object...os) {
        System.err.println(deepToString(os));
    }
    
    public static void main(String[] args) {
        if (LOCAL) {
            try {
                System.setIn(new FileInputStream(""in.txt""));
            } catch (Throwable e) {
                LOCAL = false;
            }
        }
        if (!LOCAL) {
            try {
                Locale.setDefault(Locale.US);
                System.setOut(new PrintStream(new BufferedOutputStream(System.out)));
            } catch (Throwable e) {
            }
        }
        new Main().run();
        System.out.flush();
    }
}
",0023_A,CODEFORCES,3782,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.util.*;
import java.io.*;

public class solve {
	Scanner in;
	PrintWriter out;

	public void solve() throws IOException {
		int n = in.nextInt();
		long k = in.nextLong();
		int[] a = new int[n];
		Set<Long> b = new TreeSet<Long>();
		for (int i = 0; i < n; i++) {
			a[i] = in.nextInt();
		}
		Arrays.sort(a);
		int ans = 0;
		for (int i = n - 1; i >= 0; i--) {
			if (!b.contains((long) k * a[i])) {
				ans++;
				b.add((long) a[i]);
			}
		}
		out.print(ans);
	}

	public void run() {
		try {
			in = new Scanner(System.in);
			out = new PrintWriter(System.out);

			solve();

			out.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		FastScanner(File f) {
			try {
				br = new BufferedReader(new FileReader(f));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		String next() {
			while (st == null || !st.hasMoreTokens()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}
	}

	public static void main(String[] arg) {
		new solve().run();
	}
}
",0274_A,CODEFORCES,2709,k-Multiple Free Set,"A k-multiple free set is a set of integers where there is no pair of integers where one is equal to another integer multiplied by k. That is, there are no two integers x and y (x < y) from the set, such that y = x·k.
You're given a set of n distinct positive integers. Your task is to find the size of it's largest k-multiple free subset.
The first line of the input contains two integers n and k (1 ≤ n ≤ 105, 1 ≤ k ≤ 109). The next line contains a list of n distinct positive integers a1, a2, ..., an (1 ≤ ai ≤ 109).
All the numbers in the lines are separated by single spaces.
","input
On the only line of the output print the size of the largest k-multiple free subset of {a1, a2, ..., an}.
output
In the sample input one of the possible maximum 2-multiple free subsets is {4, 5, 6}.
","binarysearch, greedy, sortings",4
"import java.util.*;
import java.lang.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.*;
import java.math.*;
public class Main {
    public void dfs(ArrayList<Integer>[] graph,int[] visited,int source) {
        
    }
    public static void main(String[] args) throws Exception{
        Reader.init(System.in);
        PrintWriter out = new PrintWriter(System.out);
        Main mm =new Main();
        int n=Reader.nextInt();
        int m=Reader.nextInt();
        String s=Reader.next();
        int[][] count=new int[m][m];
        for(int i=1;i<n;i++) {
            count[s.charAt(i)-'a'][s.charAt(i-1)-'a']++;
            count[s.charAt(i-1)-'a'][s.charAt(i)-'a']++;
        }
        int[] dp=new int[1<<m];
        Arrays.fill(dp, Integer.MAX_VALUE/10);
        for(int i=0;i<m;i++) {
            dp[1<<i]=0;
        }
        for(int i=0;i<(1<<m);i++) {
            int extra=0;
            for(int j=0;j<m;j++) {
                if((i&(1<<j))>0) {
                for(int k=0;k<m;k++) {
                    if(j!=k &&  (i&(1<<k))==0) {
                        extra+=count[j][k];
                    }
                }
               }
            }
            for(int j=0;j<m;j++) {
                if((i&(1<<j))==0) {
                    dp[i|(1<<j)]=Math.min(dp[i|(1<<j)], dp[i]+extra);
                }
            }
        }
        out.println(dp[(1<<m)-1]);
        out.close();
}
}
class Reader {
    static BufferedReader reader;
    static StringTokenizer tokenizer;
    /** call this method to initialize reader for InputStream */
    static void init() throws IOException {
         reader = new BufferedReader(
                 new FileReader(""input.txt""));
    tokenizer = new StringTokenizer("""");
    }
    static void init(InputStream input) {
        reader = new BufferedReader(
                     new InputStreamReader(input) );
        tokenizer = new StringTokenizer("""");
    }
    /** get next word */
    static String nextLine() throws IOException{
        return reader.readLine();
    }
    static String next() throws IOException {
        while ( ! tokenizer.hasMoreTokens() ) {
            //TODO add check for eof if necessary
            tokenizer = new StringTokenizer(
                   reader.readLine() );
        }
        return tokenizer.nextToken();
    }
    static int nextInt() throws IOException {
        return Integer.parseInt( next() );
    }
    static long nextLong() throws IOException {
        return Long.parseLong( next() );
    }
    static double nextDouble() throws IOException {
        return Double.parseDouble( next() );
    }
}",1238_E,CODEFORCES,4857,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp",7
"import java.util.Scanner;
import java.util.Arrays;

public class P166A 
{
	public static void main(String[] args) 
	{
		Scanner myScanner = new Scanner(System.in);
		int n = myScanner.nextInt();
		int k = myScanner.nextInt();
		Team[] queue = new Team[n];
		for (int i = 0; i < n; i++)
		{
			queue[i] = new Team(myScanner.nextInt(), myScanner.nextInt());
		}
		Arrays.sort(queue);
		
		int counter = 0;
		int i = 0;
		int p = -1;
		int t = -1;
		for (; i < k; i++)
		{
			if (p == queue[i].problems && t == queue[i].penalty)
				counter++;
			else
			{
				p = queue[i].problems;
				t = queue[i].penalty;
				counter = 1;
			}
		}
		for (; i < n; i++)
		{
			if (p == queue[i].problems && t == queue[i].penalty)
				counter++;
			else
				break;
		}
		System.out.println(counter);
	}

	static class Team implements Comparable<Team>
	{
		int problems;
		int penalty;
		
		public Team(int problems, int penalty)
		{
			this.problems = problems;
			this.penalty = penalty;
		}
		
		public int compareTo(Team t)
		{
			if (problems > t.problems) return -1;
			else if (problems < t.problems) return 1;
			else if (penalty > t.penalty) return 1;
			else if (penalty < t.penalty) return -1;
			else return 0;
		}
	}
}
",0166_A,CODEFORCES,2523,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class C {
	static final int M = 1000000007;	
	
	public static void main(String[] args) throws IOException{
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(in.readLine());
		
		long x = Long.parseLong(st.nextToken());
		if(x == 0){
			System.out.println(0);
			System.exit(0);
		}
		final long k = Long.parseLong(st.nextToken());	
		x = x%M;
		
		long ans = (exp(2, k+1)*x - (exp(2, k) - 1))%M;
		if(ans < 0) ans += M;
		System.out.println(ans);
		/*
		for(long i = 1234567890; i < 1234567999; i++){
			ans = (exp(2, i+1)*x - (exp(2, i) - 1))%M;
			if(ans < 0) ans += M;
			System.out.println(ans);
		}
		/*
		System.out.println((k-1)/2);
		System.out.println(x);
		System.out.println(exp(2, k));
		System.out.println(exp(2, k+1));
		*/
	}
	
	public static long exp(long a, long n){
		if(n == 0) return 1;
		if(n == 1) return a%M;
		if(n%2 == 0) return exp((a*a)%M, n/2);
		else return (a*exp((a*a)%M, (n-1)/2))%M;
	}
}
",0992_C,CODEFORCES,1204,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"/*
Roses are red
Memes are neat
All my test cases time out
Lmao yeet
*/
import java.util.*;
import java.io.*;

   public class B
   {
      public static void main(String args[]) throws Exception
      {
         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));  
         StringTokenizer st = new StringTokenizer(infile.readLine());
         int N = Integer.parseInt(st.nextToken());
         int K = Integer.parseInt(st.nextToken());
         //bin search
         //ugh I'm shafting
         long x = (long)N;
         long low = 0L;
         long high = N;
         while(low != high)
         {
            x = (low+high+1)/2;
            long add = (x*(x+1))/2;
            long y = N-x;
            if(add-y > K)
               high = x;
            else if(add-y == K)
            {
               System.out.println(y);
               break;
            }
            else
               low = x;
         }
         //run time?
      }
      public static void sort(int[] arr)
      {
         PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
         for(int a: arr)
            pq.add(a);
         for(int i=0; i < arr.length; i++)
            arr[i] = pq.poll();
      }
   }",1195_B,CODEFORCES,1426,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import java.io.*;
import java.util.*;

public class FireAgain {

    public static void main(String[] args) throws IOException {
		System.setIn(new FileInputStream(""input.txt""));
		System.setOut(new PrintStream(""output.txt""));
        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		String s[] = r.readLine().split(""\\s+"");
		int n = Integer.parseInt(s[0]);
		int m = Integer.parseInt(s[1]);
		int k = Integer.parseInt(r.readLine());
		int[][] a = new int[n][m];
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < m; j++)
				a[i][j] = Integer.MAX_VALUE;
		}
		assert k >= 1 && k < n * m;
		int max = 0;
		StringTokenizer st = new StringTokenizer(r.readLine());
		assert st.countTokens() == k;
		for(; k > 0; k--) {
			int x = Integer.parseInt(st.nextToken()) - 1;
			int y = Integer.parseInt(st.nextToken()) - 1;
			assert x >= 1 && x <= n && y >= 1 && y <= n;

			for(int i = 0; i < n; i++) {
				for(int j = 0; j < m; j++) {
					int d = Math.abs(i - x) + Math.abs(j - y);
					if(a[i][j] > d)
						a[i][j] = d;
					if(k == 1 && a[i][j] > max)
						max = a[i][j];
				}
			}
		}

		for(int i = 0; i < n; i++) {
			for(int j = 0; j < m; j++) {
				if(a[i][j] == max) {
					System.out.println((i + 1) + "" "" + (j + 1));
					return;
				}
			}
		}
    }

}
",0035_C,CODEFORCES,3843,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"import java.io.*;
import java.lang.*;
import java.util.*;

// Sachin_2961 submission //
public class CodeforcesA {


    public void solve() {
        int n = Integer.parseInt(fs.Line());
        int[]ar = new int[n];
        for(int i=0;i<n;i++)
            ar[i] = Integer.parseInt(fs.Line());
        ArrayDeque<Integer>stack = new ArrayDeque<>();
        for(int i=0;i<n;i++){
            if(ar[i] != 1){
                while (stack.peek()+1!=ar[i]){
                    stack.pop();
                }
                stack.pop();
            }
            stack.push(ar[i]);
            Iterator e = stack.descendingIterator();
            int j= 0;
            while (j < stack.size()){
                out.print(e.next());
                if( j+1 < stack.size())
                    out.print(""."");
                j++;
            }
            out.println();
        }
    }
    static boolean multipleTestCase = true; static FastScanner fs; static PrintWriter out;
    public void run(){
        fs = new FastScanner();
        out = new PrintWriter(System.out);
        int tc = (multipleTestCase)?fs.nInt():1;
        while (tc-->0)solve();
        out.flush();
        out.close();
    }
    public static void main(String[]args){
        try{
            new CodeforcesA().run();
        }catch (Exception e){
            e.printStackTrace();
        }

    }
    static class FastScanner {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=new StringTokenizer("""");
        String n() {
            while (!st.hasMoreTokens())
                try {
                    st=new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            return st.nextToken();
        }
        String Line()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
        int nInt() {return Integer.parseInt(n()); }
        long nLong() {return Long.parseLong(n());}
        int[]aI(int n){
            int[]ar = new int[n];
            for(int i=0;i<n;i++)
                ar[i] = nInt();
            return ar;
        }
    }
}",1523_C,CODEFORCES,3651,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees",5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;

/**
 * Created by Tejas on 18-10-2018.
 */
public class Main {

    static HashSet<Integer> adjList[];
    public static void main(String[]args)throws IOException{
        BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(System.in));
        StringBuilder stringBuilder=new StringBuilder();

        String temp[]=bufferedReader.readLine().split("" "");
        int V=Integer.parseInt(temp[0]);
        int E=Integer.parseInt(temp[1]);
        adjList=new HashSet[V];
        for(int i=0;i<V;i++)
            adjList[i]=new HashSet<>();
        for(int i=0;i<E;i++){
            temp=bufferedReader.readLine().split("" "");
            int x=Integer.parseInt(temp[0])-1;
            int y=Integer.parseInt(temp[1])-1;
            adjList[y].add(x);
            adjList[x].add(y);
        }
        stringBuilder.append(solve(V)+""\n"");
        System.out.println(stringBuilder);
    }

    private static long solve(int V) {

        long dp[][]=new long[(1<<V)][V];
        long count=0;
        for(int i=0;i<V;i++)
            dp[(1<<i)][i]=1;
        for(int mask=1;mask<(1<<V);mask++){
            // HW starting at pos first and ending at j.
            int first = Integer.numberOfTrailingZeros(mask);
            for(int i=0;i<V;i++){
                if((mask&(1<<i))==0 || first==i) continue;
                for (int j = 0; j < V; j++)
                    if (adjList[i].contains(j) && (mask & (1<<j))!=0)
                        dp[mask][i] += dp[mask ^ (1 << i)][j];
                //Calculating simple cycles
                if (Integer.bitCount(mask)>=3)
                    if(adjList[first].contains(i))
                        count+=dp[mask][i];
            }
        }
        return count/2;
    }
}
",0011_D,CODEFORCES,4377,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import java.io.BufferedReader;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.util.StringTokenizer;



public class Main {

	static long n , k;

	static long bs()

	{

		long lo = 1 ,hi = k, ans = -1;

		while(lo<=hi)

		{

			long mid = (lo + hi) >>1;

			long r = range(mid);

			if(r >= n)

			{

				ans = k - mid +2;

				lo = mid + 1;

			}else

			{

				hi = mid - 1;

			}

		}

		return ans;

	}

	

	static long range(long x)

	{

		return f(k) - f(x-1);

	}

	

	static long f(long x)

	{

		return (1l * x * (x+1))/2;

	}

	

	public static void main(String[] args) throws IOException 

	{

		Scanner sc = new Scanner((System.in));

		n = sc.nextLong() ; k = sc.nextLong();

		if(n==1){

			System.out.println(0);

			return;

		}

		n -= k;

		k -= 2;

		if(n<=0)

		{

			System.out.println(1);

			return;

		}

		

		

		long ans = bs() ;

		System.out.println(ans);

	}

	

	static class Scanner 

	{

		StringTokenizer st;

		BufferedReader br;

		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

		public Scanner(String s) throws FileNotFoundException {

			br = new BufferedReader(new FileReader(s));

		}

		public String next() throws IOException 

		{

			while (st == null || !st.hasMoreTokens()) 

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}

		public int nextInt() throws IOException {return Integer.parseInt(next());}

		public String nextLine() throws IOException {return br.readLine();}		

		public long nextLong() throws IOException {return Long.parseLong(next());}		

		public double nextDouble() throws IOException {return Double.parseDouble(next());}	

		public boolean ready() throws IOException {return br.ready();}

	}



}",0287_B,CODEFORCES,909,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Cf1017A {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int result = 1;
        int thomasSum = 0;
        StringTokenizer stk;
        stk = new StringTokenizer(br.readLine());
        int first = Integer.parseInt(stk.nextToken());
        int second = Integer.parseInt(stk.nextToken());
        int third = Integer.parseInt(stk.nextToken());
        int fourth = Integer.parseInt(stk.nextToken());
        thomasSum = first + second + third + fourth;
        int tmp;
        for (int i = 1; i < n; i++) {
            stk = new StringTokenizer(br.readLine());
            first = Integer.parseInt(stk.nextToken());
            second = Integer.parseInt(stk.nextToken());
            third = Integer.parseInt(stk.nextToken());
            fourth = Integer.parseInt(stk.nextToken());
            tmp = first + second + third + fourth;
            if (tmp > thomasSum)
                result++;
        }
        System.out.println(result);
    }
}",1017_A,CODEFORCES,2034,The Rank,"John Smith knows that his son, Thomas Smith, is among the best students in his class and even in his school. After the students of the school took the exams in English, German, Math, and History, a table of results was formed.
There are $$$n$$$ students, each of them has a unique id (from $$$1$$$ to $$$n$$$). Thomas's id is $$$1$$$. Every student has four scores correspond to his or her English, German, Math, and History scores. The students are given in order of increasing of their ids.
In the table, the students will be sorted by decreasing the sum of their scores. So, a student with the largest sum will get the first place. If two or more students have the same sum, these students will be sorted by increasing their ids. 
Please help John find out the rank of his son. 
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 1000$$$) — the number of students.
Each of the next $$$n$$$ lines contains four integers $$$a_i$$$, $$$b_i$$$, $$$c_i$$$, and $$$d_i$$$ ($$$0\leq a_i, b_i, c_i, d_i\leq 100$$$) — the grades of the $$$i$$$-th student on English, German, Math, and History. The id of the $$$i$$$-th student is equal to $$$i$$$.
Print the rank of Thomas Smith. Thomas's id is $$$1$$$.
","input
In the first sample, the students got total scores: $$$398$$$, $$$400$$$, $$$398$$$, $$$379$$$, and $$$357$$$. Among the $$$5$$$ students, Thomas and the third student have the second highest score, but Thomas has a smaller id, so his rank is $$$2$$$.
output
In the second sample, the students got total scores: $$$369$$$, $$$240$$$, $$$310$$$, $$$300$$$, $$$300$$$, and $$$0$$$. Among the $$$6$$$ students, Thomas got the highest score, so his rank is $$$1$$$.
",implementation,3
"import java.io.*;
import java.util.*;
/*
 * Heart beats fast
 * 		Colors and promises
 * 			How to be brave
 * 				How can I love when I am afraid...
 */
public class Main
{
	public static void main(String[] args)
	{
		long x=nl(),k=nl();
		if(x==0)
		{
			pr(0);
			exit();
		}
		x%=mod;
		pr((((x*powm(2,k+1,mod))%mod-powm(2,k,mod)+1)%mod+mod)%mod);
		System.out.print(output);
	}
	///////////////////////////////////////////
	///////////////////////////////////////////
	///template from here
	static class pair
	{
		long a, b;
		pair(){}
		pair(long c,long d){a=c;b=d;}
	}
	static interface combiner
	{
		public long combine(long a, long b);
	}
	static final int mod=1000000007;
	static final double eps=1e-9;
	static final long inf=100000000000000000L;
	static Reader in=new Reader();
	static StringBuilder output=new StringBuilder();
	static Random rn=new Random();
	static void reverse(int[]a){for(int i=0; i<a.length/2; i++){a[i]^=a[a.length-i-1];a[a.length-i-1]^=a[i];a[i]^=a[a.length-i-1];}}
	static void sort(int[]a)
	{
		int te;
		for(int i=0; i<a.length; i+=2)
		{
			te=rn.nextInt(a.length);
			if(i!=te)
			{
				a[i]^=a[te];
				a[te]^=a[i];
				a[i]^=a[te];
			}
		}
		Arrays.sort(a);
	}
	static void sort(long[]a)
	{
		int te;
		for(int i=0; i<a.length; i+=2)
		{
			te=rn.nextInt(a.length);
			if(i!=te)
			{
			a[i]^=a[te];
			a[te]^=a[i];
			a[i]^=a[te];
			}
		}
		Arrays.sort(a);
	}
	static void sort(double[]a)
	{
		int te;
		double te1;
		for(int i=0; i<a.length; i+=2)
		{
			te=rn.nextInt(a.length);
			if(i!=te)
			{
			te1=a[te];
			a[te]=a[i];
			a[i]=te1;
			}
		}
		Arrays.sort(a);
	}
	static void sort(int[][]a)
	{
		Arrays.sort(a, new Comparator<int[]>()
		{
			public int compare(int[]a,int[]b)
			{
				if(a[0]>b[0])
					return -1;
				if(b[0]>a[0])
					return 1;
				return 0;
			}
		});
	}
	static void sort(pair[]a)
	{
		Arrays.sort(a,new Comparator<pair>()
				{
			@Override
			public int compare(pair a,pair b)
			{
				if(a.a>b.a)
					return 1;
				if(b.a>a.a)
				return -1;
				return 0;
			}
				});
	}
	static int log2n(long a)
	{
		int te=0;
		while(a>0)
		{
			a>>=1;
			++te;
		}
		return te;
	}
	static class vector implements Iterable<Integer>
	{
		int a[],size;
		vector(){a=new int[10];size=0;}
		vector(int n){a=new int[n];size=0;}
		public void add(int b){if(++size==a.length)a=Arrays.copyOf(a, 2*size);a[size-1]=b;}
		public void sort(){Arrays.sort(a, 0, size);}
		public void sort(int l, int r){Arrays.sort(a, l, r);}
		@Override
		public Iterator<Integer> iterator() {
			Iterator<Integer> hola=new Iterator<Integer>()
					{
				int cur=0;
						@Override
						public boolean hasNext() {
							return cur<size;
						}
						@Override
						public Integer next() {
							return a[cur++];
						}				
					};
			return hola;
		}
	}
	//output functions////////////////
	static void pr(Object a){output.append(a+""\n"");}
	static void pr(){output.append(""\n"");}
	static void p(Object a){output.append(a);}
	static void pra(int[]a){for(int i:a)output.append(i+"" "");output.append(""\n"");}
	static void pra(long[]a){for(long i:a)output.append(i+"" "");output.append(""\n"");}
	static void pra(String[]a){for(String i:a)output.append(i+"" "");output.append(""\n"");}
	static void pra(double[]a){for(double i:a)output.append(i+"" "");output.append(""\n"");}
	static void sop(Object a){System.out.println(a);}
	static void flush(){System.out.println(output);output=new StringBuilder();}
	//////////////////////////////////
	//input functions/////////////////
	static int ni(){return Integer.parseInt(in.next());}
	static long nl(){return Long.parseLong(in.next());}
	static String ns(){return in.next();}
	static double nd(){return Double.parseDouble(in.next());}
	static int[] nia(int n){int a[]=new int[n];for(int i=0; i<n; i++)a[i]=ni();return a;}
	static int[] pnia(int n){int a[]=new int[n+1];for(int i=1; i<=n; i++)a[i]=ni();return a;}
	static long[] nla(int n){long a[]=new long[n];for(int i=0; i<n; i++)a[i]=nl();return a;}
	static String[] nsa(int n){String a[]=new String[n];for(int i=0; i<n; i++)a[i]=ns();return a;}
	static double[] nda(int n){double a[]=new double[n];for(int i=0; i<n; i++)a[i]=nd();return a;}
	//////////////////////////////////
	//some utility functions
	static void exit(){System.out.print(output);System.exit(0);}
	static int min(int... a){int min=a[0];for(int i:a)min=Math.min(min, i);return min;}
	static int max(int... a){int max=a[0];for(int i:a)max=Math.max(max, i);return max;}	
	static int gcd(int... a){int gcd=a[0];for(int i:a)gcd=gcd(gcd, i);return gcd;}	
	static long min(long... a){long min=a[0];for(long i:a)min=Math.min(min, i);return min;}
	static long max(long... a){long max=a[0];for(long i:a)max=Math.max(max, i);return max;}	
	static long gcd(long... a){long gcd=a[0];for(long i:a)gcd=gcd(gcd, i);return gcd;}	
	static String pr(String a, long b){String c="""";while(b>0){if(b%2==1)c=c.concat(a);a=a.concat(a);b>>=1;}return c;}
	static long powm(long a, long b, long m)
	{long an=1;long c=a;while(b>0)
	{if(b%2==1)an=(an*c)%m;c=(c*c)%m;b>>=1;}return an;}
	static int gcd(int a, int b){if(b==0)return a;return gcd(b, a%b);}
	static long gcd(long a, long b){if(b==0)return a;return gcd(b, a%b);}
	static class Reader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;
        public Reader() {
            reader = new BufferedReader(new InputStreamReader(System.in), 32768);
            tokenizer = null;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
    }
}",0992_C,CODEFORCES,1215,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {

        new Main().go();
    }

    PrintWriter out;
    Reader in;
    BufferedReader br;

    Main() throws IOException {

        try {

            //br = new BufferedReader( new FileReader(""input.txt"") );
            //in = new Reader(""input.txt"");
            in = new Reader(""input.txt"");
            out = new PrintWriter( new BufferedWriter(new FileWriter(""output.txt"")) );
        }
        catch (Exception e) {

            //br = new BufferedReader( new InputStreamReader( System.in ) );
            in = new Reader();
            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );
        }
    }

    void go() throws Exception {

        //int t = in.nextInt();
        int t = 1;
        while (t > 0) {
            solve();
            t--;
        }

        out.flush();
        out.close();
    }


    int inf = 2000000000;
    int mod = 1000000007;
    double eps = 0.000000001;

    int n;
    int m;

    ArrayList<Pair>[] g;
    String s;
    int[][] a;
    void solve() throws IOException {
        int n = in.nextInt();
        int m = in.nextInt();
        a = new int[n][m];
        for (int i = 0; i < n; i++) {
            String s = in.nextLine();
            for (int j = 0; j < m; j++) {
                a[i][j] = s.charAt(j);
            }
        }

        int[][] f = new int[n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                f[i][j] = inf;

        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 0; j < m; j++) {
                if (a[i][j] == '*') {
                    f[i][j] = Math.min(f[i][j], cnt);
                    cnt++;
                } else {
                    cnt = 0;
                }
            }
        }

        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = m - 1; j >= 0; j--) {
                if (a[i][j] == '*') {
                    f[i][j] = Math.min(f[i][j], cnt);
                    cnt++;
                } else {
                    cnt = 0;
                }
            }
        }

        for (int j = 0; j < m; j++) {
            int cnt = 0;
            for (int i = 0; i < n; i++) {
                if (a[i][j] == '*') {
                    f[i][j] = Math.min(f[i][j], cnt);
                    cnt++;
                } else {
                    cnt = 0;
                }
            }
        }

        for (int j = 0; j < m; j++) {
            int cnt = 0;
            for (int i = n - 1; i >= 0; i--) {
                if (a[i][j] == '*') {
                    f[i][j] = Math.min(f[i][j], cnt);
                    cnt++;
                } else {
                    cnt = 0;
                }
            }
        }

        ArrayList<Item> ans = new ArrayList<>();
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++) {
                if (a[i][j] == '*' && f[i][j] > 0)
                    ans.add(new Item(i + 1, j + 1, f[i][j]));
            }
        boolean[][] used = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 0; j < m; j++) {
                if (a[i][j] == '*' && f[i][j] > 0) {
                    cnt = Math.max(cnt, f[i][j] + 1);
                }
                if (cnt > 0) used[i][j] = true;
                cnt--;
            }
            cnt = 0;
            for (int j = m - 1; j >= 0; j--) {
                if (a[i][j] == '*' && f[i][j] > 0) {
                    cnt = Math.max(cnt, f[i][j] + 1);
                }
                if (cnt > 0) used[i][j] = true;
                cnt--;
            }
        }

        for (int j = 0; j < m; j++) {
            int cnt = 0;
            for (int i = 0; i < n; i++) {
                if (a[i][j] == '*' && f[i][j] > 0) {
                    cnt = Math.max(cnt, f[i][j] + 1);
                }
                if (cnt > 0) used[i][j] = true;
                cnt--;
            }
            cnt = 0;
            for (int i = n - 1; i >= 0; i--) {
                if (a[i][j] == '*' && f[i][j] > 0) {
                    cnt = Math.max(cnt, f[i][j] + 1);
                }
                if (cnt > 0) used[i][j] = true;
                cnt--;
            }
        }

        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (a[i][j] == '*' && !used[i][j]) {
                    out.println(-1);
                    return;
                }

        out.println(ans.size());
        for (Item i : ans)
            out.println(i.a + "" "" + i.b + "" "" + i.c);
    }


    class Pair implements Comparable<Pair>{

        int a;
        int b;

        Pair(int a, int b) {

            this.a = a;
            this.b = b;
        }

        public int compareTo(Pair p) {
            if (a != p.a)
                return Integer.compare(a, p.a);
            else
                return Integer.compare(b, p.b);
        }
    }

    class Item {

        int a;
        int b;
        int c;

        Item(int a, int b, int c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }

    }


    class Reader {

        BufferedReader  br;
        StringTokenizer tok;

        Reader(String file) throws IOException {
            br = new BufferedReader( new FileReader(file) );
        }

        Reader() throws IOException {
            br = new BufferedReader( new InputStreamReader(System.in) );
        }

        String next() throws IOException {

            while (tok == null || !tok.hasMoreElements())
                tok = new StringTokenizer(br.readLine());
            return tok.nextToken();
        }

        int nextInt() throws NumberFormatException, IOException {
            return Integer.valueOf(next());
        }

        long nextLong() throws NumberFormatException, IOException {
            return Long.valueOf(next());
        }

        double nextDouble() throws NumberFormatException, IOException {
            return Double.valueOf(next());
        }


        String nextLine() throws IOException {
            return br.readLine();
        }

    }

    static class InputReader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public InputReader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public InputReader(String file_name) throws IOException
        {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public String readLine() throws IOException
        {
            byte[] buf = new byte[64]; // line length
            int cnt = 0, c;
            while ((c = read()) != -1)
            {
                if (c == '\n')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
            if (neg)
                return -ret;
            return ret;
        }

        public double nextDouble() throws IOException
        {
            double ret = 0, div = 1;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();

            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');

            if (c == '.')
            {
                while ((c = read()) >= '0' && c <= '9')
                {
                    ret += (c - '0') / (div *= 10);
                }
            }

            if (neg)
                return -ret;
            return ret;
        }

        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
    }

}",1015_E2,CODEFORCES,3292,Stars Drawing (Hard Edition),"A star is a figure of the following type: an asterisk character '*' in the center of the figure and four rays (to the left, right, top, bottom) of the same positive length. The size of a star is the length of its rays. The size of a star must be a positive number (i.e. rays of length $$$0$$$ are not allowed).
Let's consider empty cells are denoted by '.', then the following figures are stars:
You are given a rectangular grid of size $$$n \times m$$$ consisting only of asterisks '*' and periods (dots) '.'. Rows are numbered from $$$1$$$ to $$$n$$$, columns are numbered from $$$1$$$ to $$$m$$$. Your task is to draw this grid using any number of stars or find out that it is impossible. Stars can intersect, overlap or even coincide with each other. The number of stars in the output can't exceed $$$n \cdot m$$$. Each star should be completely inside the grid. You can use stars of same and arbitrary sizes.
In this problem, you do not need to minimize the number of stars. Just find any way to draw the given grid with at most $$$n \cdot m$$$ stars.
The first line of the input contains two integers $$$n$$$ and $$$m$$$ ($$$3 \le n, m \le 1000$$$) — the sizes of the given grid.
The next $$$n$$$ lines contains $$$m$$$ characters each, the $$$i$$$-th line describes the $$$i$$$-th row of the grid. It is guaranteed that grid consists of characters '*' and '.' only.
If it is impossible to draw the given grid using stars only, print ""-1"".
Otherwise in the first line print one integer $$$k$$$ ($$$0 \le k \le n \cdot m$$$) — the number of stars needed to draw the given grid. The next $$$k$$$ lines should contain three integers each — $$$x_j$$$, $$$y_j$$$ and $$$s_j$$$, where $$$x_j$$$ is the row index of the central star character, $$$y_j$$$ is the column index of the central star character and $$$s_j$$$ is the size of the star. Each star should be completely inside the grid.
","input
In the first example the output 
output
is also correct.
","binarysearch, dp, greedy",5
"import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;


public class Main {


	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt(), sum = 0;
		
		Integer[] A = new Integer[n];
		
		for (int i = 0 ; i < n ; i++) {
			A[i] = sc.nextInt();
			sum += A[i];
		}
		
		Arrays.sort(A, Collections.reverseOrder());
		
		int c = 0, ans = 0;
		
		while (ans <= sum) {
			ans += A[c];
			sum -= A[c];
			c++;
		}
		
		System.out.println(c);
	}
}
",0160_A,CODEFORCES,2436,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Locale;
import java.util.StringTokenizer;

public class Solution implements Runnable {
	
	public static void main(String[] args) {
		(new Thread(new Solution())).start();
	}
	
	BufferedReader in;
	PrintWriter out;
	StringTokenizer st;
	
	String nextToken() throws IOException {
		while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}
	
	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}
	
	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}
	
	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
	
	void solve() throws Exception {
		boolean[] r = new boolean[1010];
		Arrays.fill(r, true);
		r[0] = r[1] = false;
		for (int i = 2; i < 1010; i++) {
			if (r[i]) {
				for (int j = i + i; j < 1010; j += i) {
					r[j] = false;
				}
			}
		}
		int[] pr = new int[1010];
		int l = 0;
		for (int i = 2; i < 1010; i++) if (r[i]) pr[l++] = i;
		int n = nextInt();
		int k = nextInt();
		int ans = 0;
		int j = 0;
		for (int i = 2; i <= n; i++) {
			if (r[i]) {
			for (; j < l - 1; j++) {
				if (i == pr[j] + pr[j + 1] + 1) {
					ans++;
					break;
				}
				if (i < pr[j] + pr[j + 1] + 1) break;
			}
			}
		}
		if (ans >= k) out.println(""YES""); else out.println(""NO"");
	}
	
	public void run() {
		try {
			Locale.setDefault(Locale.US);
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			solve();
		} catch (Exception e) {
			e.printStackTrace();
		}
		out.flush();
	}

}
",0017_A,CODEFORCES,1511,Noldbach problem,"Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least k prime numbers from 2 to n inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.
Two prime numbers are called neighboring if there are no other prime numbers between them.
You are to help Nick, and find out if he is right or wrong.
The first line of the input contains two integers n (2 ≤ n ≤ 1000) and k (0 ≤ k ≤ 1000).
","input
Output YES if at least k prime numbers from 2 to n inclusively can be expressed as it was described above. Otherwise output NO.
output
In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.
","bruteforce, math, numbertheory",3
"import java.util.*;
import java.io.*;

public class ProblemD
{

    static int mod = (int) (1e9+7);
    static InputReader in;
    static PrintWriter out;
    
    static void update(int i, int val, int[] bit){
        for(; i < bit.length; i += (i&-i))
            bit[i] += val;
    }
    
    static int query(int i, int[] bit){
        int ans=0;
        
        for(; i>0; i -= (i&-i))
            ans += bit[i];
        
        return ans;
    }
    
    static int get(int l, int r, int[] bit){
        if(l > r) return 0;
        return query(r, bit) - query(l - 1, bit);
    }
    
    static void solve()
    {
        in = new InputReader(System.in);
        out = new PrintWriter(System.out);            
        
        int n = in.nextInt();
        int[] arr = new int[n + 1];
        int[] bit = new int[n + 2];
        
        for(int i = 1; i <= n; i++){
            arr[i] = in.nextInt();
        }
        int cnt = 0;
        
        for(int i = n; i > 0; i--){
            cnt += query(arr[i], bit);
            update(arr[i], 1, bit);
        }
        cnt %= 2;
        
        int q = in.nextInt();

        while(q-- > 0){
            
            int l = in.nextInt();
            int r = in.nextInt();
            int length = r - l + 1;
            int x = (length * (length - 1)) / 2;
            x %= 2;
            cnt ^= x;
            out.println(cnt == 0 ? ""even"" : ""odd"");
        }
        
        out.close();
    }
    
    public static void main(String[] args)
    {
        new Thread(null ,new Runnable(){
            public void run(){
                try{
                    solve();
                } catch(Exception e){
                    e.printStackTrace();
                }
            }
        },""1"",1<<26).start();
        
    }

    static class Pair implements Comparable<Pair>
    {

        long x,y;

        Pair (long x,long y)
        {
                this.x = x;
                this.y = y;
        }
        public int compareTo(Pair o)
        {
            return Long.compare(this.x,o.x);
                //return 0;
        }

        public boolean equals(Object o)
        {
            if (o instanceof Pair)
            {
                Pair p = (Pair)o;
                return p.x == x && p.y==y;
            }
            return false;
        }

        @Override
        public String toString()
        {
            return x + "" ""+ y ;
        }

        /*public int hashCode()
        {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }*/

    } 

    static long add(long a,long b){
        long x=(a+b);
        while(x>=mod) x-=mod;
        return x;
    }

    static long sub(long a,long b){
        long x=(a-b);
        while(x<0) x+=mod;
        return x;
    }
    
    static long mul(long a,long b){
        long x=(a*b);
        while(x>=mod) x-=mod;
        return x;
    }
    
    static String rev(String s){
        StringBuilder sb=new StringBuilder(s);
        sb.reverse();
        return sb.toString();
    }
    
    static long gcd(long x,long y)
    {
        if(y==0)
                return x;
        else
                return gcd(y,x%y);
    }

    static int gcd(int x,int y)
    {
        if(y==0)
                return x;
        else 
                return gcd(y,x%y);
    }

    static long pow(long n,long p,long m)
    {
         long  result = 1;
          if(p==0){
            return 1;
          }
          
        while(p!=0)
        {
            if(p%2==1)
                result *= n;
            if(result >= m)
               result %= m;
            p >>=1;
            n*=n;
            if(n >= m)
                n%=m;
        }
        
        return result;
    }

    static long pow(long n,long p)
    {
        long  result = 1;
          if(p==0)
            return 1;

        while(p!=0)
        {
            if(p%2==1)
                result *= n;	    
            p >>=1;
            n*=n;	    
        }
        return result;
    }

    static void debug(Object... o)
    {
            System.out.println(Arrays.deepToString(o));
    }

    static class InputReader
    {

        private final InputStream stream;
        private final byte[] buf = new byte[8192];
        private int curChar, snumChars;
        private SpaceCharFilter filter;

        public InputReader(InputStream stream)
        {
                this.stream = stream;
        }

        public int snext()
        {
                if (snumChars == -1)
                        throw new InputMismatchException();
                if (curChar >= snumChars)
                {
                        curChar = 0;
                        try
                        {
                                snumChars = stream.read(buf);
                        } catch (IOException e)
                        {
                                throw new InputMismatchException();
                        }
                        if (snumChars <= 0)
                                return -1;
                }
                return buf[curChar++];
        }

        public int nextInt()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                int sgn = 1;
                if (c == '-')
                {
                        sgn = -1;
                        c = snext();
                }
                int res = 0;
                do
                {
                        if (c < '0' || c > '9')
                                throw new InputMismatchException();
                        res *= 10;
                        res += c - '0';
                        c = snext();
                } while (!isSpaceChar(c));
                return res * sgn;
        }

        public long nextLong()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                int sgn = 1;
                if (c == '-')
                {
                        sgn = -1;
                        c = snext();
                }
                long res = 0;
                do
                {
                        if (c < '0' || c > '9')
                                throw new InputMismatchException();
                        res *= 10;
                        res += c - '0';
                        c = snext();
                } while (!isSpaceChar(c));
                return res * sgn;
        }

        public int[] nextIntArray(int n)
        {
                int a[] = new int[n];
                for (int i = 0; i < n; i++)
                {
                        a[i] = nextInt();
                }
                return a;
        }

        public long[] nextLongArray(int n)
        {
                long a[] = new long[n];
                for (int i = 0; i < n; i++)
                {
                        a[i] = nextLong();
                }
                return a;
        }

        public String readString()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                StringBuilder res = new StringBuilder();
                do
                {
                        res.appendCodePoint(c);
                        c = snext();
                } while (!isSpaceChar(c));
                return res.toString();
        }

        public String nextLine()
        {
                int c = snext();
                while (isSpaceChar(c))
                        c = snext();
                StringBuilder res = new StringBuilder();
                do
                {
                        res.appendCodePoint(c);
                        c = snext();
                } while (!isEndOfLine(c));
                return res.toString();
        }

        public boolean isSpaceChar(int c)
        {
                if (filter != null)
                        return filter.isSpaceChar(c);
                return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private boolean isEndOfLine(int c)
        {
                return c == '\n' || c == '\r' || c == -1;
        }

        public interface SpaceCharFilter
        {
                public boolean isSpaceChar(int ch);
        }

    }
}    
",0911_D,CODEFORCES,3188,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.util.*;
import java.io.*;
import java.math.BigInteger;
public class template {
	public static void main(String[] args) throws Exception {
		FastScanner sc = new FastScanner();
		PrintWriter pw = new PrintWriter(System.out);
		int n = sc.nextInt();
		Integer[] arr = new Integer[n];
		for(int i=0;i<n;i++) {
			arr[i]=sc.nextInt();
		}
		Arrays.sort(arr);
		int ct = 0;
		boolean[] ar = new boolean[n];
		for(int i=0;i<n;i++) {
			if(!ar[i]) {
				ar[i]=true;
				ct++;
				int x = arr[i];
				for(int j=0;j<n;j++) {
					if(arr[j]%x==0) {
						ar[j]=true;
					}
				}
			}
		}
		
		pw.println(ct);
		pw.close();
	}
}
@SuppressWarnings(""all"")
class FastScanner {
    BufferedReader br;
    StringTokenizer st;
    public FastScanner(BufferedReader d) {
        br=d;
    }
    public FastScanner(String s) {
        try {
            br = new BufferedReader(new FileReader(s));
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
 
    public FastScanner() {
        br = new BufferedReader(new InputStreamReader(System.in));
    }
 
    String nextToken() {
        while (st == null || !st.hasMoreElements()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }
 
    int nextInt() {
        return Integer.parseInt(nextToken());
    }
 
    long nextLong() {
        return Long.parseLong(nextToken());
    }
 
    double nextDouble() {
        return Double.parseDouble(nextToken());
    }
}",1209_A,CODEFORCES,3515,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"import java.util.ArrayList;

import java.util.Collections;

import java.util.List;

import java.util.Scanner;



public class Main {

    private static class Node<V extends Comparable<V>> {

        public Node parent;

        private final V data;



        public Node(V data) {

            this.data = data;

            this.parent = null;

        }



    }



    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        long n = sc.nextLong(), s = sc.nextLong();

        long first = -1l;

        for (long i = s; i < s + 1000l; i = i + 1l) {

            if (i - summa(i) >= s) {

                first = i;

                break;

            }

        }

        long res = n - first + 1l;

        if(res<0) res = 0;

        System.out.println(res);



    }



    static long summa(long n) {

        long sum = 0l;

        if (n % 10l == n) return n;

        sum += n % 10l + summa(n / 10l);

        return sum;

    }

}

",0817_C,CODEFORCES,1113,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.Reader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        MyInput in = new MyInput(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskE solver = new TaskE();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskE {
        static final int mod = 998244353;

        public void solve(int testNumber, MyInput in, PrintWriter out) {
            int n = in.nextInt();
            int K = in.nextInt();

            long[][] dp = new long[n + 1][n + 1];
            for (int i = 1; i <= n; i++) {
                dp[i][0] = 1;
                for (int j = 1; j <= n; j++) {
                    for (int k = 1; k <= i && k <= j; k++) {
                        dp[i][j] += dp[i][j - k];
                        if (dp[i][j] >= mod) dp[i][j] -= mod;
                    }
                }
            }

            long ans = 0;
            long[][] dp2 = new long[n + 1][n + 1];
            for (int i = 1; i <= n; i++)
                if (i < K) {
                    for (long[] d : dp2) Arrays.fill(d, 0L);
                    dp2[0][0] = ((dp[i][n] - dp[i - 1][n]) * 2 % mod + mod) % mod;
                    for (int j = 1; j <= n; j++) {
                        for (int k = 1; k <= j; k++) {
                            if (k * i < K) {
                                dp2[j][k] += dp2[j - 1][k - 1];
                                if (dp2[j][k] >= mod) dp2[j][k] -= mod;
                            }
                            if (j > 1) {
                                dp2[j][1] += dp2[j - 1][k - 1];
                                if (dp2[j][1] >= mod) dp2[j][1] -= mod;
                            }
                        }
                    }
//            dump(i, dp2);
                    for (int k = 1; k <= n; k++) {
                        ans += dp2[n][k];
                    }
                }

            out.println((ans % mod + mod) % mod);
        }

    }

    static class MyInput {
        private final BufferedReader in;
        private static int pos;
        private static int readLen;
        private static final char[] buffer = new char[1024 * 8];
        private static char[] str = new char[500 * 8 * 2];
        private static boolean[] isDigit = new boolean[256];
        private static boolean[] isSpace = new boolean[256];
        private static boolean[] isLineSep = new boolean[256];

        static {
            for (int i = 0; i < 10; i++) {
                isDigit['0' + i] = true;
            }
            isDigit['-'] = true;
            isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
            isLineSep['\r'] = isLineSep['\n'] = true;
        }

        public MyInput(InputStream is) {
            in = new BufferedReader(new InputStreamReader(is));
        }

        public int read() {
            if (pos >= readLen) {
                pos = 0;
                try {
                    readLen = in.read(buffer);
                } catch (IOException e) {
                    throw new RuntimeException();
                }
                if (readLen <= 0) {
                    throw new MyInput.EndOfFileRuntimeException();
                }
            }
            return buffer[pos++];
        }

        public int nextInt() {
            int len = 0;
            str[len++] = nextChar();
            len = reads(len, isSpace);
            int i = 0;
            int ret = 0;
            if (str[0] == '-') {
                i = 1;
            }
            for (; i < len; i++) ret = ret * 10 + str[i] - '0';
            if (str[0] == '-') {
                ret = -ret;
            }
            return ret;
        }

        public char nextChar() {
            while (true) {
                final int c = read();
                if (!isSpace[c]) {
                    return (char) c;
                }
            }
        }

        int reads(int len, boolean[] accept) {
            try {
                while (true) {
                    final int c = read();
                    if (accept[c]) {
                        break;
                    }
                    if (str.length == len) {
                        char[] rep = new char[str.length * 3 / 2];
                        System.arraycopy(str, 0, rep, 0, str.length);
                        str = rep;
                    }
                    str[len++] = (char) c;
                }
            } catch (MyInput.EndOfFileRuntimeException e) {
            }
            return len;
        }

        static class EndOfFileRuntimeException extends RuntimeException {
        }

    }
}

",1027_E,CODEFORCES,3295,Inverse Coloring,"You are given a square board, consisting of $$$n$$$ rows and $$$n$$$ columns. Each tile in it should be colored either white or black.
Let's call some coloring beautiful if each pair of adjacent rows are either the same or different in every position. The same condition should be held for the columns as well.
Let's call some coloring suitable if it is beautiful and there is no rectangle of the single color, consisting of at least $$$k$$$ tiles.
Your task is to count the number of suitable colorings of the board of the given size.
Since the answer can be very large, print it modulo $$$998244353$$$.
A single line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 500$$$, $$$1 \le k \le n^2$$$) — the number of rows and columns of the board and the maximum number of tiles inside the rectangle of the single color, respectively.
Print a single integer — the number of suitable colorings of the board of the given size modulo $$$998244353$$$.
Board of size $$$1 \times 1$$$ is either a single black tile or a single white tile. Both of them include a rectangle of a single color, consisting of $$$1$$$ tile.
","input
Here are the beautiful colorings of a board of size $$$2 \times 2$$$ that don't include rectangles of a single color, consisting of at least $$$3$$$ tiles:
output
The rest of beautiful colorings of a board of size $$$2 \times 2$$$ are the following:
","combinatorics, dp, math",5
"import java.util.*;
import java.io.*;
public class Main
{
	public static void main(String args[]) throws IOException
	{
		Scanner sc = new Scanner(System.in);
                int n = sc.nextInt(), k = sc.nextInt(), kol = 0, prev;
                boolean ok;
                ArrayList<Integer> al = new ArrayList<Integer>();
                al.add(2);
                prev = 2;
                for(int i=3;i<=n;i+=2)
                {
                	ok = true;
                	for(Integer x: al) 
                	if (i%x == 0)
                	{
                		ok = false;
                		break;
                	}
                	if (ok) 
                	{
                		for(Integer x: al)
                		if (ok) 
                		{
                			prev = x; 
                			ok = false;
                		} else
                		{
	                		if (x + prev + 1 == i) 
	                		{
	                			kol++;
	                			break;
	                		}
	                		if (x + prev + 1 > i) break;
	                		prev = x;
                		}
                		al.add(i);
                	}
                }
                if (kol >= k) System.out.print(""YES""); else System.out.print(""NO"");
	}
}",0017_A,CODEFORCES,1530,Noldbach problem,"Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least k prime numbers from 2 to n inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.
Two prime numbers are called neighboring if there are no other prime numbers between them.
You are to help Nick, and find out if he is right or wrong.
The first line of the input contains two integers n (2 ≤ n ≤ 1000) and k (0 ≤ k ≤ 1000).
","input
Output YES if at least k prime numbers from 2 to n inclusively can be expressed as it was described above. Otherwise output NO.
output
In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.
","bruteforce, math, numbertheory",3
"import java.io.*;
import java.util.*;


public class A {
    public static void main(String[] args) throws Exception {
        new A().solve();
    }
    void solve() throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(in.readLine());
        if (n == 0) {
            System.out.println(""0 0 0"");
            return;
        }
        int p2 = 0;
        int p1 = 1;
        while (true) {
            int now = p2 + p1;
            if (n == now) {
                System.out.println(""0 "" + p1 + "" "" + p2);
                return;
            } else {
                p2 = p1;
                p1 = now;
            }
        }
    }
}
",0199_A,CODEFORCES,191,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"import java.util.*;
import java.lang.*;
import java.io.*;
 
/* Name of the class has to be ""Main"" only if the class is public. */
public class Ideone
{
static double p[][];
    static double dp[];
    static int n;
 
    public static int BitCount(int u) {
        int uCount;
 
        uCount = u - ((u >> 1) & 033333333333) - ((u >> 2) & 011111111111);
        return ((uCount + (uCount >> 3)) & 030707070707) % 63;
    }
 
    public static double f(int mask) {
        if (dp[mask] > -0.5)
            return dp[mask];
 
        dp[mask] = 0;
 
        int ones = BitCount(mask);
        double pairs = (((ones * (ones + 1))) >> 1);
        //System.out.println(pairs);
 
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if ((mask & (1 << i)) != 0 && (mask & (1 << j)) == 0)
                    dp[mask] += f(mask | (1 << j)) * p[i][j] / pairs;
            }
        }
 
        return dp[mask];
    }
 
    public static void main(String[] args) throws NumberFormatException,
            IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(bf.readLine());
        p = new double[n][n];
        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(bf.readLine());
            for (int j = 0; j < n; j++) {
                p[i][j] = Double.parseDouble(st.nextToken());
            }
        }
 
        dp = new double[1 << n];
 
        Arrays.fill(dp, -1.0);
 
        dp[(1 << n) - 1] = 1.;
 
        for (int i = 0; i < n - 1; i++) {
            System.out.print(f(1 << i) + "" "");
        }
 
        System.out.println(f((1 << (n - 1))));
 
    }
}",0016_E,CODEFORCES,4483,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"import java.util.*;
import java.io.*;
import java.math.BigInteger;

public class Problem
{

    static int mod = (int) (1e9+7);
    static InputReader in;
    static PrintWriter out;
    static int[] rt;
    static int[] size;

    static void initialize(int n){
        rt = new int[n + 1];
        size = new int[n + 1];
        for(int i = 0; i < rt.length; i++){
            rt[i] = i;
            size[i] = 1;
        }
    }
    
    static int root(int x){
        while(rt[x] != x){
            rt[x] = rt[rt[x]];
            x = rt[x];
        }
        return x;
    }
    
    static long union(int x,int y){
        int root_x = root(x);
        int root_y = root(y);
        if(root_x == root_y) return 0;
        long val = size[root_x] *1l* size[root_y];
        if(size[root_x]<size[root_y]){
            rt[root_x] = rt[root_y];
            size[root_y] += size[root_x];
        }
        else{
            rt[root_y] = rt[root_x];
            size[root_x] += size[root_y];            
        }
        
        return val;
    }
    
    static void solve()
    {
        in = new InputReader(System.in);
        out = new PrintWriter(System.out);            
        
        int t = 1;
        
        while(t-- > 0){
            int n = in.nextInt();
            int[] arr = in.nextIntArray(n);
            ArrayList<Pair> list = new ArrayList<>();
            
            for(int i = 1; i < n; i++){
                int u = in.nextInt() - 1;
                int v = in.nextInt() - 1;
                list.add(new Pair(u, v, Math.max(arr[u],arr[v])));
            }
            list.sort((p1,p2) -> Integer.compare(p1.i, p2.i));
            initialize(n);
            long s1 = 0;
            for(int i = 0; i < list.size(); i++){
                s1 += union(list.get(i).x, list.get(i).y) * list.get(i).i;
            }
            for(int i = 0; i < list.size(); i++){
                Pair p = list.get(i);
                p.i = Math.min(arr[p.x],arr[p.y]);
            }
            list.sort((p1,p2) -> -Integer.compare(p1.i, p2.i));
            initialize(n);
            long s2 = 0;
            for(int i = 0; i < list.size(); i++){
                s2 += union(list.get(i).x, list.get(i).y) * list.get(i).i;
            }
            
            out.println(s1 - s2);
        }
        
        out.close();
    }
    
    public static void main(String[] args)
    {
        new Thread(null ,new Runnable(){
            public void run(){
                try{
                    solve();
                } catch(Exception e){
                    e.printStackTrace();
                }
            }
        },""1"",1<<26).start();
        
    }

    static class Pair implements Comparable<Pair>
    {

        int x,y;
        int i;


        Pair (int x,int y)
        {
                this.x = x;
                this.y = y;
        }

        Pair (int x,int y, int i)
        {
                this.x = x;
                this.y = y;
                this.i = i;
        }

        public int compareTo(Pair o)
        {
            if(this.x != o.x)
                return -Integer.compare(this.x, o.y);
            return -Integer.compare(this.y,o.y);
                //return 0;
        }

        public boolean equals(Object o)
        {
            if (o instanceof Pair)
            {
                Pair p = (Pair)o;
                return p.x == x && p.y==y;
            }
            return false;
        }

        @Override
        public String toString()
        {
            return x + "" ""+ y + "" ""+i;
        }

        /*public int hashCode()
        {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }*/

    } 

    static long add(long a,long b){
        long x=(a+b);
        while(x>=mod) x-=mod;
        return x;
    }

    static long sub(long a,long b){
        long x=(a-b);
        while(x<0) x+=mod;
        return x;
    }
    
    static long mul(long a,long b){
        long x=(a*b);
        while(x>=mod) x-=mod;
        return x;
    }
    
    static String rev(String s){
        StringBuilder sb=new StringBuilder(s);
        sb.reverse();
        return sb.toString();
    }
    
    static long gcd(long x,long y)
    {
        if(y==0)
                return x;
        else
                return gcd(y,x%y);
    }

    static int gcd(int x,int y)
    {
        if(y==0)
                return x;
        else 
                return gcd(y,x%y);
    }

    static long pow(long n,long p,long m)
    {
         long  result = 1;
          if(p==0){
            return n;
          }
          
        while(p!=0)
        {
            if(p%2==1)
                result *= n;
            if(result >= m)
               result %= m;
            p >>=1;
            n*=n;
            if(n >= m)
                n%=m;
        }
        
        return result;
    }

    static long pow(long n,long p)
    {
        long  result = 1;
          if(p==0)
            return 1;

        while(p!=0)
        {
            if(p%2==1)
                result *= n;	    
            p >>=1;
            n*=n;	    
        }
        return result;
    }

    static void debug(Object... o)
    {
            System.out.println(Arrays.deepToString(o));
    }

    static class InputReader
    {

        private final InputStream stream;
        private final byte[] buf = new byte[8192];
        private int curChar, snumChars;
        private SpaceCharFilter filter;

        public InputReader(InputStream stream)
        {
                this.stream = stream;
        }

        public int snext()
        {
                if (snumChars == -1)
                        throw new InputMismatchException();
                if (curChar >= snumChars)
                {
                        curChar = 0;
                        try
                        {
                                snumChars = stream.read(buf);
                        } catch (IOException e)
                        {
                                throw new InputMismatchException();
                        }
                        if (snumChars <= 0)
                                return -1;
                }
                return buf[curChar++];
        }

        public int nextInt()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                int sgn = 1;
                if (c == '-')
                {
                        sgn = -1;
                        c = snext();
                }
                int res = 0;
                do
                {
                        if (c < '0' || c > '9')
                                throw new InputMismatchException();
                        res *= 10;
                        res += c - '0';
                        c = snext();
                } while (!isSpaceChar(c));
                return res * sgn;
        }

        public long nextLong()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                int sgn = 1;
                if (c == '-')
                {
                        sgn = -1;
                        c = snext();
                }
                long res = 0;
                do
                {
                        if (c < '0' || c > '9')
                                throw new InputMismatchException();
                        res *= 10;
                        res += c - '0';
                        c = snext();
                } while (!isSpaceChar(c));
                return res * sgn;
        }

        public int[] nextIntArray(int n)
        {
                int a[] = new int[n];
                for (int i = 0; i < n; i++)
                {
                        a[i] = nextInt();
                }
                return a;
        }

        public long[] nextLongArray(int n)
        {
                long a[] = new long[n];
                for (int i = 0; i < n; i++)
                {
                        a[i] = nextLong();
                }
                return a;
        }

        public String readString()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                StringBuilder res = new StringBuilder();
                do
                {
                        res.appendCodePoint(c);
                        c = snext();
                } while (!isSpaceChar(c));
                return res.toString();
        }

        public String nextLine()
        {
                int c = snext();
                while (isSpaceChar(c))
                        c = snext();
                StringBuilder res = new StringBuilder();
                do
                {
                        res.appendCodePoint(c);
                        c = snext();
                } while (!isEndOfLine(c));
                return res.toString();
        }

        public boolean isSpaceChar(int c)
        {
                if (filter != null)
                        return filter.isSpaceChar(c);
                return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private boolean isEndOfLine(int c)
        {
                return c == '\n' || c == '\r' || c == -1;
        }

        public interface SpaceCharFilter
        {
                public boolean isSpaceChar(int ch);
        }

    }
}    
",0915_F,CODEFORCES,2798,Imbalance Value of a Tree,"You are given a tree T consisting of n vertices. A number is written on each vertex; the number written on vertex i is ai. Let's denote the function I(x, y) as the difference between maximum and minimum value of ai on a simple path connecting vertices x and y.
Your task is to calculate .
The first line contains one integer number n (1 ≤ n ≤ 106) — the number of vertices in the tree.
The second line contains n integer numbers a1, a2, ..., an (1 ≤ ai ≤ 106) — the numbers written on the vertices.
","input
Then n - 1 lines follow. Each line contains two integers x and y denoting an edge connecting vertex x and vertex y (1 ≤ x, y ≤ n, x ≠ y). It is guaranteed that these edges denote a tree.
output
Print one number equal to .
","datastructures, dsu, graphs, trees",4
"import java.io.*;
import java.util.*;

public class Main { 
    public static void main(String[] args) throws IOException { 
        //InputStream input = System.in;
        //OutputStream output = System.out;
        InputReader in = new InputReader(new FileReader(new File(""input.txt"")));
        PrintWriter out = new PrintWriter(new FileWriter(new File(""output.txt"")));
        //InputReader in = new InputReader(input);
        //PrintWriter out = new PrintWriter(output);
        Solution s = new Solution();
        s.solve(1, in, out);
        out.close();
    }

    static class Solution { 
        
        double EPS = 0.0000001;
        public void solve(int cs, InputReader in, PrintWriter out) {

            int n = in.nextInt(), m = in.nextInt();
            Graph g = new Graph(n, m);
            int k = in.nextInt();
            for (int[] v : g.vis)
                Arrays.fill(v, -1);
            while (k-- > 0) {
                Pair start = new Pair(in.nextInt()-1, in.nextInt()-1);
                g.bfs(start);
            }
            int idx1 = 0, idx2 = 0, max = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; ++j) {
                    if (g.vis[i][j] > max) {
                        idx1 = i;
                        idx2 = j;
                        max = g.vis[i][j];
                    }
                }
            }
            out.println((idx1+1) + "" "" + (idx2+1));
        }

        static class Pair {
            int x, y;

            public Pair(int x, int y) {
                this.x = x ;
                this.y = y;
            }
        }

        static class Graph {
            LinkedList<Integer> adj[];
            int n, e;
            int[][] vis;

            @SuppressWarnings(""unchecked"")
            public Graph(int n, int e) {
                this.n = n;
                this.e = e;
                adj = new LinkedList[n];
                for (int i = 0; i < n; ++i)
                    adj[i] = new LinkedList<>();
                vis = new int[n][e];
            }
            
            int[] dx = {0, 0, 1, -1};
            int[] dy = {1, -1, 0, 0};

            void bfs(Pair src) {
                Queue<Pair> q = new LinkedList<>();
                vis[src.x][src.y] = 0;
                q.add(src);
                while (!q.isEmpty()) {
                    Pair p = q.poll();
                    for (int k = 0; k < 4; k++) {
                        int ni = p.x+dx[k];
                        int nj = p.y+dy[k];
                        if (isValid(ni, nj) && (vis[ni][nj] == -1 || vis[p.x][p.y]+1 < vis[ni][nj])) {
                            vis[ni][nj] = vis[p.x][p.y]+1;
                            q.add(new Pair(ni, nj));
                        }
                    }
                    
                }
            }

            boolean isValid(int i, int j) {
                return i >= 0 && i < n && j >= 0 && j < e;
            }
        }
    }

    static class InputReader { 
        BufferedReader br;
        StringTokenizer st;
        
        public InputReader(InputStream i) {
            br = new BufferedReader(new InputStreamReader(i), 32768);
            st = null;
        }

        public InputReader(FileReader s) {
            br = new BufferedReader(s);
            st = null;
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try { 
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        public int nextInt() { 
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() { 
            try { 
                return br.readLine();
            } catch (IOException e) { 
                throw new RuntimeException(e);
            }
        }
    }
    static class Reader {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
        public Reader(){
            din=new DataInputStream(System.in);
            buffer=new byte[BUFFER_SIZE];
            bufferPointer=bytesRead=0;
        }

        public Reader(String file_name) throws IOException{
            din=new DataInputStream(new FileInputStream(file_name));
            buffer=new byte[BUFFER_SIZE];
            bufferPointer=bytesRead=0;
        }

        public String readLine() throws IOException{
            byte[] buf=new byte[64]; // line length
            int cnt=0,c;
            while((c=read())!=-1){
                if(c=='\n')break;
                buf[cnt++]=(byte)c;
            }
            return new String(buf,0,cnt);
        }

        public int nextInt() throws IOException{
            int ret=0;byte c=read();
            while(c<=' ')c=read();
            boolean neg=(c=='-');
            if(neg)c=read();
            do{ret=ret*10+c-'0';}while((c=read())>='0'&&c<='9');
            if(neg)return -ret;
            return ret;
        }

        public long nextLong() throws IOException{
            long ret=0;byte c=read();
            while(c<=' ')c=read();
            boolean neg=(c=='-');
            if(neg)c=read();
            do{ret=ret*10+c-'0';}while((c=read())>='0'&&c<='9');
            if(neg)return -ret;
            return ret;
        }

        public double nextDouble() throws IOException{
            double ret=0,div=1;byte c=read();
            while(c<=' ')c=read();
            boolean neg=(c=='-');
            if(neg)c = read();
            do {ret=ret*10+c-'0';}while((c=read())>='0'&&c<='9');
            if(c=='.')while((c=read())>='0'&&c<='9')
                ret+=(c-'0')/(div*=10);
            if(neg)return -ret;
            return ret;
        }

        private void fillBuffer() throws IOException{
            bytesRead=din.read(buffer,bufferPointer=0,BUFFER_SIZE);
            if(bytesRead==-1)buffer[0]=-1;
        }

        private byte read() throws IOException{
            if(bufferPointer==bytesRead)fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException{
            if(din==null) return;
            din.close();
        }
    }
}

",0035_C,CODEFORCES,3920,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"import java.util.*;
import java.io.*;

public class A {

    ArrayList<Integer> list = new ArrayList<Integer>();
    
    
    boolean valid(int n) {
        Queue<Integer> q = new LinkedList<Integer>();
        q.add(4);
        q.add(7);
        int crnt;
        while(!q.isEmpty()) {
            crnt = q.poll();
            if(n%crnt == 0) return true;
            if ( crnt*10 + 4 <= 1000 ) q.add(crnt*10 + 4);
            if ( crnt*10 + 7 <= 1000 ) q.add(crnt*10 + 7);
        }
        return false;
    }
    
    void dfs(int n){
        if(n>1000)return;
        if(n!=0)list.add(n);
        n = n*10;
        dfs(n+4);
        dfs(n+7);
    }

    void run() {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        if (valid(n)) {
            System.out.println(""YES"");
        } else {
            System.out.println(""NO"");
        }
    }

    public static void main(String[] args) {
        new A().run();
    }

}
",0122_A,CODEFORCES,106,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory",1
"// Dummy text
import java.io.*; 
import java.util.*; 
  public class forgery
  {  
    public static void main(String[] args) throws IOException 
    { 
           BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
           int n=Integer.parseInt(br.readLine());
          long answer=0;
          if(n==1)
          answer=1;
          else
          answer= 2*n*n-2*n+1;
          System.out.println(answer);
 }
  }",1180_A,CODEFORCES,744,Alex and a Rhombus,"While playing with geometric figures Alex has accidentally invented a concept of a $$$n$$$-th order rhombus in a cell grid.
A $$$1$$$-st order rhombus is just a square $$$1 \times 1$$$ (i.e just a cell).
A $$$n$$$-th order rhombus for all $$$n \geq 2$$$ one obtains from a $$$n-1$$$-th order rhombus adding all cells which have a common side with it to it (look at the picture to understand it better).
Alex asks you to compute the number of cells in a $$$n$$$-th order rhombus.
The first and only input line contains integer $$$n$$$ ($$$1 \leq n \leq 100$$$) — order of a rhombus whose numbers of cells should be computed.
","input
Print exactly one integer — the number of cells in a $$$n$$$-th order rhombus.
output
Images of rhombus corresponding to the examples are given in the statement.
","dp, implementation, math",1
"import java.io.*;
import java.util.*;
import java.lang.*;
public class Main{
    static InputReader sc;
    static PrintWriter pw;
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        sc = new InputReader(inputStream);
        pw = new PrintWriter(outputStream);
        solve();
        pw.close();
    }
    // static int L,R,top,bottom;
    // static int cnt,edge;
    // static long ans;
    public static void solve() {
        // int t=sc.nextInt();           
        int t=1;
        u:while(t-->0){ 
            int n=s(0); 
            int m=s(0);
            int k=s(0);            
            long [][][]arr=new long [n][m][4];
            for(int i=0;i<n;i++){
                for(int j=0;j<m-1;j++){
                    long v=s(0l);
                    arr[i][j][0]=v;
                    arr[i][j+1][2]=v;
                }
            }
            for(int i=0;i<n-1;i++){
                for(int j=0;j<m;j++){
                    long v=s(0l);
                    arr[i][j][1]=v;
                    arr[i+1][j][3]=v;
                }
            }
            Long [][][]dp=new Long [n][m][k+1];
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++)
                    for(int p=1;p<=k;p++)
                        helper(i,j,p,dp,arr,n,m);
            }
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++)
                    p(dp[i][j][k]+"" "");
                pln("""");
            }
        }           
    }         
    static int [][]dir=new int [][]{{0,1},{1,0},{0,-1},{-1,0}};
    public static long helper(int i, int j, int k, Long [][][]dp, long [][][]arr, int n, int m){
        if(k<0)
            return -1;
        if(k==0)
            return 0;
        if(dp[i][j][k]!=null)
            return dp[i][j][k];
        int x, y;
        long ans=Long.MAX_VALUE,val;
        for(int d=0;d<4;d++){
            x=i+dir[d][0];
            y=j+dir[d][1];
            if(x<0||x>=n||y<0||y>=m)
                continue;
            val=helper(x,y,k-2,dp,arr,n,m);
            if(val!=-1)
                ans=Math.min(ans,val+2*arr[i][j][d]);
        }
        return dp[i][j][k]=(ans==Long.MAX_VALUE?-1:ans);        
    }
    public static int find(List<Integer> list, int x){
        int l=0,r=list.size()-1,m;
        while(l<=r){
            m=(r-l)/2+l;
            if(list.get(m)<=x)
                l=m+1;
            else
                r=m-1;
        }
        return r;
    } 
    static class Node{
        int val;
        long cost;
        Node next;
        Node(int v,long c){
            val=v;
            next=null;
            cost=c;
        }
    }    
    public static long sum(long n){
        long val=0l;
        while(n>0){
            val+=n%10;
            n/=10;
        }
        return val;
    }
    // static class Node{
    //     int left,right;
    //     Node prev,next;
    //     Node(int i, int v){
    //         left=i;
    //         right=v;
    //         prev=next=null;
    //     }
    //     void remove(){
    //         this.prev.next=this.next;
    //         this.next.prev=this.prev;
    //     }
    //     void insert(Node node){
    //         node.next=this;
    //         node.prev=this.prev;
    //         node.prev.next=node;
    //         this.prev=node;
    //     }
    // } 
    public static int  findDiameter(int r, List<List<Integer>>list){
        return findFarthest(findFarthest(r,list)[0],list)[1];
    }
    public static int[] findFarthest(int u, List<List<Integer>>list){
        int n=list.size();
        boolean []vis=new boolean[n+1];
        Queue<Integer>q=new LinkedList<>();
        q.offer(u);
        vis[u]=true;
        int s,pr,cnt=0;
        int []ar=new int[]{u,0};
        while(q.size()>0){
            s=q.size();
            while(s-->0){
                pr=q.poll();
                if(ar[1]<cnt){
                    ar[1]=cnt;
                    ar[0]=pr;
                }
                for(int i:list.get(pr)){
                    if(!vis[i]){
                        vis[i]=true;
                        q.offer(i);
                    }
                }
            }
            cnt++;
        }
        return ar;
    }
    public static long atMostK(char []chrr, int k){
        if(k<0)
            return 0;
        int l=0,cnt=0;
        long ans=0l;
        for(int i=0;i<chrr.length;i++){
            if(chrr[i]=='1')
                cnt++;
            while(cnt>k){
                if(chrr[l++]=='1')
                    cnt--;
            }
            ans+=(long)(i-l)+1l;
        }
        return ans;
    }
    public static int ask(int l){
        System.out.println(l);
        System.out.flush();
        return sc.nextInt();
    }
    public static void sort(long []arr){
        ArrayList<Long> list=new ArrayList<>();
        for(int i=0;i<arr.length;i++)
            list.add(arr[i]);
        Collections.sort(list);
        for(int i=0;i<arr.length;i++)
            arr[i]=list.get(i);
    }
    public static void swap(char []chrr, int i, int j){
        char temp=chrr[i];
        chrr[i]=chrr[j];
        chrr[j]=temp;
    }
    public static int countSetBits(long n){
        int a=0;
        while(n>0){
            a+=(n&1);
            n>>=1;
        }
        return a;
    }
    static class Pair{
        int v,w;
        Pair(int V, int W){
            v=V;
            w=W;
        }
     //*
    }
    /*/
        public int compareTo(Pair p){
            return (b-p.b);
        }
        public int hashCode(){
            int hashcode = (a+"" ""+b).hashCode();
            return hashcode;
        }
        public boolean equals(Object obj){
            if (obj instanceof Pair) {
                Pair p = (Pair) obj;
                return (p.a==this.a && p.b == this.b);
            }
            return false;
        }
    }
    //*/
    static boolean isPrime(long n) { 
        if (n <= 1) 
            return false; 
        if (n <= 3) 
            return true; 
        if (n % 2 == 0 || n % 3 == 0) 
            return false; 
        for (int i = 5; i * i <= n; i = i + 6) 
            if (n % i == 0 || n % (i + 2) == 0) 
                return false; 
        return true; 
    } 
    static long gcd(long a, long b) { 
        if (b == 0) 
            return a; 
        return a>b?gcd(b, a % b):gcd(a, b % a);  
    } 
    static long fast_pow(long base,long n,long M){
        if(n==0)
           return 1;
        if(n==1)
        return base;
        long halfn=fast_pow(base,n/2,M);
        if(n%2==0)
            return ( halfn * halfn ) % M;
        else
            return ( ( ( halfn * halfn ) % M ) * base ) % M;
    }
    static long modInverse(long n,long M){
        return fast_pow(n,M-2,M);
    }
    public static int s(int n){
        return sc.nextInt();
    }
    public static long s(long n){
        return sc.nextLong();
    }
    public static String s(String n){
        return sc.next();
    }
    public static double s(double n){
        return sc.nextDouble();
    }
    public static void p(int n){
        pw.print(n);
    }
    public static void p(long n){
        pw.print(n);
    }
    public static void p(String n){
        pw.print(n);
    }
    public static void p(double n){
        pw.print(n);
    }
    public static void pln(int n){
        pw.println(n);
    }
    public static void pln(long n){
        pw.println(n);
    }
    public static void pln(String n){
        pw.println(n);
    }
    public static void pln(double n){
        pw.println(n);
    }
    public static void feedArr(long []arr){
        for(int i=0;i<arr.length;i++)
            arr[i]=sc.nextLong();
    }
    public static void feedArr(double []arr){
        for(int i=0;i<arr.length;i++)
            arr[i]=sc.nextDouble();
    }
    public static void feedArr(int []arr){
        for(int i=0;i<arr.length;i++)
            arr[i]=sc.nextInt();
    }
    public static void feedArr(String []arr){
        for(int i=0;i<arr.length;i++)
            arr[i]=sc.next();
    }
    public static String printArr(int []arr){
        StringBuilder sbr=new StringBuilder();
        for(int i:arr)
            sbr.append(i+"" "");
        return sbr.toString();
    }
    public  static String printArr(long []arr){
        StringBuilder sbr=new StringBuilder();
        for(long i:arr)
            sbr.append(i+"" "");
        return sbr.toString();
    }
    public static String printArr(String []arr){
        StringBuilder sbr=new StringBuilder();
        for(String i:arr)
            sbr.append(i+"" "");
        return sbr.toString();
    }
    public static String printArr(double []arr){
        StringBuilder sbr=new StringBuilder();
        for(double i:arr)
            sbr.append(i+"" "");
        return sbr.toString();
    }
    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;
 
        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}",1517_D,CODEFORCES,4204,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class B {
    final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    final PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    StringTokenizer tokenizer;
    final int[][] d;
    final int n;
    final int[] time;
    final Action[] actions;

    private static final class Action {
        int a;
        int b;

        public Action(int a) {
            this.a = this.b = a;
        }

        public Action(int a, int b) {
            this.a = a;
            this.b = b;
        }

        @Override
        public String toString() {
            if (a == b)
                return "" "" + (a+1);
            return "" "" + (a+1) + "" "" + (b+1);
        }
    }

    private static final int dist(int x1, int y1, int x2, int y2) {
        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    }

    private final boolean in(int x, int set) {
        return ((1 << x) & set) != 0;
    }

    private final int off(int x, int set) {
        return (set ^ (set & (1 << x)));
    }

    private final int solve(int set) {
        if (time[set] > 0)
            return time[set];
        int min = Integer.MAX_VALUE;
        if (set == 0)
            min = 0;
        else {
            int a;
            for (a = 0; a < n; a++)
                if (in(a, set))
                    break;
            int subset = off(a, set);
            int aux = 2 * d[a][a] + solve(subset);
            if (aux < min) {
                min = aux;
                actions[set] = new Action(a);
            }
            for (int b = a + 1; b < n; b++)
                if (in(b, subset)) {
                    aux = d[a][a] + d[b][b] + d[a][b] + solve(off(b, subset));
                    if (aux < min) {
                        min = aux;
                        actions[set] = new Action(a, b);
                    }
                }
        }
        time[set] = min;
        return min;
    }

    private B() throws IOException {
        int bx = nextInt();
        int by = nextInt();
        n = nextInt();
        int[] x = new int[n];
        int[] y = new int[n];
        for (int i = 0; i < n; i++) {
            x[i] = nextInt();
            y[i] = nextInt();
        }
        reader.close();

        d = new int[n][n];
        for (int i = 0; i < n; i++) {
            d[i][i] = dist(bx, by, x[i], y[i]);// |A|
            for (int j = i + 1; j < n; j++)
                d[i][j] = dist(x[i], y[i], x[j], y[j]);// |AB|
        }
        int set = 1 << n;
        time = new int[set];
        actions = new Action[set];
        set--;
        printer.println(solve(set));
        printer.print(""0"");
        while (set != 0) {
            solve(set);
            Action action = actions[set];
            printer.print(action);
            printer.print("" 0"");
            set = off(action.a, set);
            set = off(action.b, set);
        }

        printer.println();
        printer.close();
    }

    private final int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    private final String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }

    public static void main(String[] args) throws IOException {
        new B();
    }

}
",0008_C,CODEFORCES,4334,Looking for Order,"Girl Lena likes it when everything is in order, and looks for order everywhere. Once she was getting ready for the University and noticed that the room was in a mess — all the objects from her handbag were thrown about the room. Of course, she wanted to put them back into her handbag. The problem is that the girl cannot carry more than two objects at a time, and cannot move the handbag. Also, if he has taken an object, she cannot put it anywhere except her handbag — her inherent sense of order does not let her do so.
You are given the coordinates of the handbag and the coordinates of the objects in some Сartesian coordinate system. It is known that the girl covers the distance between any two objects in the time equal to the squared length of the segment between the points of the objects. It is also known that initially the coordinates of the girl and the handbag are the same. You are asked to find such an order of actions, that the girl can put all the objects back into her handbag in a minimum time period.
The first line of the input file contains the handbag's coordinates xs, ys. The second line contains number n (1 ≤ n ≤ 24) — the amount of objects the girl has. The following n lines contain the objects' coordinates. All the coordinates do not exceed 100 in absolute value. All the given positions are different. All the numbers are integer.
","input
In the first line output the only number — the minimum time the girl needs to put the objects into her handbag. 
output
In the second line output the possible optimum way for Lena. Each object in the input is described by its index number (from 1 to n), the handbag's point is described by number 0. The path should start and end in the handbag's point. If there are several optimal paths, print any of them. 
","bitmasks, dp",7
"import java.io.*;
import java.util.*;
public class Main {
    public static void main(String args[])
    {
        long start=System.currentTimeMillis();
        FastReader input=new FastReader();
        PrintWriter out=new PrintWriter(System.out);
        int T=1;
        while(T-->0)
        {
            long n=input.nextLong();
            int m=input.nextInt();
            long k=input.nextLong();
            long p[]=new long[(int)m];
            for(int i=0;i<m;i++)
            {
                p[i]=input.nextLong();
            }
            long sum=0;
            int i=0;
            int count=0;
            while(i<m)
            {
                HashSet<Long> set=new HashSet<>();
                int ind=-1;
                for(int j=i;j<m;j++)
                {
                    long x=p[j]-sum;
                    long y=0;
                    if(x%k==0)
                    {
                        y=x/k;
                    }
                    else
                    {
                        y=x/k;
                        y++;
                    }
                    set.add(y);
                    if(set.size()>1)
                    {
                        ind=j;
                        break;
                    }
                }
                count++;
                if(ind==-1)
                {
                    break;
                }
                sum+=ind-i;
                i=ind;
            }
            out.println(count);
        }
        out.close();
    }
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}",1191_C,CODEFORCES,2160,Tokitsukaze and Discard Items,"Recently, Tokitsukaze found an interesting game. Tokitsukaze had $$$n$$$ items at the beginning of this game. However, she thought there were too many items, so now she wants to discard $$$m$$$ ($$$1 \le m \le n$$$) special items of them.
These $$$n$$$ items are marked with indices from $$$1$$$ to $$$n$$$. In the beginning, the item with index $$$i$$$ is placed on the $$$i$$$-th position. Items are divided into several pages orderly, such that each page contains exactly $$$k$$$ positions and the last positions on the last page may be left empty.
Tokitsukaze would do the following operation: focus on the first special page that contains at least one special item, and at one time, Tokitsukaze would discard all special items on this page. After an item is discarded or moved, its old position would be empty, and then the item below it, if exists, would move up to this empty position. The movement may bring many items forward and even into previous pages, so Tokitsukaze would keep waiting until all the items stop moving, and then do the operation (i.e. check the special page and discard the special items) repeatedly until there is no item need to be discarded.
Tokitsukaze wants to know the number of operations she would do in total.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \le n \le 10^{18}$$$, $$$1 \le m \le 10^5$$$, $$$1 \le m, k \le n$$$) — the number of items, the number of special items to be discarded and the number of positions in each page.
The second line contains $$$m$$$ distinct integers $$$p_1, p_2, \ldots, p_m$$$ ($$$1 \le p_1 < p_2 < \ldots < p_m \le n$$$) — the indices of special items which should be discarded.
Print a single integer — the number of operations that Tokitsukaze would do in total.
","input
For the first example:
output
For the second example, Tokitsukaze would focus on the second page $$$[6, 7, 8, 9, 10]$$$ and discard all special items at once.
",implementation,3
"import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {
	static BigInteger tow=new BigInteger(""2""),mod=new BigInteger(""1000000007"");
	static BigInteger pow(BigInteger a,BigInteger b) {
		if(b.equals(BigInteger.ZERO))return BigInteger.ONE;
		BigInteger x=pow(a,b.divide(tow));
		if(b.mod(tow).equals(BigInteger.ZERO)) 
			return x.mod(mod).multiply(x.mod(mod)).mod(mod);
		else 
			return x.mod(mod).multiply(x.mod(mod)).mod(mod).multiply(a).mod(mod);
	}
	public static void main(String[] args) throws IOException {
		BigInteger x=in.RB(),k=in.RB();
		if(k.equals(BigInteger.ZERO))System.out.println(x.multiply(tow).mod(mod));
		else if(x.equals(BigInteger.ZERO))System.out.println(0);
		else {
			BigInteger x1=tow.multiply(x).subtract(BigInteger.ONE);
			x1=x1.mod(mod);
			BigInteger x2=pow(tow,k);
			x2=x2.mod(mod);
			System.out.println(x1.multiply(x2).add(BigInteger.ONE).mod(mod));
			
		}
	}
}


class in{
	static StringTokenizer st=new StringTokenizer("""");
	static BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
	static String next() throws IOException {
		while(!st.hasMoreTokens())st=new StringTokenizer(bf.readLine());
		return st.nextToken();
	}
	static int RI() throws IOException {
		return Integer.parseInt(next());
	}
	static BigInteger RB() throws IOException {
		return new BigInteger(next());
	}
}",0992_C,CODEFORCES,1168,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import java.util.*;
import java.io.*;
public class Main{

        BufferedReader in;
        StringTokenizer str = null;
        PrintWriter out;

        private String next() throws Exception{
                if (str == null || !str.hasMoreTokens())
                        str = new StringTokenizer(in.readLine());
                return str.nextToken();
        }
        
        private int nextInt() throws Exception{
                return Integer.parseInt(next());
        }
        
        private long nextLong() throws Exception{
                return Long.parseLong(next());
        }
        
        private double nextDouble() throws Exception{
                return Double.parseDouble(next());
        }

        public void run() throws Exception{
                in = new BufferedReader(new InputStreamReader(System.in));//new FileReader();
                out = new PrintWriter(System.out);//new File();
                int n = nextInt();
                HashSet<Integer> hs = new HashSet<Integer>();
                for(int i=0;i<n;i++) hs.add(nextInt());
                if (hs.size() == 1){
                  out.println(""NO"");
                  out.close();
                  return;
                }
                int a[] = new int[hs.size()];
                int yk = 0;
                for(int i:hs) a[yk++] = i;
                Arrays.sort(a);
                out.println(a[1]);
                out.close();
        }

        public static void main(String args[]) throws Exception{
                new Main().run();
        }
}
 
",0022_A,CODEFORCES,2335,Second Order Statistics,"Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.
","input
The first input line contains integer n (1 ≤ n ≤ 100) — amount of numbers in the sequence. The second line contains n space-separated integer numbers — elements of the sequence. These numbers don't exceed 100 in absolute value.
output
If the given sequence has the second order statistics, output this order statistics, otherwise output NO.
",bruteforce,4
"

import java.util.*;
import java.io.*;
import java.awt.Point;
import java.math.BigInteger;

import static java.lang.Math.*;

// Solution is at the bottom of code

public class _AAAA implements Runnable{
	
	final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;
	
	BufferedReader in;
	OutputWriter out;
	StringTokenizer tok = new StringTokenizer("""");
	
	public static void main(String[] args){
		new Thread(null, new _AAAA(), """", 128 * (1L << 20)).start();
	}
	
	/////////////////////////////////////////////////////////////////////
	
	void init() throws FileNotFoundException{
		Locale.setDefault(Locale.US);
		
		if (ONLINE_JUDGE){
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new OutputWriter(System.out);
		}else{
			in = new BufferedReader(new FileReader(""input.txt""));
			out = new OutputWriter(""output.txt"");
		}
	}
	
	////////////////////////////////////////////////////////////////
	
	long timeBegin, timeEnd;

	void time(){
		timeEnd = System.currentTimeMillis();
		System.err.println(""Time = "" + (timeEnd - timeBegin));
	}
	
	void debug(Object... objects){
		if (ONLINE_JUDGE){
			for (Object o: objects){
				System.err.println(o.toString());
			}
		}
	}
	
	/////////////////////////////////////////////////////////////////////
	
	public void run(){
		try{
			timeBegin = System.currentTimeMillis();
			Locale.setDefault(Locale.US);
			
			init();
			solve();
			
			out.close();
			time();
		}catch (Exception e){
			e.printStackTrace(System.err);
			System.exit(-1);
		}
	}
	
	/////////////////////////////////////////////////////////////////////
	
	String delim = "" "";
	
	String readString() throws IOException{
		while(!tok.hasMoreTokens()){
			try{
				tok = new StringTokenizer(in.readLine());
			}catch (Exception e){
				return null;
			}
		}
		
		return tok.nextToken(delim);
	}
	
	String readLine() throws IOException{
		return in.readLine();
	}
	
	/////////////////////////////////////////////////////////////////
	
	final char NOT_A_SYMBOL = '\0';
	
	char readChar() throws IOException{
		int intValue = in.read();
		
		if (intValue == -1){
			return NOT_A_SYMBOL;
		}
		
		return (char) intValue;
	}
	
	char[] readCharArray() throws IOException{
		return readLine().toCharArray();
	}
	
	/////////////////////////////////////////////////////////////////
	
	int readInt() throws IOException{
		return Integer.parseInt(readString());
	}
	
	int[] readIntArray(int size) throws IOException{
		int[] array = new int[size];
		
		for (int index = 0; index < size; ++index){
			array[index] = readInt();
		}
		
		return array;
	}
	
	///////////////////////////////////////////////////////////////////
	
	long readLong() throws IOException{
		return Long.parseLong(readString());
	}
	
	long[] readLongArray(int size) throws IOException{
		long[] array = new long[size];
		
		for (int index = 0; index < size; ++index){
			array[index] = readLong();
		}
		
		return array;
	}
	
	////////////////////////////////////////////////////////////////////
	
	double readDouble() throws IOException{
		return Double.parseDouble(readString());
	}
	
	double[] readDoubleArray(int size) throws IOException{
		double[] array = new double[size];
		
		for (int index = 0; index < size; ++index){
			array[index] = readDouble();
		}
		
		return array;
	}
	
	/////////////////////////////////////////////////////////////////////
	
	Point readPoint() throws IOException{
		return new Point(readInt(), readInt());
	}
	
	Point[] readPointArray(int size) throws IOException{
		Point[] array = new Point[size];
		
		for (int index = 0; index < size; ++index){
			array[index] = readPoint();
		}
		
		return array;
	}
	
	/////////////////////////////////////////////////////////////////////
	
	class OutputWriter extends PrintWriter{

		final int DEFAULT_PRECISION = 12;
		
		int precision;
		String format, formatWithSpace;
		
		{
			precision = DEFAULT_PRECISION;
			
			format = createFormat(precision);
			formatWithSpace = format + "" "";
		}
		
		public OutputWriter(OutputStream out) {
			super(out);
		}

		public OutputWriter(String fileName) throws FileNotFoundException {
			super(fileName);
		}
		
		public int getPrecision() {
			return precision;
		}

		public void setPrecision(int precision) {
			this.precision = precision;
			
			format = createFormat(precision);
			formatWithSpace = format + "" "";
		}
		
		private String createFormat(int precision){
			return ""%."" + precision + ""f"";
		}
		
		@Override
		public void print(double d){
			printf(format, d);
		}
		
		public void printWithSpace(double d){
			printf(formatWithSpace, d);
		}

		public void printAll(double...d){
			for (int i = 0; i < d.length - 1; ++i){
				printWithSpace(d[i]);
			}
			
			print(d[d.length - 1]);
		}
		
		@Override
		public void println(double d){
			printlnAll(d);
		}
		
		public void printlnAll(double... d){
			printAll(d);
			println();
		}
	}
	
	/////////////////////////////////////////////////////////////////////
	
	int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; 
	
	boolean check(int index, int lim){
		return (0 <= index && index < lim);
	}
	
	/////////////////////////////////////////////////////////////////////
	
	void solve() throws IOException{
		int n = readInt();
		int k = readInt();
		
		Map<Long, Integer> map = new TreeMap<Long, Integer>();
		for (int i = 0; i < n; ++i){
			map.put(readLong(), i);
		}
		
		int ans = 0;
		boolean[] used = new boolean[n];
		for (Map.Entry<Long, Integer> e: map.entrySet()){
			if (used[e.getValue()]) continue;
			long value = e.getKey() * k;
			Integer index = map.get(value);
			
			if (index != null){
				used[index] = true;
			}
			
			++ans;
		}
		
		out.println(ans);
	}
}

",0274_A,CODEFORCES,2712,k-Multiple Free Set,"A k-multiple free set is a set of integers where there is no pair of integers where one is equal to another integer multiplied by k. That is, there are no two integers x and y (x < y) from the set, such that y = x·k.
You're given a set of n distinct positive integers. Your task is to find the size of it's largest k-multiple free subset.
The first line of the input contains two integers n and k (1 ≤ n ≤ 105, 1 ≤ k ≤ 109). The next line contains a list of n distinct positive integers a1, a2, ..., an (1 ≤ ai ≤ 109).
All the numbers in the lines are separated by single spaces.
","input
On the only line of the output print the size of the largest k-multiple free subset of {a1, a2, ..., an}.
output
In the sample input one of the possible maximum 2-multiple free subsets is {4, 5, 6}.
","binarysearch, greedy, sortings",4
"import org.omg.PortableServer.AdapterActivator;

import java.io.*;
import java.lang.reflect.Array;
import java.net.CookieHandler;
import java.util.*;
import java.math.*;
import java.lang.*;
import java.util.concurrent.LinkedBlockingDeque;

import static java.lang.Math.*;

public class TaskA implements Runnable {
    long m = (int)1e9+7;
    PrintWriter w;
    InputReader c;
    public void run() {
        c = new InputReader(System.in);
        w = new PrintWriter(System.out);
        int n = c.nextInt();
        int a[] = scanArrayI(n);
        int maxtime = Integer.MAX_VALUE,ind = -1;
        for(int i=0;i<n;i++){
            int time = Integer.MAX_VALUE;
            if(a[i]<i+1)
                time = i;
            else{
                time = (int)ceil((a[i] - i)/(double)n) * n + i;
            }
            if(time<maxtime){
                maxtime = time;
                ind = i;
            }
        }
        w.println(ind+1);
        w.close();
    }
    static long gcd(long a, long b) {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }
    public static void sortbyColumn(int arr[][], int col){
        Arrays.sort(arr, new Comparator<int[]>()
        {
            public int compare(int[] o1, int[] o2){
                return(Integer.valueOf(o1[col]).compareTo(o2[col]));
            }
        });

    }
    public static class DJSet {
        public int[] upper;

        public DJSet(int n) {
            upper = new int[n];
            Arrays.fill(upper, -1);
        }

        public int root(int x) {
            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
        }

        public boolean equiv(int x, int y) {
            return root(x) == root(y);
        }

        public boolean union(int x, int y) {
            x = root(x);
            y = root(y);
            if (x != y) {
                if (upper[y] < upper[x]) {
                    int d = x;
                    x = y;
                    y = d;
                }
                upper[x] += upper[y];
                upper[y] = x;
            }
            return x == y;
        }
    }
    public static int[] radixSort(int[] f)    {
        int[] to = new int[f.length];
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        return f;
    }
    public void printArray(int[] a){
        for(int i=0;i<a.length;i++)
            w.print(a[i]+"" "");
        w.println();
    }
    public int[] scanArrayI(int n){
        int a[] = new int[n];
        for(int i=0;i<n;i++)
            a[i] = c.nextInt();
        return a;
    }
    public long[] scanArrayL(int n){
        long a[] = new long[n];
        for(int i=0;i<n;i++)
            a[i] = c.nextLong();
        return a;
    }
    public void printArray(long[] a){
        for(int i=0;i<a.length;i++)
            w.print(a[i]+"" "");
        w.println();
    }
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars==-1)
                throw new InputMismatchException();

            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                }
                catch (IOException e) {
                    throw new InputMismatchException();
                }

                if(numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            int c = read();

            while(isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;
            do {
                if(c<'0'||c>'9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    public static void main(String args[]) throws Exception {
        new Thread(null, new TaskA(),""TaskA"",1<<26).start();
    }
}",0996_B,CODEFORCES,2843,World Cup,"Allen wants to enter a fan zone that occupies a round square and has $$$n$$$ entrances.
There already is a queue of $$$a_i$$$ people in front of the $$$i$$$-th entrance. Each entrance allows one person from its queue to enter the fan zone in one minute.
Allen uses the following strategy to enter the fan zone: 
Determine the entrance through which Allen will finally enter the fan zone.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^5$$$) — the number of entrances.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_i \le 10^9$$$) — the number of people in queues. These numbers do not include Allen.
Print a single integer — the number of entrance that Allen will use.
In the first example the number of people (not including Allen) changes as follows: $$$[\textbf{2}, 3, 2, 0] \to [1, \textbf{2}, 1, 0] \to [0, 1, \textbf{0}, 0]$$$. The number in bold is the queue Alles stands in. We see that he will enter the fan zone through the third entrance.
","input
In the second example the number of people (not including Allen) changes as follows: $$$[\textbf{10}, 10] \to [9, \textbf{9}] \to [\textbf{8}, 8] \to [7, \textbf{7}] \to [\textbf{6}, 6] \to \\ [5, \textbf{5}] \to [\textbf{4}, 4] \to [3, \textbf{3}] \to [\textbf{2}, 2] \to [1, \textbf{1}] \to [\textbf{0}, 0]$$$.
output
In the third example the number of people (not including Allen) changes as follows: $$$[\textbf{5}, 2, 6, 5, 7, 4] \to [4, \textbf{1}, 5, 4, 6, 3] \to [3, 0, \textbf{4}, 3, 5, 2] \to \\ [2, 0, 3, \textbf{2}, 4, 1] \to [1, 0, 2, 1, \textbf{3}, 0] \to [0, 0, 1, 0, 2, \textbf{0}]$$$.
","binarysearch, math",4
"import java.io.PrintWriter;
import java.util.Scanner;

/**
 * Created with IntelliJ IDEA.
 * User: vaibhav mittal
 * Date: 23/6/12
 * Time: 1:15 AM
 * To change this template use File | Settings | File Templates.
 */
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);

        long n = in.nextLong();
        out.println(0 + "" "" + 0 + "" "" + n);

        in.close();
        out.close();
    }
}
",0199_A,CODEFORCES,201,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"import java.util.*;
import java.io.*;

public class P1 {
	public static void main(String[] args) {
		String s = null;
		// citire
		try {
//			Scanner sc = new Scanner(new File(""in.txt""));
			Scanner sc = new Scanner(System.in);
			s = sc.next();
			
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		
		int n = s.length();
		
		HashSet<String> h = new HashSet<String>();
		String t=null;
		boolean b;
		int lmax = 0;
		for (int i=0; i<n; i++) {
			for (int j=i+1; j<=n; j++) {
				t = s.substring(i, j);
				b = h.add(t);
//				System.out.println(t + ""	""  + b);
				if (b==false) {
					if (j-i>lmax) {
						lmax = j-i;
//						System.out.println(t);
					}
				}
			}
		}
		System.out.println(lmax);
	}
}
",0023_A,CODEFORCES,3736,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"
import java.awt.Point;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class A {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int k = in.nextInt() - 1;
        Point[] A = new Point[n];
        for (int i = 0; i < n; i++)
            A[i] = new Point(in.nextInt(), in.nextInt());
        Arrays.sort(A, new Comparator<Point>() {
            public int compare(Point o1, Point o2) {
                if (o1.x != o2.x)
                    return o2.x - o1.x;
                if (o1.y != o2.y)
                    return o1.y - o2.y;
                return 0;
            }
        });
        int i = k;
        int j = k;
        while (i >= 0 && A[i].x == A[k].x && A[i].y == A[k].y)
            i--;
        while (j < n && A[j].x == A[k].x && A[j].y == A[k].y)
            j++;
        System.out.println(j - i - 1);
    }
}
",0166_A,CODEFORCES,2486,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class PipelineRedo {
	public static void main(String[] args){
		FastScanner sc = new FastScanner();
		long n = sc.nextLong() - 1;
		long k = sc.nextInt() - 1;
		
		if(n==0){
			System.out.println(0);
			return;
		}else if(n <= k){
			System.out.println(1);
			return;
		}else if(n > k*(k+1)/2){
			System.out.println(-1);
			return;
		}
		
		//n > k, and there exists a subset (1..k) = n
		//goal : sum( subset of (1...k) ) = n
		//obs: if exists a soln, it's always possible to push everything to the right-> t + left...k
		//so that t + left...k = n, so we just have to find the smallest left such that left..k <= n
		long rightSum = k*(k+1)/2;
		long lo = 1;
		long hi = k;
		while(lo < hi){
			long mid = lo + (hi-lo+1)/2;
			long val = rightSum - mid*(mid-1)/2;
			
			if(val <= n){
				hi = mid -1;
			}else{
				lo = mid;
			}
		}
		//now lo points to the greatest left for which left..k > n
		//so lo+1 points to the smallest left for which left..k <= n
		//we still have an extra 't' to the left
		if(rightSum - (lo+1)*(lo)/2 == n){
			System.out.println(k - (lo+1) + 1);
		}else{
			System.out.println(1 + (k - (lo+1) + 1));
		}
	}
	
	public static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(String s) {
			try {
				br = new BufferedReader(new FileReader(s));
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		public FastScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String nextToken() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(nextToken());
		}

		long nextLong() {
			return Long.parseLong(nextToken());
		}

		double nextDouble() {
			return Double.parseDouble(nextToken());
		}
	}
}
",0287_B,CODEFORCES,921,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.util.Scanner;
public class Main
{
	public static void main(String[] args) {
	    Scanner sc =new Scanner(System.in);
	    long n=sc.nextLong();
	    long x=1;
	    long ar=0;
	    tag:for(long i=1;;i++)
	    {
	        ar+=9*i*x;
	        if(ar>=n)
	        {
	            long d = n - (ar-9*i*x);
	            long ans = x+d/i;
	            long p=d%i;
	            if(p==0)
	            {
	                p=i;
	                ans--;
	            }
	            p=i-p;
	            p++;
	            long fns=0;
	            //System.out.println(ans);
	            while(p!=0)
	            {
	                fns=ans%10;
	                ans/=10;
	                p--;
	            }
	            System.out.println(fns);
	            
	            break tag;
	        }
	        x*=10;
	    }
	}
}
",1177_B,CODEFORCES,1303,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;


public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int l, r, sum = 0;
            int[] a = new int[n+5];
            for (int i = 0; i < n; i++) a[i] = in.nextInt();
            for (int i = 0; i < n; i++)
                for (int j = i+1; j < n; j++)
                    if (a[i] > a[j]) sum++;
            int q = in.nextInt();
            while (q-- > 0){
                l = in.nextInt();
                r = in.nextInt();
                sum += (r-l+1)/2;
                if (sum % 2 == 1) out.println(""odd"");
                else out.println(""even"");
            }
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}
	  		 	 		 			      	  			    	",0911_D,CODEFORCES,3174,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.io.*;
import java.util.StringTokenizer;


public class Main {
    static int[] a;

    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int n = sc.nextInt();
        a = sc.nextIntArray(n);
        long inversions = divide(0, n - 1);
//        out.println(inversions);
//        System.err.println(Arrays.toString(a));
        if (n == 5) out.println(""Petr"");
        else {
            if (n % 2 == 0) out.println(inversions % 2 == 0 ? ""Petr"" : ""Um_nik"");
            else out.println(inversions % 2 != 0 ? ""Petr"" : ""Um_nik"");
        }
        out.flush();
        out.close();
    }

    static long divide(int b, int e) {
        if (b == e) return 0;
        long cnt = 0;
        int mid = b + e >> 1;
        cnt += divide(b, mid);
        cnt += divide(mid + 1, e);
        cnt += merge(b, mid, e);
        return cnt;
    }

    static long merge(int b, int mid, int e) {
        long cnt = 0;
        int len = e - b + 1;
        int[] tmp = new int[len];
        int i = b, j = mid + 1;
        for (int k = 0; k < len; k++) {
            if (i == mid + 1 || (j != e + 1 && a[i] > a[j])) {
                tmp[k] = a[j++];
                cnt += (mid + 1 - i);
            } else tmp[k] = a[i++];
        }
        for (int k = 0; k < len; k++)
            a[b + k] = tmp[k];
        return cnt;
    }

    static class Scanner {

        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream system) {
            br = new BufferedReader(new InputStreamReader(system));
        }


        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public char nextChar() throws IOException {
            return next().charAt(0);
        }

        public Long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public boolean ready() throws IOException {
            return br.ready();
        }


        public int[] nextIntArray(int n) throws IOException {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public long[] nextLongArray(int n) throws IOException {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }


        public Integer[] nextIntegerArray(int n) throws IOException {
            Integer[] a = new Integer[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public double[] nextDoubleArray(int n) throws IOException {
            double[] ans = new double[n];
            for (int i = 0; i < n; i++)
                ans[i] = nextDouble();
            return ans;
        }

        public short nextShort() throws IOException {
            return Short.parseShort(next());
        }

    }
}",0986_B,CODEFORCES,2827,Petr and Permutations,"Petr likes to come up with problems about randomly generated data. This time problem is about random permutation. He decided to generate a random permutation this way: he takes identity permutation of numbers from $$$1$$$ to $$$n$$$ and then $$$3n$$$ times takes a random pair of different elements and swaps them. Alex envies Petr and tries to imitate him in all kind of things. Alex has also come up with a problem about random permutation. He generates a random permutation just like Petr but swaps elements $$$7n+1$$$ times instead of $$$3n$$$ times. Because it is more random, OK?!
You somehow get a test from one of these problems and now you want to know from which one.
In the first line of input there is one integer $$$n$$$ ($$$10^{3} \le n \le 10^{6}$$$).
In the second line there are $$$n$$$ distinct integers between $$$1$$$ and $$$n$$$ — the permutation of size $$$n$$$ from the test.
It is guaranteed that all tests except for sample are generated this way: First we choose $$$n$$$ — the size of the permutation. Then we randomly choose a method to generate a permutation — the one of Petr or the one of Alex. Then we generate a permutation using chosen method.
If the test is generated via Petr's method print ""Petr"" (without quotes). If the test is generated via Alex's method print ""Um_nik"" (without quotes).
","input
Please note that the sample is not a valid test (because of limitations for $$$n$$$) and is given only to illustrate input/output format. Your program still has to print correct answer to this test to get AC.
output
Due to randomness of input hacks in this problem are forbidden.
","combinatorics, math",4
"import java.io.*;
import java.util.*;

public class A {
    public static void main(String[] args) throws Exception {
	// TODO Auto-generated method stub
	BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
	PrintWriter out = new PrintWriter(System.out);
	String s = bf.readLine();
	out.println(25);
	
	out.flush();
	out.close();

    }
}
",0630_A,CODEFORCES,561,Again Twenty Five!,"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. ""Do I give such a hard task?"" — the HR manager thought. ""Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.""
Could you pass the interview in the machine vision company in IT City?
","input
The only line of the input contains a single integer n (2 ≤ n ≤ 2·1018) — the power in which you need to raise number 5.
output
Output the last two digits of 5n without spaces between them.
",numbertheory,1
"import java.util.Locale;
import java.util.Scanner;

public class E {
	public static void main(String[] args) {
		new E().run();
	}

	private void run() {
		Locale.setDefault(Locale.US);
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		double[][] p = new double[n][n];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++)
				p[i][j] = sc.nextDouble();
		}
		sc.close();
		double[] w = new double[1 << n];
		int max = (1 << n) - 1;
		w[max] = 1;
		for (int mask = max; mask > 0; mask--) {
			int count = 0;
			for (int i = 0; i < n; i++)
				if (((mask >> i) & 1) > 0)
					for (int j = i + 1; j < n; j++)
						if (((mask >> j) & 1) > 0) {
							count++;
						}
			if (count > 0)
				for (int i = 0; i < n; i++)
					if (((mask >> i) & 1) > 0)
						for (int j = i + 1; j < n; j++)
							if (((mask >> j) & 1) > 0) {
								w[mask ^ (1 << j)] += w[mask] * p[i][j] / count;
								w[mask ^ (1 << i)] += w[mask] * (1 - p[i][j])
										/ count;
							}
		}
		for (int i = 0; i < n; i++) {
			if (i != 0)
				System.out.print(' ');
			System.out.printf(""%.6f"", w[1 << i]);
		}
		System.out.println();
	}
}
",0016_E,CODEFORCES,4518,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author pttrung
 */
public class B {

    static Senator[] data;

    public static void main(String[] args) {
        Scanner in = new Scanner(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);
        int n = in.nextInt();
        int k = in.nextInt();
        int A = in.nextInt();
        data = new Senator[n];
        for (int i = 0; i < n; i++) {
            data[i] = new Senator(in.nextInt(), in.nextInt());
        }
        out.println(cal(0, new int[n], A, k));

        out.close();
    }

    public static double cal(int index, int[] num, int A, int left) {
        if (index == data.length - 1) {
            int dif = (100 - data[index].loyal)/10;
            dif = left >= dif? dif:left;
            num[index] =  dif;
           
            double result = 0;
            for (int k = 0; k < (1 << num.length); k++) {
                double val = 1;
                double total = 0;
                for (int i = 0; i < num.length; i++) {
                    if (((1 << i) & k) != 0) {
                        val *= ((double)(data[i].loyal + 10*num[i])/100);
                    } else {
                        val *= ((double)(100 - (data[i].loyal + 10*num[i]))/100);
                        total += data[i].level;
                    }
                }
                if (countBit(k) > num.length / 2) {
                    result += val;
                } else {
                    result += val * ((double) A / (A + total));
                }
            }
//           // if(result >= 1){
//                for(int i : num){
//                    System.out.print(i + "" "");
//                }
//                System.out.println(""\n"" + result);
//            //}
            return result;
        } else {
            double result = 0;
            for (int i = 0; i <= left; i++) {
                if (i * 10 + data[index].loyal <= 100) {
                    num[index] = i;
                  //  double val = cal(index + 1 , num , A, left - i);
                    
                    result = Math.max(result, cal(index + 1, num, A, left - i));
                } else {
                    break;
                }
            }
            return result;
        }
    }

    public static int countBit(int val) {
        int result = 0;
        while (val > 0) {
            result += val % 2;
            val >>= 1;
        }
        return result;
    }

    public static class Senator {

        int level, loyal;

        public Senator(int level, int loyal) {
            this.level = level;
            this.loyal = loyal;
        }
    }

    public static boolean nextPer(int[] data) {
        int i = data.length - 1;
        while (i > 0 && data[i] < data[i - 1]) {
            i--;
        }
        if (i == 0) {
            return false;
        }
        int j = data.length - 1;
        while (data[j] < data[i - 1]) {
            j--;
        }
        int temp = data[i - 1];
        data[i - 1] = data[j];
        data[j] = temp;
        Arrays.sort(data, i, data.length);
        return true;
    }

    public static class Point {

        int x, y, z;

        public Point(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }

    public double pow(double a, int b) {
        if (b == 0) {
            return 1;
        }
        if (b == 1) {
            return a;
        }
        double val = pow(a, b / 2);
        if (b % 2 == 0) {
            return val * val;
        } else {
            return val * val * a;
        }
    }

    public static long gcd(long a, long b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }

    public static long lcm(long a, long b) {
        return a * b / gcd(a, b);
    }
}
",0105_B,CODEFORCES,4557,Dark Assembly,"Dark Assembly is a governing body in the Netherworld. Here sit the senators who take the most important decisions for the player. For example, to expand the range of the shop or to improve certain characteristics of the character the Dark Assembly's approval is needed.
The Dark Assembly consists of n senators. Each of them is characterized by his level and loyalty to the player. The level is a positive integer which reflects a senator's strength. Loyalty is the probability of a positive decision in the voting, which is measured as a percentage with precision of up to 10%. 
Senators make decisions by voting. Each of them makes a positive or negative decision in accordance with their loyalty. If strictly more than half of the senators take a positive decision, the player's proposal is approved. 
If the player's proposal is not approved after the voting, then the player may appeal against the decision of the Dark Assembly. To do that, player needs to kill all the senators that voted against (there's nothing wrong in killing senators, they will resurrect later and will treat the player even worse). The probability that a player will be able to kill a certain group of senators is equal to A / (A + B), where A is the sum of levels of all player's characters and B is the sum of levels of all senators in this group. If the player kills all undesired senators, then his proposal is approved.
Senators are very fond of sweets. They can be bribed by giving them candies. For each received candy a senator increases his loyalty to the player by 10%. It's worth to mention that loyalty cannot exceed 100%. The player can take no more than k sweets to the courtroom. Candies should be given to the senators before the start of voting.
Determine the probability that the Dark Assembly approves the player's proposal if the candies are distributed among the senators in the optimal way.
The first line contains three integers n, k and A (1 ≤ n, k ≤ 8, 1 ≤ A ≤ 9999).
Then n lines follow. The i-th of them contains two numbers — bi and li — the i-th senator's level and his loyalty.
The levels of all senators are integers in range from 1 to 9999 (inclusive). The loyalties of all senators are integers in range from 0 to 100 (inclusive) and all of them are divisible by 10.
Print one real number with precision 10 - 6 — the maximal possible probability that the Dark Assembly approves the player's proposal for the best possible distribution of candies among the senators.
","input
In the first sample the best way of candies' distribution is giving them to first three of the senators. It ensures most of votes.
output
It the second sample player should give all three candies to the fifth senator.
","bruteforce, probabilities",7
"import java.util.Scanner;

public class C {
  public static void main (String args[]) {
    Scanner in = new Scanner(System.in);
    
    int n = in.nextInt();
    int r = in.nextInt();
    
    double pos[][] = new double[n][2];
    
    for(int i = 0; i < n; i++) {
    	
    	pos[i][0] = in.nextInt();
    	
    	double y = r;
    	
    	for(int j = 0; j < i; j++) {
    		if(Math.abs(pos[i][0] - pos[j][0]) <= 2*r) {
    			
    			double tempy = pos[j][1] + Math.sqrt(Math.pow(2*r, 2) - Math.pow(Math.abs(pos[i][0] - pos[j][0]), 2));
    			
    			if(tempy > y) y = tempy;
    		}
    	}
    	
    	pos[i][1] = y;
    	System.out.print(y + "" "");
    }
  }
}",0908_C,CODEFORCES,3018,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"import java.io.*;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.Queue;

public class E3 {
	InputStream is;
	FastWriter out;
	String INPUT = """";
	
	void solve()
	{
		for(int T = ni();T > 0;T--)go();
	}

	int[] lpf = enumLowestPrimeFactors(10000000);

	void go()
	{
		int n = ni(), K = ni();
		int[] a = na(n);
		for(int i = 0;i < n;i++){
			a[i] = factorFast(a[i], lpf);
		}
		a = shrink(a);

		int[][] dp = new int[K+1][n+1];
		for(int i = 0;i <= K;i++){
			Arrays.fill(dp[i], 999999999);
		}
		for(int i = 0;i <= K;i++)dp[i][0] = 0;

		int[] prev = makePrev(a, n+1);

		int[] imos = new int[n+5];
		int[] pp = new int[K+1];
		int[] vs = new int[K+1];
		for(int i = 0;i < n;i++){
			int p = prev[i];
			imos[p+1]--;

			for(int j = 0;j <= K;j++){
				vs[j]++;
				if(pp[j] >= p+1){
					vs[j]--;
				}
				while(vs[j] > j){
					pp[j]++;
					vs[j] += imos[pp[j]];
				}
				for(int k = 0;k+j <= K;k++){
					dp[k+j][i+1] = Math.min(dp[k+j][i+1], dp[k][pp[j]] + 1);
				}
			}
		}
		out.println(dp[K][n]);
	}

	public static int[] shrink(int[] a) {
		int n = a.length;
		long[] b = new long[n];
		for (int i = 0; i < n; i++) b[i] = (long) a[i] << 32 | i;
		Arrays.sort(b);
		int[] ret = new int[n];
		int p = 0;
		for (int i = 0; i < n; i++) {
			if (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0) p++;
			ret[(int) b[i]] = p;
		}
		return ret;
	}


	public static int[] makePrev(int[] a, int sup)
	{
		int n = a.length;
		int[] mnext = new int[sup];
		Arrays.fill(mnext, -1);
		int[] next = new int[n];
		for(int i = 0;i < n;i++){
			next[i] = mnext[a[i]];
			mnext[a[i]] = i;
		}
		return next;
	}

	public static int factorFast(int n, int[] lpf)
	{
		int ret = 1;
		int e = 0;
		int last = -1;
		while(lpf[n] > 0) {
			int p = lpf[n];
			if (last != p) {
				if (last > 0 && e % 2 == 1) {
					ret = ret * last;
				}

				last = p;
				e = 1;
			} else {
				e++;
			}
			n /= p;
		}

		if(last > 0 && e % 2 == 1){
			ret *= last;
		}
		return ret;
	}


	public static int[] enumLowestPrimeFactors(int n)
	{
		int tot = 0;
		int[] lpf = new int[n+1];
		int u = n+32;
		double lu = Math.log(u);
		int[] primes = new int[(int)(u/lu+u/lu/lu*1.5)];
		for(int i = 2;i <= n;i++)lpf[i] = i;
		for(int p = 2;p <= n;p++){
			if(lpf[p] == p)primes[tot++] = p;
			int tmp;
			for(int i = 0;i < tot && primes[i] <= lpf[p] && (tmp = primes[i]*p) <= n;i++){
				lpf[tmp] = primes[i];
			}
		}
		return lpf;
	}


	void run() throws Exception
	{
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new FastWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception { new E3().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}

	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}

	private long[] nal(int n)
	{
		long[] a = new long[n];
		for(int i = 0;i < n;i++)a[i] = nl();
		return a;
	}

	private char[][] nm(int n, int m) {
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}

	private int[][] nmi(int n, int m) {
		int[][] map = new int[n][];
		for(int i = 0;i < n;i++)map[i] = na(m);
		return map;
	}

	private int ni() { return (int)nl(); }

	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}

		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

	public static class FastWriter
	{
		private static final int BUF_SIZE = 1<<13;
		private final byte[] buf = new byte[BUF_SIZE];
		private final OutputStream out;
		private int ptr = 0;

		private FastWriter(){out = null;}

		public FastWriter(OutputStream os)
		{
			this.out = os;
		}

		public FastWriter(String path)
		{
			try {
				this.out = new FileOutputStream(path);
			} catch (FileNotFoundException e) {
				throw new RuntimeException(""FastWriter"");
			}
		}

		public FastWriter write(byte b)
		{
			buf[ptr++] = b;
			if(ptr == BUF_SIZE)innerflush();
			return this;
		}

		public FastWriter write(char c)
		{
			return write((byte)c);
		}

		public FastWriter write(char[] s)
		{
			for(char c : s){
				buf[ptr++] = (byte)c;
				if(ptr == BUF_SIZE)innerflush();
			}
			return this;
		}

		public FastWriter write(String s)
		{
			s.chars().forEach(c -> {
				buf[ptr++] = (byte)c;
				if(ptr == BUF_SIZE)innerflush();
			});
			return this;
		}

		private static int countDigits(int l) {
			if (l >= 1000000000) return 10;
			if (l >= 100000000) return 9;
			if (l >= 10000000) return 8;
			if (l >= 1000000) return 7;
			if (l >= 100000) return 6;
			if (l >= 10000) return 5;
			if (l >= 1000) return 4;
			if (l >= 100) return 3;
			if (l >= 10) return 2;
			return 1;
		}

		public FastWriter write(int x)
		{
			if(x == Integer.MIN_VALUE){
				return write((long)x);
			}
			if(ptr + 12 >= BUF_SIZE)innerflush();
			if(x < 0){
				write((byte)'-');
				x = -x;
			}
			int d = countDigits(x);
			for(int i = ptr + d - 1;i >= ptr;i--){
				buf[i] = (byte)('0'+x%10);
				x /= 10;
			}
			ptr += d;
			return this;
		}

		private static int countDigits(long l) {
			if (l >= 1000000000000000000L) return 19;
			if (l >= 100000000000000000L) return 18;
			if (l >= 10000000000000000L) return 17;
			if (l >= 1000000000000000L) return 16;
			if (l >= 100000000000000L) return 15;
			if (l >= 10000000000000L) return 14;
			if (l >= 1000000000000L) return 13;
			if (l >= 100000000000L) return 12;
			if (l >= 10000000000L) return 11;
			if (l >= 1000000000L) return 10;
			if (l >= 100000000L) return 9;
			if (l >= 10000000L) return 8;
			if (l >= 1000000L) return 7;
			if (l >= 100000L) return 6;
			if (l >= 10000L) return 5;
			if (l >= 1000L) return 4;
			if (l >= 100L) return 3;
			if (l >= 10L) return 2;
			return 1;
		}

		public FastWriter write(long x)
		{
			if(x == Long.MIN_VALUE){
				return write("""" + x);
			}
			if(ptr + 21 >= BUF_SIZE)innerflush();
			if(x < 0){
				write((byte)'-');
				x = -x;
			}
			int d = countDigits(x);
			for(int i = ptr + d - 1;i >= ptr;i--){
				buf[i] = (byte)('0'+x%10);
				x /= 10;
			}
			ptr += d;
			return this;
		}

		public FastWriter write(double x, int precision)
		{
			if(x < 0){
				write('-');
				x = -x;
			}
			x += Math.pow(10, -precision)/2;
			//		if(x < 0){ x = 0; }
			write((long)x).write(""."");
			x -= (long)x;
			for(int i = 0;i < precision;i++){
				x *= 10;
				write((char)('0'+(int)x));
				x -= (int)x;
			}
			return this;
		}

		public FastWriter writeln(char c){
			return write(c).writeln();
		}

		public FastWriter writeln(int x){
			return write(x).writeln();
		}

		public FastWriter writeln(long x){
			return write(x).writeln();
		}

		public FastWriter writeln(double x, int precision){
			return write(x, precision).writeln();
		}

		public FastWriter write(int... xs)
		{
			boolean first = true;
			for(int x : xs) {
				if (!first) write(' ');
				first = false;
				write(x);
			}
			return this;
		}

		public FastWriter write(long... xs)
		{
			boolean first = true;
			for(long x : xs) {
				if (!first) write(' ');
				first = false;
				write(x);
			}
			return this;
		}

		public FastWriter writeln()
		{
			return write((byte)'\n');
		}

		public FastWriter writeln(int... xs)
		{
			return write(xs).writeln();
		}

		public FastWriter writeln(long... xs)
		{
			return write(xs).writeln();
		}

		public FastWriter writeln(char[] line)
		{
			return write(line).writeln();
		}

		public FastWriter writeln(char[]... map)
		{
			for(char[] line : map)write(line).writeln();
			return this;
		}

		public FastWriter writeln(String s)
		{
			return write(s).writeln();
		}

		private void innerflush()
		{
			try {
				out.write(buf, 0, ptr);
				ptr = 0;
			} catch (IOException e) {
				throw new RuntimeException(""innerflush"");
			}
		}

		public void flush()
		{
			innerflush();
			try {
				out.flush();
			} catch (IOException e) {
				throw new RuntimeException(""flush"");
			}
		}

		public FastWriter print(byte b) { return write(b); }
		public FastWriter print(char c) { return write(c); }
		public FastWriter print(char[] s) { return write(s); }
		public FastWriter print(String s) { return write(s); }
		public FastWriter print(int x) { return write(x); }
		public FastWriter print(long x) { return write(x); }
		public FastWriter print(double x, int precision) { return write(x, precision); }
		public FastWriter println(char c){ return writeln(c); }
		public FastWriter println(int x){ return writeln(x); }
		public FastWriter println(long x){ return writeln(x); }
		public FastWriter println(double x, int precision){ return writeln(x, precision); }
		public FastWriter print(int... xs) { return write(xs); }
		public FastWriter print(long... xs) { return write(xs); }
		public FastWriter println(int... xs) { return writeln(xs); }
		public FastWriter println(long... xs) { return writeln(xs); }
		public FastWriter println(char[] line) { return writeln(line); }
		public FastWriter println(char[]... map) { return writeln(map); }
		public FastWriter println(String s) { return writeln(s); }
		public FastWriter println() { return writeln(); }
	}

	public void trnz(int... o)
	{
		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");
		System.out.println();
	}

	// print ids which are 1
	public void trt(long... o)
	{
		Queue<Integer> stands = new ArrayDeque<>();
		for(int i = 0;i < o.length;i++){
			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));
		}
		System.out.println(stands);
	}

	public void tf(boolean... r)
	{
		for(boolean x : r)System.out.print(x?'#':'.');
		System.out.println();
	}

	public void tf(boolean[]... b)
	{
		for(boolean[] r : b) {
			for(boolean x : r)System.out.print(x?'#':'.');
			System.out.println();
		}
		System.out.println();
	}

	public void tf(long[]... b)
	{
		if(INPUT.length() != 0) {
			for (long[] r : b) {
				for (long x : r) {
					for (int i = 0; i < 64; i++) {
						System.out.print(x << ~i < 0 ? '#' : '.');
					}
				}
				System.out.println();
			}
			System.out.println();
		}
	}

	public void tf(long... b)
	{
		if(INPUT.length() != 0) {
			for (long x : b) {
				for (int i = 0; i < 64; i++) {
					System.out.print(x << ~i < 0 ? '#' : '.');
				}
			}
			System.out.println();
		}
	}

	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",1497_E2,CODEFORCES,4092,Square-Free Division (hard version),"This is the hard version of the problem. The only difference is that in this version $$$0 \leq k \leq 20$$$.
There is an array $$$a_1, a_2, \ldots, a_n$$$ of $$$n$$$ positive integers. You should divide it into a minimal number of continuous segments, such that in each segment there are no two numbers (on different positions), whose product is a perfect square.
Moreover, it is allowed to do at most $$$k$$$ such operations before the division: choose a number in the array and change its value to any positive integer.
What is the minimum number of continuous segments you should use if you will make changes optimally?
The first line contains a single integer $$$t$$$ $$$(1 \le t \le 1000)$$$  — the number of test cases.
The first line of each test case contains two integers $$$n$$$, $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$0 \leq k \leq 20$$$).
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 10^7$$$).
It's guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \cdot 10^5$$$.
For each test case print a single integer  — the answer to the problem.
","input
In the first test case it is possible to change the array this way: $$$[\underline{3}, 6, 2, 4, \underline{5}]$$$ (changed elements are underlined). After that the array does not need to be divided, so the answer is $$$1$$$.
output
In the second test case it is possible to change the array this way: $$$[6, 2, \underline{3}, 8, 9, \underline{5}, 3, 6, \underline{10}, \underline{11}, 7]$$$. After that such division is optimal: 
","datastructures, dp, greedy, math, numbertheory, twopointers",6
"import java.util.*;
import java.io.*;
import java.math.*;
import java.awt.geom.*;

public class FunctionHeight {
    public static void main(String[] args) {
        MyScanner sc = new MyScanner();
        long n = sc.nl();
        long k = sc.nl();
        long ans = (n+k-1)/n;
        System.out.println(ans);
    }

    /////////// TEMPLATE FROM HERE /////////////////
    private static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int ni() {
            return Integer.parseInt(next());
        }

        float nf() {
            return Float.parseFloat(next());
        }

        long nl() {
            return Long.parseLong(next());
        }

        double nd() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}",1036_A,CODEFORCES,686,Function Height,"You are given a set of $$$2n+1$$$ integer points on a Cartesian plane. Points are numbered from $$$0$$$ to $$$2n$$$ inclusive. Let $$$P_i$$$ be the $$$i$$$-th point. The $$$x$$$-coordinate of the point $$$P_i$$$ equals $$$i$$$. The $$$y$$$-coordinate of the point $$$P_i$$$ equals zero (initially). Thus, initially $$$P_i=(i,0)$$$.
The given points are vertices of a plot of a piecewise function. The $$$j$$$-th piece of the function is the segment $$$P_{j}P_{j + 1}$$$.
In one move you can increase the $$$y$$$-coordinate of any point with odd $$$x$$$-coordinate (i.e. such points are $$$P_1, P_3, \dots, P_{2n-1}$$$) by $$$1$$$. Note that the corresponding segments also change.
For example, the following plot shows a function for $$$n=3$$$ (i.e. number of points is $$$2\cdot3+1=7$$$) in which we increased the $$$y$$$-coordinate of the point $$$P_1$$$ three times and $$$y$$$-coordinate of the point $$$P_5$$$ one time:
Let the area of the plot be the area below this plot and above the coordinate axis OX. For example, the area of the plot on the picture above is 4 (the light blue area on the picture above is the area of the plot drawn on it).
Let the height of the plot be the maximum $$$y$$$-coordinate among all initial points in the plot (i.e. points $$$P_0, P_1, \dots, P_{2n}$$$). The height of the plot on the picture above is 3.
Your problem is to say which minimum possible height can have the plot consisting of $$$2n+1$$$ vertices and having an area equal to $$$k$$$. Note that it is unnecessary to minimize the number of moves.
It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 10^{18}$$$) — the number of vertices in a plot of a piecewise function and the area we need to obtain.
Print one integer — the minimum possible height of a plot consisting of $$$2n+1$$$ vertices and with an area equals $$$k$$$. It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
One of the possible answers to the first example:
The area of this plot is 3, the height of this plot is 1.
","input
There is only one possible answer to the second example:
output
The area of this plot is 12, the height of this plot is 3.
",math,1
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;


public class CodeF 
{
	static class Scanner
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer("""");
		
		public String nextLine()
		{
			try
			{
				return br.readLine();
			}
			catch(Exception e)
			{
				throw(new RuntimeException());
			}
		}
		
		public String next()
		{
			while(!st.hasMoreTokens())
			{
				String l = nextLine();
				if(l == null)
					return null;
				st = new StringTokenizer(l);
			}
			return st.nextToken();
		}
		
		public int nextInt()
		{
			return Integer.parseInt(next());
		}
		
		public long nextLong()
		{
			return Long.parseLong(next());
		}
		
		public double nextDouble()
		{
			return Double.parseDouble(next());
		}
		
		public int[] nextIntArray(int n)
		{
			int[] res = new int[n];
			for(int i = 0; i < res.length; i++)
				res[i] = nextInt();
			return res;
		}
		
		public long[] nextLongArray(int n)
		{
			long[] res = new long[n];
			for(int i = 0; i < res.length; i++)
				res[i] = nextLong();
			return res;
		}
		
		public double[] nextDoubleArray(int n)
		{
			double[] res = new double[n];
			for(int i = 0; i < res.length; i++)
				res[i] = nextDouble();
			return res;
		}
		public void sortIntArray(int[] array)
		{
			Integer[] vals = new Integer[array.length];
			for(int i = 0; i < array.length; i++)
				vals[i] = array[i];
			Arrays.sort(vals);
			for(int i = 0; i < array.length; i++)
				array[i] = vals[i];
		}
		
		public void sortLongArray(long[] array)
		{
			Long[] vals = new Long[array.length];
			for(int i = 0; i < array.length; i++)
				vals[i] = array[i];
			Arrays.sort(vals);
			for(int i = 0; i < array.length; i++)
				array[i] = vals[i];
		}
		
		public void sortDoubleArray(double[] array)
		{
			Double[] vals = new Double[array.length];
			for(int i = 0; i < array.length; i++)
				vals[i] = array[i];
			Arrays.sort(vals);
			for(int i = 0; i < array.length; i++)
				array[i] = vals[i];
		}

		public String[] nextStringArray(int n) 
		{	
			String[] vals = new String[n];
			for(int i = 0; i < n; i++)
				vals[i] = next();
			return vals;
		}
		
		Integer nextInteger()
		{
			String s = next();
			if(s == null)
				return null;
			return Integer.parseInt(s);
		}
		
		int[][] nextIntMatrix(int n, int m)
		{
			int[][] ans = new int[n][];
			for(int i = 0; i < n; i++)
				ans[i] = nextIntArray(m);
			return ans;
		}
	}
	
	static int[] compute_prefix_function(char[] p) {
	    int[] pi = new int[p.length]; pi[0] = -1; int k = -1;
	    for (int i = 1; i < p.length; i++) {
	        while (k >= 0 && p[k + 1] != p[i]) k = pi[k];
	        if (p[k + 1] == p[i]) k++; pi[i] = k;
	    }
	    return pi;
	}

	static boolean KMP_Matcher(String pattern, String text) {
	    char[] p = pattern.toCharArray(); char[] t = text.toCharArray();
	    int[] pi = compute_prefix_function(p); int q = -1;
	    int cuenta = 0;
	    for (int i = 0; i < text.length(); i++) {
	        while (q >= 0 && p[q + 1] != t[i]) q = pi[q];
	        if (p[q + 1] == t[i]) q++;
	        if (q == p.length - 1) {
	            cuenta++;
	            q = pi[q];
	        }
	    }
	    return cuenta >= 2;
	}
	
	public static void main(String[] args)
	{
		Scanner sc = new Scanner();
		String entrada = sc.next();
		int mejor = 0;
		for(int i = 0; i < entrada.length(); i++)
		{
			for(int j = i + 1; j <= entrada.length(); j++)
			{
				String sub = entrada.substring(i, j);
				if(KMP_Matcher(sub, entrada))
					mejor = Math.max(j - i, mejor);
			}
		}
		System.out.println(mejor);
	}
}",0023_A,CODEFORCES,3815,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.HashSet;
import java.util.Scanner;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author xwchen
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            int n = in.nextInt();
            String s = in.next();

            int[] cnt = new int[26];
            int[] cnt2 = new int[26];
            int j = 0;
            int res = n;
            HashSet<Character> set = new HashSet<Character>();
            for (char c : s.toCharArray()) {
                set.add(c);
            }
            int m = set.size();

            for (int i = 0; i < n; ++i) {
                if (Character.isLowerCase(s.charAt(i))) {
                    cnt[s.charAt(i) - 'a']++;
                } else {
                    cnt2[s.charAt(i) - 'A']++;
                }
                while (isOK(cnt, cnt2, m)) {
                    res = Math.min(res, i - j + 1);
                    if (Character.isLowerCase(s.charAt(j))) {
                        cnt[s.charAt(j) - 'a']--;
                    } else {
                        cnt2[s.charAt(j) - 'A']--;
                    }
                    ++j;
                }
            }
            out.println(res);
        }

        boolean isOK(int[] cnt, int[] cnt2, int m) {
            int c = 0;
            for (int i = 0; i < 26; ++i) {
                if (cnt[i] > 0) {
                    ++c;
                }
            }
            for (int i = 0; i < 26; ++i) {
                if (cnt2[i] > 0) {
                    ++c;
                }
            }
            return c >= m;
        }

    }
}

",0701_C,CODEFORCES,1808,They Are Everywhere,"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.
There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 
Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. 
The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.
The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. 
Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. 
In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.
","input
In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 
output
In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.
","binarysearch, strings, twopointers",3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class prb {
    static int n, m, k;
    static int[][] w1, w2;

    public static void main(String[] args) {
        n = Reader.nextInt();
        m = Reader.nextInt();
        k = Reader.nextInt();
        if (k % 2 == 1) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++)
                    System.out.print(""-1 "");
                if (i != n - 1)
                    System.out.println();
            }
            return;
        }
        w1 = new int[n][m - 1];
        w2 = new int[n - 1][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m - 1; j++)
                w1[i][j] = Reader.nextInt();
        for (int i = 0; i < n - 1; i++)
            for (int j = 0; j < m; j++)
                w2[i][j] = Reader.nextInt();
        int[][][] b = new int[k / 2][n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                for (int l = 0; l < k / 2; l++)
                    b[l][i][j] = Integer.MAX_VALUE;
        //b[0] init
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m - 1; j++) {
                b[0][i][j] = Math.min(b[0][i][j], 2 * w1[i][j]);
                b[0][i][j + 1] = Math.min(b[0][i][j + 1], 2 * w1[i][j]);
            }
        for (int i = 0; i < n - 1; i++)
            for (int j = 0; j < m; j++) {
                b[0][i][j] = Math.min(b[0][i][j], 2 * w2[i][j]);
                b[0][i + 1][j] = Math.min(b[0][i + 1][j], 2 * w2[i][j]);
            }
        for (int l = 1; l < k/2; l++){
            for (int i = 0; i < n; i++)
                for (int j = 0; j < m - 1; j++) {
                    b[l][i][j] = Math.min(b[l][i][j], b[l-1][i][j+1] + 2 * w1[i][j]);
                    b[l][i][j + 1] = Math.min(b[l][i][j + 1], b[l-1][i][j] + 2 * w1[i][j]);
                }
            for (int i = 0; i < n - 1; i++)
                for (int j = 0; j < m; j++) {
                    b[l][i][j] = Math.min(b[l][i][j], b[l-1][i+1][j] + 2 * w2[i][j]);
                    b[l][i + 1][j] = Math.min(b[l][i + 1][j], b[l-1][i][j] + 2 * w2[i][j]);
                } 
        }
            
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++)
                System.out.print(b[k/2 - 1][i][j] + "" "");
            if (i != n - 1)
                System.out.println();
        }
    }
}

class Reader {
    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    public static StringTokenizer st;

    public static void setInput(InputStream inputStream) {
        br = new BufferedReader(new InputStreamReader(inputStream));
    }

    public static String next() {
        while (st == null || !st.hasMoreElements()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }


    public static int nextInt() {
        return Integer.parseInt(next());
    }
    public static char nextChar() {
        char str = 0;
        try {
            str = ((char) br.read());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return str;
    }

    public static long nextLong() {
        return Long.parseLong(next());
    }

    public static double nextDouble() {
        return Double.parseDouble(next());
    }

    public static String nextLine() {
        String str = """";
        try {
            str = br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return str;
    }
}
",1517_D,CODEFORCES,4285,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.util.*;
import java.io.*;

public class Main implements Runnable {
	private void solution() throws IOException {
		int n = in.nextInt();
		int m = in.nextInt();
		boolean[][] adj = new boolean[n][n];
		long res = 0;
		for (int i = 0; i < m; ++i) {
			int x = in.nextInt();
			int y = in.nextInt();
			adj[x - 1][y - 1] = true;
			adj[y - 1][x - 1] = true;
		}
		for (int i = 0; i < n; ++i) {
			for (int j = i + 1; j < n; ++j) {
				if (adj[i][j]) {
					--res;
				}
			}
		}
		for (int i = 0; i < n; ++i) {
			long[][] dp = new long[n - i][1 << (n - i)];
			dp[0][0] = 1;
			for (int mask = 0; mask < (1 << (n - i)); ++mask) {
				for (int j = 0; j < n - i; ++j) {
					if (dp[j][mask] != 0) {
						for (int k = 0; k < n - i; ++k) {
							if (((mask >> k) & 1) == 0 && adj[j + i][k + i]) {
								dp[k][mask | (1 << k)] += dp[j][mask];
							}
						}
					}
				}
				if (((mask >> 0) & 1) != 0) {
					res += dp[0][mask];
				}
			}
		}
		out.println(res / 2);
	}

	public void run() {
		try {
			solution();
			in.reader.close();
			out.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	private class Scanner {
		BufferedReader reader;
		StringTokenizer tokenizer;

		public Scanner(Reader reader) {
			this.reader = new BufferedReader(reader);
			this.tokenizer = new StringTokenizer("""");
		}

		public boolean hasNext() throws IOException {
			while (!tokenizer.hasMoreTokens()) {
				String next = reader.readLine();
				if (next == null) {
					return false;
				}
				tokenizer = new StringTokenizer(next);
			}
			return true;
		}

		public String next() throws IOException {
			hasNext();
			return tokenizer.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public String nextLine() throws IOException {
			tokenizer = new StringTokenizer("""");
			return reader.readLine();
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}
	}

	public static void main(String[] args) throws IOException {
		new Thread(null, new Main(), """", 1 << 28).start();
	}
	PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
	Scanner in = new Scanner(new InputStreamReader(System.in));
}
",0011_D,CODEFORCES,4419,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import java.io.*;
import java.util.StringTokenizer;

public class A {

    public static void main(String[] args) throws IOException {
        new A().solve();
    }

    BufferedReader br;
    StringTokenizer st = new StringTokenizer("""");

    private void solve() throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        String s = nextToken();
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            for (int j = i + 1; j < s.length(); j++) {
                int k = 0;
                while (k < s.length() - j && s.charAt(i + k) == s.charAt(j + k)) {
                    k++;
                }
                res = Math.max(res, k);
            }
        }
        PrintWriter pw = new PrintWriter(System.out);
        pw.println(res);
        pw.close();
    }

    String nextToken() throws IOException {
        while (!st.hasMoreTokens()) {
            st = new StringTokenizer(br.readLine());
        }
        return st.nextToken();
    }

}
",0023_A,CODEFORCES,3784,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.*;
import java.util.*;


public class Solution {
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader(String s) {
            try {
                br = new BufferedReader(new FileReader(s));
            } catch (FileNotFoundException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String nextToken() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(nextToken());
        }

        String nextLine() throws IOException {
            return br.readLine();
        }

        long nextLong() {
            return Long.parseLong(nextToken());
        }

        double nextDouble() {
            return Double.parseDouble(nextToken());
        }

        float nextFloat() {
            return Float.parseFloat(nextToken());
        }
    }


    static FastReader f = new FastReader();
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static long[] fact;

    static int[] inputArray(int n) throws IOException {
        int[] a = new int[n];
        for(int i = 0 ; i < n ; i++) {
//            a[i] = (int) (Math.random()*1e5 + 1);
            a[i] = f.nextInt();
        }
        return a;
    }
    static long[] inputLongArray(int n) throws IOException {
        long[] a = new long[n];
        for(int i = 0 ; i < n ; i++) {
            a[i] = f.nextLong();
//            a[i] = (long) (Math.random() * 1e9 + 1);
        }
        return a;
    }

    static long gcd(long a , long b) {
        if(a == 0 || b == 0) {
            return Math.max(a , b);
        }
        //System.out.println(""a - "" + a + "" b - "" + b);
        if(a % b == 0) {
            return b;
        }
        return gcd(b , a % b);
    }

    static void initializeFact() {
        fact = new long[MAX_N];
        for(int i = 0 ; i < fact.length ; i++) {
            if(i == 0) {
                fact[i] = 1;
            }
            else {
                fact[i] = fact[i-1] * i % mod;
            }
        }
    }

    static long longModulus(long x , long m) {
        if(x < m) {
            return x;
        }
        long d = x / m;
        return x - d * m;
    }


    static BitSet sieveOfEratosthenes(int n)
    {
        BitSet isPrime = new BitSet(n+1);
        isPrime.set(0, n + 1);
        isPrime.set(0);
        isPrime.set(1);
        for(int i = 2; i * i <= n ; i++)
        {
            if(isPrime.get(i))
                for(int j = i * i ; j <= n; j += i)
                    isPrime.clear(j);
        }
        return isPrime;
    }

    static long moduloInversePrime(long a) {
        //System.out.println(""modulo inverse of "" + a + "" -> "" + ans);
        return modPow(a , mod - 2);
    }

    static long mult(long a, long b)
    {
        return (a * b % mod);
    }

    static long modPow(long a, int step)
    {
        long ans = 1;
        while(step != 0)
        {
            if((step & 1) != 0)
                ans = mult(ans , a);
            a = mult(a , a);
            step >>= 1;
        }
        return ans;
    }

    static int query(int l , int r) {
        System.out.println(""? "" + l + "" "" + r);
        System.out.flush();
        return f.nextInt();
    }

    static int sum(int n) {
        return n * (n + 1) / 2;
    }

    private static final int mod = (int) (1e9 + 7);
    static int MAX_N = (int) Math.sqrt(1e9);


    public static void main(String[] args) throws IOException {
        int test = f.nextInt();

//        System.out.println(MAX_N);

        TreeSet<Integer> set = new TreeSet<>();
        for(int i = 1 ; i <= MAX_N ; i++) {
            set.add(i*i*2);
            set.add(i*i*4);
        }

//        System.out.println(set);

        for(int t = 1 ; t <= test ; t++) {
            int n = f.nextInt();
            if(set.contains(n)) {
                sb.append(""YES"").append(""\n"");
            }
            else {
                sb.append(""NO"").append(""\n"");
            }

        }
        System.out.println(sb);
    }


}
",1515_B,CODEFORCES,2187,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",3
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;

/**
 *
 * @author is2ac
 */
public class D_CF {

    public static void main(String[] args) {
        FastScanner58 fs = new FastScanner58();
        PrintWriter pw = new PrintWriter(System.out);
        //int t = fs.ni();
        int t = 1;
        // for (int tc = 0; tc < t; tc++) {
        for (int tc = 0; tc < t; tc++) {
            int n = fs.ni();
            int m = fs.ni();
            int k = fs.ni();
            int[][] a = new int[n][m - 1];
            int[][] b = new int[n - 1][m];
            for (int i = 0; i < n; i++) {
                a[i] = fs.intArray(m - 1);
            }
            for (int i = 0; i < n - 1; i++) {
                b[i] = fs.intArray(m);
            }
            int[][] res = new int[n][m];
            Integer[][][] dp = new Integer[n][m][k / 2 + 1];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    res[i][j] = recur(i, j, k / 2, dp, a, b) * 2;
                }
            }
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < res.length; i++) {
                for (int j = 0; j < m; j++) {
                    //matrix[i][j]++;
                    if (k%2==1) {
                        sb.append(-1 + "" "");
                    } else {
                        sb.append(res[i][j] + "" "");
                    }
                }
                sb.append(""\n"");
            }
            pw.println(sb);
        }
        pw.close();
    }

    public static int recur(int i, int j, int k, Integer[][][] dp, int[][] a, int[][] b) {
        if (k == 0) {
            return 0;
        }
        int n = (int) (1e9);
        if (dp[i][j][k] != null) {
            return dp[i][j][k];
        }
        if (i != 0) {
            n = Math.min(n, recur(i - 1, j, k - 1, dp, a, b) + b[i - 1][j]);
        }
        if (j != 0) {
            n = Math.min(n, recur(i, j - 1, k - 1, dp, a, b) + a[i][j - 1]);
        }
        if (i != a.length - 1) {
            n = Math.min(n, recur(i + 1, j, k - 1, dp, a, b) + b[i][j]);
        }
        if (j != b[0].length - 1) {
            n = Math.min(n, recur(i, j + 1, k - 1, dp, a, b) + a[i][j]);
        }
        return dp[i][j][k] = n;
    }
}

class FastScanner58 {

    BufferedReader br;
    StringTokenizer st;

    public FastScanner58() {
        br = new BufferedReader(new InputStreamReader(System.in), 32768);
        st = null;
    }

    String next() {
        while (st == null || !st.hasMoreElements()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }

    int ni() {
        return Integer.parseInt(next());
    }

    int[] intArray(int N) {
        int[] ret = new int[N];
        for (int i = 0; i < N; i++) {
            ret[i] = ni();
        }
        return ret;
    }

    long nl() {
        return Long.parseLong(next());
    }

    long[] longArray(int N) {
        long[] ret = new long[N];
        for (int i = 0; i < N; i++) {
            ret[i] = nl();
        }
        return ret;
    }

    double nd() {
        return Double.parseDouble(next());
    }

    String nextLine() {
        String str = """";
        try {
            str = br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return str;
    }
}

class UnionFind17 {

    int[] id;

    public UnionFind17(int size) {
        id = new int[size];
        for (int i = 0; i < size; i++) {
            id[i] = i;
        }
    }

    public int find(int p) {
        int root = p;
        while (root != id[root]) {
            root = id[root];
        }
        while (p != root) {
            int next = id[p];
            id[p] = root;
            p = next;
        }
        return root;
    }

    public void union(int p, int q) {
        int a = find(p), b = find(q);
        if (a == b) {
            return;
        }
        id[b] = a;
    }
}
",1517_D,CODEFORCES,4202,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"/**
 * MxNINJA 04:06:52 ص 14/01/2014
 */
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder line = new StringBuilder(reader.readLine());
        int length = 0;
        for (int head = 0; head < line.length(); head++) {
            for (int tail = line.length() - 1; tail > head; tail--) {
                String subString = line.substring(head, tail);
                if(line.indexOf(subString,head+1)>-1){
                    length = Math.max(subString.length(), length);
                }
            }
        }
        System.out.println(length);
    }
}",0023_A,CODEFORCES,3696,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.util.*;

public class A {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(""0 0 "" + n);
    }
}",0199_A,CODEFORCES,170,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"import java.io.*;
import java.util.*;

public class Main implements Runnable {

	public void _main() throws IOException {
		int n = nextInt();
		int k = nextInt();
		boolean[] p = new boolean[n + 1];
		Arrays.fill(p, true);
		List<Integer> primes = new ArrayList<Integer>();
		for (int i = 2; i <= n; i++)
			if (p[i]) {
				primes.add(i);
				for (int j = i + i; j <= n; j += i)
					p[j] = false;
			}
		boolean[] ok = new boolean[n + 1];
		for (int i = 0; i < primes.size() - 1; i++) {
			int x = primes.get(i);
			int y = primes.get(i + 1);
			if (x + y + 1 <= n)
				ok[x + y + 1] = true;
		}
		for (int i = 2; i <= n; i++)
			if (p[i] && ok[i]) {
				--k;				
			}		
		out.println(k <= 0 ? ""YES"" : ""NO"");
	}

	private BufferedReader in;
	private PrintWriter out;
	private StringTokenizer st;

	private String next() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			String rl = in.readLine();
			if (rl == null)
				return null;
			st = new StringTokenizer(rl);
		}
		return st.nextToken();
	}

	private int nextInt() throws IOException {
		return Integer.parseInt(next());
	}

	private long nextLong() throws IOException {
		return Long.parseLong(next());
	}

	private double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}

	public static void main(String[] args) {
		new Thread(new Main()).start();
	}

	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);

			_main();

			out.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(202);
		}
	}

}
",0017_A,CODEFORCES,1496,Noldbach problem,"Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least k prime numbers from 2 to n inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.
Two prime numbers are called neighboring if there are no other prime numbers between them.
You are to help Nick, and find out if he is right or wrong.
The first line of the input contains two integers n (2 ≤ n ≤ 1000) and k (0 ≤ k ≤ 1000).
","input
Output YES if at least k prime numbers from 2 to n inclusively can be expressed as it was described above. Otherwise output NO.
output
In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.
","bruteforce, math, numbertheory",3
"import java.util.Scanner;
public class solution {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int t = sc.nextInt();
		
		for(int i=0; i<t; i++) {
			String s = sc.next(); 
			int indexOfC = s.indexOf('C');
			if(s.charAt(0)=='R' && s.charAt(1)-'0'<=9 && indexOfC>0) {
				int row, col;
				row = Integer.parseInt(s.substring(1, indexOfC));
				col = Integer.parseInt(s.substring(indexOfC+1));
				
				StringBuilder colStr = new StringBuilder();
                while (col > 0) {
                    colStr.insert(0, (char)((col - 1) % 26 + 'A'));
                    col = (col - 1) / 26;
                }
                System.out.println(colStr.toString()+""""+row);
			}
			else {
				int k,row,col = 0;

				for(k=0; s.charAt(k)-'A'>=0; k++) {
                    col *= 26;
                    col += s.charAt(k) - 'A' + 1;
				}
				row = Integer.parseInt(s.substring(k));
				System.out.println(""R""+row+""C""+col);
			}
		}
	}
}
",0001_B,CODEFORCES,1488,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math",3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Set;

/**
 * @author Ran Bi (ran.bi@addepar.com)
 */
public class C {

  public static void main(String[] arg) throws IOException {
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.valueOf(in.readLine());
    char[] s = in.readLine().toCharArray();
    int i = 0, j = 0;
    int[] ct = new int[256];
    Set<Character> all = new HashSet<>();
    for (char c : s) {
      all.add(c);
    }
    int total = 0, res = Integer.MAX_VALUE;
    while (j < s.length) {
      while (total < all.size() && j < s.length) {
        if (ct[s[j]] == 0) {
          total++;
        }
        ct[s[j]]++;
        j++;
      }
      res = Math.min(res, j - i);
      while (total == all.size() && i < s.length) {
        ct[s[i]]--;
        if (ct[s[i]] == 0) {
          total--;
        }
        i++;
        if (total == all.size()) {
          res = Math.min(res, j - i);
        }
      }
    }
    System.out.println(res);
  }
}
",0701_C,CODEFORCES,1773,They Are Everywhere,"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.
There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 
Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. 
The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.
The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. 
Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. 
In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.
","input
In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 
output
In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.
","binarysearch, strings, twopointers",3
"
import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;
import java.io.*;

public class Mulitple
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		
		String s = r.readLine();

		System.out.println(num(s));
	}

	public static int num(String s)
	{
		int answer = 0;
		Set<String> set = new HashSet<String>();
		for(int j = s.length()-1; j>=1; j--)
		{
			for(int i = 0; i<s.length()-j+1; i++)
			{
				if(set.contains(s.substring(i,i+j)))
				{
					return s.substring(i,i+j).length();
				}
				else
				{
					set.add(s.substring(i,i+j));
				}
			}
		}

		return 0; 

	}
}


",0023_A,CODEFORCES,3808,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.StringTokenizer;

public class C implements Runnable {

	private void Solution() throws IOException {
		int n = nextInt(), max = 0, maxi = 0;
		ArrayList<Integer> mas = new ArrayList<Integer>();
		for (int i = 0; i < n; i++) {
			int num = nextInt();
			if (num > max) {
				max = num;
				maxi = i;
			}
			mas.add(num);
		}
		mas.remove(maxi);
		mas.add(max == 1 ? 2 : 1);
		Collections.shuffle(mas);
		Collections.sort(mas);
		for (int i = 0; i < n; i++)
			System.out.print(mas.get(i) + "" "");
	}

	public static void main(String[] args) {
		new C().run();
	}

	BufferedReader in;
	StringTokenizer tokenizer;

	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			tokenizer = null;
			Solution();
			in.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	String nextToken() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens())
			tokenizer = new StringTokenizer(in.readLine());
		return tokenizer.nextToken();
	}
}",0135_A,CODEFORCES,2402,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings",4
"import java.io.*;
import java.util.*;
import static java.lang.Math.*;

public class A implements Runnable {
	
	final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;
	
	BufferedReader in;
	PrintWriter out;
	StringTokenizer tok;
	
	@Override
	public void run() {
		try {
			long startTime = System.currentTimeMillis();
			if (ONLINE_JUDGE) {
				in = new BufferedReader(new InputStreamReader(System.in));
				out = new PrintWriter(System.out);
			} else {
				in = new BufferedReader(new FileReader(""input.txt""));
				out = new PrintWriter(""output.txt"");
			}
			tok = new StringTokenizer("""");
			Locale.setDefault(Locale.US);
			solve();
			in.close();
			out.close();
			long endTime = System.currentTimeMillis();
			long totalMemory = Runtime.getRuntime().totalMemory();
			long freeMemory = Runtime.getRuntime().freeMemory();
			System.err.println(""Time = "" + (endTime - startTime) + "" ms"");
			System.err.println(""Memory = "" + ((totalMemory - freeMemory) / 1024) + "" KB"");
		} catch (Throwable e) {
			e.printStackTrace(System.err);
			System.exit(-1);
		}
	}
	
	String readString() throws IOException {
		while (!tok.hasMoreTokens()) {
			tok = new StringTokenizer(in.readLine());
		}
		return tok.nextToken();
	}
	
	int readInt() throws IOException {
		return Integer.parseInt(readString());
	}
	
	long readLong() throws IOException {
		return Long.parseLong(readString());
	}
	
	double readDouble() throws IOException {
		return Double.parseDouble(readString());
	}
	
	void debug(Object... o) {
		if (!ONLINE_JUDGE) {
			System.err.println(Arrays.deepToString(o));
		}
	}
	
	public static void main(String[] args) {
		new Thread(null, new A(), """", 256 * 1024 * 1024).start();
	}

	static class Utils {

		private Utils() {}

		public static void mergeSort(int[] a) {
			mergeSort(a, 0, a.length - 1);
		}

		private static void mergeSort(int[] a, int leftIndex, int rightIndex) {
			final int MAGIC_VALUE = 50;
			if (leftIndex < rightIndex) {
				if (rightIndex - leftIndex <= MAGIC_VALUE) {
					insertionSort(a, leftIndex, rightIndex);
				} else {
					int middleIndex = (leftIndex + rightIndex) / 2;
					mergeSort(a, leftIndex, middleIndex);
					mergeSort(a, middleIndex + 1, rightIndex);
					merge(a, leftIndex, middleIndex, rightIndex);
				}
			}
		}

		private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {
			int length1 = middleIndex - leftIndex + 1;
			int length2 = rightIndex - middleIndex;
			int[] leftArray = new int[length1];
			int[] rightArray = new int[length2];
			System.arraycopy(a, leftIndex, leftArray, 0, length1);
			System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);
			for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {
				if (i == length1) {
					a[k] = rightArray[j++];
				} else if (j == length2) {
					a[k] = leftArray[i++];
				} else {
					a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];
				}
			}
		}

		private static void insertionSort(int[] a, int leftIndex, int rightIndex) {
			for (int i = leftIndex + 1; i <= rightIndex; i++) {
				int current = a[i];
				int j = i - 1;
				while (j >= leftIndex && a[j] > current) {
					a[j + 1] = a[j];
					j--;
				}
				a[j + 1] = current;
			}
		}

	}
	
//------------------------------------------------------------------------------
	
	void solve() throws IOException {
		int n = readInt();
		int[] a = new int[n];
		int sum = 0;
		for (int i = 0; i < n; i++) {
			a[i] = readInt();
			sum += a[i];
		}
		Utils.mergeSort(a);
		int s = 0, c = 0;
		for (int i = n-1; i >= 0; i--) {
			s += a[i];
			c++;
			if (2 * s > sum) {
				break;
			}
		}
		out.println(c);
		
	}
	
}
",0160_A,CODEFORCES,2473,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"import java.util.*;
import java.io.*;
 
public class uo{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int testcases = Integer.parseInt(st.nextToken());
		for(int lmn=0;lmn<testcases;lmn++){
			st = new StringTokenizer(br.readLine());
			int n = Integer.parseInt(st.nextToken());
			// int k = Integer.parseInt(st.nextToken());
			// st = new StringTokenizer(br.readLine());
			ArrayList<Integer> a = new ArrayList<>();
			for(int lmn1 = 0;lmn1<n;lmn1++){
				st = new StringTokenizer(br.readLine());
				int a1 = Integer.parseInt(st.nextToken());
				if(a.size()>0 && (a1==1)){
					// a.add(a1);
				}
				else if(a.size()>0){
					if(a.size()==1){
						a.remove(0);
					}
					else{
						int i = a.size()-1;
						while(a.size()>0 && i>=0 && a.get(i)+1 != a1){
							a.remove(i);
							i--;
						}
						a.remove(a.size()-1);
						// System.out.println(a+"" ""+i);

					}
				}
				// while(a.size()>0 && a.get(a.size()-1)+1<a1){
				// 	a.remove(a.size()-1);
				// }
				if(a.size()==0){
					a.add(a1);
				}
				else{
					a.add(a1);
				}
				if(a.size()==1){
					System.out.println(a.get(0));
				}
				else{
					for(int i=0;i<a.size()-1;i++){
						
						System.out.print(a.get(i)+""."");
					}
					System.out.println(a.get(a.size()-1));
				}
				

			}
		}
		
	}
}",1523_C,CODEFORCES,3624,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees",5
"
import java.util.Scanner;

public class Pipeline3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		Scanner sc = new Scanner(System.in);
		long n = sc.nextLong();
		long k = sc.nextLong();
		
	    if(n==1)
	    {
	    	System.out.println(""0"");
	    }else  if(n <= k)
	    {
	    	System.out.println(""1"");
	    }
	    else
	    {
	    	k--;
	    	n--;
	    	
	    	if(sum(k) < n)
	    		System.out.println(-1);
	    	else
	    	{
	    		System.out.println(minCalc(n, k));
	    	}
	    	
	    }

	}
	
	
	private static long minCalc(long n, long k) {
		// TODO Auto-generated method stub
		
		long start= 1; 
		long end = k;
		
		while(start< end)
		{
			long mid = (start + end)/2;
			
			long sum =sum(mid , k);
			
			if(sum == n)
			{
				return k - mid +1;
			}
			if(sum > n)
				start = mid + 1;
			else
				end = mid;
				
		}
		return k-start + 2;
		
	}


	public static long sum(long n)
	{
		return  n*(n+1)/2;
	}
	public static long sum(long s, long e)
	{
		if(s <= 1)
			return sum(e);
		else
			return sum(e) - sum(s-1);
	}

}
",0287_B,CODEFORCES,969,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String ...args) throws Throwable {
        Scanner in = new Scanner(System.in);
        String init = in.nextLine();
        HashSet<String> h = new HashSet<String>();
        for (int len = init.length() - 1; len >= 1; --len)  {
            h.clear();
            for (int pos = 0; pos + len <= init.length(); ++pos) {
                String now = init.substring(pos, pos + len);
                if (h.contains(now)) {
                    System.out.println(len);
                    return;
                }
                h.add(now);
            }

        }

        System.out.println(0);
    }
}
        ",0023_A,CODEFORCES,3737,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.*;

import java.util.*;

import static java.lang.Math.*;



public class Solution {



    BufferedReader in;

    StringTokenizer st;

    PrintWriter out;



    int n, m, k;

    int[] x, y;



    char[] qx = new char[4000000], qy = new char[4000000];

    int b, e;



    char[][] d;



    int[] dx = { -1, 0, 1, 0 }, dy = { 0, -1, 0, 1 };



    void bfs() {

        b = e = 0;

        for (int i = 0; i < d.length; i++) {

            Arrays.fill(d[i], (char)(1 << 14));

        }

        for (int i = 0; i < k; ++i) {

            qx[e] = (char) x[i];

            qy[e++] = (char) y[i];

            d[x[i]][y[i]] = 0;

        }

        for (; b < e; ++b) {

            int x = qx[b];

            int y = qy[b];

            for (int i = 0; i < 4; ++i) {

                int nx = x + dx[i];

                int ny = y + dy[i];

                if (nx >= 0 && nx < n && ny >= 0 && ny < m)

                    if (d[nx][ny] > d[x][y] + 1) {

                        d[nx][ny] = (char) (d[x][y] + 1);

                        qx[e] = (char) nx;

                        qy[e++] = (char) ny;

                    }

            }

        }

    }



    void solve() throws IOException {

        n = ni();

        m = ni();

        k = ni();

        x = new int[k];

        y = new int[k];

        for (int i = 0; i < k; ++i) {

            x[i] = ni() - 1;

            y[i] = ni() - 1;

        }

        d = new char[n][m];

        bfs();

        int x = -1, y = -1, last = -1;

        for (int i = 0; i < n; ++i)

            for (int j = 0; j < m; ++j)

                if (d[i][j] > last) {

                    last = d[i][j];

                    x = i;

                    y = j;

                }

        ++x;

        ++y;

        out.println(x + "" "" + y);

    }



    public Solution() throws IOException {

        Locale.setDefault(Locale.US);

        in = new BufferedReader(new FileReader(""input.txt""));

        out = new PrintWriter(""output.txt"");

        solve();

        in.close();

        out.close();

    }



    String nline() throws IOException {

        return in.readLine();

    }



    String ns() throws IOException {

        while (st == null || !st.hasMoreTokens()) {

            st = new StringTokenizer(nline());

        }

        return st.nextToken();

    }



    int ni() throws IOException {

        return Integer.valueOf(ns());

    }



    long nl() throws IOException {

        return Long.valueOf(ns());

    }



    double nd() throws IOException {

        return Double.valueOf(ns());

    }



    public static void main(String[] args) throws IOException {

        new Solution();

    }

}

",0035_C,CODEFORCES,3922,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"//package codeforces;

import java.util.*;

public class Main {
    class team implements Comparable<team>{
        int pro,time;

        public int compareTo(team oth) {
            if(pro>oth.pro)
                return -1;
            if(pro==oth.pro&&time<oth.time)
                return -1;
            // TODO Auto-generated method stub
            return 1;
        }
        
    }
    Scanner scan=new Scanner(System.in);
    void run(){
        int n=scan.nextInt();
        int k=scan.nextInt()-1;
        team tm[]=new team[n];
        for(int i=0;i<n;i++){
            tm[i]=new team();
            tm[i].pro=scan.nextInt();
            tm[i].time=scan.nextInt();
        }
        Arrays.sort(tm);
        int sum=0;
        
        for(int i=k;i>=0;i--)
            if(tm[i].pro==tm[k].pro&&tm[i].time==tm[k].time)
                sum++;
        for(int i=k;i<n;i++)
            if(tm[i].pro==tm[k].pro&&tm[i].time==tm[k].time)
                sum++;
        System.out.println(sum-1);
    }
    public static void main(String args[]) {
         
        new Main().run();
    }

}",0166_A,CODEFORCES,2509,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"import static java.math.BigInteger.*;
import static java.util.Arrays.*;

import java.io.*;
import java.lang.reflect.*;
import java.util.*;

public class A {

	final int MOD = (int)1e9 + 7;
	final double eps = 1e-12;
	final int INF = (int)1e9;
	
	public A () {
		int N = sc.nextInt();
		int K = sc.nextInt();
		Long [] A = sc.nextLongs();

		sort(A);
		Set<Long> S = new HashSet<Long>();
		
		for (long a : A) {
			if (a % K == 0 && S.contains(H(a/K)))
				continue;
			S.add(H(a));
		}
		
		int res = S.size();
		exit(res);
	}

	long P = probablePrime(60, new Random()).longValue();
	long Q = probablePrime(60, new Random()).longValue();
	
	long H(long x) {
		return (P*x) % Q;
	}
	
	////////////////////////////////////////////////////////////////////////////////////

	/* Dear hacker, don't bother reading below this line, unless you want to help me debug my I/O routines :-) */
	
	static MyScanner sc = new MyScanner();
	
	static class MyScanner {
		public String next() {
			newLine();
			return line[index++];
		}
		
		public char nextChar() {
			return next().charAt(0);
		}
				
		public int nextInt() {
			return Integer.parseInt(next());
		}
		
		public long nextLong() {
			return Long.parseLong(next());
		}
		
		public double nextDouble() {
			return Double.parseDouble(next());
		}
		
		public String nextLine() {
			line = null;
			return readLine();
		}
		
		public String [] nextStrings() {
			line = null;
			return readLine().split("" "");
		}
		
		public char [] nextChars() {
			return next().toCharArray();
		}

		public Integer [] nextInts() {
			String [] L = nextStrings();
			Integer [] res = new Integer [L.length];
			for (int i = 0; i < L.length; ++i)
				res[i] = Integer.parseInt(L[i]);
			return res;
		}	
		
		public Long [] nextLongs() {
			String [] L = nextStrings();
			Long [] res = new Long [L.length];
			for (int i = 0; i < L.length; ++i)
				res[i] = Long.parseLong(L[i]);
			return res;
		}

		public Double [] nextDoubles() {
			String [] L = nextStrings();
			Double [] res = new Double [L.length];
			for (int i = 0; i < L.length; ++i)
				res[i] = Double.parseDouble(L[i]);
			return res;
		}

		public String [] next (int N) {
			String [] res = new String [N];
			for (int i = 0; i < N; ++i)
				res[i] = sc.next();
			return res;
		}
		
		public Integer [] nextInt (int N) {
			Integer [] res = new Integer [N];
			for (int i = 0; i < N; ++i)
				res[i] = sc.nextInt();
			return res;
		}		
		
		public Long [] nextLong (int N) {
			Long [] res = new Long [N];
			for (int i = 0; i < N; ++i)
				res[i] = sc.nextLong();
			return res;
		}		
		
		public Double [] nextDouble (int N) {
			Double [] res = new Double [N];
			for (int i = 0; i < N; ++i)
				res[i] = sc.nextDouble();
			return res;
		}		
		
		public String [][] nextStrings (int N) {
			String [][] res = new String [N][];
			for (int i = 0; i < N; ++i)
				res[i] = sc.nextStrings();
			return res;
		}
		
		public Integer [][] nextInts (int N) {
			Integer [][] res = new Integer [N][];
			for (int i = 0; i < N; ++i)
				res[i] = sc.nextInts();
			return res;
		}
		
		public Long [][] nextLongs (int N) {
			Long [][] res = new Long [N][];
			for (int i = 0; i < N; ++i)
				res[i] = sc.nextLongs();
			return res;
		}
		
		public Double [][] nextDoubles (int N) {
			Double [][] res = new Double [N][];
			for (int i = 0; i < N; ++i)
				res[i] = sc.nextDoubles();
			return res;
		}
		
		//////////////////////////////////////////////
		
		private boolean eol() {
			return index == line.length;
		}

		private String readLine() {
			try {
				return r.readLine();
			} catch (Exception e) {
				throw new Error(e);
			}
		}
		private final BufferedReader r;

		MyScanner () {
			this(new BufferedReader(new InputStreamReader(System.in)));
		}
		
		MyScanner(BufferedReader r) {
			try {
				this.r = r;
				while (!r.ready())
					Thread.sleep(1);
				start();
			} catch (Exception e) {
				throw new Error(e);
			}
		}
		
		private String [] line;
		private int index;

		private void newLine() {
			if (line == null || eol()) {
				line = readLine().split("" "");
				index = 0;
			}
		}		
	}
	
	static void print(Object o, Object... a) {
		printDelim("" "", o, a);
	}
	
	static void cprint(Object o, Object... a) {
		printDelim("""", o, a);
	}
	
	static void printDelim (String delim, Object o, Object... a) {
		pw.println(build(delim, o, a));
	}

	static void exit (Object o, Object... a) {
		print(o, a);
		exit();
	}

	static void exit () {
		pw.close();
		System.out.flush();
		System.err.println(""------------------"");
		System.err.println(""Time: "" + ((millis() - t) / 1000.0));
		System.exit(0);
	}
	
	void NO() {
		throw new Error(""NO!"");
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	
	static String build(String delim, Object o, Object... a) {
		StringBuilder b = new StringBuilder();
		append(b, o, delim);
		for (Object p : a)
			append(b, p, delim);
		return b.toString().trim();		
	}
	
	static void append(StringBuilder b, Object o, String delim) {
		if (o.getClass().isArray()) {
			int L = Array.getLength(o);
			for (int i = 0; i < L; ++i)
				append(b, Array.get(o, i), delim);
		} else if (o instanceof Iterable<?>) {
			for (Object p : (Iterable<?>)o)
				append(b, p, delim);
		} else
			b.append(delim).append(o);		
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	
	public static void main(String[] args) {
		new A();
		exit();
	}

	static void start() {
		t = millis();
	}

	static PrintWriter pw = new PrintWriter(System.out);
	
	static long t;
	
	static long millis() {
		return System.currentTimeMillis();
	}	
}
",0274_A,CODEFORCES,2711,k-Multiple Free Set,"A k-multiple free set is a set of integers where there is no pair of integers where one is equal to another integer multiplied by k. That is, there are no two integers x and y (x < y) from the set, such that y = x·k.
You're given a set of n distinct positive integers. Your task is to find the size of it's largest k-multiple free subset.
The first line of the input contains two integers n and k (1 ≤ n ≤ 105, 1 ≤ k ≤ 109). The next line contains a list of n distinct positive integers a1, a2, ..., an (1 ≤ ai ≤ 109).
All the numbers in the lines are separated by single spaces.
","input
On the only line of the output print the size of the largest k-multiple free subset of {a1, a2, ..., an}.
output
In the sample input one of the possible maximum 2-multiple free subsets is {4, 5, 6}.
","binarysearch, greedy, sortings",4
"import java.math.*;
import java.text.*;
import java.util.*;
public class Main {

    public static void main(String args[]) {
        Scanner sca = new Scanner(System.in);
        long k,n;
        long ans;
        long[] pw = new long[33];
        pw[1]=4;
        pw[0]=1;
        for(int i=2;i<=31;i++)
            pw[i]=pw[i-1]<<2;
        int t;
        t = sca.nextInt();
        for(int cas=1;cas<=t;cas++) {
            n = sca.nextLong();
            k = sca.nextLong();
            ans = n;
            long last, path = 1;
            for (int i = 0; ; i++) {
                if ((pw[i + 1] - 1) / 3 > k) {
                    ans -= i;
                    last = k - (pw[i] - 1) / 3;
                    break;
                }
                path *= 2;
            }
            long sp = path * 2 - 1;
            if (ans < 0 || (ans == 0 && last > 0)) {
                System.out.println(""NO"");
                continue;
            }
            BigInteger sq = BigInteger.valueOf(path).multiply(BigInteger.valueOf(path)).subtract(BigInteger.valueOf(sp));
            if (ans == 1 && sq.compareTo(BigInteger.valueOf(last))==-1 && last < sp) {
                System.out.println(""NO"");
                continue;
            } else if (ans == 1 && last >= sp) {
                ans--;
            }
            System.out.println(""YES ""+ans);
        }

    }
}",1080_D,CODEFORCES,1272,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"import java.util.*;

import java.io.*;

public class Spreadsheets

{

	public static void main(String args[]) throws Exception

	{

		BufferedReader f=new BufferedReader(new InputStreamReader(System.in));

		int runs=Integer.parseInt(f.readLine());

		for(int x=0;x<runs;x++)

		{

			String in=f.readLine();

			if(in.matches(""R\\d+C\\d+""))

			{

				String[] arr=in.split(""[RC]"");

				int temp=Integer.parseInt(arr[2]);

				String res="""";

				while(temp!=0)

				{

				    if(temp%26==0)

				    {

				        res+=""Z"";

				        temp/=26;

				        temp--;

				    }

				    else

				    {

						res+=(char)(temp%26+64);

						temp/=26;

				    }

				}

				StringBuilder a=new StringBuilder(res);

				System.out.println(a.reverse().toString()+arr[1]);

			}

			else

			{

				int pos=in.replaceFirst(""\\d"",""@"").indexOf(""@"");

				String temp=in.substring(0,pos);

				int res=0;

				for(int y=0;y<temp.length();y++)

					res=res*26+temp.charAt(y)-64;

				System.out.println(""R""+in.substring(pos)+""C""+res);

			}

		}

	}

}",0001_B,CODEFORCES,1466,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math",3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;
 
public class A {
 
	static double[][] a;
	static int N;
	static double[][] memo;
 
	static double[] dp(int alive)
	{
		int count = Integer.bitCount(alive);
		if(count == 1)
		{
			double[] ret = new double[N];
			for(int i = 0; i < N; ++i)
				if((alive & (1<<i)) != 0)
				{
					ret[i] = 1;
					break;
				}
			return memo[alive] = ret;
		}
		if(memo[alive] != null)
			return memo[alive];
		
		double[] ret = new double[N];
		for(int j = 0; j < N; ++j)
			if((alive & (1<<j)) != 0)
			{
				double[] nxt = dp(alive & ~(1<<j));
				for(int i = 0; i < N; ++i)
					ret[i] += die[j][alive] * nxt[i];			
			}
		return memo[alive] = ret;
	}
 
	static double[][] die;
	static void f()
	{
		die = new double[N][1<<N];
		for(int i = 0; i < N; ++i)
			for(int j = 0; j < 1<<N; ++j)
			{
				int count = Integer.bitCount(j);
				if(count <= 1)
					continue;
				double prop = 1.0 / (count * (count - 1) >> 1);
				for(int k = 0; k < N; ++k)
					if((j & (1<<k)) != 0)
						die[i][j] += prop * a[k][i]; 
			}
 
	}
 
	public static void main(String[] args) throws IOException {
 
		Scanner sc = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
 
		N = sc.nextInt();
		
		a = new double[N][N];
		for(int i = 0; i < N; ++i)
			for(int j = 0; j < N; ++j)
				a[i][j] = sc.nextDouble();
		memo = new double[1<<N][];
		
		f();
		
		double[] ret = dp((1<<N) - 1);
		for(int i = 0; i < N - 1; ++i)
			out.printf(""%.8f "",ret[i]);
		out.printf(""%.8f\n"", ret[N-1]);
 
		out.flush();
		out.close();
	}
 
	static class Scanner 
	{
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}

		public String next() throws IOException 
		{
			while (st == null || !st.hasMoreTokens()) 
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public double nextDouble() throws NumberFormatException, IOException
		{
			return Double.parseDouble(next());
		}

		public int nextInt() throws IOException {return Integer.parseInt(next());}

		public long nextLong() throws IOException {return Long.parseLong(next());}

		public String nextLine() throws IOException {return br.readLine();}

		public boolean ready() throws IOException {return br.ready();}


	}
} ",0016_E,CODEFORCES,4473,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"import java.io.IOException;
import java.io.PrintStream;
import java.util.*;

public class Template {

    public static void main(String[] args) throws IOException {
        final Scanner in = new Scanner(System.in);
        final PrintStream out = System.out;
        int n = in.nextInt(), m = in.nextInt();
        boolean[][] g = new boolean[n][n];
        for (int i = 0; i < m; ++i) {
            int a = in.nextInt(), b = in.nextInt();
            --a; --b;
            g[a][b] = g[b][a] = true;
        }
        final int mx = 1<<n;
        long[][] dp = new long[mx][n];
        long res = 0;
        for (int mask = 0; mask < mx; ++mask)
            for (int i = 0; i < n; ++i) {
                if (mask == (1 << i)) {
                    dp[mask][i] = 1;
                } else if (((mask & (1 << i)) != 0) && ((mask & ((1 << i) - 1)) != 0)) {
                    long r = 0;
                    int next = mask ^ (1<<i);
                    for (int j = 0; j < n; ++j) if (g[i][j]) {
                        r += dp[next][j];
                    }
                    dp[mask][i] = r;
                } else {
                    dp[mask][i] = 0;
                }

                if ((mask & (mask-1)) != 0 && g[i][lowestBit(mask)]) {
                    res += dp[mask][i];
                }

            }

        System.out.println((res-m)/2);
    }

    private static int lowestBit(int mask) {
        for (int i = 0;;++i) {
            if ((mask & (1<<i)) > 0) {
                return i;
            }
        }
    }

}
",0011_D,CODEFORCES,4442,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException; 
import java.io.InputStreamReader; 
import java.util.Scanner; 
import java.util.StringTokenizer; 
import java.util.*;
import java.io.*;
public class codeforces 
{ 
   static class Student{
       long x,y;
        Student(long x,long y){
            this.x=x;
            this.y=y;
        }
    }
    static int prime[];
    static void sieveOfEratosthenes(int n) 
    { 
        // Create a boolean array ""prime[0..n]"" and initialize 
        // all entries it as true. A value in prime[i] will 
        // finally be false if i is Not a prime, else true. 
        int pos=0;
        prime= new int[n+1]; 
        for(int p = 2; p*p <=n; p++) 
        { 
            // If prime[p] is not changed, then it is a prime 
            if(prime[p] == 0)
            { 
                // Update all multiples of p
                prime[p]=p;
                for(int i = p*p; i <= n; i += p) 
                    prime[i] = p; 
            } 
        } 
    }
static    class Sortbyroll implements Comparator<Student> 
{ 
    // Used for sorting in ascending order of 
    // roll number 
    public int compare(Student c, Student b) 
    { 
        if(c.x<=b.x)
            return -1;
        return 1;
    } 
} 
static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader() 
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 
 
    static class Edge{
        int a,b;
        Edge(int a,int b){
            this.a=a;
            this.b=b;
        }
    }
    static int parent[];
    static int rank[];
    static int b[][];
    //static int seg[];
    static int ans;
    static void solve()throws IOException{
        FastReader sc=new FastReader();
        int c,x,i;
        long l,r,y=1,f=0,t1,t2;
        int a1[]=new int[64];
        int a2[]=new int[64];
        int ans[]=new int[64];
        c=-1;
        l=sc.nextLong();
        t1=l;
        r=sc.nextLong();
        t2=r;
        while(l!=0){
            a1[++c]=(int)(l%(long)2);
            l=l/(long)2;
        }
        c=-1;
                while(r!=0){
            a2[++c]=(int)(r%(long)2);
                    r=r/(long)2;
        }
        for(i=63;i>=0;i--){
            ans[i]=a2[i];
            if(a2[i]==1&&a1[i]==0)
                break;
        }
        if(t1==t2)
            System.out.println(0);
        else
        System.out.println((1l<<(i+1))-1);
    }
    public static void main(String[] args){
        //long sum=0;
        try {
                codeforces.solve();
                } catch (Exception e) {
                    e.printStackTrace();
                }
    }
 /*static long power(long x, long y, long p) 
{ 
    long res = 1;      // Initialize result 
  
    x = x % p;  // Update x if it is more than or  
                // equal to p 
  
    /*while (y > 0) 
    { 
        // If y is odd, multiply x with result 
        if ((y & (long)1)%2!=0) 
            res = (res*x) % p; 
  
        // y must be even now 
        y = y>>1; // y = y/2 
        x = (x*x) % p;   
    } */
    //return res%p; 
   static int find(int x) 
    { 
        // Finds the representative of the set 
        // that x is an element of 
        while(parent[x]!=x) 
        { 
            // if x is not the parent of itself 
            // Then x is not the representative of 
            // his set,
            x=parent[x];
  
            // so we recursively call Find on its parent 
            // and move i's node directly under the 
            // representative of this set 
        } 
  
        return x; 
    }
    static void union(int x, int y) 
    { 
        // Find representatives of two sets 
        int xRoot = find(x), yRoot = find(y); 
  
        // Elements are in the same set, no need 
        // to unite anything. 
        if (xRoot == yRoot) 
            return; 
  
         // If x's rank is less than y's rank 
        if (rank[xRoot] < rank[yRoot]) 
  
            // Then move x under y  so that depth 
            // of tree remains less 
            parent[xRoot] = yRoot; 
  
        // Else if y's rank is less than x's rank 
        else if (rank[yRoot] < rank[xRoot]) 
  
            // Then move y under x so that depth of 
            // tree remains less 
            parent[yRoot] = xRoot; 
  
        else // if ranks are the same 
        { 
            // Then move y under x (doesn't matter 
            // which one goes where) 
            parent[yRoot] = xRoot; 
  
            // And increment the the result tree's 
            // rank by 1 
            rank[xRoot] = rank[xRoot] + 1; 
        } 
    } 
    static long gcd(long a, long b) 
    { 
        if (a == 0) 
            return b; 
        return gcd(b % a, a); 
    }
}",0276_D,CODEFORCES,863,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;

public class ProblemE {
	
	
	static final int INF = 1000000;
	
	
	
	public static void main(String[] args) throws IOException {
		BufferedReader s = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(System.out);

		int n = Integer.valueOf(s.readLine());
		double[][] prob = new double[n][n];
		double[] dp = new double[1<<n];
		for (int i = 0 ; i < n ; i++) {
			String[] line = s.readLine().split("" "");
			for (int j = 0 ; j < n ; j++) {
				prob[i][j] = Double.valueOf(line[j]);
			}
		}
		
		dp[(1<<n)-1] = 1.0d;
		for (int p = (1<<n)-1 ; p >= 1 ; p--) {
			if (dp[p] > 0.0d) {
				int left = Integer.bitCount(p);
				if (left == 1) {
					continue;
				}
				double baseProb = 1.0d / (left * (left - 1) / 2);
				for (int i = 0 ; i < n ; i++) {
					if ((p & (1<<i)) == 0) {
						continue;
					}
					for (int j = i+1 ; j < n ; j++) {
						if ((p & (1<<j)) == 0) {
							continue;
						}
						dp[p-(1<<i)] += dp[p] * baseProb * prob[j][i];
						dp[p-(1<<j)] += dp[p] * baseProb * prob[i][j];
					}
				}
			}
		}
		
		
		StringBuffer b = new StringBuffer();
		for (int i = 0 ; i < n ; i++) {
			b.append("" "").append(dp[1<<i]);
		}
		out.println(b.substring(1));
		out.flush();
	}



	public static void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}
}",0016_E,CODEFORCES,4503,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author sheep
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskD solver = new TaskD();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskD {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n = in.nextInt();
        boolean[][] map = new boolean[n][n];
        int m = in.nextInt();

        int[] us = new int[m];
        int[] vs = new int[m];

        for (int i = 0; i < m; ++i) {
            int u = in.nextInt() - 1;
            int v = in.nextInt() - 1;
            map[u][v] = true;

            us[i] = u;
            vs[i] = v;
        }

        int ans = Integer.MAX_VALUE;
        for (int center = 0; center < n; ++center) {
            int fixed = 0;
            for (int i = 0; i < n; ++i) {
                if (!map[center][i]) {
                    ++fixed;
                }
                if (!map[i][center] && i != center) {
                    ++fixed;
                }
            }

            MaxFlow flow = new MaxFlow(n * 2 + 2, n * 2, n * 2 + 1);

            for (int i = 0; i < n; ++i) {
                if (i == center) continue;
                flow.insert(n * 2, i, 1);
                flow.insert(i + n, n * 2 + 1, 1);
            }

            for (int i = 0; i < m; ++i) {
                if (us[i] == center || vs[i] == center) {
                    continue;
                }

                flow.insert(us[i], vs[i] + n, 1);
                ++fixed;
            }

            ans = Math.min(ans, fixed + (n - 1) - 2 * flow.maxFlow());
        }

        out.println(ans);
    }
}

class InputReader {
    BufferedReader reader;
    StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream));
        tokenizer = null;
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (Exception e) {
                throw new UnknownError();
            }
        }
        return tokenizer.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    }

class MaxFlow
{
    public class Edge
    {
        public int u,v,c;
        public Edge next,r;

        public Edge(int u,int v,int c)
        {
            this.u = u;
            this.v = v;
            this.c = c;
            next = r = null;
        }
    }

    public Edge vertex[];
    public int height[], nheight[];
    public int s, t, n;

    public void init(int n,int s,int t)
    {
        height = new int[n+1];
        nheight = new int[n+1];
        vertex = new Edge[n+1];
        this.s = s;
        this.t = t;
        this.n = n;
    }

    public MaxFlow(int n,int s,int t)
    {
        init(n,s,t);
    }

    public void insert(int u,int v,int c)
    {
        Edge e = new Edge(u,v,c);
        Edge r = new Edge(v,u,0);
        e.r = r;
        r.r = e;
        e.next = vertex[u];
        vertex[u] = e;
        r.next = vertex[v];
        vertex[v] = r;
    }

    public int augPath(int u,int push)
    {
        if (u == t) return push;
        int flow = push, minheight = n-1;
        for (Edge e = vertex[u]; e != null; e = e.next)
            if (e.c != 0)
            {
                if (height[e.v] + 1 == height[e.u])
                {
                    int delta = flow < e.c ? flow : e.c;
                    if (delta > 0)
                        delta = augPath(e.v,delta);
                    e.c -= delta;
                    e.r.c += delta;
                    flow -= delta;
                    if (0 == flow || height[s] >= n) return push - flow;
                }
                minheight = Math.min(minheight, height[e.v]);
            }
        if (push == flow)
        {
            --nheight[height[u]];
            if (0 == nheight[height[u]]) height[s] = n;
            height[u] = ++minheight;
            ++nheight[height[u]];
        }
        return push - flow;
    }

    public int maxFlow()
    {
        Arrays.fill(height, 0);
        Arrays.fill(nheight, 0);
        nheight[0] = n;
        int flow = 0;
        while (height[s] < n)
            flow += augPath(s,Integer.MAX_VALUE);
        return flow;
    }
}
",0387_D,CODEFORCES,3995,George and Interesting Graph,"George loves graphs. Most of all, he loves interesting graphs. We will assume that a directed graph is interesting, if it meets the following criteria: 
However, not everything's that simple. George got a directed graph of n vertices and m arcs as a present. The graph didn't have any multiple arcs. As George loves interesting graphs, he wants to slightly alter the presented graph and transform it into an interesting one. In one alteration he can either remove an arbitrary existing arc from the graph or add an arbitrary arc to the graph. 
George wonders: what is the minimum number of changes that he needs to obtain an interesting graph from the graph he's got as a present? Help George and find the answer to the question.
The first line contains two space-separated integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ 1000) — the number of vertices and arcs in the presented graph.
Each of the next m lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n) — the descriptions of the graph's arcs. Pair (ai, bi) means that the graph contains an arc from vertex number ai to vertex number bi. It is guaranteed that the presented graph doesn't contain multiple arcs.
Assume that the grah vertices are numbered 1 through n.
Print a single integer — the answer to George's question.
","input
For more information about directed graphs, please visit: http://en.wikipedia.org/wiki/Directed_graph
output
In the first sample the graph already is interesting, its center is vertex 3.
",graphmatchings,6
"



import java.util.Scanner;



public class D {

    static long max;



    public static long[] getOneRange(long min, long max,int bit) {

        long st=(min&(((1l<<63)-1)&~((1l<<(bit+1))-1)))|(1l<<bit);

        long end=st|((1l<<(bit+1))-1);

        long interSt=Math.max(st,min);

        long interEnd=Math.min(end, max);

        if(interSt>interEnd) return null;

        return new long[]{interSt,interEnd};

    }



    public static long[] getZeroRange(long min, long max,int bit) {

        long st=min&(((1l<<63)-1)&~((1l<<(bit+1))-1));

        long end=st|((1l<<bit)-1);

        long interSt=Math.max(st,min);

        long interEnd=Math.min(end, max);

        if(interSt>interEnd) return null;

        return new long[]{interSt,interEnd};

    }



    public static void solve(int bitPosition, long min1, long max1, long min2,

            long max2, long curNum) {

        if (bitPosition == -1) {

            max = Math.max(max, curNum);

            return;

        }

        long[] firZeroRange = getZeroRange(min1, max1,bitPosition);

        long[] secZeroRange = getZeroRange(min2, max2,bitPosition);

        long[] firOneRange = getOneRange(min1, max1,bitPosition);

        long[] secOneRange = getOneRange(min2, max2,bitPosition);

        if ((firOneRange != null && secZeroRange != null)

                || (firZeroRange != null && secOneRange != null)) {

            long newNum = curNum | (1l << bitPosition);

            if (firOneRange != null && secZeroRange != null&&

                    (firOneRange[1]-firOneRange[0]+1)==1l<<bitPosition&&

                    (secZeroRange[1]-secZeroRange[0]+1)==1l<<bitPosition) {

                solve(bitPosition - 1, firOneRange[0], firOneRange[1],

                        secZeroRange[0], secZeroRange[1], newNum);

                return;

            }

            if (firZeroRange != null && secOneRange != null&&

                    (firZeroRange[1]-firZeroRange[0]+1)==1l<<bitPosition&&

                    (secOneRange[1]-secOneRange[0]+1)==1l<<bitPosition) {

                solve(bitPosition - 1, firZeroRange[0], firZeroRange[1],

                        secOneRange[0], secOneRange[1], newNum);

                return;

            }

            if (firOneRange != null && secZeroRange != null) {

                solve(bitPosition - 1, firOneRange[0], firOneRange[1],

                        secZeroRange[0], secZeroRange[1], newNum);

            }

            if (firZeroRange != null && secOneRange != null) {

                solve(bitPosition - 1, firZeroRange[0], firZeroRange[1],

                        secOneRange[0], secOneRange[1], newNum);

            }

        } else {

            solve(bitPosition - 1, min1, max1, min2, max2, curNum);

        }

    }



    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        long l = sc.nextLong();

        long r = sc.nextLong();

        max = 0;

        solve(62, l, r, l, r, 0);

        System.out.println(max);

    }

}

",0276_D,CODEFORCES,826,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import java.io.*;
import java.util.*;

public class P035C {
    private class Pair {
        private int x;
        private int y;
        
        private Pair(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        public int hashCode() {
            return 37 * x + y;
        }
        
        public boolean equals(Object other) {
            if (other instanceof Pair) {
                Pair otherPair = (Pair)other;
                return x == otherPair.x && y == otherPair.y;
            }
            
            return false;
        }
    }
    
    private boolean[][] visited;
    private final int N;
    private final int M;
    private final int k;
    private ArrayList<Pair> fires = new ArrayList<Pair>();
    private ArrayList<Pair> neighbors = new ArrayList<Pair>();
    
    public P035C() throws IOException {
        Scanner sc = new Scanner(new File(""input.txt""));

        N = sc.nextInt();
        M = sc.nextInt();
        visited = new boolean[N][M];
        k = sc.nextInt();
        for (int i = 0; i < k; i++) {
            int x = sc.nextInt() - 1;
            int y = sc.nextInt() - 1;
            fires.add(new Pair(x, y));
        }
        bfs();
    }
    
    private void bfs() throws IOException{
        java.util.Queue<Pair> queue = new ArrayDeque<Pair>();
        for (Pair p : fires) {
            queue.add(p);
            visited[p.x][p.y] = true;
        }
        
        Pair last = fires.get(0);
        while (!queue.isEmpty()) {
            Pair p = last = queue.poll();            
            for (Pair pn : getNeighbors(p)) {
                if (!visited[pn.x][pn.y]) {
                    queue.add(pn);
                    visited[pn.x][pn.y] = true;
                }
            }
        }
        
        PrintWriter output = new PrintWriter(new FileWriter(new File(""output.txt"")));
        output.printf(""%d %d\n"", last.x + 1, last.y + 1);
        output.close();
    }
    
    private Collection<Pair> getNeighbors(Pair p) {
        neighbors.clear();
        if (p.x > 0)   neighbors.add(new Pair(p.x-1, p.y));
        if (p.x < N-1) neighbors.add(new Pair(p.x+1, p.y));
        if (p.y > 0)   neighbors.add(new Pair(p.x, p.y-1));
        if (p.y < M-1) neighbors.add(new Pair(p.x, p.y+1));
        
        return neighbors;
    }
    
    public static void main(String[] args) throws IOException {
        P035C solution = new P035C();
    }
}
        
      ",0035_C,CODEFORCES,3925,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;


/*

 */
public class C455 {
	static int N;
	static final int mod = 1_000_000_007;
	static int[][] memo;
	static int[] list;
	public static void main(String[] args) {
		FS scan = new FS(System.in);
		
		N = scan.nextInt();
		list = new int[N];
		for(int i=0;i<N;i++) {
			list[i] = scan.next().equals(""s"")?0:1;
		}
		if(list[N-1] == 1) {
			System.out.println(0);
			return;
		}
		memo = new int[N+1][N+2];
		Arrays.fill(memo[N], 1);
		int[] sum = new int[N+2];
		
		for(int i=N-1;i>=0;i--) {
			sum[0] = memo[i+1][0];
			for(int j=1;j<sum.length;j++) {
				sum[j] = sum[j-1] + memo[i+1][j];
				sum[j] %= mod;
			}
			for(int j=0;j<=N;j++) {
				if (list[i]==1 && (i==0 || list[i-1]==1))
					memo[i][j] = memo[i+1][j+1];
				else if(i==0 || list[i-1] == 1)
					memo[i][j] = memo[i+1][j];
				else if (list[i]==1){
//					for(int k=0;k<=j;k++) {
//						memo[i][j] += memo[i+1][k+1];
//					}
					memo[i][j] = sum[j+1] - sum[0] + mod;
					memo[i][j] %= mod;
					
				}
				else if (list[i]==0) {
					memo[i][j] = sum[j];
				}
			}
		}
		
//		for(int i=0;i<=N;i++) {
//			for(int j=0;j<=N;j++) {
//				System.out.print(memo[i][j]+"" "");
//			}
//			System.out.println();
//		}
//		System.out.println();
		System.out.println(memo[0][0]);
	}
	
	private static class FS {
		BufferedReader br;
		StringTokenizer st;
		public FS(InputStream in) {
			br = new BufferedReader(new InputStreamReader(in));
		}
		String next(){
			while(st==null||!st.hasMoreElements()){
				try{st = new StringTokenizer(br.readLine());}
				catch(IOException e){e.printStackTrace();}
			}
			return st.nextToken();
		}
		int nextInt() {return Integer.parseInt(next());}
		long nextLong() {return Long.parseLong(next());}
		double nextDouble() { return Double.parseDouble(next());}
	}
}
",0909_C,CODEFORCES,3114,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"// discussed with rainboy
import java.io.*;
import java.util.*;

public class CF915E {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter pw = new PrintWriter(System.out);
		int n = Integer.parseInt(br.readLine());
		int q = Integer.parseInt(br.readLine());
		TreeMap<Integer, Integer> mp = new TreeMap<>();
		int ans = 0;
		while (q-- > 0) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int l = Integer.parseInt(st.nextToken()) - 1;
			int r = Integer.parseInt(st.nextToken());
			int t = Integer.parseInt(st.nextToken());
			Map.Entry<Integer, Integer> e;
			int l_, r_;
			if (t == 1) {
				if ((e = mp.floorEntry(l)) != null && (r_ = e.getValue()) >= l) {
					l_ = e.getKey();
					ans -= r_ - l_;
					l = l_;
					r = Math.max(r, r_);
				}
				while ((e = mp.higherEntry(l)) != null && (l_ = e.getKey()) <= r) {
					r_ = e.getValue();
					ans -= r_ - l_;
					r = Math.max(r, r_);
					mp.remove(l_);
				}
				ans += r - l;
				mp.put(l, r);
			} else {
				r_ = l;
				if ((e = mp.floorEntry(l)) != null && (r_ = e.getValue()) > l) {
					l_ = e.getKey();
					if (l_ < l)
						mp.put(l_, l);
					else
						mp.remove(l_);
					ans -= r_ - l;
				}
				while ((e = mp.higherEntry(l)) != null && (l_ = e.getKey()) < r) {
					r_ = e.getValue();
					mp.remove(l_);
					ans -= r_ - l_;
				}
				if (r_ > r) {
					mp.put(r, r_);
					ans += r_ - r;
				}
			}
			pw.println(n - ans);
		}
		pw.close();
	}
}
",0915_E,CODEFORCES,2797,Physical Education Lessons,"This year Alex has finished school, and now he is a first-year student of Berland State University. For him it was a total surprise that even though he studies programming, he still has to attend physical education lessons. The end of the term is very soon, but, unfortunately, Alex still hasn't attended a single lesson!
Since Alex doesn't want to get expelled, he wants to know the number of working days left until the end of the term, so he can attend physical education lessons during these days. But in BSU calculating the number of working days is a complicated matter:
There are n days left before the end of the term (numbered from 1 to n), and initially all of them are working days. Then the university staff sequentially publishes q orders, one after another. Each order is characterised by three numbers l, r and k:
Help Alex to determine the number of working days left after each order!
The first line contains one integer n, and the second line — one integer q (1 ≤ n ≤ 109, 1 ≤ q ≤ 3·105) — the number of days left before the end of the term, and the number of orders, respectively.
","input
Then q lines follow, i-th line containing three integers li, ri and ki representing i-th order (1 ≤ li ≤ ri ≤ n, 1 ≤ ki ≤ 2).
output
Print q integers. i-th of them must be equal to the number of working days left until the end of the term after the first i orders are published.
","datastructures, implementation, sortings",4
"

import java.io.*;

import java.util.*;



public class z3 {



    public static long tr(long k, long n) {



        long left = 1;

        long right = k;



        while (left < right) {

            long mid = (left + right) / 2;

            long s = sum(mid, k);

            if (s == n) {

                return k - mid + 1;

            } else if (s > n) {

                left = mid + 1;

            } else {

                right = mid;

            }

        }



        return k - left +2 ;

    }



    static long sum(long left, long right , long s) {

        if (left <= right) 

            s = sum(right) - sum(left-1);

        return s;

    }

       static long sum(long left, long right ) {

        return sum(left, right, 0);

    }





    static long sum(long n) {

        return n * (n + 1) / 2;

    }



    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);

         long n = in.nextLong();

        long k = in.nextLong();

        if (n == 1) {

            System.out.println(""0"");

        } else if (k >= n) {

            System.out.println(""1"");

        } else {

            n -= 1;

            k -= 1;

        

        

        if (sum(k) < n) {

            System.out.println(""-1"");

        } else {



            System.out.println(tr(k, n));



        }

        }

    }

}

",0287_B,CODEFORCES,901,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.util.*;
public class CFEdu66 {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		long n = in.nextLong();
		long k = in.nextLong();
		double tmp = Math.sqrt(9 + 8*(n+k));
		if(Math.ceil(tmp)-tmp<0.001)
			tmp = Math.ceil(tmp);
		
		long root = (long)tmp;
		long x = (-3+root)/2;
		System.out.println(n-x);
		
	}

}
",1195_B,CODEFORCES,1414,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import com.sun.org.apache.xerces.internal.util.SynchronizedSymbolTable;
import jdk.management.cmm.SystemResourcePressureMXBean;

import java.awt.*;
import java.io.*;
import java.lang.reflect.Array;
import java.text.DecimalFormat;
import java.util.*;
import java.util.List;
import java.math.*;

public class Newbie {

    static InputReader sc = new InputReader(System.in);
    static PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
        solver s = new solver();
        int t = 1;
        while (t > 0) {
            s.solve();
            t--;
        }
        out.close();
    }

   /* static class descend implements Comparator<pair1> {
        public int compare(pair1 o1, pair1 o2) {
            if (o1.pop != o2.pop)
                return (int) (o1.pop - o2.pop);
            else
                return o1.in - o2.in;
        }
    }*/

    static class InputReader {
        public BufferedReader br;
        public StringTokenizer token;

        public InputReader(InputStream stream) {
            br = new BufferedReader(new InputStreamReader(stream), 32768);
            token = null;
        }

        public String next() {
            while (token == null || !token.hasMoreTokens()) {
                try {
                    token = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return token.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }

    static class card {
        long a;
        int cnt;
        int i;

        public card(long a, int cnt, int i) {
            this.a = a;
            this.cnt = cnt;
            this.i = i;
        }
    }

    static class ascend implements Comparator<pair> {
        public int compare(pair o1, pair o2) {
            return o1.a - o2.a;
        }
    }

    static class extra {

        static boolean v[] = new boolean[100001];
        static List<Integer> l = new ArrayList<>();
        static int t;

        static void shuffle(long a[]) {
            List<Long> l = new ArrayList<>();
            for (int i = 0; i < a.length; i++)
                l.add(a[i]);
            Collections.shuffle(l);
            for (int i = 0; i < a.length; i++)
                a[i] = l.get(i);
        }

        static long gcd(long a, long b) {
            if (b == 0)
                return a;
            else
                return gcd(b, a % b);
        }

        static boolean valid(int i, int j, int r, int c) {
            if (i >= 0 && i < r && j >= 0 && j < c)
                return true;
            else
                return false;
        }

        static void seive() {
            for (int i = 2; i < 100001; i++) {
                if (!v[i]) {
                    t++;
                    l.add(i);
                    for (int j = 2 * i; j < 100001; j += i)
                        v[j] = true;
                }
            }
        }

        static int binary(long a[], long val, int n) {
            int mid = 0, l = 0, r = n - 1, ans = 0;
            while (l <= r) {
                mid = (l + r) >> 1;
                if (a[mid] == val) {
                    r = mid - 1;
                    ans = mid;
                } else if (a[mid] > val)
                    r = mid - 1;
                else {
                    l = mid + 1;
                    ans = l;
                }
            }
            return (ans + 1);
        }

        static long fastexpo(int x, int y) {
            long res = 1;
            while (y > 0) {
                if ((y & 1) == 1) {
                    res *= x;
                }
                y = y >> 1;
                x = x * x;
            }
            return res;
        }

        static long lfastexpo(int x, int y, int p) {
            long res = 1;
            x = x % p;
            while (y > 0) {
                if ((y & 1) == 1) {
                    res = (res * x) % p;
                }
                y = y >> 1;
                x = (x * x) % p;
            }
            return res;
        }
    }

    static class pair {
        int a;
        int b;

        public pair(int a, int i) {
            this.a = a;
            this.b = i;
        }
    }

    static class pair1 {
        pair p;
        int in;

        public pair1(pair a, int n) {
            this.p = a;
            this.in = n;
        }
    }

    static long m = (long) 1e9 + 7;

    static class solver {
        void solve() {
            int n = sc.nextInt();
            int ans=0;
            int a[]=new int[2*n];
            for (int i = 0; i < 2 * n; i++) {
               a[i]=sc.nextInt();
            }
            for(int i=0;i<2*n;i++)
            {
                if(a[i]>0)
                {
                    int j=0;
                    for(j=i+1;a[i]!=a[j];j++)
                    {
                        if(a[j]>0)
                            ans++;
                    }
                    a[j]=0;
                }
            }
            System.out.println(ans);
        }
    }
}",0995_B,CODEFORCES,3278,Suit and Tie,"Allen is hosting a formal dinner party. $$$2n$$$ people come to the event in $$$n$$$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $$$2n$$$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.
Help Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 100$$$), the number of pairs of people.
The second line contains $$$2n$$$ integers $$$a_1, a_2, \dots, a_{2n}$$$. For each $$$i$$$ with $$$1 \le i \le n$$$, $$$i$$$ appears exactly twice. If $$$a_j = a_k = i$$$, that means that the $$$j$$$-th and $$$k$$$-th people in the line form a couple.
Output a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.
","input
In the first sample case, we can transform $$$1 1 2 3 3 2 4 4 \rightarrow 1 1 2 3 2 3 4 4 \rightarrow 1 1 2 2 3 3 4 4$$$ in two steps. Note that the sequence $$$1 1 2 3 3 2 4 4 \rightarrow 1 1 3 2 3 2 4 4 \rightarrow 1 1 3 3 2 2 4 4$$$ also works in the same number of steps.
output
The second sample case already satisfies the constraints; therefore we need $$$0$$$ swaps.
","greedy, implementation, math",5
"import java.io.*;
import java.util.*;
public class D11 {
	static HashMap<State, Integer> map;
	static long[][] ans;
	static boolean[][] connect;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		map = new HashMap<State, Integer>();
		connect = new boolean[n][n];
		ans = new long[n][1<<n];
		for(int i = 0; i < n; i++)
			Arrays.fill(ans[i], -1);
		int m = Integer.parseInt(st.nextToken());
		while(m-- > 0)	{
			st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			a--;
			b--;
			connect[a][b] = connect[b][a] = true;
		}
		long ret = 0;
		int mask = 1 << n;
		mask--;
		for(int i = 0; i < n; i++)	{
			for(int out = i+1; out < n; out++)	{
				if(connect[i][out])	{
					ret += solve(mask - (1<<out), out, true);
				}
			}
			mask -= (1<<i);
		}
		System.out.println(ret/2);
	}
	public static long solve(int mask, int start, boolean a)	{
		if(ans[start][mask] != -1)
			return ans[start][mask];
		int end = 0;
		while((mask & (1<<end)) == 0)
			end++;
		long ret = 0;
		for(int out = 0; out < connect.length; out++)	{
			if(connect[start][out] && (mask & (1 << out)) != 0)	{
				if(out == end)	{
					if(!a)
						ret++;
				}
				else
					ret += solve(mask - (1<<out), out, false);
			}
		}
		ans[start][mask] = ret;
		return ret;
	}
	static class State	{
		public byte start, go;
		public int mask;
		public State(byte a, byte b, int c)	{
			start = a;
			go = b;
			mask = c;
		}
		public int hashCode()	{
			return 10007*mask + 43 * start + go;
		}
		public boolean equals(Object o)	{
			State s = (State)o;
			return start == s.start && go == s.go && mask == s.mask;
		}
	}
}
",0011_D,CODEFORCES,4458,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"///package round_global_14;


import java.io.*;
import java.util.*;

public class B {
    static class InputReader {
        BufferedReader buffreader;
        StringTokenizer strtokenizer;
        public InputReader(InputStream inputstr) {
            buffreader = new BufferedReader(new InputStreamReader(inputstr), 1000000);strtokenizer = null; }
        //////////////////////////////////////////////////////////////////////////////////////////
        String next() {
            while (strtokenizer == null || !strtokenizer.hasMoreTokens()) {
                try { strtokenizer = new StringTokenizer(buffreader.readLine()); }
                catch (IOException e) { throw new RuntimeException(e); }
            }
            return strtokenizer.nextToken(); }
        ///////////////////////////////////////////////////////////////////////////////////////////
        public int nextInt() { return Integer.parseInt(next()); }
        public long nextLong() { return Long.parseLong(next()); }
        public double nextDouble() { return Double.parseDouble(next()); }
        public int[] nextIntArr(int n){
            int[] arr=new int[n];
            for (int i=0;i<n;i++){arr[i]=nextInt();}
            return arr;}
        public long[] nextLongArr(int n){
            long[] arr=new long[n];
            for (int i=0;i<n;i++){arr[i]=nextLong();}
            return arr;}
        public String[] nextStringArr(int n){
            String[] arr=new String[n];
            for (int i=0;i<n;i++){arr[i]=next();}
            return arr;}
    }
    static InputReader r = new InputReader(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    public static void main(String[] args){
        int t=r.nextInt();
        for (int v=0;v<t;v++){
            int n=r.nextInt();
            if (n%2==1){
                pw.println(""NO"");
            }
            else{
                int x=n/2;
                boolean check=false;
                for (int i=1;i<=(int)Math.sqrt(x)+1;i++){
                    if (i*i*2==x||i*i==x){
                        pw.println(""YES"");check=true;break;
                    }
                }
                if (!check){
                    pw.println(""NO"");
                }
            }


        }
        pw.close();


    }
}
",1515_B,CODEFORCES,2184,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",3
"import java.awt.Point;
import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;


import static java.lang.Math.*;

public class Start {

    final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;
    BufferedReader in;
    PrintWriter out;
    StringTokenizer tok = new StringTokenizer("""");

    void init() throws FileNotFoundException {
        if (ONLINE_JUDGE) {
            in = new BufferedReader(new InputStreamReader(System.in));
            out = new PrintWriter(System.out);
        } else {
            in = new BufferedReader(new FileReader(""input.txt""));
            out = new PrintWriter(""output.txt"");
        }
    }

    String readString() throws IOException {
        while (!tok.hasMoreTokens()) {
            tok = new StringTokenizer(in.readLine());
        }
        return tok.nextToken();
    }

    int readInt() throws IOException {
        return Integer.parseInt(readString());
    }

    long readLong() throws IOException {
        return Long.parseLong(readString());
    }

    double readDouble() throws IOException {
        return Double.parseDouble(readString());
    }

    public static void main(String[] args) {
        new Start().run();
    }

    public static void mergeSort(int[] a) {
        mergeSort(a, 0, a.length - 1);
    }

    private static void mergeSort(int[] a, int levtIndex, int rightIndex) {
        final int MAGIC_VALUE = 50;
        if (levtIndex < rightIndex) {
            if (rightIndex - levtIndex <= MAGIC_VALUE) {
                insertionSort(a, levtIndex, rightIndex);
            } else {
                int middleIndex = (levtIndex + rightIndex) / 2;
                mergeSort(a, levtIndex, middleIndex);
                mergeSort(a, middleIndex + 1, rightIndex);
                merge(a, levtIndex, middleIndex, rightIndex);
            }
        }
    }

    private static void merge(int[] a, int levtIndex, int middleIndex,
            int rightIndex) {
        int length1 = middleIndex - levtIndex + 1;
        int length2 = rightIndex - middleIndex;
        int[] levtArray = new int[length1];
        int[] rightArray = new int[length2];
        System.arraycopy(a, levtIndex, levtArray, 0, length1);
        System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);
        for (int k = levtIndex, i = 0, j = 0; k <= rightIndex; k++) {
            if (i == length1) {
                a[k] = rightArray[j++];
            } else if (j == length2) {
                a[k] = levtArray[i++];
            } else {
                a[k] = levtArray[i] <= rightArray[j] ? levtArray[i++]
                        : rightArray[j++];
            }
        }
    }

    private static void insertionSort(int[] a, int levtIndex, int rightIndex) {
        for (int i = levtIndex + 1; i <= rightIndex; i++) {
            int current = a[i];
            int j = i - 1;
            while (j >= levtIndex && a[j] > current) {
                a[j + 1] = a[j];
                j--;
            }
            a[j + 1] = current;
        }
    }

    public void run() {
        try {
            long t1 = System.currentTimeMillis();
            init();
            solve();
            out.close();
            long t2 = System.currentTimeMillis();
            System.err.println(""Time = "" + (t2 - t1));
        } catch (Exception e) {
            e.printStackTrace(System.err);
            System.exit(-1);
        }
    }
    
    class Lol implements Comparable<Lol>{
        int x;
        int y;
        
            public Lol (int x , int y){
                this.x = x;
                this.y = y;
            }

            @Override
            public int compareTo(Lol arg0) {
                if (arg0.x == x) {
                    return y-arg0.y;
                }
                return arg0.x-x;
            }
        
    }

    public void solve() throws IOException {
        
        int n = readInt();
        int k = readInt();
        k--;
        Lol [] a = new Lol [n];
                
        for (int i  = 0 ; i  <n; i++){
            int x = readInt();
            int y = readInt();
            a[i] = new Lol(x, y);
        }
        Arrays.sort(a);
        int ans = 1; 
        for (int i =k+1; i>-1; i++){
            if (i==n) break;
            if (a[i].x==a[k].x && a[i].y == a[k].y){
                ans++;
            }
            else break;
        }
        if (k!=0){
            for (int i =k-1; i>=0; i--){
                if (a[i].x==a[k].x && a[i].y == a[k].y){
                    ans++;
                }
                else break;
            }
        }
        out.print(ans);
        
        
        
    }
}

































",0166_A,CODEFORCES,2494,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"import java.io.*;
import java.util.*;
import java.lang.*;
import java.math.BigInteger;
public class Main{
    static InputReader sc;
    static PrintWriter pw;
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        sc = new InputReader(inputStream);
        pw = new PrintWriter(outputStream);
        solve();
        pw.close();
    }
    // static int L,R,top,bottom;
    // static int cnt,edge;
    // static long ans;
    static int time;
    // static boolean isIsland;
    static BigInteger min(BigInteger a, BigInteger b){        
        if(a.compareTo(b)<0)
            return a;
        return b;
    }
    public static void solve(){        
        int t=1;
        t=s(0);
        u:while(t-->0){
            int n=s(0);
            int []arr=new int [n];
            feedArr(arr);
            Stack<Pair> stk=new Stack<>();
            stk.push(new Pair("""",1));
            pln(1);
            Pair pr;
            for(int i=1;i<n;i++){
                if(arr[i]==1){
                    pr=stk.peek();
                    stk.push(new Pair(pr.s+(pr.s.length()==0?"""":""."")+pr.i,1));
                    pln(stk.peek().s+"".""+stk.peek().i);
                }
                else if(stk.peek().i==arr[i]-1){
                    pr=stk.pop();
                    pln(pr.s+(pr.s.length()==0?"""":""."")+arr[i]);
                    pr.i++;
                    stk.push(pr);
                }
                else{
                    stk.pop();
                    i--;
                }
            }
        }        
    }        
    static long fact(long p){
        long ans=1l;
        for(long i=2;i<=p;i++)
            ans*=i;
        return ans;
    }    
    static int find(int j, List<Integer> B, List<Integer> A, int i){
        // System.out.println(""Hi"");
        int l=j,r=B.size()-1,m;        
        while(l<=r){
            m=(r-l)/2+l;
            if(A.size()-i-1<=B.size()-m-1)
                l=m+1;
            else
                r=m-1;
        }
        // System.out.println(""Bye"");
        return r;
    }
    static int find2(List<Integer> B, int x){
        int l=0,r=B.size()-1,m;
        // System.out.println(""Hi2"");
        // System.out.println(j);
        while(l<=r){            
            m=(r-l)/2+l;
            // System.out.println(m);
            if(B.get(m)-x<=0)
                l=m+1;
            else
                r=m-1;
        }
        // System.out.println(""Bye2"");
        return r;        
    }
    static long nPr(long n, long r){
        long ans=1;
        for(long i=1;i<=r;i++)
            ans*=(n-i+1);
        return ans;
    }
    static long nCr(long n, long r){
        long ans=1;
        for(long i=1;i<=r;i++){
            ans*=(n-i+1);
            ans/=i;
        }
        return ans;
    }
    static void update_DAG(int cur,int val, int []graph, int n)
    {
        if(val>maxx[cur])
        {
            int x=graph[cur];
            if(x!=-1)
                update_DAG(x,val+1,graph,n);
            maxx[cur]=val;
            update(cur,val,n);
        }
    }
    static int []bit, maxx;
    static void update(int i,int val, int n)
    {
        while(i<=n)
        {
            bit[i]=Math.max(bit[i],val);
            i=i+(i&(-i));
        }
    }
    static int query(int i)
    {
        int ret=0;
        while(i>0)
        {
            ret=Math.max(ret,bit[i]);
            i=i-(i&(-i));
        }
        return ret;
    }    
    public static int [][]dir=new int [][]{{1,0},{0,1},{-1,0},{0,-1}};        
    public static int find(List<Integer> list, int x){
        int l=0,r=list.size()-1,m;
        while(l<=r){
            m=(r-l)/2+l;
            if(list.get(m)<=x)
                l=m+1;
            else
                r=m-1;
        }
        return r;
    } 
    static class Node{
        int val;
        long cost;
        Node next;
        Node(int v,long c){
            val=v;
            next=null;
            cost=c;
        }
    }    
    public static long sum(long n){
        long val=0l;
        while(n>0){
            val+=n%10;
            n/=10;
        }
        return val;
    }
    // static class Node{
    //     int left,right;
    //     Node prev,next;
    //     Node(int i, int v){
    //         left=i;
    //         right=v;
    //         prev=next=null;
    //     }
    //     void remove(){
    //         this.prev.next=this.next;
    //         this.next.prev=this.prev;
    //     }
    //     void insert(Node node){
    //         node.next=this;
    //         node.prev=this.prev;
    //         node.prev.next=node;
    //         this.prev=node;
    //     }
    // } 
    public static int  findDiameter(int r, List<List<Integer>>list){
        return findFarthest(findFarthest(r,list)[0],list)[1];
    }
    public static int[] findFarthest(int u, List<List<Integer>>list){
        int n=list.size();
        boolean []vis=new boolean[n+1];
        Queue<Integer>q=new LinkedList<>();
        q.offer(u);
        vis[u]=true;
        int s,pr,cnt=0;
        int []ar=new int[]{u,0};
        while(q.size()>0){
            s=q.size();
            while(s-->0){
                pr=q.poll();
                if(ar[1]<cnt){
                    ar[1]=cnt;
                    ar[0]=pr;
                }
                for(int i:list.get(pr)){
                    if(!vis[i]){
                        vis[i]=true;
                        q.offer(i);
                    }
                }
            }
            cnt++;
        }
        return ar;
    }
    public static long atMostK(char []chrr, int k){
        if(k<0)
            return 0;
        int l=0,cnt=0;
        long ans=0l;
        for(int i=0;i<chrr.length;i++){
            if(chrr[i]=='1')
                cnt++;
            while(cnt>k){
                if(chrr[l++]=='1')
                    cnt--;
            }
            ans+=(long)(i-l)+1l;
        }
        return ans;
    }
    public static int ask(int l, int r){
        System.out.println(""? ""+l+"" ""+r);
        System.out.flush();
        return sc.nextInt();
    }
    public static void sort(int []arr){
        ArrayList<Integer> list=new ArrayList<>();
        for(int i=0;i<arr.length;i++)
            list.add(arr[i]);
        Collections.sort(list);
        for(int i=0;i<arr.length;i++)
            arr[i]=list.get(i);
    }
    public static void sort(long []arr){
        ArrayList<Long> list=new ArrayList<>();
        for(int i=0;i<arr.length;i++)
            list.add(arr[i]);
        Collections.sort(list);
        for(int i=0;i<arr.length;i++)
            arr[i]=list.get(i);
    }
    public static void swap(char []chrr, int i, int j){
        char temp=chrr[i];
        chrr[i]=chrr[j];
        chrr[j]=temp;
    }
    public static int countSetBits(long n){
        int a=0;
        while(n>0){
            a+=(n&1);
            n>>=1;
        }
        return a;
    }
    static class Pair{
        String s;
        int i;
        Pair(String S, int I){
            s=S;
            i=I;
        }
     //*
    }
    /*/
        public int compareTo(Pair p){
            return (b-p.b);
        }
        public int hashCode(){
            int hashcode = (a+"" ""+b).hashCode();
            return hashcode;
        }
        public boolean equals(Object obj){
            if (obj instanceof Pair) {
                Pair p = (Pair) obj;
                return (p.a==this.a && p.b == this.b);
            }
            return false;
        }
    }
    //*/
    static boolean isPrime(long n) { 
        if (n <= 1) 
            return false; 
        if (n <= 3) 
            return true; 
        if (n % 2 == 0 || n % 3 == 0) 
            return false; 
        for (int i = 5; i * i <= n; i = i + 6) 
            if (n % i == 0 || n % (i + 2) == 0) 
                return false; 
        return true; 
    } 
    static long gcd(long a, long b) { 
        if (b == 0) 
            return a; 
        return a>b?gcd(b, a % b):gcd(a, b % a);  
    } 
    static long fast_pow(long base,long n,long M){
        if(n==0)
           return 1;
        if(n==1)
        return base;
        long halfn=fast_pow(base,n/2,M);
        if(n%2==0)
            return ( halfn * halfn ) % M;
        else
            return ( ( ( halfn * halfn ) % M ) * base ) % M;
    }
    static long modInverse(long n,long M){
        return fast_pow(n,M-2,M);
    }
    public static int s(int n){
        return sc.nextInt();
    }
    public static long s(long n){
        return sc.nextLong();
    }
    public static String s(String n){
        return sc.next();
    }
    public static double s(double n){
        return sc.nextDouble();
    }
    public static void p(int n){
        pw.print(n);
    }
    public static void p(long n){
        pw.print(n);
    }
    public static void p(String n){
        pw.print(n);
    }
    public static void p(double n){
        pw.print(n);
    }
    public static void pln(int n){
        pw.println(n);
    }
    public static void pln(long n){
        pw.println(n);
    }
    public static void pln(String n){
        pw.println(n);
    }
    public static void pln(double n){
        pw.println(n);
    }
    public static void feedArr(long []arr){
        for(int i=0;i<arr.length;i++)
            arr[i]=sc.nextLong();
    }
    public static void feedArr(double []arr){
        for(int i=0;i<arr.length;i++)
            arr[i]=sc.nextDouble();
    }
    public static void feedArr(int []arr){
        for(int i=0;i<arr.length;i++)
            arr[i]=sc.nextInt();
    }
    public static void feedArr(String []arr){
        for(int i=0;i<arr.length;i++)
            arr[i]=sc.next();
    }
    public static String printArr(int []arr){
        StringBuilder sbr=new StringBuilder();
        for(int i:arr)
            sbr.append(i+"" "");
        return sbr.toString();
    }
    public  static String printArr(long []arr){
        StringBuilder sbr=new StringBuilder();
        for(long i:arr)
            sbr.append(i+"" "");
        return sbr.toString();
    }
    public static String printArr(String []arr){
        StringBuilder sbr=new StringBuilder();
        for(String i:arr)
            sbr.append(i+"" "");
        return sbr.toString();
    }
    public static String printArr(double []arr){
        StringBuilder sbr=new StringBuilder();
        for(double i:arr)
            sbr.append(i+"" "");
        return sbr.toString();
    }
    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;
 
        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}
class AncestorQuerier {
    int [][]dp;
    int N=200001;
    int M=22;
    int max;    
    public void preCompute(int []par){
        for(int i=0;i<N;i++){
            if(i>=2&&i<par.length)
                dp[i][0]=par[i];
            else
                dp[i][0]=-1;
        }
        for(int j=1;j<M;j++){
            for(int i=0;i<N;i++){
                if(dp[i][j-1]!=-1)
                    dp[i][j]=dp[dp[i][j-1]][j-1];
            }
        }       
    }    
    public int getAncestor(int val, int k) {
        if(k<0||val>max)
            return -1;
        if(k==0)
            return val;
        int t=(1<<(M-1));        
        for(int i=M-1;i>=0&&val!=-1;i--,t>>=1){
            if(t<=k){
                val=dp[val][i];
                k-=t;
            }
        }
        return val;   
    }
}",1523_C,CODEFORCES,3620,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees",5
"import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class main
{
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;
	private PrintWriter pw;
	private long mod = 1000000000 + 7;

	private StringBuilder ans_sb;
	private ArrayList<Integer> primes;
	private long ans;

	private void soln()
	{
		int n = nextInt();
		long[] arr = new long[n];
		for (int i = 0; i < n; i++)
			arr[i] = nextLong();
		Segment tree = new Segment(n, arr);
		long[] ans = new long[n];
		BigInteger fa = BigInteger.ZERO;
		HashMap<Long, Integer> map = new HashMap<>();
		for (int i = 0; i < n; i++)
		{
			ans[i] = ((long) i + 1) * arr[i] - tree.query(0, i);
			if (map.containsKey(arr[i] - 1))
			{
				long tmp = map.get(arr[i] - 1);
				ans[i] -= tmp;
			}
			if (map.containsKey(arr[i] + 1))
			{
				long tmp = map.get(arr[i] + 1);
				ans[i] += tmp;
			}

			if (!map.containsKey(arr[i]))
				map.put(arr[i], 0);
			map.put(arr[i], map.get(arr[i]) + 1);
			fa = fa.add(new BigInteger(Long.toString(ans[i])));
		}
		// debug(ans);
		/*
		 * Node[] nn = new Node[n]; for(int i=0;i<n;i++) { nn[i] = new Node();
		 * nn[i].node = i; nn[i].dist = arr[i]; } //debug(fa); Arrays.sort(nn);
		 * //debug(nn); for(int i=0;i<n-1;i++) { if(nn[i].dist + 1 == nn[i+1].dist) {
		 * System.out.println(nn[i].node +"" ""+nn[i+1].node); if(nn[i].node >
		 * nn[i+1].node) { fa++; }else fa--; } }
		 */
		pw.println(fa.toString());
		// int k = nextInt();
		// int n = nextInt();
		// String[] arr = new String[k];
		// for(int i=0;i<k;i++)
		// arr[i] = nextLine();
		// HashSet<String> set1 = new HashSet<>();
		// for(int i=0;i<k;i++)
		// set1.add(arr[i]);
		// if(set1.size() == 1) {
		// String s = arr[0];
		// pw.print(s.charAt(1));
		// pw.print(s.charAt(0));
		// for(int i=2;i<n;i++)
		// pw.print(s.charAt(i));
		// }else {
		// String s1 = arr[0];
		// set1.remove(arr[0]);
		// HashSet<Integer>[] aa = new HashSet[set1.size()];
		// ArrayList<String> set = new ArrayList<>();
		// for(String s:set1)
		// set.add(s);
		// int k1 = 0;
		// boolean f1 = false;
		// for(String s:set) {
		// aa[k1] = new HashSet<>();
		// for(int i=0;i<n;i++)
		// if(s1.charAt(i) != s.charAt(i))
		// aa[k1].add(i);
		// if(aa[k1].size() > 4) {
		// pw.println(-1);
		// f1 = true;
		// }
		// k1++;
		// }
		// //debug(set);
		// char[] ch = s1.toCharArray();
		//
		// boolean[] f11 = new boolean[set.size()];
		// int k2 = 0;
		// for(String s:set) {
		// int[] freq = new int[26];
		// for(int i=0;i<n;i++)
		// freq[s.charAt(i)-'a']++;
		// boolean kuu = false;
		// for(int i=0;i<26;i++)
		// if(freq[i] >= 2) {
		// kuu = true;
		// break;
		// }
		// f11[k2] = true;
		// k2++;
		// }
		// // debug(f11);
		//
		// for(int i=0;i<n;i++) {
		// if(f1)
		// break;
		// for(int j=i+1;j<n;j++) {
		// if(f1)
		// break;
		// //System.out.println(i+"" ""+j);
		// char tmp = ch[i];
		// ch[i] = ch[j];
		// ch[j] = tmp;
		// k1 = 0;
		// HashSet<Integer> haha = new HashSet<>();
		// boolean f = true;
		// for(String s:set) {
		// HashSet<Integer> indi = aa[k1];
		// boolean h1 = false;
		// boolean h2 = false;
		// if(!indi.contains(i)) {
		// indi.add(i);
		// h1 = true;
		// }
		// if(!indi.contains(j)) {
		// indi.add(j);
		// h2 = true;
		// }
		// int cnt = 0;
		// for(int ii:indi) {
		// if(s.charAt(ii) != ch[ii])
		// cnt++;
		// }
		// /*if(i==1 && j==3) {
		// System.out.println(cnt+"" ""+i+"" ""+j+"" ""+s);
		// debug(indi);
		// }*/
		// if(cnt > 2 ) {
		// f = false;
		// break;
		// }
		// if(cnt ==1 && !f11[k1]) {
		// f = false;
		// break;
		// }
		// if(h1)
		// indi.remove(i);
		// if(h2)
		// indi.remove(j);
		// k1++;
		//
		// }
		// if(f) {
		// for(int i1=0;i1<n;i1++) {
		// pw.print(ch[i1]);
		// }
		// f1 = true;
		// break;
		// }
		// tmp = ch[i];
		// ch[i] = ch[j];
		// ch[j] = tmp;
		// }
		// }
		// if(!f1)
		// pw.println(-1);
		// }
	}

	public class Segment
	{
		private Node[] tree;
		private boolean[] lazy;
		private int size;
		private int n;
		private long[] base;

		private class Node
		{
			private int l;
			private int r;
			private long ans;
			private long ans2;
		}

		public Segment(int n, long[] arr)
		{
			this.base = arr;
			int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));
			size = 2 * (int) Math.pow(2, x) - 1;
			tree = new Node[size];
			lazy = new boolean[size];
			this.n = n;
			// this.set = set1;
			build(0, 0, n - 1);
		}

		public void build(int id, int l, int r)
		{
			if (l == r)
			{
				tree[id] = new Node();
				tree[id].l = l;
				tree[id].r = r;
				tree[id].ans = base[l];
				return;
			}
			int mid = (l + r) / 2;
			build(2 * id + 1, l, mid);
			build(2 * id + 2, mid + 1, r);
			tree[id] = merge(tree[2 * id + 1], tree[2 * id + 2], l, r);
			// System.out.println(l+"" ""+r+"" ""+tree[id].l+"" ""+tree[id].r+"" ""+tree[id].ans);
		}

		public Node merge(Node n1, Node n2, int l, int r)
		{
			Node ret = new Node();
			if (n1 == null && n2 == null)
				return null;
			else if (n1 == null)
			{
				ret.ans = n2.ans;
			}

			else if (n2 == null)
			{
				ret.ans = n1.ans;
			} else
			{

				ret.ans = n1.ans + n2.ans;

			}

			return ret;
		}

		public long query(int l, int r)
		{
			Node ret = queryUtil(l, r, 0, 0, n - 1);
			if (ret == null)
			{
				return 0;
			} else
				return ret.ans;
		}

		private Node queryUtil(int x, int y, int id, int l, int r)
		{
			if (l > y || x > r)
				return null;
			if (x <= l && r <= y)
			{
				return tree[id];
			}
			int mid = l + (r - l) / 2;
			// shift(id);
			Node q1 = queryUtil(x, y, 2 * id + 1, l, mid);
			Node q2 = queryUtil(x, y, 2 * id + 2, mid + 1, r);

			return merge(q1, q2, Math.max(l, x), Math.min(r, y));
		}

		public void update(int x, int y, int c)
		{
			update1(x, y, c, 0, 0, n - 1);
		}

		private void update1(int x, int y, int colour, int id, int l, int r)
		{
			// System.out.println(l+"" ""+r+"" ""+x);
			if (x > r || y < l)
				return;
			if (x <= l && r <= y)
			{
				if (colour != -1)
				{
					tree[id] = new Node();
					tree[id].ans = 1;
				} else
					tree[id] = null;
				return;
			}
			int mid = l + (r - l) / 2;
			// shift(id);
			if (y <= mid)
				update1(x, y, colour, 2 * id + 1, l, mid);
			else if (x > mid)
				update1(x, y, colour, 2 * id + 2, mid + 1, r);
			else
			{
				update1(x, y, colour, 2 * id + 1, l, mid);
				update1(x, y, colour, 2 * id + 2, mid + 1, r);
			}
			tree[id] = merge(tree[2 * id + 1], tree[2 * id + 2], l, r);

		}

		public void print(int l, int r, int id)
		{
			if (l == r)
			{
				if (tree[id] != null)
					System.out.println(l + "" "" + r + "" "" + tree[id].l + "" "" + tree[id].r + "" "" + tree[id].ans + "" ""
							+ tree[id].ans2);
				return;
			}
			int mid = l + (r - l) / 2;
			print(l, mid, 2 * id + 1);
			print(mid + 1, r, 2 * id + 2);
			if (tree[id] != null)
				System.out.println(
						l + "" "" + r + "" "" + tree[id].l + "" "" + tree[id].r + "" "" + tree[id].ans + "" "" + tree[id].ans2);
		}

		public void shift(int id)
		{

		}
	}

	private class Node implements Comparable<Node>
	{
		int node;
		long dist;

		@Override
		public int compareTo(Node arg0)
		{
			if (this.dist != arg0.dist)
				return (int) (this.dist - arg0.dist);
			return this.node - arg0.node;
		}

		public boolean equals(Object o)
		{
			if (o instanceof Node)
			{
				Node c = (Node) o;
				return this.node == c.node && this.dist == c.dist;
			}
			return false;
		}

		public String toString()
		{
			return this.node + "", "" + this.dist;
		}
	}

	private void debug(Object... o)
	{
		System.out.println(Arrays.deepToString(o));
	}

	private long pow(long a, long b, long c)
	{
		if (b == 0)
			return 1;
		long p = pow(a, b / 2, c);
		p = (p * p) % c;
		return (b % 2 == 0) ? p : (a * p) % c;
	}

	private long gcd(long n, long l)
	{
		if (l == 0)
			return n;
		return gcd(l, n % l);
	}

	public static void main(String[] args) throws Exception
	{
		new Thread(null, new Runnable()
		{
			@Override
			public void run()
			{
				new main().solve();
			}
		}, ""1"", 1 << 26).start();
	}

	public StringBuilder solve()
	{
		InputReader(System.in);
		/*
		 * try { InputReader(new FileInputStream(""C:\\Users\\hardik\\Desktop\\in.txt""));
		 * } catch(FileNotFoundException e) {}
		 */
		pw = new PrintWriter(System.out);
		ans_sb = new StringBuilder();
		soln();

		pw.close();
		// System.out.println(ans_sb);
		return ans_sb;
	}

	public void InputReader(InputStream stream1)
	{
		stream = stream1;
	}

	private boolean isWhitespace(int c)
	{
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	private boolean isEndOfLine(int c)
	{
		return c == '\n' || c == '\r' || c == -1;
	}

	private int read()
	{
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars)
		{
			curChar = 0;
			try
			{
				numChars = stream.read(buf);
			} catch (IOException e)
			{
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	private int nextInt()
	{
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-')
		{
			sgn = -1;
			c = read();
		}
		int res = 0;
		do
		{
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	private long nextLong()
	{
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-')
		{
			sgn = -1;
			c = read();
		}
		long res = 0;
		do
		{
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	private String nextToken()
	{
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do
		{
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	private String nextLine()
	{
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do
		{
			res.appendCodePoint(c);
			c = read();
		} while (!isEndOfLine(c));
		return res.toString();
	}

	private int[] nextIntArray(int n)
	{
		int[] arr = new int[n];
		for (int i = 0; i < n; i++)
		{
			arr[i] = nextInt();
		}
		return arr;
	}

	private long[] nextLongArray(int n)
	{
		long[] arr = new long[n];
		for (int i = 0; i < n; i++)
		{
			arr[i] = nextLong();
		}
		return arr;
	}

	private void pArray(int[] arr)
	{
		for (int i = 0; i < arr.length; i++)
		{
			System.out.print(arr[i] + "" "");
		}
		System.out.println();
		return;
	}

	private void pArray(long[] arr)
	{
		for (int i = 0; i < arr.length; i++)
		{
			System.out.print(arr[i] + "" "");
		}
		System.out.println();
		return;
	}

	private boolean isSpaceChar(int c)
	{
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	private char nextChar()
	{
		int c = read();
		while (isSpaceChar(c))
			c = read();
		char c1 = (char) c;
		while (!isSpaceChar(c))
			c = read();
		return c1;
	}

	private interface SpaceCharFilter
	{
		public boolean isSpaceChar(int ch);
	}
}",0903_D,CODEFORCES,2770,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math",4
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Iterator;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.SplittableRandom;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.Comparator;
import java.util.NoSuchElementException;
import java.io.InputStream;
/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        final static int SAMPLES = 100;

        public void solve(int testNumber, InputReader in, OutputWriter out) {
            SplittableRandom splittableRandom = new SplittableRandom(System.currentTimeMillis());
            int n = in.readInt();
            int numQueries = in.readInt();
            int[] a = IOUtils.readIntArray(in, n);
            MiscUtils.decreaseByOne(a);
            int aMax = ArrayUtils.maxElement(a);
            Query[] queries = new Query[numQueries];
            for (int i = 0; i < queries.length; i++) {
                queries[i] = new Query(in.readInt() - 1, in.readInt() - 1, in.readInt(), i);
            }
            int blockSize = (int) Math.sqrt(numQueries);
            for (Query query : queries) {
                query.BLOCK = query.left / blockSize;
            }
            Arrays.sort(queries, new Comparator<Query>() {
                public int compare(Query o1, Query o2) {
                    if (o1.BLOCK != o2.BLOCK) {
                        return Integer.compare(o1.BLOCK, o2.BLOCK);
                    }
                    return o1.BLOCK % 2 == 0 ? Integer.compare(o1.right, o2.right) : -Integer.compare(o1.right, o2.right);
                }
            });
            int[] counts = new int[aMax + 1];
            int leftPtr = 0, rightPtr = -1;
            for (Query query : queries) {
                while (leftPtr < query.left) {
                    counts[a[leftPtr++]]--;
                }
                while (leftPtr > query.left) {
                    counts[a[--leftPtr]]++;
                }
                while (rightPtr < query.right) {
                    counts[a[++rightPtr]]++;
                }
                while (rightPtr > query.right) {
                    counts[a[rightPtr--]]--;
                }
                // count * k > r - l + 1
                int res = 1000 * 1000 * 1000;
                for (int SAMPLE = 0; SAMPLE < SAMPLES; SAMPLE++) {
                    int val = a[query.left + splittableRandom.nextInt(query.right - query.left + 1)];
                    int count = counts[val];
                    if (count * query.k > query.right - query.left + 1) {
                        res = Math.min(res, val);
                    }
                }
                if (res >= 1000 * 1000 * 1000) {
                    query.res = -1;
                } else {
                    query.res = res + 1;
                }
            }
            Arrays.sort(queries, new Comparator<Query>() {
                public int compare(Query o1, Query o2) {
                    return Integer.compare(o1.index, o2.index);
                }
            });
            for (Query query : queries) {
                out.printLine(query.res);
            }
        }

        class Query {
            int left;
            int right;
            int k;
            int index;
            int BLOCK;
            int res;

            public Query(int left, int right, int k, int index) {
                this.left = left;
                this.right = right;
                this.k = k;
                this.index = index;
            }
        }
    }
    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void printLine(int i) {
            writer.println(i);
        }
    }
    static interface IntReversableCollection extends IntCollection {
    }
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    static interface IntIterator {
        public int value() throws NoSuchElementException;
        public boolean advance();
        public boolean isValid();
    }
    static class ArrayUtils {
        public static int maxElement(int[] array) {
            return new IntArray(array).max();
        }
    }
    static abstract class IntAbstractStream implements IntStream {
        public String toString() {
            StringBuilder builder = new StringBuilder();
            boolean first = true;
            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
                if (first) {
                    first = false;
                } else {
                    builder.append(' ');
                }
                builder.append(it.value());
            }
            return builder.toString();
        }

        public boolean equals(Object o) {
            if (!(o instanceof IntStream)) {
                return false;
            }
            IntStream c = (IntStream) o;
            IntIterator it = intIterator();
            IntIterator jt = c.intIterator();
            while (it.isValid() && jt.isValid()) {
                if (it.value() != jt.value()) {
                    return false;
                }
                it.advance();
                jt.advance();
            }
            return !it.isValid() && !jt.isValid();
        }

        public int hashCode() {
            int result = 0;
            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
                result *= 31;
                result += it.value();
            }
            return result;
        }
    }
    static class IntArray extends IntAbstractStream implements IntList {
        private int[] data;

        public IntArray(int[] arr) {
            data = arr;
        }

        public int size() {
            return data.length;
        }

        public int get(int at) {
            return data[at];
        }

        public void removeAt(int index) {
            throw new UnsupportedOperationException();
        }
    }
    static class MiscUtils {
        public static void decreaseByOne(int[]... arrays) {
            for (int[] array : arrays) {
                for (int i = 0; i < array.length; i++) {
                    array[i]--;
                }
            }
        }
    }
    static interface IntList extends IntReversableCollection {
        public abstract int get(int index);
        public abstract void removeAt(int index);
        default public IntIterator intIterator() {
            return new IntIterator() {
                private int at;
                private boolean removed;

                public int value() {
                    if (removed) {
                        throw new IllegalStateException();
                    }
                    return get(at);
                }

                public boolean advance() {
                    at++;
                    removed = false;
                    return isValid();
                }

                public boolean isValid() {
                    return !removed && at < size();
                }

                public void remove() {
                    removeAt(at);
                    at--;
                    removed = true;
                }
            };
        }
    }
    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {
        public IntIterator intIterator();
        default public Iterator<Integer> iterator() {
            return new Iterator<Integer>() {
                private IntIterator it = intIterator();

                public boolean hasNext() {
                    return it.isValid();
                }

                public Integer next() {
                    int result = it.value();
                    it.advance();
                    return result;
                }
            };
        }
        default public int compareTo(IntStream c) {
            IntIterator it = intIterator();
            IntIterator jt = c.intIterator();
            while (it.isValid() && jt.isValid()) {
                int i = it.value();
                int j = jt.value();
                if (i < j) {
                    return -1;
                } else if (i > j) {
                    return 1;
                }
                it.advance();
                jt.advance();
            }
            if (it.isValid()) {
                return 1;
            }
            if (jt.isValid()) {
                return -1;
            }
            return 0;
        }
        default public int max() {
            int result = Integer.MIN_VALUE;
            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
                int current = it.value();
                if (current > result) {
                    result = current;
                }
            }
            return result;
        }
    }
    static interface IntCollection extends IntStream {
        public int size();
    }
    static class IOUtils {
        public static int[] readIntArray(InputReader in, int size) {
            int[] array = new int[size];
            for (int i = 0; i < size; i++) {
                array[i] = in.readInt();
            }
            return array;
        }
    }
}

",0840_D,CODEFORCES,4039,Destiny,"Once, Leha found in the left pocket an array consisting of n integers, and in the right pocket q queries of the form l r k. If there are queries, then they must be answered. Answer for the query is minimal x such that x occurs in the interval l r strictly more than  times or  - 1 if there is no such number. Help Leha with such a difficult task.
First line of input data contains two integers n and q (1 ≤ n, q ≤ 3·105) — number of elements in the array and number of queries respectively.
Next line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — Leha's array.
","input
Each of next q lines contains three integers l, r and k (1 ≤ l ≤ r ≤ n, 2 ≤ k ≤ 5) — description of the queries.
output
Output answer for each query in new line.
","datastructures, probabilities",6
"import java.io.*;
import java.util.*;
import java.util.function.IntPredicate;

import static java.lang.Math.*;

public class Main {
    FastScanner in;
    PrintWriter out;

    static final String FILE = """";

    public static final int TEST = 0;

    class Interact {
        Rect a, b;

        public Interact(int x11, int y11, int x12, int y12, int x21, int y21, int x22, int y22) {
            a = new Rect(x11, y11, x12, y12);
            b = new Rect(x21, y21, x22, y22);
        }

        int query(int x1, int y1, int x2, int y2) {
            int ans = 0;
            if (x1 <= a.x1 && x2 >= a.x2 && y1 <= a.y1 && y2 >= a.y2)
                ans++;
            if (x1 <= b.x1 && x2 >= b.x2 && y1 <= b.y1 && y2 >= b.y2)
                ans++;
            return ans;
        }
    }
    Interact interact;

    class Rect {
        int x1, y1, x2, y2;

        public Rect() {
        }

        public Rect(int x1, int y1, int x2, int y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        }

        @Override
        public String toString() {
            return x1 + "" "" + y1 + "" "" + x2 + "" "" + y2;
        }
    }

    int calls;

    int query(int x1, int y1, int x2, int y2, Rect rect) {
        calls++;
        if (calls >= 190)
            throw new RuntimeException();

        if (TEST == 0) {
            out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
            out.flush();
            int ans = in.nextInt();
            if (x1 <= rect.x1 && x2 >= rect.x2 && y1 <= rect.y1 && y2 >= rect.y2)
                ans--;
            return ans;
        } else {
            int ans = interact.query(x1, y1, x2, y2);
            if (x1 <= rect.x1 && x2 >= rect.x2 && y1 <= rect.y1 && y2 >= rect.y2)
                ans--;
            return ans;
        }
    }

    static int binarySearchFirstTrue(IntPredicate predicate, int fromInclusive, int toInclusive) {
        int a = fromInclusive, b = toInclusive;
        while (a != b) {
            int la = a, lb = b;
            int mid = (a + b) / 2;
            if (predicate.test(mid))
                b = mid;
            else
                a = mid;
            if (la == a && lb == b) {
                if (predicate.test(a))
                    b = a;
                else
                    a = b;
            }
        }
        return a;
    }

    static int binarySearchLastTrue(IntPredicate predicate, int fromInclusive, int toInclusive) {
        int a = fromInclusive, b = toInclusive;
        while (a != b) {
            int la = a, lb = b;
            int mid = (a + b) / 2;
            if (predicate.test(mid))
                a = mid;
            else
                b = mid;
            if (la == a && lb == b) {
                if (predicate.test(b))
                    a = b;
                else
                    b = a;
            }
        }
        return a;
    }

    static Rect rect;

    void test() {
        Random random = new Random(13);
        for (int test = 0; test < 1000; test++) {

        }
    }

    void solve() {
        rect = new Rect();

        if (TEST == 0) {
            int n = in.nextInt();
            List<Rect> list = new ArrayList<>();
            for (int r = 0; r < 2; r++) {
                int x2 = binarySearchFirstTrue(i -> query(1, 1, i, n, rect) >= 1, 1, n);
                int x1 = binarySearchLastTrue(i -> query(i, 1, x2, n, rect) >= 1, 1, x2);
                int y2 = binarySearchFirstTrue(i -> query(x1, 1, x2, i, rect) >= 1, 1, n);
                int y1 = binarySearchLastTrue(i -> query(x1, i, x2, y2, rect) >= 1, 1, y2);
                rect = new Rect(x1, y1, x2, y2);
                list.add(rect);
            }
            out.println(""! "" + list.get(0) + "" "" + list.get(1));
            out.flush();
        } else {
            int n = in.nextInt();
            int x11 = in.nextInt(), y11 = in.nextInt(), x12 = in.nextInt(), y12 = in.nextInt();
            int x21 = in.nextInt(), y21 = in.nextInt(), x22 = in.nextInt(), y22 = in.nextInt();
            interact = new Interact(x11, y11, x12, y12, x21, y21, x22, y22);
            List<Rect> list = new ArrayList<>();
            for (int r = 0; r < 2; r++) {
                int x2 = binarySearchFirstTrue(i -> query(1, 1, i, n, rect) >= 1, 1, n);
                int x1 = binarySearchLastTrue(i -> query(i, 1, x2, n, rect) >= 1, 1, x2);
                int y2 = binarySearchFirstTrue(i -> query(x1, 1, x2, i, rect) >= 1, 1, n);
                int y1 = binarySearchLastTrue(i -> query(x1, i, x2, y2, rect) >= 1, 1, y2);
                rect = new Rect(x1, y1, x2, y2);
                list.add(rect);
            }
            out.println(""! "" + list.get(0) + "" "" + list.get(1));
            out.flush();
        }
    }

    public void run() {
        if (FILE.equals("""")) {
            in = new FastScanner(System.in);
            out = new PrintWriter(System.out);
        } else {
            try {
                in = new FastScanner(new FileInputStream(FILE +
                        "".in""));
                out = new PrintWriter(new FileOutputStream(FILE +
                        "".out""));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }
        solve();
        out.close();
    }

    public static void main(String[] args) {
        (new Main()).run();
    }

    class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        public String nextLine() {
            st = null;
            try {
                return br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public float nextFloat() {
            return Float.parseFloat(next());
        }
    }

}",0713_B,CODEFORCES,1035,Searching Rectangles,"Filya just learned new geometry object — rectangle. He is given a field consisting of n × n unit cells. Rows are numbered from bottom to top with integer from 1 to n. Columns are numbered from left to right with integers from 1 to n. Cell, located at the intersection of the row r and column c is denoted as (r, c). Filya has painted two rectangles, such that their sides are parallel to coordinate axes and each cell lies fully inside or fully outside each of them. Moreover, no cell lies in both rectangles.
Later, hedgehog Filya became interested in the location of his rectangles but was unable to find the sheet of paper they were painted on. They were taken by Sonya and now she wants to play a little game with Filya. He tells her a query rectangle and she replies with the number of initial rectangles that lie fully inside the given query rectangle. The query rectangle should match the same conditions as initial rectangles. Rectangle lies fully inside the query if each o its cells lies inside the query.
Filya knows Sonya really well, so is sure that if he asks more than 200 questions she will stop to reply.
The first line of the input contains an integer n (2 ≤ n ≤ 216) — size of the field.
For each query an integer between 0 and 2 is returned — the number of initial rectangles that lie fully inside the query rectangle.
To make a query you have to print ""? x1 y1 x2 y2"" (without quotes) (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n), where (x1, y1) stands for the position of the bottom left cell of the query and (x2, y2) stands for the up right cell of the query. You are allowed to ask no more than 200 queries. After each query you should perform ""flush"" operation and read the answer.
In case you suppose you've already determined the location of two rectangles (or run out of queries) you should print ""! x11 y11 x12 y12 x21 y21 x22 y22"" (without quotes), where first four integers describe the bottom left and up right cells of the first rectangle, and following four describe the corresponding cells of the second rectangle. You can print the rectangles in an arbitrary order. After you have printed the answer, print the end of the line and perform ""flush"". Your program should terminate immediately after it print the answer.
To flush you can use (just after printing an integer and end-of-line): 
You will get the Wrong Answer verdict if you ask more than 200 queries, or if you print an incorrect coordinates.
You will get the Idleness Limit Exceeded verdict if you don't print anything (but you should) or if you forget about flushing the output (more info below).
Hacking.
The first line should contain an integer n (2 ≤ n ≤ 216).
","input
The second line should contain four integers x1, y1, x2, y2 (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n) — the description of the first rectangle.
output
The third line contains the description of the second rectangle in the similar way.
","binarysearch, constructivealgorithms, interactive",2
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import java.util.StringTokenizer;

public class Main {
	
	InputStreamReader  inp = new InputStreamReader(System.in);
	BufferedReader in = new BufferedReader(inp);
	boolean test = false;

	String[] inData = { ""9"",
""HTHTHTHHT"",
		};

	static int id = -1;
	public String readLine() throws IOException {
		id++;
		if(test)
			return inData[id];
		else
			return in.readLine();
	}
	
	
	public Main() throws Throwable {
		
		int animalNr = Integer.valueOf(readLine());
		String animals = readLine();
		
		boolean[] state = new boolean[animalNr];
		int tigerCount = 0;
		for (int i = 0; i < animals.length(); i++) {
			if('T' == animals.charAt(i)){
				state[i] = true;
				tigerCount++;
			}
		}
		int best = Integer.MAX_VALUE;
		for (int i = 0; i < state.length; i++) {
			int swaps = 0;
			for (int j = i; j < i+tigerCount; j++) {
				if(state[j %animalNr] == false){
					swaps ++;
				}
			}
			if(swaps < best){
				best = swaps;
			}
		}
		
		System.out.println(best);
		
	}
	
	
	public static void main(String[] args) throws Throwable {
		new Main();
	}
}",0046_C,CODEFORCES,1601,Hamsters and Tigers,"Today there is going to be an unusual performance at the circus — hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.
The first line contains number n (2 ≤ n ≤ 1000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols ""H"" and ""T"". The ""H""s correspond to hamsters and the ""T""s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.
","input
Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.
output
In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then — the tiger in position 9 with the hamster in position 7.
",twopointers,3
"import java.io.BufferedReader;
import java.io.InputStreamReader;

public class B001 {
	static String conv(String s) {
		if (s.matches(""[A-Z]+\\d+"")) {
			int row = 0, col = 0;
			for (int x = 0; x < s.length(); x++) {
				char c = s.charAt(x);
				if (Character.isDigit(c)) {
					row = Integer.parseInt(s.substring(x));
					break;
				}
				col *= 26;
				col += c - 'A' + 1;
			}
			return String.format(""R%dC%d"", row, col);
		} else {
			String[] ss = s.split(""[RC]"");
			int row = Integer.parseInt(ss[1]), col = Integer.parseInt(ss[2]);
			StringBuffer coll = new StringBuffer();
			while (col > 0) {
				coll.append((char)('A' + (col - 1 + 26) % 26));
				col--;
				col /= 26;
			}
			return String.format(""%s%d"", coll.reverse().toString(), row);
		}
	}

	public static void main(String[] args) throws Exception {
		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(r.readLine());
		for (int x = 0; x < n; x++) {
			System.out.println(conv(r.readLine()));
		}
	}
}
",0001_B,CODEFORCES,1493,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math",3
"import java.util.*;
import java.io.*;
import java.lang.*;
import java.math.*;
import java.util.Map.*;
public class codeforces {
     static int count =0;
     static boolean f=false;
     static int [] arr;
	static 	PrintWriter pw=new PrintWriter(System.out);
	static void solve(int index , int mask) {
		if(index==arr.length) {
			int sum1=0; int sum2=0;
			for(int i=0;i<arr.length;i++) {
				if((mask & 1<<i)!=0) sum1+=arr[i];
				
			}
			return;
		}
		solve(index+1, mask | 1<<index);
		solve(index+1, mask);
	}
	public static void main(String [] args) throws IOException, InterruptedException {
		Scanner sc=new Scanner(System.in);
		int x=sc.nextInt();
		int y=sc.nextInt();
		pair [] arr=new pair[x];
		for(int i=0;i<x;i++) arr[i]=new pair(i, sc.nextInt(),0);
		for(int i=0;i<x;i++) arr[i].y=sc.nextInt();
		Arrays.sort(arr);
		PriorityQueue<Integer> qq=new PriorityQueue<>();
		//pw.println(Arrays.toString(arr));
		Long [] list=new Long [x];
		long sum=0; 
		for(int i=0;i<x;i++) {
			pair w=arr[i];
			if(qq.size()<y) {
				qq.add(w.y);
				sum+=w.y;
				list[w.i]=sum;

			}else if(!qq.isEmpty()) {
				sum+=w.y;
				list[w.i]=sum;
				int first=qq.poll();
				if(w.y>first) {
					sum-=first;
					qq.add(w.y);
				}else {
					qq.add(first);
					sum-=w.y;
				}
			} else list[w.i]=(long) w.y;
			//pw.println(qq);
		}
		for(Long w:list) pw.print(w+"" ""); 
		pw.flush();
		pw.close();
	}
	
	
	static class pair implements Comparable<pair>{
		String  name; int x,y,i ;
		public pair(String name , int x) {
			this.name=name; this.x=x;
		}
		
		public pair (int i,int x,int y) {
			this.i=i; this.x=x; this.y=y; 
		}
		public int compareTo(pair o) {
			return x-o.x;
		}
		public int compareTo1(pair o) {
			if(!name.equals(o.name))
				return name.compareTo(o.name);
			return x-o.x;
		}
		public String toString() {
			return i+"" ""+x+"" ""+y;
		}
	}

   static class Scanner {
		StringTokenizer st;
		BufferedReader br;
 
		public Scanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}
 
		public Scanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}
 
		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}
 
		public String nextLine() throws IOException {
			return br.readLine();
		}
 
		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}
 
		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}
 
		public char nextChar() throws IOException {
			return next().charAt(0);
		}
 
		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}
 
		public boolean ready() throws IOException {
			return br.ready();
		}
 
		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
	}",0994_B,CODEFORCES,2839,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings",4
"import java.io.*;

public class BH

{

public static void main(String args[])throws IOException

{

BufferedReader obj=new BufferedReader(new InputStreamReader(System.in));

int n=Integer.parseInt(obj.readLine());

int c=0,f,l;

while(c<n)

{

String s=obj.readLine();

char ch=s.charAt(0);

String p="""",q="""";

l=s.length();

for(f=1;f<l;f++)

{

if(s.charAt(f)=='C')

break;

}

if(ch=='R'&&(s.charAt(1)>='0'&&s.charAt(1)<='9')&&f!=l)

{

p=s.substring(1,f);

int y=Integer.parseInt(s.substring(f+1));

while(y!=0)

{

int d=y%26;

if(d==0)

{

d=26;

y=(y/26)-1;

}

else

y=y/26;

q=((char)(64+d))+q;

}

}

else

{

for(f=0;f<l;f++)

{

char t=s.charAt(f);

if(t>='1'&& t<='9')

break;

}

p=s.substring(0,f);

q=""R""+s.substring(f);

f--;

int w=0;

int e=0;

while(w<=f)

{

e=e+((int)Math.pow(26,w))*((int)p.charAt(f-w)-64);

w++;

}

p=""C""+e;

}

System.out.println(q+p);

c++;

}

}

}











",0001_B,CODEFORCES,1460,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math",3
"import java.util.*;
public class TwentyFive {
	
	public static void main(String[] args)
	{
		System.out.println(""25"");
	}
}
",0630_A,CODEFORCES,562,Again Twenty Five!,"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. ""Do I give such a hard task?"" — the HR manager thought. ""Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.""
Could you pass the interview in the machine vision company in IT City?
","input
The only line of the input contains a single integer n (2 ≤ n ≤ 2·1018) — the power in which you need to raise number 5.
output
Output the last two digits of 5n without spaces between them.
",numbertheory,1
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class PaintColor {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String input[] = br.readLine().split("" "");
        int c = 0;
        Set<Integer> s = new HashSet<>();
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(input[i]);
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            if (!s.contains(arr[i])) {
                c++;
                for (int j = i; j < n; j++) {
                    if (arr[j] % arr[i] == 0) {
                        s.add(arr[j]);
                    }
                }
            }
        }
        System.out.println(c);
    }
}
",1209_A,CODEFORCES,3529,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"//package round97;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

public class A {

	static BufferedReader bf = new BufferedReader(new InputStreamReader(
			System.in));
	static StringTokenizer st;
	static PrintWriter out = new PrintWriter(System.out);

	static String nextToken() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			String s = bf.readLine();
			if (s == null)
				return null;
			st = new StringTokenizer(s);
		}

		return st.nextToken();
	}

	static int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	static long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	static String nextStr() throws IOException {
		return nextToken();
	}

	static double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	public static void main(String[] args) throws IOException {
		int n = nextInt();
		int a[] = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = nextInt();
		}
		Arrays.sort(a);
		
		for (int q = 0; q < n; q++) {
			if (a[q] != 1) {
				out.print(""1"");
				for (int i = 1; i < n; i++) {
					out.print("" "" + a[i - 1]);
				}
				out.flush();
				return;
			}
		}
		
		for (int i = 0; i < n - 1; i++) {
			out.print(""1 "");
		}
		out.println(""2"");
		out.flush();
		
		
	}
}
",0135_A,CODEFORCES,2416,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings",4
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    private static StringTokenizer st;
    private static BufferedReader br;
    public static long MOD = 1000000007;

    public static void print(Object x) {
        System.out.println(x + """");
    }
    public static String join(Collection<?> x, String space) {
        if (x.size() == 0) return """";
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (Object elt : x) {
            if (first) first = false;
            else sb.append(space);
            sb.append(elt);
        }
        return sb.toString();
    }

    public static String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            String line = br.readLine();
            st = new StringTokenizer(line.trim());
        }
        return st.nextToken();
    }
    public static int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }
    public static long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    // Finds smallest rectangle containing something along 1 dimension.
    public static long[] search(long[] none, long[] some) throws IOException {
        long[] med = new long[4];
        for (int i = 0; i < 4; i++) {
            if (Math.abs(none[i] - some[i]) == 1) {
                return some;
            }
            med[i] = (none[i] + some[i]) / 2;
        }

        int ans = query(med);

        if (ans > 0) return search(none, med);
        else return search(med, some);
    }

    public static int query(long[] query) throws IOException {
        print(""? "" + arr(query));
        System.out.flush();

        int ans = nextInt();
        if (contains(query)) ans -= 1;

        return ans;
    }

    public static boolean contains(long[] search) {
        if (rect1 == null) return false;
        if (search[0] > rect1[0]) return false;
        if (search[1] > rect1[1]) return false;
        if (search[2] < rect1[2]) return false;
        if (search[3] < rect1[3]) return false;
        return true;
    }

    public static String arr(long[] x) {
        return x[0] + "" "" + x[1] + "" "" + x[2] + "" "" + x[3];
    }
    public static long[] find() throws IOException {
        long[] d0 = {1, 1, 1, 1};
        long[] some = {1, 1, n, n};
        if (query(d0) > 0) {
            return d0;
        }
//        print(""   "" + arr(some));
        long[] none = {1, 1, n, 1};
        if (query(none) > 0) some = none;
        else some = search(none, some);

//        print(""   "" + arr(some));
        none = new long[] {1, 1, 1, some[3]};
        if (query(none) > 0) some = none;
        else some = search(none, some);

//        print(""   "" + arr(some));
        none = new long[] {1, some[3], some[2], some[3]};
        if (query(none) > 0) some = none;
        else some = search(none, some);

//        print(""   "" + arr(some));
        none = new long[] {some[2], some[1], some[2], some[3]};
        if (query(none) > 0) some = none;
        else some = search(none, some);
        return some;
    }

    public static long[] rect1 = null;
    public static long[] rect2 = null;
    public static long n;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));

        n = nextLong();

        rect1 = find();
        rect2 = find();
        print(""! "" + arr(rect1) + "" ""
                   + arr(rect2));
        System.out.flush();
    }
}
",0713_B,CODEFORCES,1026,Searching Rectangles,"Filya just learned new geometry object — rectangle. He is given a field consisting of n × n unit cells. Rows are numbered from bottom to top with integer from 1 to n. Columns are numbered from left to right with integers from 1 to n. Cell, located at the intersection of the row r and column c is denoted as (r, c). Filya has painted two rectangles, such that their sides are parallel to coordinate axes and each cell lies fully inside or fully outside each of them. Moreover, no cell lies in both rectangles.
Later, hedgehog Filya became interested in the location of his rectangles but was unable to find the sheet of paper they were painted on. They were taken by Sonya and now she wants to play a little game with Filya. He tells her a query rectangle and she replies with the number of initial rectangles that lie fully inside the given query rectangle. The query rectangle should match the same conditions as initial rectangles. Rectangle lies fully inside the query if each o its cells lies inside the query.
Filya knows Sonya really well, so is sure that if he asks more than 200 questions she will stop to reply.
The first line of the input contains an integer n (2 ≤ n ≤ 216) — size of the field.
For each query an integer between 0 and 2 is returned — the number of initial rectangles that lie fully inside the query rectangle.
To make a query you have to print ""? x1 y1 x2 y2"" (without quotes) (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n), where (x1, y1) stands for the position of the bottom left cell of the query and (x2, y2) stands for the up right cell of the query. You are allowed to ask no more than 200 queries. After each query you should perform ""flush"" operation and read the answer.
In case you suppose you've already determined the location of two rectangles (or run out of queries) you should print ""! x11 y11 x12 y12 x21 y21 x22 y22"" (without quotes), where first four integers describe the bottom left and up right cells of the first rectangle, and following four describe the corresponding cells of the second rectangle. You can print the rectangles in an arbitrary order. After you have printed the answer, print the end of the line and perform ""flush"". Your program should terminate immediately after it print the answer.
To flush you can use (just after printing an integer and end-of-line): 
You will get the Wrong Answer verdict if you ask more than 200 queries, or if you print an incorrect coordinates.
You will get the Idleness Limit Exceeded verdict if you don't print anything (but you should) or if you forget about flushing the output (more info below).
Hacking.
The first line should contain an integer n (2 ≤ n ≤ 216).
","input
The second line should contain four integers x1, y1, x2, y2 (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n) — the description of the first rectangle.
output
The third line contains the description of the second rectangle in the similar way.
","binarysearch, constructivealgorithms, interactive",2
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class A {
    private static StreamTokenizer in;
    private static PrintWriter out;
    
    private static int nextInt() throws Exception{
        in.nextToken();
        return (int)in.nval;
    }
    
    private static String nextString() throws Exception{
        in.nextToken();
        return in.sval;
    }
    
    static{
        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(System.out);
    }
    
    public static void main(String[] args)throws Exception{
        int n = nextInt();
        
        out.println(n*3/2);
        
        out.flush();
    }
}
",0084_A,CODEFORCES,85,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;

public class KingEscape {

    public static void main(String[] args) {
        Reader read = new Reader();

        int n = read.nextInt();
        int a1 = read.nextInt();
        int a2 = read.nextInt();
        int b1 = read.nextInt();
        int b2 = read.nextInt();
        int c1 = read.nextInt();
        int c2 = read.nextInt();

        if (b1 > a1 && b2 > a2 && c1 > a1 && c2 > a2)
            System.out.print(""YES"");
        else if (b1 > a1 && b2 < a2 && c1 > a1 && c2 < a2)
            System.out.print(""YES"");
        else if (b1 < a1 && b2 > a2 && c1 < a1 && c2 > a2)
            System.out.print(""YES"");
        else if (b1 < a1 && b2 < a2 && c1 < a1 && c2 < a2)
            System.out.print(""YES"");
        else
            System.out.print(""NO"");
    }

    private static class Reader {

        private final BufferedReader reader;
        private final String separator;
        private String ln;
        private String[] tokens;
        private int ptr;

        Reader(String separator, InputStream input) {
            this.reader = new BufferedReader(new InputStreamReader(input));
            this.separator = separator;
            this.ptr = -1;
        }

        Reader(String separator) { this(separator, System.in); }

        Reader() { this("" ""); }

        String nextStr(){
            if (Objects.isNull(ln)) {
                try {
                    ln = reader.readLine();
                } catch (IOException e) {
                    System.out.println(e.getMessage());
                }
                if (Objects.nonNull(ln)) {
                    tokens = ln.split(separator);
                    ptr = 0;
                } else {
                    throw new NoSuchElementException(""no next element"");
                }

            } else if (ptr == tokens.length) {
                ln = null;
                tokens = null;
                ptr = -1;
                return nextStr();
            }

            return tokens[ptr++];
        }

        int nextInt() { return Integer.parseInt(nextStr()); }

        long nextLong() { return Long.parseLong(nextStr()); }

        double nextDouble() { return Double.parseDouble(nextStr()); }
    }
}
",1033_A,CODEFORCES,681,King Escape,"Alice and Bob are playing chess on a huge chessboard with dimensions $$$n \times n$$$. Alice has a single piece left — a queen, located at $$$(a_x, a_y)$$$, while Bob has only the king standing at $$$(b_x, b_y)$$$. Alice thinks that as her queen is dominating the chessboard, victory is hers. 
But Bob has made a devious plan to seize the victory for himself — he needs to march his king to $$$(c_x, c_y)$$$ in order to claim the victory for himself. As Alice is distracted by her sense of superiority, she no longer moves any pieces around, and it is only Bob who makes any turns.
Bob will win if he can move his king from $$$(b_x, b_y)$$$ to $$$(c_x, c_y)$$$ without ever getting in check. Remember that a king can move to any of the $$$8$$$ adjacent squares. A king is in check if it is on the same rank (i.e. row), file (i.e. column), or diagonal as the enemy queen. 
Find whether Bob can win or not.
The first line contains a single integer $$$n$$$ ($$$3 \leq n \leq 1000$$$) — the dimensions of the chessboard.
The second line contains two integers $$$a_x$$$ and $$$a_y$$$ ($$$1 \leq a_x, a_y \leq n$$$) — the coordinates of Alice's queen.
The third line contains two integers $$$b_x$$$ and $$$b_y$$$ ($$$1 \leq b_x, b_y \leq n$$$) — the coordinates of Bob's king.
The fourth line contains two integers $$$c_x$$$ and $$$c_y$$$ ($$$1 \leq c_x, c_y \leq n$$$) — the coordinates of the location that Bob wants to get to.
It is guaranteed that Bob's king is currently not in check and the target location is not in check either.
Furthermore, the king is not located on the same square as the queen (i.e. $$$a_x \neq b_x$$$ or $$$a_y \neq b_y$$$), and the target does coincide neither with the queen's position (i.e. $$$c_x \neq a_x$$$ or $$$c_y \neq a_y$$$) nor with the king's position (i.e. $$$c_x \neq b_x$$$ or $$$c_y \neq b_y$$$).
Print ""YES"" (without quotes) if Bob can get from $$$(b_x, b_y)$$$ to $$$(c_x, c_y)$$$ without ever getting in check, otherwise print ""NO"".
You can print each letter in any case (upper or lower).
In the diagrams below, the squares controlled by the black queen are marked red, and the target square is marked blue.
In the first case, the king can move, for instance, via the squares $$$(2, 3)$$$ and $$$(3, 2)$$$. Note that the direct route through $$$(2, 2)$$$ goes through check.
","input
In the second case, the queen watches the fourth rank, and the king has no means of crossing it.
output
In the third case, the queen watches the third file.
","dfsandsimilar, graphs, implementation",1
"import java.io.*;
import java.util.*;

public class CF1515E extends PrintWriter {
	CF1515E() { super(System.out, true); }
	Scanner sc = new Scanner(System.in);
	public static void main(String[] $) {
		CF1515E o = new CF1515E(); o.main(); o.flush();
	}

	int[] ff, gg; int md;
	long ch(int n, int k) {
		return (long) ff[n] * gg[k] % md * gg[n - k] % md;
	}
	long inv(int a) {
		return a == 1 ? 1 : inv(a - md % a) * (md / a + 1) % md;
	}
	void main() {
		int n = sc.nextInt();
		md = sc.nextInt();
		int[] p2 = new int[n];
		for (int p = 1, i = 0; i < n; i++) {
			p2[i] = p;
			p = p * 2 % md;
		}
		ff = new int[n + 1];
		gg = new int[n + 1];
		long f = 1;
		for (int i = 0; i <= n; i++) {
			gg[i] = (int) inv(ff[i] = (int) f);
			f = f * (i + 1) % md;
		}
		int[][] dp = new int[n + 1][n + 1]; dp[1][1] = 1; dp[2][2] = 2;
		for (int u = 3; u <= n; u++)
			for (int v = 1; v <= u; v++) {
				long x = v == u ? p2[u - 1] : 0;
				for (int k = 1; k < v && k <= u - 2; k++)
					x += dp[u - k - 1][v - k] * ch(v, k) % md * p2[k - 1] % md;
				dp[u][v] = (int) (x % md);
			}
		int ans = 0;
		for (int v = 1; v <= n; v++)
			ans = (ans + dp[n][v]) % md;
		println(ans);
	}
}
",1515_E,CODEFORCES,4139,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.IOException;
import java.util.StringTokenizer;
/*
 * @author Tnascimento 
 */

public class MaeDosDragoes {
	public static PrintWriter saida = new PrintWriter(System.out, false);
	public static class Escanear {
        BufferedReader reader;
        StringTokenizer tokenizer;
		public Escanear() {
            this(new InputStreamReader(System.in));
        }
		public Escanear(Reader in) {
            reader = new BufferedReader(in);
        }
        String proximo() {
            if (tokenizer == null || !tokenizer.hasMoreElements()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return tokenizer.nextToken();
        }
        
        int proximoNum() {
            return Integer.parseInt(proximo());
        }
    }
    public static void main(String[] args) {
		Escanear escanear = new Escanear();
		int proximoInt = escanear.proximoNum();
        long[] aux = new long[proximoInt];
        double proximoDouble = escanear.proximoNum();
        for(Integer i = 0; i < proximoInt; i++) {
            for(Integer j =0; j < proximoInt; j++) {
                Integer val = escanear.proximoNum();
                if (val.equals(1) || i.equals(j)) {
				 aux[i] |= 1L << j;
				}
            }
        }
        int esquerda = proximoInt/2;
        int direita = proximoInt - esquerda;
		int maiorMascara = 1 << esquerda;
		int[] depois = new int[1 << esquerda];
		Integer mascara = 1;
		while (mascara < maiorMascara) {
			int mascaraAtual = mascara;
            for(int j = 0; j < esquerda; j++) {
                if (((1 << j) & mascara) > 0) {
                    mascaraAtual &= aux[j + direita] >> direita;
                    depois[mascara] = Math.max(depois[mascara], depois[mascara ^ (1 << j)]);
                }
            }
            if (mascara.equals(mascaraAtual)) {
                depois[mascara] = Math.max(depois[mascara],Integer.bitCount(mascara));
			}
			mascara++;
		}
        int auxiliar = 0;
        int mascaraMaxima = 1 << direita;
        for(int i = 0; i < mascaraMaxima; i++) {
            int mascaraCorrente = i;
            int mascaraValor = maiorMascara -1;
            for(int j = 0; j < direita; j++) {
                if (((1 << j) & i) > 0) {
                    mascaraCorrente &= (aux[j] & (mascaraMaxima-1));
                    mascaraValor &= aux[j] >> direita;
                }
            }
            if (mascaraCorrente != i) continue;
            auxiliar = Math.max(auxiliar, Integer.bitCount(i) + depois[mascaraValor]);
        }
        proximoDouble/=auxiliar;
        saida.println(proximoDouble * proximoDouble * (auxiliar * (auxiliar-1))/2);
        saida.flush();
    }
}

",0839_E,CODEFORCES,4641,Mother of Dragons,"There are n castles in the Lannister's Kingdom and some walls connect two castles, no two castles are connected by more than one wall, no wall connects a castle to itself. 
Sir Jaime Lannister has discovered that Daenerys Targaryen is going to attack his kingdom soon. Therefore he wants to defend his kingdom. He has k liters of a strange liquid. He wants to distribute that liquid among the castles, so each castle may contain some liquid (possibly zero or non-integer number of liters). After that the stability of a wall is defined as follows: if the wall connects two castles a and b, and they contain x and y liters of that liquid, respectively, then the strength of that wall is x·y.
Your task is to print the maximum possible sum of stabilities of the walls that Sir Jaime Lannister can achieve.
The first line of the input contains two integers n and k (1 ≤ n ≤ 40, 1 ≤ k ≤ 1000).
Then n lines follows. The i-th of these lines contains n integers ai, 1, ai, 2, ..., ai, n (). If castles i and j are connected by a wall, then ai, j = 1. Otherwise it is equal to 0.
It is guaranteed that ai, j = aj, i and ai, i = 0 for all 1 ≤ i, j ≤ n.
Print the maximum possible sum of stabilities of the walls that Sir Jaime Lannister can achieve.
Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.
Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .
","input
In the first sample, we can assign 0.5, 0.5, 0 liters of liquid to castles 1, 2, 3, respectively, to get the maximum sum (0.25).
output
In the second sample, we can assign 1.0, 1.0, 1.0, 1.0 liters of liquid to castles 1, 2, 3, 4, respectively, to get the maximum sum (4.0)
","bruteforce, graphs, math, meet-in-the-middle",7
"import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.StringTokenizer;
import java.math.BigInteger;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author ffao
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Parser in = new Parser(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskA {
    int mod = 1000000009;

    public void solve(int testNumber, Parser in, OutputWriter out) {
        int n = in.nextInt();
        int m = in.nextInt();
        int k = in.nextInt();

        int o = m;
        m -= n - (n/k);
        if (m < 0) m = 0;

        long temp = n/k;
        long ans;
        if (m == 0) ans = 0;
        else {
            ans = (MathUtils.modpow(2, m+1, mod) + mod - 2) % mod;
            ans = (ans * k) % mod;
        }

        out.println((ans + (o - m*k)) % mod);
    }
}

class Parser
{
    private BufferedReader din;
    private StringTokenizer tokenizer;

    public Parser(InputStream in)
    {
        din = new BufferedReader(new InputStreamReader(in));
        tokenizer = null;
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(din.readLine());
            } catch (Exception e) {
                throw new UnknownError();
            }
        }
        return tokenizer.nextToken();
    }

    public int nextInt()
    {
        return Integer.parseInt(next());
    }

    }

class OutputWriter extends PrintWriter {
    public OutputWriter(Writer out) {
        super(out);
    }

    public OutputWriter(OutputStream out) {
        super(out);
    }

    }

class MathUtils {

    public static long modpow(int b, int e, int m) {
        if (e == 0) return 1%m;
        else if (e == 1) return b%m;

        long temp = modpow(b, e/2, m);
        temp = (temp * temp) % m;
        if (e % 2 == 1) temp = (temp * b) % m;

        return temp;
    }

    }
",0338_A,CODEFORCES,997,Quiz,"Manao is taking part in a quiz. The quiz consists of n consecutive questions. A correct answer gives one point to the player. The game also has a counter of consecutive correct answers. When the player answers a question correctly, the number on this counter increases by 1. If the player answers a question incorrectly, the counter is reset, that is, the number on it reduces to 0. If after an answer the counter reaches the number k, then it is reset, and the player's score is doubled. Note that in this case, first 1 point is added to the player's score, and then the total score is doubled. At the beginning of the game, both the player's score and the counter of consecutive correct answers are set to zero.
Manao remembers that he has answered exactly m questions correctly. But he does not remember the order in which the questions came. He's trying to figure out what his minimum score may be. Help him and compute the remainder of the corresponding number after division by 1000000009 (109 + 9).
The single line contains three space-separated integers n, m and k (2 ≤ k ≤ n ≤ 109; 0 ≤ m ≤ n).
Print a single integer — the remainder from division of Manao's minimum possible score in the quiz by 1000000009 (109 + 9).
Sample 1. Manao answered 3 questions out of 5, and his score would double for each two consecutive correct answers. If Manao had answered the first, third and fifth questions, he would have scored as much as 3 points.
","input
Sample 2. Now Manao answered 4 questions. The minimum possible score is obtained when the only wrong answer is to the question 4.
output
Also note that you are asked to minimize the score and not the remainder of the score modulo 1000000009. For example, if Manao could obtain either 2000000000 or 2000000020 points, the answer is 2000000000 mod 1000000009, even though 2000000020 mod 1000000009 is a smaller number.
","greedy, math, numbertheory",2
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;
import java.util.StringTokenizer;

import java.util.*;
import static java.lang.Math.*;

public class ProblemC {
	public static void main(String[] args) {
		FastScanner input = new FastScanner();
		int n = input.nextInt();
		int radius = input.nextInt();
		ArrayList<Integer> diskXToFall = new ArrayList<Integer>();
		for (int a = 0; a < n; a++) {
			diskXToFall.add(input.nextInt());
		}
		ArrayList<P> stationaryDisks = new ArrayList<P>();
		for (int a = 0; a < n; a++) {
			double highCollision = radius;
			for (P i : stationaryDisks) {
				if (Math.abs(diskXToFall.get(a) - i.x) - 1e-8 <= 2 * radius) {
					double hypot = 2 * radius;
					double leg = Math.abs(diskXToFall.get(a) - i.x);
					double yOffset = Math.sqrt(Math.abs(hypot * hypot - leg * leg));
					highCollision = Math.max(highCollision, yOffset + i.y);
				}
			}
			stationaryDisks.add(new P(diskXToFall.get(a), highCollision));
		}
		for(int a = 0; a < n; a++) {
			System.out.print(stationaryDisks.get(a).y + "" "");
		}
		

	}

	static class P implements Comparable<P> {
		final double x, y;

		P(double x, double y) {
			this.x = x;
			this.y = y;
		}

		P sub(P that) {
			return new P(x - that.x, y - that.y);
		}

		P add(P that) {
			return new P(x + that.x, y + that.y);
		}

		double dot(P that) {
			return x * that.x + y * that.y;
		}

		P scale(double s) {
			return new P(x * s, y * s);
		}

		// Use hypot() only if intermediate overflow must be avoided; very slow
		double length() {
			return sqrt(x * x + y * y);
		}

		double length2() {
			return x * x + y * y;
		}

		P leftNormal() {
			return new P(-y, x);
		} // rotateCCW(90deg)

		P rightNormal() {
			return new P(y, -x);
		} // rotateCW(90deg)

		P normalize() {
			double n = length();
			return n > 0 ? new P(x / n, y / n) : origin();
		}

		P scaleToLength(double l) {
			return normalize().scale(l);
		}

		P project(P a) {
			return scale(a.dot(this) / length2());
		}

		P reflect(P a) {
			return project(a).scale(2.0).sub(a);
		}

		// use if sin, cos are known
		P rotateCCW(double sinT, double cosT) {
			return new P(x * cosT - y * sinT, x * sinT + y * cosT);
		}

		P rotateCW(double sinT, double cosT) {
			return rotateCCW(-sinT, cosT);
		}

		P rotate(double theta) {
			return rotateCCW(sin(theta), cos(theta));
		}

		// angle to horizontal (1, 0); result is in [-pi, pi] rad or (-180-180) deg
		double theta() {
			return atan2(y, x);
		}

		// angle between two vectors, result is in [0, pi] rad (0-180 deg)
		double angleTo(P a) {
			return acos(this.dot(a) / this.length() / a.length());
		}

		boolean isOrigin() {
			return x == 0 && y == 0;
		}

		public String toString() {
			return String.format(""(%f,%f)"", this.x, this.y);
		}

		static P read(Scanner s) {
			return new P(s.nextDouble(), s.nextDouble());
		}

		static P origin() {
			return new P(0, 0);
		}

		double det(P that) {
			return this.x * that.y - this.y * that.x;
		}

		double crossproduct(P that) {
			return this.det(that);
		}

		P half(P q) {
			return normalize().add(q.normalize());
		}

		double dist(P to) {
			return sub(to).length();
		}

		double signedParallelogramArea(P b, P c) {
			return (b.sub(this).crossproduct(c.sub(this)));
		}

		boolean isCollinearWith(P b, P c) {
			return abs(signedParallelogramArea(b, c)) <= EPS;
		}

		// is going from this to b to c a CCW turn? Do not use if points may be
		// collinear
		boolean isCCW(P b, P c) {
			return signedParallelogramArea(b, c) > 0;
		}

		double signedTriangleArea(P b, P c) {
			return signedParallelogramArea(b, c) / 2.0;
		}

		// memory-optimized version of this.sub(to).length2() that avoids an
		// intermediate object
		double dist2(P to) {
			double dx = this.x - to.x;
			double dy = this.y - to.y;
			return dx * dx + dy * dy;
		}

		/**
		 * Compute x for a * x + b = 0 and ||x|| = C where 'this' is a. Care must be
		 * taken to handle the case where either a.x or a.y is near zero.
		 */
		P[] solveDotProductConstrainedByNorm(double b, double C) {
			P a = this;
			if (a.isOrigin())
				throw new Error(""degenerate case"");

			boolean transpose = abs(a.x) > abs(a.y);
			a = transpose ? new P(a.y, a.x) : a;

			Double[] x = solvequadratic(a.length2(), 2.0 * b * a.x, b * b - a.y * a.y * C * C);
			P[] p = new P[x.length];
			for (int i = 0; i < x.length; i++) {
				double x1 = x[i];
				double x2 = ((-b - a.x * x1) / a.y);
				p[i] = transpose ? new P(x2, x1) : new P(x1, x2);
			}
			return p;
		}

		@Override
		public int compareTo(P that) {
			if (abs(this.x - that.x) > EPS)
				return Double.compare(this.x, that.x);
			return Double.compare(this.y, that.y);
		}
	}

	static class HP extends P { // Hashable Point
		HP(double x, double y) {
			super(x, y);
		}

		@Override
		public int hashCode() {
			return Double.hashCode(x + 32768 * y);
		}

		@Override
		public boolean equals(Object _that) {
			HP that = (HP) _that;
			return this.x == that.x && this.y == that.y;
		}
	}

	/**
	 * Sort points by polar angle relative to center, using trig. This is a
	 * counter-clockwise sort with zero at 3 o'clock.
	 */
	static Comparator<P> makePolarAngleComparatorTrig(final P center) {
		return new Comparator<P>() {
			public int compare(P a, P b) {
				double thetaa = a.sub(center).theta();
				double thetab = b.sub(center).theta();
				if (thetaa < 0)
					thetaa += 2 * PI;
				if (thetab < 0)
					thetab += 2 * PI;
				int c = Double.compare(thetaa, thetab);
				if (c != 0)
					return c;
				return Double.compare(b.x, a.x); // arbitrary tie-breaker
			}
		};
	}

	/**
	 * Sort points by polar angle relative to center, w/o trig. This is a
	 * counter-clockwise sort with zero at 3 o'clock.
	 */
	static Comparator<P> makePolarAngleComparator(final P center) {
		return new Comparator<P>() {
			public int compare(P a, P b) {
				// orientation() requires that a and b lie in the same half-plane
				if (a.y >= center.y && b.y < center.y)
					return -1;
				if (b.y >= center.y && a.y < center.y)
					return 1;
				int orientation = (int) Math.signum(center.signedParallelogramArea(b, a));
				if (orientation != 0)
					return orientation;
				return Double.compare(b.x, a.x); // arbitrary tie-breaker
			}
		};
	}

	/*
	 * Solve a * x^2 + b * x + c == 0 Returns 0, 1, or 2 solutions. If 2 solutions
	 * x1, x2, guarantees that x1 < x2
	 */
	static Double[] solvequadratic(double a, double b, double c) {
		double D = b * b - 4 * a * c;
		if (D < -EPS)
			return new Double[] {};
		D = max(D, 0);
		if (D == 0)
			return new Double[] { -b / 2.0 / a };
		double d = sqrt(D);
		// Numerically more stable, see
		// XXXX
		if (signum(b) == 0)
			return new Double[] { d / 2.0 / a, -d / 2.0 / a };
		double x1 = (-b - signum(b) * d) / (2 * a);
		double x2 = c / (a * x1);
		return new Double[] { Math.min(x1, x2), Math.max(x1, x2) };
	}

	/*
	 * The Line/Circle classes provide a number of methods that require dealing with
	 * floating point precision issues. Default EPS to a suitable value, such as
	 * 1e-6, which should work for many problems in which the input coordinates are
	 * in integers and subsequently inexact floating point values are being
	 * computed.
	 */
	static double EPS = 1e-6;

	/*
	 * A line denoted by two points p and q. For internal computations, we use the
	 * parametric representation of the line as p + t d where d = q - p. For
	 * convenience, we compute and store d in the constructor. Most methods hide the
	 * parametric representation of the line, but it is exposed via
	 * getPointFromParameter and intersectionParameters for those problems that need
	 * it.
	 *
	 * The line may be interpreted either as a line segment denoted by the two end
	 * points, or as the infinite line determined by these two points. Intersection
	 * methods are provided for both cases.
	 */
	static class Line {
		P p, q, d;

		Line(P p, P q) {
			this.p = p;
			this.q = q;
			d = q.sub(p);
		}

		P getPointFromParameter(double t) {
			return p.add(d.scale(t));
		}

		// reflect vector across vector (as if line originated at (0, 0))
		P reflect(P d2) {
			return d.reflect(d2);
		}

		// reflect point across (infinite) line
		P reflectPoint(P r) {
			return reflect(r.sub(p)).add(p);
		}

		// project p onto this (infinite) line. Returns point on line
		P project(P a) {
			return p.add(d.project(a.sub(p)));
		}

		// return distance of point P from this (infinite) line.
		double distance(P a) {
			return project(a).dist(a);
		}

		@Override
		public String toString() {
			return String.format(""[%s => %s]"", p, q);
		}

		/*
		 * Point of intersection of this line segment with another line segment. Returns
		 * only points that lie inside both line segments, else null.
		 *
		 * Result may include points ""just outside"" the bounds, given EPS.
		 */
		P intersectsInBounds(Line l) {
			double[] st = intersectionParameters(l);
			if (st == null)
				return null;

			// check that point of intersection is in direction 'd'
			// and within segment bounds
			double s = st[0];
			double t = st[1];
			if (s >= -EPS && s <= 1 + EPS && -EPS <= t && t <= 1 + EPS)
				return getPointFromParameter(s);

			return null;
		}

		/*
		 * Point of intersection of this (infinite) line with other (infinite) line.
		 * Return null if collinear.
		 */
		P intersects(Line l) {
			double[] st = intersectionParameters(l);
			if (st != null)
				return getPointFromParameter(st[0]);
			return null;
		}

		/*
		 * Intersect this line with that line Solves: this.p + s * this.d == l.p + t l.d
		 * Return null if lines are collinear Else returns [s, t].
		 */
		double[] intersectionParameters(Line l) {
			P dneg = p.sub(q);
			double D = l.d.det(dneg);
			// Use Cramer's rule; see text
			if (D == 0.0)
				return null;

			P rp = p.sub(l.p);
			return new double[] { l.d.det(rp) / D, rp.det(dneg) / D };
		}

		/*
		 * Compute points of intersection of this infinite line with a circle. Computes
		 * projection 'x' of c.c onto line, then computes x +/- d.scaleToLength(h) where
		 * h is computed via Pythagoras. Sorted by decreasing 't' (as would be used in
		 * getPointFromParameter)
		 *
		 * May return two points even if line is a tangent.
		 */
		P[] intersectsCircle(Circle c) {
			P x = project(c.c);
			double D = x.dist(c.c);
			// outside by more than EPS
			if (D > c.R + EPS)
				return new P[0];
			double h = sqrt(max(0, c.R * c.R - D * D));
			if (h == 0)
				return new P[] { x }; // EPS (!?)
			return new P[] { x.add(d.scaleToLength(h)), x.add(d.scaleToLength(-h)) };
		}

		/*
		 * Compute points of intersection of this infinite line with a circle.
		 *
		 * Solves a + t * b = c + r subject to ||r|| = R Returns zero, one, or two
		 * points on the periphery, e.g. c + r[0,1], sorted by decreasing 't'.
		 * Alternative version which requires solving quadratic equation.
		 *
		 * Careful: set EPS if you need to handle round-off error in discriminant.
		 */
		P[] intersectsCircleAlternative(Circle c) {
			P ca = c.c.sub(p);
			P d = q.sub(p);
			Double[] t = solvequadratic(d.length2(), -2 * d.dot(ca), ca.length2() - c.R * c.R);
			P[] r = new P[t.length];
			for (int i = 0; i < t.length; i++)
				r[i] = p.add(d.scale(t[i]));
			return r;
		}

		/**
		 * Is r contained within the line segment spanned by p/q, including their
		 * endpoints?
		 */
		boolean isInBounds(P r) {
			return abs(p.dist(q) - p.dist(r) - q.dist(r)) <= EPS;
		}

		/**
		 * Is r on the infinite line?
		 */
		boolean isOnLine(P r) {
			return r.isCollinearWith(p, q);
		}
	}

	/**
	 * Alternative line implementation using the ""general form"" equation.
	 *
	 * a * x + b * y + c = 0
	 *
	 * This is provided for problems in which a line may be given in general form in
	 * the input. Compared to class Line, GLine: - is shorter, particularly when
	 * only line/line and line/circle intersections are required. - does not support
	 * those functions of Line that relate to LineSegment.
	 */
	static class GLine {
		// we represent a, b as a vector to benefit from the available dot/det routines.
		P n; // n = new P(a, b) --- this is the (right) normal vector to the line
		double c;

		GLine(double a, double b, double c) {
			this.n = new P(a, b);
			if (a == 0 && b == 0)
				throw new Error(""a and b cannot both be zero"");
			this.c = c;
		}

		GLine(P p, P q) {
			this(p.y - q.y, q.x - p.x, p.det(q));
		}

		P intersects(GLine that) {
			double D = n.det(that.n);
			if (D == 0.0)
				return null;
			return new P((this.n.y * that.c - that.n.y * this.c) / D, (that.n.x * this.c - this.n.x * that.c) / D);
		}

		double signedDistance(P p) {
			return (n.dot(p) + c) / n.length();
		}

		double distance(P p) {
			return abs(signedDistance(p));
		}

		// checks if on (infinite) line.
		boolean isOnLine(P p) {
			return signedDistance(p) <= EPS;
		}

		// checks if on the same side, no EPS
		boolean onSameSide(P p, P q) {
			return signum(signedDistance(p)) == signum(signedDistance(q));
		}

		// angle of inclination to horizontal; result is in [0, pi] rad
		// XXX untested
		double theta() {
			double angle = atan2(n.x, -n.y);
			return angle < 0 ? (angle + PI) : angle;
		}

		// XXX untested
		boolean parallelWith(GLine that) {
			return n.det(that.n) <= EPS;
		}

		// XXX untested
		boolean perpendicularTo(GLine that) {
			return n.dot(that.n) <= EPS;
		}

		// circle-line intersection, refactored from
		// XXXX
		P[] intersectsCircle(Circle C) {
			// shift line to center, this is undone by adding C.c before returning.
			double c = n.dot(C.c) + this.c;
			double n2 = n.length2();
			double r = C.R;

			P p = n.scale(-c / n2).add(C.c); // undo shift to center
			if (c * c > r * r * n2 + EPS) {
				return new P[] {};
			} else if (abs(c * c - r * r * n2) < EPS) {
				return new P[] { p };
			} else {
				double d = r * r - c * c / n2;
				double m = sqrt(d / n2);
				P q = n.rightNormal().scale(m);
				return new P[] { p.add(q), p.sub(q) };
			}
		}

		@Override
		public String toString() {
			return String.format(""Line:(n=%s C=%f)"", n, c);
		}
	}

	static class Circle {
		P c;
		double R;

		Circle(P c, double R) {
			this.c = c;
			this.R = R;
		}

		@Override
		public String toString() {
			return String.format(""{%s, %.03f}"", c, R);
		}

		/* Is this point inside the circle */
		boolean isInside(P p) {
			return R > p.dist(c) - EPS;
		}

		/* Is this point on the circle's periphery */
		boolean isOnCircle(P p) {
			return abs(p.dist(c) - R) <= EPS;
		}

		/*
		 * a line segment is outside a circle if both end points are outside and if any
		 * intersection points are outside the bounds of the line segment.
		 */
		boolean isOutside(Line l) {
			if (isInside(l.p) || isInside(l.q))
				return false;
			P[] _is = l.intersectsCircle(this);
			if (_is.length > 1)
				for (P is : _is)
					if (l.isInBounds(is))
						return false;
			return true;
		}

		/* Returns the tangent lines that the point p makes with this circle, if any. */
		Line[] tangentLines(P p) {
			// Let c +/- r be the tangent points. Then there's a 'd' such that
			// p + d - r = c
			// Since d r = 0, we multiply by r and get
			// (p - c) r - ||r|| = 0 subject to ||r|| = R
			P[] r = p.sub(c).solveDotProductConstrainedByNorm(-R * R, R);
			Line[] tangents = new Line[r.length];
			for (int i = 0; i < tangents.length; i++)
				tangents[i] = new Line(p, c.add(r[i]));
			return tangents;
		}

		/*
		 * Compute points of intersection of this circle (c1, r1) with that circle (c2,
		 * r2). Model as triangle equation m = c2 - c1 = r1 - r2 m = r1 - r2 -> m^2 =
		 * r1^2 + r2^2 - 2 r1 r2 (squaring) -> r1 r2 = (r1^2 + r2^2 - m^2)/2 and by
		 * multiplying by r1 we obtain m = r1 - r2 -> m r1 = r1^2 - r1 r2 -> m r1 = r1^2
		 * - (r1^2 + r2^2 - m^2)/2 -> m r1 + (r2^2 - r1^2 - m^2)/2 = 0 and ready for
		 * solveDotProductConstrainedByNorm
		 *
		 * Note that if the circles are (apprx) touching, this function may return 0, 1,
		 * or 2 intersection points, depending on which side of 0 the discriminant
		 * falls. You will not get NaN.
		 *
		 * If the circles coincidence (same center and radius) this will throw an
		 * 'degenerate case' error in solveDotProductConstrainedByNorm !!!
		 */
		P[] intersectsCircle(Circle that) {
			double r1 = this.R;
			double r2 = that.R;
			P m = that.c.sub(this.c);
			P[] r1sol = m.solveDotProductConstrainedByNorm((r2 * r2 - r1 * r1 - m.length2()) / 2, r1);
			// compute [c +/- r1] to obtain intersection points
			P[] is = new P[r1sol.length];
			for (int i = 0; i < r1sol.length; i++)
				is[i] = this.c.add(r1sol[i]);
			return is;
		}

		/*
		 * Shorter version of intersectsCircle that solves quadratic equation inline.
		 * Assumes there are 2 intersection points. The vector 'mid' is where the
		 * altitude of the triangle formed by the centers and the intersection point
		 * hits the line connecting the centers. Its length is e. midn is normal to it
		 * and its length is f.
		 */
		P[] intersectsCircleAlternative(Circle that) {
			P m = that.c.sub(this.c);
			double b = this.R * this.R;
			// div-by-zero if circles share center
			double e = (m.length2() + b - that.R * that.R) / 2 / m.length();
			double f = sqrt(b - e * e); // NaN if circles don't intersect
			P[] is = new P[2];
			P mid = this.c.add(m.scaleToLength(e));
			P midn = m.rightNormal();
			for (int i = 0; i < is.length; i++) {
				is[i] = mid.add(midn.scaleToLength(f));
				f *= -1;
			}
			return is;
		}

		// returns true if this circle is outside that circle
		boolean isOutside(Circle that) {
			return this.c.dist(that.c) > (this.R + that.R);
		}

		// returns true if this circle is entirely contained inside that circle
		boolean isContainedIn(Circle that) {
			// extend line from that.c to this.c by radius R
			P m = this.c.sub(that.c);
			return that.isInside(this.c.add(m.scaleToLength(this.R)));
		}

		/* Construct smallest circle that circumscribes 2 points a and b. */
		static Circle getCircumCircle(P a, P b) {
			P c = a.add(b).scale(.5);
			return new Circle(c, c.dist(a));
		}

		/* Construct circle circumscribed by 3 points a, b, c */
		static Circle getCircumCircle(P a, P b, P c) {
			P B = b.sub(a);
			P C = c.sub(a);
			double d = 2 * B.crossproduct(C);
			if (abs(d) < EPS) // points are collinear
				return getCircumCircle(new P(min(a.x, min(b.x, c.x)), min(a.y, min(b.y, c.y))),
						new P(max(a.x, max(b.x, c.x)), max(a.y, max(b.y, c.y))));

			double z1 = B.length2();
			double z2 = C.length2();
			P cc = new P(C.y * z1 - B.y * z2, B.x * z2 - C.x * z1).scale(1.0 / d);
			return new Circle(cc.add(a), cc.length());
		}

		/*
		 * Find minimum enclosing circle for a set of points. Peter, we need a source
		 * for this algorithm and its expected complexity.
		 */
		static Circle minEnclosingCircle(P[] p) {
			if (p.length == 0)
				return new Circle(new P(0, 0), 0);
			if (p.length == 1)
				return new Circle(p[0], 0);
			Collections.shuffle(Arrays.asList(p));
			Circle circle = getCircumCircle(p[0], p[1]);
			for (int i = 2; i < p.length; i++) {
				if (!circle.isInside(p[i])) {
					circle = getCircumCircle(p[0], p[i]);
					for (int j = 1; j < i; j++) {
						if (!circle.isInside(p[j])) {
							circle = getCircumCircle(p[j], p[i]);
							for (int k = 0; k < j; k++) {
								if (!circle.isInside(p[k])) {
									circle = getCircumCircle(p[i], p[j], p[k]);
								}
							}
						}
					}
				}
			}
			return circle;
		}
	}

	/**
	 * Some basic operations on Polygons.
	 */
	static class Polygon {
		P[] p; // open form, p[0] connects to p[n-1]

		// Constructors clone original array/collection
		Polygon(Collection<P> c) {
			this.p = c.toArray(new P[c.size()]);
		}

		Polygon(P[] p) {
			this.p = (P[]) p.clone();
		}

		/* Absolute of signed triangle areas */
		double signedArea() {
			double area = 0.0;
			for (int i = 0; i < p.length; i++) {
				area += p[i].det(p[(i + 1) % p.length]);
			}
			return area / 2.0;
		}

		double absoluteArea() {
			return abs(signedArea());
		}

		/*
		 * Returns an P[] array representing an open shape that is the convex hull of
		 * the given array of points, or null if less than 2 points were given.
		 */
		public Polygon convexHull() {
			if (p.length < 2)
				return null;

			// (0) find the lowest point, breaking ties to the right
			final P min = Collections.min(Arrays.asList(p), new Comparator<P>() {
				public int compare(P p1, P p2) {
					int y = Double.valueOf(p1.y).compareTo(p2.y);
					return y != 0 ? y : Double.valueOf(p1.x).compareTo(p2.x);
				}
			});

			// (1) sort points by angle from pivot
			Arrays.sort(p, new Comparator<P>() {
				public int compare(P p1, P p2) {
					double o = min.signedParallelogramArea(p1, p2); // crossproduct
					if (o != 0)
						return -(int) Math.signum(o);

					// if collinear, use distance to break tie
					return Double.valueOf(min.dist(p1)).compareTo(min.dist(p2));
				}
			});

			// (3) create stack
			Stack<P> hull = new Stack<P>();
			assert p[0] == min;
			hull.push(p[0]);
			hull.push(p[1]);

			// (4) select points that maintain left turns
			for (int i = 2; i < p.length; i++) {
				P next = p[i];
				while (hull.size() >= 2) {
					P snd = hull.get(hull.size() - 2);
					P top = hull.peek();
					if (snd.isCCW(top, next)) // keep
						break;

					hull.pop(); // discard
				}
				// keep current point
				hull.push(next);
			}
			return new Polygon(hull);
		}

		/*
		 * ""Point-in-Polygon"" PIP tests. Return true if point is contained in this
		 * polygon
		 *
		 * All of these tests may return 0 or 1 for points on the boundary. A separate
		 * test is required to determine if a point is on the boundary.
		 */
		public boolean contains(P q) {
			return contains_WN(q);
		}

		/*
		 * Crossing-number based algorith due to Wm. Randolph Franklin. Works only for
		 * simple polygons.
		 */
		private boolean contains_CN(P q) {
			boolean c = false;
			for (int i = 0, j = p.length - 1; i < p.length; j = i++) {
				if ((((p[i].y <= q.y) && (q.y < p[j].y)) || ((p[j].y <= q.y) && (q.y < p[i].y)))
						&& (q.x < (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y) + p[i].x))
					c = !c;
			}
			return c;
		}

		/*
		 * Winding numbers based algorithm, which also works for self-intersecting
		 * polygons. XXXX describes this as the
		 * always preferred algorithm.
		 *
		 * Return: wn = the winding number (=0 only when P is outside)
		 */
		public boolean contains_WN(P q) {
			int wn = 0; // the winding number counter

			// loop through all edges of the polygon
			int n = p.length;
			for (int i = 0; i < n; i++) { // edge from V[i] to V[i+1]
				P p = this.p[i], pn = this.p[(i + 1) % n];
				if (p.y <= q.y) { // start y <= P.y
					if (pn.y > q.y) // an upward crossing
						if (p.isCCW(pn, q)) // P left of edge
							++wn; // have a valid up intersect
				} else { // start y > P.y (no test needed)
					if (pn.y <= q.y) // a downward crossing
						if (!p.isCCW(pn, q)) // P right of edge
							--wn; // have a valid down intersect
				}
			}
			return wn != 0;
		}

		/**
		 * Is q on the boundary of this polygon?
		 */
		public boolean onBoundary(P q) {
			int n = p.length;
			for (int i = 0; i < n; i++) {
				P pi = this.p[i], pj = this.p[(i + 1) % n];
				if (new Line(pi, pj).isInBounds(q))
					return true;
			}
			return false;
		}

		@Override
		public String toString() {
			return Arrays.toString(p);
		}
	}

	public static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(Reader in) {
			br = new BufferedReader(in);
		}

		public FastScanner() {
			this(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String readNextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}

		int[] readIntArray(int n) {
			int[] a = new int[n];
			for (int idx = 0; idx < n; idx++) {
				a[idx] = nextInt();
			}
			return a;
		}

		long[] readLongArray(int n) {
			long[] a = new long[n];
			for (int idx = 0; idx < n; idx++) {
				a[idx] = nextLong();
			}
			return a;
		}
	}
}
",0908_C,CODEFORCES,2946,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"import java.util.Arrays;
import java.util.Scanner;

public class E {
    static double[] dp;
    static int[] oneCount;
    static int end;
    static int n;
    static double[][] prob;
    public static double solve(int mask) {
        if(mask==end) return 1;
        int oneC=0,zeroC=0;
        for(int i=0;i<n;i++) {
            if((mask|(1<<i))==mask) oneC++;
            else zeroC++;
        }
        double res=0;
        for(int i=0;i<n;i++) {
            if((mask|(1<<i))!=mask) continue;
            for(int j=0;j<n;j++) {
                //
                if((mask|(1<<j))==mask) continue;
                //System.out.println(i+"" ""+j+"" ""+prob[i][j]+"" ""+Integer.toBinaryString(mask)+"" ""+oneC+"" ""+zeroC);
                res+=(1.0/((oneC*(oneC+1))/2))*prob[i][j]*solve(mask|(1<<j));
            }
        }
        return dp[mask]=res;
    }
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        n=sc.nextInt();
        prob=new double[n][n];
        for(int i=0;i<n;i++) 
            for(int j=0;j<n;j++)
                prob[i][j]=sc.nextDouble();
        dp=new double[1<<n];
        oneCount=new int[1<<n];
        int c;
        for(int i=0;i<dp.length;i++) {
            c=0;
            for(int j=0;j<n;j++) {
                if((i|(1<<j))==i) c++;
            }
            oneCount[i]=c;
        }
        end=(1<<n)-1;
        double res,rad;
        int count;
        for(int k=end;k>0;k--) {
            if(k==end) dp[k]=1;
            else {
                res=0;
                count=oneCount[k];
                count=count*(count+1);
                count>>=1;
                rad=1.0/count;
                //System.out.println(rad+"" ""+count);
                for(int i=0;i<n;i++) {
                    if((k|(1<<i))!=k) continue;
                    for(int j=0;j<n;j++) {
                        //
                        if((k|(1<<j))==k) continue;
                        //System.out.println(i+"" ""+j+"" ""+prob[i][j]+"" ""+Integer.toBinaryString(mask)+"" ""+oneC+"" ""+zeroC);
                        res+=rad*prob[i][j]*dp[k|(1<<j)];
                    }
                }
                dp[k]=res;
            }
        }
        //Arrays.fill(dp, -1);
        for(int i=0;i<n;i++)
            System.out.print(dp[1<<i]+"" "");
            //System.out.print(solve(1<<i)+"" "");
//      for(int i=0;i<18;i++){
//          for(int k=0;k<18;k++)
//              System.out.print(Math.random()+"" "");
//          System.out.println();
//      }
    }
}",0016_E,CODEFORCES,4507,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"import java.io.OutputStream;

import java.io.IOException;

import java.io.InputStream;

import java.io.PrintWriter;

import java.io.PrintStream;

import java.util.StringTokenizer;

import java.io.IOException;

import java.io.BufferedReader;

import java.io.InputStreamReader;

import java.io.InputStream;



/**

 * Built using CHelper plug-in

 * Actual solution is at the top

 *

 * @author Wolfgang Beyer

 */

public class Main {

    public static void main(String[] args) {

        InputStream inputStream = System.in;

        OutputStream outputStream = System.out;

        InputReader in = new InputReader(inputStream);

        PrintWriter out = new PrintWriter(outputStream);

        TaskC solver = new TaskC();

        solver.solve(1, in, out);

        out.close();

    }



    static class TaskC {

        public void solve(int testNumber, InputReader in, PrintWriter out) {

            long n = in.nextLong();

            long s = in.nextLong();



            if (n - digitSum(n) < s) {

                out.println(0);

                return;

            }



            long left = 0;

            long right = n;

            while (left < right) {

                long mid = left + (right - left) / 2;

                if (mid - digitSum(mid) >= s) { // if condition(mid) == true

                    right = mid;

                } else {

                    left = mid + 1;

                }

            }

            out.println(n - left + 1);

        }



        long digitSum(long a) {

            long result = 0;

            while (a > 0) {

                result += a % 10;

                a /= 10;

            }

            return result;

        }



    }



    static class InputReader {

        private static BufferedReader in;

        private static StringTokenizer tok;



        public InputReader(InputStream in) {

            this.in = new BufferedReader(new InputStreamReader(in));

        }



        public long nextLong() {

            return Long.parseLong(next());

        }



        public String next() {

            try {

                while (tok == null || !tok.hasMoreTokens()) {

                    tok = new StringTokenizer(in.readLine());

                    //tok = new StringTokenizer(in.readLine(), "", \t\n\r\f""); //adds commas as delimeter

                }

            } catch (IOException ex) {

                System.err.println(""An IOException was caught :"" + ex.getMessage());

            }

            return tok.nextToken();

        }



    }

}



",0817_C,CODEFORCES,1065,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class pre426
{
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
    public static void main(String args[])
    {
        FastReader obj = new FastReader();
        long a = obj.nextLong(),b = obj.nextLong();
        String as = Long.toBinaryString(a),bs = Long.toBinaryString(b);
        while(as.length()<bs.length()) as = '0'+as;
        while(bs.length()<as.length()) bs = '0'+bs;
        String s = ""0"";
        boolean flag = false;
        for(int i=0;i<as.length();i++)
        {
            if(flag) s = s+'1';
            else if(as.charAt(i)!=bs.charAt(i) && !flag)
            {
                s = s+'1';
                flag = true;
            }
        }
        long l = Long.parseLong(s,2);
        System.out.println(l);
    }
}
",0276_D,CODEFORCES,798,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import java.util.Scanner;

public class TrickyAlchemy {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		long sum=0;
		long yc=sc.nextInt();
		long bc=sc.nextInt();
		long y=sc.nextInt();
		long g=sc.nextInt();
		long b=sc.nextInt();
		long m=2*y+g;
		long n=g+3*b;
		if(yc<m)
			sum=sum+(m-yc);
		if(bc<n)
			sum=sum+(n-bc);
		System.out.println(Math.abs(sum));
		sc.close();

	}

}
",0912_A,CODEFORCES,592,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation,1
"import java.util.*;

public class Paint {
    public static void main (String srgs[] ){
        
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        TreeSet<Integer> ts=new TreeSet<>();
        for(int i=0;i<n;++i){
            ts.add(sc.nextInt());
        }
        int x=0;
        int a[]=new int[ts.size()];
        for(int y:ts){
            a[x++]=y;
        }
        for(int i=0;i<ts.size()-1;++i){
            for(int j=i+1;j<ts.size();++j){
                if((a[i]!=-1)&&(a[j]!=-1)&&(a[j]%a[i]==0)){
                    a[j]=-1;
                }
            }
        }
        int c=0;
        for(int z:a){
            if(z!=-1)++c;
        }
        System.out.print(c);
    }
}",1209_A,CODEFORCES,3551,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"import java.io.IOException;
import java.util.Locale;
import java.util.Scanner;

public class A {

    public void processInput() throws IOException {
        Scanner in = new Scanner(System.in);

        long n = in.nextLong();
        long res = go(n);

        System.out.printf(Locale.ENGLISH, ""%d\n"", res);

        in.close();
    }

    public long go(long n) {

        long res = n;

        String str = String.valueOf(n);
        
        StringBuilder sb = new StringBuilder(str);
        sb.deleteCharAt(str.length() - 1);
        if (sb.length() > 0 && !sb.toString().equals(""-"")) {
            res = Math.max(res, Long.valueOf(sb.toString()));
        }
        
        if (str.length() > 1) {
            if (str.charAt(str.length() - 2) != '-') {
                sb = new StringBuilder(str);
                sb.deleteCharAt(str.length() - 2);
                res = Math.max(res, Long.valueOf(sb.toString()));
            }
        }
        
        return res;
    }

    public static void main(String[] args) throws Exception {
        A a = new A();
        a.processInput();
    }
}",0313_A,CODEFORCES,315,Ilya and Bank Account,"Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.
Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.
Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.
The single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.
In a single line print an integer — the maximum state of the bank account that Ilya can get. 
","input
In the first test sample Ilya doesn't profit from using the present.
output
In the second test sample you can delete digit 1 and get the state of the account equal to 0.
","implementation, numbertheory",1
"import java.io.*;
import java.util.*;

public class Main {
	public static void main (String[] args) throws IOException {
		BufferedReader reader = new BufferedReader (new InputStreamReader (System.in));
		String[] splitted = reader.readLine().split("" "");
		int n = Integer.parseInt(splitted[0]);
		int m = Integer.parseInt(splitted[1]);
		int k = Integer.parseInt(splitted[2]);
		PriorityQueue<Integer> queue = new PriorityQueue<Integer> (1000, Collections.reverseOrder());
		splitted = reader.readLine().split("" "");
		for (int ii = 0; ii < splitted.length; ii++) {
			queue.add(Integer.parseInt(splitted[ii]));
		}
		
		int counter = 0;
		int spot = k;
		while (spot < m && !queue.isEmpty()) {
			spot = spot + queue.poll() - 1;
			counter++;
		}
		if (spot < m) {
			System.out.println(""-1"");
		} else {
			System.out.println(counter);
		}
	}
}",0257_A,CODEFORCES,2680,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings",4
"import java.util.*;

public class p343A 
{
    static long n = 0;
    static void resistance(long a, long b) 
    {
        n += a/b;
        a %= b;
        if(a!=0) resistance(b, a);
    }
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        long a = in.nextLong();
        long b = in.nextLong();
        resistance(a, b);
        System.out.println(n);
    }
}",0343_A,CODEFORCES,406,Rational Resistance,"Mad scientist Mike is building a time machine in his spare time. To finish the work, he needs a resistor with a certain resistance value.
However, all Mike has is lots of identical resistors with unit resistance R0 = 1. Elements with other resistance can be constructed from these resistors. In this problem, we will consider the following as elements: 
With the consecutive connection the resistance of the new element equals R = Re + R0. With the parallel connection the resistance of the new element equals . In this case Re equals the resistance of the element being connected.
Mike needs to assemble an element with a resistance equal to the fraction . Determine the smallest possible number of resistors he needs to make such an element.
The single input line contains two space-separated integers a and b (1 ≤ a, b ≤ 1018). It is guaranteed that the fraction  is irreducible. It is guaranteed that a solution always exists.
Print a single number — the answer to the problem.
Please do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.
","input
In the first sample, one resistor is enough.
output
In the second sample one can connect the resistors in parallel, take the resulting element and connect it to a third resistor consecutively. Then, we get an element with resistance . We cannot make this element using two resistors.
","math, numbertheory",1
"import java.io.*;
import java.util.*;

public class Codeforces {
    public static void main(String[] args) throws IOException {
        //long start = System.currentTimeMillis();

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        long n = Long.parseLong(st.nextToken());
        int maxSize = Integer.parseInt(st.nextToken());

        maxSize = (int) Math.min(n, maxSize);

        pw.println(solve(n, maxSize));
        //System.out.println(""time: "" + (System.currentTimeMillis() - start));
        pw.close();
    }

    private static int solve(long n, int maxSize) {
        if (n == 1) {
            return 0;
        }

        int i = getLargestSequence(n, maxSize);

        if (i == -1) {
            return -1;
        }

        long numPipes = getSummation(maxSize, i);

        maxSize -= i;

        /*
        maxSize = 10
        numPipes = 517
        n = 525

        find the largest number i where 517 + i - 1 <= 525
        i is at most maxSize
        so 517 + (i + 1) <= 525 is false
        and 517 + (i - 1) <= 525 is true

        TTTTT>T<FFFFFF
        TTT -> go right
        TTF -> bingo
        TFF -> go left
        FFF -> go left
         */
        while (numPipes != n && maxSize > 1) {
            int l = 2;
            int r = maxSize;
            while (l <= r) {
                int m = l + (r - l) / 2;

                boolean okLeft = numPipes + (m - 2) <= n;
                boolean okMid = numPipes + (m - 1) <= n;
                boolean okRight = numPipes + (m) <= n;

                if (okLeft && okMid && !okRight) {
                    maxSize = m;
                    break;
                }

                if (okLeft && okMid) {
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }

            numPipes += maxSize - 1;
            maxSize--;

            i++;
        }

        return i;
    }

    private static int getLargestSequence(long n, int maxSize) {
        int l = 1;
        int r = maxSize - 1;
        while (l <= r) {
            int m = l + (r - l) / 2;

            long left = getSummation(maxSize, m + 1);
            long mid = getSummation(maxSize, m);

            if (left == n) {
                return m + 1;
            } else if (mid == n) {
                return m;
            }

            if (left > n && mid < n) {
                return m;
            }

            if (left < n && mid < n) {
                l = m + 1;
            } else {
                r = m - 1;
            }

            // we want left > n
            // we want mid to be the greatest it can be without exceeding n
            // TTTTFFFF
            // 00 - go l
            // 10 - bingo
            // 11 - go r
            // 11 -  go r
        }

        return -1;
    }

    // Returns the sum of the last k terms of the sequence
    // 2, 3, ... maxSize - 2, maxSize - 1, maxSize
    private static long getSummation(int maxSize, long k) {
        return k * (maxSize - k + 1 + maxSize) / 2 - (k - 1);
    }
}
",0287_B,CODEFORCES,951,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.util.Scanner;

import java.util.regex.Pattern;

import java.util.regex.PatternSyntaxException;



public class Main {

	public static void main(String[] args) {

		Scanner s = new Scanner(System.in);

		

		int n = s.nextInt();

		

		for(int i = 0; i < n; i++){

			String in = s.next();

			if(in.matches(""^R\\d+C\\d+"")){

				//rc

				String a[] = in.split(""C"");

				int r = Integer.parseInt(a[1]);

				String ans = """";

				while(r > 0){

					r--;

					char c = (char) ('A'+(r%26)-1);

					r /= 26;

					if(c == 'Z'){

						c = 'A';

					} else {

						c++;

					}

					ans = c+ans;

				}

				ans += a[0].substring(1);

				System.out.println(ans);

			} else {

				//ab

				String chars = """";

				String nums = """";

				for(int j = 0; j < in.length(); j++){

					if(Character.isDigit(in.charAt(j))){

						nums += in.charAt(j);

					} else {

						chars += in.charAt(j);

					}

				}

				String ans = ""R""+nums+""C"";

				

				int r = 0;

				for(int j = 0; j <  chars.length(); j++){

					r = r*26+chars.charAt(j)-'A'+1;

				}

				System.out.println(ans+r);

				

			}

			

		}

		

	}

}

",0001_B,CODEFORCES,1469,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math",3
"import java.io.*;
import java.util.*;

public class a implements Runnable {

	private void solve() throws IOException {
		int n = nextInt();
		int oddcnt = 0, evencnt = 0;
		int odd = 0, even = 0;
		for (int i = 0; i < n; i++) {
			int a = nextInt();
			if (a % 2 == 0) {
				even = i + 1;
				evencnt++;
			} else {
				odd = i + 1;
				oddcnt++;
			}
		}
		if (oddcnt == 1) {
			System.out.println(odd);
		} else {
			System.out.println(even);
		}
	}

	public static void main(String[] args) {
		new Thread(new a()).start();
	}

	BufferedReader br;
	StringTokenizer st;
	PrintWriter out;
	boolean eof = false;

	public void run() {
		Locale.setDefault(Locale.US);
		try {
			br = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			solve();
			out.close();
		} catch (Throwable e) {
			e.printStackTrace();
			System.exit(239);
		}
	}

	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return ""0"";
			}
		}
		return st.nextToken();
	}

	int nextInt() {
		return Integer.parseInt(nextToken());
	}

	long nextLong() {
		return Long.parseLong(nextToken());
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}
}",0025_A,CODEFORCES,1551,IQ test,"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given n numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given n numbers finds one that is different in evenness.
","input
The first line contains integer n (3 ≤ n ≤ 100) — amount of numbers in the task. The second line contains n space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.
output
Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.
",bruteforce,3
"import java.awt.List;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;
import java.util.StringTokenizer;


public class main {
	
	static long d,x,y;
	public static void main(String[] args) {
		FastScanner in = new FastScanner();
	    
		long x = in.nextLong(), k = in.nextLong();
		
		long mod = 1000000007;
		
		long one = pow(2,k,mod);
		
		one %= mod;
		
		long two = (2*x)%mod-1;
		
		two %= mod;
		
		long ans = (one*two)%mod+1;
		
		ans %= mod;
		
		if(ans<0)
			ans += mod;
		
		if(x==0)
			System.out.println(""0"");
		else
			System.out.println(ans);
	        
	}
	private static long pow(long a, long b, long mod) {
		if(b==0) return 1;
		
		if(b==1)
			return a;
		
		if(b%2==0)
			return pow((a*a)%mod,b/2,mod);
		else
			return (a*pow((a*a)%mod,(b-1)/2,mod))%mod;
		
	}
	
	

	

}










class FastScanner {
	BufferedReader br;
	StringTokenizer st;
	
	public FastScanner() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}
	
	String next() {
		while (st == null || !st.hasMoreElements()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return st.nextToken();
	}
	
	int nextInt() {
		return Integer.parseInt(next());
	}
	
	long nextLong() {
		return Long.parseLong(next());
	}
}
",0992_C,CODEFORCES,1209,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

public class Main {
	int work(int x){
		if(x%2==0)return x+1;
		else return x-1;
	}
	static int N = 200050;
	class Node implements Comparable <Node>{
		int x, id;
		Node(int x, int id){
			this.x = x; this.id = id;
		}
		public int compareTo(Node o){
			return Integer.compare(x, o.x);
		}
		public String toString(){
			return id + ""="" + x;
		}
	}
	class Edge{
		int from, to, nex;
		Edge (int from, int to, int nex){
			this.from = from;
			this.to = to;
			this.nex = nex;
		}
	}
	Edge[] edge = new Edge[N*10];
	int[] head = new int[N];
	int edgenum;  
	void addedge(int u, int v){  
	    Edge E = new Edge(u, v, head[u]);  
	    edge[edgenum] = E;  
	    head[u] = edgenum ++;  
	}  
	
	int n;
	int[] p = new int[N], ans = new int[N];
	int a, b, max;
    Map<Integer, Integer> map = new HashMap();
    boolean match(int x, int y, int col){
    	int P = map.get(x);
    	if(map.containsKey(y-x) == false)
    		return false;
    	int Q = map.get(y - x);
    	if(ans[Q] == -1 || x * 2 == y){
    		ans[Q] = ans[P] = col;
    	}
    	else {
    		if(match(a+b-2*y+x, y, col))
    			ans[Q] = ans[P] = col; 		
    		else return false;
    	}
    	return true;
    }
    boolean solve(){
    	if(max >= a && max >= b)return false;
    	for(int i = 1; i <= n; i++)
    		if(ans[i] == -1)
    		{
    			if(match(p[i], a, 0)==false && match(p[i], b, 1) == false)
    				return false;
    		}    	
    	return true;
    }
	void init(){
		n = cin.nextInt();
		a = cin.nextInt(); b = cin.nextInt();
		max = 0;
		for(int i = 1; i <= n; i++){
			ans[i] = -1;
			p[i] = cin.nextInt();
			map.put(p[i], i);
			if(p[i] > max) max = p[i];
		}
	}
	public void work(){
		init();
		if(solve()){
			out.println(""YES"");
			for(int i = 1; i <= n; i++)out.print(ans[i]+"" ""); out.println();
		}
		else 
			out.println(""NO"");
	}
	Main() {
        cin = new Scanner(System.in);  
        out = new PrintWriter(System.out);
    }  
    public static void main(String[] args) {
        Main e = new Main();  
        e.work();
        out.close();
    }
    public Scanner cin;
    public static PrintWriter out;
}
/*
http://blog.csdn.net/keshuai19940722/article/details/39528801

*/",0468_B,CODEFORCES,1737,Two Sets,"Little X has n distinct integers: p1, p2, ..., pn. He wants to divide all of them into two sets A and B. The following two conditions must be satisfied:
Help Little X divide the numbers into two sets or determine that it's impossible.
The first line contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The next line contains n space-separated distinct integers p1, p2, ..., pn (1 ≤ pi ≤ 109).
If there is a way to divide the numbers into two sets, then print ""YES"" in the first line. Then print n integers: b1, b2, ..., bn (bi equals either 0, or 1), describing the division. If bi equals to 0, then pi belongs to set A, otherwise it belongs to set B.
","input
If it's impossible, print ""NO"" (without the quotes).
output
It's OK if all the numbers are in the same set, and the other one is empty.
","2-sat, dfsandsimilar, dsu, graphmatchings, greedy",3
"
import java.io.*;
import java.util.*;

public class CottageVillage
{
	public Scanner in = new Scanner(System.in);
	public PrintStream out = System.out;

	public int n, t;
	public Pair[] v;
	
	public void main()
	{
		n = in.nextInt();
		t = in.nextInt();
		
		int i;
		v = new Pair[n];
		for(i=0;i<n;++i) v[i] = new Pair(in.nextInt() * 2, in.nextInt());
		
		Arrays.sort(v);
		
		int res = 2;
		for(i=0;i+1<n;++i)
		{
			if(v[i].x + v[i].y + 2*t == v[i+1].x - v[i+1].y) ++res;
			else if(v[i].x+v[i].y+2*t < v[i+1].x-v[i+1].y) res +=2;
		}
		
		out.println(res);
	}//end public void main()

	//int pair
	private class Pair implements Comparable<Pair>
	{
		public int x, y;
		public Pair(int xx, int yy) { x = xx; y = yy; }

		public int compareTo(Pair u)
		{
			if(x!=u.x) return x-u.x;
			return y-u.y;
		}

		public String toString() { return ""("" + x + "","" + y + "")""; }
	}
	
	public static void main(String[] args)
	{
		(new CottageVillage()).main();
	}
}",0015_A,CODEFORCES,2294,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"
import java.io.*;
import java.util.InputMismatchException;

public class CF278 {

    static String filePath = ""/home/bishoy/IdeaProjects/Arabic competetive programming/src/a/test"";

    public static void main(String args[]) {
        InputReader inputReader = Helper.readInput(Helper.Input.STD, filePath);
        OutputWriter out = new OutputWriter(System.out);
        long n = inputReader.readLong();
        long k = inputReader.readLong();

        if (n == 1)
            out.printLine(0);
        else if (n <= k)
            out.printLine(1);
        else {
            n--;
            k--;
            if (sum(k) < n)
                out.printLine(-1);
            else {
                out.printLine(countSplitters(k, n));
            }
        }
        out.flush();
        out.close();
    }

    private static long countSplitters(long k, long n) {
        long start = 1, end = k;
        while (start < end) {
            long mid = (start + end) / 2;

            long sum = sum(mid, k);

            if (sum == n)
                return k - mid + 1;
            if (sum > n) {
                start = mid + 1;
            } else {
                end = mid;
            }

        }

        return k - start + 2;

    }

    static long sum(long s) {
        return s * (s + 1) / 2;
    }

    static long sum(long s, long e) {
        if (s <= 1)
            return sum(e);
        else
            return sum(e) - sum(s - 1);
    }


    static class Helper {
        static InputReader inputReader = null;
        static OutputWriter out = null;

        public static enum Input {
            FILE, STD
        }

        public static class Pair<K, V> {
            public K key;
            public V value;

            public Pair(K key, V value) {
                this.key = key;
                this.value = value;
            }


            @Override
            public String toString() {
                return ""( "" + key + "" , "" + value + "")"";
            }
        }


        public static InputReader readInput(Enum type, String filePath) {
            if (type == Input.FILE) {
                try {
                    inputReader = new InputReader(new FileInputStream(new File(filePath)));
                } catch (FileNotFoundException e) {
                    e.printStackTrace();
                }
            } else
                inputReader = new InputReader(System.in);


            return inputReader;
        }


        public static boolean validIndices(int r, int c, int n, int m) {
            if (r >= 0 && c >= 0 && r < n && c < m) return true;
            else return false;
        }
    }

    private static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }


        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public double readDouble() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E') {
                    return res * Math.pow(10, readInt());
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E') {
                        return res * Math.pow(10, readInt());
                    }
                    if (c < '0' || c > '9') {
                        throw new InputMismatchException();
                    }
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public long readLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }

    private static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
            writer.flush();
        }

        public void printLine(Object... objects) {
            print(objects);
            writer.println();
            writer.flush();
        }

        public void close() {
            writer.close();
        }

        public void flush() {
            writer.flush();
        }
    }
}",0287_B,CODEFORCES,945,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class RespectTheRules {
    private static final double E = 1E-10;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double a = scanner.nextDouble();
        double maxV = scanner.nextDouble();
        double l = scanner.nextDouble();
        double d = scanner.nextDouble();
        double w = scanner.nextDouble();

        double r = l - d;
        w = Math.min(w, maxV);

        List<WayPoint> wayPoints = new ArrayList<WayPoint>(256);
        double t = 0;

        wayPoints.add(new WayPoint(0));

        double dW = dTo(w, 0, a);
        if (leq(dW, d)) {
            wayPoints.add(new WayPoint(w));
            {
                double v = v(w, a, (d - dW) / 2);
                v = Math.min(v, maxV);

                wayPoints.add(new WayPoint(v));
                wayPoints.add(new WayPoint(w));

                double dW_V = dTo(v, w, a);
                double vDistance = d - dW - 2 * dW_V;
                if (!eq(vDistance)) {
                    t += vDistance / maxV;
                }
            }
            {
                double dW_MaxV = dTo(maxV, w, a);
                dW_MaxV = Math.min(dW_MaxV, r);
                double v = v(w, a, dW_MaxV);
                wayPoints.add(new WayPoint(v));
                double dMaxV = r - dW_MaxV;
                if (!eq(dMaxV)) {
                    t += dMaxV / maxV;
                }
            }

        } else {
            double dMaxV = dTo(maxV, 0, a);
            dMaxV = Math.min(dMaxV, l);
            double v = v(0, a, dMaxV);
            wayPoints.add(new WayPoint(v));
            double dv = l - dMaxV;
            if (!eq(dMaxV)) {
                t += dv / maxV;
            }
        }

        for (int i = 1; i < wayPoints.size(); ++i) {
            double v0 = wayPoints.get(i - 1).v;
            double v = wayPoints.get(i).v;
            t += Math.abs(tTo(v, v0, a));
        }
        System.out.println(t);
    }

    static double tTo(double v, double v0, double a) {
        return (v - v0) / a;
    }

    static double dTo(double v, double v0, double a) {
        return (v * v - v0 * v0) / (2 * a);
    }

    static double v(double v0, double a, double d) {
        return Math.sqrt(2 * d * a + v0 * v0);
    }

    static boolean eq(double value) {
        return Math.abs(value) <= E;
    }

    static boolean l(double v) {
        return v < -E;
    }

    static boolean leq(double v) {
        return l(v) || eq(v);
    }

    static boolean leq(double one, double another) {
        return leq(one - another);
    }

    static class WayPoint {
        double v;

        WayPoint(double v) {
            this.v = v;
        }
    }
}
",0005_D,CODEFORCES,21,Follow Traffic Rules,"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.
It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km/h2, and has maximum speed of v km/h. The road has the length of l km, and the speed sign, limiting the speed to w km/h, is placed d km (1 ≤ d < l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.
The car can enter Bercouver at any speed.
","input
The first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).
output
Print the answer with at least five digits after the decimal point.
","implementation, math",1
"import java.io.*;
import java.util.*;

public class substring {
	static BufferedReader br;
	static StringTokenizer st;
	static PrintWriter out;
	public static void main(String[] args) throws IOException {
		InputStream input = System.in;
		//InputStream input = new FileInputStream(""fileIn.in"");
		OutputStream output = System.out;
		//OutputStream output = new FileOutputStream(""fileOut.out"");
		br = new BufferedReader(new InputStreamReader(input));
		out = new PrintWriter(output);
		String in = br.readLine();
      int len = in.length();
      int doub = len;
      boolean found = false;
      while (!found)
         {
         int count = 0;
         String[] parts = new String[len - doub + 1];
         for (int i = 0; i < len - doub + 1; i++)
            parts[i] = in.substring(i,i+doub);
         for (int i = 1; i < len - doub + 1; i++)
            for (int j = 0; j < i; j++)
               if (parts[i].equals(parts[j]))
                  count++;
         if (count >= 1)
            found = true;
         doub--;
         }
      out.println(doub+1);
		out.close();
	}
}
",0023_A,CODEFORCES,3764,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"    //    A Computer is Like a mischievous genie.
    //    It will give you exactly what you ask for,
    //    but not always what you want
    //    A code by Rahul Verma


    import java.io.BufferedOutputStream;
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.io.PrintWriter;
    import java.math.BigInteger;
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Collections;
    import java.util.Comparator;
    import java.util.HashMap;
    import java.util.HashSet;
    import java.util.LinkedHashSet;
    import java.util.LinkedList;
    import java.util.List;
    import java.util.PriorityQueue;
    import java.util.Queue;
    import java.util.Set;
    import java.util.Stack;
    import java.util.StringTokenizer;
    import java.util.TreeMap;
    import java.util.TreeSet;


    public class Main {


        static class Clock {

            protected long start, stop;

            public void start() {

                start = System.currentTimeMillis();
            }

            public void stop() {
                stop = System.currentTimeMillis();
            }

            public String getTime() {

                return ((stop - start) + "" ms"");
            }
        }


        public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

        static class FastReader {

            BufferedReader br;
            StringTokenizer st;

            public FastReader() {
                br = new BufferedReader(new
                    InputStreamReader(System.in));
            }

            String next() {
                while (st == null || !st.hasMoreElements()) {
                    try {
                        st = new StringTokenizer(br.readLine());
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                return st.nextToken();
            }

            int nextInt() {
                return Integer.parseInt(next());
            }

            long nextLong() {
                return Long.parseLong(next());
            }

            double nextDouble() {
                return Double.parseDouble(next());
            }

            String[] nextSArray() {
                String sr[] = null;
                try {
                    sr = br.readLine().trim().split("" "");
                } catch (IOException e) {
                    e.printStackTrace();
                }
                return sr;
            }

            String nextLine() {
                String str = """";
                try {
                    str = br.readLine();
                } catch (IOException e) {
                    e.printStackTrace();
                }

                return str;
            }
        }


        static long powmodulo(long a, long p) {
            if (p == 0) {
                return 1 % mod;
            }
            if (p == 1) {
                return a % mod;
            }
            long ans = 1;
            while (p > 0) {
                if ((p & 1) > 0) {
                    ans = (ans * a) % mod;
                }
                a = (a * a) % mod;
                p = p >> 1;
            }
            return ans % mod;
        }


        static long mod = 1000000007;

        static long gcd(long a, long b) {
            if (a == 0) {
                return b;
            }
            return gcd(b % a, a);
        }

        static long fast_powerNumbers(long a, long n) {
            if (n == 1) {
                return a;
            }
            long ans = fast_powerNumbers(a, n / 2);
            if (n % 2 == 0) {
                return (ans * ans);
            } else {
                return ((ans * ans) * (a));
            }
        }


        static void dfs_helper(int[][] arr, int i, int j, int team, int n, int m) {
            arr[i][j] = team;
            if (i - 1 >= 0 && arr[i - 1][j] == 1) {
                dfs(arr, i - 1, j, team, n, m);
            }
            if (j - 1 >= 0 && arr[i][j - 1] == 1) {
                dfs(arr, i, j - 1, team, n, m);
            }
            if (i + 1 < n && arr[i + 1][j] == 1) {
                dfs(arr, i + 1, j, team, n, m);
            }
            if (j + 1 < m && arr[i][j + 1] == 1) {
                dfs(arr, i, j + 1, team, n, m);
            }

        }

        static void dfs(int[][] arr, int i, int j, int team, int n, int m) {
            dfs_helper(arr, i, j, team, n, m);

        }
        public static int arr[];


        static void seive(int n) {
            // 1 is not prime
            arr = new int[n + 1];
            arr[0] = arr[1] = 1;
            for (int i = 4; i <= n; i = i + 2) {
                arr[i] = 1;
            }
            for (int i = 3; i * i <= n; i = i + 2) {
                if (arr[i] == 0) {
                    for (int j = i * i; j <= n; j = j + i) {
                        arr[j] = 1;
                    }

                }
            }
        }


        public static HashMap<Integer,Integer> primefac(int n)
        {
            HashMap<Integer,Integer>hm=new HashMap<>();
            //int x = (int) Math.sqrt(n);
            for (int i = 2; i <=n; i++) {
                int x=0;
                while(n%i==0)
                {
                    n=n/i;
                    ++x;
                }
                if(x!=0)
                {
                    hm.put(i,x);
                }
            }
            return hm;
        }
       static long fac(int p)
       {
           if(p==0||p==1)
               return 1;
           return p*fac(p-1);
       }


        public static void main(String[] args) throws Exception {
            FastReader sc = new FastReader();

            Clock clock = new Clock();

            clock.start();
          int n = sc.nextInt();
          int a=sc.nextInt();
          double arr[][] = new double[n][2];
          int one=0;
            for (int i = 0; i < n; i++) {
                arr[i][0]=sc.nextDouble();
                if(arr[i][0]==1)
                    ++one;
            }
            for (int i = 0; i < n; i++) {
                arr[i][1]=sc.nextDouble();
                if(arr[i][1]==1)
                    ++one;
            }
            if(one!=0)
            {
                System.out.println(-1);
                return;
            }

            double ans=a;
            ArrayList<Double>al=new ArrayList<>();
            al.add(arr[0][0]);
            int k=0;
            for (int i = 1; i < n; i++) {
               al.add(arr[i][1]);
               al.add(arr[i][0]);
            }

            al.add(arr[0][1]);
            Collections.reverse(al);
            for (int i = 0; i < al.size(); i++) {
                ans =  (ans + (ans/(al.get(i)-1)));
            }
//            System.out.println(al);
//            System.out.println(al.size());
            System.out.println(ans-a);


    }}


    class Pair{

        int a,b;
        Pair(int a,int b)
        {
            this.a=a;
            this.b=b;
        }
    }
    class DSU
    {
        int parent[];
        int rank[];

        long sum[] ;
        DSU(int n)
        {
            this.parent=new int[n];
            this.rank=new int[n];
            sum=new long[n];
            Arrays.fill(parent,-1);
            Arrays.fill(rank,1);

        }

        int find(int s1)
        {
            if(parent[s1]==-1)
                return s1;
            return parent[s1]=find(parent[s1]);
        }

        void unite(int s1,int s2)
        {
            int p1=this.find(s1);
            int p2=this.find(s2);
            if(p1==p2)
                return;
            if(rank[p1]>rank[p2])
            {
                parent[p2]=p1;
                rank[p1]+=rank[p2];
                // System.out.println(arr[p2]);

                sum[p1]+=sum[p2];
                //sum[p2]+=sum[p1];

            }
            else
            {
                parent[p1]=p2;
                rank[p2]+=rank[p1];
                //System.out.println(arr[p1]);
                sum[p2]+=sum[p1];
                //sum[p1]+=sum[p2];
            }
        }


    }

    class Gaph {

        HashMap<Integer, ArrayList<Integer>> hm;

        Gaph() {
            hm = new HashMap<>();
        }

        Gaph(int n) {

            hm = new HashMap<>();
            for (int i = 0; i < n; i++) {
                hm.put(i, new ArrayList<Integer>());
            }
        }

        // function for adding an edge.................................................
        public void addEdge(int a, int b, boolean isDir) {
            if (isDir) {
                if (hm.containsKey(a)) {
                    hm.get(a).add(b);
                } else {
                    hm.put(a, new ArrayList<>(Arrays.asList(b)));
                }
            } else {
                if (hm.containsKey(a)) {
                    hm.get(a).add(b);
                } else if (!hm.containsKey(a)) {
                    hm.put(a, new ArrayList<>(Arrays.asList(b)));
                }

                if (hm.containsKey(b)) {
                    hm.get(b).add(a);
                } else if (!hm.containsKey(b)) {
                    hm.put(b, new ArrayList<>(Arrays.asList(a)));
                }
            }
        }


    }

    // out.println(al.toString().replaceAll(""[\\[|\\]|,]"",""""));",1010_A,CODEFORCES,2022,Fly,"Natasha is going to fly on a rocket to Mars and return to Earth. Also, on the way to Mars, she will land on $$$n - 2$$$ intermediate planets. Formally: we number all the planets from $$$1$$$ to $$$n$$$. $$$1$$$ is Earth, $$$n$$$ is Mars. Natasha will make exactly $$$n$$$ flights: $$$1 \to 2 \to \ldots n \to 1$$$.
Flight from $$$x$$$ to $$$y$$$ consists of two phases: take-off from planet $$$x$$$ and landing to planet $$$y$$$. This way, the overall itinerary of the trip will be: the $$$1$$$-st planet $$$\to$$$ take-off from the $$$1$$$-st planet $$$\to$$$ landing to the $$$2$$$-nd planet $$$\to$$$ $$$2$$$-nd planet $$$\to$$$ take-off from the $$$2$$$-nd planet $$$\to$$$ $$$\ldots$$$ $$$\to$$$ landing to the $$$n$$$-th planet $$$\to$$$ the $$$n$$$-th planet $$$\to$$$ take-off from the $$$n$$$-th planet $$$\to$$$ landing to the $$$1$$$-st planet $$$\to$$$ the $$$1$$$-st planet.
The mass of the rocket together with all the useful cargo (but without fuel) is $$$m$$$ tons. However, Natasha does not know how much fuel to load into the rocket. Unfortunately, fuel can only be loaded on Earth, so if the rocket runs out of fuel on some other planet, Natasha will not be able to return home. Fuel is needed to take-off from each planet and to land to each planet. It is known that $$$1$$$ ton of fuel can lift off $$$a_i$$$ tons of rocket from the $$$i$$$-th planet or to land $$$b_i$$$ tons of rocket onto the $$$i$$$-th planet. 
For example, if the weight of rocket is $$$9$$$ tons, weight of fuel is $$$3$$$ tons and take-off coefficient is $$$8$$$ ($$$a_i = 8$$$), then $$$1.5$$$ tons of fuel will be burnt (since $$$1.5 \cdot 8 = 9 + 3$$$). The new weight of fuel after take-off will be $$$1.5$$$ tons. 
Please note, that it is allowed to burn non-integral amount of fuel during take-off or landing, and the amount of initial fuel can be non-integral as well.
Help Natasha to calculate the minimum mass of fuel to load into the rocket. Note, that the rocket must spend fuel to carry both useful cargo and the fuel itself. However, it doesn't need to carry the fuel which has already been burnt. Assume, that the rocket takes off and lands instantly.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 1000$$$) — number of planets.
The second line contains the only integer $$$m$$$ ($$$1 \le m \le 1000$$$) — weight of the payload.
The third line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 1000$$$), where $$$a_i$$$ is the number of tons, which can be lifted off by one ton of fuel.
The fourth line contains $$$n$$$ integers $$$b_1, b_2, \ldots, b_n$$$ ($$$1 \le b_i \le 1000$$$), where $$$b_i$$$ is the number of tons, which can be landed by one ton of fuel. 
It is guaranteed, that if Natasha can make a flight, then it takes no more than $$$10^9$$$ tons of fuel.
If Natasha can fly to Mars through $$$(n - 2)$$$ planets and return to Earth, print the minimum mass of fuel (in tons) that Natasha should take. Otherwise, print a single number $$$-1$$$.
It is guaranteed, that if Natasha can make a flight, then it takes no more than $$$10^9$$$ tons of fuel.
The answer will be considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$. Formally, let your answer be $$$p$$$, and the jury's answer be $$$q$$$. Your answer is considered correct if $$$\frac{|p - q|}{\max{(1, |q|)}} \le 10^{-6}$$$.
Let's consider the first example.
","input
Initially, the mass of a rocket with fuel is $$$22$$$ tons.
output
In the second case, the rocket will not be able even to take off from Earth.
","binarysearch, math",3
"
import java.util.*;

public class Main {

  public static String toString(int a){
    return Integer.toString(a);
  }

  public static void print(int[] a, String curr){

  }

  static ArrayList<String> ans;

  public static void solve(int n, int[] a){
    int i = 0;
    Stack<Integer> st = new Stack<>();
    while(i < n) {
      if(st.isEmpty() || a[i] == 1){
        st.push(a[i]);
      }
      else{
        while(st.peek() != a[i] - 1){
          st.pop();
        }
        st.pop();
        st.push(a[i]);
      }
      Stack<Integer> cp = (Stack<Integer>) st.clone();
      String s = """";
      while(!cp.isEmpty()){
        s = '.' + cp.peek().toString() + s;
        cp.pop();
      }
      if(s.charAt(0) == '.'){
        s = s.substring(1);
      }
      System.out.println(s);
      i++;
    }
  }

  public static void main(String[] args) {

    Scanner sc = new Scanner(System.in);

    int t = sc.nextInt();

    while (t-- > 0) {
      int n = sc.nextInt();
      int[] a = new int[n];
      for(int i = 0 ; i < n ; i++){
        a[i] = sc.nextInt();
      }
      ans = new ArrayList<>();
      solve(n,a);
    }
  }
}


",1523_C,CODEFORCES,3672,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees",5
"import java.util.*;
import java.math.*;
import java.io.*;
public class Main
	{
	public static void main(String args[])	throws IOException
		{
		Scanner c=new Scanner(System.in);
		int N=c.nextInt();
		int A[]=new int[N];
		for(int i=0;i<N;i++) 
			{
			A[i]=c.nextInt();
			}
		Arrays.sort(A);
		int sum=0;
		for(int i=0;i<N;i++) 
			{
			sum+=A[i];
			}
		int my=0;
		int coins=0;
		for(int i=N-1;i>=0;i--) 
			{
			coins++;			//include coin i
			my+=A[i];
			if(my>sum-my)
				{
				System.out.println(coins);
				break;
				}
			}
		}
	}

//must declare new classes here",0160_A,CODEFORCES,2452,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"import java.io.*;
import java.util.*;

public class Rhombus {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = Integer.parseInt(in.nextLine());

		solve(n);
	}

	public static void solve(int n) {
		System.out.println(2 * n * n - (2 * n - 1));
	}
}",1180_A,CODEFORCES,745,Alex and a Rhombus,"While playing with geometric figures Alex has accidentally invented a concept of a $$$n$$$-th order rhombus in a cell grid.
A $$$1$$$-st order rhombus is just a square $$$1 \times 1$$$ (i.e just a cell).
A $$$n$$$-th order rhombus for all $$$n \geq 2$$$ one obtains from a $$$n-1$$$-th order rhombus adding all cells which have a common side with it to it (look at the picture to understand it better).
Alex asks you to compute the number of cells in a $$$n$$$-th order rhombus.
The first and only input line contains integer $$$n$$$ ($$$1 \leq n \leq 100$$$) — order of a rhombus whose numbers of cells should be computed.
","input
Print exactly one integer — the number of cells in a $$$n$$$-th order rhombus.
output
Images of rhombus corresponding to the examples are given in the statement.
","dp, implementation, math",1
"import java.io.*;
import java.util.*;
import java.math.*;

public class Main{
  final int mod = 1000000007;
  final int maxn = -1;
  final double eps = 1e-9;

  long digits(long n){
    if(n == 0) return 0;
    int p = (int)Math.log10(n);
    return (p + 1) * (n - (long)Math.pow(10, p) + 1) + digits((long)Math.pow(10, p) - 1);
  }

  void solve(){
    // freopen(""in"");
    String s = """";
    long k = nextLong();
    long i = 1;
    long j = k;
    while(i < j){
      long m = (i + j) / 2;
      if(digits(m) < k){
        i = m + 1;
      }
      else{
        j = m;
      }
    }
    if(digits(i) >= k) --i;
    printf(""%c\n"", String.valueOf(i + 1).charAt((int)(k - digits(i) - 1)));
  }

  final double pi = Math.acos(-1.0);
  final long infl = 0x3f3f3f3f3f3f3f3fl;
  final int inf = 0x3f3f3f3f;
  final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;

  boolean zero(double x){ return x < eps; }

  /** io **/
  PrintWriter out;
  BufferedReader reader;
  StringTokenizer tokens;

  Main(){
    long s = System.currentTimeMillis();
    tokens = new StringTokenizer("""");
    reader = new BufferedReader(new InputStreamReader(System.in), 1 << 15);
    out = new PrintWriter(System.out);
    Locale.setDefault(Locale.US);     // imprime double com ponto
    solve();
    out.close();
    debug(""Time elapsed: %dms"", System.currentTimeMillis() - s);
  }

  void freopen(String s){
    try{ reader = new BufferedReader(new InputStreamReader(new FileInputStream(s)), 1 << 15); }
    catch(FileNotFoundException e){ throw new RuntimeException(e); }
  }

  /** input -- supõe que não chegou no EOF **/
  int nextInt(){ return Integer.parseInt(next()); }
  long nextLong(){ return Long.parseLong(next()); }
  double nextDouble(){ return Double.parseDouble(next()); }

  String next(){ readTokens(); return tokens.nextToken(); }
  String nextLine(){ readTokens(); return tokens.nextToken(""\n""); }

  boolean readTokens(){
    while(!tokens.hasMoreTokens()){             // lê os dados, ignorando linhas vazias
      try{
        String line = reader.readLine();
        if(line == null) return false;          // EOF
        tokens = new StringTokenizer(line);
      }
      catch(IOException e){ throw new RuntimeException(e); }
    }
    return true;
  }

  /** output **/
  void printf(String s, Object... o){ out.printf(s, o); }
  void debug(String s, Object... o){ if(!ONLINE_JUDGE) System.err.printf((char)27 + ""[91m"" + s + (char)27 + ""[0m"", o); }

  public static void main(String[] args){ new Main(); }
}
",1177_B,CODEFORCES,1332,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.*;
import java.math.*;
import static java.lang.Math.*;
import static java.util.Arrays.sort;
import static java.util.Collections.sort;
import static java.util.Arrays.fill;
import static java.util.Arrays.copyOfRange;
import static java.util.Arrays.binarySearch;
 
import static java.lang.Math.min;
import static java.lang.Math.max;
 
import static java.lang.Math.min;
import static java.lang.Math.max;
 
import java.util.*;
import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;

public class Main {

	public static void main(String[] args) throws IOException {
		int n = in.nextInt();
		int[] a = in.nextIntArray(n);
		sort(a);
		int ans = 0;
		boolean[] done = new boolean[n];
		for(int i = 0; i < n; i ++) {
			if(done[i])
				continue;
			ans ++;
			for(int j = i + 1; j < n; j ++)
				if(a[j] % a[i] == 0)
					done[j] = true;
		}
		out.write(ans + ""\n"");
		out.flush();
	}
 
	public static FastReader in = new FastReader();
	public static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void gcj(int cn, Object ans) throws IOException {
		System.out.print(""Case #"" + cn + "": "" + ans + ""\n"");
	}
	
	public static ArrayList <Integer>[] ALArrayI(int size) {
		ArrayList <Integer>[] l = new ArrayList[size];
		for(int i = 0; i < size; i ++)
			l[i] = new ArrayList <> ();
		return l;
	}
	
	public static ArrayList <Long>[] ALArrayL(int size) {
		ArrayList <Long>[] l = new ArrayList[size];
		for(int i = 0; i < size; i ++)
			l[i] = new ArrayList <> ();
		return l;
	}
	
	public static Integer[] integerList(int fi, int fo) {
		Integer[] l = new Integer[fo - fi];
		for(int i = 0; i < fo - fi; i ++)
			l[i] = fi + i;
		return l;
	}
}
 
class Graph {
	TreeSet <Integer>[] g;
	
	public Graph(int n) {
		g = new TreeSet[n];
		for(int i = 0; i < n; i ++)
			g[i] = new TreeSet <> ();
	}
	
	public void addEdge(int u, int v) {
		g[u].add(v);
	}
	
	public TreeSet <Integer> getAdj(int u) {
		return g[u];
	}
	
	public int nodes() {
		return g.length;
	}
}
 
class FastReader {
    BufferedReader br;
    StringTokenizer st;
 
    public FastReader() {
        br = new BufferedReader(new InputStreamReader(System.in));
    }
    
    public String next() {
        while (st == null || !st.hasMoreElements()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException  e) {
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }
 
    public char nextChar() {
    	return next().charAt(0);
    }
    
    public int nextInt() {
        return Integer.parseInt(next());
    }
 
    public long nextLong() {
        return Long.parseLong(next());
    }
 
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public String nextLine() {
        String str = """";
        try {
            str = br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return str;
    }
    
    public int[] nextIntArray(int n) {
    	int[] a = new int[n];
    	for(int i = 0; i < n; i ++)
    		a[i] = nextInt();
    	return a;
    }
    
    public Integer[] nextIntegerArray(int n) {
    	Integer[] a = new Integer[n];
    	for(int i = 0; i < n; i ++)
    		a[i] = nextInt();
    	return a;
    }
    
    public long[] nextLongArray(int n) {
    	long[] a = new long[n];
    	for(int i = 0; i < n; i ++)
    		a[i] = nextLong();
    	return a;
    }
    
    public double[] nextDoubleArray(int n) {
    	double[] a = new double[n];
    	for(int i = 0; i < n; i ++)
    		a[i] = nextDouble();
    	return a;
    }
    
    public String[] nextStringArray(int n) {
    	String[] a = new String[n];
    	for(int i = 0; i < n; i ++)
    		a[i] = next();
    	return a;
    }
}",1209_A,CODEFORCES,3475,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"/*
    JAI MATA DI
 */

import java.util.*;

//import javax.print.attribute.HashAttributeSet;

import java.io.*;
import java.math.BigInteger;
import java.sql.Array;

public class CP {
	  static class FR{
			BufferedReader br;
			StringTokenizer st;
			public FR() {
				br = new BufferedReader(new InputStreamReader(System.in));
			}
			String next() 
		    { 
		        while (st == null || !st.hasMoreElements()) 
		        { 
		            try
		            { 
		                st = new StringTokenizer(br.readLine()); 
		            } 
		            catch (IOException  e) 
		            { 
		                e.printStackTrace(); 
		            } 
		        } 
		        return st.nextToken(); 
		    } 

		    int nextInt() 
		    { 
		        return Integer.parseInt(next()); 
		    } 

		    long nextLong() 
		    { 
		        return Long.parseLong(next()); 
		    } 

		    double nextDouble() 
		    { 
		        return Double.parseDouble(next()); 
		    } 

		    String nextLine() 
		    { 
		        String str = """"; 
		        try
		        { 
		            str = br.readLine(); 
		        } 
		        catch (IOException e) 
		        { 
		            e.printStackTrace(); 
		        } 
		        return str; 
		    } 
		}
	 static int mod  = 1000000007;
	 static long gcd(long a, long b)
	  {      
	     if (b == 0)
	        return a;
	     return gcd(b, a % b); 
	  }
	 static boolean[] prime(int num) {
			boolean[] bool = new boolean[num];
		     
		      for (int i = 0; i< bool.length; i++) {
		         bool[i] = true;
		      }
		      for (int i = 2; i< Math.sqrt(num); i++) {
		         if(bool[i] == true) {
		            for(int j = (i*i); j<num; j = j+i) {
		               bool[j] = false;
		            }
		         }
		      }
		      if(num >= 0) {
		    	  bool[0] = false;
		    	  bool[1] = false;
		      }
		      
		      return bool;
		}
	 static class Pair implements Comparable<Pair>{
		 	int x;
	 		int y;
	 		Pair(int key , int value){
	 			this.x = key;
	 			this.y = value;
	 		}
			@Override
			public int compareTo(Pair o) {
				return this.x - o.x;
			}
//			@Override
//			public int hashCode(){
//				return val + ind;
//			}
	 	}
	 	
	
	 public static void main(String args[]) {
		 
		 FR sc = new FR();
		 int n = sc.nextInt() , m = sc.nextInt() , k = sc.nextInt();
		 int[][] arr = new int[n][m];
		 if(k%2 == 1) {
			 for(int i = 0 ; i<n ; i++) {
				 for(int j = 0 ;j<m ; j++) System.out.print(""-1 "");
				 System.out.println();
			 }
			 return;
		 }
		 x = n; y = m;
		 int[][] he = new int[n][m-1];
		 int[][] ve = new int[n-1][m];
		 for(int i = 0 ; i <he.length ; i++) {
			 for(int j = 0 ; j<he[0].length ; j++) he[i][j] = sc.nextInt();
		 }
		 for(int i = 0 ; i<ve.length ; i++) {
			 for(int j = 0 ; j<ve[0].length ; j++) ve[i][j] = sc.nextInt();
		 }
		 int[][][] dp = new int[n+1][m+1][11];
		for(int i = 0 ; i<x ; i++) {
			for(int j = 0 ; j<y; j++) arr[i][j] = 2*fnc(he, ve, i, j, k/2, dp);
		}
		for(int i = 0 ; i<x;i++) {
			for(int j = 0 ;j<y;j++) System.out.print(arr[i][j]+"" "");
			System.out.println();
		}
	 }
	 static int  x , y;
	 
	 static int edge(int[][] he , int[][] ve , int i ,int j , char cc) {
		if(cc == 'L') {
			return he[i][j];
		}
		if(cc == 'R') {
			return he[i][j-1];
		}
		if(cc == 'U') return ve[i][j];
		 return ve[i-1][j];
		 
	 }
	 
	static int fnc(int[][] he, int[][] ve ,int i , int j , int k ,int[][][] dp) {
		if(k == 0) return 0;
		if(dp[i][j][k]!=0) return dp[i][j][k];
		int tot = Integer.MAX_VALUE;
		if(i+1 < x) {
			tot = Math.min(tot, fnc(he, ve, i + 1, j,k-1, dp) + edge(he, ve, i+1, j, 'D'));
		}
		if(i-1>=0) {
			tot = Math.min(tot, fnc(he, ve, i-1, j, k-1, dp) + edge(he, ve, i-1, j, 'U'));
		}
		if(j-1>=0) {
			tot = Math.min(tot, fnc(he, ve, i, j-1, k-1, dp) + edge(he, ve, i, j-1, 'L') );
		}
		if(j+1<y) {
			tot = Math.min(tot, fnc(he, ve, i, j+1, k-1, dp) + edge(he, ve, i, j+1, 'R'));
		}
		dp[i][j][k] = tot;
		return dp[i][j][k];
	}
}",1517_D,CODEFORCES,4252,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashSet;
import java.util.StringTokenizer;
import java.util.TreeMap;

public class AA {
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		int n = sc.nextInt();
		int d =sc.nextInt();
		int[] hotels = new int[n];
		for (int i = 0; i < hotels.length; i++) {
			hotels[i] = sc.nextInt();
		}
		int count = 0;
		for (int i = 0; i < hotels.length-1; i++) {
			int one = hotels[i];
			int two = hotels[i+1];
			double mid = (two-one)*1.0/2.0;
			if(mid==d) {
				count++;
//				System.out.println(""hello""+"" ""+i+"" ""+(i+1));
			}
			else if(mid>d) {
//				System.out.println(""hello2""+"" ""+i+"" ""+(i+1));
				count+=2;
				
			}
			
		}
		count+=2;
		System.out.println(count);
		
		
		out.flush();
		out.close();
	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}//19 91 991 919 199

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public double nextDouble() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder(""0"");
			double res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder(""0"");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

	}

}
",1004_A,CODEFORCES,1976,Sonya and Hotels,"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.
The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $$$n$$$ hotels, where the $$$i$$$-th hotel is located in the city with coordinate $$$x_i$$$. Sonya is a smart girl, so she does not open two or more hotels in the same city.
Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $$$d$$$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 
Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $$$n$$$ hotels to the new one is equal to $$$d$$$.
The first line contains two integers $$$n$$$ and $$$d$$$ ($$$1\leq n\leq 100$$$, $$$1\leq d\leq 10^9$$$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.
The second line contains $$$n$$$ different integers in strictly increasing order $$$x_1, x_2, \ldots, x_n$$$ ($$$-10^9\leq x_i\leq 10^9$$$) — coordinates of Sonya's hotels.
Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $$$d$$$.
","input
In the first example, there are $$$6$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$-6$$$, $$$5$$$, $$$6$$$, $$$12$$$, $$$13$$$, and $$$19$$$.
output
In the second example, there are $$$5$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$2$$$, $$$6$$$, $$$13$$$, $$$16$$$, and $$$21$$$.
",implementation,3
"import java.io.*;
import java.math.*;
import java.util.*;
public class C {
	static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

    static FastReader s = new FastReader();
    static PrintWriter out = new PrintWriter(System.out);

    private static int[] rai(int n) {
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = s.nextInt();
        }
        return arr;
    }

    private static int[][] rai(int n, int m) {
        int[][] arr = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                arr[i][j] = s.nextInt();
            }
        }
        return arr;
    }

    private static long[] ral(int n) {
        long[] arr = new long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = s.nextLong();
        }
        return arr;
    }

    private static long[][] ral(int n, int m) {
        long[][] arr = new long[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                arr[i][j] = s.nextLong();
            }
        }
        return arr;
    }

    private static int ri() {
        return s.nextInt();
    }

    private static long rl() {
        return s.nextLong();
    }

    private static String rs() {
        return s.next();
    }
    static int n;
    static long dp[][];
    static List<Integer> adj[];
    static int cost[][];
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		FastReader sc=new FastReader();
		int t,m=0,i=0,j=0,k=0,c=0,fg=0,p=0,q=0,tm=0,a=0,b=0,x=0,y=0,z=0,max=-1,min=Integer.MAX_VALUE;
		String str;
		long sum=0,ans=0;
		BigInteger f=BigInteger.valueOf(0);
		t=sc.nextInt();
		while(t-->0)
		{
			n=sc.nextInt();
			List<Integer> pre=new ArrayList();
			while(n-->0)
			{
				a=sc.nextInt();
				List<Integer> l=new ArrayList();
				if(a==1)
				{
					for(i=0;i<pre.size();i++)
					{
						System.out.print(pre.get(i)+""."");
						l.add(pre.get(i));
					}
					System.out.println(a);
					l.add(a);
					pre=new ArrayList(l);
				}
				else
				{
					for(i=pre.size()-1;i>=0;i--)
						if(a-pre.get(i)==1)
							break;
					for(j=0;j<i;j++)
					{
						System.out.print(pre.get(j)+""."");
						l.add(pre.get(j));
					}
					System.out.println(a);
					l.add(a);
					pre=new ArrayList(l);
				}
			}
		}
	}
}",1523_C,CODEFORCES,3660,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees",5
"import java.util.*;
public class ProA {
	static long n;

	public static void main(String[] args) {
		Scanner in=new Scanner(System.in);
		n=in.nextLong();
		System.out.println(25);
	}
}
",0630_A,CODEFORCES,553,Again Twenty Five!,"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. ""Do I give such a hard task?"" — the HR manager thought. ""Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.""
Could you pass the interview in the machine vision company in IT City?
","input
The only line of the input contains a single integer n (2 ≤ n ≤ 2·1018) — the power in which you need to raise number 5.
output
Output the last two digits of 5n without spaces between them.
",numbertheory,1
"import java.util.Arrays;
import java.util.Scanner;

public class A {

    void run(){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        boolean dif = false;
        for(int i=0;i<n;i++)a[i]=sc.nextInt();
        Arrays.sort(a);
        if(n==1){
            System.out.println(a[0]==1?2:1);return;
        }
        int[] m = new int[n];
        for(int i=1;i<n;i++)if(a[i]!=a[i-1])dif=true;
        m[0] = 1;
        for(int i=1;i<n;i++)m[i]=a[i-1];
        if(!dif&&a[0]==1)m[n-1]++;
        
        for(int i=0;i<n;i++)System.out.print(m[i]+(i==n-1?""\n"":"" ""));
    }
    
    public static void main(String[] args) {
        new A().run();
    }
}",0135_A,CODEFORCES,2417,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings",4
"import java.io.*;
import java.util.*;

public class D {

	public static BufferedReader br;
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

	public static void main(String[] args) throws IOException {
		readInput();
		out.close();
	}
	static int n;
	static long[] a;
	
	static void solve() {
		boolean firstwin = true;
		// Auto lose: Everything is zero, three or more of the same exist, two doubles, or the game is like two types of stones and it's not two piles.
		if (n == 1) firstwin = a[0]%2==1 ? true:false;
		else if (n == 2) {
			if (a[0] + a[1] == 0) firstwin = false;
			else if ((a[0]+a[1])%2 == 0) firstwin = true;
			else firstwin = false;
		}
		else {
			HashMap<Long, Integer> hm = new HashMap<Long, Integer>();
			int numdub = 0;
			long dub = 0;
			for (long x: a) {
				if (!hm.containsKey(x)) hm.put(x, 0);
				hm.put(x, hm.get(x)+1);
				if (hm.get(x) == 3) firstwin = false; // Handles all zero fine
				if (hm.get(x) == 2) {
					numdub++;
					dub = x;
				}
			}
			if (numdub >= 2) firstwin = false;
			if (numdub == 1) {
				// If theres like 35788 we fail but treeset doesnt catch that.
				if (hm.containsKey(dub-1)) firstwin=false;
			}
		}
		if (!firstwin) out.println(""cslnb"");
		else if (n >= 2){
			// My intution is screaming they will attempt to make the longest increasing sequence starting with zero.
			// Whoever is the sucekr in this situation takes the L.
			//  If there is not this increasing sequence, that MUST necessarily trigger a weird condition. So, if we ever go negative, we know first loses.
			Arrays.sort(a);
			long extra = 0;
			for (int i = 0; i < n; i++) {
				long bias = a[i]-i;
				if (bias < 0) firstwin = false;
				extra += bias;
			}
			if (firstwin) {
				if (extra % 2 == 0) firstwin = false;
				else firstwin = true;
			}
			out.println(firstwin ? ""sjfnb"": ""cslnb"");
		}
		else out.println(firstwin ? ""sjfnb"": ""cslnb"");
	}
	
	public static void readInput() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		// br = new BufferedReader(new FileReader(""in.in""));
		n = Integer.parseInt(br.readLine());
		a= new long[n];
		StringTokenizer st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) a[i] = Long.parseLong(st.nextToken());
		solve();
	}
}
",1191_D,CODEFORCES,2164,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy",3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    static BufferedReader reader;
    static StringTokenizer st;
    private static void setReader() {
        reader = new BufferedReader(new InputStreamReader(System.in));
    }
    private static void updateST() throws IOException {
        if (st==null || !st.hasMoreElements()) st = new StringTokenizer(reader.readLine());
    }
    private static int nextInt() throws IOException {
        updateST();
        return Integer.parseInt(st.nextToken());
    }

    public static void main(String[] args) throws IOException {
        setReader();
        int n = nextInt(), MOD = nextInt();
        long[] pow = new long[n+2];
        pow[0] = 1;
        for (int i=1; i<=n+1; i++) pow[i] = (pow[i-1] * 2) % MOD;
        long[][] C = new long[n+2][n+2];
        for (int i=0; i<=n+1; i++) {
            C[i][0] = 1;
            for (int j=1; j<=i; j++) {
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }
        long[][] dp = new long[n+2][n+1];
        dp[0][0] = 1;
        for (int i=0; i<=n; i++) {
            for (int j=0; j<=i; j++) {
                for (int k=1; i + k + 1 <= n + 1; k++) {
                    dp[i + k + 1][j + k]+=(((dp[i][j] * C[j + k][k]) % MOD * pow[k-1]) % MOD);
                    dp[i + k + 1][j + k]%=MOD;
                }
            }
        }
        long res = 0;
        for (int i=0; i<=n; i++) res = (res + dp[n+1][i]) % MOD;
        System.out.println(res);
    }
}",1515_E,CODEFORCES,4124,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class E implements Runnable {
	public static void main (String[] args) {new Thread(null, new E(), ""_cf"", 1 << 28).start();}

	int n, m;
	char[] str;
	int[][] occs, cost;
	int[] dp;
	
	public void run() {
		FastScanner fs = new FastScanner();
		PrintWriter out = new PrintWriter(System.out);
		System.err.println("""");

		n = fs.nextInt(); m = fs.nextInt();
		str = fs.next().toCharArray();
		occs = new int[m][m];
		for(int i = 0; i < n-1; i++) {
			occs[str[i]-'a'][str[i+1]-'a']++;
			occs[str[i+1]-'a'][str[i]-'a']++;
		}
		//cost[mask][v] = numPairs with v for some all bits on in mask
		int all = (1<<m)-1;
		cost = new int[m][1<<m];
		for(int i = 0; i < m; i++) {
			for(int mask = 1; mask < all; mask++) {
				if(((1<<i)&mask) > 0) continue;
				int lb = mask & (-mask);
				int trail = Integer.numberOfTrailingZeros(lb);
				int nmask = mask ^ lb;
				cost[i][mask] = cost[i][nmask]+occs[i][trail];
			}
		}
		
		dp = new int[1<<m];
		Arrays.fill(dp, -1);
		System.out.println(solve(0));
		
		out.close();
	}
	
	int oo = (int)1e9;
	int solve(int mask) {
		if(mask == (1<<m)-1) return 0;
		if(dp[mask] != -1) return dp[mask];
		int res = oo;
		
		int addOn = 0;
		for(int nxt = 0; nxt < m; nxt++) {
			if(((1<<nxt)&mask) > 0) continue;
			addOn += cost[nxt][mask];
		}
		for(int nxt = 0; nxt < m; nxt++) {
			if(((1<<nxt)&mask) > 0) continue;
			int ret = addOn+solve(mask | (1<<nxt));
			res = Math.min(res, ret);
		}
		
		return dp[mask] = res;
	}
	
	class FastScanner {
		public int BS = 1<<16;
		public char NC = (char)0;
		byte[] buf = new byte[BS];
		int bId = 0, size = 0;
		char c = NC;
		double num = 1;
		BufferedInputStream in;

		public FastScanner() {
			in = new BufferedInputStream(System.in, BS);
		}

		public FastScanner(String s) {
			try {
				in = new BufferedInputStream(new FileInputStream(new File(s)), BS);
			}
			catch (Exception e) {
				in = new BufferedInputStream(System.in, BS);
			}
		}

		public char nextChar(){
			while(bId==size) {
				try {
					size = in.read(buf);
				}catch(Exception e) {
					return NC;
				}                
				if(size==-1)return NC;
				bId=0;
			}
			return (char)buf[bId++];
		}

		public int nextInt() {
			return (int)nextLong();
		}

		public long nextLong() {
			num=1;
			boolean neg = false;
			if(c==NC)c=nextChar();
			for(;(c<'0' || c>'9'); c = nextChar()) {
				if(c=='-')neg=true;
			}
			long res = 0;
			for(; c>='0' && c <='9'; c=nextChar()) {
				res = (res<<3)+(res<<1)+c-'0';
				num*=10;
			}
			return neg?-res:res;
		}

		public double nextDouble() {
			double cur = nextLong();
			return c!='.' ? cur:cur+nextLong()/num;
		}

		public String next() {
			StringBuilder res = new StringBuilder();
			while(c<=32)c=nextChar();
			while(c>32) {
				res.append(c);
				c=nextChar();
			}
			return res.toString();
		}

		public String nextLine() {
			StringBuilder res = new StringBuilder();
			while(c<=32)c=nextChar();
			while(c!='\n') {
				res.append(c);
				c=nextChar();
			}
			return res.toString();
		}

		public boolean hasNext() {
			if(c>32)return true;
			while(true) {
				c=nextChar();
				if(c==NC)return false;
				else if(c>32)return true;
			}
		}
		
		public int[] nextIntArray(int n) {
			int[] res = new int[n];
			for(int i = 0; i < n; i++) res[i] = nextInt();
			return res;
		}
		
	}

}",1238_E,CODEFORCES,4838,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp",7
"import java.util.*;

public class a {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		double w = in.nextDouble();
		int tot = 2;
		Interval[] houses = new Interval[n];
		for(int i=0; i<n; i++) {
			double center = in.nextDouble();
			double wid = in.nextDouble();
			houses[i] = new Interval(center-wid/2,center+wid/2);
		}
		Arrays.sort(houses);
		for(int i=1; i<n; i++) {
			double dist = houses[i].s - houses[i-1].e;
			if(dist+1e-6 >= w) {
				tot+=2;
				if(Math.abs(w-dist) < 1e-6)
					tot--;
			}
		}
		System.out.println(tot);
	}
}
class Interval implements Comparable<Interval> {
	double s, e;
	Interval(double a, double b) {
		s=a;
		e=b;
	}
	public int compareTo(Interval i) {
		return (int)Math.signum(s-i.s);
	}
}
",0015_A,CODEFORCES,2267,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;


public class Test {
public static void main(String[] args) throws IOException{
	BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
	//StringTokenizer st=new StringTokenizer(bf.readLine());
	int n=Integer.parseInt(bf.readLine());
	
	if(n%2==0) System.out.println(4+"" ""+(n-4));
	else System.out.println(9+"" ""+(n-9));
	
}
}
",0472_A,CODEFORCES,459,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory",1
"import java.util.Scanner;

import static java.lang.Integer.bitCount;
import static java.lang.Integer.numberOfTrailingZeros;
import static java.lang.System.out;

/**
 * 11D
 *
 * @author artyom
 */
public class ASimpleTask {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] d = new int[n][n];
        for (int i = 0, m = sc.nextInt(); i < m; i++) {
            int a = sc.nextInt() - 1, b = sc.nextInt() - 1;
            d[a][b] = 1;
            d[b][a] = 1;
        }
        long[][] dp = new long[1 << n][n];

        // SOLUTION BEGINS
        for (int mask = 1; mask < 1 << n; mask++) {
            int start = numberOfTrailingZeros(mask); // the starting vertex of a Hamiltonian walk
            if (bitCount(mask) == 1) {
                dp[mask][start] = 1;
                continue;
            }
            for (int i = 0; i < n; i++) {
                if ((mask & (1 << i)) > 0 && i != start) {
                    int xmask = mask ^ (1 << i); // mask without vertex i
                    for (int j = 0; j < n; j++) {
                        if (d[j][i] > 0) {
                            dp[mask][i] += dp[xmask][j];
                        }
                    }
                }
            }
        }
        // SOLUTION ENDS

        long sum = 0;
        for (int mask = 1; mask < 1 << n; mask++) {
            if (bitCount(mask) >= 3) { // We need at least 3 vertices for a cycle
                for (int i = 0; i < n; i++) {
                    if (d[numberOfTrailingZeros(mask)][i] > 0) {
                        sum += dp[mask][i];
                    }
                }
            }
        }
        out.print(sum / 2);
    }
}",0011_D,CODEFORCES,4456,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        Task276D solver = new Task276D();
        solver.solve(1, in, out);
        out.close();
    }

    static class Task276D {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            long l = in.nextLong();
            long r = in.nextLong();
            String ls = Long.toBinaryString(l);
            String rs = Long.toBinaryString(r);
            int max = rs.length();
            int min = ls.length();
            int i, j = max - min;

            //out.println(ls + "" "" + rs);
            int size = max;
            if (max == min) {
                for (i = 0; i < min; i++) {
                    if (ls.charAt(i) != rs.charAt(i + j))
                        break;
                }
                //out.println(i);
                size = max - i;
            }

            out.println((long) Math.pow(2, size) - 1);
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void println(long i) {
            writer.println(i);
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",0276_D,CODEFORCES,851,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"

import java.awt.Point;

import java.io.BufferedReader;

import java.io.BufferedWriter;

import java.io.FileReader;

import java.io.FileWriter;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;



public class FireAgain {



    int k, i, j,n,m,x,y;

    void run() {

        try {

            BufferedReader bfd = new BufferedReader(new FileReader(""input.txt""));

            BufferedWriter out = new BufferedWriter(new FileWriter(""output.txt""));

//          BufferedReader bfd = new BufferedReader(new InputStreamReader(System.in));

            StringTokenizer tk = new StringTokenizer(bfd.readLine());

            

            n = Integer.parseInt(tk.nextToken());

            m = Integer.parseInt(tk.nextToken());

            boolean vis[][] = new boolean[n][m];

            k = Integer.parseInt(bfd.readLine());

            tk = new StringTokenizer(bfd.readLine());

            Queue<Point> q = new LinkedList<Point>();

            Point last = new Point(0,0);

            while(k-->0){

                x = Integer.parseInt(tk.nextToken())-1;

                y = Integer.parseInt(tk.nextToken())-1;

                q.add(new Point(x,y));

                vis[x][y] = true;

            }

            while(!q.isEmpty()) {

                Point frnt = q.poll();

                for(i=frnt.x-1;i<=frnt.x+1;++i)

                    for(j=frnt.y-1;j<=frnt.y+1;++j)

                        if(val(i,j)&& !vis[i][j]&&(frnt.x==i||frnt.y==j)){

                            q.add(new Point(i,j));

                            last = new Point(i,j);

                            vis[i][j] = true;

                        }

            }

//          System.out.println(last.x+1 + "" "" +(last.y+1));

            out.write(last.x+1 + "" "" +(last.y+1)+""\n"");

            out.flush();

            out.close();

        } catch (Exception e) {



        }

    }

    

    boolean val(int x,int y){

        return x>=0&&x<n&&y>=0&&y<m;

    }

    public static void main(String[] args) {

        new FireAgain().run();

    }



}

",0035_C,CODEFORCES,3873,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"import java.util.*;
import java.math.*;
import java.io.*;
public class Main
	{
	public static void main(String args[])	throws IOException
		{
		Scanner c=new Scanner(System.in);
		int n=c.nextInt();
		int a=c.nextInt();		//higher
		int b=c.nextInt();		//lower
		int C[]=new int[n];
		for(int i=0;i<n;i++) 
			C[i]=c.nextInt();
		Arrays.sort(C);
		//System.out.println(Arrays.toString(C));
		int petya=C[n-a];
		System.out.println((C[n-a]-C[n-a-1]));
		}
	}

//must declare new classes here",0169_A,CODEFORCES,2579,Chores,"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do n chores. Each chore is characterized by a single parameter — its complexity. The complexity of the i-th chore equals hi.
As Petya is older, he wants to take the chores with complexity larger than some value x (hi > x) to leave to Vasya the chores with complexity less than or equal to x (hi ≤ x). The brothers have already decided that Petya will do exactly a chores and Vasya will do exactly b chores (a + b = n).
In how many ways can they choose an integer x so that Petya got exactly a chores and Vasya got exactly b chores?
The first input line contains three integers n, a and b (2 ≤ n ≤ 2000; a, b ≥ 1; a + b = n) — the total number of chores, the number of Petya's chores and the number of Vasya's chores.
The next line contains a sequence of integers h1, h2, ..., hn (1 ≤ hi ≤ 109), hi is the complexity of the i-th chore. The numbers in the given sequence are not necessarily different.
All numbers on the lines are separated by single spaces.
Print the required number of ways to choose an integer value of x. If there are no such ways, print 0.
","input
In the first sample the possible values of x are 3, 4 or 5.
output
In the second sample it is impossible to find such x, that Petya got 3 chores and Vasya got 4.
",sortings,4
"import java.io.*;
import java.util.*;
import java.math.*;
 
public class Main {
	static int t,m,mod=998244353,maxn=1000000,q,n,k;
    static int INF=(int)1e8;
    
    void solve(PrintWriter out, Reader in) throws IOException{
        n = in.nextInt();
        m = in.nextInt();
        
        String str = in.next();
        int[][] pre = new int[1<<m][m];
        
        int child=0,head,child2=0;
        for(int i=0;i<n;i++){
            if(i!=0) child = 1<<(str.charAt(i-1)-'a');
            if(i!=n-1) child2 = 1<<(str.charAt(i+1)-'a');
            head = str.charAt(i)-'a';
            
            if(i!=0) pre[child][head]++;
            if(i!=n-1) pre[child2][head]++;
        }
        
        //pre[child][head] - number of elemnts that exists in child and are adjacent to head in the string.
        
        int rmv=0;
        for(int i=0;i<m;i++){
            head = i;
            for(int j=1;j<1<<m;j++){
                if(pre[j][i]!=0) continue;
                
                rmv = j-(j&-j);
                pre[j][head] = pre[rmv][head]+pre[j^rmv][head];
            }
        }
        
        
        int[] dp = new int[1<<m];
        for(int i=1;i<1<<m;i++) dp[i] = INF;
        
        // dp[mask] - the minimum cost using a permutation of the set bits in the mask.
        
        int bit=0,full=(1<<m)-1,cnt=0;
        for(int j=1;j<1<<m;j++){
            for(int i=0;i<m;i++){
                if(((1<<i)&j)!=0){
                    bit = 1<<i;
                    cnt = cnt(j);
                    dp[j] = Math.min(dp[j],dp[j^bit]+pre[j^bit][i]*cnt-pre[j^full][i]*cnt);
                }
            }
        }
        
        out.println(dp[full]);
    }
    
    
    
    
    static int cnt(int x){
        int res=0;
        while(x>0){
            res+=x&1;
            x>>=1;
        }
        return res;
    }
    
    static class Reader {
 
    private InputStream mIs;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
 
    public Reader() {
        this(System.in);
    }
 
    public Reader(InputStream is) {
        mIs = is;
    }
 
    public int read() {
        if (numChars == -1) {
            throw new InputMismatchException();
 
    }
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = mIs.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0) {
                return -1;
            }
        }
        return buf[curChar++];
    }
 
    public String nextLine() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isEndOfLine(c));
        return res.toString();
    }
 
    public String next() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }
 
    double nextDouble()
    {
        return Double.parseDouble(next());
    }
 
    public long nextLong() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }
 
    public int nextInt() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }
 
    public boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }
 
    public boolean isEndOfLine(int c) {
        return c == '\n' || c == '\r' || c == -1;
    }
 
    }
    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        Reader in = new Reader();
        Main solver = new Main();
        solver.solve(out, in);
        out.flush();
        out.close();
 
    }
}",1238_E,CODEFORCES,4840,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp",7
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        static int n;
        static int m;
        static int steps;
        static long[][] distJ;
        static long[][] distI;
        static long[][][] memo;

        public void solve(int testNumber, InputReader in, OutputWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            steps = in.nextInt();
            memo = new long[n][m][steps];
            distJ = new long[n][m - 1];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m - 1; j++) {
                    distJ[i][j] = in.nextLong();
                }
            }
            distI = new long[n - 1][m];
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < m; j++) {
                    distI[i][j] = in.nextLong();
                }
            }


            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (steps % 2 != 0) {
                        out.print(-1 + "" "");
                    } else {
                        out.print(2 * lowestCost(i, j, steps / 2) + "" "");
                    }
                }
                out.println();
            }
        }

        private long lowestCost(int i, int j, int distance) {
            if (distance == 0) {
                return 0;
            }
            if (memo[i][j][distance] > 0) {
                return memo[i][j][distance];
            }

            long minDist = Long.MAX_VALUE;
            //j + 1 and j -1
            if (j < m - 1) {
                // move forward on j
                minDist = Math.min(minDist, distJ[i][j] + lowestCost(i, j + 1, distance - 1));
            }
            if (j > 0) {
                // move backward on j
                minDist = Math.min(minDist, distJ[i][j - 1] + lowestCost(i, j - 1, distance - 1));
            }

            if (i < n - 1) {
                // move forward on i
                minDist = Math.min(minDist, distI[i][j] + lowestCost(i + 1, j, distance - 1));
            }
            if (i > 0) {
                // move backward on i
                minDist = Math.min(minDist, distI[i - 1][j] + lowestCost(i - 1, j, distance - 1));
            }

            //memoize
            memo[i][j][distance] = minDist;
            return minDist;
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void println() {
            writer.println();
        }

        public void close() {
            writer.close();
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",1517_D,CODEFORCES,4203,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"//package CF;

// Div One
import java.util.*;

public class CFA_200 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		long x = sc.nextLong();
		long y = sc.nextLong();
		
		System.out.println(Wilf_tree(x, y));
		
		sc.close();
	}
	
	static long Wilf_tree(long a,long b)
	{
		if(a==0||b==0)
			return 0;
		if(a>=b)
			return a/b+Wilf_tree(a%b, b);
		else
			return b/a+Wilf_tree(a, b%a);
	}

}
",0343_A,CODEFORCES,379,Rational Resistance,"Mad scientist Mike is building a time machine in his spare time. To finish the work, he needs a resistor with a certain resistance value.
However, all Mike has is lots of identical resistors with unit resistance R0 = 1. Elements with other resistance can be constructed from these resistors. In this problem, we will consider the following as elements: 
With the consecutive connection the resistance of the new element equals R = Re + R0. With the parallel connection the resistance of the new element equals . In this case Re equals the resistance of the element being connected.
Mike needs to assemble an element with a resistance equal to the fraction . Determine the smallest possible number of resistors he needs to make such an element.
The single input line contains two space-separated integers a and b (1 ≤ a, b ≤ 1018). It is guaranteed that the fraction  is irreducible. It is guaranteed that a solution always exists.
Print a single number — the answer to the problem.
Please do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.
","input
In the first sample, one resistor is enough.
output
In the second sample one can connect the resistors in parallel, take the resulting element and connect it to a third resistor consecutively. Then, we get an element with resistance . We cannot make this element using two resistors.
","math, numbertheory",1
"import javax.swing.text.html.HTMLDocument;
import java.util.*;
import java.lang.*;
import java.io.*;

public class Solution {
    static int[][][] dp = new int[505][505][15];
    static int[][] w1 = new int[505][505];
    static int[][] w2 = new int[505][505];
    public static void main(String[] args) throws java.lang.Exception {
        out = new PrintWriter(new BufferedOutputStream(System.out));
        sc = new FastReader();
        int test = 1;
        for (int t = 0; t < test; t++) {
            solve();
        }
        out.close();
    }

    private static void solve() {
        int n = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m - 1; j++) {
                w1[i][j] = sc.nextInt();
            }
        }
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < m; j++) {
                w2[i][j] = sc.nextInt();
            }
        }
        if (k % 2 != 0) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    out.print(-1 + "" "");
                }
                out.println();
            }
            return;
        }
        k /= 2;
        for (int x = 1; x <= k; x++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    dp[i][j][x] = Integer.MAX_VALUE;
                    if (inRange(i - 1, j, n, m)) {
                        int w = w2[i - 1][j];
                        dp[i][j][x] = Math.min(dp[i][j][x], dp[i - 1][j][x - 1] + w);
                    }
                    if (inRange(i, j - 1, n, m)) {
                        int w = w1[i][j - 1];
                        dp[i][j][x] = Math.min(dp[i][j][x], dp[i][j - 1][x - 1] + w);
                    }
                    if (inRange(i + 1, j, n, m)) {
                        int w = w2[i][j];
                        dp[i][j][x] = Math.min(dp[i][j][x], dp[i + 1][j][x - 1] + w);
                    }
                    if (inRange(i, j + 1, n, m)) {
                        int w = w1[i][j];
                        dp[i][j][x] = Math.min(dp[i][j][x], dp[i][j + 1][x - 1] + w);
                    }
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int boredness = dp[i][j][k] * 2;
                out.print(boredness + "" "");
            }
            out.println();
        }
    }

    private static boolean inRange(int i, int j, int n, int m) {
        if (i < 0 || i >= n || j < 0 || j >= m) {
            return false;
        }
        return true;
    }

    public static FastReader sc;
    public static PrintWriter out;
    static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;

        public FastReader()
        {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt()
        {
            return Integer.parseInt(next());
        }

        long nextLong()
        {
            return Long.parseLong(next());
        }

        double nextDouble()
        {
            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
}",1517_D,CODEFORCES,4235,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.io.IOException;

/**
 * Created by ww on 13.02.2016.
 */
public class rgb {


    public static void main(String[] args) throws IOException {
        System.out.print(25);
        return ;

    }
}
",0630_A,CODEFORCES,524,Again Twenty Five!,"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. ""Do I give such a hard task?"" — the HR manager thought. ""Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.""
Could you pass the interview in the machine vision company in IT City?
","input
The only line of the input contains a single integer n (2 ≤ n ≤ 2·1018) — the power in which you need to raise number 5.
output
Output the last two digits of 5n without spaces between them.
",numbertheory,1
"import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	int[] data = parseInts(in.readLine().split("" ""));
	int n = data[0];
	int m = data[1];
	List<Integer> riders = new ArrayList<>(n);
	NavigableMap<Integer, Integer> drivers = new TreeMap<>();	
	{
	    int[] xs = parseInts(in.readLine().split("" ""));
	    int[] ts = parseInts(in.readLine().split("" ""));
	    for (int i = 0; i < ts.length; i++) {
		if (ts[i] == 1) {
		    drivers.put(xs[i], 0);
		} else {
		    riders.add(xs[i]);
		}
	    }
	}
	for (int r : riders) {
	    int distLeft = Integer.MAX_VALUE;
	    Integer left = drivers.lowerKey(r);
	    if (left != null) {
		distLeft = r - left;
	    }
	    int distRight = Integer.MAX_VALUE;
	    Integer right = drivers.higherKey(r);
	    if (right != null) {
		distRight = right - r;
	    }
	    if (distLeft <= distRight) {
		drivers.put(left, drivers.get(left) + 1);
	    } else {
		drivers.put(right, drivers.get(right) + 1);
	    }
	}
	PrintWriter out = new PrintWriter(System.out);
	Iterator<Integer> it = drivers.values().iterator();
	out.print(it.next());
	while (it.hasNext()) {
	    out.print(' ');
	    out.print(it.next());
	}
	out.println();
	out.close();
    }

    private static int[] parseInts(String[] numerals) {
	int[] xs = new int[numerals.length];
	for (int i = 0; i < numerals.length; i++) {
	    xs[i] = Integer.parseInt(numerals[i]);
	}
	return xs;
    }
}
",1075_B,CODEFORCES,2095,Taxi drivers and Lyft,"Palo Alto is an unusual city because it is an endless coordinate line. It is also known for the office of Lyft Level 5.
Lyft has become so popular so that it is now used by all $$$m$$$ taxi drivers in the city, who every day transport the rest of the city residents — $$$n$$$ riders.
Each resident (including taxi drivers) of Palo-Alto lives in its unique location (there is no such pair of residents that their coordinates are the same).
The Lyft system is very clever: when a rider calls a taxi, his call does not go to all taxi drivers, but only to the one that is the closest to that person. If there are multiple ones with the same distance, then to taxi driver with a smaller coordinate is selected.
But one morning the taxi drivers wondered: how many riders are there that would call the given taxi driver if they were the first to order a taxi on that day? In other words, you need to find for each taxi driver $$$i$$$ the number $$$a_{i}$$$ — the number of riders that would call the $$$i$$$-th taxi driver when all drivers and riders are at their home?
The taxi driver can neither transport himself nor other taxi drivers.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n,m \le 10^5$$$) — number of riders and taxi drivers.
The second line contains $$$n + m$$$ integers $$$x_1, x_2, \ldots, x_{n+m}$$$ ($$$1 \le x_1 < x_2 < \ldots < x_{n+m} \le 10^9$$$), where $$$x_i$$$ is the coordinate where the $$$i$$$-th resident lives. 
The third line contains $$$n + m$$$ integers $$$t_1, t_2, \ldots, t_{n+m}$$$ ($$$0 \le t_i \le 1$$$). If $$$t_i = 1$$$, then the $$$i$$$-th resident is a taxi driver, otherwise $$$t_i = 0$$$.
It is guaranteed that the number of $$$i$$$ such that $$$t_i = 1$$$ is equal to $$$m$$$.
Print $$$m$$$ integers $$$a_1, a_2, \ldots, a_{m}$$$, where $$$a_i$$$ is the answer for the $$$i$$$-th taxi driver. The taxi driver has the number $$$i$$$ if among all the taxi drivers he lives in the $$$i$$$-th smallest coordinate (see examples for better understanding).
In the first example, we have only one taxi driver, which means an order from any of $$$n$$$ riders will go to him.
","input
In the second example, the first taxi driver lives at the point with the coordinate $$$2$$$, and the second one lives at the point with the coordinate $$$6$$$. Obviously, the nearest taxi driver to the rider who lives on the $$$3$$$ coordinate is the first one, and to the rider who lives on the coordinate $$$5$$$ is the second one. The rider who lives on the $$$4$$$ coordinate has the same distance to the first and the second taxi drivers, but since the first taxi driver has a smaller coordinate, the call from this rider will go to the first taxi driver.
output
In the third example, we have one rider and the taxi driver nearest to him is the fourth one.
","implementation, sortings",3
"import java.io.*;
import java.util.*;
import java.util.stream.*;

public class ProblemF {
    private static boolean debug = false;

    private static int N;
    private static int[] A;

    private static void solveProblem(InputStream instr) throws Exception {
        InputReader sc = new InputReader(instr);
        int testCount = 1;
        if (debug) {
            testCount = sc.nextInt();
        }

        for (int t = 1; t <= testCount; t++) {
            printDebug(""------ "" + t + "" ------"");
            N = sc.nextInt();
            A = readInts(sc, N);
            Object result = solveTestCase();
            System.out.println(result);
        }
    }

    private static Object solveTestCase() {
        int sum[] = new int[N];
        sum[0] = A[0];
        for (int i = 1; i < N; i++) {
            sum[i] = sum[i - 1] + A[i];
        }
        Map<Integer, List<int[]>> map = new HashMap<>();
        for (int i = 0; i < N; i++) {
            for (int j = i; j < N; j++) {
                int groupSum = sum[j] - (i == 0 ? 0 : sum[i - 1]);
                map.putIfAbsent(groupSum, new ArrayList<>());
                map.get(groupSum).add(new int[]{i, j});
            }
        }
        int max = -1;
        List<int[]> maxAnswer = null;
        for (Map.Entry<Integer, List<int[]>> entry : map.entrySet()) {
            List<int[]> values = entry.getValue();
            if (values.size() <= max) {
                continue;
            }
            List<int[]> curr = findMax(values);
            if (curr.size() > max) {
                max = curr.size();
                maxAnswer = curr;

            }
        }
        List<String> answer = new ArrayList<>();
        for (int[] value : maxAnswer) {
            answer.add((value[0] + 1) + "" "" + (value[1] + 1));
        }
        return max + ""\n"" + joinValues(answer, ""\n"");
    }

    private static List<int[]> findMax(List<int[]> values) {
        values.sort(new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[1] - o2[1];
            }
        });
        List<int[]> answer = new ArrayList<>();
        int right = -1;
        for (int i = 0; i < values.size(); i++) {
            int[] value = values.get(i);
            if (value[0] > right) {
                answer.add(value);
                right = value[1];
            }
        }
        return answer;
    }

    private static int[] readInts(InputReader sc, int N) throws Exception {
        int[] arr = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = sc.nextInt();
        }
        return arr;
    }

    private static String joinValues(List<? extends Object> list, String delim) {
        return list.stream().map(Object::toString).collect(Collectors.joining(delim));
    }

    private static String joinValues(int[] arr, String delim) {
        List<Object> list = new ArrayList<>();
        for (Object value : arr) {
            list.add(value);
        }
        return list.stream().map(Object::toString).collect(Collectors.joining(delim));
    }

    public static void printDebug(Object str) {
        if (debug) {
            System.out.println(""DEBUG: "" + str);
        }
    }

    private static final class InputReader {
        private final InputStream stream;
        private final byte[] buf = new byte[1024];
        private int curChar;
        private int Chars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        private int read() throws Exception {
            if (curChar >= Chars) {
                curChar = 0;
                Chars = stream.read(buf);
                if (Chars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public final int nextInt() throws Exception {
            return (int)nextLong();
        }

        public final long nextLong() throws Exception {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
                if (c == -1)
                    throw new IOException();
            }
            boolean negative = false;
            if (c == '-') {
                negative = true;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += (c - '0');
                c = read();
            } while (!isSpaceChar(c));
            return negative ? (-res) : (res);
        }

        public final int[] nextIntBrray(int size) throws Exception {
            int[] arr = new int[size];
            for (int i = 0; i < size; i++)
                arr[i] = nextInt();
            return arr;
        }

        public final String next() throws Exception {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.append((char)c);
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public final String nextLine() throws Exception {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.append((char)c);
                c = read();
            } while (c != '\n' && c != -1);
            return res.toString();
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
    }

    public static void main(String[] args) throws Exception {
        long currTime = System.currentTimeMillis();
        if (debug) {
            solveProblem(new FileInputStream(new File(""input.in"")));
            System.out.println(""Time: "" + (System.currentTimeMillis() - currTime));
        } else {
            solveProblem(System.in);
        }
    }

}
",1141_F2,CODEFORCES,3346,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"import java.util.Scanner;

public class explorer_space {

    static int mainarr[][][] ;

    static int dp(int hori_top[][], int ver_top[][] , int i , int j, int n , int m , int k) {
        if(k==0) {
            return 0 ;
        }
        int up = 10000000 ;
        int down = 10000000 ;
        int l_side = 10000000 ;
        int r_side = 10000000 ;
        if(i>= 1){
            int t = mainarr[i-1][j][k-1] == -1 ? dp(hori_top, ver_top, i-1, j, n, m, k-1) : mainarr[i-1][j][k-1] ;
            up = ver_top[i-1][j] + t ;
            mainarr[i-1][j][k-1] = t ;
        }
        if(i!=n-1){
            int t = mainarr[i+1][j][k-1] == -1 ? dp(hori_top, ver_top, i+1, j, n, m, k-1) : mainarr[i+1][j][k-1] ;
            down = ver_top[i][j] + t ;
            mainarr[i+1][j][k-1] = t ;
        }
        if(j>=1) {
            int t = mainarr[i][j-1][k-1] == -1 ? dp(hori_top, ver_top, i, j-1, n, m, k-1) : mainarr[i][j-1][k-1] ;
            l_side = hori_top[i][j-1] +t ;
            mainarr[i][j-1][k-1] = t ;
        }
        if(j!=m-1) {
            int t = mainarr[i][j+1][k-1] == -1 ? dp(hori_top, ver_top, i, j+1, n, m, k-1) : mainarr[i][j+1][k-1]  ;
            r_side = hori_top[i][j] + t ;
            mainarr[i][j+1][k-1] = t ; 
        }
        int upm = Math.min(up, down) ;
        int side = Math.min(l_side, r_side) ;
        return Math.min(upm, side) ;
    }
    public static void main(String[] args) {
        Scanner s = new Scanner (System.in) ;
        int n = s.nextInt() ;
        int m = s.nextInt() ;
        int k = s.nextInt() ;
        int hori_top[][] = new int [n][m-1] ;
        int ver_top[][] = new int [n-1][m] ;
        for(int i=0 ; i<n ; i++) {
            for(int j=0 ; j<m-1 ; j++) {
                hori_top[i][j] = s.nextInt() ;
            }
        }

        if(k%2 == 0) {
            mainarr = new int[n][m][k/2] ;
            for(int i=0 ; i<n ; i++) {
                for(int j=0 ; j<m ; j++) {
                    for(int l=0 ; l<k/2 ; l++) {
                        mainarr[i][j][l] = -1 ;
                    }
                }
            }
        }

        for(int i=0 ; i<n-1 ; i++) {
            for(int j=0 ; j<m ; j++) {
                ver_top[i][j] = s.nextInt() ;
            }
        }

        for(int i=0 ; i<n ; i++) {
            for(int j=0 ; j<m ; j++) {
                if(k%2 != 0){
                    System.out.print(-1 + "" "");
                }
                else {
                    System.out.print(2*dp(hori_top , ver_top , i , j , n , m , k/2) + "" "");
                }
            }
            System.out.println();
        }
    }
}
",1517_D,CODEFORCES,4280,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author prakhar897
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        APaintTheNumbers solver = new APaintTheNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class APaintTheNumbers {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.nextInt();
            int arr[] = in.nextIntArray(n);
            Arrays.sort(arr);
            int ans = 0;
            for (int i = 0; i < n; i++) {
                if (arr[i] == -1)
                    continue;
                else {
                    //out.println(arr[i]);
                    ans++;
                    for (int j = i + 1; j < n; j++) {
                        if (arr[j] % arr[i] == 0)
                            arr[j] = -1;
                    }
                    arr[i] = -1;
                    //out.println(arr);
                }
            }
            out.println(ans);
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public int[] nextIntArray(int n) {
            int[] array = new int[n];
            for (int i = 0; i < n; ++i) array[i] = nextInt();
            return array;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void println(int i) {
            writer.println(i);
        }

    }
}

",1209_A,CODEFORCES,3574,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"import java.util.*;

public class Main {
	
	public static class node implements Comparable<node>{
		int l,r;
		node(){}
		node(int l,int r) {
			this.l=l;
			this.r=r;
		}
		@Override
		public int compareTo(node rhs) {
			return r-rhs.r;
		}
	}
	
	public static void main(String args[]){
		Scanner in = new Scanner(System.in);
		int a = in.nextInt();
		int x[] = new int[a];
		for(int n=0;n<a;n++){
			x[n] = in.nextInt();
		}
		int max = 1;
		int t = 0;
		HashMap<Integer, ArrayList<node>> map = new HashMap<Integer, ArrayList<node>>();
		for(int n=0;n<a;n++){
			int num = 0;
			for(int m=n;m<a;m++){
				num += x[m];
				node node = new node(n, m);
				if(!map.containsKey(num)){
					ArrayList<node> list = new ArrayList<node>();
					list.add(node);
					map.put(num, list);
					if(max == 1)t = num;
				}
				else{
					ArrayList<node> list = map.get(num);
					int left = 0;
					int right = list.size()-1;				
					int res = list.size();
					while(left <= right){
						int mid = (left + right) >> 1;
						//System.out.println(mid +"" ""+ left +"" "" +right);
						if(list.get(mid).r >= n){
							res = mid;
							right = mid - 1;
						}
						else{
							left = mid + 1;
						}
					}
					if(res == list.size()){
						list.add(node);
						if(max < res+1){
							max = res+1;
							t = num;
						}
					}
					else if(list.get(res).r>m){
						list.set(res, node);
						if(max < res){
							max = list.size();
							t = num;
						}
					}
					
				}
			}
		}
		System.out.println(max);
		for(int n=0;n<max;n++){
			System.out.println((map.get(t).get(n).l+1)+"" ""+(map.get(t).get(n).r+1));
		}
		
	}
}",1141_F2,CODEFORCES,3362,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"import java.util.Scanner;
import java.util.ArrayList;
import java.util.Collections;
public class Paint_The_Numbers {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		ArrayList<Integer> paint = new ArrayList<Integer>();
		int num = scan.nextInt();
		for(int i = 0; i < num;i++)
			paint.add(scan.nextInt());
		Collections.sort(paint);
		int counter = 0;
		//System.out.println(paint);
		while(paint.size()!=0) {
			num = paint.remove(0);
			for(int i = 0; i<paint.size();i++) {
				if(paint.get(i)%num==0) {
					paint.remove(i--);
				}
			}
			counter++;
		}
		System.out.println(counter);
	}

}
",1209_A,CODEFORCES,3570,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"
import java.util.*;


public class E
{
   public static void main(String[] args)
   {
      new E(new Scanner(System.in));
   }


   public E(Scanner in)
   {
      int N = in.nextInt();
      double[][] g = new double[N][N];

      for (int j=0; j<N; j++)
         for (int i=0; i<N; i++)
            g[i][j] = in.nextDouble();

      double[] memo = new double[1<<N];
      memo[(1<<N)-1] = 1.0;
      
      for (int m=(1<<N)-1; m>0; m--)
      {
         int cnt = 0;
         for (int i=0; i<N; i++)
         {
            int m1 = 1 << i;
            if ((m1&m) > 0)
               cnt++;
         }

         int sum = (cnt*(cnt-1))/2;
         for (int i=0; i<N; i++)
         {
            int m1 = 1 << i;
            if ((m1&m) == 0) continue;

            for (int j=i+1; j<N; j++)
            {
               int m2 = 1 << j;
               if ((m2&m) == 0) continue;
               
               memo[m-m1] += (g[i][j]*memo[m])/sum;
               memo[m-m2] += (g[j][i]*memo[m])/sum;
            }
         }
      }

      StringBuilder sb = new StringBuilder();
      for (int i=0; i<N; i++)
      {
         double res = memo[1<<i];
         sb.append(String.format(""%.8f"", res));
         sb.append(' ');
      }
      System.out.println(sb.toString().trim());
   }
}
",0016_E,CODEFORCES,4471,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"import java.util.*;
import java.io.*;
import java.awt.Point;
import java.math.BigDecimal;
import java.math.BigInteger;

import static java.lang.Math.*;

// Solution is at the bottom of code

public class B implements Runnable{
	
	final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;
	
	BufferedReader in;
	OutputWriter out;
	StringTokenizer tok = new StringTokenizer("""");
	
	public static void main(String[] args){
		new Thread(null, new B(), """", 128 * (1L << 20)).start();
	}
	
	/////////////////////////////////////////////////////////////////////
	
	void init() throws FileNotFoundException{
		Locale.setDefault(Locale.US);
		
		if (ONLINE_JUDGE){
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new OutputWriter(System.out);
		}else{
			in = new BufferedReader(new FileReader(""input.txt""));
			out = new OutputWriter(""output.txt"");
		}
	}
	
	////////////////////////////////////////////////////////////////
	
	long timeBegin, timeEnd;

	void time(){
		timeEnd = System.currentTimeMillis();
		System.err.println(""Time = "" + (timeEnd - timeBegin));
	}
	
	void debug(Object... objects){
		if (ONLINE_JUDGE){
			for (Object o: objects){
				System.err.println(o.toString());
			}
		}
	}
	
	/////////////////////////////////////////////////////////////////////
	
	public void run(){
		try{
			timeBegin = System.currentTimeMillis();
			Locale.setDefault(Locale.US);
			
			init();
			solve();
			
			out.close();
			time();
		}catch (Exception e){
			e.printStackTrace(System.err);
			System.exit(-1);
		}
	}
	
	/////////////////////////////////////////////////////////////////////
	
	String delim = "" "";
	
	String readString() throws IOException{
		while(!tok.hasMoreTokens()){
			try{
				tok = new StringTokenizer(in.readLine());
			}catch (Exception e){
				return null;
			}
		}
		
		return tok.nextToken(delim);
	}
	
	String readLine() throws IOException{
		return in.readLine();
	}
	
	/////////////////////////////////////////////////////////////////
	
	final char NOT_A_SYMBOL = '\0';
	
	char readChar() throws IOException{
		int intValue = in.read();
		
		if (intValue == -1){
			return NOT_A_SYMBOL;
		}
		
		return (char) intValue;
	}
	
	char[] readCharArray() throws IOException{
		return readLine().toCharArray();
	}
	
	/////////////////////////////////////////////////////////////////
	
	int readInt() throws IOException {
		return Integer.parseInt(readString());
	}
	
	int[] readIntArray(int size) throws IOException {
		int[] array = new int[size];
		
		for (int index = 0; index < size; ++index){
			try {
				array[index] = readInt();
			} catch (Exception e) {
				System.err.println(index);
				return null;
			}
		}
		
		return array;
	}
	
	int[] readSortedIntArray(int size) throws IOException {
		Integer[] array = new Integer[size];
		
		for (int index = 0; index < size; ++index) {
			array[index] = readInt();
		}
		Arrays.sort(array);
		
		int[] sortedArray = new int[size];
		for (int index = 0; index < size; ++index) {
			sortedArray[index] = array[index];
		}
		
		return sortedArray;
	}
	
	int[] readIntArrayWithDecrease(int size) throws IOException {
		int[] array = readIntArray(size);
		
		for (int i = 0; i < size; ++i) {
			array[i]--;
		}
		
		return array;
	}
	
	///////////////////////////////////////////////////////////////////
	
	int[][] readIntMatrix(int rowsCount, int columnsCount) throws IOException {
		int[][] matrix = new int[rowsCount][];
		
		for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {
			matrix[rowIndex] = readIntArray(columnsCount);
		}
		
		return matrix;
	}
	
	int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) throws IOException {
		int[][] matrix = new int[rowsCount][];
		
		for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {
			matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);
		}
		
		return matrix;
	}
	
	///////////////////////////////////////////////////////////////////
	
	long readLong() throws IOException{
		return Long.parseLong(readString());
	}
	
	long[] readLongArray(int size) throws IOException{
		long[] array = new long[size];
		
		for (int index = 0; index < size; ++index){
			array[index] = readLong();
		}
		
		return array;
	}
	
	////////////////////////////////////////////////////////////////////
	
	double readDouble() throws IOException{
		return Double.parseDouble(readString());
	}
	
	double[] readDoubleArray(int size) throws IOException{
		double[] array = new double[size];
		
		for (int index = 0; index < size; ++index){
			array[index] = readDouble();
		}
		
		return array;
	}
	
	////////////////////////////////////////////////////////////////////
		
	BigInteger readBigInteger() throws IOException {
		return new BigInteger(readString());
	}
	
	BigDecimal readBigDecimal() throws IOException {
		return new BigDecimal(readString());
	}
	
	/////////////////////////////////////////////////////////////////////
	
	Point readPoint() throws IOException{
		int x = readInt();
		int y = readInt();
		return new Point(x, y);
	}
	
	Point[] readPointArray(int size) throws IOException{
		Point[] array = new Point[size];
		
		for (int index = 0; index < size; ++index){
			array[index] = readPoint();
		}
		
		return array;
	}
	
	/////////////////////////////////////////////////////////////////////
	
	List<Integer>[] readGraph(int vertexNumber, int edgeNumber)
	throws IOException{
		@SuppressWarnings(""unchecked"")
		List<Integer>[] graph = new List[vertexNumber];
		
		for (int index = 0; index < vertexNumber; ++index){
			graph[index] = new ArrayList<Integer>();
		}
		
		while (edgeNumber-- > 0){
			int from = readInt() - 1;
			int to = readInt() - 1;
			
			graph[from].add(to);
			graph[to].add(from);
		}
		
		return graph;
	}
	
	/////////////////////////////////////////////////////////////////////
	
	static class IntIndexPair {
		
		static Comparator<IntIndexPair> increaseComparator = new Comparator<B.IntIndexPair>() {
			
			@Override
			public int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {
				int value1 = indexPair1.value;
				int value2 = indexPair2.value;
				
				if (value1 != value2) return value1 - value2;
				
				int index1 = indexPair1.index;
				int index2 = indexPair2.index;
				
				return index1 - index2;
			}
		};
		
		static Comparator<IntIndexPair> decreaseComparator = new Comparator<B.IntIndexPair>() {
			
			@Override
			public int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {
				int value1 = indexPair1.value;
				int value2 = indexPair2.value;
				
				if (value1 != value2) return -(value1 - value2);
				
				int index1 = indexPair1.index;
				int index2 = indexPair2.index;
				
				return index1 - index2;
			}
		};
		
		int value, index;

		public IntIndexPair(int value, int index) {
			super();
			this.value = value;
			this.index = index;
		}		
		
		public int getRealIndex() {
			return index + 1;
		}
	}
	
	IntIndexPair[] readIntIndexArray(int size) throws IOException {
		IntIndexPair[] array = new IntIndexPair[size];
		
		for (int index = 0; index < size; ++index) {
			array[index] = new IntIndexPair(readInt(), index);
		}
		
		return array;
	}
	
	/////////////////////////////////////////////////////////////////////
	
	static class OutputWriter extends PrintWriter {

		final int DEFAULT_PRECISION = 12;
		
		protected int precision;
		protected String format, formatWithSpace;
		
		{
			precision = DEFAULT_PRECISION;
			
			format = createFormat(precision);
			formatWithSpace = format + "" "";
		}
		
		public OutputWriter(OutputStream out) {
			super(out);
		}

		public OutputWriter(String fileName) throws FileNotFoundException {
			super(fileName);
		}
		
		public int getPrecision() {
			return precision;
		}

		public void setPrecision(int precision) {
			precision = max(0, precision);
			this.precision = precision;
			
			format = createFormat(precision);
			formatWithSpace = format + "" "";
		}
		
		private String createFormat(int precision){
			return ""%."" + precision + ""f"";
		}
		
		@Override
		public void print(double d){
			printf(format, d);
		}
		
		public void printWithSpace(double d){
			printf(formatWithSpace, d);
		}

		public void printAll(double...d){
			for (int i = 0; i < d.length - 1; ++i){
				printWithSpace(d[i]);
			}
			
			print(d[d.length - 1]);
		}
		
		@Override
		public void println(double d){
			printlnAll(d);
		}
		
		public void printlnAll(double... d){
			printAll(d);
			println();
		}
	}
	
	/////////////////////////////////////////////////////////////////////
	
	static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; 
	static final int[][] steps8 = {
			{-1, 0}, {1, 0}, {0, -1}, {0, 1},
			{-1, -1}, {1, 1}, {1, -1}, {-1, 1}
	};
	
	static final boolean check(int index, int lim){
		return (0 <= index && index < lim);
	}
	
	/////////////////////////////////////////////////////////////////////
	
	static final boolean checkBit(int mask, int bit){
		return (mask & (1 << bit)) != 0;
	}
	
	/////////////////////////////////////////////////////////////////////
	
	static final long getSum(int[] array) {
		long sum = 0;
		for (int value: array) {
			sum += value;
		}
		
		return sum;
	}
	
	static final Point getMinMax(int[] array) {
		int min = array[0];
		int max = array[0];
		
		for (int index = 0, size = array.length; index < size; ++index, ++index) {
			int value = array[index];
			
			if (index == size - 1) {
				min = min(min, value);
				max = max(max, value);
			} else {
				int otherValue = array[index + 1];
				
				if (value <= otherValue) {
					min = min(min, value);
					max = max(max, otherValue);
				} else {
					min = min(min, otherValue);
					max = max(max, value);
				}
			}
		}
		
		return new Point(min, max);
	}
	
	/////////////////////////////////////////////////////////////////////
	
	void solve() throws IOException {
		int n = readInt();
		
		int a = readInt();
		int b = readInt();
		
		Map<Integer, Integer> numbers = new HashMap<>();
		int[] p = readIntArray(n);
		for (int index = 0; index < n; ++index) {
			numbers.put(p[index], index);
		}
		
		Set<Integer> used = new HashSet<Integer>();
		Deque<Integer> q = new ArrayDeque<Integer>();
		
		int[] answers = new int[n];
		for (int i = 0; i < n; ++i) {
			if (used.contains(p[i])) continue;
			
			int leftSize = 0;
			for (int number = p[i], cur = a, next = b;
					numbers.containsKey(number) && !used.contains(number);
					number = cur - number, cur = (a ^ b ^ cur), next = (a ^ b ^ next)) {
				q.addFirst(number);
				used.add(number);
				
				++leftSize;
			}
			
			for (int number = b - p[i], cur = a, next = b;
					numbers.containsKey(number) && !used.contains(number);
					number = cur - number, cur = (a ^ b ^ cur), next = (a ^ b ^ next)) {
				q.addLast(number);
				used.add(number);
			}
			
			int curColor = (leftSize & 1);
			if ((q.size() & 1) == 1) {
				int first = q.peekFirst();
				
				// 0 - a, 1 - b
				if (curColor == 0 && (first << 1) == b
						||
					curColor == 1 && (first << 1) == a) {
					q.poll();
					
					curColor ^= 1;
					
					int firstIndex = numbers.get(first);
					answers[firstIndex] = curColor;
				} else {
					int last = q.peekLast();
					
					// 0 - b, 1 - a
					if (curColor == 0 && (last << 1) == a
							||
						curColor == 1 && (first << 1) == b) {
						q.poll();
						
						int firstIndex = numbers.get(first);
						answers[firstIndex] = curColor;
					} else {
						out.println(""NO"");
						return;
					}
				}
			}
			
			while (q.size() > 0) {
				int first = q.poll();
				int second = q.poll();
				
				int firstIndex = numbers.get(first);
				int secondIndex = numbers.get(second);
				
				answers[firstIndex] = curColor;
				answers[secondIndex] = curColor;
			}
		}
		
		out.println(""YES"");
		for (int answer : answers) {
			out.print(answer + "" "");
		}
		out.println();
	}
}

",0468_B,CODEFORCES,1724,Two Sets,"Little X has n distinct integers: p1, p2, ..., pn. He wants to divide all of them into two sets A and B. The following two conditions must be satisfied:
Help Little X divide the numbers into two sets or determine that it's impossible.
The first line contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The next line contains n space-separated distinct integers p1, p2, ..., pn (1 ≤ pi ≤ 109).
If there is a way to divide the numbers into two sets, then print ""YES"" in the first line. Then print n integers: b1, b2, ..., bn (bi equals either 0, or 1), describing the division. If bi equals to 0, then pi belongs to set A, otherwise it belongs to set B.
","input
If it's impossible, print ""NO"" (without the quotes).
output
It's OK if all the numbers are in the same set, and the other one is empty.
","2-sat, dfsandsimilar, dsu, graphmatchings, greedy",3
"import java.util.*;
import java.text.*;
import java.io.*;
import java.math.*;
public class code5 {
	InputStream is;
	PrintWriter out;
	static long mod=pow(10,9)+7;
	static int dx[]={0,0,1,-1},dy[]={1,-1,0,0};
	String arr[];
	long dp[][];
	void solve() throws IOException
	{
		int n=ni();
		int a[]=na(n);
		int q=ni();
		boolean flag=false;
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<i;j++)
			{
				if(a[j]>a[i])
					flag^=true;
			}
		}
		while(q--!=0)
		{
			int l=ni()-1;
			int r=ni()-1;
			int num=(r-l+1);
			int tot=num*(num-1)/2;
			if(tot%2==1)
				flag^=true;
			if(flag)
				out.println(""odd"");
			else
				out.println(""even"");			
		}
	}
	int sum(int i)
	{
		int sum=0;
		while(i!=0)
		{
			if((i%10)%2==1)
				sum+=i%10;
			i/=10;
		}
		return sum;
	}
	ArrayList<Integer> al[];
 	void take(int n,int m)
 	{
 		al=new ArrayList[n];
 		for(int i=0;i<n;i++)
 			al[i]=new ArrayList<Integer>();
 		for(int i=0;i<m;i++)
 		{
 			int x=ni()-1;
 			int y=ni()-1;
 			al[x].add(y);
 			al[y].add(x);
 		}
 	}
 	int check(long n)
 	{
 		int count=0;
 		while(n!=0)
 		{
 			if(n%10!=0)
 				break;
 			n/=10;
 			count++;
 		}
 		return count;
 	}
	public static int count(int x)
	{
		int num=0;
		while(x!=0)
		{
			x=x&(x-1);
			num++;
		}
		return num;
	}
	static long d, x, y;
	void extendedEuclid(long A, long B) {
	    if(B == 0) {
	        d = A;
	        x = 1;
	        y = 0;
	    }
	    else {
	        extendedEuclid(B, A%B);
	        long temp = x;
	        x = y;
	        y = temp - (A/B)*y;
	    }
	}
	long modInverse(long A,long M) //A and M are coprime
	{
	    extendedEuclid(A,M);
	    return (x%M+M)%M;    //x may be negative
	}
	public static void mergeSort(int[] arr, int l ,int r){
		if((r-l)>=1){
			int mid = (l+r)/2;
			mergeSort(arr,l,mid);
			mergeSort(arr,mid+1,r);
			merge(arr,l,r,mid);
		}
	}
	public static void merge(int arr[], int l, int r, int mid){
		int n1 = (mid-l+1), n2 = (r-mid);
		int left[] = new int[n1];
		int right[] = new int[n2];
		for(int i =0 ;i<n1;i++) left[i] = arr[l+i];
		for(int i =0 ;i<n2;i++) right[i] = arr[mid+1+i];
		int i =0, j =0, k = l;
		while(i<n1 && j<n2){
			if(left[i]>right[j]){
				arr[k++] = right[j++];
			}
			else{
				arr[k++] = left[i++];
			}
		}
		while(i<n1) arr[k++] = left[i++];
		while(j<n2) arr[k++] = right[j++];
	}
	public static void mergeSort(long[] arr, int l ,int r){
		if((r-l)>=1){
			int mid = (l+r)/2;
			mergeSort(arr,l,mid);
			mergeSort(arr,mid+1,r);
			merge(arr,l,r,mid);
		}
	}
	public static void merge(long arr[], int l, int r, int mid){
		int n1 = (mid-l+1), n2 = (r-mid);
		long left[] = new long[n1];
		long right[] = new long[n2];
		for(int i =0 ;i<n1;i++) left[i] = arr[l+i];
		for(int i =0 ;i<n2;i++) right[i] = arr[mid+1+i];
		int i =0, j =0, k = l;
		while(i<n1 && j<n2){
			if(left[i]>right[j]){
				arr[k++] = right[j++];
			}
			else{
				arr[k++] = left[i++];
			}
		}
		while(i<n1) arr[k++] = left[i++];
		while(j<n2) arr[k++] = right[j++];
	}
	 static class Pair implements Comparable<Pair>{
		 
	       int x,y,k;
	       int i,dir;
	       long val;
		Pair (int x,int y){
			this.x=x;
			this.y=y;
		}   
		public int compareTo(Pair o) {
			if(this.x!=o.x)
				return this.x-o.x;
			return this.y-o.y;
		}
	 
		public String toString(){
			return x+"" ""+y+"" ""+k+"" ""+i;}
		public boolean equals(Object o) {
			if (o instanceof Pair) {
				Pair p = (Pair)o;
				return p.x == x && p.y == y;
			}
			return false;
		}
		public int hashCode() {
			return new Long(x).hashCode()*31 + new Long(y).hashCode() ;
		}
	} 
	    
	    public static boolean isPal(String s){
	        for(int i=0, j=s.length()-1;i<=j;i++,j--){
	                if(s.charAt(i)!=s.charAt(j)) return false;
	        }
	        return true;
	    }
	    public static String rev(String s){
			StringBuilder sb=new StringBuilder(s);
			sb.reverse();
			return sb.toString();
	    }
	    
	    public static long gcd(long x,long y){
		if(y==0)
			return x;
		else
			return gcd(y,x%y);
	    }
	    
	    public static int gcd(int x,int y){
	    	if(y==0) 
	    		return x; 
	    	return gcd(y,x%y);
	    }
	    
	    public static long gcdExtended(long a,long b,long[] x){
	        
	        if(a==0){
	            x[0]=0;
	            x[1]=1;
	            return b;
	        }
	        long[] y=new long[2];
	        long gcd=gcdExtended(b%a, a, y);
	        
	        x[0]=y[1]-(b/a)*y[0];
	        x[1]=y[0];
	        
	        return gcd;
	    }
	    
	    public static int abs(int a,int b){
		return (int)Math.abs(a-b);
	    }
	 
	    public static long abs(long a,long b){
		return (long)Math.abs(a-b);
	    }
	    
	    public static int max(int a,int b){
		if(a>b)
			return a;
		else
			return b;
	    }
	 
	    public static int min(int a,int b){
		if(a>b)
			return b;
		else 
			return a;
	    }
	    
	    public static long max(long a,long b){
		if(a>b)
			return a;
		else
			return b;
	    }
	 
	    public static long min(long a,long b){
		if(a>b)
			return b;
		else 
			return a;
	    }
	 
	    public static long pow(long n,long p,long m){
		 long  result = 1;
		  if(p==0)
		    return 1;
		if (p==1)
		    return n;
		while(p!=0)
		{
		    if(p%2==1)
		        result *= n;
		    if(result>=m)
		    result%=m;
		    p >>=1;
		    n*=n;
		    if(n>=m)
		    n%=m;
		}
		return result;
	    }
	    
	    public static long pow(long n,long p){
		long  result = 1;
		  if(p==0)
		    return 1;
		if (p==1)
		    return n;
		while(p!=0)
		{
		    if(p%2==1)
		        result *= n;	    
		    p >>=1;
		    n*=n;	    
		}
		return result;
	    }
	    public static void debug(Object... o) {
			System.out.println(Arrays.deepToString(o));
		}
	    void run() throws Exception {
			is = System.in;
			out = new PrintWriter(System.out);
			solve();
			out.flush();
		}
	   
	    public static void main(String[] args) throws Exception {
			new Thread(null, new Runnable() {
				public void run() {
					try {
						new code5().run();
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			}, ""1"", 1 << 26).start();
			
	    	//new code5().run();
		}
	    private byte[] inbuf = new byte[1024];
		public int lenbuf = 0, ptrbuf = 0;
	 
		private int readByte() {
			if (lenbuf == -1)
				throw new InputMismatchException();
			if (ptrbuf >= lenbuf) {
				ptrbuf = 0;
				try {
					lenbuf = is.read(inbuf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return -1;
			}
			return inbuf[ptrbuf++];
		}
	 
		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}
	 
		private int skip() {
			int b;
			while ((b = readByte()) != -1 && isSpaceChar(b));
			return b;
		}
	 
		private double nd() {
			return Double.parseDouble(ns());
		}
	 
		private char nc() {
			return (char) skip();
		}
	 
		private String ns() {
			int b = skip();
			StringBuilder sb = new StringBuilder();
			while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}
	 
		private char[] ns(int n) {
			char[] buf = new char[n];
			int b = skip(), p = 0;
			while (p < n && !(isSpaceChar(b))) {
				buf[p++] = (char) b;
				b = readByte();
			}
			return n == p ? buf : Arrays.copyOf(buf, p);
		}
	 
		private char[][] nm(int n, int m) {
			char[][] map = new char[n][];
			for (int i = 0; i < n; i++)
				map[i] = ns(m);
			return map;
		}
	 
		private int[] na(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = ni();
			return a;
		}
		private long[] nl(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nl();
			return a;
		}
	 
		private int ni() {
			int num = 0, b;
			boolean minus = false;
			while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
				;
			if (b == '-') {
				minus = true;
				b = readByte();
			}
	 
			while (true) {
				if (b >= '0' && b <= '9') {
					num = num * 10 + (b - '0');
				} else {
					return minus ? -num : num;
				}
				b = readByte();
			}
		}
	 
		private long nl() {
			long num = 0;
			int b;
			boolean minus = false;
			while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
				;
			if (b == '-') {
				minus = true;
				b = readByte();
			}
	 
			while (true) {
				if (b >= '0' && b <= '9') {
					num = num * 10 + (b - '0');
				} else {
					return minus ? -num : num;
				}
				b = readByte();
			}
		}
	 
}",0911_D,CODEFORCES,3145,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"//package bitManipulation;
import java.util.*;
import java.lang.*;
import java.io.*;
public class D__Little_Girl_and_Maximum_XOR {
static class FastReader {
	BufferedReader br;
	StringTokenizer st;

	public FastReader() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}

	String next() {
		while (st == null || !st.hasMoreElements()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return st.nextToken();
	}

	int nextInt() {
		return Integer.parseInt(next());
	}

	long nextLong() {
		return Long.parseLong(next());
	}

	double nextDouble() {
		return Double.parseDouble(next());
	}

	String nextLine() {
		String str = """";
		try {
			str = br.readLine();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return str;
	}

	int[] readArray(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}
}

static void ruffle_sort(int[] a) {
	//shandom_ruffle
	Random r = new Random();
	int n = a.length;
	for (int i = 0; i < n; i++) {
		int oi = r.nextInt(n);
		int temp = a[i];
		a[i] = a[oi];
		a[oi] = temp;
	}

	//sort
	Arrays.sort(a);
}

static int hcf(int a, int b) {
	if (b == 0)
		return a;
	return hcf(b, a % b);
}

static int pow(int a, int b) {
	int ans = 1;
	while (b > 0) {
		if ((b & 1) != 0)
			ans *= a;

		a = a * a;
		b = b >> 1;
	}
	return ans;
}

static void prime(List<Integer> prime, int n) {

	boolean arr[] = new boolean[n + 1];
	Arrays.fill(arr, true);
	arr[0] = arr[1] = false;
	for (int i = 2; i * i <= n; i++) {
		if (arr[i] == true) {
			//prime.add(i);
			for (int j = i * i; j < arr.length; j += i)
				arr[j] = false;
		}
	}
	for (int i = 0; i < arr.length; i++) {
		if (arr[i] == true)
			prime.add(i);
	}

}

static boolean bitcheck(long n,int i) {
return (n&(1L<<i))!=0;
}
public static void main(String[] args) throws java.lang.Exception {
	try {
		FastReader sc = new FastReader();
		PrintWriter out = new PrintWriter(System.out);
		long a=sc.nextLong();
		long b=sc.nextLong();
		int bit=62;
		while(bit>=0 && (bitcheck(a,bit)==bitcheck(b,bit)))
		{
			bit--;
		}
		//System.out.println(bit);
		long ans= (1L<<(bit+1))-1;
		System.out.println(ans);
			out.close();
	} catch (Exception e) {
	} finally {
		return;
	}
}

}
",0276_D,CODEFORCES,799,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;

public class CFC {

    BufferedReader br;
    PrintWriter out;
    StringTokenizer st;
    boolean eof;
    final long MOD = 1000L * 1000L * 1000L + 7;
    int[] dx = {0, -1, 0, 1};
    int[] dy = {1, 0, -1, 0};

    void solve() throws IOException {
        int n = nextInt();
        long[] dp0 = new long[10 + n];
        long[] dp1 = new long[10 + n];
        long[] pre = new long[10 + n];
        dp0[0] = 1;
        String[] arr = new String[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nextString();
        }
        String s = ""s"";
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp1, 0);

            if (i == 0) {
                dp0[0] = 1;
                dp1[0] = 1;
            }
            else {
                if (arr[i - 1].equals(s)) {
                    for (int j = 0; j <= n + 5; j++) {
                        dp1[j] = pre[j];
                    }
                }
                else {
                    for (int j = 1; j <= n + 5; j++) {
                        dp1[j] = dp0[j - 1];
                    }
                }
            }

            Arrays.fill(pre, 0);
            pre[n + 5] = dp1[n + 5];
            for (int j = n + 4; j >= 0; j--) {
                pre[j] = pre[j + 1] + dp1[j];
                pre[j] %= MOD;
            }

            for (int j = 0; j <= n + 5; j++) {
                dp0[j] = dp1[j];
            }
        }

        long res = 0;
        for (int j = 0; j <= n + 5; j++) {
            res += dp0[j];
            res %= MOD;
        }

        out(res);
    }

    void shuffle(int[] a) {
        int n = a.length;
        for(int i = 0; i < n; i++) {
            int r = i + (int) (Math.random() * (n - i));
            int tmp = a[i];
            a[i] = a[r];
            a[r] = tmp;
        }
    }

    int gcd(int a, int b) {
        while(a != 0 && b != 0) {
            int c = b;
            b = a % b;
            a = c;
        }
        return a + b;
    }
    private void outln(Object o) {
        out.println(o);
    }
    private void out(Object o) {
        out.print(o);
    }
    public CFC() throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);
        solve();
        out.close();
    }
    public static void main(String[] args) throws IOException {
        new CFC();
    }

    public long[] nextLongArr(int n) throws IOException{
        long[] res = new long[n];
        for(int i = 0; i < n; i++)
            res[i] = nextLong();
        return res;
    }
    public int[] nextIntArr(int n) throws IOException {
        int[] res = new int[n];
        for(int i = 0; i < n; i++)
            res[i] = nextInt();
        return res;
    }
    public String nextToken() {
        while (st == null || !st.hasMoreTokens()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (Exception e) {
                eof = true;
                return null;
            }
        }
        return st.nextToken();
    }
    public String nextString() {
        try {
            return br.readLine();
        } catch (IOException e) {
            eof = true;
            return null;
        }
    }
    public int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }
    public long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }
    public double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }
}
",0909_C,CODEFORCES,3102,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"// Don't place your source in a package
import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;






// Please name your class Main
public class Main {
    static Scanner in = new Scanner(System.in);
    public static void main (String[] args) throws java.lang.Exception {
        PrintWriter out = new PrintWriter(System.out);

        int T=1;
        for(int t=0;t<T;t++){
            int n=Int();
            int A[][]=new int[n][2];


            for(int i=0;i<n;i++){
                A[i][0]=Int();
                A[i][1]=Int();
            }

            Solution sol=new Solution();
            sol.solution(out,A);

        }
        out.flush();

    }

    public static long Long(){
        return in.nextLong();
    }
    public static int Int(){
        return in.nextInt();
    }
    public static String Str(){
        return in.next();
    }
}


class Solution{
    int dp[];
    TreeMap<Integer,Integer>tree=new TreeMap<>();
    public void solution(PrintWriter out,int A[][]){
        int res=Integer.MIN_VALUE;
        int n=A.length;
        Arrays.sort(A,(a,b)->{
            return a[0]-b[0];
        });
        dp=new int[n];
        Arrays.fill(dp,-1);

        for(int i=0;i<A.length;i++){
            tree.put(A[i][0],i);
        }


        for(int i=0;i<A.length;i++){
            res=Math.max(res,1+dfs(A,i));
        }
        System.out.println((n+1)-res);
    }

    public int dfs(int A[][],int i){
        if(dp[i]!=-1){
            return dp[i];
        }

        int pos=A[i][0];
        int pow=A[i][1];



        Integer floor=tree.floorKey(pos-pow-1);
        int res=1;
        if(floor==null){

        }
        else{
            res+=dfs(A,tree.get(floor));
        }
        dp[i]=res;
        return res;
    }

}

",0608_C,CODEFORCES,1759,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;


public class C {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        int w = in.nextInt();
        int h = in.nextInt();
        int n = in.nextInt();
        TreeSet<Integer> wt = new TreeSet<Integer>();
        wt.add(0);
        wt.add(w);
        TreeSet<Integer> ht = new TreeSet<Integer>();
        ht.add(0);
        ht.add(h);
        TreeMap<Integer, Integer> mw = new TreeMap<Integer, Integer>();
        mw.put(w, 1);
        TreeMap<Integer, Integer> mh = new TreeMap<Integer, Integer>();
        mh.put(h, 1);
        for (int i = 0; i < n; i++) {
            String s = in.next();
            int c = in.nextInt();
            if (s.charAt(0) == 'H') {
                addNewCut(mh, ht, c);
            } else {
                addNewCut(mw, wt, c);
            }
            long hl = (long)mh.lastKey();
            long wl = (long)mw.lastKey();
            out.println(hl * wl);
        }
        out.close();
    }
    
    private static void addNewCut(TreeMap<Integer, Integer> max, TreeSet<Integer> t, int cut) {
        int l = t.lower(cut);
        int h = t.higher(cut);
        int dif = h - l;
        int k = max.get(dif);
        if (k <= 1) {
            max.remove(dif);
        } else {
            max.put(dif, k - 1);
        }
        t.add(cut);
        
        Integer p = max.get(cut - l);
        if (p == null) {
            max.put(cut - l, 1);
        } else {
            max.put(cut - l, p + 1);
        }

        p = max.get(h - cut);
        if (p == null) {
            max.put(h - cut, 1);
        } else {
            max.put(h - cut, p + 1);
        }
    }
   
}

class InputReader {
public BufferedReader reader;
public StringTokenizer tokenizer;

public InputReader(InputStream stream) {
  reader = new BufferedReader(new InputStreamReader(stream), 32768);
  tokenizer = null;
}

public String next() {
  while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
          tokenizer = new StringTokenizer(reader.readLine());
      } catch (IOException e) {
          throw new RuntimeException(e);
      }
  }
  return tokenizer.nextToken();
}

public int nextInt() {
  return Integer.parseInt(next());
}

}",0527_C,CODEFORCES,2742,Glass Carving,"Leonid wants to become a glass carver (the person who creates beautiful artworks by cutting the glass). He already has a rectangular w mm  ×  h mm sheet of glass, a diamond glass cutter and lots of enthusiasm. What he lacks is understanding of what to carve and how.
In order not to waste time, he decided to practice the technique of carving. To do this, he makes vertical and horizontal cuts through the entire sheet. This process results in making smaller rectangular fragments of glass. Leonid does not move the newly made glass fragments. In particular, a cut divides each fragment of glass that it goes through into smaller fragments.
After each cut Leonid tries to determine what area the largest of the currently available glass fragments has. Since there appear more and more fragments, this question takes him more and more time and distracts him from the fascinating process.
Leonid offers to divide the labor — he will cut glass, and you will calculate the area of the maximum fragment after each cut. Do you agree?
The first line contains three integers w, h, n (2 ≤ w, h ≤ 200 000, 1 ≤ n ≤ 200 000).
Next n lines contain the descriptions of the cuts. Each description has the form H y or V x. In the first case Leonid makes the horizontal cut at the distance y millimeters (1 ≤ y ≤ h - 1) from the lower edge of the original sheet of glass. In the second case Leonid makes a vertical cut at distance x (1 ≤ x ≤ w - 1) millimeters from the left edge of the original sheet of glass. It is guaranteed that Leonid won't make two identical cuts.
","input
After each cut print on a single line the area of the maximum available glass fragment in mm2.
output
Picture for the first sample test: 
","binarysearch, datastructures, implementation",4
"import java.util.*;
public final class Solution{
    public static void main(String args[]){
        Scanner scan=new Scanner(System.in);
        int n=scan.nextInt();
        int k=scan.nextInt();
        int r=n*2;
        int g=n*5;
        int b=n*8;
        int cnt=0;
        if(r%k==0){
            cnt+=r/k;
        }
        else{
            cnt+=r/k+1;
        }
        if(g%k==0){
            cnt+=g/k;
        }
        else{
            cnt+=g/k+1;
        }
        if(b%k==0){
            cnt+=b/k;
        }
        else{
            cnt+=b/k+1;
        }
        System.out.print(cnt);
    }
}",1080_A,CODEFORCES,730,Petya and Origami,"Petya is having a party soon, and he has decided to invite his $$$n$$$ friends.
He wants to make invitations in the form of origami. For each invitation, he needs two red sheets, five green sheets, and eight blue sheets. The store sells an infinite number of notebooks of each color, but each notebook consists of only one color with $$$k$$$ sheets. That is, each notebook contains $$$k$$$ sheets of either red, green, or blue.
Find the minimum number of notebooks that Petya needs to buy to invite all $$$n$$$ of his friends.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1\leq n, k\leq 10^8$$$) — the number of Petya's friends and the number of sheets in each notebook respectively.
Print one number — the minimum number of notebooks that Petya needs to buy.
","input
In the first example, we need $$$2$$$ red notebooks, $$$3$$$ green notebooks, and $$$5$$$ blue notebooks.
output
In the second example, we need $$$5$$$ red notebooks, $$$13$$$ green notebooks, and $$$20$$$ blue notebooks.
",math,1
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.NoSuchElementException;

public class D {

    int N,M;
    int[] a,l,r;

    private void solve() {
        N = nextInt();

        a = new int[N];
        for(int i = 0;i < N;i++) {
            a[i] = nextInt();
        }

        M = nextInt();

        l = new int[M];
        r = new int[M];
        for(int i = 0;i < M;i++) {
            l[i] = nextInt();
            r[i] = nextInt();
        }

        int count = 0;
        for(int i = 0;i < N - 1;i++) {
            for(int j = i + 1;j < N;j++) if (a[i] > a[j]) {
                count++;
            }
        }

        for(int i = 0;i < M;i++) {
            count += (r[i] - l[i] + 1) * (r[i] - l[i]) / 2;
            count %= 2;
            out.println(count == 0 ? ""even"" : ""odd"");
        }
    }

    public static void main(String[] args) {
        out.flush();
        new D().solve();
        out.close();
    }

    /* Input */
    private static final InputStream in = System.in;
    private static final PrintWriter out = new PrintWriter(System.out);
    private final byte[] buffer = new byte[2048];
    private int p = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (p < buflen)
            return true;
        p = 0;
        try {
            buflen = in.read(buffer);
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (buflen <= 0)
            return false;
        return true;
    }

    public boolean hasNext() {
        while (hasNextByte() && !isPrint(buffer[p])) {
            p++;
        }
        return hasNextByte();
    }

    private boolean isPrint(int ch) {
        if (ch >= '!' && ch <= '~')
            return true;
        return false;
    }

    private int nextByte() {
        if (!hasNextByte())
            return -1;
        return buffer[p++];
    }

    public String next() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = -1;
        while (isPrint((b = nextByte()))) {
            sb.appendCodePoint(b);
        }
        return sb.toString();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    public long nextLong() {
        return Long.parseLong(next());
    }

    public double nextDouble() {
        return Double.parseDouble(next());
    }
}",0911_D,CODEFORCES,3210,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Nasko
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {

            int N = in.nextInt();


            if (N == 1) {
                out.println(1);
            } else if (N == 2) {
                out.println(2);
            } else if (N == 3) {
                out.println(6);
            } else {

                long best = Long.MIN_VALUE;
                best = Math.max(best, lcm(N, lcm(N - 1, N - 2)));
                best = Math.max(best, lcm(N, lcm(N - 2, N - 3)));
                best = Math.max(best, lcm(N, lcm(N - 1, N - 3)));
                best = Math.max(best, lcm(N - 1, lcm(N - 2, N - 3)));

                out.println(best);
            }
        }

        private long lcm(long a, long b) {
            return a * (b / gcd(a, b));
        }

        private long gcd(long a, long b) {
            return b == 0 ? a : gcd(b, a % b);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",0235_A,CODEFORCES,242,LCM Challenge,"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.
But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than n. Can you help me to find the maximum possible least common multiple of these three integers?
The first line contains an integer n (1 ≤ n ≤ 106) — the n mentioned in the statement.
Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than n.
The least common multiple of some positive integers is the least positive integer which is multiple for each of them.
","input
The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.
output
For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.
",numbertheory,1
"import java.io.*;
import java.util.HashMap;
import java.util.Map;

public class Round364_div2_C {

    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(System.out);
        solve(in, out);
        out.flush();
    }


    public static void solve(FastReader in, PrintWriter out) {
        int n = in.readInt();
        String s = in.readString();

        int totalCnt = (int) s.chars().distinct().count();

        Map<Character, Integer> curCnts = new HashMap<>();

        int solution = s.length();
        int i = 0;
        for (int j = 0 ; j < s.length() ; j++) {
            // add s_j
            char sj = s.charAt(j);
            curCnts.put(sj, curCnts.getOrDefault(sj, 0) + 1);

            // contract s_i
            while (curCnts.getOrDefault(s.charAt(i), 0) > 1) {
                char si = s.charAt(i);
                int siCnt = curCnts.get(si);
                if (siCnt > 1) {
                    curCnts.put(si, siCnt - 1);
                } else {
                    curCnts.remove(si);
                }
                i++;
            }

            if (curCnts.size() == totalCnt) {
                solution = Math.min(solution, j - i + 1);
            }
        }

        out.println(solution);
    }


    /**
     * Custom buffered reader. Faster than Scanner and BufferedReader + StringTokenizer.
     */
    static class FastReader {
        private final InputStream stream;
        private int current;
        private int size;
        private byte[] buffer = new byte[1024 * 8];

        public FastReader(InputStream stream) {
            this.stream = stream;
            current = 0;
            size = 0;
        }

        public int readInt() {
            int sign = 1;
            int abs = 0;
            int c = readNonEmpty();
            if (c == '-') {
                sign = -1;
                c = readAny();
            }
            do {
                if (c < '0' || c > '9') {
                    throw new IllegalStateException();
                }
                abs = 10 * abs + (c - '0');
                c = readAny();
            } while (!isEmpty(c));
            return sign * abs;
        }

        public int[] readIntArray(int n) {
            int[] array = new int[n];
            for (int i = 0 ; i < n ; i++) {
                array[i] = readInt();
            }
            return array;
        }

        public char readChar() {
            return (char) readNonEmpty();
        }

        public String readString() {
            StringBuffer sb = new StringBuffer();
            int c;
            do {
                c = readAny();
            } while (isEmpty(c));
            do {
                sb.append((char) c);
                c = readAny();
            } while (!isEmpty(c));
            return sb.toString();
        }

        private int readAny() {
            try {
                if (current >= size) {
                    current = 0;
                    size = stream.read(buffer);
                    if (size < 0) {
                        return -1;
                    }
                }
            } catch (IOException e) {
                throw new RuntimeException(""Failed to readAny next byte"", e);
            }
            return buffer[current++];
        }

        private int readNonEmpty() {
            int result;
            do {
                result = readAny();
            } while (isEmpty(result));
            return result;
        }

        private static boolean isEmpty(int c) {
            return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == -1;
        }
    }
}
",0701_C,CODEFORCES,1789,They Are Everywhere,"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.
There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 
Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. 
The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.
The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. 
Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. 
In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.
","input
In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 
output
In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.
","binarysearch, strings, twopointers",3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;

/**
 * Created by Daniil on 5/29/2016.
 */
public class TaskB {


    public static int strIndex;
    public static void main(String[] args) throws IOException {

        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();

        char[] s = scanner.next().toCharArray();

        int[][] r = new int[n][54];

        Set<Character> chars = new HashSet<>();

        for (int i= 0 ;i < n; ++ i)chars.add(s[i]);

        List<Character> all = new ArrayList<>();

        for (Character c: chars)all.add(c);

        for (int i = n - 1; i >= 0; -- i){
            for (int j = 0;j < 54; ++ j){
                if (i == n - 1){
                    r[i][j] = -1;
                }else {
                    r[i][j] = r[i + 1][j];
                }
            }
            r[i][getCode(s[i])] = i;
        }

        int res = n;


        for (int i =0; i < n; ++ i){
            int mx = 1;
            boolean fl = false;
            for (Character c: all){
                if (r[i][getCode(c)] == -1){
                    fl = true;
                    break;
                }
                mx = Math.max(mx, r[i][getCode(c)] - i + 1);
            }
            if (fl){
                System.out.println(res);
                return;
            }
            res = Math.min(res, mx);
        }
        System.out.println(res);

        scanner.close();
        //reader.close();
    }

    public static int getCode(char a){
        if (Character.isUpperCase(a))return a - 'A';
        return (a - 'a') + 26;
    }

    public static int getLetter(int n){
        if (n > 25)return (char)((n - 26) + 'a');
        return (char)((n) + 'A');
    }



    static class IO{


        BufferedReader reader;
        StringTokenizer tokenizer;
        PrintWriter writer;

        public void init() {
            try {
                reader = new BufferedReader(new InputStreamReader(System.in),8*1024);
                writer = new PrintWriter(System.out);
            } catch (Exception e) {
                e.printStackTrace();
                System.exit(261);
            }
        }

        void destroy() {
            writer.close();
            System.exit(0);
        }

        void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0)
                    writer.print(' ');
                writer.print(objects[i]);
            }
        }

        void println(Object... objects) {
            print(objects);
            writer.println();
        }

        String nextLine() throws IOException {
            return reader.readLine();
        }

        String nextToken() throws IOException {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
                tokenizer = new StringTokenizer(nextLine());
            return tokenizer.nextToken();
        }

        int nextInt() throws NumberFormatException, IOException {
            return Integer.parseInt(nextToken());
        }

        long nextLong() throws NumberFormatException, IOException {
            return Long.parseLong(nextToken());
        }

        double nextDouble() throws NumberFormatException, IOException {
            return Double.parseDouble(nextToken());
        }
    }


}
",0701_C,CODEFORCES,1798,They Are Everywhere,"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.
There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 
Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. 
The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.
The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. 
Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. 
In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.
","input
In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 
output
In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.
","binarysearch, strings, twopointers",3
"// Don't place your source in a package
import javax.swing.*;
import java.lang.reflect.Array;
import java.text.DecimalFormat;
import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;
import java.util.stream.Stream;


// Please name your class Main
public class Main {
    static FastScanner fs=new FastScanner();
    static class FastScanner {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=new StringTokenizer("""");
        public String next() {
            while (!st.hasMoreElements())
                try {
                    st=new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            return st.nextToken();
        }
        int Int() {
            return Integer.parseInt(next());
        }

        long Long() {
            return Long.parseLong(next());
        }

        String Str(){
            return next();
        }
    }


    public static void main (String[] args) throws java.lang.Exception {
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T=1;
        for(int t=0;t<T;t++){
            int n=Int(),k=Int();
            int A[][]=new int[n][2];
            for(int i=0;i<n;i++){
                A[i][0]=Int();
                A[i][1]=Int();
            }

            Solution sol=new Solution(out);
            sol.solution(A,k);
        }
        out.close();

    }


    public static int Int(){
        return fs.Int();
    }
    public static long Long(){
        return fs.Long();
    }
    public static String Str(){
        return fs.Str();
    }

}






class Solution{
    PrintWriter out;
    public Solution(PrintWriter out){
        this.out=out;
    }



    long dp[][];
    int mod=1000000007;
    int time;
    public void solution(int A[][],int t){
        this.time=t;
        dp=new long[4][1<<A.length+2];
        for(int i=0;i<dp.length;i++){
            Arrays.fill(dp[i],-1);
        }

        long a=dfs(A,0,(1<<A.length)-1);
        out.println(a);
    }

    public long dfs(int A[][],int pre,int state){
        int use=cal(A,state);
        if(time-use==0){
            return 1;
        }
        if(time<use||state==0){
            return 0;
        }

        if(dp[pre][state]!=-1)return dp[pre][state];

        long res=0;

        for(int i=0;i<A.length;i++){
            if(((state&(1<<i))!=0)&&A[i][1]!=pre){
                res+=dfs(A,A[i][1],(state^(1<<i)));
                res%=mod;
            }
        }

        dp[pre][state]=res;
        return res;
    }

    public int cal(int A[][],int state){
        int t=0;
        for(int i=0;i<A.length;i++){
            if((state&(1<<i))==0){
                t+=A[i][0];
            }
        }
        return t;
    }


}












/*
                             ;\
                            |' \
         _                  ; : ;
        / `-.              /: : |
       |  ,-.`-.          ,': : |
       \  :  `. `.       ,'-. : |
        \ ;    ;  `-.__,'    `-.|
         \ ;   ;  :::  ,::'`:.  `.
          \ `-. :  `    :.    `.  \
           \   \    ,   ;   ,:    (\
            \   :., :.    ,'o)): ` `-.
           ,/,' ;' ,::""'`.`---'   `.  `-._
         ,/  :  ; '""      `;'          ,--`.
        ;/   :; ;             ,:'     (   ,:)
          ,.,:.    ; ,:.,  ,-._ `.     \""""'/
          '::'     `:'`  ,'(  \`._____.-'""'
             ;,   ;  `.  `. `._`-.  \\
             ;:.  ;:       `-._`-.\  \`.
              '`:. :        |' `. `\  ) \
      -hrr-      ` ;:       |    `--\__,'
                   '`      ,'
                        ,-'


                      free bug dog
*/


",1185_G1,CODEFORCES,4694,Playlist for Polycarp (easy version),"The only difference between easy and hard versions is constraints.
Polycarp loves to listen to music, so he never leaves the player, even on the way home from the university. Polycarp overcomes the distance from the university to the house in exactly $$$T$$$ minutes.
In the player, Polycarp stores $$$n$$$ songs, each of which is characterized by two parameters: $$$t_i$$$ and $$$g_i$$$, where $$$t_i$$$ is the length of the song in minutes ($$$1 \le t_i \le 15$$$), $$$g_i$$$ is its genre ($$$1 \le g_i \le 3$$$).
Polycarp wants to create such a playlist so that he can listen to music all the time on the way from the university to his home, and at the time of his arrival home, the playlist is over. Polycarp never interrupts songs and always listens to them from beginning to end. Thus, if he started listening to the $$$i$$$-th song, he would spend exactly $$$t_i$$$ minutes on its listening. Polycarp also does not like when two songs of the same genre play in a row (i.e. successively/adjacently) or when the songs in his playlist are repeated.
Help Polycarpus count the number of different sequences of songs (their order matters), the total duration is exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different.
The first line of the input contains two integers $$$n$$$ and $$$T$$$ ($$$1 \le n \le 15, 1 \le T \le 225$$$) — the number of songs in the player and the required total duration, respectively.
Next, the $$$n$$$ lines contain descriptions of songs: the $$$i$$$-th line contains two integers $$$t_i$$$ and $$$g_i$$$ ($$$1 \le t_i \le 15, 1 \le g_i \le 3$$$) — the duration of the $$$i$$$-th song and its genre, respectively.
Output one integer — the number of different sequences of songs, the total length of exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different. Since the answer may be huge, output it modulo $$$10^9 + 7$$$ (that is, the remainder when dividing the quantity by $$$10^9 + 7$$$).
In the first example, Polycarp can make any of the $$$6$$$ possible playlist by rearranging the available songs: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$ and $$$[3, 2, 1]$$$ (indices of the songs are given).
","input
In the second example, the first and second songs cannot go in succession (since they have the same genre). Thus, Polycarp can create a playlist in one of $$$2$$$ possible ways: $$$[1, 3, 2]$$$ and $$$[2, 3, 1]$$$ (indices of the songs are given).
output
In the third example, Polycarp can make the following playlists: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$, $$$[3, 2, 1]$$$, $$$[1, 4]$$$, $$$[4, 1]$$$, $$$[2, 3, 4]$$$ and $$$[4, 3, 2]$$$ (indices of the songs are given).
","bitmasks, combinatorics, dp",7
"import java.io.*;
import java.util.*;

public class E {

	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

	public static void main(String[] args) throws IOException {
		readInput();
		out.close();
	}
	
	static long[][] dp;
	static int n;
	static long m;
	

	static long pow(long b, long e) {
		if (e== 0) return 1;
		long r= pow(b,e/2);
		r = r * r % m;
		if ((e&1)==1) return r *b%m;
		return r;
	}
	
	static long modinv(long a) {return pow(a,m-2);}
	
	static long solve(int len, int num) {
		if (len == -1 && num == -1) return 1;
		if (num < 0 || len <= 0) return 0;
		if (dp[len][num] == -1) {
			dp[len][num] = 0;
			for (int i = 0; i < len; i++) {
				if (i == 1) continue;
				long sol = pow[len-i-1]*solve(i-1,num-1)%m;
				sol = sol * faci[len-i]% m;
				dp[len][num] += sol;
				dp[len][num] %= m;
			}
			
		}
		return dp[len][num];
	}
	static long[] fac, faci, pow;
	
	public static void readInput() throws IOException {
		// br = new BufferedReader(new FileReader("".in""));
		// out = new PrintWriter(new FileWriter("".out""));
		StringTokenizer st = new StringTokenizer(br.readLine());
		n = Integer.parseInt(st.nextToken());
		m = Long.parseLong(st.nextToken());
		fac = new long[500];
		pow = new long[500];
		faci = new long[fac.length];
		fac[0] = pow[0] = 1;
		faci[0] = modinv(fac[0]);
		for (int i = 1; i < fac.length; i++) {
			fac[i] = fac[i-1]*i%m;
			faci[i] = modinv(fac[i]);
			pow[i] = pow[i-1] * 2 % m;
		}
		dp = new long[n+1][n+1];
		for (long[] a: dp) Arrays.fill(a, -1);
		// Number of ways to make a segment of length x is 2^(x-1)
		// DP: Given position I.
		long ans =0 ;
		for (int i = 0 ; i <= n/2+1; i++) {
			//System.out.println(i + "": "" + solve(n,i) + "" "" + (n-i) + "" "" + (i));
			long sol = solve(n,i) * fac[n-i];
			sol %= m;
			ans += sol;
		}
		out.println(ans%m);
	}
}
",1515_E,CODEFORCES,4155,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"
/**
 * Mx NINJA 04:06:52 ص 14/01/2014
 */
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {

    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder line = new StringBuilder(reader.readLine());
        int length = 0;
        for (int head = 0; head < line.length(); head++) {
            for (int tail = line.length() - 1; tail > head; tail--) {
                String subString = line.substring(head, tail);
                if(line.indexOf(subString,head+1)>-1){
                    length = Math.max(subString.length(), length);
                }
            }
        }
        System.out.println(length);
    }
}",0023_A,CODEFORCES,3800,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
import com.sun.org.apache.xalan.internal.xsltc.dom.BitArray;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.BitSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author abdelrahman
 */
public class p1 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        new p1().run();

    }

    private void run() {
        try {
            // TODO code application logic here
            Scanner scanner = new Scanner(System.in);
            String in = scanner.next();
            
            Hashtable<String, Boolean> tmp = new Hashtable<String, Boolean>();
            int sol = 0;
            for (int i = 0; i < in.length(); i++) {
                for (int j = i + 1; j <= in.length(); j++) {
                    String str = in.substring(i, j);
                    if (tmp.containsKey(str)) {
                        if (tmp.get(str)) {
                            if(str.length() > sol)  sol=str.length();
                            boolean tmp1 = tmp.remove(str);
                            tmp.put(str, false);
                        }
                    } else {
                        tmp.put(str, Boolean.TRUE);
                    }
                }

            }
            System.out.println(sol);
        } catch (Exception ex) {
        }
    }

    
}
",0023_A,CODEFORCES,3822,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
	public static void main(String[] args) throws NumberFormatException,
			IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		int n = Integer.parseInt(br.readLine());
		String s = n + """";
		if (n >= 0)
			System.out.println(n);
		else {
			int a = n, b = Integer.parseInt(s.substring(0, s.length() - 1)), c = Integer.parseInt(s.substring(0, s.length()-2)+s.charAt(s.length()-1));
			System.out.println(Math.max(a, Math.max(b,c)));
		}
	}
}
",0313_A,CODEFORCES,337,Ilya and Bank Account,"Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.
Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.
Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.
The single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.
In a single line print an integer — the maximum state of the bank account that Ilya can get. 
","input
In the first test sample Ilya doesn't profit from using the present.
output
In the second test sample you can delete digit 1 and get the state of the account equal to 0.
","implementation, numbertheory",1
"import java.io.*;
import java.util.*;

public class A
{	
	
	
		public static void main(String[] args) throws IOException 
		{
				
				Scanner sc=new Scanner(System.in);
				PrintWriter pw=new PrintWriter(System.out);
				int n=sc.nextInt();
				String []a=new String[n];
				String []b=new String[n];
				
				TreeMap<String,Integer> map1=new TreeMap(),map2=new TreeMap();
				for(int i=0;i<n;i++)
				{
					String s=sc.next();
					map1.put(s, map1.getOrDefault(s, 0)+1);
					
				}
				for(int i=0;i<n;i++)
				{
					String s=sc.next();
					map2.put(s, map2.getOrDefault(s, 0)+1);
					
				}
				int ans=0;
				for(String s:map2.keySet())
				{
					int cnt=map1.getOrDefault(s, 0);
					ans+=Math.max(0, map2.get(s)-cnt);
				}
				pw.println(ans);
				pw.close();
		}
		
		
		
		static class Scanner
		{
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}
		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}
		public Scanner(String s) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(s));
		}
		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}
		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public boolean ready() throws IOException {
			return br.ready();
		}
	}

		
		
}",1000_A,CODEFORCES,1946,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation",3
"// practice with rainboy
import java.io.*;
import java.util.*;

public class CF111C extends PrintWriter {
	CF111C() { super(System.out, true); }
	Scanner sc = new Scanner(System.in);
	public static void main(String[] $) {
		CF111C o = new CF111C(); o.main(); o.flush();
	}

	int encode(int[] aa, int m) {
		int a = 0;
		for (int j = 0; j < m; j++)
			a = a * 3 + aa[j];
		return a;
	}
	void decode(int[] aa, int m, int a, int base) {
		for (int j = m - 1; j >= 0; j--) {
			aa[j] = a % base;
			a /= base;
		}
	}
	void main() {
		int n = sc.nextInt();
		int m = sc.nextInt();
		if (n < m) {
			int tmp = n; n = m; m = tmp;
		}
		int p = 1;
		for (int j = 0; j < m; j++)
			p *= 3;
		int[] dp = new int[p];
		int[] dq = new int[p];
		int[] aa = new int[m];
		int[] bb = new int[m];
		for (int j = 0; j < m; j++)
			aa[j] = 1;
		Arrays.fill(dp, -1);
		dp[encode(aa, m)] = 0;
		while (n-- > 0) {
			Arrays.fill(dq, -1);
			for (int a = 0; a < p; a++) {
				if (dp[a] < 0)
					continue;
				decode(aa, m, a, 3);
				for (int b = 0; b < 1 << m; b++) {
					decode(bb, m, b, 2);
					boolean bad = false;
					for (int j = 0; j < m; j++)
						if (aa[j] == 0 && bb[j] == 0) {
							bad = true;
							break;
						}
					if (bad)
						continue;
					int cnt = 0;
					for (int j = 0; j < m; j++)
						if (bb[j] == 1) {
							bb[j] = 2;
							cnt++;
						}
					for (int j = 0; j < m; j++)
						if (bb[j] == 0 && (aa[j] == 2 || j > 0 && bb[j - 1] == 2 || j + 1 < m && bb[j + 1] == 2))
							bb[j] = 1;
					int a_ = encode(bb, m);
					dq[a_] = Math.max(dq[a_], dp[a] + m - cnt);
				}
			}
			int[] tmp = dp; dp = dq; dq = tmp;
		}
		int ans = 0;
		for (int a = 0; a < p; a++) {
			if (dp[a] <= ans)
				continue;
			decode(aa, m, a, 3);
			boolean bad = false;
			for (int j = 0; j < m; j++)
				if (aa[j] == 0) {
					bad = true;
					break;
				}
			if (!bad)
				ans = dp[a];
		}
		println(ans);
	}
}
",0111_C,CODEFORCES,4610,Petya and Spiders,"Little Petya loves training spiders. Petya has a board n × m in size. Each cell of the board initially has a spider sitting on it. After one second Petya chooses a certain action for each spider, and all of them humbly perform its commands. There are 5 possible commands: to stay idle or to move from current cell to some of the four side-neighboring cells (that is, one command for each of the four possible directions). Petya gives the commands so that no spider leaves the field. It is allowed for spiders to pass through each other when they crawl towards each other in opposite directions. All spiders crawl simultaneously and several spiders may end up in one cell. Petya wants to know the maximum possible number of spider-free cells after one second.
The first line contains two space-separated integers n and m (1 ≤ n, m ≤ 40, n·m ≤ 40) — the board sizes.
In the first line print the maximum number of cells without spiders.
In the first sample the only possible answer is:
s
","input
In the second sample one of the possible solutions is: 
output
s denotes command ""stay idle"", l, r, d, u denote commands ""crawl left"", ""crawl right"", ""crawl down"", ""crawl up"", correspondingly.
","bitmasks, dp, dsu",7
"/*Author: Satyajeet Singh, Delhi Technological University*/
    import java.io.*;
    import java.util.*;
    import java.text.*; 
    import java.lang.*;
    import java.math.*;
 
public class Main{
/*********************************************Constants******************************************/
    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));        
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static long mod=(long)1e9+7;
    static long mod1=998244353;
    static boolean sieve[];
    static ArrayList<Integer> primes;
    static long factorial[],invFactorial[];
    static ArrayList<Pair> graph[];
    static boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
/****************************************Solutions Begins***************************************/  
    static int n,m;
    static long cost[][],dp[];
    public static void main(String[] args) throws Exception{
        String st[]=nl();
        n=pi(st[0]);
        m=pi(st[1]);
        st=nl();
        String str=st[0];
        int mn=10000;
        for(int i=0;i<n;i++){
            mn=Math.min(mn,str.charAt(i));
        }
        cost=new long[m][m];
        for(int i=1;i<n;i++){
            int a1=str.charAt(i-1)-mn;
            int a2=str.charAt(i)-mn;
            if(a1==a2)continue;
            cost[a1][a2]++;
            cost[a2][a1]++;
        }
        int mm=1<<m;
        dp=new long[mm];
        Arrays.fill(dp,Long.MAX_VALUE/2);
        dp[0]=0;
        //debug(cost);
        long cntbit[]=new long[mm];
        int minbit[]=new int[mm];

        for(int mask=1;mask<mm;mask++){
            cntbit[mask]=1+cntbit[(mask&(mask-1))];
            for(int i=0;i<m;i++){
                if(((mask>>i)&1)!=0){
                    minbit[mask]=i;
                    break;
                }
            }
        }
        long cntcost[][]=new long[mm][m];
        for(int mask=0;mask<mm;mask++){
            for(int i=0;i<m;i++){
                int b=minbit[mask];
                cntcost[mask][i]=cntcost[mask^(1<<b)][i]+cost[i][b];
            }
        }
        int yy=mm-1;
        for(int mask=0;mask<mm;mask++){
            long cnt=cntbit[mask];
            for(int i=0;i<m;i++){
                if(((mask>>i)&1)!=0){
                    long ans=cnt*(cntcost[mask][i]-cntcost[yy^mask][i]);
                    dp[mask]=Math.min(dp[mask],dp[mask^(1<<i)]+ans);
                }
            }
        }
        out.println(dp[mm-1]);
/****************************************Solutions Ends**************************************************/
        out.flush();
        out.close();
    }
/****************************************Template Begins************************************************/
    static String[] nl() throws Exception{
        return br.readLine().split("" "");
    }
    static String[] nls() throws Exception{
        return br.readLine().split("""");
    }
    static int pi(String str) {
        return Integer.parseInt(str);
    }
    static long pl(String str){
        return Long.parseLong(str);
    }
    static double pd(String str){
        return Double.parseDouble(str);
    }
/***************************************Precision Printing**********************************************/
    static void printPrecision(double d){
        DecimalFormat ft = new DecimalFormat(""0.000000000000000000000""); 
        out.println(ft.format(d));
    }
/**************************************Bit Manipulation**************************************************/
    static void printMask(long mask){
        System.out.println(Long.toBinaryString(mask));
    }
    static int countBit(long mask){
        int ans=0;
        while(mask!=0){
            if(mask%2==1){
                ans++;
            }
            mask/=2;
        }
        return ans;
    }
/******************************************Graph*********************************************************/
    static void Makegraph(int n){
        graph=new ArrayList[n];
        for(int i=0;i<n;i++){
            graph[i]=new ArrayList<>();
        }
    }
    static void addEdge(int a,int b){
        graph[a].add(new Pair(b,1));
    }
    static void addEdge(int a,int b,int c){
        graph[a].add(new Pair(b,c));
    }    
/*********************************************PAIR********************************************************/
    static class PairComp implements Comparator<Pair>{
        public int compare(Pair p1,Pair p2){
            return p1.u-p2.u;
        }
    }
    static class Pair implements Comparable<Pair> {
        int u;
        int v;
        int index=-1;
        public Pair(int u, int v) {
            this.u = u;
            this.v = v;
        }
        public int hashCode() {
            int hu = (int) (u ^ (u >>> 32));
            int hv = (int) (v ^ (v >>> 32));
            return 31 * hu + hv;
        }
        public boolean equals(Object o) {
            Pair other = (Pair) o;
            return u == other.u && v == other.v;
        }
        public int compareTo(Pair other) {
            if(index!=other.index)
                return Long.compare(index, other.index);
            return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);
        }
        public String toString() {
            return ""[u="" + u + "", v="" + v + ""]"";
        }
    }
/******************************************Long Pair*******************************************************/
    static class PairCompL implements Comparator<Pairl>{
        public int compare(Pairl p1,Pairl p2){
            long a=p1.u*p2.v;
            long b=p2.u*p1.v;
            if(a>b){
                return -1;
            }
            else if(a<b){
                return 1;
            }
            else{
                return 0;
            }
        }
    }
    static class Pairl implements Comparable<Pairl> {
            long u;
            long v;
            int index=-1;
            public Pairl(long u, long v) {
                this.u = u;
                this.v = v;
            }
    
            public int hashCode() {
                int hu = (int) (u ^ (u >>> 32));
                int hv = (int) (v ^ (v >>> 32));
                return 31 * hu + hv;
            }
    
            public boolean equals(Object o) {
                Pairl other = (Pairl) o;
                return u == other.u && v == other.v;
            }
    
            public int compareTo(Pairl other) {
                if(index!=other.index)
                    return Long.compare(index, other.index);
                return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);
            }
    
            public String toString() {
                return ""[u="" + u + "", v="" + v + ""]"";
            }
        }
/*****************************************DEBUG***********************************************************/
    public static void debug(Object... o) {
        if(!oj)
        System.out.println(Arrays.deepToString(o));
    }
/************************************MODULAR EXPONENTIATION***********************************************/
    static long modulo(long a,long b,long c) {
        long x=1;
        long y=a%c;
        while(b > 0){
            if(b%2 == 1){
                x=(x*y)%c;
            }
            y = (y*y)%c; // squaring the base
            b /= 2;
        }
        return  x%c;
    }
/********************************************GCD**********************************************************/
    static long gcd(long x, long y)
    {
        if(x==0)
            return y;
        if(y==0)
            return x;
        long r=0, a, b;
        a = (x > y) ? x : y; // a is greater number
        b = (x < y) ? x : y; // b is smaller number
        r = b;
        while(a % b != 0)
        {
            r = a % b;
            a = b;
            b = r;
        }
        return r;
    }
/******************************************SIEVE**********************************************************/
    static void sieveMake(int n){
        sieve=new boolean[n];
        Arrays.fill(sieve,true);
        sieve[0]=false;
        sieve[1]=false;
        for(int i=2;i*i<n;i++){
            if(sieve[i]){
                for(int j=i*i;j<n;j+=i){
                    sieve[j]=false;
                }
            }
        }
        primes=new ArrayList<Integer>();
        for(int i=0;i<n;i++){
            if(sieve[i]){
                primes.add(i);
            }
        }        
    }
/********************************************End***********************************************************/
}",1238_E,CODEFORCES,4862,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp",7
"import java.util.*;
import java.io.*;

public class main{

	static int max = 5000+1;
	static FastReader in = new FastReader();
	static PrintWriter out = new PrintWriter(System.out);
	static int N = 18;
	static int[][] mn1 = new int[N][N]; 
	static int[][] mn2 = new int[N][N];
	static int[][] dp = new int[1<<N][N];
	static int n,m;
	
	static void solve(){
		n = in.nextInt(); m = in.nextInt();
		int[][] a = new int[n][m];
		for(int i=0;i<n;i++)for(int j=0;j<m;j++)a[i][j] = in.nextInt();
		for(int i=0;i<n;i++){
			Arrays.fill(mn1[i],Integer.MAX_VALUE);
			Arrays.fill(mn2[i],Integer.MAX_VALUE);
		}
		
		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++)
				for(int k=0;k<m;k++){
					mn1[i][j] = Math.min(mn1[i][j],Math.abs(a[i][k]-a[j][k]));
					if(k<=m-2)
						mn2[i][j] = Math.min(mn2[i][j],Math.abs(a[i][k]-a[j][k+1]));
				}
		int ans = 0;
		for(int i=0;i<n;i++){
			for(int x=0;x<1<<n;x++)Arrays.fill(dp[x],-1);
			for(int j=0;j<n;j++)dp[1<<j][j] = 0;
			dp[1<<i][i] = Integer.MAX_VALUE;
			for(int j=0;j<n;j++)
				ans = Math.max(ans,Math.min(mn2[j][i],calc((1 << n) - 1, j)));
		}
		out.println(ans);
	}

	static int calc(int mask, int v){
		if (dp[mask][v] != -1)
			return dp[mask][v];
		dp[mask][v] = 0;
		for(int u=0;u<n;u++) if (v != u && (((mask >> u) & 1)>0))
			dp[mask][v] = Math.max(dp[mask][v], Math.min(mn1[u][v], calc(mask ^ (1 << v), u)));
		return dp[mask][v];
	}


	public static void main(String[] args){
		solve();
		out.flush();
		out.close();
	}	

	static class FastReader{
        BufferedReader br;
        StringTokenizer st;
        public FastReader(){
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        public FastReader(String s) throws Exception{
            br = new BufferedReader(new FileReader(s));
        }

        String next(){
            while (st == null || !st.hasMoreElements()){
                try{
                    st = new StringTokenizer(br.readLine());
                }catch (IOException  e){
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        String nextLine(){
            String str = """";
            try{   
                str = br.readLine();
            }catch (IOException e){
                e.printStackTrace();
            }  
            return str;
        }
        int nextInt(){return Integer.parseInt(in.next());}
    	long nextLong(){return Long.parseLong(in.next());}
    	double nextDouble(){return Double.parseDouble(in.next());}
    }
}




// |xvcxv|vcv[cvcvc|cxv||]vcvx:v|c|vxc|[|cvx:cxvx||||]",1102_F,CODEFORCES,4676,Elongated Matrix,"You are given a matrix $$$a$$$, consisting of $$$n$$$ rows and $$$m$$$ columns. Each cell contains an integer in it.
You can change the order of rows arbitrarily (including leaving the initial order), but you can't change the order of cells in a row. After you pick some order of rows, you traverse the whole matrix the following way: firstly visit all cells of the first column from the top row to the bottom one, then the same for the second column and so on. During the traversal you write down the sequence of the numbers on the cells in the same order you visited them. Let that sequence be $$$s_1, s_2, \dots, s_{nm}$$$. 
The traversal is $$$k$$$-acceptable if for all $$$i$$$ ($$$1 \le i \le nm - 1$$$) $$$|s_i - s_{i + 1}| \ge k$$$.
Find the maximum integer $$$k$$$ such that there exists some order of rows of matrix $$$a$$$ that it produces a $$$k$$$-acceptable traversal.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 16$$$, $$$1 \le m \le 10^4$$$, $$$2 \le nm$$$) — the number of rows and the number of columns, respectively.
Each of the next $$$n$$$ lines contains $$$m$$$ integers ($$$1 \le a_{i, j} \le 10^9$$$) — the description of the matrix.
Print a single integer $$$k$$$ — the maximum number such that there exists some order of rows of matrix $$$a$$$ that it produces an $$$k$$$-acceptable traversal.
In the first example you can rearrange rows as following to get the $$$5$$$-acceptable traversal:
Then the sequence $$$s$$$ will be $$$[5, 10, 4, 9, 3, 8, 3, 9]$$$. Each pair of neighbouring elements have at least $$$k = 5$$$ difference between them.
","input
In the second example the maximum $$$k = 0$$$, any order is $$$0$$$-acceptable.
output
In the third example the given order is already $$$3$$$-acceptable, you can leave it as it is.
","binarysearch, bitmasks, bruteforce, dp, graphs",7
"import java.util.*;
import java.io.*;
public class Problem1517d {
    static class node {
        int a, b, v;
        public node(int a, int b, int v) {
            this.a = a;
            this.b = b;
            this.v = v;
        }
    }
    static int inf = 0x3f3f3f3f;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int num = Integer.parseInt(st.nextToken());
        if (num % 2 == 1) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    System.out.print(""-1 "");
                }
                System.out.println();
            }
            System.out.flush();
            return;
        }
        List<node>[][] map = new ArrayList[n][m];
        for (int i = 0; i < n; i++) {
            map[i][0] = new ArrayList<node>();
            st = new StringTokenizer(br.readLine());
            for (int j = 1; j < m; j++) {
                map[i][j] = new ArrayList<node>();
                int v = Integer.parseInt(st.nextToken());
                map[i][j - 1].add(new node(i, j, v));
                map[i][j].add(new node(i, j - 1, v));
            }
        }
        for (int i = 1; i < n; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < m; j++) {
                int v = Integer.parseInt(st.nextToken());
                map[i - 1][j].add(new node(i, j, v));
                map[i][j].add(new node(i - 1, j, v));
            }
        }
        num = num >> 1;
        int[][][] dp = new int[n][m][num + 1];
        for (int k = 1; k <= num; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    dp[i][j][k] = inf;
                    for (node node : map[i][j]) {
                        dp[i][j][k] = Math.min(dp[i][j][k], dp[node.a][node.b][k - 1] + node.v);
                    }
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                System.out.print((dp[i][j][num] << 1) + "" "");
            }
            System.out.println();
        }
        System.out.flush();
    }
}",1517_D,CODEFORCES,4269,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;


public class CF224B {
    
    public static void main(String[] args) throws Exception {
        new CF224B().solve();
    }

    private void solve() throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        final int MAX_A = 100000;
        int[] freq = new int[MAX_A+1];
        int numDistinct = 0;
        int r = -1;
        for (int i = 0; i < n; i++) {
            int t = a[i];
            freq[t]++;
            if (freq[t] == 1) {
                numDistinct++;
            }
            if (numDistinct == k) {
                r = i;
                break;
            }
        }
        if (r == -1) {
            System.out.println(""-1 -1"");
            return;
        }
        int l;
        for (l = 0; l < r; l++) {
            int t = a[l];
            freq[t]--;
            if (freq[t] == 0) {
                break;
            }
        }
        System.out.println((l+1) + "" "" + (r+1));
    }

}
",0224_B,CODEFORCES,1672,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers",3
"import static java.lang.Math.*;
import static java.lang.System.currentTimeMillis;
import static java.lang.System.exit;
import static java.lang.System.arraycopy;
import static java.util.Arrays.sort;
import static java.util.Arrays.binarySearch;
import static java.util.Arrays.fill;
import java.util.*;
import java.io.*;

public class Main {

	public static void main(String[] args) throws IOException {
		try {
			if (new File(""input.txt"").exists())
				System.setIn(new FileInputStream(""input.txt""));
		} catch (SecurityException e) {
		}
		new Thread(null, new Runnable() {
			public void run() {
				try {
					new Main().run();
				} catch (Throwable e) {
					e.printStackTrace();
					exit(999);
				}
			}
		}, ""1"", 1 << 23).start();
	}

	BufferedReader in;
	PrintWriter out;
	StringTokenizer st = new StringTokenizer("""");

	int n, m;
	int dp[][][];
	int MV = Integer.MAX_VALUE >> 1;
	int ans = MV;
	
	private void run() throws IOException {
		in = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);

		n = nextInt();
		m = nextInt();
		if(n < m){ int d = n; n = m; m = d; }
		int M = 1 << m;
		dp = new int[n][M][M];
		for(int a[][] : dp)
			for(int b[] : a)
				fill(b, MV);
		
//		for(int i = 0 ; i < M; i++){
//			int next = (( i | (i << 1) | (i >> 1) ) & (M - 1));
//			if(  next!= (M -1))
//				continue;
//			if(n > 1)
//				dp[0][next][0] = Integer.bitCount(i);
//			else
//				ans = min(ans, Integer.bitCount(i));
//		}
		dp[0][0][0] = 0;
		
		for(int i = 0; i < n; i++)
			for(int m1 = 0; m1 < M; m1++)
				for(int m2 = 0; m2 < M; m2++){
					if(dp[i][m1][m2] == MV)
						continue;
					for(int nm1 = 0; nm1 < M; nm1++)
						for(int nm2 = 0; nm2 < M; nm2++){
							int res1 = m1 | (nm1) | (nm1 << 1) | (nm1 >> 1) | (nm2);
							res1 &= (M - 1);
							
							if(res1 != (M - 1))
								continue;
							
							
							int res2 = m2 | (nm1) | (nm2 << 1) | (nm2 >> 1) | (nm2);
							res2 &= (M - 1);
							
//							if(i == 2 && m1 == 3 && m2 == 2 && nm1 == 0 && nm2 == 0){
//								System.err.println(""kek"");
//								System.err.println(dp[i][m1][m2]);
//								System.err.println(res1 + "" | "" + res2);
//								System.err.println(M);
//							}
							
							int next1 = res2 & (M - 1);
							int next2 = nm2 & ( M - 1);
							int over = Integer.bitCount(nm1) + Integer.bitCount(nm2);
							
							if(i < n - 1)
								dp[i+1][next1][next2] = min(dp[i + 1][next1][next2], dp[i][m1][m2] + over);
							else
								if((res1 & (M - 1)) == (M - 1)){
									ans = min(dp[i][m1][m2] + over, ans);
								}
						}
					
				}
//		System.err.println(ans);
		out.println(n * m - ans);
		
		in.close();
		out.close();
	}
	String nextToken() throws IOException {
		while (!st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}
	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}
	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}
	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
	String nextLine() throws IOException {
		st = new StringTokenizer("""");
		return in.readLine();
	}
	boolean EOF() throws IOException {
		while (!st.hasMoreTokens()) {
			String s = in.readLine();
			if (s == null)
				return true;
			st = new StringTokenizer(s);
		}
		return false;
	}
}
",0111_C,CODEFORCES,4588,Petya and Spiders,"Little Petya loves training spiders. Petya has a board n × m in size. Each cell of the board initially has a spider sitting on it. After one second Petya chooses a certain action for each spider, and all of them humbly perform its commands. There are 5 possible commands: to stay idle or to move from current cell to some of the four side-neighboring cells (that is, one command for each of the four possible directions). Petya gives the commands so that no spider leaves the field. It is allowed for spiders to pass through each other when they crawl towards each other in opposite directions. All spiders crawl simultaneously and several spiders may end up in one cell. Petya wants to know the maximum possible number of spider-free cells after one second.
The first line contains two space-separated integers n and m (1 ≤ n, m ≤ 40, n·m ≤ 40) — the board sizes.
In the first line print the maximum number of cells without spiders.
In the first sample the only possible answer is:
s
","input
In the second sample one of the possible solutions is: 
output
s denotes command ""stay idle"", l, r, d, u denote commands ""crawl left"", ""crawl right"", ""crawl down"", ""crawl up"", correspondingly.
","bitmasks, dp, dsu",7
"import java.awt.Point;
import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;
import static java.lang.Math.*;
 
public class Solution15A {
        
        final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"")!=null;
        BufferedReader in;
        PrintWriter out;
        StringTokenizer tok = new StringTokenizer("""");
        
        void init() throws FileNotFoundException{
                if (ONLINE_JUDGE){
                        in = new BufferedReader(new InputStreamReader(System.in));
                        out = new PrintWriter(System.out);
                }else{
                        in = new BufferedReader(new FileReader(""input.txt""));
                        out = new PrintWriter(""output.txt"");
                }
        }
        
        String readString() throws IOException{
                while(!tok.hasMoreTokens()){
                        tok = new StringTokenizer(in.readLine());
                }
                return tok.nextToken();
        }
        
        int readInt() throws IOException{
                return Integer.parseInt(readString());
        }
        
        long readLong() throws IOException{
                return Long.parseLong(readString());
        }
        
        double readDouble() throws IOException{
                return Double.parseDouble(readString());
        }
        
        public static void main(String[] args){
                new Solution15A().run();
        }
        
        public void run(){
                try{
                        long t1 = System.currentTimeMillis();
                        init();
                        solve();
                        out.close();
                        long t2 = System.currentTimeMillis();
                        System.err.println(""Time = ""+(t2-t1));
                }catch (Exception e){
                        e.printStackTrace(System.err);
                        System.exit(-1);
                }
        }
        
        static class Utils {
 
                private Utils() {}
 
                public static void mergeSort(int[] a) {
                        mergeSort(a, 0, a.length - 1);
                }
 
                private static void mergeSort(int[] a, int leftIndex, int rightIndex) {
                        final int MAGIC_VALUE = 50;
                        if (leftIndex < rightIndex) {
                                if (rightIndex - leftIndex <= MAGIC_VALUE) {
                                        insertionSort(a, leftIndex, rightIndex);
                                } else {
                                        int middleIndex = (leftIndex + rightIndex) / 2;
                                        mergeSort(a, leftIndex, middleIndex);
                                        mergeSort(a, middleIndex + 1, rightIndex);
                                        merge(a, leftIndex, middleIndex, rightIndex);
                                }
                        }
                }
 
                private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {
                        int length1 = middleIndex - leftIndex + 1;
                        int length2 = rightIndex - middleIndex;
                        int[] leftArray = new int[length1];
                        int[] rightArray = new int[length2];
                        System.arraycopy(a, leftIndex, leftArray, 0, length1);
                        System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);
                        for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {
                                if (i == length1) {
                                        a[k] = rightArray[j++];
                                } else if (j == length2) {
                                        a[k] = leftArray[i++];
                                } else {
                                        a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];
                                }
                        }
                }
 
                private static void insertionSort(int[] a, int leftIndex, int rightIndex) {
                        for (int i = leftIndex + 1; i <= rightIndex; i++) {
                                int current = a[i];
                                int j = i - 1;
                                while (j >= leftIndex && a[j] > current) {
                                        a[j + 1] = a[j];
                                        j--;
                                }
                                a[j + 1] = current;
                        }
                } 
        }
        
        class Square implements Comparable<Square>{
        	public Square(int x, int a){
        		this.x = x;
        		this.a = a;
        	}
        	
        	@Override
			public int compareTo(Square o) {
				if(this.x > o.x) return 1;
				if(this.x < o.x) return -1;
				return 0;
			}

			public int a, x;
        }
        
        
        void solve() throws IOException{
        	int n = readInt();
        	int t = readInt();
        	Square[] houses = new Square[n];
        	for(int i = 0; i < n; i++){
        		int a = readInt();
        		int b = readInt();
        		houses[i] = new Square(a, b);
        	}
        	Arrays.sort(houses);
        	int count = 0;
        	for(int i = 0; i < n; i++){
        		if(i == 0) count++;
        		else{
        			if(houses[i].x - houses[i].a/2.0 - t > houses[i-1].x + houses[i-1].a/2.0)
        				count++;
        		}
        		if(i == n - 1) count++;
        		else{
        			if(houses[i].x + houses[i].a/2.0 + t <= houses[i+1].x - houses[i+1].a/2.0)
        				count++;
        		}
        	}
        	out.println(count);
        }
        
        static double distance(long x1, long y1, long x2, long y2){
        	return Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
        }
        
        static long gcd(long a, long b){
        	while(a != b){
        		if(a < b) a -=b;
        		else b -= a;
        	}
        	return a;
        }
        
        static long lcm(long a, long b){
        	return a * b /gcd(a, b);
        }
}",0015_A,CODEFORCES,2258,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"/*
* Author: Nikhil Garg
* Date:   2010-12-05
*
*/
import java.io.*;
import java.util.*;
import java.math.*;

public class javatemp
{
	static String map(int a)
	{
		if( a == 0) return ""S"";
		else if ( a == 1 ) return ""M"";
		else if ( a == 2 ) return ""L"";
		else if ( a == 3 ) return ""XL"";
		else if ( a == 4 ) return ""XXL"";
		return """";
	}
	
	public static void main(String[] args) throws IOException
	{
		BufferedReader in = new BufferedReader( new InputStreamReader(System.in));
		int ans = 1000;
		in.readLine();
		String s = in.readLine();
		int H = 0;
		for(int i =0; i < s.length(); i++)
			if( s.charAt(i) == 'H') H++;

		
		for(int i = 0; i < s.length(); i++)
		{
			int count = 0;
			for(int j = 0; j < H; j++)
				if( s.charAt( (i +j) % s.length()) =='T') count ++;
			ans = Math.min ( ans, count);
		}
		System.out.println(ans);

	}
	
	
	static void debug(Object...os)
	{
		System.out.println(Arrays.deepToString(os));
	}
}",0046_C,CODEFORCES,1621,Hamsters and Tigers,"Today there is going to be an unusual performance at the circus — hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.
The first line contains number n (2 ≤ n ≤ 1000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols ""H"" and ""T"". The ""H""s correspond to hamsters and the ""T""s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.
","input
Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.
output
In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then — the tiger in position 9 with the hamster in position 7.
",twopointers,3
"import java.util.Scanner;

public class IQ {
  public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    int n = scan.nextInt();
    int[] a = new int[n];
    for(int i = 0; i < n; i++)
      a[i] = scan.nextInt();
    for(int i = 0; i < n; i++) {
      boolean x = a[i] % 2 == 0;
      int c = 0;
      for(int j = 0; j < n; j++) {
        if(x != (a[j] % 2 == 0))
          c++;
      }
      if(c == n-1) {
        System.out.println(i+1);
        break;
      }
    }
  }
}
",0025_A,CODEFORCES,1590,IQ test,"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given n numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given n numbers finds one that is different in evenness.
","input
The first line contains integer n (3 ≤ n ≤ 100) — amount of numbers in the task. The second line contains n space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.
output
Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.
",bruteforce,3
"import java.util.*;
import java.io.*;
public class A{
       
       public static void main(String args[]){
              Scanner sc = new Scanner(System.in);
              int n = sc.nextInt();
              int ans = 0;
              for(int i = 1; i <= n; i++){
                     ans += ((i*2) <= n) ? i : n-i+1;
              }
              System.out.println(ans);
       }
}",0909_B,CODEFORCES,1825,Segments,"You are given an integer N. Consider all possible segments on the coordinate axis with endpoints at integer points with coordinates between 0 and N, inclusive; there will be  of them.
You want to draw these segments in several layers so that in each layer the segments don't overlap (they might touch at the endpoints though). You can not move the segments to a different location on the coordinate axis. 
Find the minimal number of layers you have to use for the given N.
The only input line contains a single integer N (1 ≤ N ≤ 100).
","input
Output a single integer - the minimal number of layers required to draw the segments for the given N.
output
As an example, here are the segments and their optimal arrangement into layers for N = 4.
","constructivealgorithms, math",3
"



import java.util.*;



public class z3 {



    public static long tr(long n, long k) {



        long left = 1;

        long right = k;



        while (left < right) {

            long mid = (left + right) / 2;

            long s = sum(mid, k);

            if (s == n) {

                return k - mid + 1;

            } else if (s > n) {

                left = mid + 1;

            } else {

                right = mid;

            }

        }



        return k - left +2 ;

    }



    static long sum(long left, long right , long s) {

        if (left <= right) 

            s = sum(right) - sum(left-1);

        return s;

    }

       static long sum(long left, long right ) {

        return sum(left, right, 0);

    }





    static long sum(long n) {

        return n * (n + 1) / 2;

    }



    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);

         long n = in.nextLong();

        long k = in.nextLong();

        if (n == 1) {

            System.out.println(0);

        } else if (k >= n) {

            System.out.println(1);

        } else {

            n -= 1;

            k -= 1;

        

        

        if (sum(k) < n) {

            System.out.println(-1);

        } else {



            System.out.println(tr(n, k));



        }

        }

    }

}

",0287_B,CODEFORCES,903,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashSet;
import java.util.List;
import java.util.StringTokenizer;

public class D {

    int[][] fast(int n, int m){

        int[][] ans = new int[2][n * m];
        int c = 0;

        for (int left = 1, right = m; left < right; left++, right--) {
            for (int l = 1, r = n; l <= n && r >= 1; l++, r--) {
                ans[0][c] = l;
                ans[1][c++] = left;

                ans[0][c] = r;
                ans[1][c++] = right;
            }
        }

        if (m % 2 == 1) {
            int x = m/2 + 1;
            for(int l = 1, r = n;l < r;l++, r--){
                ans[0][c] = l;
                ans[1][c++] = x;

                ans[0][c] = r;
                ans[1][c++] = x;
                    if(n % 2 == 1 && l + 2 == r){
                        ans[0][c] = l+1;
                        ans[1][c++] = x;
                    }
            }
        }

        if(n == 1 && m % 2 == 1){
            ans[0][c] = 1;
            ans[1][c] = m/2 + 1;
        }

        return ans;
    }

    void stress(){

        for(int i = 3;i<=5;i++){
            for(int j = 2;j<=5;j++){
                int[][] ans = new int[2][];
                try{
                    ans = fast(i, j);
                }catch(Exception e){
                    out.println(""ошибка"");
                    out.print(i + "" "" + j);
                    return;
                }

                boolean[][] check = new boolean[i][j];
                for(int c = 0;c<ans[0].length;c++){
                    int x = ans[0][c] - 1;
                    int y = ans[1][c] - 1;
                    check[x][y] = true;
                }

                for(int c = 0;c<i;c++){
                    for(int q = 0;q<j;q++){
                        if(!check[c][q]){
                            out.println(i + "" "" + j);
                            out.println(""точки"");
                            for(int w = 0;w<ans[0].length;w++){
                                out.println(ans[0][w] + "" "" + ans[1][w]);
                            }
                            return;
                        }
                    }
                }

                HashSet<String> set = new HashSet<>();
                for(int c = 1;c<ans[0].length;c++){
                    int x = ans[0][c] - ans[0][c- 1];
                    int y = ans[1][c] - ans[1][c - 1];
                    set.add(x + "" "" + y);
                }

                if(set.size() < i * j - 1){
                    out.println(i + "" "" + j);
                    out.println(""вектора"");
                    for(int w = 0;w<ans[0].length;w++){
                        out.println(ans[0][w] + "" "" + ans[1][w]);
                    }
                    return;
                }
            }
        }
    }

    void normal(){
        int n =readInt();
        int m = readInt();
        int[][] ans = fast(n, m);
        for(int i = 0;i<ans[0].length;i++){
            out.println(ans[0][i] + "" "" + ans[1][i]);
        }
    }

    boolean stress = false;
    void solve(){
        if(stress) stress();
        else normal();
    }

    public static void main(String[] args) {
        new D().run();
    }

    void run(){
        init();
        solve();
        out.close();
    }

    BufferedReader in;
    PrintWriter out;

    StringTokenizer tok = new StringTokenizer("""");

    void init(){
        in = new BufferedReader(new InputStreamReader(System.in));
        out  = new PrintWriter(System.out);
    }

    String readLine(){
        try{
            return in.readLine();
        }catch(Exception ex){
            throw new RuntimeException(ex);
        }
    }
    String readString(){
        while(!tok.hasMoreTokens()){
            String nextLine = readLine();
            if(nextLine == null) return null;
            tok = new StringTokenizer(nextLine);
        }
        return tok.nextToken();
    }

    int readInt(){
        return Integer.parseInt(readString());
    }

    long readLong(){
        return Long.parseLong(readString());
    }

    double readDouble(){
        return Double.parseDouble(readString());
    }
}
",1179_B,CODEFORCES,3429,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms,5
"//package round584;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.InputMismatchException;
import java.util.Map;

public class E1 {
	InputStream is;
	PrintWriter out;
	String INPUT = """";
	
	void solve()
	{
		for(int T = ni();T > 0;T--){
			int n = ni(), m = ni();
			int[][] a = new int[n][];
			for(int i = 0;i < n;i++)a[i] = na(m);
			
			int[][] sss = new int[1<<n][m];
			for(int i = 1;i < 1<<n;i+=2){
				int[] ss = new int[m];
				for(int j = 0;j < m;j++){
					int cur = i;
					int lmax = 0;
					for(int sh = 0;sh < n;sh++){
						int s = 0;
						for(int k = 0;k < n;k++){
							if(cur<<~k<0){
								s += a[k][j];
							}
						}
						lmax = Math.max(lmax, s);
						cur = cur>>>1|(cur&1)<<n-1;
					}
					ss[j] = lmax;
				}
				sss[i] = ss;
			}
			ptns = new HashMap<>();
			dfs(new int[n], 0, -1);
			int ans = 0;
			if(n == 4 && m >= 4){
				int[] one = Arrays.copyOf(sss[1], m);
				Arrays.sort(one);
				ans = one[m-1] + one[m-2] + one[m-3] + one[m-4];
			}
			
			for(int[] cs : ptns.values()){
				if(cs.length == 4)continue;
				int[] u = new int[cs.length];
				inner:
				do{
					for(int i = 0;i < cs.length;i++){
						for(int j = i+1;j < cs.length;j++){
							if(u[i] == u[j])continue inner;
						}
					}
					int val = 0;
					for(int i = 0;i < cs.length;i++){
						val += sss[cs[i]][u[i]];
					}
					ans = Math.max(ans, val);
				}while(inc(u, m));
			}
			out.println(ans);
		}
	}
	
	public static boolean inc(int[] a, int base) {
		int n = a.length;
		int i;
		for (i = n - 1; i >= 0 && a[i] == base - 1; i--)
			;
		if (i == -1)
			return false;

		a[i]++;
		Arrays.fill(a, i + 1, n, 0);
		return true;
	}

	
	Map<Long, int[]> ptns = new HashMap<>();
//	Set<Long> all = new HashSet<>();
	
	void dfs(int[] a, int pos, int max)
	{
		if(pos == a.length){
			int[] ptn = new int[max+1];
			int n = a.length;
			for(int i = 0;i < n;i++){
				ptn[a[i]] |= 1<<i;
			}
			for(int i = 0;i <= max;i++){
				ptn[i] = ptn[i]>>>Integer.numberOfTrailingZeros(ptn[i]);
			}
//			for(int i = 0;i <= max;i++){
//				int min = ptn[i];
//				int k = ptn[i];
//				for(int j = 0;j < 12;j++){
//					int nk = k>>>1|(k&1)<<11;
//					k = nk;
//					min = Math.min(min, k);
//				}
//				ptn[i] = min;
//			}
			Arrays.sort(ptn);
			long h = 0;
			for(int v : ptn){
				h= h * 1000000009 + v;
			}
//			all.add(h);
			ptns.put(h, ptn);
			return;
		}
		
		for(int i = 0;i <= max+1;i++){
			a[pos] = i;
			dfs(a, pos+1, Math.max(i, max));
		}
	}
	
	void run() throws Exception
	{
//		int n = 4, m = 100;
//		Random gen = new Random();
//		StringBuilder sb = new StringBuilder();
//		sb.append(40 + "" "");
//		for(int rep = 0;rep < 40;rep++){
//			sb.append(n + "" "");
//			sb.append(m + "" "");
//			for (int i = 0; i < n*m; i++) {
//				sb.append(gen.nextInt(100000) + "" "");
//			}
//		}
//		INPUT = sb.toString();


		
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception { new E1().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",1209_E1,CODEFORCES,4750,Rotate Columns (easy version),"This is an easier version of the next problem. The difference is only in constraints.
You are given a rectangular $$$n \times m$$$ matrix $$$a$$$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want (possibly zero). You can perform this operation to a column multiple times.
After you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $$$i$$$-th row it is equal $$$r_i$$$. What is the maximal possible value of $$$r_1+r_2+\ldots+r_n$$$?
The first line contains an integer $$$t$$$ ($$$1 \le t \le 40$$$), the number of test cases in the input.
The first line of each test case contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 4$$$, $$$1 \le m \le 100$$$) — the number of rows and the number of columns in the given matrix $$$a$$$. 
Each of the following $$$n$$$ lines contains $$$m$$$ integers, the elements of $$$a$$$ ($$$1 \le a_{i, j} \le 10^5$$$).
Print $$$t$$$ integers: answers for all test cases in the order they are given in the input.
","input
In the first test case, you can shift the third column down by one, this way there will be $$$r_1 = 5$$$ and $$$r_2 = 7$$$.
output
In the second case you can don't rotate anything at all, this way there will be $$$r_1 = r_2 = 10$$$ and $$$r_3 = 9$$$.
","bitmasks, bruteforce, dp, greedy, sortings",7
"import java.util.Scanner;
import java.io.OutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		Scanner in = new Scanner(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
    public void solve(int testNumber, Scanner in, PrintWriter out) {
        int balance = in.nextInt();
        if (balance >= 0) {
            out.println(balance);
            return;
        }

        balance = -balance;
        int a = balance / 100;

        int b = Math.min(balance % 10, (balance / 10) % 10);

        balance = -(a * 10 + b);

        out.println(balance);
    }
}

",0313_A,CODEFORCES,345,Ilya and Bank Account,"Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.
Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.
Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.
The single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.
In a single line print an integer — the maximum state of the bank account that Ilya can get. 
","input
In the first test sample Ilya doesn't profit from using the present.
output
In the second test sample you can delete digit 1 and get the state of the account equal to 0.
","implementation, numbertheory",1
"
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.PrintStream;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Wolfgang Beyer
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            long MOD = 1000000007;

            long[] current = new long[n + 3];
            //long[] sum = new long[n + 3];
            current[0] = 1;

            for (int i = 0; i < n - 1; i++) {

                String s = in.next();
                if (s.equals(""f"")) {
                    for (int j = i + 1; j > 0; j--) {
                        current[j] = current[j - 1];
                        current[j] %= MOD;
                    }
                    current[0] = 0;
                } else {
                    for (int j = i + 1; j >= 0; j--) {
                        //sum[j] = sum[j + 1] + current[j];
                        current[j] = current[j + 1] + current[j];
                        current[j] %= MOD;
                    }
                    //for (int j = 0; j <= i + 1; j++) {
                    //  current[j] =
                    //}
                }
            }
            long result = 0;
            for (int i = 0; i <= n; i++) {
                result += current[i];
                result %= MOD;
            }
            out.println(result);
        }

    }

    static class InputReader {
        private static BufferedReader in;
        private static StringTokenizer tok;

        public InputReader(InputStream in) {
            this.in = new BufferedReader(new InputStreamReader(in));
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public String next() {
            try {
                while (tok == null || !tok.hasMoreTokens()) {
                    tok = new StringTokenizer(in.readLine());
                    //tok = new StringTokenizer(in.readLine(), "", \t\n\r\f""); //adds commas as delimeter
                }
            } catch (IOException ex) {
                System.err.println(""An IOException was caught :"" + ex.getMessage());
            }
            return tok.nextToken();
        }

    }
}

",0909_C,CODEFORCES,3113,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"import java.io.*;
import java.util.*;


public class A {
    
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int k = in.nextInt();
        int so[]= new int[n];
        for(int i=0;i<n;i++) so[i]=in.nextInt();
        Arrays.sort(so);
        if(m<=k) {
            System.out.println(""0"");
            return;
        }
        int sum=0;
        int socUsed=0;
        int cont=0;
        for(int i=n-1;i>=0;i--){
            cont++;
            sum+=so[i]; 
            if(sum>=m || sum+(k-1)>=m){
                System.out.println(cont);
                return;
            }   
            sum--;  
        }   
        System.out.println(""-1"");
    }
}
",0257_A,CODEFORCES,2676,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings",4
"// Don't place your source in a package

import java.math.BigInteger;
import java.util.*;
import java.lang.*;
import java.io.*;



// Please name your class Main
public class Main {
    static FastScanner fs=new FastScanner();
    static class FastScanner {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=new StringTokenizer("""");
        public String next() {
            while (!st.hasMoreElements())
                try {
                    st=new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            return st.nextToken();
        }
        int Int() {
            return Integer.parseInt(next());
        }

        long Long() {
            return Long.parseLong(next());
        }

        String Str(){
            return next();
        }
    }


    public static void main (String[] args) throws java.lang.Exception {
        PrintWriter out = new PrintWriter(System.out);


        int T=1;
        for(int t=0;t<T;t++){
            long k=Long();
            Solution sol=new Solution(out);
            sol.solution(k);
        }
        out.flush();

    }


    public static int Int(){
        return fs.Int();
    }
    public static long Long(){
        return fs.Long();
    }
    public static String Str(){
        return fs.Str();
    }

}






class Solution{
    PrintWriter out;
    public Solution(PrintWriter out){
        this.out=out;
    }


    long f[]=new long[15];
    public void solution(long k){
        f[0]=9;
        for(int i=1;i<f.length;i++){
            f[i]=10*f[i-1];
        }
        for(int i=1;i<f.length;i++){
            f[i]*=(i+1);
        }

        long l=1,r=1000000000000l;
        long res=-1;
        long count=0;
        while(l<=r){
            long mid=l+(r-l)/2;
            long cnt=get(mid);
            if(cnt>=k){
                res=mid;
                count=cnt;
                r=mid-1;
            }
            else{
                l=mid+1;
            }
        }

        int extra=(int)(count-k);
        String s=res+"""";
        out.println(s.charAt(s.length()-1-extra));
    }

    public long get(long n){
        long res=0;
        long base=0;
        int i=0;
        while(true){
            if(n<=base*10+9){
                res=res+(i+1)*(n-base);
                break;
            }
            res+=(f[i]);
            i++;
            base=base*10+9;
        }
        return res;
    }











}



/*
                             ;\
                            |' \
         _                  ; : ;
        / `-.              /: : |
       |  ,-.`-.          ,': : |
       \  :  `. `.       ,'-. : |
        \ ;    ;  `-.__,'    `-.|
         \ ;   ;  :::  ,::'`:.  `.
          \ `-. :  `    :.    `.  \
           \   \    ,   ;   ,:    (\
            \   :., :.    ,'o)): ` `-.
           ,/,' ;' ,::""'`.`---'   `.  `-._
         ,/  :  ; '""      `;'          ,--`.
        ;/   :; ;             ,:'     (   ,:)
          ,.,:.    ; ,:.,  ,-._ `.     \""""'/
          '::'     `:'`  ,'(  \`._____.-'""'
             ;,   ;  `.  `. `._`-.  \\
             ;:.  ;:       `-._`-.\  \`.
              '`:. :        |' `. `\  ) \
      -hrr-      ` ;:       |    `--\__,'
                   '`      ,'
                        ,-'


                      free bug dog
*/





",1177_B,CODEFORCES,1361,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author ankur
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            long k = in.nextLong();
            HashMap<Long, Integer> hm = new HashMap<>();
            long ar[] = in.nextLongArray(n);
            for (int i = 0; i < n; i++) {
                long dist = ar[i] + k;
                long min = k;
                for (int j = 0; j < n; j++) {
                    min = Math.min(min, Math.abs(ar[j] - dist));
                }
                if (min == k) {
                    hm.put(dist, 1);
                }
                dist = ar[i] - k;
                min = k;
                for (int j = 0; j < n; j++) {
                    min = Math.min(min, Math.abs(ar[j] - dist));
                }
                if (min == k) {
                    hm.put(dist, 1);
                }
            }
            out.print(hm.size());
        }

    }

    static class InputReader {
        private final InputStream stream;
        private final byte[] buf = new byte[8192];
        private int curChar;
        private int snumChars;

        public InputReader(InputStream st) {
            this.stream = st;
        }

        public int read() {
            //*-*------clare------
//remeber while comparing 2 non primitive data type not to use ==
//remember Arrays.sort for primitive data has worst time case complexity of 0(n^2) bcoz it uses quick sort
//again silly mistakes ,yr kb tk krta rhega ye mistakes
//try to write simple codes ,break it into simple things
//knowledge>rating
        /*
        public class Main
        implements Runnable{
    public static void main(String[] args) {
        new Thread(null,new Main(),""Main"",1<<26).start();

    }
    public void run() {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();//chenge the name of task
        solver.solve(1, in, out);
        out.close();
    }
         */

            if (snumChars == -1)
                throw new InputMismatchException();
            if (curChar >= snumChars) {
                curChar = 0;
                try {
                    snumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (snumChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public long[] nextLongArray(int n) {
            long a[] = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextLong();
            }
            return a;
        }

        public boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",1004_A,CODEFORCES,1975,Sonya and Hotels,"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.
The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $$$n$$$ hotels, where the $$$i$$$-th hotel is located in the city with coordinate $$$x_i$$$. Sonya is a smart girl, so she does not open two or more hotels in the same city.
Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $$$d$$$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 
Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $$$n$$$ hotels to the new one is equal to $$$d$$$.
The first line contains two integers $$$n$$$ and $$$d$$$ ($$$1\leq n\leq 100$$$, $$$1\leq d\leq 10^9$$$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.
The second line contains $$$n$$$ different integers in strictly increasing order $$$x_1, x_2, \ldots, x_n$$$ ($$$-10^9\leq x_i\leq 10^9$$$) — coordinates of Sonya's hotels.
Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $$$d$$$.
","input
In the first example, there are $$$6$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$-6$$$, $$$5$$$, $$$6$$$, $$$12$$$, $$$13$$$, and $$$19$$$.
output
In the second example, there are $$$5$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$2$$$, $$$6$$$, $$$13$$$, $$$16$$$, and $$$21$$$.
",implementation,3
"import java.io.*;
import java.util.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class cf287b {

    public static void main(String[] args) throws IOException {
        long n = rnl() - 1, k = nl(), sum = k * (k - 1) / 2;
        if(n > sum) {
            prln(-1);
        } else if(n == 0) {
            prln(0);
        } else {
            long l = 0, r = k - 2, max = 0;
            while(l <= r) {
                long m = l + (r - l) / 2;
                if(n <= sum - m * (m + 1) / 2) {
                    max = m;
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }
            prln(k - 1 - max);
        }
        close();
    }

    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));
    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));
    static StringTokenizer input;
    static Random rand = new Random();

    // references
    // IBIG = 1e9 + 7
    // IRAND ~= 3e8
    // IMAX ~= 2e10
    // LMAX ~= 9e18
    // constants
    static final int IBIG = 1000000007;
    static final int IRAND = 327859546;
    static final int IMAX = 2147483647;
    static final int IMIN = -2147483648;
    static final long LMAX = 9223372036854775807L;
    static final long LMIN = -9223372036854775808L;
    // util
    static int minof(int a, int b, int c) {return min(a, min(b, c));}
    static int minof(int... x) {return x.length == 1 ? x[0] : x.length == 2 ? min(x[0], x[1]) : min(x[0], minstarting(1, x));}
    static int minstarting(int offset, int... x) {assert x.length > 2; return offset == x.length - 2 ? min(x[offset], x[offset + 1]) : min(x[offset], minstarting(offset + 1, x));}
    static long minof(long a, long b, long c) {return min(a, min(b, c));}
    static long minof(long... x) {return x.length == 1 ? x[0] : x.length == 2 ? min(x[0], x[1]) : min(x[0], minstarting(1, x));}
    static long minstarting(int offset, long... x) {assert x.length > 2; return offset == x.length - 2 ? min(x[offset], x[offset + 1]) : min(x[offset], minstarting(offset + 1, x));}
    static int maxof(int a, int b, int c) {return max(a, max(b, c));}
    static int maxof(int... x) {return x.length == 1 ? x[0] : x.length == 2 ? max(x[0], x[1]) : max(x[0], maxstarting(1, x));}
    static int maxstarting(int offset, int... x) {assert x.length > 2; return offset == x.length - 2 ? max(x[offset], x[offset + 1]) : max(x[offset], maxstarting(offset + 1, x));}
    static long maxof(long a, long b, long c) {return max(a, max(b, c));}
    static long maxof(long... x) {return x.length == 1 ? x[0] : x.length == 2 ? max(x[0], x[1]) : max(x[0], maxstarting(1, x));}
    static long maxstarting(int offset, long... x) {assert x.length > 2; return offset == x.length - 2 ? max(x[offset], x[offset + 1]) : max(x[offset], maxstarting(offset + 1, x));}
    static int powi(int a, int b) {if(a == 0) return 0; int ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}
    static long powl(long a, int b) {if(a == 0) return 0; long ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}
    static int floori(double d) {return (int)d;}
    static int ceili(double d) {return (int)ceil(d);}
    static long floorl(double d) {return (long)d;}
    static long ceill(double d) {return (long)ceil(d);}
    static void shuffle(int[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}
    static void shuffle(long[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}
    static void shuffle(double[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}
    static <T> void shuffle(T[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); T swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}
    static void sort(int[] a) {shuffle(a); Arrays.sort(a);}
    static void sort(long[] a) {shuffle(a); Arrays.sort(a);}
    static void sort(double[] a) {shuffle(a); Arrays.sort(a);}
    static void qsort(int[] a) {Arrays.sort(a);}
    static void qsort(long[] a) {Arrays.sort(a);}
    static void qsort(double[] a) {Arrays.sort(a);}
    static int randInt(int min, int max) {return rand.nextInt(max - min + 1) + min;}
    // input
    static void r() throws IOException {input = new StringTokenizer(__in.readLine());}
    static int ri() throws IOException {return Integer.parseInt(__in.readLine());}
    static long rl() throws IOException {return Long.parseLong(__in.readLine());}
    static int[] ria(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()); return a;}
    static long[] rla(int n) throws IOException {long[] a = new long[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Long.parseLong(input.nextToken()); return a;}
    static char[] rcha() throws IOException {return __in.readLine().toCharArray();}
    static String rline() throws IOException {return __in.readLine();}
    static int rni() throws IOException {input = new StringTokenizer(__in.readLine()); return Integer.parseInt(input.nextToken());}
    static int ni() {return Integer.parseInt(input.nextToken());}
    static long rnl() throws IOException {input = new StringTokenizer(__in.readLine()); return Long.parseLong(input.nextToken());}
    static long nl() {return Long.parseLong(input.nextToken());}
    // output
    static void pr(int i) {__out.print(i);}
    static void prln(int i) {__out.println(i);}
    static void pr(long l) {__out.print(l);}
    static void prln(long l) {__out.println(l);}
    static void pr(double d) {__out.print(d);}
    static void prln(double d) {__out.println(d);}
    static void pr(char c) {__out.print(c);}
    static void prln(char c) {__out.println(c);}
    static void pr(char[] s) {__out.print(new String(s));}
    static void prln(char[] s) {__out.println(new String(s));}
    static void pr(String s) {__out.print(s);}
    static void prln(String s) {__out.println(s);}
    static void pr(Object o) {__out.print(o);}
    static void prln(Object o) {__out.println(o);}
    static void prln() {__out.println();}
    static void pryes() {__out.println(""yes"");}
    static void pry() {__out.println(""Yes"");}
    static void prY() {__out.println(""YES"");}
    static void prno() {__out.println(""no"");}
    static void prn() {__out.println(""No"");}
    static void prN() {__out.println(""NO"");}
    static void pryesno(boolean b) {__out.println(b ? ""yes"" : ""no"");};
    static void pryn(boolean b) {__out.println(b ? ""Yes"" : ""No"");}
    static void prYN(boolean b) {__out.println(b ? ""YES"" : ""NO"");}
    static void prln(int... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}
    static void prln(long... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}
    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for(int i = 0; i < n; __out.print(iter.next()), __out.print(' '), ++i); if(n >= 0) __out.println(iter.next());}
    static void h() {__out.println(""hlfd"");}
    static void flush() {__out.flush();}
    static void close() {__out.close();}
}",0287_B,CODEFORCES,958,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.util.Scanner;

import java.io.OutputStream;

import java.io.IOException;

import java.io.PrintWriter;

import java.io.InputStream;



/**

 * Built using CHelper plug-in

 * Actual solution is at the top

 * @author dy

 */

public class Main {

    public static void main(String[] args) {

        InputStream inputStream = System.in;

        OutputStream outputStream = System.out;

        Scanner in = new Scanner(inputStream);

        PrintWriter out = new PrintWriter(outputStream);

        TaskB solver = new TaskB();

        solver.solve(1, in, out);

        out.close();

    }

}



class TaskB {

    public void solve(int testNumber, Scanner in, PrintWriter out) {

        long N = in.nextLong();

        int K = in.nextInt();

        long pipes = 1;

        if(N == 1){

            out.println(0);return;

        }

        long left = 0, right = K - 1, find = -1;

        while (left <= right){

            long mid = (left + right) / 2;

            if(mid * mid + (1 - 2 * K) * mid + 2 * (N - 1) <= 0){

                find = mid;

                right = mid - 1;

            }

            else

                left = mid + 1;

        }

        out.println(find);

    }

}

",0287_B,CODEFORCES,910,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.io.*;
import java.util.*;

public class Main {

    private static void solve(InputReader in, OutputWriter out) {
        int n = in.nextInt();

        if (n < 6) {
            out.println(-1);
        } else {
            int m = (n - 2);
            for (int i = 2; i <= m; i++) {
                out.println(""1 "" + i);
            }
            out.println(m + "" "" + (m + 1));
            out.println(m + "" "" + (m + 2));
        }

        for (int i = 2; i <= n; i++) {
            out.println(""1 "" + i);
        }
    }

    private static void shuffleArray(int[] array) {
        int index;
        Random random = new Random();
        for (int i = array.length - 1; i > 0; i--) {
            index = random.nextInt(i + 1);
            if (index != i) {
                array[index] ^= array[i];
                array[i] ^= array[index];
                array[index] ^= array[i];
            }
        }
    }

    public static void main(String[] args) {
        InputReader in = new InputReader(System.in);
        OutputWriter out = new OutputWriter(System.out);
        solve(in, out);
        in.close();
        out.close();
    }

    private static class InputReader {
        private BufferedReader br;
        private StringTokenizer st;

        InputReader(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
            st = null;
        }

        String nextLine() {
            String line = null;
            try {
                line = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return line;
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                String line = nextLine();
                if (line == null) return null;
                st = new StringTokenizer(line);
            }
            return st.nextToken();
        }

        byte nextByte() {
            return Byte.parseByte(next());
        }

        short nextShort() {
            return Short.parseShort(next());
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        void close() {
            try {
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private static class OutputWriter {
        BufferedWriter bw;

        OutputWriter(OutputStream os) {
            bw = new BufferedWriter(new OutputStreamWriter(os));
        }

        void print(int i) {
            print(Integer.toString(i));
        }

        void println(int i) {
            println(Integer.toString(i));
        }

        void print(long l) {
            print(Long.toString(l));
        }

        void println(long l) {
            println(Long.toString(l));
        }

        void print(double d) {
            print(Double.toString(d));
        }

        void println(double d) {
            println(Double.toString(d));
        }

        void print(boolean b) {
            print(Boolean.toString(b));
        }

        void println(boolean b) {
            println(Boolean.toString(b));
        }

        void print(char c) {
            try {
                bw.write(c);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        void println(char c) {
            println(Character.toString(c));
        }

        void print(String s) {
            try {
                bw.write(s);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        void println(String s) {
            print(s);
            print('\n');
        }

        void close() {
            try {
                bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
",0959_C,CODEFORCES,1846,Mahmoud and Ehab and the wrong algorithm,"Mahmoud was trying to solve the vertex cover problem on trees. The problem statement is:
Given an undirected tree consisting of n nodes, find the minimum number of vertices that cover all the edges. Formally, we need to find a set of vertices such that for each edge (u, v) that belongs to the tree, either u is in the set, or v is in the set, or both are in the set. Mahmoud has found the following algorithm:
The depth of a node in a tree is the number of edges in the shortest path between this node and the root. The depth of the root is 0.
Ehab told Mahmoud that this algorithm is wrong, but he didn't believe because he had tested his algorithm against many trees and it worked, so Ehab asked you to find 2 trees consisting of n nodes. The algorithm should find an incorrect answer for the first tree and a correct answer for the second one.
The only line contains an integer n (2 ≤ n ≤ 105), the number of nodes in the desired trees.
The output should consist of 2 independent sections, each containing a tree. The algorithm should find an incorrect answer for the tree in the first section and a correct answer for the tree in the second. If a tree doesn't exist for some section, output ""-1"" (without quotes) for that section only.
If the answer for a section exists, it should contain n - 1 lines, each containing 2 space-separated integers u and v (1 ≤ u, v ≤ n), which means that there's an undirected edge between node u and node v. If the given graph isn't a tree or it doesn't follow the format, you'll receive wrong answer verdict.
If there are multiple answers, you can print any of them.
In the first sample, there is only 1 tree with 2 nodes (node 1 connected to node 2). The algorithm will produce a correct answer in it so we printed  - 1 in the first section, but notice that we printed this tree in the second section.
","input
In the second sample:
output
In the first tree, the algorithm will find an answer with 4 nodes, while there exists an answer with 3 nodes like this:  In the second tree, the algorithm will find an answer with 3 nodes which is correct: 
","constructivealgorithms, trees",3
"import java.io.*;
import java.util.*;

public class F {
    public static void main(String[] args) throws IOException {
        try (Input input = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {
            int n = input.nextInt();
            int[] p = new int[n + 1];
            for (int i = 1; i <= n; i++) {
                p[i] = input.nextInt();
            }
            int[] parent = new int[n + 1];
            int[] childrenCount = new int[n + 1];
            for (int u = 2; u <= n; u++) {
                parent[u] = input.nextInt();
                childrenCount[parent[u]]++;
            }
            int[][] g = new int[n + 1][];
            for (int i = 1; i <= n; i++) {
                g[i] = new int[childrenCount[i]];
                childrenCount[i] = 0;
            }
            for (int u = 2; u <= n; u++) {
                int v = parent[u];
                g[v][childrenCount[v]++] = u;
            }
            class Path {
                final int v1, v2, lca;

                Path(int v1, int v2, int lca) {
                    this.v1 = v1;
                    this.v2 = v2;
                    this.lca = lca;
                }

                private boolean isVertical() {
                    return lca == v1 || lca == v2;
                }

                private int getLeft() {
                    return v1 == lca ? v2 : v1;
                }

                private int getRight() {
                    return v2;
                }

                @Override
                public String toString() {
                    if (lca == v1) {
                        return String.format(""%d->%d"", v1, v2);
                    }
                    return String.format(""%d->(%d)->%d"", v1, lca, v2);
                }
            }
            class LCA {
                private final int[] enter = new int[n + 1];
                private final int[] leave = new int[n + 1];
                private final int[] timeline = new int[2 * n];
                private int time = 0;

                private void dfs(int u) {
                    enter[u] = time;
                    timeline[time++] = u;
                    for (int v : g[u]) {
                        dfs(v);
                        timeline[time++] = u;
                    }
                    leave[u] = time;
                }

                {
                    dfs(1);
                }

                class SegmentTree {
                    int size = 1;
                    {
                        while (size <= timeline.length) {
                            size *= 2;
                        }
                    }
                    final int[] a = new int[2 * size];
                    {
                        enter[0] = Integer.MAX_VALUE;
                        System.arraycopy(timeline, 0, a, size, time);
                        for (int i = size - 1; i > 0; i--) {
                            int left = a[2 * i];
                            int right = a[2 * i + 1];
                            a[i] = enter[left] < enter[right] ? left : right;
                        }
                    }

                    int getLCA(int v1, int v2) {
                        int from = Math.min(enter[v1], enter[v2]);
                        int to = enter[v1] + enter[v2] - from;
                        int lca = 0;
                        for (from += size, to += size; from < to; from /= 2, to /= 2) {
                            if (from % 2 == 1) {
                                if (enter[a[from]] < enter[lca]) {
                                    lca = a[from];
                                }
                                from++;
                            }
                            if (to % 2 == 1) {
                                --to;
                                if (enter[a[to]] < enter[lca]) {
                                    lca = a[to];
                                }
                            }
                        }
                        return lca;
                    }
                }

                private boolean isParent(int p, int u) {
                    return enter[p] <= enter[u] && leave[p] >= leave[u];
                }

                private SegmentTree st = new SegmentTree();

                Path unitePaths(Path p1, Path p2) {
                    if (p1 == null || p2 == null) {
                        return null;
                    }
                    if (!p1.isVertical() && !p2.isVertical()) {
                        if (p1.lca != p2.lca) {
                            return null;
                        }
                        int v1 = isParent(p1.v1, p2.v1) ? p2.v1 : p1.v1;
                        int v2 = isParent(p1.v2, p2.v2) ? p2.v2 : p1.v2;
                        for (int u : new int[]{p1.v1, p1.v2, p2.v1, p2.v2}) {
                            if (!isParent(u, v1) && !isParent(u, v2)) {
                                return null;
                            }
                        }
                        return new Path(v1, v2, p1.lca);
                    }
                    int lca = 0;
                    if (!p1.isVertical()) {
                        lca = p1.lca;
                    }
                    if (!p2.isVertical()) {
                        lca = p2.lca;
                    }
                    for (int u : new int[]{p1.v1, p1.v2}) {
                        for (int v : new int[]{p2.v1, p2.v2}) {
                            if (isParent(u, v) || isParent(v, u)) {
                                continue;
                            }
                            int l = st.getLCA(u, v);
                            if (lca == 0) {
                                lca = l;
                            }
                            if (l != lca) {
                                return null;
                            }
                        }
                    }
                    if (lca == 0) {
                        int v1 = isParent(p1.v1, p2.v1) ? p1.v1 : p2.v1;
                        int v2 = isParent(p1.v2, p2.v2) ? p2.v2 : p1.v2;
                        return new Path(v1, v2, v1);
                    }
                    int v1 = leave[p2.getLeft()] < leave[p1.getLeft()] ? p2.getLeft() : p1.getLeft();
                    int v2 = enter[p2.getRight()] > enter[p1.getRight()] ? p2.getRight() : p1.getRight();
                    for (int u : new int[]{p1.v1, p1.v2, p2.v1, p2.v2}) {
                        if (!isParent(u, v1) && !isParent(u, v2)) {
                            return null;
                        }
                        if (enter[u] < enter[lca]) {
                            return null;
                        }
                    }
                    return new Path(v1, v2, lca);
                }
            }
            final LCA lca = new LCA();
            int[] pReverse = new int[n];
            for (int i = 1; i <= n; i++) {
                pReverse[p[i]] = i;
            }
            class SegmentTree {
                private int size = 1;
                {
                    while (size <= n) {
                        size *= 2;
                    }
                }
                private Path[] a = new Path[2 * size];
                {
                    for (int i = 0; i < n; i++) {
                        a[size + i] = new Path(pReverse[i], pReverse[i], pReverse[i]);
                    }
                    for (int i = size - 1; i > 0; i--) {
                        a[i] = lca.unitePaths(a[2 * i], a[2 * i + 1]);
                    }
                }

                private void swap(int u, int v) {
                    int pu = p[u];
                    int pv = p[v];
                    p[u] = pv;
                    p[v] = pu;
                    pReverse[pv] = u;
                    pReverse[pu] = v;
                    Path pathU = a[size + pu];
                    Path pathV = a[size + pv];
                    a[size + pu] = pathV;
                    a[size + pv] = pathU;
                    for (pu = pu + size >> 1, pv = pv + size >> 1; pu > 0; pu /= 2, pv /= 2) {
                        a[pu] = lca.unitePaths(a[2 * pu], a[2 * pu + 1]);
                        if (pv != pu) {
                            a[pv] = lca.unitePaths(a[2 * pv], a[2 * pv + 1]);
                        }
                    }
                }

                private int getMex() {
                    int i = 1, l = size;
                    while (a[i] == null) {
                        i *= 2;
                        l /= 2;
                    }
                    Path p = a[i];
                    int mex = l;
                    i = 2 * i + 2;
                    while (l > 1) {
                        Path r = lca.unitePaths(p, a[i]);
                        l /= 2;
                        if (r == null) {
                            i *= 2;
                            continue;
                        }
                        i = 2 * i + 2;
                        p = r;
                        mex += l;
                    }
                    return mex;
                }
            }
            SegmentTree st = new SegmentTree();
            int q = input.nextInt();
            for (int i = 0; i < q; i++) {
                if (input.nextInt() == 2) {
                    writer.println(st.getMex());
                } else {
                    st.swap(input.nextInt(), input.nextInt());
                }
            }
        }
    }

    interface Input extends Closeable {
        String next() throws IOException;

        default int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        default long nextLong() throws IOException {
            return Long.parseLong(next());
        }
    }

    private static class StandardInput implements Input {
        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        private StringTokenizer stringTokenizer;

        @Override
        public void close() throws IOException {
            reader.close();
        }

        @Override
        public String next() throws IOException {
            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {
                stringTokenizer = new StringTokenizer(reader.readLine());
            }
            return stringTokenizer.nextToken();
        }
    }
}",1084_F,CODEFORCES,2901,Max Mex,"Once Grisha found a tree (connected graph without cycles) with a root in node $$$1$$$.
But this tree was not just a tree. A permutation $$$p$$$ of integers from $$$0$$$ to $$$n - 1$$$ is written in nodes, a number $$$p_i$$$ is written in node $$$i$$$.
As Grisha likes to invent some strange and interesting problems for himself, but not always can solve them, you need to help him deal with two types of queries on this tree.
Let's define a function $$$MEX(S)$$$, where $$$S$$$ is a set of non-negative integers, as a smallest non-negative integer that is not included in this set.
Let $$$l$$$ be a simple path in this tree. So let's define indices of nodes which lie on $$$l$$$ as $$$u_1$$$, $$$u_2$$$, $$$\ldots$$$, $$$u_k$$$. 
Define $$$V(l)$$$ as a set {$$$p_{u_1}$$$, $$$p_{u_2}$$$, $$$\ldots$$$ , $$$p_{u_k}$$$}. 
Then queries are: 
The first line contains a single integer $$$n$$$ ($$$2 \leq n \leq 2 \cdot 10^5$$$) — the number of nodes of a tree.
The second line contains $$$n$$$ integers — $$$p_1$$$, $$$p_2$$$, $$$\ldots$$$, $$$p_n$$$ ($$$0\leq p_i < n$$$) — the permutation $$$p$$$, it's guaranteed that all numbers are different .
The third line contains $$$n - 1$$$ integers — $$$d_2$$$, $$$d_3$$$, $$$\ldots$$$, $$$d_n$$$ ($$$1 \leq d_i < i$$$), where $$$d_i$$$ is a direct ancestor of node $$$i$$$ in a tree.
The fourth line contains a single integer $$$q$$$ ($$$1 \leq q \leq 2 \cdot 10^5$$$) — the number of queries.
The following $$$q$$$ lines contain the description of queries:
At the beginning of each of next $$$q$$$ lines, there is a single integer $$$t$$$ ($$$1$$$ or $$$2$$$) — the type of a query: 
","input
For each type 2 query print a single integer — the answer for this query.
output
Number written in brackets is a permutation value of a node. 
","datastructures, trees",4
"import java.util.Scanner;

public class SportMafia {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		int k = sc.nextInt();
		
		int next = 1;
		int current = 0;
		int result = 0;
		
		for(int i = 0; i < n; i++) {
			if(current < k) {
				current += next++;
			} else {
				current--;
				result++;
			}
		}
		
		System.out.println(result);
		
		sc.close();
	}
}
",1195_B,CODEFORCES,1431,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import java.util.*;
import java.io.*;
public class LCMChallenge
{
	public static void main(String[] args)
	{
		Scanner in = new Scanner(System.in);
		
		int n = in.nextInt();
		
		if(n < 3)
		{
			System.out.println(n);
		}
		else if(n % 2 == 1)
		{
			System.out.println((long)n * (n - 1) * (n - 2));
		}
		else
		{
			if(n % 3 != 0)
			{
				System.out.println((long)n * (n - 1) * (n - 3));
			}
			else
			{
				System.out.println((long)(n - 1) * (n - 2) * (n - 3));
			}
		}
	}
}
",0235_A,CODEFORCES,240,LCM Challenge,"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.
But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than n. Can you help me to find the maximum possible least common multiple of these three integers?
The first line contains an integer n (1 ≤ n ≤ 106) — the n mentioned in the statement.
Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than n.
The least common multiple of some positive integers is the least positive integer which is multiple for each of them.
","input
The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.
output
For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.
",numbertheory,1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class C {
	BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
	StringTokenizer st = null;

	private void solution() throws IOException {
		int n = nextInt();
		int[] mas = new int[n];
		for (int i = 0; i < n; i++) {
			mas[i] = nextInt();
		}

		Arrays.sort(mas);

		if (mas[n - 1] == 1) {
			mas[n - 1] = 2;
		} else {
			mas[n - 1] = 1;
		}
		Arrays.sort(mas);
		for (int i = 0; i < n; i++) {
			System.out.print(mas[i] + "" "");
		}

	}

	String nextToken() throws IOException {
		if (st == null || !st.hasMoreTokens()) {
			st = new StringTokenizer(bf.readLine());
		}
		return st.nextToken();
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	public static void main(String args[]) throws IOException {
		new C().solution();
	}
}",0135_A,CODEFORCES,2404,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings",4
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.FilterInputStream;
import java.io.BufferedInputStream;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Jenish
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        ScanReader in = new ScanReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        C489 solver = new C489();
        solver.solve(1, in, out);
        out.close();
    }

    static class C489 {
        int mod = 1000000007;

        public void solve(int testNumber, ScanReader in, PrintWriter out) {
            long x = in.scanLong();
            long k = in.scanLong();
            if (x == 0) {
                out.println(0);
                return;
            }
            long p = CodeX.power(2, k, mod);
            long ans = (2 * p * (x % mod)) % mod;
            ans = (ans + 1) % mod;
            ans = (ans - p + mod) % mod;
            out.println(ans);
        }

    }

    static class CodeX {
        public static long power(long x, long y, long p) {
            long res = 1;
            x = x % p;
            while (y > 0) {
                if ((y & 1) != 0)
                    res = (res * x) % p;
                y = y >> 1;
                x = (x * x) % p;
            }
            return res;
        }

    }

    static class ScanReader {
        private byte[] buf = new byte[4 * 1024];
        private int INDEX;
        private BufferedInputStream in;
        private int TOTAL;

        public ScanReader(InputStream inputStream) {
            in = new BufferedInputStream(inputStream);
        }

        private int scan() {
            if (INDEX >= TOTAL) {
                INDEX = 0;
                try {
                    TOTAL = in.read(buf);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (TOTAL <= 0) return -1;
            }
            return buf[INDEX++];
        }

        private boolean isWhiteSpace(int n) {
            if (n == ' ' || n == '\n' || n == '\r' || n == '\t' || n == -1) return true;
            else return false;
        }

        public long scanLong() {
            long I = 0;
            int n = scan();
            while (isWhiteSpace(n)) n = scan();
            int neg = 1;
            if (n == '-') {
                neg = -1;
                n = scan();
            }
            while (!isWhiteSpace(n)) {
                if (n >= '0' && n <= '9') {
                    I *= 10;
                    I += n - '0';
                    n = scan();
                }
            }
            return neg * I;
        }

    }
}

",0992_C,CODEFORCES,1190,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"/*
If you want to aim high, aim high
Don't let that studying and grades consume you
Just live life young
******************************
If I'm the sun, you're the moon
Because when I go up, you go down
*******************************
I'm working for the day I will surpass you
****************************************

*/ 
  
import java.util.*;
import java.awt.Point;
import java.lang.Math; 
import java.util.Arrays;
import java.util.Scanner;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.util.Comparator;
import java.math.BigInteger;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.stream.IntStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.StringTokenizer;
 
public class Main {
     
	public static void main(String[] args) {
		FastScanner in=new FastScanner();
		OutputStream outputStream = System.out;
          PrintWriter out = new PrintWriter(outputStream);
        
          int a[][] = new int[26][9];
          for(int i=0;i<3;i++){
               String S = in.n();
               a[S.charAt(1)-'a'][S.charAt(0)-'1']++;
          }
          int max = 0;
          for (int c=0; c<26; c++) {
            for (int d=0; d<9; d++) {
                max = Math.max(max, a[c][d]);
            }
          }
          int minKoutsu = 3-max;
          max = 0;
           for (int c=0; c<26; c++) {
            for (int d=2; d<9; d++) {
                int count = 0;
                for (int i=-2; i<=0; i++) {
                    if (a[c][d+i] > 0) {
                        count++;
                    }
                }
                max = Math.max(max, count);
            }
        }
        int minShuntsu = 3-max;
        int answer = Math.min(minKoutsu, minShuntsu);
        System.out.println(answer);
        
          
	}
     
     private static int sumOfDigits(int number) {
        if (number <= 0) return 0;
        int sum = 0;
        while (number > 0) {
            sum += number%10;
            number /= 10;
        }
        return sum;
    }
     
     static void ruffle_sort(int[] a) {
		//shandom_ruffle
		Random r=new Random();
		int n=a.length;
		for (int i=0; i<n; i++) {
			int oi=r.nextInt(i);
			int temp=a[i];
			a[i]=a[oi];
			a[oi]=temp;
		}
		
		//sort
		Arrays.sort(a);
	}
  
	static class FastScanner {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st=new StringTokenizer("""");
		String next() {
			while (!st.hasMoreTokens())
				try {
					st=new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			return st.nextToken();
		}
		
		int ni() {
			return Integer.parseInt(next());
		}
		void print(int a){
		     System.out.println(a);
		}
		String n(){
		     return next();
		}
		void ps(String a) {
		        System.out.print(a);
		}
		void pls(String a) {
		        System.out.println(a);
		}
		int[] ria(int n) {
			int[] a=new int[n];
			for (int i=0; i<n; i++) a[i]=ni();
			return a;
		}
		char[] rca(int n, String S){
		     char a[] = S. toCharArray();
		     return a;
		}
		int [][] rda(int n, int m){
		    int a[][] = new int[n][m];
		    for(int i=0;i<n;i++){
		        for(int j=0;j<m;j++){
		            a[i][j]=ni();
		        }
		    }
		    return a;
		}
		void pa(int [] a) {
			for (int i=0; i<a.length; i++)
		        System.out.print(a[i]+"" "");
		}
	
		
	     void pla(int [] a) {
			for (int i=0; i<a.length; i++)
		        System.out.println(a[i]);
		}
		
		long nl() {
			return Long.parseLong(next());
		}
	}
 
	
    static int max(){
         return Integer.MAX_VALUE;
    }
    	
 
    public int factorial(int n) {
            int fact = 1;
            int i = 1;
           while(i <= n) {
             fact *= i;
             i++;
           }
            return fact;
    }
    
    

    public static long gcd(long x,long y)
    {
    	if(x%y==0)
    		return y;
    	else
    		return gcd(y,x%y);
    }
    public static int gcd(int x,int y)
    {
    	if(x%y==0)
    		return y;
    	else 
    		return gcd(y,x%y);
    }
    public static int abs(int a,int b)
    {
    	return (int)Math.abs(a-b);
    }
    public static long abs(long a,long b)
    {
    	return (long)Math.abs(a-b);
    }
    public static int max(int a,int b)
    {
    	if(a>b)
    		return a;
    	else
    		return b;
    }
    public static int min(int a,int b)
    {
    	if(a>b)
    		return b;
    	else 
    		return a;
    }
    public static long max(long a,long b)
    {
    	if(a>b)
    		return a;
    	else
    		return b;
    }
    public static long min(long a,long b)
    {
    	if(a>b)
    		return b;
    	else 
    		return a;
    }
     
     
    public static long pow(long n,long p,long m)
    {
    	 long  result = 1;
    	  if(p==0)
    	    return 1;
    	if (p==1)
    	    return n;
    	while(p!=0)
    	{
    	    if(p%2==1)
    	        result *= n;
    	    if(result>=m)
    	    result%=m;
    	    p >>=1;
    	    n*=n;
    	    if(n>=m)
    	    n%=m;
    	}
    	return result;
    }
    public static long pow(long n,long p)
    {
    	long  result = 1;
    	  if(p==0)
    	    return 1;
    	if (p==1)
    	    return n;
    	while(p!=0)
    	{
    	    if(p%2==1)
    	        result *= n;	    
    	    p >>=1;
    	    n*=n;	    
    	}
    	return result;
     
    }
     
    static long sort(int a[]){  
         int n=a.length;
    	int b[]=new int[n];	
    	return mergeSort(a,b,0,n-1);
         
    }
     
    static long mergeSort(int a[],int b[],long left,long right){
         long c=0;
         if(left<right){   
          long mid=left+(right-left)/2;
    	 c= mergeSort(a,b,left,mid);
    	 c+=mergeSort(a,b,mid+1,right);
    	 c+=merge(a,b,left,mid+1,right); 
         }	
    	return c;	 
    }
    static long merge(int a[],int  b[],long left,long mid,long right){
         long c=0;int i=(int)left;int j=(int)mid; int k=(int)left;
         while(i<=(int)mid-1&&j<=(int)right){ 
              if(a[i]<=a[j]){
                   b[k++]=a[i++]; 
              }
              else{ 
                   b[k++]=a[j++];c+=mid-i;
              }
         }
         
         while (i <= (int)mid - 1)   
                 b[k++] = a[i++]; 
         while (j <= (int)right)
                 b[k++] = a[j++];
         for (i=(int)left; i <= (int)right; i++) 
    	        a[i] = b[i];
    	        return c; 
         }
         
      static class InputReader extends BufferedReader {
        public InputReader(InputStream st) {
            super(new InputStreamReader(st));
        }
 
        public String readLine() {
            try {
                return super.readLine();
            } catch (IOException e) {
                return null;
            }
        }
 
        private int readByte() {
            try {
                return read();
            } catch (IOException e) {
                throw new RuntimeException();
            }
        }
 
        public int ni() {
            int num = 0, b;
            boolean minus = false;
            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;
            if (b == '-') {
                minus = true;
                b = readByte();
            }
 
            while (true) {
                if (b >= '0' && b <= '9') {
                    num = num * 10 + (b - '0');
                } else {
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }
 
      
 
    } 
     
  } ",1191_B,CODEFORCES,748,Tokitsukaze and Mahjong,"Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $$$1$$$ to $$$9$$$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $$$\ldots$$$, 9m, 1p, 2p, $$$\ldots$$$, 9p, 1s, 2s, $$$\ldots$$$, 9s.
In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.
Do you know the minimum number of extra suited tiles she needs to draw so that she can win?
Here are some useful definitions in this game:
Some examples: 
Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.
The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $$$1$$$ to $$$9$$$ and the second character is m, p or s.
Print a single integer — the minimum number of extra suited tiles she needs to draw.
In the first example, Tokitsukaze already has a shuntsu.
","input
In the second example, Tokitsukaze already has a koutsu.
output
In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
","bruteforce, implementation",1
"//package baobab;

import java.io.*;
import java.util.*;

public class C {

    public static void main(String[] args) {
        CIO io = new CIO();
        try {
            Csolver solver = new Csolver(io);
            solver.solve();
        } finally {
            io.close();
        }
    }

}

class Csolver {
    CIO io;

    public Csolver(CIO io) {
        this.io = io;
    }

    public void solve() {
        int n = io.nextInt();
        String input = io.next();
        int[] count = new int[1000];
        int pokemonsInRange = 0;
        int answer = Integer.MAX_VALUE;
        int a = 0;
        int b = 0;
        for (; b < n ; b++) {
            char end = input.charAt(b);
            if (count[end] == 0) {
                pokemonsInRange++;
                answer = Integer.MAX_VALUE;
            }
            count[end]++;
            while (count[input.charAt(a)] > 1) {
                count[input.charAt(a)]--;
                a++;
            }
            answer = Math.min(answer, b-a+1);
        }
        io.println(answer);
    }

    private static class Pair implements Comparable<Pair> {
        int id;
        long val;

        public Pair(long val, int id) {
            this.val = val;
            this.id = id;
        }

        @Override
        public int compareTo(Pair o) {
            if (this.val < o.val) return -1;
            if (this.val > o.val) return 1;
            return this.id - o.id;
        }
    }

    private List<Integer>[] toGraph(CIO io, int n) {
        List<Integer>[] g = new ArrayList[n+1];
        for (int i=1; i<=n; i++) g[i] = new ArrayList<>();
        for (int i=1; i<=n-1; i++) {
            int a = io.nextInt();
            int b = io.nextInt();
            g[a].add(b);
            g[b].add(a);
        }
        return g;
    }
}

class CIO extends PrintWriter {
    private InputStreamReader r;
    private static final int BUFSIZE = 1 << 15;
    private char[] buf;
    private int bufc;
    private int bufi;
    private StringBuilder sb;

    public CIO() {
        super(new BufferedOutputStream(System.out));
        r = new InputStreamReader(System.in);

        buf = new char[BUFSIZE];
        bufc = 0;
        bufi = 0;
        sb = new StringBuilder();
    }

    private void fillBuf() throws IOException {
        bufi = 0;
        bufc = 0;
        while(bufc == 0) {
            bufc = r.read(buf, 0, BUFSIZE);
            if(bufc == -1) {
                bufc = 0;
                return;
            }
        }
    }

    private boolean pumpBuf() throws IOException {
        if(bufi == bufc) {
            fillBuf();
        }
        return bufc != 0;
    }

    private boolean isDelimiter(char c) {
        return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f';
    }

    private void eatDelimiters() throws IOException {
        while(true) {
            if(bufi == bufc) {
                fillBuf();
                if(bufc == 0) throw new RuntimeException(""IO: Out of input."");
            }

            if(!isDelimiter(buf[bufi])) break;
            ++bufi;
        }
    }

    public String next() {
        try {
            sb.setLength(0);

            eatDelimiters();
            int start = bufi;

            while(true) {
                if(bufi == bufc) {
                    sb.append(buf, start, bufi - start);
                    fillBuf();
                    start = 0;
                    if(bufc == 0) break;
                }

                if(isDelimiter(buf[bufi])) break;
                ++bufi;
            }

            sb.append(buf, start, bufi - start);

            return sb.toString();
        } catch(IOException e) {
            throw new RuntimeException(""IO.next: Caught IOException."");
        }
    }

    public int nextInt() {
        try {
            int ret = 0;

            eatDelimiters();

            boolean positive = true;
            if(buf[bufi] == '-') {
                ++bufi;
                if(!pumpBuf()) throw new RuntimeException(""IO.nextInt: Invalid int."");
                positive = false;
            }

            boolean first = true;
            while(true) {
                if(!pumpBuf()) break;
                if(isDelimiter(buf[bufi])) {
                    if(first) throw new RuntimeException(""IO.nextInt: Invalid int."");
                    break;
                }
                first = false;

                if(buf[bufi] >= '0' && buf[bufi] <= '9') {
                    if(ret < -214748364) throw new RuntimeException(""IO.nextInt: Invalid int."");
                    ret *= 10;
                    ret -= (int)(buf[bufi] - '0');
                    if(ret > 0) throw new RuntimeException(""IO.nextInt: Invalid int."");
                } else {
                    throw new RuntimeException(""IO.nextInt: Invalid int."");
                }

                ++bufi;
            }

            if(positive) {
                if(ret == -2147483648) throw new RuntimeException(""IO.nextInt: Invalid int."");
                ret = -ret;
            }

            return ret;
        } catch(IOException e) {
            throw new RuntimeException(""IO.nextInt: Caught IOException."");
        }
    }

    public long nextLong() {
        try {
            long ret = 0;

            eatDelimiters();

            boolean positive = true;
            if(buf[bufi] == '-') {
                ++bufi;
                if(!pumpBuf()) throw new RuntimeException(""IO.nextLong: Invalid long."");
                positive = false;
            }

            boolean first = true;
            while(true) {
                if(!pumpBuf()) break;
                if(isDelimiter(buf[bufi])) {
                    if(first) throw new RuntimeException(""IO.nextLong: Invalid long."");
                    break;
                }
                first = false;

                if(buf[bufi] >= '0' && buf[bufi] <= '9') {
                    if(ret < -922337203685477580L) throw new RuntimeException(""IO.nextLong: Invalid long."");
                    ret *= 10;
                    ret -= (long)(buf[bufi] - '0');
                    if(ret > 0) throw new RuntimeException(""IO.nextLong: Invalid long."");
                } else {
                    throw new RuntimeException(""IO.nextLong: Invalid long."");
                }

                ++bufi;
            }

            if(positive) {
                if(ret == -9223372036854775808L) throw new RuntimeException(""IO.nextLong: Invalid long."");
                ret = -ret;
            }

            return ret;
        } catch(IOException e) {
            throw new RuntimeException(""IO.nextLong: Caught IOException."");
        }
    }

    public double nextDouble() {
        return Double.parseDouble(next());
    }

}",0701_C,CODEFORCES,1779,They Are Everywhere,"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.
There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 
Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. 
The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.
The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. 
Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. 
In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.
","input
In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 
output
In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.
","binarysearch, strings, twopointers",3
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class C {
	BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
	StringTokenizer st = null;
	PrintWriter out;

	public void solution() throws IOException {
		int n = nextInt();
		int a[] = new int[n];
		int b[] = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = nextInt();
			b[i] = a[i];
		}
		Arrays.sort(a);
		int ans = 0;
		for (int i = 0; i < n; i++) {
			if (a[i] != b[i]) {
				ans++;
			}
		}

		if (ans == 2 || ans == 0) {
			System.out.println(""YES"");
		} else {
			System.out.println(""NO"");
		}

	}

	public String nextToken() throws IOException {
		if (st == null || !st.hasMoreTokens()) {
			st = new StringTokenizer(bf.readLine());
		}
		return st.nextToken();
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	public void print(int a[]) {
		for (int i = 0; i < a.length; i++) {
			System.out.print(a[i] + "" "");
		}
	}

	public static void main(String args[]) throws IOException {
		new C().solution();
	}
}",0220_A,CODEFORCES,2613,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class Main {
	public static void main(String[] args) throws Exception {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);

		Task task = new Task();
		task.solve(in, out);
		out.close();

	}
	
	static class Rectangle {
		int x1, y1;
		int x2, y2;
	}
	
	static class Task {
		/**
		 * BEFORE SUBMITTING!!!
		 * MAKE SURE IT IS RIGHT!!!!!
		 * LONG!!
		 * Check if m,n aren't misused
		 * Make sure the output format is right (YES/NO vs Yes/No, newlines vs spaces)
		 * Run with n = 1 or n = 0
		 * Make sure two ints aren't multiplied to get a long

		 *
		 */
		public void solve(InputReader in, PrintWriter out) {
			int n = in.nextInt();
			
			//ideas: procurar linha que os divide e procurar dentro desses sub-retangulos
			// procurar até ser 1
			
			//corner cases: se procurar até ser 1 e não verificar se tem 1 do outro lado posso chegar a 1,2...not good
			// tenho que procurar 1,1
			
			int l = 1;
			int r = n;
			
			int ans = 0;
			
			
			while(r >= l) {
				int mid = (r + l) / 2;
				if(ask(in,out,1,1,mid, n) == 0) {
					l = mid + 1;
				} else {
					ans = mid;
					r = mid - 1;
				}
			}
			//par 1,1
			//FDS ISTO
			if(ans < n && ask(in,out,ans + 1, 1,n,n) == 1) {
				Rectangle r1 = find(in,out,1,1,ans,n,n);
				Rectangle r2 = find(in,out,ans + 1,1,n,n,n);
				System.out.printf(""! %d %d %d %d %d %d %d %d\n"", r1.x1, r1.y1, r1.x2, r1.y2, r2.x1, r2.y1, r2.x2, r2.y2);
			} else {
				l = 1;
				r = n;
				
				ans = 0;
				
				
				while(r >= l) {
					int mid = (r + l) / 2;
					if(ask(in,out,1,1,n, mid) == 0) {
						l = mid + 1;
					} else {
						ans = mid;
						r = mid - 1;
					}
				}
				
				Rectangle r1 = find(in,out,1,1,n,ans,n);
				Rectangle r2 = find(in,out,1,ans + 1,n,n,n);
				System.out.printf(""! %d %d %d %d %d %d %d %d\n"", r1.x1, r1.y1, r1.x2, r1.y2, r2.x1, r2.y1, r2.x2, r2.y2);
				
			}
			
			
		}
		//HASDFDSJGHDFJKSGDFJSGJDFSGJDSFGJF
		//FKING WORK
		public Rectangle find(InputReader in, PrintWriter out,int x1, int y1, int x2, int y2, int n) {
			Rectangle rec = new Rectangle();
			
			int ansx1 = x1;
			int ansx2 = x2;
			int ansy1 = y1;
			int ansy2 = y2;

			int l = x1;
			int r = x2;
			

			// quero o minimo v >= x2 
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,y1,mid,y2) == 1) {
					ansx2 = mid;
					r = mid - 1;
				} else {
					l = mid + 1;
				}

			}
									
			//out.printf(""x2 = %d"", ansx2);
			
			

			r = x2;
			l = x1;
			
			// quero o maximo v <= x1
			
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,mid,y1,x2,y2) == 1) {
					ansx1 = mid;
					l = mid + 1;
				} else {
					r = mid - 1;
				}

			}
									
			//out.printf(""x1 = %d"", ansx1);
			
			
			l = y1;
			r = y2;
			
			// quero o minimo v >= y2 
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,y1,x2,mid) == 1) {
					ansy2 = mid;
					r = mid - 1;
				} else {
					l = mid + 1;
				}

			}
									
			//out.printf(""y2 = %d"", ansy2);
			

			
			

			r = y2;
			l = y1;
			

			// quero o maximo v <= y1
			
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,mid,x2,y2) == 1) {
					ansy1 = mid;
					l = mid + 1;
				} else {
					r = mid - 1;
				}

			}
									
			//out.printf(""y1 = %d"", ansy1);
			


			
			rec.x1 = ansx1;
			rec.x2 = ansx2;
			rec.y1 = ansy1;
			rec.y2 = ansy2;

			
			
			return rec;
		}
		
		public int ask(InputReader in, PrintWriter out, int x1, int y1, int x2, int y2) {
			System.out.printf(""? %d %d %d %d\n"",x1,y1,x2,y2);
			System.out.flush();
			return in.nextInt();
		}
	}

	static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader(InputStream stream) {
			reader = new BufferedReader(new InputStreamReader(stream), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}
		
		public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
               
            } catch (IOException e) {
            }
            return null;
        }


	}
}

",0713_B,CODEFORCES,1028,Searching Rectangles,"Filya just learned new geometry object — rectangle. He is given a field consisting of n × n unit cells. Rows are numbered from bottom to top with integer from 1 to n. Columns are numbered from left to right with integers from 1 to n. Cell, located at the intersection of the row r and column c is denoted as (r, c). Filya has painted two rectangles, such that their sides are parallel to coordinate axes and each cell lies fully inside or fully outside each of them. Moreover, no cell lies in both rectangles.
Later, hedgehog Filya became interested in the location of his rectangles but was unable to find the sheet of paper they were painted on. They were taken by Sonya and now she wants to play a little game with Filya. He tells her a query rectangle and she replies with the number of initial rectangles that lie fully inside the given query rectangle. The query rectangle should match the same conditions as initial rectangles. Rectangle lies fully inside the query if each o its cells lies inside the query.
Filya knows Sonya really well, so is sure that if he asks more than 200 questions she will stop to reply.
The first line of the input contains an integer n (2 ≤ n ≤ 216) — size of the field.
For each query an integer between 0 and 2 is returned — the number of initial rectangles that lie fully inside the query rectangle.
To make a query you have to print ""? x1 y1 x2 y2"" (without quotes) (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n), where (x1, y1) stands for the position of the bottom left cell of the query and (x2, y2) stands for the up right cell of the query. You are allowed to ask no more than 200 queries. After each query you should perform ""flush"" operation and read the answer.
In case you suppose you've already determined the location of two rectangles (or run out of queries) you should print ""! x11 y11 x12 y12 x21 y21 x22 y22"" (without quotes), where first four integers describe the bottom left and up right cells of the first rectangle, and following four describe the corresponding cells of the second rectangle. You can print the rectangles in an arbitrary order. After you have printed the answer, print the end of the line and perform ""flush"". Your program should terminate immediately after it print the answer.
To flush you can use (just after printing an integer and end-of-line): 
You will get the Wrong Answer verdict if you ask more than 200 queries, or if you print an incorrect coordinates.
You will get the Idleness Limit Exceeded verdict if you don't print anything (but you should) or if you forget about flushing the output (more info below).
Hacking.
The first line should contain an integer n (2 ≤ n ≤ 216).
","input
The second line should contain four integers x1, y1, x2, y2 (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ n) — the description of the first rectangle.
output
The third line contains the description of the second rectangle in the similar way.
","binarysearch, constructivealgorithms, interactive",2
"import java.io.*;
import java.util.*;
public class A{
	public static BufferedReader k;
	public static BufferedWriter z;
	

	
	public static void main(String [] args)throws IOException{
		k = new BufferedReader(new InputStreamReader(System.in));
		z = new BufferedWriter(new OutputStreamWriter(System.out));
		
		
	        String[] dat = k.readLine().split("" "");

	        long l = Long.parseLong(dat[0]);
	        long r = Long.parseLong(dat[1]);
			
			if(r-l<=1){
				z.write(-1+""\n"");
			}
			else if(r-l == 2){
				
				
				if((l&1)!=0){
					z.write(-1+""\n"");
				}
				else{
					z.write(l+"" ""+(l+1)+"" ""+r+""\n"");
				}
				
			}
			else{
				if((l&1)==0){
					z.write(l+"" ""+(l+1)+"" ""+(l+2)+""\n"");
				}
				else{
					z.write((l+1)+"" ""+(l+2)+"" ""+(l+3)+""\n"");
				}
			}
			
			
			
			
		
		z.flush();

	}

}",0483_A,CODEFORCES,471,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        long n = scan.nextLong();
        long k = scan.nextLong();
        long D = 9 + 4 * (2 * k + 2 * n);
        long y = (- 3 + (long)Math.sqrt(D)) / 2;
        System.out.println(n - y);
    }
}",1195_B,CODEFORCES,1395,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import static java.lang.Math.max;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class GivenString implements Runnable
{
  public static void main(String[] args) throws Exception
  {
    new GivenString().run();
  }

  private void solve() throws Exception
  {
    String s = nextToken();
    int len = s.length();
    KMP kmp = new KMP();
    int r = 0;
    for (int i = 0; i < len; i++)
    {
      for (int j = i + 1; j <= len; j++)
      {
        String cur = s.substring(i, j);
        int count = kmp.search(s, cur);
        if (count >= 2)
          r = max(r, cur.length());
      }
    }
    out.println(r);
  }

  class KMP
  {
    public int search(String text, String pattern)
    {
      int count = 0;
      int n = text.length(), m = pattern.length(), matchPoint = -1;
      char pat[] = pattern.toCharArray(), t[] = text.toCharArray();
      int p[] = prefixTable(pattern);
      int j = 0;
      for (int i = 0; i < n; i++)
      {
        while (j > 0 && pat[j] != t[i])
          j = p[j - 1];
        if (pat[j] == t[i])
          j++;
        if (j == m)
        {
          matchPoint = i - m + 1;
          j = p[j - 1];
          count++;
        }
      }
      return count;
    }

    private int[] prefixTable(String pat)
    {
      int m = pat.length(), p[] = new int[m];
      char s[] = pat.toCharArray();
      int j = 0;
      for (int i = 1; i < m; i++)
      {
        while (j > 0 && s[j] != s[i])
          j = p[j - 1];
        if (s[j] == s[i])
          j++;
        p[i] = j;
      }
      return p;
    }

  }

  // -------------- Input/Output routines below ---------------//
  private BufferedReader in;
  PrintWriter out;
  StringTokenizer tokenizer;

  public void run()
  {
    // String problem = this.getClass().getName();
    try
    {
      in = new BufferedReader(new InputStreamReader(System.in));
      out = new PrintWriter(new BufferedOutputStream(System.out));
      solve();
      out.flush();
      in.close();
      out.close();
    }
    catch (Exception e)
    {
      e.printStackTrace();
      // System.exit(1);
    }
  }

  String nextToken() throws IOException
  {
    while (tokenizer == null || !tokenizer.hasMoreTokens())
    {
      tokenizer = new StringTokenizer(in.readLine());
    }
    return tokenizer.nextToken();
  }

  int nextInt() throws IOException
  {
    return Integer.parseInt(nextToken());
  }

  long nextLong() throws IOException
  {
    return Long.parseLong(nextToken());
  }

  double nextDouble() throws IOException
  {
    return Double.parseDouble(nextToken());
  }

}",0023_A,CODEFORCES,3810,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"


import java.io.*;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

@SuppressWarnings(""Duplicates"")

public class solveLOL {
    FastScanner in;
    PrintWriter out;
    boolean systemIO = true, multitests = false;
    int INF = Integer.MAX_VALUE / 2;


    void solve() {
        int n = in.nextInt();
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = in.nextInt();
        }
        Arrays.sort(arr);
        boolean used[] = new boolean[n];
        int k = 0;
        for (int i = 0; i < n; i++) {
            if (!used[i]) {
                used[i] = true;
                for (int j = i + 1; j < n; j++) {
                    if (!used[j] && arr[j] % arr[i] == 0) {
                        used[j] = true;
                    }
                }
                k++;
            }
        }
        System.out.println(k);



    }

    class pair implements Comparable<pair> {
        int a;
        int b;

        pair(int A, int B) {
            this.a = A;
            this.b = B;
        }

        public int compareTo(pair o) {
            return a != o.a ? Double.compare(a, o.a) : b - o.b;
        }
    }

    void shuffleArray(long[] ar) {
        Random rnd = ThreadLocalRandom.current();
        for (int i = ar.length - 1; i > 0; i--) {
            int index = rnd.nextInt(i + 1);
            long a = ar[index];
            ar[index] = ar[i];
            ar[i] = a;
        }
    }

    void printArray(long[] ar) {
        for (long k : ar) {
            System.out.print(k + "" "");
        }
        System.out.println();
    }

    void reverseArray(long[] ar) {
        for (int i = 0, j = ar.length - 1; i < j; i++, j--) {
            long a = ar[i];
            ar[i] = ar[j];
            ar[j] = a;
        }
    }

    private void run() throws IOException {
        if (systemIO) {
            in = new solveLOL.FastScanner(System.in);
            out = new PrintWriter(System.out);
        } else {
            in = new solveLOL.FastScanner(new File(""input.txt""));
            out = new PrintWriter(new File(""output.txt""));
        }
        for (int t = multitests ? in.nextInt() : 1; t-- > 0; )
            solve();

        out.close();
    }

    class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        FastScanner(File f) {
            try {
                br = new BufferedReader(new FileReader(f));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        FastScanner(InputStream f) {
            br = new BufferedReader(new InputStreamReader(f));
        }

        String nextLine() {
            try {
                return br.readLine();
            } catch (IOException e) {
                return null;
            }
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

    }

    public static void main(String[] arg) throws IOException {
        new solveLOL().run();
    }

}",1209_A,CODEFORCES,3494,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"import java.util.Scanner;

public class p912A {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		long A = scan.nextInt(), B = scan.nextInt(), x = scan.nextInt(), y = scan.nextInt(), z = scan.nextInt(),
				ans = 0;
		A -= 2 * x + y;
		B -= 3 * z + y;
		if (A < 0)
			ans -= A;
		if (B < 0)
			ans -= B;
		System.out.println(ans);
	}

}
",0912_A,CODEFORCES,577,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation,1
"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

import java.util.Set;
import java.util.Map.Entry;

import java.util.HashMap;
import java.util.Iterator;

public class test {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        String num = input.nextLine();

        System.out.println(""25"");
    }
}",0630_A,CODEFORCES,540,Again Twenty Five!,"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. ""Do I give such a hard task?"" — the HR manager thought. ""Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.""
Could you pass the interview in the machine vision company in IT City?
","input
The only line of the input contains a single integer n (2 ≤ n ≤ 2·1018) — the power in which you need to raise number 5.
output
Output the last two digits of 5n without spaces between them.
",numbertheory,1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.StringTokenizer;
import javafx.util.Pair;

public class Solve6 {

    public static void main(String[] args) throws IOException {
        PrintWriter pw = new PrintWriter(System.out);
        new Solve6().solve(pw);
        pw.flush();
        pw.close();
    }

    public void solve(PrintWriter pw) throws IOException {
        FastReader sc = new FastReader();
        int n = sc.nextInt();
        int[] a = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = sc.nextInt();
        }
        HashMap<Integer, LinkedList<Pair<Integer, Integer>>> h = new HashMap();
        for (int i = 1; i <= n; i++) {
            int s = 0;
            for (int j = i; j >= 1; j--) {
                s += a[j];
                LinkedList<Pair<Integer, Integer>> l;
                if (!h.containsKey(s)) {
                    l = new LinkedList();
                } else {
                    l = h.get(s);
                }
                l.add(new Pair(j, i));
                h.put(s, l);
            }
        }

        int max = 0, index = 0;
        for (Map.Entry<Integer, LinkedList<Pair<Integer, Integer>>> entrySet : h.entrySet()) {
            int i = 0, size = 0;
            for (Pair<Integer, Integer> pair : entrySet.getValue()) {
                if (pair.getKey() > i) {
                    i = pair.getValue();
                    size++;
                }
            }
            if (size > max) {
                max = size;
                index = entrySet.getKey();
            }
        }
        pw.println(max);
        int i = 0;
        for (Pair<Integer, Integer> pair : h.get(index)) {
            if (pair.getKey() > i) {
                pw.println(pair.getKey() + "" "" + pair.getValue());
                i = pair.getValue();
            }
        }
    }

    static class FastReader {

        StringTokenizer st;
        BufferedReader br;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        public boolean hasNext() throws IOException {
            String s = br.readLine();
            if (s == null || s.isEmpty()) {
                return false;
            }
            st = new StringTokenizer(s);
            return true;
        }

        public String next() throws IOException {
            if (st == null || !st.hasMoreTokens()) {
                String s = br.readLine();
                if (s.isEmpty()) {
                    return null;
                }
                st = new StringTokenizer(s);
            }
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }
    }
}
",1141_F2,CODEFORCES,3339,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"import java.util.*;
public class MargariteAndTheBestPresent {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int q = sc.nextInt();
		int l = 0;
		int r = 0;
		List<Integer> z = new ArrayList<>();
		for(int j=0;j<q;j++) {
			l = sc.nextInt();
			r = sc.nextInt();
			System.out.println(func(r) - func(l-1));
		}	
	}
	static long func(long x) {
		if(x%2==0) {
			return x/2;
		}
		else {
			return -x+func(x-1);
		}
	}
}",1080_B,CODEFORCES,733,Margarite and the best present,"Little girl Margarita is a big fan of competitive programming. She especially loves problems about arrays and queries on them.
Recently, she was presented with an array $$$a$$$ of the size of $$$10^9$$$ elements that is filled as follows: 
That is, the value of the $$$i$$$-th element of the array $$$a$$$ is calculated using the formula $$$a_i = i \cdot (-1)^i$$$.
She immediately came up with $$$q$$$ queries on this array. Each query is described with two numbers: $$$l$$$ and $$$r$$$. The answer to a query is the sum of all the elements of the array at positions from $$$l$$$ to $$$r$$$ inclusive.
Margarita really wants to know the answer to each of the requests. She doesn't want to count all this manually, but unfortunately, she couldn't write the program that solves the problem either. She has turned to you — the best programmer.
Help her find the answers!
The first line contains a single integer $$$q$$$ ($$$1 \le q \le 10^3$$$) — the number of the queries.
Each of the next $$$q$$$ lines contains two integers $$$l$$$ and $$$r$$$ ($$$1 \le l \le r \le 10^9$$$) — the descriptions of the queries.
Print $$$q$$$ lines, each containing one number — the answer to the query. 
In the first query, you need to find the sum of the elements of the array from position $$$1$$$ to position $$$3$$$. The sum is equal to $$$a_1 + a_2 + a_3 = -1 + 2 -3 = -2$$$.
In the second query, you need to find the sum of the elements of the array from position $$$2$$$ to position $$$5$$$. The sum is equal to $$$a_2 + a_3 + a_4 + a_5 = 2 -3 + 4 - 5 = -2$$$.
In the third query, you need to find the sum of the elements of the array from position $$$5$$$ to position $$$5$$$. The sum is equal to $$$a_5 = -5$$$.
","input
In the fourth query, you need to find the sum of the elements of the array from position $$$4$$$ to position $$$4$$$. The sum is equal to $$$a_4 = 4$$$.
output
In the fifth query, you need to find the sum of the elements of the array from position $$$2$$$ to position $$$3$$$. The sum is equal to $$$a_2 + a_3 = 2 - 3 = -1$$$.
",math,1
"
import java.awt.Point;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.ObjectInputStream.GetField;
import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

import javax.sound.sampled.ReverbType;


public class N718 {
	static PrintWriter out;
	static Scanner sc;
	static ArrayList<int[]>q,w,x;
	static ArrayList<Integer>adj[];
	static HashSet<Integer>primesH;
	static boolean prime[];
	//static ArrayList<Integer>a;
	static HashSet<Long>tmp;
	static int[][][]dist;
	static boolean[]v;
	static int[]a,b,c,d;
	static Boolean[][]dp;
	static char[][]mp;
	static int A,B,n,m,h,ans,sum;
	//static String a,b;
	static long oo=(long)1e9+7;
	public static void main(String[]args) throws IOException {
		sc=new Scanner(System.in);
		out=new PrintWriter(System.out);
		//A();
		//B();
		//C();
		D();
		//E();
		//F();
		//G();
		out.close();
	}
	  private static void A() throws IOException {
		  int t=ni();
		  while(t-->0) {
				long l=nl();
				if(l%2050!=0)ol(-1);
				else {
					long num=l/2050;
					int cnt=0;
					while(num>0) {
						cnt+=num%10;
						num/=10;
					}
					ol(cnt);
					
				}
		  }
		
	   }
		static void B() throws IOException {
			int t=ni();
			while(t-->0) {
				int n=ni(),m=ni();
				int[][]a=nmi(n,m);
				PriorityQueue<int[]>pq=new PriorityQueue<int[]>((u,v)->u[0]-v[0]);
				ArrayList<Integer>[]nums=new ArrayList[n];
				for(int i=0;i<n;i++) {
					//nums[i]=new ArrayList<Integer>();
					for(int j=0;j<m;j++) {
						///nums[i].add(a[i][j]);
						pq.add(new int[] {a[i][j],i});
					}
				}
				int[][]ans=new int[n][m];
				for(int i=0;i<m;i++) {
					int[]x=pq.poll();
					ans[x[1]][i]=x[0];
				}
				int []indices=new int[n];
				while(!pq.isEmpty()) {
					int[]x=pq.poll();
					int i=x[1];
					while(ans[i][indices[i]]!=0) {
						indices[i]++;
					}
					ans[i][indices[i]]=x[0];
				}
				for(int i=0;i<n;i++) {
					for(int j=0;j<m;j++) {
						out.print(ans[i][j]+"" "");
					}
					ol("""");
				}
			}
		}
		
		static void C() throws IOException{
			 int t=1;
			 while(t-->0) {
				 int n=ni();
				 a=nai(n);
				 int[][]ans=new int[n][n];
				 for(int i=0;i<n;i++)ans[i][i]=a[i];
				 for(int i=n-1;i>=0;i--) {
					 int j=i,k=i;
					 int cur=ans[i][i];
					 cur--;
					 while(cur>0) {
						 j++;
						 if(j>=n||ans[j][k]!=0) {
							 j--;
							 k--;
						 }
						 ans[j][k]=ans[i][i];
						 cur--;
					 }
				 }
				 for(int i=0;i<n;i++) {
					 for(int j=0;j<=i;j++) {
						 out.print(ans[i][j]+"" "");
					 }
					 ol("""");
				 }
			 }
		}
		private static Boolean dp(int i, int j) {
			if(j>sum/2)return false;
			if(i==x.size()) {
				return sum/2==j;
			}
			if(dp[i][j]!=null)return dp[i][j];
			
			return dp[i][j]=dp(i+1,j+x.get(i)[0])||dp(i+1,j);
		}
		static boolean isPrime(long n) {
			if(n==2)return true;
			if(n<2||n%2==0)return false;
			
			for(long i=3L;i*i<n;i+=2l) {
				long rem=(n%i);
				if(rem==0)return false;
			}
			return true;
		}
		static void D() throws IOException {
			int t=1;
			while(t-->0) {
				int n=ni(),m=ni(),k=ni();
				int[][]ans=new int[n][m];
				dist=new int[n][m][4];
				for(int i=0;i<n;i++)for(int j=0;j>m;j++)
					Arrays.fill(dist[i][j], Integer.MAX_VALUE);
				int x;
				for(int i=0;i<n;i++) {
					for(int j=0;j<m-1;j++) {
						dist[i][j][2]=(x=ni());
						dist[i][j+1][3]=x;
					}
				}
				for(int i=0;i<n-1;i++) {
					for(int j=0;j<m;j++) {
						dist[i][j][1]=(x=ni());
						dist[i+1][j][0]=x;
					}
				}
				int[][]nans=new int[n][m];
				if(k%2==1) {
					for(int i=0;i<n;i++)Arrays.fill(ans[i], -1);
				}else {
					for(int ii=0;ii<k/2;ii++) {
					for(int i=0;i<n;i++) {
						
						for(int j=0;j<m;j++) {
							nans[i][j]=Integer.MAX_VALUE;
							if(i>0)
								nans[i][j]=Math.min(nans[i][j], ans[i-1][j]+2*dist[i-1][j][1]);
							if(i<n-1)
								nans[i][j]=Math.min(nans[i][j], ans[i+1][j]+2*dist[i+1][j][0]);
							if(j>0)
								nans[i][j]=Math.min(nans[i][j], ans[i][j-1]+2*dist[i][j-1][2]);
							if(j<m-1)
								nans[i][j]=Math.min(nans[i][j], ans[i][j+1]+2*dist[i][j+1][3]);
						}
					}
					int[][]tmp=ans;
					ans=nans;
					nans=tmp;
					}
				}
				for(int i=0;i<n;i++) {
					for(int j=0;j<m;j++) {
						out.print(ans[i][j]+"" "");
					}
					ol("""");
				}
			}
		}
		private static int bfs(int i, int j,int k) {
			boolean [][]vis=new boolean[dist.length][dist[0].length];
			Queue<int[]>q=new LinkedList<int[]>();
			int mn=Integer.MAX_VALUE;
			q.add(new int[] {i,j,0,0});
			int[]dx=new int[] {-1,1,0,0};
			int[]dy=new int[] {0,0,1,-1};
			while(!q.isEmpty()) {
				int []x=q.poll();
				vis[x[0]][x[1]]=true;
				int c=x[2];
				if(c>k/2)continue;
				if(c>0&&k%c==0&&(k/c)%2==0) {
					mn=Math.min(mn,x[3]*k/c );
				}
				for(int a=0;a<4;a++) {
					int nx=x[0]+dx[a];
					int ny=x[1]+dy[a];
					if(valid(nx,ny)&&!vis[nx][ny]) {
						q.add(new int[] {nx,ny,c+1,x[3]+dist[x[0]][x[1]][a]});
					}
				}
				
			}
			return mn;
		}
		private static boolean valid(int nx, int ny) {
			return nx>=0&&nx<dist.length&&ny>=0&&ny<dist[0].length;
		}
		static int gcd (int a, int b) {
		    return b==0?a:gcd (b, a % b);
		}
		
	static void E() throws IOException {
		int t=ni();
		while(t-->0) {
			
			
		}
		
	}

	static void F() throws IOException {
		int t=ni();
		while(t-->0) {
			
		}
	}
	static void CC() throws IOException {
		for(int kk=2;kk<21;kk++) {
			ol(kk+""   -------"");
		int n=kk;
		int k=n-2;
		int msk=1<<k;
		int[]a=new int[k];
		for(int i=0;i<a.length;i++)a[i]=i+2;
		int mx=1;
		int ms=0;
		for(int i=1;i<msk;i++) {
			long prod=1;
			int cnt=0;
			for(int j=0;j<a.length;j++) {
				if(((i>>j)&1)!=0) {
					prod*=a[j];
					cnt++;
				}
			}
			if(cnt>=mx&&prod%n==1) {
				mx=cnt;
				ms=i;
			}
			
		}
		ol(mx==1?mx:mx+1);
		out.print(1+"" "");
		long pr=1;
		for(int j=0;j<a.length;j++) {
			if(((ms>>j)&1)!=0) {
				out.print(a[j]+"" "");
				pr*=a[j];
			}
		}
		ol("""");
		ol(""Prod: ""+pr);
		ol(n+""*""+((pr-1)/n)+"" + ""+1);
		}
	}
	static int ni() throws IOException {
		return sc.nextInt();
	}
	static double nd() throws IOException {
		return sc.nextDouble();
	}
	static long nl() throws IOException {
		return  sc.nextLong();
	}
	static String ns() throws IOException {
		return sc.next();
	}
	static int[] nai(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = sc.nextInt();
		return a;
	}
	static long[] nal(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = sc.nextLong();
		return a;
	}
	static int[][] nmi(int n,int m) throws IOException{
		int[][]a=new int[n][m];
		for(int i=0;i<n;i++) {
			for(int j=0;j<m;j++) {
				a[i][j]=sc.nextInt();
			}
		}
		return a;
	}

	static long[][] nml(int n,int m) throws IOException{
		long[][]a=new long[n][m];
		for(int i=0;i<n;i++) {
			for(int j=0;j<m;j++) {
				a[i][j]=sc.nextLong();
			}
		}
		return a;
	}
	static void o(String x) {
		out.print(x);
	}
	static void ol(String x) {
		out.println(x);
	}
	static void ol(int x) {
		out.println(x);
	}
	static void disp1(int []a) {
		for(int i=0;i<a.length;i++) {
			out.print(a[i]+"" "");
		}
		out.println();
	}

	static class Scanner 
	{
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

		public String next() throws IOException 
		{
			while (st == null || !st.hasMoreTokens()) 
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}
		public boolean hasNext() {return st.hasMoreTokens();}
		public int nextInt() throws IOException {return Integer.parseInt(next());}
		
		public double nextDouble() throws IOException {return Double.parseDouble(next());}
		
		public long nextLong() throws IOException {return Long.parseLong(next());}

		public String nextLine() throws IOException {return br.readLine();}
			
		public boolean ready() throws IOException {return br.ready(); }
		

	}
}
",1517_D,CODEFORCES,4213,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.util.*;

public class A
{
	public static void main(String args[])
	{
		boolean[] b = new boolean[11000];
		Arrays.fill(b, true);
		b[0] = b[1] = false;

		for(int i=2;i < b.length;i++)
		{
			if(!b[i])
				continue;

			for(int j=2;i*j<b.length;j++)
				b[i*j] = false;
		}

		int[] p = new int[11000];
		int pn = 0;

		for(int i=0;i < b.length;i++)
		{
			if(b[i])
				p[pn++] = i;
		}

		Scanner scan = new Scanner(System.in);

		int n = scan.nextInt();
		int k = scan.nextInt();

		int rtn = 0;

		
		for(int j=0;p[j] <= n;j++)
		{
			//Try to make sum
			for(int h=0;h <= j;h++)
			{
				if(p[h] + p[h+1] + 1 == p[j])
				{
					rtn++;
					break;
				}
			}
		}

		System.out.println(rtn >= k ? ""YES"" : ""NO"");
		

	}
}",0017_A,CODEFORCES,1503,Noldbach problem,"Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least k prime numbers from 2 to n inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.
Two prime numbers are called neighboring if there are no other prime numbers between them.
You are to help Nick, and find out if he is right or wrong.
The first line of the input contains two integers n (2 ≤ n ≤ 1000) and k (0 ≤ k ≤ 1000).
","input
Output YES if at least k prime numbers from 2 to n inclusively can be expressed as it was described above. Otherwise output NO.
output
In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.
","bruteforce, math, numbertheory",3
"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.StringTokenizer;

public class P {

	public static void main(String[] args) throws NumberFormatException, IOException {
		Scanner sc = new Scanner();
		PrintWriter out = new PrintWriter(System.out);
		int N = sc.nextInt(), x = sc.nextInt(), y = sc.nextInt();
		long C = sc.nextLong();

		int lo = 0, hi = (int) (1e6);
		int answer = -1;
		while (lo <= hi) {
			int L = lo + (hi - lo) / 2;
			long area = 0;
			for (int steps = 0; steps <= L; ++steps) { // L + 1 steps to right
				if (y + steps > N)
					break;
				long up = Math.min(x, 1 + L - steps), down = Math.min(N - x, L - steps);
				area += up + down;
			}

			for (int steps = 1; steps <= L; ++steps) { // L steps to left
				if (y - steps < 1)
					break;
				long up = Math.min(x, 1 + L - steps), down = Math.min(N - x, L - steps);
				area += up + down;
			}
			if (area >= C) {
				answer = L;
				hi = L - 1;
			} else
				lo = L + 1;
		}
		out.println(answer);

		out.flush();
		out.close();
	}

	static class Scanner {
		BufferedReader br;
		StringTokenizer st;

		Scanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		Scanner(String file) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(file));
		}

		String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		int nextInt() throws NumberFormatException, IOException {
			return Integer.parseInt(next());
		}

		String nextLine() throws IOException {
			return br.readLine();
		}

		long nextLong() throws NumberFormatException, IOException {
			return Long.parseLong(next());
		}

	}
}",0256_B,CODEFORCES,761,Mr,"Mr. Bender has a digital table of size n × n, each cell can be switched on or off. He wants the field to have at least c switched on squares. When this condition is fulfilled, Mr Bender will be happy.
We'll consider the table rows numbered from top to bottom from 1 to n, and the columns — numbered from left to right from 1 to n. Initially there is exactly one switched on cell with coordinates (x, y) (x is the row number, y is the column number), and all other cells are switched off. Then each second we switch on the cells that are off but have the side-adjacent cells that are on.
For a cell with coordinates (x, y) the side-adjacent cells are cells with coordinates (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1).
In how many seconds will Mr. Bender get happy?
The first line contains four space-separated integers n, x, y, c (1 ≤ n, c ≤ 109; 1 ≤ x, y ≤ n; c ≤ n2).
","input
In a single line print a single integer — the answer to the problem.
output
Initially the first test has one painted cell, so the answer is 0. In the second test all events will go as is shown on the figure. .
","binarysearch, bruteforce, math",2
"import java.util.Scanner;


public class P23A {

	public static void main(String[] args) {

		Scanner in = new Scanner(System.in);
		String s = in.nextLine();
		int max = 0;
		for(int i = 0; i < s.length(); i++)
			for(int k = s.length(); k > max + i; k--)
				if(s.substring(i + 1).contains(s.substring(i,k)))
					max = k - i; 
		System.out.println(max);
	}

}
",0023_A,CODEFORCES,3743,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class C {

	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);

		int n = sc.nextInt();
		int r = sc.nextInt();
		
		double ans[] = new double[n];
		
		int[] x = new int[n];
		
		for (int i = 0; i < n; i++) {
			x[i] = sc.nextInt();
		}
		
		for (int i = 0; i < n; i++) {
			ans[i] = r;
			for (int j = 0; j < i; j++) {
				int d = Math.abs(x[i] - x[j]);
				if(d <= 2 * r) {
					ans[i] = Math.max(ans[i], ans[j] + Math.sqrt(4 * r * r - d * d));
				}
			}
			
			out.print(ans[i] + "" "");
		}
		out.println();
		
		out.flush();
		out.close();
	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public Scanner(String file) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(file));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public double nextDouble() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder(""0"");
			double res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder(""0"");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

	}
}",0908_C,CODEFORCES,2991,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class D {

	public static void solve(FastScanner fs) {	
		int n=fs.nextInt();
		int[] a=fs.readArray(n);
		boolean even=((countInversions(a)&1)==0);
		int q=fs.nextInt();
		for (int i=0; i<q; i++) {
			int start=fs.nextInt();
			int end=fs.nextInt();
			int diff=end-start;
			boolean evenChange=(diff+1)/2%2==0;
			even^=!evenChange;
			System.out.println(even?""even"":""odd"");
		}
	}
	
	private static int countInversions(int[] a) {
		int c=0;
		for (int i=0; i<a.length; i++) {
			for (int j=i+1; j<a.length; j++)
				if (a[j]<a[i])
					c++;
		}
		return c;
	}

	
	
	
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		FastScanner scanner = new FastScanner(System.in);
		solve(scanner);
	}
	

	private static class FastScanner {
		BufferedReader br;
		StringTokenizer st;
		public FastScanner(InputStream in) {
			br = new BufferedReader(new InputStreamReader(in));
		}
		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}
		int nextInt() {
			return Integer.parseInt(next());
		}
		long nextLong() {
			return Long.parseLong(next());
		}
		double nextDouble() {
			return Double.parseDouble(next());
		}
		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}
		int[] readArray(int n) {
			int[] a=new int[n];
			for (int i=0; i<n; i++)
				a[i]=nextInt();
			return a;
		}
	}
}


",0911_D,CODEFORCES,3192,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.util.*;
import java.io.*;
 
public class Main {
	public static void main(String args[]) {new Main().run();}
 
	FastReader in = new FastReader();
	PrintWriter out = new PrintWriter(System.out);
	void run(){
		out.println(work());
		out.flush();
	}
	long mod=1000000007;
	long gcd(long a,long b) {
		return b==0?a:gcd(b,a%b);
	}
	long work() {
		int n=in.nextInt();
		int m=in.nextInt();
		String str=in.next();
		long[] dp=new long[1<<m];
		long[][] cnt=new long[m][m];
		long[] rec=new long[1<<m];	
   	        for(int i=1;i<n;i++) {
			int n1=str.charAt(i-1)-'a';
			int n2=str.charAt(i)-'a';
			cnt[n1][n2]++;
			cnt[n2][n1]++;
		}
		for(int i=1;i<1<<m;i++) {
			dp[i]=9999999999L;
			long v=0;
			int b=0;//最低位的1
			for(int j=0;j<m;j++) {
				if((i&(1<<j))>0) {
					b=j;
					break;
				}
			}
			for(int j=0;j<m;j++) {
				if((i&(1<<j))==0) {
					v+=cnt[b][j];
				}else {
					if(b!=j)v-=cnt[b][j];
				}
			}
			v+=rec[i-(1<<b)];
			for(int j=0;j<m;j++) {
				if((i&(1<<j))>0) {
					dp[i]=Math.min(dp[i], dp[i-(1<<j)]+v);
				}
			}
			rec[i]=v;
		}
		
		return dp[(1<<m)-1];
	}
}
 
 
 
class FastReader
{
	BufferedReader br;
	StringTokenizer st;
 
	public FastReader()
	{
		br=new BufferedReader(new InputStreamReader(System.in));
	}
 
	public String next() 
	{
		if(st==null || !st.hasMoreElements())
		{
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return st.nextToken();
	}
 
	public int nextInt() 
	{
		return Integer.parseInt(next());
	}
 
	public long nextLong()
	{
		return Long.parseLong(next());
	}
}


		 		  	  			 				 	 	    		",1238_E,CODEFORCES,4834,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp",7
"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Ideone
{
    public static void main (String[] args) throws java.lang.Exception
    {
     int n,a,b;
     Scanner obj=new Scanner(System.in);
    
     n=obj.nextInt();
    
     if(n%4==0){a=n/2;b=n/2;System.out.println(a+"" ""+b);}
     else if(n%2==0 && n%4!=0)
     {a=n/2-1;b=n/2+1;System.out.println(a+"" ""+b);}
     
     else if(n%2!=0)
     {  a=4;b=0;
       while(b!=1)
       { b=n-a;
         if(b%3==0){ System.out.println(a+"" ""+b);break; }
         else{a=a+2;}
       }
     }
    }
}",0472_A,CODEFORCES,461,Design Tutorial: Learn from Math,"One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.
For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.
You are given an integer n no less than 12, express it as a sum of two composite numbers.
The only line contains an integer n (12 ≤ n ≤ 106).
Output two composite integers x and y (1 < x, y < n) such that x + y = n. If there are multiple solutions, you can output any of them.
","input
In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.
output
In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.
","math, numbertheory",1
"import java.util.Scanner;
public class main
{
public static void main(String[]args)
{
Scanner sc=new Scanner(System.in);
int n=sc.nextInt();
int k=sc.nextInt();
int res=0;
res=k/n;
int r=k%n;
if(r!=0)
System.out.println(res+1);
else if(r==0)
System.out.println(res);
}
}",1061_A,CODEFORCES,693,Coins,"You have unlimited number of coins with values $$$1, 2, \ldots, n$$$. You want to select some set of coins having the total value of $$$S$$$. 
It is allowed to have multiple coins with the same value in the set. What is the minimum number of coins required to get sum $$$S$$$?
The only line of the input contains two integers $$$n$$$ and $$$S$$$ ($$$1 \le n \le 100\,000$$$, $$$1 \le S \le 10^9$$$)
Print exactly one integer — the minimum number of coins required to obtain sum $$$S$$$.
In the first example, some of the possible ways to get sum $$$11$$$ with $$$3$$$ coins are: 
It is impossible to get sum $$$11$$$ with less than $$$3$$$ coins.
","input
In the second example, some of the possible ways to get sum $$$16$$$ with $$$3$$$ coins are: 
output
It is impossible to get sum $$$16$$$ with less than $$$3$$$ coins.
","greedy, implementation, math",1
"import java.util.Scanner;

public class R489C {
	static long MOD=(long)1e9+7;
	public static void main(String[] args) {
		Scanner scan=new Scanner(System.in);
		long n=scan.nextLong(), k=scan.nextLong();
		if(n==0) {
			System.out.println(0);
			return;
		}
		long x=2*n-1;
		long e=exp(2,k);
		System.out.println((x%MOD*e%MOD+1)%MOD);
	}
	public static long exp(long x, long e) {
		long res=1;     

		while (e>0)	{
			if(e%2==1) res=(res*x)%MOD;
			
			e/=2;
			x=(x*x)%MOD;
		}
		return res;
	}
}",0992_C,CODEFORCES,1232,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import java.util.*;

public class ProblemA {
	
	public static void main(String[] args)
	{
		Scanner s = new Scanner(System.in);
		
		int n = s.nextInt();
		int t = s.nextInt();
		TreeMap<Integer,Integer> map = new TreeMap<Integer,Integer>();
		
//		int x = 0 ;
		while(s.hasNextInt())
		{
			int i = s.nextInt();
			int j = s.nextInt();
			map.put(i,j);
//			x++;
//			if(x == 2)
//				break;
		}
		
		int count = 0;
		double left = -100000;
		double right;
		int size;
		for(Integer i : map.keySet())
		{
			size = map.get(i);
			right = (double)i - (double)size/2.0;
			
			if(right - left > t)
			{
				count+=2;
			}
			if(right - left == t)
			{
				count++;
			}
			
			left = (double)i + (double)size/2.0;
		}
		
		System.out.println(count);
	}

}
 ",0015_A,CODEFORCES,2252,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"import java.math.*;
import java.util.*;
import java.io.*;

public class Main {
    void solve() {
        long x=nl(),k=nl();
        if(x==0) {
            pw.println(0);
            return;
        }
        long d=modpow(2,k,M);
        long ans=mul(2,d,M);
        ans=mul(ans,x,M)%M;
        ans++;
        ans%=M;
        ans=(ans-d+M)%M;

        pw.println(ans);


    }
//    long mul(long a, long b,long M)
//    {
//        return (a*1L*b)%M;
//    }
    long mul(long x, long y, long m) {
        long ans = 0;
        while (y>0) {
            if ((y & 1)>0) {
                ans += x;
                if (ans >= m) ans -= m;
            }
            x = x + x;
            if (x >= m) x -= m;
            y >>= 1;
        }
        return ans;
    }

    long modpow(long a, long b,long M)
    {
        long r=1;
        while(b>0)
        {
            if((b&1)>0) r=mul(r,a,M);
            a=mul(a,a,M);
            b>>=1;
        }
        return r;
    }

    long M=(long)1e9+7;
    InputStream is;
    PrintWriter pw;
    String INPUT = """";
    void run() throws Exception {
        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
        pw = new PrintWriter(System.out);
        long s = System.currentTimeMillis();
        solve();
        pw.flush();
        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");
    }

    public static void main(String[] args) throws Exception { new Main().run(); }

    private byte[] inbuf = new byte[1024];
    public int lenbuf = 0, ptrbuf = 0;

    private int readByte() {
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }

    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }

    private double nd() { return Double.parseDouble(ns()); }
    private char nc() { return (char)skip(); }

    private String ns() {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    private char[] ns(int n) {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }

    private char[][] nm(int n, int m) {
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }

    private int[] na(int n) {
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }

    private int ni() {
        int num = 0, b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }

        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }

    private long nl() {
        long num = 0;
        int b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }

        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }

    private void tr(Object... o) { if(INPUT.length() > 0)System.out.println(Arrays.deepToString(o)); }
}",0992_C,CODEFORCES,1202,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.LinkedList;
import java.util.StringTokenizer;

public class GeorgeAndInterestingGraph {
    public static void main(String[] args) {
        MyScanner sc = new MyScanner();
        
        int N = sc.nextInt();
        int M = sc.nextInt();
        
        int[] edgeFrom = new int[M];
        int[] edgeTo = new int[M];
        for (int i = 0; i < M; i++) {
        	edgeFrom[i] = sc.nextInt();
        	edgeTo[i] = sc.nextInt();
        }
        
        int best = Integer.MAX_VALUE;
        for (int i = 0; i < N; i++) {
        	boolean[][] mat = makeAdjMat(N, edgeFrom, edgeTo);
        	best = Math.min(best, count(mat, i, M));
        }
        
        System.out.println(best);
    }
    
    public static int count(boolean[][] mat, int center, int M) {
//    	int N = mat.length;
//    	int M = mat[0].length;
//
//    	int centerConnect = (mat[center][center]) ? 0 : 1;
//    	for (int i = 0; i < N; i++) {
//			if (i != center) {
//				if (!mat[i][center]) {
//					centerConnect++;
//				}
//				if (!mat[center][i]) {
//					centerConnect++;
//				}
//			}
//	    	mat[i][center] = false;
//	    	mat[center][i] = false;
//		}
//    	
//    	int[][] adjMat = new int[2 * N + 2][2 * N + 2];
//    	for (int i = 0; i < N; i++) {
//    		for (int j = 0; j < N; j++) {
//    			int idx = N + j;
//    			adjMat[i][idx] = (mat[i][j]) ? 1 : 0;
//    		}
//    	}
//    	int s = 2 * N;
//    	int t = 2 * N + 1;
//    	for (int i = 0; i < N; i++) {
//    		adjMat[s][i] = 1;
//    	}
//    	for (int i = N; i < 2 * N; i++) {
//    		adjMat[i][t] = 1;
//    	}
//    	
//    	int matches = fordFulkerson(adjMat, s, t);
//    	
//    	return centerConnect + matches;
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	int N = mat.length;
//    	int M = mat[0].length;
    	
    	int cntWithI = (mat[center][center]) ? 1 : 0;
    	for (int i = 0; i < N; i++) {
    		if (i != center) {
    			if (mat[i][center]) {
    				cntWithI++;
    			}
    			if (mat[center][i]) {
    				cntWithI++;
    			}
    		}
        	mat[i][center] = false;
        	mat[center][i] = false;
    	}
    	
    	int other = M - cntWithI;
    	
//    	int centerConnect = (mat[center][center]) ? 0 : 1;
//    	
//    	for (int i = 0; i < N; i++) {
//    		if (i != center) {
//    			if (!mat[i][center]) {
//    				centerConnect++;
//    			}
//    			if (!mat[center][i]) {
//    				centerConnect++;
//    			}
//    		}
//        	mat[i][center] = false;
//        	mat[center][i] = false;
//    	}
    	
    	int matches = bipartiteMatching(mat);
    	
    	return (2 * N - 1 - cntWithI + other - matches + N - 1 - matches);
//    	return (centerConnect + N - 1 - matches);
    }
    
    public static boolean[][] makeAdjMat(int N, int[] edgeFrom, int[] edgeTo) {
    	boolean[][] mat = new boolean[N][N];
    	for (int i = 0; i < edgeFrom.length; i++) {
    		int from = edgeFrom[i] - 1;
    		int to = edgeTo[i] - 1;
    		mat[from][to] = true;
    	}
    	return mat;
    }
    
    /**
     * Returns true if there is a path from the source 's' to the sink 't' in the residual graph.
     * Also fills parent[] to store the path.
     * See here for more info:  XXXX
     */
    public static boolean fordFulkersonHelper(int[][] resid, int s, int t, int[] parent) {
    	int V = resid.length;
    	boolean[] visited = new boolean[V];
    	LinkedList<Integer> q = new LinkedList<Integer>();
    	q.push(s);
    	visited[s] = true;
    	parent[s] = -1;
    	
    	while (!q.isEmpty()) {
    		int u = q.pop();
    		for (int v = 0; v < V; v++) {
    			if (!visited[v] && resid[u][v] > 0) {
    				q.push(v);
    				parent[v] = u;
    				visited[v] = true;
    			}
    		}
    	}
    	
    	return visited[t];
    }
    
    /**
     * Returns the maximum flow from 's' to 't' in the given graph.
     * See here for more info:  XXXX
     */
    public static int fordFulkerson(int[][] graph, int s, int t) {
    	int V = graph.length;
    	int[][] resid = new int[V][V];
    	int[] parent = new int[V];
    	int maxFlow = 0;
    	
    	for (int u = 0; u < V; u++) {
    		for (int v = 0; v < V; v++) {
    			resid[u][v] = graph[u][v];
    		}
    	}
    	
    	while (fordFulkersonHelper(resid, s, t, parent)) {
    		int pathFlow = Integer.MAX_VALUE;
    		for (int v = t; v != s; v = parent[v]) {
    			int u = parent[v];
    			pathFlow = Math.min(pathFlow,  resid[u][v]);
    		}
    		for (int v = t; v != s; v = parent[v]) {
    			int u = parent[v];
    			resid[u][v] -= pathFlow;
    			resid[v][u] += pathFlow;
    		}
    		maxFlow += pathFlow;
    	}
    	
    	return maxFlow;
    }
    
    /**
     * Returns true if a matching for vertex 'u' is possible.
     * See here for more info:  XXXX
     */
    public static boolean bipartiteMatchingHelper(boolean[][] bpGraph, int u, boolean[] seen, int[] matchR) {
    	int N = bpGraph[0].length;
    	for (int v = 0; v < N; v++) {
    		if (bpGraph[u][v] && !seen[v]) {
    			seen[v] = true;
    			if (matchR[v] < 0 || bipartiteMatchingHelper(bpGraph, matchR[v], seen, matchR)) {
    				matchR[v] = u;
    				return true;
    			}
    		}
    	}
    	return false;
    }
    
    /**
     * Returns the maximum bipartite matching from an an adjacency matrix.
     * Note:  bpGraph[i][j] = true if there is an edge from i to j.
     * Note:  matchIJ (array of length M) is an output variable containing the matchings, such that matchIJ[i] = j means that there is a match from i to j.
     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.
     * See here for more info:  XXXX
     */
    public static int bipartiteMatching(boolean[][] bpGraph, int[] matchIJ, int[] matchJI) {
    	int ans = bipartiteMatching(bpGraph, matchJI);
    	
    	for (int i = 0; i < matchJI.length; i++) {
    		matchIJ[i] = -1;
    	}
    	
    	for (int j = 0; j < matchJI.length; j++) {
    		int i = matchJI[j];
    		if (i >= 0) {
    			matchIJ[i] = j;
    		}
    	}
    	
    	return ans;
    }
    
    /**
     * Returns the maximum bipartite matching from an an adjacency matrix.
     * Note:  bpGraph[i][j] = true if there is an edge from i to j.
     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.
     * See here for more info:  XXXX
     */
    public static int bipartiteMatching(boolean[][] bpGraph, int[] matchJI) {
    	int M = bpGraph.length;
    	int N = bpGraph[0].length;
    	
    	for (int i = 0; i < N; i++) {
    		matchJI[i] = -1;
    	}
    	
    	int ans = 0;
    	for (int u = 0; u < M; u++) {
    		boolean[] seen = new boolean[N];
    		if (bipartiteMatchingHelper(bpGraph, u, seen, matchJI)) {
    			ans++;
    		}
    	}
    	
    	return ans;
    }
    
    /**
     * Returns the maximum bipartite matching from an an adjacency matrix.
     * Overload of the bipartiteMatching function without output parameters.
     * See here for more info:  XXXX
     */
    public static int bipartiteMatching(boolean[][] bpGraph) {
    	int N = bpGraph[0].length;
    	int[] matchJI = new int[N];
    	return bipartiteMatching(bpGraph, matchJI);
    }
    
    /**
     * Overload of the bipartiteMatching function taking an adjacency matrix of int[][] instead of boolean[][].
     */
    public static int bipartiteMatching(int[][] intGraph) {
    	boolean[][] bpGraph = intToBooleanAdjMat(intGraph);
    	return bipartiteMatching(bpGraph);
    }

    /**
     * Overload of the bipartiteMatching function taking an adjacency matrix of int[][] instead of boolean[][].
     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.
     */
    public static int bipartiteMatching(int[][] intGraph, int[] matchJI) {
    	boolean[][] bpGraph = intToBooleanAdjMat(intGraph);
    	return bipartiteMatching(bpGraph, matchJI);
    }

    /**
     * Overload of the bipartiteMatching function taking an adjacency matrix of int[][] instead of boolean[][].
     * Note:  matchIJ (array of length M) is an output variable containing the matchings, such that matchIJ[i] = j means that there is a match from i to j.
     * Note:  matchJI (array of length N) is an output variable containing the matchings, such that matchJI[j] = i means that there is a match from i to j.
     */
    public static int bipartiteMatching(int[][] intGraph, int[] matchIJ, int[] matchJI) {
    	boolean[][] bpGraph = intToBooleanAdjMat(intGraph);
    	return bipartiteMatching(bpGraph, matchIJ, matchJI);
    }
    
    /**
     * Converts an integer adjacency matrix of 1's and 0's to a boolean adjacency matrix.
     * Useful with bipartiteMatching, which takes adjancency matrix of boolean[][] as input (instead of int[][]).
     */
    public static boolean[][] intToBooleanAdjMat(int[][] mat) {
    	int M = mat.length;
    	int N = mat[0].length;
    	boolean[][] bMat = new boolean[M][N];
    	for (int i = 0; i < M; i++) {
    		for (int j = 0; j < N; j++) {
    			bMat[i][j] = (mat[i][j] != 0);
    		}
    	}
    	return bMat;
    }

    public static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        String nextLine() {
            String str = """";
            try { str = br.readLine(); }
            catch (IOException e) { e.printStackTrace(); }
            return str;
        }
    }
}",0387_D,CODEFORCES,3992,George and Interesting Graph,"George loves graphs. Most of all, he loves interesting graphs. We will assume that a directed graph is interesting, if it meets the following criteria: 
However, not everything's that simple. George got a directed graph of n vertices and m arcs as a present. The graph didn't have any multiple arcs. As George loves interesting graphs, he wants to slightly alter the presented graph and transform it into an interesting one. In one alteration he can either remove an arbitrary existing arc from the graph or add an arbitrary arc to the graph. 
George wonders: what is the minimum number of changes that he needs to obtain an interesting graph from the graph he's got as a present? Help George and find the answer to the question.
The first line contains two space-separated integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ 1000) — the number of vertices and arcs in the presented graph.
Each of the next m lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n) — the descriptions of the graph's arcs. Pair (ai, bi) means that the graph contains an arc from vertex number ai to vertex number bi. It is guaranteed that the presented graph doesn't contain multiple arcs.
Assume that the grah vertices are numbered 1 through n.
Print a single integer — the answer to George's question.
","input
For more information about directed graphs, please visit: http://en.wikipedia.org/wiki/Directed_graph
output
In the first sample the graph already is interesting, its center is vertex 3.
",graphmatchings,6
"import java.util.Scanner;


public final class b1 {

	public static void main(String[] args) {
		Scanner datain = new Scanner(System.in);
		long l=datain.nextLong();
		long r=datain.nextLong();
		if(r-l<2){System.out.print(-1);}else{
			if(((r-l)==2)&&(l%2==1)){System.out.print(-1);}else{
				if((l%2)==0){System.out.print(""""+l+"" ""+(l+1)+"" ""+(l+2));}else{
					System.out.print(""""+(l+1)+"" ""+(l+2)+"" ""+(l+3));
				}
			}
		}
	}

}
",0483_A,CODEFORCES,484,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"import java.util.*;
import java.io.*;

public class MinimumDiameterTree{
    public static void main(String[] args) {
	InputReader in = new InputReader (System.in);
	PrintWriter out = new PrintWriter (System.out);

	int n = in.nextInt();
	int s = in.nextInt();
	int deg[] = new int [n];
	
	for (int i = 1; i < n; ++i) {
	    deg[in.nextInt() - 1] ++;
	    deg[in.nextInt() - 1] ++;
	}

	int l = 0;
	for (int i = 0; i < n; ++i)
	    if (deg[i] == 1) l ++;

	out.println((double) 2 * s / l);
	out.close();
    }

    public static class InputReader {
	public BufferedReader reader;
	public StringTokenizer tokenizer;

	public InputReader(InputStream stream) {
	    reader = new BufferedReader(new InputStreamReader(stream), 32768);
	    tokenizer = null;
	}

	public String next() {
	    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
		try {
		    tokenizer = new StringTokenizer(reader.readLine());
		} catch(IOException e) {
		    throw new RuntimeException(e);
		}
	    }
	    return tokenizer.nextToken();
	}

	public int nextInt() {
	    return Integer.parseInt(next());
	}

	public long nextLong() {
            return Long.parseLong(next());
        }
    }
}
",1086_B,CODEFORCES,2106,Minimum Diameter Tree,"You are given a tree (an undirected connected graph without cycles) and an integer $$$s$$$.
Vanya wants to put weights on all edges of the tree so that all weights are non-negative real numbers and their sum is $$$s$$$. At the same time, he wants to make the diameter of the tree as small as possible.
Let's define the diameter of a weighed tree as the maximum sum of the weights of the edges lying on the path between two some vertices of the tree. In other words, the diameter of a weighed tree is the length of the longest simple path in the tree, where length of a path is equal to the sum of weights over all edges in the path.
Find the minimum possible diameter that Vanya can get.
The first line contains two integer numbers $$$n$$$ and $$$s$$$ ($$$2 \leq n \leq 10^5$$$, $$$1 \leq s \leq 10^9$$$) — the number of vertices in the tree and the sum of edge weights.
Each of the following $$$n−1$$$ lines contains two space-separated integer numbers $$$a_i$$$ and $$$b_i$$$ ($$$1 \leq a_i, b_i \leq n$$$, $$$a_i \neq b_i$$$) — the indexes of vertices connected by an edge. The edges are undirected.
It is guaranteed that the given edges form a tree.
Print the minimum diameter of the tree that Vanya can get by placing some non-negative real weights on its edges with the sum equal to $$$s$$$.
Your answer will be considered correct if its absolute or relative error does not exceed $$$10^{-6}$$$.
Formally, let your answer be $$$a$$$, and the jury's answer be $$$b$$$. Your answer is considered correct if $$$\frac {|a-b|} {max(1, b)} \leq 10^{-6}$$$.
In the first example it is necessary to put weights like this:
","input
It is easy to see that the diameter of this tree is $$$2$$$. It can be proved that it is the minimum possible diameter.
output
In the second example it is necessary to put weights like this:
","greedy, implementation, trees",3
"import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class B {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		Pattern rcp = Pattern.compile(""R(\\d+)C(\\d+)"");
		Pattern op = Pattern.compile(""(\\D+)(\\d+)"");
		for (int n = s.nextInt(); n-- > 0;) {
			String line = s.next();
			Matcher m1 = rcp.matcher(line);
			Matcher m2 = op.matcher(line);
			if (m1.matches()) {
				int a = new Integer(m1.group(2));
				String r = """";
				for (; a > 0;) {
					int b = a % 26;
					a /= 26;
					if (b < 1) {
						b = 26;
						--a;
					}
					r = (char) (b + 64) + r;
				}
				line = r + m1.group(1);
			} else if (m2.matches()) {
				int r = 0;
				for (int a : m2.group(1).toCharArray()) {
					r = r * 26 + (a - 64);
				}
				line = ""R"" + m2.group(2) + ""C"" + r;
			}
			System.out.println(line);
		}
	}
}
",0001_B,CODEFORCES,1465,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math",3
"import java.io.*;
import java.util.*;

public class Main{
	static long inf=(long)1e9;
	static HashSet<Long>squares;
	static void main() throws Exception{
		long n=sc.nextInt();
		if((n%2==0 && squares.contains(n/2)) || (n%4==0 && squares.contains(n/4))) {
			pw.println(""YES"");
		}
		else {
			pw.println(""NO"");
		}
    }
    public static void main(String[] args) throws Exception{
    	sc=new MScanner(System.in);
    	pw = new PrintWriter(System.out);
        int tc=1;
        tc=sc.nextInt();
        squares=new HashSet<Long>();
        for(long i=1;i*i<=inf;i++) {
        	squares.add(i*i);
        }
        for(int i=1;i<=tc;i++) {
//            pw.printf(""Case #%d: "", i);
            main();
        }
        pw.flush();
    }
    static PrintWriter pw;
    static MScanner sc;
    static class MScanner {
        StringTokenizer st;
        BufferedReader br;
        public MScanner(InputStream system) {
            br = new BufferedReader(new InputStreamReader(system));
        }
     
        public MScanner(String file) throws Exception {
            br = new BufferedReader(new FileReader(file));
        }
     
        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }
        public int[] intArr(int n) throws IOException {
            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();
            return in;
        }
        public long[] longArr(int n) throws IOException {
            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();
            return in;
        }
        public int[] intSortedArr(int n) throws IOException {
            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();
            shuffle(in);
            Arrays.sort(in);
            return in;
        }
        public long[] longSortedArr(int n) throws IOException {
            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();
            shuffle(in);
            Arrays.sort(in);
            return in;
        }
        public Integer[] IntegerArr(int n) throws IOException {
            Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();
            return in;
        }
        public Long[] LongArr(int n) throws IOException {
            Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();
            return in;
        }
        public String nextLine() throws IOException {
            return br.readLine();
        }
     
        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }
     
        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
     
        public char nextChar() throws IOException {
            return next().charAt(0);
        }
     
        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }
     
        public boolean ready() throws IOException {
            return br.ready();
        }
     
        public void waitForInput() throws InterruptedException {
            Thread.sleep(3000);
        }
        
    }
    static void sort(int[]in) {
    	shuffle(in);
        Arrays.sort(in);
    }
    static void sort(long[]in) {
    	shuffle(in);
        Arrays.sort(in);
    }
    static void shuffle(int[]in) {
        for(int i=0;i<in.length;i++) {
            int idx=(int)(Math.random()*in.length);
            int tmp=in[i];
            in[i]=in[idx];
            in[idx]=tmp;
        }
    }
    static void shuffle(long[]in) {
        for(int i=0;i<in.length;i++) {
            int idx=(int)(Math.random()*in.length);
            long tmp=in[i];
            in[i]=in[idx];
            in[idx]=tmp;
        }
    }
}",1515_B,CODEFORCES,2176,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",3
"import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;


public class R015A {
    final double EPS = 1e-9;    
    boolean isEqual(double x, double y) {
        return Math.abs(x-y) <= EPS * Math.max(Math.abs(x), Math.abs(y));
    }
    class Pair implements Comparable<Pair>{
        double left;
        double right;
        Pair(double left, double right) {
            this.left = left;
            this.right = right;
        }
        public String toString() {
            return ""("" + left + "","" + right + "")"";
        }
        public int hashCode() {
            return (int)(left * 17 + right * 31);
        }
        public boolean equals(Object o) {
            if(!(o instanceof Pair)) return false;
            Pair that = (Pair)o;
            return isEqual(this.left, that.left) && isEqual(this.right, that.right);
        }
        public int compareTo(Pair that) {
            if(this.left != that.left)
                return (int)(this.left - that.left);
            return (int)(this.right - that.right);
        }
    }
    public R015A() {
    }
    
    private void process() {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int t = scanner.nextInt();
        int[] x = new int[n];
        int[] a = new int[n];
        for(int i=0; i<n; i++) {
            x[i] = scanner.nextInt();
            a[i] = scanner.nextInt();
        }
        List<Pair> pairs = new ArrayList<Pair>();
        for(int i=0; i<n; i++) {
            double left = x[i] - a[i] / 2.0;
            double right= x[i] + a[i] / 2.0;
            pairs.add(new Pair(left, right));
        }
        Collections.sort(pairs);
        Set<Pair> newPairs = new HashSet<Pair>();
        newPairs.add(new Pair(pairs.get(0).left - t, pairs.get(0).left));
        for(int i=0; i<pairs.size()-1; i++) {
            if(pairs.get(i+1).left - pairs.get(i).right >= t) {
                newPairs.add(new Pair(pairs.get(i).right, pairs.get(i).right + t));
                newPairs.add(new Pair(pairs.get(i+1).left - t, pairs.get(i+1).left));
            }
        }
        newPairs.add(new Pair(pairs.get(pairs.size()-1).right, pairs.get(pairs.size()-1).right + t));
        System.out.println(newPairs.size());
    }
    
    public static void main(String[] args) {
        new R015A().process();
    }
}
",0015_A,CODEFORCES,2270,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"import java.util.*;
import java.io.*;

public class _1190_B {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);
        int n = Integer.parseInt(in.readLine());
        int[] a = new int[n];
        StringTokenizer line = new StringTokenizer(in.readLine());
        for(int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(line.nextToken());
        }
        Arrays.sort(a);
        int dupecount = 0;
        boolean escape = false;
        for(int i = 1; i < n; i++) {
            if(a[i] == a[i - 1]) {
                dupecount++;
                if(a[i] > 0 && (i < 2 || a[i - 2] + 1 < a[i])) {
                    escape = true;
                }
            }
        }
        if(dupecount > 1 || (dupecount == 1 && !escape)) {
            out.println(""cslnb"");
        }else {
            long dif = 0;
            for(int i = 0; i < n; i++) {
                dif += a[i] - i;
            }
            if(dif % 2 == 0) {
                out.println(""cslnb"");
            }else {
                out.println(""sjfnb"");
            }
        }
        in.close();
        out.close();
    }
}
",1190_B,CODEFORCES,2151,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
",games,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class Main {

    FastScanner in;
    PrintWriter out;

    public void solve() throws IOException {
        double a = in.nextInt();
        double v = in.nextInt();
        double l = in.nextInt();
        double d = in.nextInt();
        double w = in.nextInt();

        if (w * w / (a * 2) > d || v < w) {
            if (v * v / (a * 2) > l) {
                out.println(Math.sqrt(l * 2 / a));
            }
            else {
                double t = v / a;
                double s = l - t * v / 2;
                t = t + s / v;
                out.println(t);
            }
            return;
        }
        double t = solveD(a, v, w, d);
        if ((v + w) * (v - w) / (a * 2) > l - d) {
            double dis = w * w + a * (l - d) * 2;
            double t1 = (Math.sqrt(dis) - w) / a;
            System.out.println(t + t1);
        }
        else {
            double t1 = (v - w) / a;
            double s = l - d - (v + w) * t1 / 2;
            double t2 = s / v;
            System.out.println(t + t1 + t2);
        }
    }

    public double solveD(double a, double vMax, double wBound, double s) {
        double v = Math.sqrt(a * s + wBound * wBound / 2);
        if (v > vMax) {
            v = vMax;
        }
        double t1 = v / a;
        double t2 = (v - wBound) / a;
        double s1 = v * t1 / 2;
        double s2 = (v + wBound) * t2 / 2;
        double sr = s - s1 - s2;
        double tr = sr / v;
        return t1 + t2 + tr;

    }

    public void run() {
        try {
            in = new FastScanner(System.in);
            out = new PrintWriter(System.out);
            solve();
            out.close();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

    class FastScanner {

        BufferedReader br;
        StringTokenizer st;

        FastScanner(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }
    }

    public static void main(String[] arg) {
        new Main().run();
    }
}
",0005_D,CODEFORCES,4,Follow Traffic Rules,"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.
It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km/h2, and has maximum speed of v km/h. The road has the length of l km, and the speed sign, limiting the speed to w km/h, is placed d km (1 ≤ d < l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.
The car can enter Bercouver at any speed.
","input
The first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).
output
Print the answer with at least five digits after the decimal point.
","implementation, math",1
"import java.util.Arrays;
import java.util.Scanner;

public class ProblemC {
	static long MOD = 1_000_000_007;

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int n = input.nextInt();
		boolean[] isFor = new boolean[n];
		for (int a = 0; a < n; a++) {
			isFor[a] = input.next().charAt(0) == 'f';
		}
		long[][] array = new long[n + 1][n + 1];
		array[0][0] = 1;
		boolean isPreviousFor = false;
		for (int idx = 0; idx < n; idx++) {
			long heightCache = 0;
			for (int height = n-1; height >= 0; height--) {
				if (isPreviousFor) {
					array[idx + 1][height + 1] += array[idx][height];
					array[idx + 1][height + 1] %= MOD;
				} else {
					heightCache += array[idx][height];
					heightCache %= MOD;
					array[idx + 1][height] += heightCache;
					array[idx + 1][height] %= MOD;
				}
			}
			isPreviousFor = isFor[idx];
		}
//		System.out.println(Arrays.deepToString(array));
		long sum = 0;
		for (int height = 0; height <= n; height++) {
			sum += array[n][height];
		}
		System.out.println(sum % MOD);
	}
}
",0909_C,CODEFORCES,3080,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"import java.io.*;
import java.util.*;
import java.math.*;

public class Main implements Runnable {
    public InputReader in;
    public PrintWriter out;

    public void solve() throws Exception {
        // solution goes here
        int N = in.nextInt();

        int[] houses = new int[N];
        boolean[] exist = new boolean[52];

        for (int i = 0; i < N; i++) {
            char c = in.nextChar();
            if ('a' <= c && c <= 'z') {
                houses[i] = 26 + (c - 'a');
            } else {
                houses[i] = (c - 'A');
            }
            exist[houses[i]] = true;
        }

        int[][] pokemons = new int[N][52];

        pokemons[0][houses[0]] = 1;

        for (int i = 1; i < N; i++) {
            System.arraycopy(pokemons[i-1], 0, pokemons[i], 0, pokemons[i].length);
            pokemons[i][houses[i]]++;
        }

        int uniques = 0;
        for(boolean bool : exist)
            if (bool)
                uniques++;

        if (uniques == 1) {
            out.print(1);
            return;
        }


        int last_variant = -1;
        for (int i = 0; i < N-1; i++) {
            if (pokemons[i][houses[i]] == pokemons[N-1][houses[i]]) {
                last_variant = i;
                break;
            }
        }

        int minimum = N;

        for (int i = 0; i <= last_variant; i++) {
            if (houses[i] == houses[i+1])
                continue;

            // binary search

            int low = i+1;
            int high = N-1;

            while (low < high) {
                int mid = (low + high) / 2;

                boolean allPresent = true;
                for (int j = 0; j < 52; j++) {
                    if (j != houses[i] && exist[j] && pokemons[mid][j] == pokemons[i][j]) {
                        allPresent = false;
                        break;
                    }
                }

                if (allPresent) {
                    high = mid; // infinite??
                } else {
                    low = mid + 1;
                }
            }

            minimum = min(minimum, low - i + 1);

        }

        out.print(minimum);
    }

    public void run() {
        try {
            in = new InputReader(System.in);
            out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
            Locale.setDefault(Locale.US);
            int tests = 1;
            while (tests-- > 0) {
                solve();
            }
            out.close();
        } catch (Throwable e) {
            e.printStackTrace();
            System.exit(7);
        }
    }

    static int abs(int x) {
        return x < 0 ? -x : x;
    }

    static int max(int a, int b) {
        return a > b ? a : b;
    }

    static int min(int a, int b) {
        return a < b ? a : b;
    }

    static long abs(long x) {
        return x < 0 ? -x : x;
    }

    static long max(long a, long b) {
        return a > b ? a : b;
    }

    static long min(long a, long b) {
        return a < b ? a : b;
    }

    public static void main(String args[]) {
        new Thread(null, new Main(), ""Main"", 1 << 28).start();
    }

    static boolean OJ = System.getProperty(""ONLINE_JUDGE"") != null;

    public void console(Object... objects) {
        if (!OJ) {
            out.println(Arrays.deepToString(objects));
            out.flush();
        }
    }

    @SuppressWarnings({""Duplicates"", ""unused""})
    static class InputReader {

        private InputStream stream;
        private byte[] buf = new byte[2048];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;

        public InputReader() {
            this.stream = System.in;
        }

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public InputReader(SpaceCharFilter filter) {
            this.stream = System.in;
            this.filter = filter;
        }

        public InputReader(InputStream stream, SpaceCharFilter filter) {
            this.stream = stream;
            this.filter = filter;
        }

        public int read() {
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public char nextChar() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            return (char) c;
        }

        public int nextDigit() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            return c - '0';
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            boolean negative = false;
            if (c == '-') {
                negative = true;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return negative ? -res : res;
        }

        public int[] nextInts(int N) {
            int[] nums = new int[N];
            for (int i = 0; i < N; i++)
                nums[i] = nextInt();
            return nums;
        }

        public long[] nextLongs(int N) {
            long[] nums = new long[N];
            for (int i = 0; i < N; i++)
                nums[i] = nextLong();
            return nums;
        }

        public int nextUnsignedInt() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int res = 0;
            do {
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res;
        }

        public final long nextLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            boolean negative = false;
            if (c == '-') {
                negative = true;
                c = read();
            }
            long res = 0;
            do {
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return negative ? -res : res;
        }

        public final long nextUnsignedLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            long res = 0;
            do {
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            long sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1 || c == '.'));

            if (c != '.') {
                return res * sgn;
            }
            c = read();

            long aft = 0;
            int len = 1;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                aft *= 10;
                len *= 10;
                aft += c - '0';
                c = read();
            } while (!isSpaceChar(c));

            return res * sgn + aft / (1.0 * len);
        }

        public String nextLine() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isEndChar(c));
            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public boolean isEndChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public char[] nextChars() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));

            char[] chars = new char[res.length()];
            res.getChars(0, chars.length, chars, 0);
            return chars;
        }

        public int[][] nextIntMatrix(int rows, int cols) {
            int[][] matrix = new int[rows][cols];
            for (int i = 0; i < rows; i++)
                for (int j = 0; j < cols; j++)
                    matrix[i][j] = nextInt();
            return matrix;
        }

        public long[][] nextLongMatrix(int rows, int cols) {
            long[][] matrix = new long[rows][cols];
            for (int i = 0; i < rows; i++)
                for (int j = 0; j < cols; j++)
                    matrix[i][j] = nextLong();
            return matrix;
        }

        public char[][] nextCharMap(int rows, int cols) {
            char[][] matrix = new char[rows][cols];
            for (int i = 0; i < rows; i++)
                for (int j = 0; j < cols; j++)
                    matrix[i][j] = nextChar();
            return matrix;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
}",0701_C,CODEFORCES,1767,They Are Everywhere,"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.
There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 
Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. 
The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.
The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. 
Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. 
In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.
","input
In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 
output
In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.
","binarysearch, strings, twopointers",3
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class Main {
    protected static final double EPS = 1e-11;
    private static StreamTokenizer in;
    private static Scanner ins;
    private static PrintWriter out;
    protected static final Double[] BAD = new Double[]{null, null};
    private boolean[][] layouts;
    private int c;
    private int b;
    private int a;
    private String word;

    public static void main(String[] args) {

        try {
            in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
            ins = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            out = new PrintWriter(System.out);
            try {
                if (System.getProperty(""xDx"") != null) {
                    in = new StreamTokenizer(new BufferedReader(new FileReader(""input.txt"")));
                    ins = new Scanner(new FileReader(""input.txt""));
                    out = new PrintWriter(new FileWriter(""output.txt""));
                }
            } catch (Exception e) {
                in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
                ins = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
                out = new PrintWriter(System.out);
            }
            new Main().run();
        } catch (Throwable e) {
//            e.printStackTrace();
            throw new RuntimeException(e);
        } finally {
            out.close();
        }
    }

    private int nextInt() throws IOException {
        in.nextToken();
        return (int) in.nval;
    }

    private long nextLong() throws IOException {
        in.nextToken();
        return (long) in.nval;
    }

    private double nextDouble() throws IOException {
        in.nextToken();
        return in.nval;
    }

    private String nextString() throws IOException {
        in.nextToken();
        return in.sval;
    }

    private char nextChar() throws IOException {
        in.nextToken();
        return (char) in.ttype;
    }

    private void run() throws Exception {
        /*int t = nextInt();
        for (int i = 0; i < t; i++) {
            out.printf(Locale.US, ""Case #%d: %d\n"", i + 1, solve());
        }*/
        solve();
    }

    private void solve() throws IOException {
        int n = ins.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = ins.nextInt();
        }

        Map<Long, Integer> map = new HashMap<>();

        BigInteger res = BigInteger.ZERO;
        long sum = 0;
        long amount = 0;

        for (int i = n - 1; i >= 0; i--) {
            long cur = a[i];
            Pair same = getZeroAmount(cur, map);

            res = res.add(BigInteger.valueOf((sum - same.sum) - cur * (amount - same.amount)));
            amount++;
            sum += cur;
            map.put(cur, map.getOrDefault(cur, 0) + 1);
        }

        out.println(res);
    }

    class Pair {
        long amount;
        long sum;

        public Pair(long amount, long sum) {
            this.amount = amount;
            this.sum = sum;
        }
    }

    private Pair getZeroAmount(long cur, Map<Long, Integer> map) {
        long amount = 0;
        long sum = 0;
        for (long i = cur - 1; i <= cur + 1; i++) {
            long amountI = map.getOrDefault(i, 0);
            amount += amountI;
            sum += amountI * i;
        }
        return new Pair(amount, sum);
    }

    private List<Integer> iterate(List<Integer> a) {
        ArrayList<Integer> b = new ArrayList<>();
        int prev = -1;
        for (int x : a) {
            if (x == prev) {
                b.add(x);
            } else {
                prev = x;
            }
        }
        return b;
    }

    private long gcd(long a, long b) {
        while (a > 0 && b > 0) {
            long k = a % b;
            a = b;
            b = k;
        }

        return a | b;
    }

}",0903_D,CODEFORCES,2787,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math",4
"import java.util.*;
import java.io.*;

public class Solution
{
    static class Reader {
		BufferedReader br;
		StringTokenizer st;
 
		public Reader() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
 
		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int[] nextArr(int n)
		{
		    int a[]=new int[n];
		    for (int i=0;i<n;i++)a[i]=nextInt();
		    return a;
		}
		
		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}
 
		double nextDouble() {
			return Double.parseDouble(next());
		}
 
		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}
 
	}
    static class Ele implements Comparable<Ele> 
    {  
        public int x,y;  
        Ele(int x1,int y1) 
        {  
            x=x1;y=y1; 
        }  
        public int compareTo(Ele ob) {  
        if(ob.x!=x)return x-ob.x;
        return this.y-ob.y;  
        }   
        public String toString()
        {
        	return ""[""+x+"",""+y+""]"";
        }
    }
	void disp(PrintWriter o,boolean b)
    {
        if (b) o.println(""Yes"");
        else o.println(""No"");
    }
    void disp(PrintWriter o,int ...a)
    {
        o.println(Arrays.toString(a));
    }
    void disp(PrintWriter o,long ...a)
    {
        o.println(Arrays.toString(a));
    }
    void func(PrintWriter o,ArrayList<Integer> a)
    {
        for (int i=0;i<a.size();i++)
        {
            if (i!=a.size()-1)
            o.print(a.get(i)+""."");
            else o.println(a.get(i));
        }
    }
    int dp[][];

	public static void main(String[] args) throws IOException 
	{
		Reader sc=new Reader();Solution G=new Solution();//MyMath mm=new MyMath();
		PrintWriter o = new PrintWriter(System.out);
		int t=1;t=sc.nextInt();
		int mod=(int)1e9+7;
		int x,x0,x1,x2;int y,y0,y1,y2;int s,s0,s1,s2;
		int n,m;int a[],b[],in[],in1[];
		long k,l;boolean v[],b1,b2;String ss;char c1[];
		//long l;long a[]; 
		ArrayList<ArrayList<Integer>> ll=new ArrayList<>();
		ArrayList<Integer> a1=new ArrayList<>();
		ArrayList<Integer> a2=new ArrayList<>();
		PriorityQueue<Integer> pq1=new PriorityQueue<>();
		PriorityQueue<Integer> pq2=new PriorityQueue<>(Collections.reverseOrder());
		ArrayDeque<Integer> dq=new ArrayDeque<>();
		TreeSet<Integer> h0=new TreeSet<>();
		TreeSet<Integer> h1=new TreeSet<>();
		TreeMap<Integer,Integer> h=new TreeMap<>();
		try{
		while (t-->0)
		{
		    n=sc.nextInt();a=sc.nextArr(n);b=new int[(int)1e4];
		    a1.add(a[0]);b[1]=a[0];
		    for (int i=1;i<n;i++)
		    {
		        G.func(o,a1);
		        x=a1.get(a1.size()-1);
		        if (a[i]==1)
		        {
		            a1.add(a[i]);
		            b[a1.size()]=a[i];
		        }
		        else if (a[i]==x+1)
		        {
		            a1.remove(a1.size()-1);
		            a1.add(a[i]);
		            b[a1.size()]=a[i];
		        }
		        else
		        {
		            while (a1.get(a1.size()-1)!=a[i]-1)
		            a1.remove(a1.size()-1);
		            a1.remove(a1.size()-1);
		            a1.add(a[i]);
		        }
		    }
		    G.func(o,a1);
		    //o.println();
		    //o.println(n);
		    //o.println();
		    //o.println();
		    //o.println(h);
		    //o.println(x2);
		    //o.println();
		    h0.clear();ll.clear();a1.clear();a2.clear();h1.clear();h.clear();pq1.clear();pq2.clear();
		}
		}
		catch (Throwable e)
		{
		    e.printStackTrace();
		}
		//o.println(""HI"");
		
        o.flush();
        o.close();
	}
} ",1523_C,CODEFORCES,3615,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees",5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Inet4Address;
import java.util.Arrays;
import java.util.StringTokenizer;

/**
 * Created by shirsh.bansal on 07/08/16.
 */
public class Main {
    public static void main(String[] args) throws IOException {
        FastScanner scanner = new FastScanner();

        int n = scanner.nextInt();
        int m = scanner.nextInt();

        boolean graph[][] = new boolean[n][n];
        for (int i = 0; i < m; i++) {
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            graph[a-1][b-1] = true;
            graph[b-1][a-1] = true;
        }

        if(n <= 2) {
            System.out.println(0);
            return;
        }

        long dp[][] = new long[1<<n][n];

        for (int i = 0; i < (1<<n); i++) {
            Arrays.fill(dp[i], -1);
        }

        for (int i = 1; i < (1<<n); i++) {
            for (int j = 0; j < n; j++) {
                f(i, j, dp, graph, n);
            }
        }

        long sum = 0;

//        for (int i = 7; i < (1 << n); i++) {
//            if(Integer.bitCount(i) < 3) continue;
//            for (int j = 0; j < n; j++) {
//                int startNode = Integer.numberOfTrailingZeros(Integer.highestOneBit(i));
//                int endNode = j;
//
//                if(graph[startNode][endNode] && dp[i][j] != -1) {
////                    System.out.println(i + "" "" + startNode + "" "" + endNode + "" "" + dp[i][j]);
//                    sum += dp[i][j];
//                }
//            }
//        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < (1 << n); j++) {
                if(Integer.bitCount(j) >= 3 && graph[Integer.numberOfTrailingZeros(j)][i]) {
                    sum += dp[j][i];
                }
            }
        }

        System.out.println(sum/2);
    }

    private static long f(int mask, int i, long[][] dp, boolean[][] graph, int n) {
        if(dp[mask][i] != -1) return dp[mask][i];
        if(Integer.bitCount(mask) == 1 && (mask&(1<<i)) != 0) {
            dp[mask][i] = 1;
        } else if(Integer.bitCount(mask) > 1 && (mask&(1<<i)) != 0 && i != Integer.numberOfTrailingZeros(mask)) {
            dp[mask][i] = 0;
            for (int j = 0; j < n; j++) {
                if(graph[i][j]) dp[mask][i] = dp[mask][i] + f(mask^(1<<i), j, dp, graph, n);
            }
        } else {
            dp[mask][i] = 0;
        }

//        int tmpMask = mask ^ (1<<i);
//        for (int j = 0; j <= firstNode; j++) {
//            if(((1<<j)&tmpMask) != 0 && graph[i][j]) {
//                dp[mask][i] += f(tmpMask, j, dp, graph, n, firstNode);
//            }
//        }
//
        return dp[mask][i];
    }

    static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        FastScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() throws IOException {
            while (st == null || !st.hasMoreTokens()) {
                st = new StringTokenizer(br.readLine());
            }
            return st.nextToken();
        }

        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }
    }
}
",0011_D,CODEFORCES,4403,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import java.util.Scanner;

public class St {

    static void metod() throws Exception {
        Scanner in = new Scanner(System.in);
        String str = in.next();

        int max = 0;
        for (int i = 0; i < str.length(); i++) {
            for (int j = i + 1; j < str.length() + 1; j++) {

                for (int k = 0; k < str.length(); k++) {
                    for (int n = k + 1; n < str.length() + 1; n++) {

                        if ((str.substring(i, j).equals(str.substring(k, n)))
                                && (k != i)) {
                            if (j - i > max)
                                max = j - i;
                        }
                    }
                }
            }
        }
        System.out.println(max);
    }

    public static void main(String args[]) throws Exception {
        St.metod();
    }
}
",0023_A,CODEFORCES,3715,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class C981 {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        Node[] nodes = new Node[N];
        for (int n=0; n<N; n++) {
            Node node = new Node();
            node.id = n+1;
            nodes[n] = node;
        }
        for (int n=1; n<N; n++) {
            int u = in.nextInt()-1;
            int v = in.nextInt()-1;
            nodes[u].next.add(nodes[v]);
            nodes[v].next.add(nodes[u]);
        }
        int degreeMoreThan2Count = 0;
        Node maxDegreeNode = nodes[0];
        for (Node node : nodes) {
            int degree = node.next.size();
            if (degree > 2) {
                degreeMoreThan2Count++;
            }
            if (degree > maxDegreeNode.next.size()) {
                maxDegreeNode = node;
            }
        }
        StringBuilder output = new StringBuilder();
        if (degreeMoreThan2Count > 1) {
            output.append(""No\n"");
        } else {
            output.append(""Yes\n"");
            output.append(maxDegreeNode.next.size()).append('\n');
            for (Node node : maxDegreeNode.next) {
                Node parent = maxDegreeNode;
                output.append(parent.id);
                while (true) {
                    if (node.next.size() == 1) {
                        break;
                    }
                    Node next = node.next.get(0);
                    if (next == parent) {
                        next = node.next.get(1);
                    }
                    parent = node;
                    node = next;
                }
                output.append(' ').append(node.id);
                output.append('\n');
            }
        }
        System.out.print(output);
    }

    static class Node {
        int id;
        List<Node> next = new ArrayList<>();
    }

}
",0981_C,CODEFORCES,1878,Useful Decomposition,"Ramesses knows a lot about problems involving trees (undirected connected graphs without cycles)!
He created a new useful tree decomposition, but he does not know how to construct it, so he asked you for help!
The decomposition is the splitting the edges of the tree in some simple paths in such a way that each two paths have at least one common vertex. Each edge of the tree should be in exactly one path.
Help Remesses, find such a decomposition of the tree or derermine that there is no such decomposition.
The first line contains a single integer $$$n$$$ ($$$2 \leq n \leq 10^{5}$$$) the number of nodes in the tree.
Each of the next $$$n - 1$$$ lines contains two integers $$$a_i$$$ and $$$b_i$$$ ($$$1 \leq a_i, b_i \leq n$$$, $$$a_i \neq b_i$$$) — the edges of the tree. It is guaranteed that the given edges form a tree.
If there are no decompositions, print the only line containing ""No"".
Otherwise in the first line print ""Yes"", and in the second line print the number of paths in the decomposition $$$m$$$. 
Each of the next $$$m$$$ lines should contain two integers $$$u_i$$$, $$$v_i$$$ ($$$1 \leq u_i, v_i \leq n$$$, $$$u_i \neq v_i$$$) denoting that one of the paths in the decomposition is the simple path between nodes $$$u_i$$$ and $$$v_i$$$. 
Each pair of paths in the decomposition should have at least one common vertex, and each edge of the tree should be presented in exactly one path. You can print the paths and the ends of each path in arbitrary order.
If there are multiple decompositions, print any.
The tree from the first example is shown on the picture below:  The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.
","input
The tree from the second example is shown on the picture below:  We can show that there are no valid decompositions of this tree.
output
The tree from the third example is shown on the picture below:  The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.
","implementation, trees",3
"
import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.TreeMap;

public class Main {

	public static void main(String[] args) {

		Scanner in = new Scanner(new BufferedInputStream(System.in));
		PrintWriter out = new PrintWriter(new BufferedWriter(
				new OutputStreamWriter(System.out)));

		while (in.hasNext()) {
			int n = in.nextInt(), a = in.nextInt(), b = in.nextInt(), c = 0;
			int[] p = new int[n];

			TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();
			for (int i = 0; i < n; i++) {
				p[i] = in.nextInt();
				map.put(p[i], i);
			}
			
			if (a > b) {
				int t = b;
				b = a;
				a = t;
				c = 1;
			}

			boolean ok = true;
			int[] cls = new int[n];
			while (ok && map.size() > 0) {
				Entry<Integer, Integer> last = map.lastEntry();
				int v = last.getKey();
				int idx = last.getValue();
				if (map.containsKey(a - v)) {
					cls[idx] = 0;
					cls[map.get(a - v)] = 0;
					map.remove(v);
					map.remove(a -v);
				} else if (map.containsKey(b - v)) {
					cls[idx] = 1;
					cls[map.get(b - v)] = 1;
					map.remove(v);
					map.remove(b -v);
				} else 
					ok = false;
			}

			if (!ok)
				System.out.println(""NO"");
			else {
				System.out.println(""YES"");
				for (int j = 0; j < cls.length; j++) {
					if (j != 0)
						System.out.print("" "");
					System.out.print(c ^ cls[j]);
				}
				System.out.println();
			}
			out.flush();
		}
		in.close();
	}

}
",0468_B,CODEFORCES,1723,Two Sets,"Little X has n distinct integers: p1, p2, ..., pn. He wants to divide all of them into two sets A and B. The following two conditions must be satisfied:
Help Little X divide the numbers into two sets or determine that it's impossible.
The first line contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The next line contains n space-separated distinct integers p1, p2, ..., pn (1 ≤ pi ≤ 109).
If there is a way to divide the numbers into two sets, then print ""YES"" in the first line. Then print n integers: b1, b2, ..., bn (bi equals either 0, or 1), describing the division. If bi equals to 0, then pi belongs to set A, otherwise it belongs to set B.
","input
If it's impossible, print ""NO"" (without the quotes).
output
It's OK if all the numbers are in the same set, and the other one is empty.
","2-sat, dfsandsimilar, dsu, graphmatchings, greedy",3
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.IOException;
import java.util.StringTokenizer;
/*
 * @author Tnascimento 
 */

public class MaeDosDragoes {
	// public static StringTokenizer tokenizer;
	// public static BufferedReader reader;
	public static PrintWriter saida = new PrintWriter(System.out, false);
	// public static String proximo() {
	// 	while (tokenizer == null || !tokenizer.hasMoreElements()) {
	// 		try {
	// 			tokenizer = new StringTokenizer(reader.readLine());
	// 		} catch (RuntimeException e) {
	// 			e.printStackTrace();
	// 		}
	// 	}
	// 	return tokenizer.nextToken();
	// }

	public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;
        
        public FastScanner(Reader in) {
            br = new BufferedReader(in);
        }
        
        public FastScanner() {
            this(new InputStreamReader(System.in));
        }
        
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        
        int nextInt() {
            return Integer.parseInt(next());
        }
    }



    public static void main(String[] args) {
		FastScanner fastScanner = new FastScanner();
        int proximoInt = fastScanner.nextInt();
        double proximoDouble = fastScanner.nextInt();
        long[] graph = new long[proximoInt];
        for(Integer i = 0; i < proximoInt; i++) {
            for(Integer j =0; j < proximoInt; j++) {
                Integer val = fastScanner.nextInt();
                if (val.equals(1) || i.equals(j)) {
				 graph[i] |= 1L << j;
				}
            }
        }

        int szLeft = proximoInt/2;
        int szRight = proximoInt - szLeft;

        int[] dp = new int[1 << szLeft];
        int maxMask = 1 << szLeft;

        for(int mask = 1; mask <maxMask; mask++) {
            int curMask = mask;

            for(int j = 0; j < szLeft; j++) {
                if (((1 << j) & mask) > 0) {
                    curMask &= graph[j + szRight] >> szRight;
                    dp[mask] = Math.max(dp[mask], dp[mask ^ (1 << j)]);
                }
            }
            if (mask == curMask) {
                dp[mask] = Math.max(dp[mask],Integer.bitCount(mask));
            }
        }
        int ans = 0;
        int rmaxMask = 1 << szRight;
        for(int mask = 0; mask < rmaxMask; mask++) {
            int curMask = mask;
            int oMask = maxMask -1;
            for(int j = 0; j < szRight; j++) {
                if (((1 << j) & mask) > 0) {
                    curMask &= (graph[j] & (rmaxMask-1));
                    oMask &= graph[j] >> szRight;
                }
            }
            if (curMask != mask) continue;
            ans = Math.max(ans, Integer.bitCount(mask) + dp[oMask]);
        }
        proximoDouble/=ans;
        saida.println(proximoDouble * proximoDouble * (ans * (ans-1))/2);
        saida.flush();
    }
}
",0839_E,CODEFORCES,4628,Mother of Dragons,"There are n castles in the Lannister's Kingdom and some walls connect two castles, no two castles are connected by more than one wall, no wall connects a castle to itself. 
Sir Jaime Lannister has discovered that Daenerys Targaryen is going to attack his kingdom soon. Therefore he wants to defend his kingdom. He has k liters of a strange liquid. He wants to distribute that liquid among the castles, so each castle may contain some liquid (possibly zero or non-integer number of liters). After that the stability of a wall is defined as follows: if the wall connects two castles a and b, and they contain x and y liters of that liquid, respectively, then the strength of that wall is x·y.
Your task is to print the maximum possible sum of stabilities of the walls that Sir Jaime Lannister can achieve.
The first line of the input contains two integers n and k (1 ≤ n ≤ 40, 1 ≤ k ≤ 1000).
Then n lines follows. The i-th of these lines contains n integers ai, 1, ai, 2, ..., ai, n (). If castles i and j are connected by a wall, then ai, j = 1. Otherwise it is equal to 0.
It is guaranteed that ai, j = aj, i and ai, i = 0 for all 1 ≤ i, j ≤ n.
Print the maximum possible sum of stabilities of the walls that Sir Jaime Lannister can achieve.
Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.
Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .
","input
In the first sample, we can assign 0.5, 0.5, 0 liters of liquid to castles 1, 2, 3, respectively, to get the maximum sum (0.25).
output
In the second sample, we can assign 1.0, 1.0, 1.0, 1.0 liters of liquid to castles 1, 2, 3, 4, respectively, to get the maximum sum (4.0)
","bruteforce, graphs, math, meet-in-the-middle",7
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

/**
 * Author -
 * User: kansal
 * Date: 9/3/11
 * Time: 5:28 PM
 */
public class CF85C {
    public static void main(String[] args) {
        reader = new BufferedReader(new InputStreamReader(System.in));

        int height = nextInt(), width = nextInt();
        if (width > height) {
            int t = width;
            width = height;
            height = t;
        }

        final int INF = height * width + 10;
        final int ALL_BITS = (1 << width)  - 1;
        int[][][] dp = new int[height + 1][1 << width][1 << width];
        for (int[][] ints : dp) {
            for (int[] anInt : ints) {
                Arrays.fill(anInt, INF);
            }
        }

        dp[0][0][0] = 0;
        for(int r = 0; r < height; ++r) {
            for(int uncovered = 0; uncovered < (1 << width); ++uncovered) {
                for(int mask = 0; mask < (1 << width); ++mask) {
                    if (dp[r][uncovered][mask] == INF) {
                        continue;
                    }

                    for(int curMask = uncovered; curMask < (1 << width); curMask = (curMask + 1) | uncovered) {
                        int curCovered = (mask | curMask);
                        curCovered |= (curMask >> 1);
                        curCovered |= (ALL_BITS & (curMask << 1));

                        int curUncovered = ALL_BITS ^ curCovered;
                        dp[r+1][curUncovered][curMask] = Math.min(dp[r+1][curUncovered][curMask], dp[r][uncovered][mask] + Integer.bitCount(curMask));
                    }
                }
            }
        }

        int res = INF;
        for(int x: dp[height][0]) res = Math.min(res, x);

        System.out.println(height * width - res);
    }

    public static BufferedReader reader;

    public static StringTokenizer tokenizer = null;

    static String nextToken() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    static public int nextInt() {
        return Integer.parseInt(nextToken());
    }

    static public long nextLong() {
        return Long.parseLong(nextToken());
    }

    static public String next() {
        return nextToken();
    }

    static public String nextLine() {
        try {
            return reader.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

}
",0111_C,CODEFORCES,4606,Petya and Spiders,"Little Petya loves training spiders. Petya has a board n × m in size. Each cell of the board initially has a spider sitting on it. After one second Petya chooses a certain action for each spider, and all of them humbly perform its commands. There are 5 possible commands: to stay idle or to move from current cell to some of the four side-neighboring cells (that is, one command for each of the four possible directions). Petya gives the commands so that no spider leaves the field. It is allowed for spiders to pass through each other when they crawl towards each other in opposite directions. All spiders crawl simultaneously and several spiders may end up in one cell. Petya wants to know the maximum possible number of spider-free cells after one second.
The first line contains two space-separated integers n and m (1 ≤ n, m ≤ 40, n·m ≤ 40) — the board sizes.
In the first line print the maximum number of cells without spiders.
In the first sample the only possible answer is:
s
","input
In the second sample one of the possible solutions is: 
output
s denotes command ""stay idle"", l, r, d, u denote commands ""crawl left"", ""crawl right"", ""crawl down"", ""crawl up"", correspondingly.
","bitmasks, dp, dsu",7
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.StringTokenizer;

public class D
{
	public static void main(String[] args) throws IOException
	{
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		
		BigInteger ans = BigInteger.ZERO;
		int n = sc.nextInt();
		int arr[] = new int[n];
		long cum[] = new long[n];
		
		for (int i = 0; i < n; i++)
			arr[i] = sc.nextInt();
		
//		int n=(int)2e5;
//		for(int i=0;i<n;i++){
//			arr[i]=1;
//			if(i>n/2)
//				arr[i]=(int)1e9;
//		}
		
		for (int i = 0; i < cum.length; i++)
		{
			cum[i] = arr[i];
			if(i > 0)
				cum[i] += cum[i-1];
		}
		
		for (int i = 0; i < n; i++)
			ans = ans.add(BigInteger.valueOf((1l*(i+1)*arr[i] - cum[i])));
		
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < n; i++)
		{
			ans =  ans.subtract(BigInteger.valueOf(map.getOrDefault(arr[i]-1, 0)));
			ans = ans.add(BigInteger.valueOf(map.getOrDefault(arr[i]+1, 0)));
			map.put(arr[i], map.getOrDefault(arr[i], 0)+1);
		}
		
		pw.println(ans);
		pw.flush();
		pw.close();
	}
	
		
	static class Scanner
	{
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s)
		{
			br = new BufferedReader(new InputStreamReader(s));
		}

		public Scanner(String s) throws FileNotFoundException
		{
			br = new BufferedReader(new FileReader(new File((s))));
		}

		public String next() throws IOException
		{
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException
		{
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException
		{
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException
		{
			return br.readLine();
		}

		public double nextDouble() throws IOException
		{
			String x = next();
			StringBuilder sb = new StringBuilder(""0"");
			double res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-')
			{
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.')
				{
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder(""0"");
					dec = true;
				} else
				{
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException
		{
			return br.ready();
		}
	}
}
",0903_D,CODEFORCES,2785,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math",4
"import java.io.BufferedReader;
import java.io.*;
import java.util.*;

public class d {

    static BufferedReader br;
    static long mod = 1000000000 + 7;
    static HashSet<Integer> p = new HashSet<>();
     static boolean debug =true;
           //  Arrays.sort(time  , (a1,a2) -> (a1[0]-a2[0])); 2d array sort lamda
    public static void main(String[] args) throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pr = new PrintWriter(System.out);
        int tc = 1;
       long[] lr =readArray(2,0);
        long l =lr[0];long r = lr[1];
        long ans =  maximumXor(l,r);
        System.out.println(ans);
    }

    public static long maximumXor(long l,long r){
           //b System.out.println(l+"" ""+r);
    	if(l==r){
    		return 0l;
    	}
    	long bit  = findHighestBit(r);
    //	System.out.println(bit);
    	if(bit-1>=l){
    		return bit+bit-1;
    	}
    	else{
    		return maximumXor(l-bit,r-bit);
    	}
    }

    public static long findHighestBit(long x){

    	for(long bit = 63;bit>=0;bit--){
    		long res = 1l<<bit;
    		res = res&x;
    		if(res!=0){
    		//	System.out.println(x +"" ""+res+"" ""+bit);
    			return res;
    		}
    	}
    	return 0;
    }

    public static <E> void print(String var ,E e){
      if(debug==true){
      System.out.println(var +"" ""+e);
      }
    }
     private static long[]  sort(long[] e){
     ArrayList<Long> x=new ArrayList<>();
     for(long c:e){
       x.add(c);
     }
     Collections.sort(x);
     long[] y = new long[e.length];
     for(int i=0;i<x.size();i++){
       y[i]=x.get(i);
     }
     return y;
     }
    public static void printDp(long[][] dp) {

        int n = dp.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                System.out.print(dp[i][j] + "" "");
            }
            System.out.println();
        }
    }

    


  

    private static long gcd(long a, long b) {
        if (a == 0)
            return b;
        if (b == 0)
            return a;

        // base case
        if (a == b)
            return a;

        // a is greater
        if (a > b)
            return gcd(a % b, b);
        return gcd(a, b % a);
    }


    public static long min(long a, long b) {
        return Math.min(a, b);
    }

    public static int min(int a, int b) {
        return Math.min(a, b);
    }


    public static void sieve() {
        int[] pf = new int[100000000 + 1];
        //0 prime //1 not prime
        pf[0] = 1;
        pf[1] = 1;
        for (int j = 2; j <= 10000; j++) {

            if (pf[j] == 0) {
                p.add(j);
                for (int k = j * j; k < pf.length; k += j) {
                    pf[k] = 1;
                }
            }
        }

    }


    public static int[] readArray(int n, int x, int z) throws Exception {
        int[] arr = new int[n];
        String[] ar = cinA();
        for (int i = x; i < n + x; i++) {
            arr[i] = getI(ar[i - x]);
        }
        return arr;
    }

    public static long[] readArray(int n, int x) throws Exception {
        long[] arr = new long[n];
        String[] ar = cinA();
        for (int i = x; i < n + x; i++) {
            arr[i] = getL(ar[i - x]);
        }
        return arr;
    }

    public static void arrinit(String[] a, long[] b) throws Exception {
        for (int i = 0; i < a.length; i++) {
            b[i] = Long.parseLong(a[i]);
        }
    }

    public static HashSet<Integer>[] Graph(int n, int edge, int directed) throws Exception {
        HashSet<Integer>[] tree = new HashSet[n];

        for (int j = 0; j < edge; j++) {

            String[] uv = cinA();
            int u = getI(uv[0]);
            int v = getI(uv[1]);
            if (directed == 0) {

                tree[v].add(u);
            }
            tree[u].add(v);
        }
        return tree;
    }

    public static void arrinit(String[] a, int[] b) throws Exception {
        for (int i = 0; i < a.length; i++) {
            b[i] = Integer.parseInt(a[i]);
        }
    }


    static double findRoots(int a, int b, int c) {
        // If a is 0, then equation is not
        //quadratic, but linear


        int d = b * b - 4 * a * c;
        double sqrt_val = Math.sqrt(Math.abs(d));


        // System.out.println(""Roots are real and different \n"");

        return Math.max((double) (-b + sqrt_val) / (2 * a),
                (double) (-b - sqrt_val) / (2 * a));


    }

    public static String cin() throws Exception {
        return br.readLine();
    }

    public static String[] cinA() throws Exception {
        return br.readLine().split("" "");
    }

    public static String[] cinA(int x) throws Exception {
        return br.readLine().split("""");
    }

    public static String ToString(Long x) {
        return Long.toBinaryString(x);
    }

    public static void cout(String s) {
        System.out.println(s);
    }

    public static Integer cinI() throws Exception {
        return Integer.parseInt(br.readLine());
    }

    public static int getI(String s) throws Exception {
        return Integer.parseInt(s);
    }

    public static long getL(String s) throws Exception {
        return Long.parseLong(s);
    }

    public static long max(long a, long b) {
        return Math.max(a, b);
    }

    public static int max(int a, int b) {
        return Math.max(a, b);
    }

    public static void coutI(int x) {
        System.out.println(String.valueOf(x));
    }

    public static void coutI(long x) {
        System.out.println(String.valueOf(x));
    }

    public static Long cinL() throws Exception {
        return Long.parseLong(br.readLine());
    }

    public static void arrInit(String[] arr, int[] arr1) throws Exception {
        for (int i = 0; i < arr.length; i++) {
            arr1[i] = getI(arr[i]);
        }

    }
}",0276_D,CODEFORCES,804,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;
import java.util.*;
import java.io.*;
import java.math.*;
import java.awt.geom.Line2D;
import java.awt.Point;
import static java.lang.reflect.Array.*;

public class LittleElephantAndProblem {

    boolean DEBUG = true;
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    StringBuilder out = new StringBuilder();
    StringTokenizer st = null;

    String s() throws IOException {
        if (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(in.readLine());
        }
        return st.nextToken();
    }

    int i() throws IOException {
        return Integer.parseInt(s());
    }

    int i(String s) throws IOException {
        return Integer.parseInt(s);
    }

    long l() throws IOException {
        return Long.parseLong(s());
    }

    long l(String s) throws IOException {
        return Long.parseLong(s);
    }

    double d() throws IOException {
        return Double.parseDouble(s());
    }

    double d(String s) throws IOException {
        return Double.parseDouble(s);
    }

    void D(Object a) {
        if (DEBUG) {
            int len = getLength(a);
            for (int i = 0; i < len; ++i) {
                System.out.print(get(a, i) + "" "");
            }
            System.out.println();
        }
    }

    void D(Object[] a) {
        if (DEBUG) {
            int R = getLength(a), C = getLength(get(a, 0));
            for (int i = 0; i < R; ++i) {
                for (int j = 0; j < C; ++j) {
                    System.out.print(get(get(a, i), j) + "" "");
                }
                System.out.println();
            }
        }
    }

    void D(String args) {
        if (DEBUG) {
            System.out.print(args);
        }
    }

    void D(String format, Object... args) {
        if (DEBUG) {
            System.out.printf(format, args);
        }
    }

    void fl() {
        System.out.print(out);
    }
    int n = i();

    public LittleElephantAndProblem() throws IOException {
        List<Integer> a = new ArrayList<Integer>();
        List<Integer> b = new ArrayList<Integer>();
        for (int i = 0; i < n; ++i) {
            int x = i();
            a.add(x);
            b.add(x);
        }
        sort(b);
        int d = 0;
        for (int i = 0; i < n; ++i) {
            if ((int)a.get(i) != (int)b.get(i)) {
                ++d;
            }
        }
        if (d > 2) {
            out.append(""NO\n"");
        } else {
            out.append(""YES\n"");
        }
        fl();
    }

    public static void main(String[] args) throws IOException {
        new LittleElephantAndProblem();
    }
}",0220_A,CODEFORCES,2602,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"
import java.util.Arrays;
import java.util.Scanner;

public class C {
    static boolean[][] matrix;
    static long[][] dp;
    static int n;
    static int m;
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        n = s.nextInt();
        m = s.nextInt();
        matrix = new boolean[n][n];
        for (int i=0; i<m; ++i) {
            int v1 = s.nextInt()-1;
            int v2 = s.nextInt()-1;
            matrix[v1][v2] = true;
            matrix[v2][v1] = true;
        }
        dp = new long[n][1<<n+1];
        for (int i=0; i<n; ++i) Arrays.fill(dp[i], -1);
        
        long res = 0;
        for (int i=0; i<n; ++i)
            res += calc(i, i, (1<<i), 1);
        
        System.out.println(res/2);
    }
    
    public static long calc(int h, int c, int m, int len) {
        if (dp[c][m] != -1)
            return dp[c][m];
        
        long ret = 0;
        if (len > 2 && matrix[c][h])
            ret = 1;
        for (int i=h+1; i<n; ++i)
            if ((m & (1<<i)) == 0 && matrix[c][i])
                ret += calc(h, i, m | (1<<i), len + 1);
        return dp[c][m] = ret;
    }
}",0011_D,CODEFORCES,4441,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class A {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner scan = new Scanner(System.in);
		int a = scan.nextInt();
		Queue<Integer> q = new LinkedList<Integer>();
		q.add(4);
		q.add(7);
		boolean luck = false;
		while(!q.isEmpty() && !luck)
		{
			int f = q.poll();
			if(a%f == 0)
			{
				luck = true;
				break;
			}
			if(f<a)
			{
				int t = (f+"""").length();
				int tt = (int)Math.pow(10, t);
				q.add(tt*4+f);
				q.add(tt*7+f);
			}
		}
		if(luck)
			System.out.println(""YES"");
		else
			System.out.println(""NO"");
		
	}

}
",0122_A,CODEFORCES,130,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory",1
"import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Random;
import java.util.TreeSet;

public final class CF_599_D1_C
{


	static boolean verb=true;
	static void log(Object X){if (verb) System.err.println(X);}
	static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+"" "");System.err.println("""");}}
	static void log(long[] X){if (verb) {for (long U:X) System.err.print(U+"" "");System.err.println("""");}}

	static void logWln(Object X){if (verb) System.err.print(X);}
	static void info(Object o){	System.out.println(o);}
	static void output(Object o){outputWln(""""+o+""\n"");	}
	static void outputWln(Object o){try {out.write(""""+ o);} catch (Exception e) {}}

	static long mod=1000000007;

	// Global vars
	static BufferedWriter out;
	static InputReader reader;


	static class Composite implements Comparable<Composite>{
		int idx;
		int v;

		public int compareTo(Composite X) {
			if (v!=X.v)
				return v-X.v;
			return idx-X.idx;


		}

		public Composite(int idx, int v) {
			this.idx = idx;
			this.v = v;
		}



	}

	static void test() {
		log(""testing"");

		log(""done"");

	}

	static void explore(ArrayList<Integer>[] components,ArrayList<Integer> bob,int[][] move,ArrayList<int[]>[] howto,int[][] list) {

		for (int x:bob) {
			if (components[x].size()==1) {
				int tm[]=howto[x].get(0);


				int L=howto[x].size();
				howto[x].add(tm);
				for (int i=0;i<L;i++) {
					int[] cur=howto[x].get(i);
					int[] nx=howto[x].get(i+1);
					int a=cur[0];
					int a2=nx[0];
					int b2=nx[1];
					move[a2][0]=list[a2][b2];
					move[a2][1]=a;
				}

			} else {
				explore(components,components[x],move,howto,list);
			}
		}
	}


	static void process() throws Exception {


		//arrayTest();

		out = new BufferedWriter(new OutputStreamWriter(System.out));
		reader = new InputReader(System.in);


		int k=reader.readInt();
		int[][] list=new int[k][];
		long[] sum=new long[k];
		int[] L=new int[k];
		HashMap<Integer,int[]> target=new HashMap<Integer,int[]>();
		long tot=0;
		for (int i=0;i<k;i++) {
			L[i]=reader.readInt();
			list[i]=new int[L[i]];
			for (int j=0;j<L[i];j++) {
				list[i][j]=reader.readInt();
				sum[i]+=list[i][j];
				target.put(list[i][j],new int[] {i,j});
			}
			tot+=sum[i];
		}

		int MX=1<<k;
		int AX=1000000001;
		ArrayList<int[]>[] howto=new ArrayList[MX];

		log(""ok with the data"");

		if (tot%k!=0) {
			output(""No"");
		} else {

			tot/=k;





			for (int i=0;i<k;i++) {

				if (sum[i]==tot) {
					//log(""nothing to do for i:""+i);
					// nothing to do
					int mask=1<<i;
					ArrayList<int[]> cand=new ArrayList<int[]>();
					cand.add(new int[] {i,0});
					howto[mask]=cand;
				} else 


					for (int j=0;j<L[i];j++) {
						int u=i;
						int v=j;
						boolean ok=true;
						int src_u=u;
						int src_v=v;
						int mask=0;
						boolean goon=true;
						ArrayList<int[]> cand=new ArrayList<int[]>();
						//log(""start loop"");
						while (goon) {
							cand.add(new int[] {u,v});
							//log(""u:""+u+"" v:""+v);
							ok=false;
							goon=false;
							long need=tot-((long)sum[u]-(long)list[u][v]);
							if (Math.abs(need)<=AX) {
								//log(""need:""+need);
								int nd=(int)need;
								int[] tm=target.get(nd);
								//log(""tm:""+tm);
								if (tm!=null) {
									//log(""can find successor"");
									int nxu=tm[0];
									int nxv=tm[1];
									if ((mask&(1<<nxu))==0) {
										mask|=1<<nxu;
										if (nxu==src_u) {
											// looping back to source
											if (nxv==src_v)
												ok=true;
										} else {
											u=nxu;
											v=nxv;
											ok=true;
											goon=true;
										}
									} 
								}
							}
						}
						if (ok) {
							if (howto[mask]==null) {

								howto[mask]=cand;

							}
						}
					}
			}

			log(""step 1 done"");

			// now mask

		
			ArrayList[] components=new ArrayList[MX];

			for (int m=0;m<MX;m++) {
				if (howto[m]!=null) {
					//String s=Integer.toBinaryString(m);
					//while (s.length()<k)
					//	s=""0""+s;
					//log(""found mask:""+s);
					components[m]=new ArrayList<Integer>();
					components[m].add(m);
				}
			}



	
			int[] msk=new int[MX];
			int w=0;
			
			for (int a=0;a<MX;a++) {
				if (howto[a]!=null) {
					ArrayList<Integer> add=new ArrayList<Integer>();
					
					int ww=w;
					for (int i=0;i<ww;i++) {
						int b=msk[i];
						if ((b&a)==0) {

							int c=b|a;
							log(""creating c:""+c+"" "");
							if (components[c]==null ) {
								components[c]=new ArrayList<Integer>();
								components[c].add(a);
								components[c].add(b);
								msk[w++]=c;
							}
						}
					}
					msk[w++]=a;
				}
			}
			//log(""msk:""+msk);
			//log(components[MX-1]);
			if (components[MX-1]!=null) {
				output(""Yes"");
				int[][] move=new int[k][2];
				explore(components,components[MX-1],move,howto,list);
				for (int i=0;i<k;i++) {
					output(move[i][0]+"" ""+(move[i][1]+1));
				}

			} else {
				output(""No"");
			}

		}


		try {
			out.close();
		} catch (Exception e) {
		}

	}





	public static void main(String[] args) throws Exception {
		process();

	}

	static final class InputReader {
		private final InputStream stream;
		private final byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		private int read() throws IOException {
			if (curChar >= numChars) {
				curChar = 0;
				numChars = stream.read(buf);
				if (numChars <= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}

		public final String readString() throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res = new StringBuilder();
			do {
				res.append((char) c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final int readInt() throws IOException {
			int c = read();
			boolean neg = false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d = (char) c;
			// log(""d:""+d);
			if (d == '-') {
				neg = true;
				c = read();
			}
			int res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			// log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		public final long readLong() throws IOException {
			int c = read();
			boolean neg = false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d = (char) c;
			// log(""d:""+d);
			if (d == '-') {
				neg = true;
				c = read();
			}
			long res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			// log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		private boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}
	}

}",1242_C,CODEFORCES,4869,Sum Balance,"Ujan has a lot of numbers in his boxes. He likes order and balance, so he decided to reorder the numbers.
There are $$$k$$$ boxes numbered from $$$1$$$ to $$$k$$$. The $$$i$$$-th box contains $$$n_i$$$ integer numbers. The integers can be negative. All of the integers are distinct. 
Ujan is lazy, so he will do the following reordering of the numbers exactly once. He will pick a single integer from each of the boxes, $$$k$$$ integers in total. Then he will insert the chosen numbers — one integer in each of the boxes, so that the number of integers in each box is the same as in the beginning. Note that he may also insert an integer he picked from a box back into the same box.
Ujan will be happy if the sum of the integers in each box is the same. Can he achieve this and make the boxes perfectly balanced, like all things should be?
The first line contains a single integer $$$k$$$ ($$$1 \leq k \leq 15$$$), the number of boxes. 
The $$$i$$$-th of the next $$$k$$$ lines first contains a single integer $$$n_i$$$ ($$$1 \leq n_i \leq 5\,000$$$), the number of integers in box $$$i$$$. Then the same line contains $$$n_i$$$ integers $$$a_{i,1}, \ldots, a_{i,n_i}$$$ ($$$|a_{i,j}| \leq 10^9$$$), the integers in the $$$i$$$-th box. 
It is guaranteed that all $$$a_{i,j}$$$ are distinct.
If Ujan cannot achieve his goal, output ""No"" in a single line. Otherwise in the first line output ""Yes"", and then output $$$k$$$ lines. The $$$i$$$-th of these lines should contain two integers $$$c_i$$$ and $$$p_i$$$. This means that Ujan should pick the integer $$$c_i$$$ from the $$$i$$$-th box and place it in the $$$p_i$$$-th box afterwards.
If there are multiple solutions, output any of those.
You can print each letter in any case (upper or lower).
In the first sample, Ujan can put the number $$$7$$$ in the $$$2$$$nd box, the number $$$2$$$ in the $$$3$$$rd box, the number $$$5$$$ in the $$$1$$$st box and keep the number $$$10$$$ in the same $$$4$$$th box. Then the boxes will contain numbers $$$\{1,5,4\}$$$, $$$\{3, 7\}$$$, $$$\{8,2\}$$$ and $$$\{10\}$$$. The sum in each box then is equal to $$$10$$$.
","input
In the second sample, it is not possible to pick and redistribute the numbers in the required way.
output
In the third sample, one can swap the numbers $$$-20$$$ and $$$-10$$$, making the sum in each box equal to $$$-10$$$.
","bitmasks, dfsandsimilar, dp, graphs",7
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;
import java.util.HashMap;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Rene
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            int n = in.nextInt();
            String s = in.next();
            HashMap<Character, Integer> indexMap = new HashMap<>();
            for (int i = 0; i < n; i++) {
                char c = s.charAt(i);
                if (!indexMap.containsKey(c)) {
                    indexMap.put(c, indexMap.size());
                }
            }
            int[] last = new int[indexMap.size()];
            Arrays.fill(last, -1_000_000);
            int answer = n;
            for (int i = 0; i < n; i++) {
                int index = indexMap.get(s.charAt(i));
                last[index] = i;
                int first = i;
                for (int a : last) first = Math.min(first, a);
                int visits = i - first + 1;
                answer = Math.min(answer, visits);
            }
            out.println(answer);
        }

    }
}

",0701_C,CODEFORCES,1815,They Are Everywhere,"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.
There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 
Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. 
The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.
The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. 
Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. 
In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.
","input
In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 
output
In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.
","binarysearch, strings, twopointers",3
"//package Current;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class test {
    static final long mod = (long) 1e9 + 7;

    static class pair {
        int x, y;

        public pair(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader(File input) throws FileNotFoundException {
            br = new BufferedReader(new FileReader(input));
        }

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

    public static void main(String args[]) throws FileNotFoundException {

        FastReader sc;

        if (System.getProperty(""ONLINE_JUDGE"") == null) {
            File input = new File(""./input.txt"");
            sc = new FastReader(input);
        } else {
            sc = new FastReader();
        }

        int t = 1;
        // t = sc.nextInt();
        while (t-- > 0) {
            // Start code

            int n = sc.nextInt();
            int m = sc.nextInt();
            int k = sc.nextInt();

            if (k % 2 == 1) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < m; j++)
                        print(-1);
                    println("""");

                }
                break;
            }

            int side[][] = new int[n][m];
            int down[][] = new int[n][m];

            int dp[][][] = new int[n][m][k + 1];

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m - 1; j++)
                    side[i][j] = sc.nextInt();
            }

            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < m; j++)
                    down[i][j] = sc.nextInt();
            }

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    int p, q, r, s;
                    p = q = r = s = Integer.MAX_VALUE;

                    if (j != 0)
                        p = 2 * side[i][j - 1];

                    if (j != m - 1)
                        q = 2 * side[i][j];

                    if (i != 0)
                        r = 2 * down[i - 1][j];

                    if (i != n - 1)
                        s = 2 * down[i][j];

                    dp[i][j][2] = Math.min(Math.min(p, q), Math.min(r, s));

                }
            }

            for (int i = 4; i <= k; i += 2) {
                for (int j = 0; j < n; j++) {
                    for (int l = 0; l < m; l++) {
                        dp[j][l][i] = Integer.MAX_VALUE;

                        if (l != 0)
                            dp[j][l][i] = Math.min(dp[j][l][i], 2 * side[j][l - 1] + dp[j][l - 1][i - 2]);

                        if (l != m - 1)
                            dp[j][l][i] = Math.min(dp[j][l][i], 2 * side[j][l] + dp[j][l + 1][i - 2]);

                        if (j != 0)
                            dp[j][l][i] = Math.min(dp[j][l][i], 2 * down[j - 1][l] + dp[j - 1][l][i - 2]);

                        if (j != n - 1)
                            dp[j][l][i] = Math.min(dp[j][l][i], 2 * down[j][l] + dp[j + 1][l][i - 2]);
                    }
                }
            }

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    print(dp[i][j][k]);
                }
                println("""");
            }
        }
    }

    static void print(Object o) {
        System.out.print(o + "" "");
    }

    static void println(Object o) {
        System.out.println(o);
    }

    static long gcd(long x, long y) {
        if (y == 0)
            return x;
        return gcd(y, x % y);
    }

    static int log2(long num) {
        return (int) (Math.log(num) / Math.log(2));
    }

    static void swap(int arr[], int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    static ArrayList<Long> factorial(int num) {
        ArrayList<Long> fac = new ArrayList<>();
        fac.add((long) 0);
        fac.add((long) 1);

        for (int i = 2; i < num; i++) {
            fac.add((fac.get(i - 1) * i) % mod);
        }

        return fac;
    }

    static long ncr(long x, long y, ArrayList<Long> fac) {
        if (y >= x)
            return (long) 1;

        long res = fac.get((int) x);
        long z = (fac.get((int) y) * fac.get((int) (x - y))) % mod;
        z = modInv(z);
        res = (res * z) % mod;
        return res;
    }

    static long modInv(long x) {
        return modExpo(x, mod - 2);
    }

    static long modExpo(long x, long y) {
        long res = 1;
        x = x % mod;
        while (y > 0) {
            if (y % 2 == 1)
                res = (res * x) % mod;
            y = y / 2;
            x = (x * x) % mod;
        }
        return res;
    }

    static int lowerBound(int n, long[] arr, long value) {
        int res = (int) 1e7;
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (arr[mid] >= value) {
                res = mid;
                r = mid - 1;
            } else
                l = mid + 1;
        }
        return res;
    }
}
",1517_D,CODEFORCES,4244,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskC solver = new TaskC();
		solver.solve(1, in, out);
		out.close();
	}

	static class TaskC {
		public void solve(int testNumber, InputReader in, PrintWriter out) {
			int n = in.nextInt();
			int r = in.nextInt();
			int[] x = new int[n];
			for (int i = 0; i < n; i++) {
				x[i] = in.nextInt();
			}
			double res = 0;
			double[] y = new double[n];

			for (int i = 0; i < n; i++) {
				double curY = r;
				for (int j = 0; j < i; j++) {
					int d = Math.abs(x[i] - x[j]);
					if (d <= 2 * r) {
						int a2 = 4 * r * r - d * d;
						curY = Math.max(curY, y[j] + Math.sqrt(a2));
					}
				}
				y[i] = curY;
				out.printf(""%.14f"", y[i]);
				if (i < n - 1) {
					out.print("" "");
				} else {
					out.println();
				}
			}
		}

	}

	static class InputReader {
		final InputStream is;
		final byte[] buf = new byte[1024];
		int pos;
		int size;

		public InputReader(InputStream is) {
			this.is = is;
		}

		public int nextInt() {
			int c = read();
			while (isWhitespace(c))
				c = read();
			int sign = 1;
			if (c == '-') {
				sign = -1;
				c = read();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = read();
			} while (!isWhitespace(c));
			return res * sign;
		}

		int read() {
			if (size == -1)
				throw new InputMismatchException();
			if (pos >= size) {
				pos = 0;
				try {
					size = is.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (size <= 0)
					return -1;
			}
			return buf[pos++] & 255;
		}

		static boolean isWhitespace(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

	}
}

",0908_C,CODEFORCES,2994,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class A{
	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	int mod=(int)1e9+9;

	long n, m, k;

	void run(){
		n=sc.nextLong();
		m=sc.nextLong();
		k=sc.nextLong();
		solve();
	}

	void solve(){
		long ans=0;
		long s=n-m;
		long remain=max(n-s*k, 0);
//		debug(""remain"", remain);
		ans=m-remain;
//		debug(""ans"", ans);
		long r=remain%k;
		ans=(ans+r)%mod;
		remain-=r;
//		debug(""remain2"", remain);
		long a=remain/k;
		long add=(powMod(2, a, mod)-1)*k%mod*2%mod;
//		debug(""add"", add);
		ans=(ans+add)%mod;
//		debug(ans);
		println(ans+"""");
	}

	long powMod(long x, long k, long mod){
		if(k==0){
			return 1%mod;
		}else if(k%2==0){
			return powMod(x*x%mod, k/2, mod);
		}else{
			return x*powMod(x, k-1, mod)%mod;
		}
	}

	void println(String s){
		System.out.println(s);
	}

	void print(String s){
		System.out.print(s);
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	public static void main(String[] args){
		Locale.setDefault(Locale.US);
		new A().run();
	}
}
",0338_A,CODEFORCES,1013,Quiz,"Manao is taking part in a quiz. The quiz consists of n consecutive questions. A correct answer gives one point to the player. The game also has a counter of consecutive correct answers. When the player answers a question correctly, the number on this counter increases by 1. If the player answers a question incorrectly, the counter is reset, that is, the number on it reduces to 0. If after an answer the counter reaches the number k, then it is reset, and the player's score is doubled. Note that in this case, first 1 point is added to the player's score, and then the total score is doubled. At the beginning of the game, both the player's score and the counter of consecutive correct answers are set to zero.
Manao remembers that he has answered exactly m questions correctly. But he does not remember the order in which the questions came. He's trying to figure out what his minimum score may be. Help him and compute the remainder of the corresponding number after division by 1000000009 (109 + 9).
The single line contains three space-separated integers n, m and k (2 ≤ k ≤ n ≤ 109; 0 ≤ m ≤ n).
Print a single integer — the remainder from division of Manao's minimum possible score in the quiz by 1000000009 (109 + 9).
Sample 1. Manao answered 3 questions out of 5, and his score would double for each two consecutive correct answers. If Manao had answered the first, third and fifth questions, he would have scored as much as 3 points.
","input
Sample 2. Now Manao answered 4 questions. The minimum possible score is obtained when the only wrong answer is to the question 4.
output
Also note that you are asked to minimize the score and not the remainder of the score modulo 1000000009. For example, if Manao could obtain either 2000000000 or 2000000020 points, the answer is 2000000000 mod 1000000009, even though 2000000020 mod 1000000009 is a smaller number.
","greedy, math, numbertheory",2
"import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class A
{
    public A()
    {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Integer mas[] = new Integer[n];
        int b = 0;
        for (int i = 0 ; i < n ; i ++)
        {
            mas[i] = sc.nextInt();
            b+=mas[i];
        }
        Arrays.sort(mas, new Comparator<Integer>()
        {

            @Override
            public int compare(Integer o1, Integer o2)
            {
                if(o1>o2)
                    return -1;
                else if(o1==o2)
                    return  0;
                else 
                    return 1;
            }      
        });
        int N = 0; int g = 0;
        for (int i = 0 ; i < n ; i ++)
        {
              g+=mas[i];
              if(g>(int)(b/2))
              {
                  System.out.println(i+1);
                  return;
              }
        }
        System.out.println(n);
    }
    public static void main(String[] args)
    {
        new A();      
    }
}
",0160_A,CODEFORCES,2444,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"import java.io.*;
import java.util.*;
import static java.lang.Math.*;

public class Solution {

    BufferedReader in;
    PrintWriter out;
    StringTokenizer st;

    static class Pair implements Comparable<Pair> {
        int x, a;

        Pair(int x, int a) {
            this.x = x;
            this.a = a;
        }

        @Override
        public int compareTo(Pair o) {
            // TODO Auto-generated method stub
            return 0;
        }
    }

    boolean isCross(double l1, double r1, double l2, double r2) {
        double r = min(r1, r2);
        double l = max(l1, l2);
        return r > l;
    }

    boolean check(double xl, double xr, double[] l, double[] r, int n) {
        boolean ok = false;
        for (int j = 0; j < n; ++j)
            ok |= isCross(xl, xr, l[j], r[j]);
        return ok;
    }

    void solve() throws IOException {
        int n = ni();
        double t = ni();
        double[] l = new double[n];
        double[] r = new double[n];
        for (int i = 0; i < l.length; i++) {
            double x = ni();
            double len = ni();
            l[i] = x - len / 2.0;
            r[i] = x + len / 2.0;
        }
        HashSet<Double> set = new HashSet<Double>();
        for (int i = 0; i < n; ++i) {
            double xl = l[i] - t;
            double xr = l[i];
            boolean ok = check(xl, xr, l, r, n);
            if (!ok)
                set.add(xl);
            xl = r[i];
            xr = r[i] + t;
            ok = check(xl, xr, l, r, n);
            if (!ok)
                set.add(xl);

        }
        out.println(set.size());
    }

    public Solution() throws IOException {
        Locale.setDefault(Locale.US);
        in = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);
        solve();
        in.close();
        out.close();
    }

    String ns() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(in.readLine());
        }
        return st.nextToken();
    }

    int ni() throws IOException {
        return Integer.valueOf(ns());
    }

    long nl() throws IOException {
        return Long.valueOf(ns());
    }

    double nd() throws IOException {
        return Double.valueOf(ns());
    }

    public static void main(String[] args) throws IOException {
        new Solution();
    }
}
",0015_A,CODEFORCES,2266,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"import java.io.*;
import java.util.*;

public class Main implements Runnable {

	public void _main() throws IOException {
		String s = next();
		for (int len = s.length(); len >= 1; len--) {
			for (int i = 0; i + len <= s.length(); i++)
				for (int j = i + 1; j + len <= s.length(); j++)
					if (s.substring(i, i + len).equals(s.substring(j, j + len))) {
						out.print(len);
						return;
					}
		}
		out.print(0);
	}

	private BufferedReader in;
	private PrintWriter out;
	private StringTokenizer st;

	private String next() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			String rl = in.readLine();
			if (rl == null)
				return null;
			st = new StringTokenizer(rl);
		}
		return st.nextToken();
	}

	private int nextInt() throws IOException {
		return Integer.parseInt(next());
	}

	private long nextLong() throws IOException {
		return Long.parseLong(next());
	}

	private double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}

	public static void main(String[] args) {
		new Thread(new Main()).start();
	}

	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);

			_main();

			out.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(202);
		}
	}

}
",0023_A,CODEFORCES,3703,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.util.HashMap;
import java.util.Scanner;

public class Solution {
    public static void main(String [] args){
        Scanner in = new Scanner(System.in);

        String ins = in.nextLine();
        HashMap <String,Integer> sub = new HashMap<String,Integer>();
        for (int i=0;i<ins.length();i++){
            for (int j=i+1;j<=ins.length();j++){
                String key = ins.substring(i,j);
                if (sub.containsKey(key)){
                    sub.put(key,sub.get(key)+1);
                } else {
                    sub.put(key,1);
                }
            }
        }

        int max = 0;
        for (String key:sub.keySet()){
            if (sub.get(key) >= 2 && key.length() > max){
                max = key.length();
            }
        }

        System.out.print(max);
    }
}
",0023_A,CODEFORCES,3787,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.*;
import java.util.*;

public class A
{
	String line;
	StringTokenizer inputParser;
	BufferedReader is;
	FileInputStream fstream;
	DataInputStream in;
	String FInput="""";
	
	void openInput(String file)
	{

		if(file==null)is = new BufferedReader(new InputStreamReader(System.in));//stdin
		else
		{
			try{
		
				
			fstream = new FileInputStream(file);
			in = new DataInputStream(fstream);
			is = new BufferedReader(new InputStreamReader(in));
			}catch(Exception e)
			{
				System.err.println(e);
			}
		}

	}
	
	void readNextLine()
	{
		try {
			line = is.readLine();
			inputParser = new StringTokenizer(line, "" "");
			//System.err.println(""Input: "" + line);
		} catch (IOException e) {
			System.err.println(""Unexpected IO ERROR: "" + e);
		}	
		catch (NullPointerException e)
		{
			line=null;
			
		}
		
	}
	
	int NextInt()
	{
		String n = inputParser.nextToken();
		int val = Integer.parseInt(n);
		
		//System.out.println(""I read this number: "" + val);
		return val;
	}
	
	long NextLong()
	{
		String n = inputParser.nextToken();
		long val = Long.parseLong(n);
		
		//System.out.println(""I read this number: "" + val);
		return val;
	}
	
	String NextString()
	{
		String n = inputParser.nextToken();
		return n;
	}
	
	void closeInput()
	{
		try {
			is.close();
		} catch (IOException e) {
			System.err.println(""Unexpected IO ERROR: "" + e);
		}
			
	}
	
	
	public static void main(String [] argv)
	{
		String filePath=null;
		if(argv.length>0)filePath=argv[0];
		new A(filePath);
	}
	
	public void readFInput()
	{
		for(;;)
		{
			try
			{
				readNextLine();
				FInput+=line+"" "";
			}
			catch(Exception e)
			{
				break;
			}
		}
		inputParser = new StringTokenizer(FInput, "" "");
	}
	 
	public A(String inputFile)
	{
		openInput(inputFile);
		
		readNextLine();
		int n=NextInt();
		
		int ret=0;
		int [] p = new int [n];
		readNextLine();
		int sum=0;
		for(int i=0; i<n; i++)
		{
			int a=NextInt();
			p[i]=a;
			sum+=a;
		}
		Arrays.sort(p);

		int my=0;
	
		for(int i=n-1; i>=0; i--)
		{
			my+=p[i];
			ret++;
			if(my*2>sum)break;
		}
		
		System.out.println(ret);
        closeInput();		
	}

}
",0160_A,CODEFORCES,2446,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"import java.io.*;
import java.util.*;

public class r584p5 {
    private static BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
    private static PrintWriter pw = new PrintWriter(System.out);
    private static int n, m, arr[][];
    private static ArrayList<HashSet<Integer>> chls;

    private static void gench(){
        chls.add(new HashSet<>());
        chls.get(0).add(0);

        for(int i=1; i<(1<<n); i++){
            int des = i^Integer.highestOneBit(i);
            HashSet<Integer> st = new HashSet<>();
            for(int z : chls.get(des)){
                st.add(z);
                st.add(z|Integer.highestOneBit(i));
            }
            chls.add(st);
        }
    }

    private static void cal(){
        int val[][] = new int[(1<<n)][m];

        for(int j=0; j<m; j++){
            val[0][j] = 0;
            for(int mask=1; mask<(1<<n); mask++){
                int max = 0;
                for(int begin=0; begin<n; begin++){
                    int sum = 0;
                    for(int ptr=begin, pos=0; pos<n; ptr=(ptr+1)%n, pos++){
                        if((mask&(1<<pos)) > 0)
                            sum += arr[ptr][j];
                    }
                    max = Math.max(max, sum);
                }
                val[mask][j] = max;
            }
        }

        int dp[][] = new int[(1<<n)][m];

        for(int mask=0; mask<(1<<n); mask++)
            dp[mask][0] = val[mask][0];

        for(int j=1; j<m; j++){
            dp[0][j] = 0;
            for(int mask=1; mask<(1<<n); mask++){

                dp[mask][j] = 0;
                for(int ch1 : chls.get(mask)){
                    int ch2 = mask^ch1;

                    dp[mask][j] = Math.max(dp[mask][j], val[ch1][j]+dp[ch2][j-1]);
                }
            }
        }

        pw.println(dp[(1<<n)-1][m-1]);
    }

    private static void run()throws IOException{
        StringTokenizer tk = new StringTokenizer(r.readLine());
        n = Integer.parseInt(tk.nextToken());
        m = Integer.parseInt(tk.nextToken());
        arr = new int[n][m];
        chls = new ArrayList<>();

        for(int i=0; i<n; i++){
            tk = new StringTokenizer(r.readLine());
            for(int j=0; j<m; j++)
                arr[i][j] = Integer.parseInt(tk.nextToken());
        }

        gench();
        cal();
    }

    public static void main(String args[])throws IOException{
        int t = Integer.parseInt(r.readLine());

        while(t-->0)
            run();

        pw.flush();
        pw.close();
    }
}",1209_E1,CODEFORCES,4787,Rotate Columns (easy version),"This is an easier version of the next problem. The difference is only in constraints.
You are given a rectangular $$$n \times m$$$ matrix $$$a$$$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want (possibly zero). You can perform this operation to a column multiple times.
After you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $$$i$$$-th row it is equal $$$r_i$$$. What is the maximal possible value of $$$r_1+r_2+\ldots+r_n$$$?
The first line contains an integer $$$t$$$ ($$$1 \le t \le 40$$$), the number of test cases in the input.
The first line of each test case contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 4$$$, $$$1 \le m \le 100$$$) — the number of rows and the number of columns in the given matrix $$$a$$$. 
Each of the following $$$n$$$ lines contains $$$m$$$ integers, the elements of $$$a$$$ ($$$1 \le a_{i, j} \le 10^5$$$).
Print $$$t$$$ integers: answers for all test cases in the order they are given in the input.
","input
In the first test case, you can shift the third column down by one, this way there will be $$$r_1 = 5$$$ and $$$r_2 = 7$$$.
output
In the second case you can don't rotate anything at all, this way there will be $$$r_1 = r_2 = 10$$$ and $$$r_3 = 9$$$.
","bitmasks, bruteforce, dp, greedy, sortings",7
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;

public class Round111A {

    public static void main(String[] args) throws IOException {
        new Round111A().run();
    }

    public void run() throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        Scanner scanner = new Scanner(reader);
        PrintWriter writer = new PrintWriter(System.out);

        int n = scanner.nextInt();
        int sum = 0;
        Integer[] a = new Integer[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
            sum += a[i];
        }
        Arrays.sort(a, Collections.reverseOrder());

        int s = 0;
        int i = 0;
        while (i < n && (s <= sum / 2)) {
            s += a[i];
            i++;
        }

        writer.print(i);

        scanner.close();
        writer.close();
    }
}
",0160_A,CODEFORCES,2469,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"import java.io.*;
import java.util.*;

public class C125 {
	public static void main(String[] args) throws IOException {
		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		String s = r.readLine();
		int n = new Integer(s);
		System.out.println(""0 0 ""+n);
	}
}
",0199_A,CODEFORCES,189,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"import java.io.BufferedReader;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.IOException;

import java.io.PrintWriter;

import java.util.Arrays;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;





public class Main {

	static int n, m, k;

	static int inf = (int) 1e9;

	static class Pair {

		int x, y;

		Pair(int a, int b) {

			x = a; y = b;

		}

	}

	static int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};

	static boolean valid(int x, int y) {

		return x >= 0 && x < n && y >= 0 && y < m;

	}

	static int[][] bfs(int[] xs, int[] ys) {

		int[][] dist = new int[n][m];

		for(int i = 0; i < n; i++)

			Arrays.fill(dist[i], inf);

		Queue<Pair> q = new LinkedList<>();

		for(int i = 0; i < k; i++) {

			dist[xs[i]][ys[i]] = 0;

			q.add(new Pair(xs[i], ys[i]));

		}



		while(!q.isEmpty()) {

			Pair p = q.remove();

			for(int d = 0; d < 4; d++) {

				int nx = p.x + dx[d], ny = p.y + dy[d];

				if(valid(nx, ny) && dist[nx][ny] == inf) {

					dist[nx][ny] = dist[p.x][p.y] + 1;

					q.add(new Pair(nx, ny));

				}

			}

		}



		return dist;

	}



	public static void main(String[] args) throws IOException {

		Scanner in = new Scanner();

		int n = in.nextInt() ; 

		int m = in.nextInt(); 

		int k = in.nextInt(); 

		int x[] = new int[k] ; 

		int y[] = new int[k] ; 

		int trees [][] = new int [n][m] ;





		for (int i = 0; i < n; i++)

			for (int j = 0; j < m; j++)

				trees[i][j]=Integer.MAX_VALUE ;



		for (int i = 0; i < k; i++)

		{

			x[i]=in.nextInt()-1; 

			y[i]=in.nextInt()-1;

			trees[x[i]][y[i]]=0 ;

		}



		int dis = Integer.MIN_VALUE ; ;

		int xp=0; ;

		int yp=0;

		for (int i = 0; i < n; i++)

			for (int j = 0; j < m; j++)

				if(trees[i][j] != 0)

					for (int j2 = 0; j2 < k; j2++)

						trees[i][j]=Math.min(trees[i][j], Math.abs(i-x[j2])+Math.abs(j-y[j2]));



		for (int i = 0; i <n; i++)

			for (int j = 0; j < m; j++)

				if(trees[i][j] > dis)

				{

					dis=trees[i][j];

					xp=i+1;

					yp=j+1;

				}

		PrintWriter out = new PrintWriter(""output.txt"");

		out.printf(""%d %d\n"", xp ,yp);

		out.close();

	}



	static class Scanner {

		BufferedReader br;

		StringTokenizer st;

		Scanner() throws FileNotFoundException {

			br = new BufferedReader(new FileReader(""input.txt""));

		}



		String next() throws IOException {

			while(st == null || !st.hasMoreTokens())

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		int nextInt() throws IOException {

			return Integer.parseInt(next());

		}

	}

}",0035_C,CODEFORCES,3903,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"import java.util.*;
import org.omg.CORBA.INTERNAL;

import java.awt.List;
import java.io.*;
import java.lang.*;
import java.lang.reflect.Array;
	
public class code1
	{
	
		public static long[][] cnt;
		public static void main(String[] args)
		{
			InputReader in = new InputReader(System.in);
			PrintWriter pw = new PrintWriter(System.out);
			
			//Code starts..
		
			
			
			
			
			
			int n = in.nextInt();
			long d = in.nextInt();
			long[] a = new long[n];
			for(int i=0; i<n; i++)
				a[i] = in.nextLong();
			
			
			int ans = 0;
			//ans++;
			HashSet<Long> set = new HashSet<>();
			/*set.add(a[0]-d);
			if(Math.abs(a[0]+d-a[1])>=d)
			{
				ans++;
				set.add(a[0]+d);
			}
			
			*/
			for(int i=1; i<n; i++)
			{
				
				//pw.println(a[i]+"" ""+a[i-1]);
				
				long dis = (long) Math.abs(a[i]-a[i-1]);
				//pw.println(dis);
				if(dis==2*d)
					ans++;
				
				if(dis-(long)2*d>0)
					ans += 2;
				
				
			}
			pw.println(ans+2);
			
			
			
			
			
			
			//Code ends....
			
			pw.flush();
			pw.close();
		}
		  
		
		
		
	
		

		static class InputReader 
		{
			 
			private final InputStream stream;
			private final byte[] buf = new byte[8192];
			private int curChar, snumChars;
			private SpaceCharFilter filter;
	 
			public InputReader(InputStream stream) 
			{
				this.stream = stream;
			}
	 
			public int snext() 
			{
				if (snumChars == -1)
					throw new InputMismatchException();
				if (curChar >= snumChars) 
				{
					curChar = 0;
					try 
					{
						snumChars = stream.read(buf);
					} 
					catch (IOException e) 
					{
						throw new InputMismatchException();
					}
					if (snumChars <= 0)
						return -1;
				}
				return buf[curChar++];
			}
	 
			public int nextInt() 
		    {
				int c = snext();
				while (isSpaceChar(c)) 
				{
					c = snext();
				}
				int sgn = 1;
				if (c == '-')
			    {
					sgn = -1;
					c = snext();
				}
				int res = 0;
				do 
				{
					if (c < '0' || c > '9')
						throw new InputMismatchException();
					res *= 10;
					res += c - '0';
					c = snext();
				} while (!isSpaceChar(c));
				return res * sgn;
			}
	 
			public long nextLong()
		    {
				int c = snext();
				while (isSpaceChar(c)) 
				{
					c = snext();
				}
				int sgn = 1;
				if (c == '-') 
				{
					sgn = -1;
					c = snext();
				}
				long res = 0;
				do 
				{
					if (c < '0' || c > '9')
						throw new InputMismatchException();
					res *= 10;
					res += c - '0';
					c = snext();
				} while (!isSpaceChar(c));
				return res * sgn;
			}
	 
			public int[] nextIntArray(int n) 
			{
				int a[] = new int[n];
				for (int i = 0; i < n; i++) 
				{
					a[i] = nextInt();
				}
				return a;
			}
	 
			public String readString()
		    {
				int c = snext();
				while (isSpaceChar(c)) 
				{
					c = snext();
				}
				StringBuilder res = new StringBuilder();
				do 
				{
					res.appendCodePoint(c);
					c = snext();
				} while (!isSpaceChar(c));
				return res.toString();
			}
	 
			public String nextLine() 
			{
				int c = snext();
				while (isSpaceChar(c))
					c = snext();
				StringBuilder res = new StringBuilder();
				do 
				{
					res.appendCodePoint(c);
					c = snext();
				} while (!isEndOfLine(c));
				return res.toString();
			}
	 
			public boolean isSpaceChar(int c) 
			{
				if (filter != null)
					return filter.isSpaceChar(c);
				return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
			}
	 
			private boolean isEndOfLine(int c) 
			{
				return c == '\n' || c == '\r' || c == -1;
			}
	 
			public interface SpaceCharFilter
		    {
				public boolean isSpaceChar(int ch);
			}
		}
		public static long c = 0;
		
		public static long mod = 1000000007;
		public static int d;
		public static int p;
		public static int q;
		public static boolean flag;
		public static long INF= Long.MAX_VALUE;
		
		public static long fun(int[] a, int[] b, int m,int n) {
			long result =0;
			for(int i=0; i<m; i++)
				for(int j=0; j<m; j++)
				{
					long[] fib  = new long[Math.max(2, n+2)];
					fib[1] = a[i];
					fib[2] = b[j];
					for(int k=3; k<=n; k++)
						fib[k] = (fib[k-1]%mod + fib[k-2]%mod)%mod;
					result = (result%mod + fib[n]%mod)%mod;
				}
			
			return result;
			
		}
		
		
		public static double slope(pair p1, pair p2)
		{
			double m = INF;
			if((p1.x - p2.x)!=0)
			m =  (p1.y - p2.y)/(p1.x - p2.x); 
			
			
			return Math.abs(m);
			
		}
		
		
		public static int count(String[] s, int f)
		{
			int count = 0;
			int n = s[0].length();
			
			if(f==1)
			{
			for(int i = 0; i<n; i++)
			{
				for(int j=0; j<n; j++)
				{
					if(i%2==0)
					{
						if(j%2==0 && s[i].charAt(j)=='0')
							count++;
						if(j%2==1 && s[i].charAt(j)=='1')
							count++;
					}
					if(i%2==1)
					{
						if(j%2==1 && s[i].charAt(j)=='0')
							count++;
						if(j%2==0 && s[i].charAt(j)=='1')
							count++;
					}
					
				}
			}
			}
			else
			{
			
			 count = 0;
			
			for(int i = 0; i<n; i++)
			{
				for(int j=0; j<n; j++)
				{
					if(i%2==1)
					{
						if(j%2==0 && s[i].charAt(j)=='0')
							count++;
						if(j%2==1 && s[i].charAt(j)=='1')
							count++;
					}
					if(i%2==0)
					{
						if(j%2==1 && s[i].charAt(j)=='0')
							count++;
						if(j%2==0 && s[i].charAt(j)=='1')
							count++;
					}
					
				}
			}
 
			}	
				
		
			return count;
			
			
			
		}
				
		public static  int gcd(int p2, int p22)
		{
		    if (p2 == 0)
		        return (int) p22;
		    return gcd(p22%p2, p2);
		}
		
			
	
		
		
		public static int findGCD(int arr[], int n)
		{
		    int result = arr[0];
		    for (int i=1; i<n; i++)
		        result = gcd(arr[i], result);
		 
		    return result;
		}
		
	
 
		public static void nextGreater(long[] a, int[] ans)
		{
			
			Stack<Integer> stk = new Stack<>();
			stk.push(0);
			
			
			for(int i=1; i<a.length; i++)
			{
				
				if(!stk.isEmpty())
				{
				int s = stk.pop();
				while(a[s]<a[i])
				{
					ans[s] = i;
					if(!stk.isEmpty())
						s = stk.pop();
					else
						break;
				}
				if(a[s]>=a[i])
					stk.push(s);
				}
				
				stk.push(i);
				
			}
			return;
			
		}
		
		public static void nextGreaterRev(long[] a, int[] ans)
		{
			
			int n = a.length;
			int[] pans = new int[n];
			Arrays.fill(pans, -1);
			long[] arev = new long[n];
			for(int i=0; i<n; i++)
				arev[i] = a[n-1-i];
			
			Stack<Integer> stk = new Stack<>();
			stk.push(0);
			
			
			for(int i=1; i<n; i++)
			{
				
				if(!stk.isEmpty())
				{
				int s = stk.pop();
				while(arev[s]<arev[i])
				{
					pans[s] = n - i-1;
					if(!stk.isEmpty())
						s = stk.pop();
					else
						break;
				}
				if(arev[s]>=arev[i])
					stk.push(s);
				}
				
				stk.push(i);
				
			}
			
			//for(int i=0; i<n; i++)
				//System.out.print(pans[i]+"" "");
			
			for(int i=0; i<n; i++)
				ans[i] = pans[n-i-1];
			
			
			
			return;
			
		}
		
		
		public static void nextSmaller(long[] a, int[] ans)
		{
			
			Stack<Integer> stk = new Stack<>();
			stk.push(0);
			
			
			for(int i=1; i<a.length; i++)
			{
				
				if(!stk.isEmpty())
				{
				int s = stk.pop();
				while(a[s]>a[i])
				{
					ans[s] = i;
					if(!stk.isEmpty())
						s = stk.pop();
					else
						break;
				}
				if(a[s]<=a[i])
					stk.push(s);
				}
				
				stk.push(i);
				
			}
			return;
			
		}
		
		
		
		
	    public static long lcm(int[] numbers) {
	        long lcm = 1;
	        int divisor = 2;
	        while (true) {
	            int cnt = 0;
	            boolean divisible = false;
	            for (int i = 0; i < numbers.length; i++) {
	                if (numbers[i] == 0) {
	                    return 0;
	                } else if (numbers[i] < 0) {
	                    numbers[i] = numbers[i] * (-1);
	                }
	                if (numbers[i] == 1) {
	                    cnt++;
	                }
	                if (numbers[i] % divisor == 0) {
	                    divisible = true;
	                    numbers[i] = numbers[i] / divisor;
	                }
	            }
	            if (divisible) {
	                lcm = lcm * divisor;
	            } else {
	                divisor++;
	            }
	            if (cnt == numbers.length) {
	                return lcm;
	            }
	        }
	    }
		public static long fact(long n) {
			
			long factorial = 1;
			 for(int i = 1; i <= n; i++)
		        {
		            factorial *= i;
		        }
			 return factorial;
		}
		
public static void factSieve(int[] a, int n) {
			
			
			for(int i=2; i<=n; i+=2)
				a[i] = 2;
			
			
			for(int i=3; i<=n; i+=2)
			{
				if(a[i]==0)
				{
					a[i] = i;
					
					for(int j=i; j*i<=n; j++)
					{
						a[i*j] = i;	
					}
				}
			}
			
			int k = 1000;
			while(k!=1)
			{
				System.out.print(a[k]+"" "");
				k /= a[k];
				
			}
		}
	
		
		public static int lowerLimit(int[] a, int n) {
			int ans = 0;
			
			int ll = 0;
			int rl = a.length-1;
		//	System.out.println(a[rl]+"" ""+n);
			if(a[0]>n)
				return 0;
			if(a[0]==n)
				return 1;
			else if(a[rl]<=n)
				return rl+1;
		
			while(ll<=rl)
			{
				
				int mid = (ll+rl)/2;
				if(a[mid]==n)
				{
					ans = mid + 1;
					break;
				}
				
				else if(a[mid]>n)
				{
					rl = mid-1;
					
				}
				else
				{
					ans = mid+1;
					ll = mid+1;
				}
			}
			
			return ans; 
		}
		
		
		public static long choose(long total, long choose){
		    if(total < choose)
		        return 0;
		    if(choose == 0 || choose == total)
		        return 1;
		    return (choose(total-1,choose-1)+choose(total-1,choose))%mod;
		}
		
		public static int[] suffle(int[] a,Random gen)
		{
			int n = a.length;
			for(int i=0;i<n;i++)
			{
				int ind = gen.nextInt(n-i)+i;
				int temp = a[ind];
				a[ind] = a[i];
				a[i] = temp;
			}
			return a;
		}
		
		public static long[] sort(long[] a)
		{
			Random gen = new Random();
			int n = a.length;
			for(int i=0;i<n;i++)
			{
				int ind = gen.nextInt(n-i)+i;
				long temp = a[ind];
				a[ind] = a[i];
				a[i] = temp;
			}
			
			Arrays.sort(a);
			return a;
		}
		
		public static pair[] sort(pair[] a)
		{
			Random gen = new Random();
			int n = a.length;
			for(int i=0;i<n;i++)
			{
				int ind = gen.nextInt(n-i)+i;
				pair temp = a[ind];
				a[ind] = a[i];
				a[i] = temp;
			}
			
			Arrays.sort(a);
			return a;
		}
		
		
		public static int[] sort(int[] a)
		{
			Random gen = new Random();
			int n = a.length;
			for(int i=0;i<n;i++)
			{
				int ind = gen.nextInt(n-i)+i;
				int temp = a[ind];
				a[ind] = a[i];
				a[i] = temp;
			}
			
			Arrays.sort(a);
			return a;
		}
		
		public static int floorSearch(int arr[], int low, int high, int x)
		{
		    if (low > high)
		        return -1;
		 
		    if (x > arr[high])
		        return high;
		    int mid = (low+high)/2;
		 
		 
		    if (mid > 0 && arr[mid-1] < x && x < arr[mid])
		        return mid-1;
		 
		    if (x < arr[mid])
		        return floorSearch(arr, low, mid-1, x);
		 
		    return floorSearch(arr, mid+1, high, x);
		}
		
		
		public static void swap(int a, int b){
			int temp = a;
			a = b;
			b = temp;
		}
		public static ArrayList<Integer> primeFactorization(int n)
		{
			ArrayList<Integer> a =new ArrayList<Integer>();
			for(int i=2;i*i<=n;i++)
			{
				while(n%i==0)
				{
					a.add(i);
					n/=i;
				}
			}
			if(n!=1)
				a.add(n);
			return a;
		}
		
		
		public static void sieve(boolean[] isPrime,int n)
		{
			for(int i=1;i<n;i++)
				isPrime[i] = true;
			
			isPrime[0] = false;
			isPrime[1] = false;
			
			for(int i=2;i*i<n;i++)
			{
				if(isPrime[i] == true)
				{
					for(int j=(2*i);j<n;j+=i)
						isPrime[j] = false;
				}
			}
		}
		
		public static int lowerbound(ArrayList<Long> net, long c2) {
			int i=Collections.binarySearch(net, c2);
			if(i<0)
				i = -(i+2);
			return i;
			
			
		}
	
		public static int lowerboundArray(long[] psum, long c2) {
			int i=Arrays.binarySearch(psum, c2);
			if(i<0)
				i = -(i+2);
			return i;
			
			
		}
		
		public static int lowerboundArray(int[] psum, int c2) {
			int i=Arrays.binarySearch(psum, c2);
			if(i<0)
				i = -(i+2);
			return i;
			
			
		}
		
		
		public static int uperboundArray(long[] psum, long c2) {
			int i=Arrays.binarySearch(psum, c2);
			if(i<0)
				i = -(i+1);
			return i;
			
			
		}
		
		
		public static int uperbound(ArrayList<Long> net, long c2) {
			int i=Collections.binarySearch(net, c2);
			if(i<0)
				i = -(i+1);
			return i;
			
			
		}
		
		
		public static int GCD(int a,int b)
		{
			if(b==0)
				return a;
			else
				return GCD(b,a%b);
		}
		
		public static long GCD(long a,long b)
		{
			if(b==0)
				return a;
			else
				return GCD(b,a%b);
		}
		
		public static void extendedEuclid(int A,int B)
		{
			if(B==0)
			{
				d = A;
				p = 1 ;
				q = 0;
			}
			else
			{
				extendedEuclid(B, A%B);
				int temp = p;
				p = q;
				q = temp - (A/B)*q;
			}
		}
		
		public static long LCM(long a,long b)
		{
			return (a*b)/GCD(a,b);
		}
		
		public static int LCM(int a,int b)
		{
			return (a*b)/GCD(a,b);
		}
		
		public static int binaryExponentiation(int x,int n)
		{
		    int result=1;
		    while(n>0)
		    {
		        if(n % 2 ==1)
		            result=result * x;
		        x=x*x;
		        n=n/2;
		    }
		    return result;
		}
		
		
		public static int[] countDer(int n)
	    {
	        int der[] = new int[n + 1];
	     
	        der[0] = 1;
	        der[1] = 0;
	        der[2] = 1;
	     
	        for (int i = 3; i <= n; ++i)
	            der[i] = (i - 1) * (der[i - 1] + der[i - 2]);
	     
	        // Return result for n
	        return der;
	    }
		
		
		 static long binomialCoeff(int n, int k)
		    {
		    long C[][] = new long[n+1][k+1];
		    int i, j;
		     
		        // Calculate  value of Binomial Coefficient in bottom up manner
		    for (i = 0; i <= n; i++)
		    {
		        for (j = 0; j <= Math.min(i, k); j++)
		        {
		            // Base Cases
		            if (j == 0 || j == i)
		                C[i][j] = 1;
		      
		            // Calculate value using previosly stored values
		            else
		                C[i][j] = C[i-1][j-1] + C[i-1][j];
		          }
		     }
		      
		    return C[n][k];
		    }
		
		public static long binaryExponentiation(long x,long n)
		{
		    long result=1;
		    while(n>0)
		    {
		        if(n % 2 ==1)
		            result=result * x;
		        x=(x%mod * x%mod)%mod;
		        n=n/2;
		    }
		    return result;
		}
		
		public static int modularExponentiation(int x,int n,int M)
		{
		    int result=1;
		    while(n>0)
		    {
		        if(n % 2 ==1)
		            result=(result * x)%M;
		        x=(x%M*x%M)%M;
		        n=n/2;
		    }
		    return result;
		}
		
		public static long modularExponentiation(long x,long n,long M)
		{
		    long result=1;
		    while(n>0)
		    {
		        if(n % 2 ==1)
		            result=(result %M* x%M)%M;
		        x=(x*x)%M;
		        n=n/2;
		    }
		    return result;
		}
		
		public static int modInverse(int A,int M)
		{
		    return modularExponentiation(A,M-2,M);
		}
		
		public static long modInverse(long A,long M)
		{
		    return modularExponentiation(A,M-2,M);
		}
		
		
		public static boolean checkYear(int year)
	    {
			if (year % 400 == 0)
	            return true;
	     
	        if (year % 100 == 0)
	            return false;
	     
	        if (year % 4 == 0)
	            return true;
	        return false;
	    }
		
		public static boolean isPrime(int n)
		{
		    
		    if (n <= 1)  return false;
		    if (n <= 3)  return true;
		    
		    if (n%2 == 0 || n%3 == 0) 
		    	return false;
		 
		    for (int i=5; i*i<=n; i=i+6)
		    {
		        if (n%i == 0 || n%(i+2) == 0)
		           return false;
		    }
		    
		    return true;
		}
		
		static class pair implements Comparable<pair>

		{
			Long x, y;

			pair(long x, long y) {
				this.x = x;
				this.y = y;
			}

			public int compareTo(pair o) {
				int result = x.compareTo(o.x);
				if (result == 0)
					result = y.compareTo(o.y);

				return result;
			}

			public String toString() {
				return x + "" "" + y;
			}

			public boolean equals(Object o) {
				if (o instanceof pair) {
					pair p = (pair) o;
					if(p.x-x==0 && p.y-y==0)
						return true;
					else
					return false;
				}
				return false;
			}

			public int hashCode() {
				return new Long(x).hashCode() * 31 + new Long(y).hashCode();
			}

		}
		
		
		static class triplet implements Comparable<triplet>
		{
			Integer x,y;
			Long z;
			triplet(Integer l,Integer m,long z)
			{
				this.x = l;
				this.y = m;
				this.z = z;
			}
			
			public  int compareTo(triplet o)
			{
				int result = x.compareTo(o.x);
				if(result==0)
					result =  y.compareTo(o.y);
				if(result==0)
					result = z.compareTo(o.z);
 
				return result;
			}
			
			public boolean equlas(Object o)
			{
				if(o instanceof triplet)
				{
					triplet p = (triplet)o;
					return x==p.x && y==p.y && z==p.z;
				}
				return false;
			}
			
			public String toString()
			{
				return x+"" ""+y+"" ""+z;
			}
			public int hashCode()
			{
				return new Long(x).hashCode()*31 + new Long(y).hashCode() + new Long(z).hashCode(); 
			}
		}
		
		static class spair implements Comparable<spair>

		{
			String x;
			Integer y;

			spair(String x, int y) {
				this.x = x;
				this.y = y;
			}

			public int compareTo(spair o) {
				
				String s1 = x + o.x;
				String s2 = o.x + x;
				long p1 = cnt[y][0] + cnt[o.y][0];
				long p2 = p1;
				
				p1 += cnt[y][1] * cnt[o.y][2];
				p2 += cnt[o.y][1] * cnt[y][2];
				
				if(p1==p2)
						return 0;
				if(p1>p2)
					return -1;
				
				return 1;
				
				
				
				
			}

			public String toString() {
				return x + "" "" + y;
			}

			/*public boolean equals(Object o) {
				if (o instanceof pair) {
					pair p = (pair) o;
					return p.x == x && p.y == y;
				}
				return false;
			}

			public int hashCode() {
				return new Long(x).hashCode() * 31 + new Long(y).hashCode();
			}
			

		}

		
		
		
	
		/*static class node implements Comparable<node>
 
		{
			Integer x, y, z;
			node(int x,int y, int z)
			{
				this.x=x;
				this.y=y;
				this.z=z;
			}
			
			public int compareTo(pair o) {
				int result = x.compareTo(o.x);
				if(result==0)
					result = y.compareTo(o.y);
				if(result==0)
					result = z.compareTo(z); 
				return result;
			}
 
			@Override
			public int compareTo(node o) {
				// TODO Auto-generated method stub
				return 0;
			}  
		}
		*/
	}
	}
	
		",1004_A,CODEFORCES,1995,Sonya and Hotels,"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.
The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $$$n$$$ hotels, where the $$$i$$$-th hotel is located in the city with coordinate $$$x_i$$$. Sonya is a smart girl, so she does not open two or more hotels in the same city.
Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $$$d$$$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 
Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $$$n$$$ hotels to the new one is equal to $$$d$$$.
The first line contains two integers $$$n$$$ and $$$d$$$ ($$$1\leq n\leq 100$$$, $$$1\leq d\leq 10^9$$$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.
The second line contains $$$n$$$ different integers in strictly increasing order $$$x_1, x_2, \ldots, x_n$$$ ($$$-10^9\leq x_i\leq 10^9$$$) — coordinates of Sonya's hotels.
Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $$$d$$$.
","input
In the first example, there are $$$6$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$-6$$$, $$$5$$$, $$$6$$$, $$$12$$$, $$$13$$$, and $$$19$$$.
output
In the second example, there are $$$5$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$2$$$, $$$6$$$, $$$13$$$, $$$16$$$, and $$$21$$$.
",implementation,3
"import java.util.*;
import java.io.*;
public class EdF {
	static long[] mods = {1000000007, 998244353, 1000000009};
	static long mod = mods[0];
	public static MyScanner sc;
    public static PrintWriter out;
	public static void main(String[] havish) throws Exception{
		// TODO Auto-generated method stub
 		sc = new MyScanner();
 		out = new PrintWriter(System.out);
 		int t = sc.nextInt();
 		while(t-->0) {
 	 		int n = sc.nextInt();
 	 		
 	 		Stack<Integer> st = new Stack<>();
 	 		Stack<Integer> temporary = new Stack<>();
 	 		for(int j = 0;j<n;j++){
 	 			int val = sc.nextInt();
 	 			boolean found = false;
 	 			while(!st.isEmpty()){
 	 				int temp = st.peek();
 	 				if (val == temp+1){
 	 					found = true;
 	 					st.pop();
 	 					break;
 	 				}
 	 				else{
 	 					temporary.add(st.pop());
 	 				}
 	 			}
 	 			if (!found){
	 	 			while(!temporary.isEmpty()){
	 	 				st.add(temporary.pop());
	 	 			}
 	 			}
 	 			st.add(val);
 	 			ArrayList<Integer> arr = new ArrayList<>();
 	 			
 	 			for(int s : st){
 	 				arr.add(s);
 	 			}
 	 			for (int s =0 ;s<arr.size()-1;s++){
 	 				out.print(arr.get(s));
 	 				out.print(""."");
 	 			}
 	 			out.println(arr.get(arr.size()-1));
 	 			temporary.clear();
 	 		}
 			
 		}
 		
 		out.close();
 		
 	}
	
	public static void sort(int[] array){
		ArrayList<Integer> copy = new ArrayList<>();
		for (int i : array)
			copy.add(i);
		Collections.sort(copy);
		for(int i = 0;i<array.length;i++)
			array[i] = copy.get(i);
	}
	static String[] readArrayString(int n){
		String[] array = new String[n];
		for(int j =0 ;j<n;j++)
			array[j] = sc.next();
		return array;
	}
	static int[] readArrayInt(int n){
    	int[] array = new int[n];
    	for(int j = 0;j<n;j++)
    		array[j] = sc.nextInt();
    	return array;
    }
	static int[] readArrayInt1(int n){
		int[] array = new int[n+1];
		for(int j = 1;j<=n;j++){
			array[j] = sc.nextInt();
		}
		return array;
	}
	static long[] readArrayLong(int n){
		long[] array = new long[n];
		for(int j =0 ;j<n;j++)
			array[j] = sc.nextLong();
		return array;
	}
	static double[] readArrayDouble(int n){
		double[] array = new double[n];
		for(int j =0 ;j<n;j++)
			array[j] = sc.nextDouble();
		return array;
	}
	static int minIndex(int[] array){
		int minValue = Integer.MAX_VALUE;
		int minIndex = -1;
		for(int j = 0;j<array.length;j++){
			if (array[j] < minValue){
				minValue = array[j];
				minIndex = j;
			}
		}
		return minIndex;
	}
	static int minIndex(long[] array){
		long minValue = Long.MAX_VALUE;
		int minIndex = -1;
		for(int j = 0;j<array.length;j++){
			if (array[j] < minValue){
				minValue = array[j];
				minIndex = j;
			}
		}
		return minIndex;
	}
	static int minIndex(double[] array){
		double minValue = Double.MAX_VALUE;
		int minIndex = -1;
		for(int j = 0;j<array.length;j++){
			if (array[j] < minValue){
				minValue = array[j];
				minIndex = j;
			}
		}
		return minIndex;
	}
	static long power(long x, long y){
		if (y == 0)
			return 1;
		if (y%2 == 1)
			return (x*power(x, y-1))%mod;
		return power((x*x)%mod, y/2)%mod;
	}
	static void verdict(boolean a){
        out.println(a ? ""YES"" : ""NO"");
    }
    public static class MyScanner {
        BufferedReader br;
        StringTokenizer st;
        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } 
                catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        int nextInt() {
            return Integer.parseInt(next());
        }
        long nextLong() {
            return Long.parseLong(next());
        }
        double nextDouble() {
            return Double.parseDouble(next());
        }
        String nextLine() {
            String str = """";
            try{
                str = br.readLine();
            } 
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        
    }	
}

//StringJoiner sj = new StringJoiner("" ""); 
//sj.add(strings)
//sj.toString() gives string of those stuff w spaces or whatever that sequence is",1523_C,CODEFORCES,3600,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees",5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class con111_A {

    public static void main( final String[] args ) throws IOException {
        final BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );
        final int n = Integer.parseInt( br.readLine() );
        final int[] a = new int[n];
        final String[] parts = br.readLine().split( "" "" );
        for ( int i = 0; i < n; ++i ) {
            a[ i ] = Integer.parseInt( parts[ i ] );
        }
        System.out.println( solve( n, a ) );
    }

    private static int solve( final int n, final int[] a ) {
        Arrays.sort( a );
        int sum = 0;
        for ( int i = 0; i < n; ++i ) {
            sum += a[ i ];
        }
        int res = 0;
        int ms = 0;
        for ( int i = n - 1; i >= 0; --i ) {
            if ( ms > sum / 2 ) {
                break;
            } else {
                ms += a[ i ];
                ++res;
            }
        }
        return res;
    }

}
",0160_A,CODEFORCES,2474,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"
import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Madi
 */
public class A630 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        String s = sc.nextLine();
        System.out.println(""25"");
    }
}
",0630_A,CODEFORCES,555,Again Twenty Five!,"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. ""Do I give such a hard task?"" — the HR manager thought. ""Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.""
Could you pass the interview in the machine vision company in IT City?
","input
The only line of the input contains a single integer n (2 ≤ n ≤ 2·1018) — the power in which you need to raise number 5.
output
Output the last two digits of 5n without spaces between them.
",numbertheory,1
"import java.util.Scanner;


public class Test {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        StringBuilder text = new StringBuilder(in.nextLine()); String substr; String max="""";
        for(int i=2; i<=text.length(); i++){
            for(int j=0; j<i; j++){
                substr = text.substring(j, i);
                if(text.lastIndexOf(substr) != text.indexOf(substr)){
                    if(substr.length() > max.length()){  max = substr;}
                }
            }
        }
        System.out.println(max.length());
    }
}
",0023_A,CODEFORCES,3762,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.util.Comparator;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.io.IOException;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.math.BigInteger;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Egor Kulikov (egor@egork.net)
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskA {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int count = in.readInt();
        int[] array = IOUtils.readIntArray(in, count);
        int[] sorted = array.clone();
        ArrayUtils.sort(sorted, IntComparator.DEFAULT);
        int differs = 0;
        for (int i = 0; i < count; i++) {
            if (array[i] != sorted[i])
                differs++;
        }
        if (differs <= 2)
            out.printLine(""YES"");
        else
            out.printLine(""NO"");
    }
}

class InputReader {

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(Object...objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void printLine(Object...objects) {
        print(objects);
        writer.println();
    }

    public void close() {
        writer.close();
    }

    }

class IOUtils {

    public static int[] readIntArray(InputReader in, int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++)
            array[i] = in.readInt();
        return array;
    }

    }

class ArrayUtils {
    private static int[] tempInt = new int[0];

    public static int[] sort(int[] array, IntComparator comparator) {
        return sort(array, 0, array.length, comparator);
    }

    public static int[] sort(int[] array, int from, int to, IntComparator comparator) {
        ensureCapacityInt(to - from);
        System.arraycopy(array, from, tempInt, 0, to - from);
        sortImpl(array, from, to, tempInt, 0, to - from, comparator);
        return array;
    }

    private static void ensureCapacityInt(int size) {
        if (tempInt.length >= size)
            return;
        size = Math.max(size, tempInt.length << 1);
        tempInt = new int[size];
    }

    private static void sortImpl(int[] array, int from, int to, int[] temp, int fromTemp, int toTemp, IntComparator comparator) {
        if (to - from <= 1)
            return;
        int middle = (to - from) >> 1;
        int tempMiddle = fromTemp + middle;
        sortImpl(temp, fromTemp, tempMiddle, array, from, from + middle, comparator);
        sortImpl(temp, tempMiddle, toTemp, array, from + middle, to, comparator);
        int index = from;
        int index1 = fromTemp;
        int index2 = tempMiddle;
        while (index1 < tempMiddle && index2 < toTemp) {
            if (comparator.compare(temp[index1], temp[index2]) <= 0)
                array[index++] = temp[index1++];
            else
                array[index++] = temp[index2++];
        }
        if (index1 != tempMiddle)
            System.arraycopy(temp, index1, array, index, tempMiddle - index1);
        if (index2 != toTemp)
            System.arraycopy(temp, index2, array, index, toTemp - index2);
    }

    }

interface IntComparator {
    public static final IntComparator DEFAULT = new IntComparator() {
        public int compare(int first, int second) {
            if (first < second)
                return -1;
            if (first > second)
                return 1;
            return 0;
        }
    };

    public int compare(int first, int second);
}",0220_A,CODEFORCES,2605,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package Round547;

import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

/**
 *
 * @author Hemant Dhanuka
 */
public class F1 {
    
    static class Reader 
    { 
        final private int BUFFER_SIZE = 1 << 16; 
        private DataInputStream din; 
        private byte[] buffer; 
        private int bufferPointer, bytesRead; 
  
        public Reader() 
        { 
            din = new DataInputStream(System.in); 
            buffer = new byte[BUFFER_SIZE]; 
            bufferPointer = bytesRead = 0; 
        } 
  
        public Reader(String file_name) throws IOException 
        { 
            din = new DataInputStream(new FileInputStream(file_name)); 
            buffer = new byte[BUFFER_SIZE]; 
            bufferPointer = bytesRead = 0; 
        } 
  
        public String readLine() throws IOException 
        { 
            byte[] buf = new byte[64]; // line length 
            int cnt = 0, c; 
            while ((c = read()) != -1) 
            { 
                if (c == '\n') 
                    break; 
                buf[cnt++] = (byte) c; 
            } 
            return new String(buf, 0, cnt); 
        } 
  
        public int nextInt() throws IOException 
        { 
            int ret = 0; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
            do
            { 
                ret = ret * 10 + c - '0'; 
            }  while ((c = read()) >= '0' && c <= '9'); 
  
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        public long nextLong() throws IOException 
        { 
            long ret = 0; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
            do { 
                ret = ret * 10 + c - '0'; 
            } 
            while ((c = read()) >= '0' && c <= '9'); 
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        public double nextDouble() throws IOException 
        { 
            double ret = 0, div = 1; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
  
            do { 
                ret = ret * 10 + c - '0'; 
            } 
            while ((c = read()) >= '0' && c <= '9'); 
  
            if (c == '.') 
            { 
                while ((c = read()) >= '0' && c <= '9') 
                { 
                    ret += (c - '0') / (div *= 10); 
                } 
            } 
  
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        private void fillBuffer() throws IOException 
        { 
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); 
            if (bytesRead == -1) 
                buffer[0] = -1; 
        } 
  
        private byte read() throws IOException 
        { 
            if (bufferPointer == bytesRead) 
                fillBuffer(); 
            return buffer[bufferPointer++]; 
        } 
  
        public void close() throws IOException 
        { 
            if (din == null) 
                return; 
            din.close(); 
        } 
    } 
    
    
    public static void main(String[] args) throws IOException {
  //    Scanner s=new Scanner(System.in);
     Reader s=new Reader();
    int n=s.nextInt();
        
        int a[]=new int[n];
        
        for(int i=0;i<n;i++){
            a[i]=s.nextInt();
        }
        
        Map<Long,PriorityQueue<Node>> map=new HashMap();
        
        for(int i=0;i<n;i++){
            long sum=0;
            for(int j=i;j<n;j++){
                sum=sum+a[j];
                PriorityQueue<Node> pq=map.get(sum);
                if(pq==null){
                    pq=new PriorityQueue();
                    map.put(sum, pq);
                }
                pq.add(new Node(i,j));
            }
            
            
        }
        
        
        Set<Long> keys=map.keySet();
        
        Iterator<Long> itr=keys.iterator();
        int max=0;
        int solbackDp[]=null;
        Node solA[]=new Node[0];
        while(itr.hasNext()){
           Long sum=itr.next();
           PriorityQueue<Node> pq1=map.get(sum);
           
           
           
           
           
           
           //Node rangelist[]=new  Node[pq1.size()+1];
            ArrayList<Node> rangelist=new ArrayList<>();
            rangelist.add(new Node(-1, -1));
            //int count=1;
            //rangelist[0]=new Node(-1,-1);
             Node last=rangelist.get(0);
            while(!pq1.isEmpty()){
                Node n1=pq1.poll();
                if(n1.l!=last.l){
                    rangelist.add(n1);
                    last=n1;
                } 
                       
           }
           int backTrack[]=new int[rangelist.size()];
           int dp[]=new int[rangelist.size()];
           Arrays.fill(dp, -1);
           int ans=fun(0,dp,rangelist,backTrack);
           if(ans>max){
               max=ans;
               solA=rangelist.toArray(solA);
               solbackDp=backTrack;
           }
        }
        
        System.out.println(max);
        
        
        int pos=0;
        while(solbackDp[pos]!=-1){
            pos=solbackDp[pos];
            System.out.println((solA[pos].l+1)+"" ""+(solA[pos].r+1));
        }
    }
    
    
    static int fun(int pos, int[] dp, ArrayList<Node> rangeList, int[] bactTrack){
        
        if(pos==rangeList.size()-1){
            bactTrack[pos]=-1;
            return 0;
          
        }
        
        if(dp[pos]!=-1){
            return dp[pos];
        }
        
        int i=pos+1;
        int maxAns=0;
        int nextPos=-1;
        for(;i<=rangeList.size()-1;i++){
            
            
            if(rangeList.get(i).l>rangeList.get(pos).r){
                int tempAns=1+fun(i, dp,rangeList, bactTrack);
                if(tempAns>maxAns){
                    maxAns=tempAns;
                    nextPos=i;
                }
            }
        }
        
        dp[pos]=maxAns;
        bactTrack[pos]=nextPos;
        return maxAns;
        
        
        
        
    }
    
    static class Node implements Comparable<Node>{
        int l;
        int r;

        public Node(int l, int r) {
            this.l = l;
            this.r = r;
        }
        
        
        
       
        @Override
        public int compareTo(Node o2) {
            if(this.l!=o2.l){
                return this.l-o2.l;
            } else{
                return this.r-o2.r;
            }
        }
        
    }
}
",1141_F2,CODEFORCES,3371,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"import java.awt.geom.Line2D;
import java.io.IOException;
import java.io.InputStream;
import java.util.InputMismatchException;

public class C488C
{
	public static void main(String[] args)
	{
		FastScanner in = new FastScanner(System.in);
		int[] x1 = new int[4];
		int[] y1 = new int[4];
		int[] x2 = new int[4];
		int[] y2 = new int[4];
		for (int i = 0; i < 4; i++) {
			x1[i] = in.nextInt();
			y1[i] = in.nextInt();
		}
		for (int i = 0; i < 4; i++) {
			x2[i] = in.nextInt();
			y2[i] = in.nextInt();
		}
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				if (Line2D.linesIntersect(x1[i], y1[i], x1[(i + 1) % 4], y1[(i + 1) % 4], x2[j], y2[j], x2[(j + 1) % 4], y2[(j + 1) % 4])) {
					System.out.println(""YES"");
					return;
				}
			}
		}
		int rectMinX = Math.min(Math.min(x1[0], x1[1]), x1[2]);
		int rectMaxX = Math.max(Math.max(x1[0], x1[1]), x1[2]);
		int rectMinY = Math.min(Math.min(y1[0], y1[1]), y1[2]);
		int rectMaxY = Math.max(Math.max(y1[0], y1[1]), y1[2]);
		if (x2[0] >= rectMinX && x2[0] <= rectMaxX && y2[0] >= rectMinY && y2[0] <= rectMaxY) {
			System.out.println(""YES"");
			return;
		}
		int dMinX = Math.min(Math.min(Math.min(x2[0], x2[1]), x2[2]), x2[3]);
		int dMaxX = Math.max(Math.max(Math.max(x2[0], x2[1]), x2[2]), x2[3]);
		int dMinY = Math.min(Math.min(Math.min(y2[0], y2[1]), y2[2]), y2[3]);
		int dMaxY = Math.max(Math.max(Math.max(y2[0], y2[1]), y2[2]), y2[3]);
		double midX = (dMinX + dMaxX) / 2.0;
		double midY = (dMinY + dMaxY) / 2.0;
		int x = x1[0];
		int y = y1[0];
		if (!above(x, y, dMinX, midY, midX, dMinY))
			System.out.println(""NO"");
		else if (!above(x, y, midX, dMinY, dMaxX, midY))
			System.out.println(""NO"");
		else if (above(x, y, dMinX, midY, midX, dMaxY))
			System.out.println(""NO"");
		else if (above(x, y, midX, dMaxY, dMaxX, midY))
			System.out.println(""NO"");
		else
			System.out.println(""YES"");
	}
	
	public static boolean above(int x, int y, double x1, double y1, double x2, double y2)
	{
		double a = (y2 - y1) / (x2 - x1);
		double b = y1 - a * x1;
		double yHat = a * x + b;
		return y > yHat;
	}
	
	/**
	 * Source: Matt Fontaine
	 */
	public static class FastScanner
	{
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public FastScanner(InputStream stream)
		{
			this.stream = stream;
		}

		int read()
		{
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars)
			{
				curChar = 0;
				try
				{
					numChars = stream.read(buf);
				} catch (IOException e)
				{
					throw new InputMismatchException();
				}
				if (numChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c)
		{
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c)
		{
			return c == '\n' || c == '\r' || c == -1;
		}

		public int nextInt()
		{
			return Integer.parseInt(next());
		}

		public long nextLong()
		{
			return Long.parseLong(next());
		}

		public double nextDouble()
		{
			return Double.parseDouble(next());
		}

		public String next()
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do
			{
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public String nextLine()
		{
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do
			{
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}
}",0994_C,CODEFORCES,670,Two Squares,"You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.
The interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.
The input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order.
The first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees.
All the values are integer and between $$$-100$$$ and $$$100$$$.
Print ""Yes"" if squares intersect, otherwise print ""No"".
You can print each letter in any case (upper or lower).
In the first example the second square lies entirely within the first square, so they do intersect.
","input
In the second sample squares do not have any points in common.
output
Here are images corresponding to the samples:
",bruteforce,1
"import java.io.*;
import java.util.*;
public class A{
	public static BufferedReader k;
	public static BufferedWriter z;
	

	
	public static void main(String [] args)throws IOException{
		k = new BufferedReader(new InputStreamReader(System.in));
		z = new BufferedWriter(new OutputStreamWriter(System.out));
		
		
	        String[] dat = k.readLine().split("" "");

	        long l = Long.parseLong(dat[0]);
	        long r = Long.parseLong(dat[1]);
			
			if(r-l<=1){
				z.write(-1+""\n"");
			}
			else if(r-l == 2){
				
				
				if((l&1)!=0){
					z.write(-1+""\n"");
				}
				else{
					z.write(l+"" ""+(l+1)+"" ""+r+""\n"");
				}
				
			}
			else{
				if(l%2==0){
					z.write(l+"" ""+(l+1)+"" ""+(l+2)+""\n"");
				}
				else{
					z.write((l+1)+"" ""+(l+2)+"" ""+(l+3)+""\n"");
				}
			}
			
			
			
			
		
		z.flush();

	}

}",0483_A,CODEFORCES,508,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"import java.util.*;
import java.io.*;
import java.math.*;
public class A{

    void solve(){
        int n=ni();
        long r=ni();
        int x[]=new int[n+1];
        for(int i=1;i<=n;i++) x[i]=ni();

        double ans[]=new double[n+1];
        ans[1]=r;
        for(int i=2;i<=n;i++){
            double mx=0;
            for(int j=1;j<i;j++) {
                double xx = Math.abs(x[i] - x[j]);
                if (xx > 2*r) {
                    mx = Math.max(mx,r);
                } else {
                    xx *= xx;
                     mx=Math.max(mx,ans[j] + Math.sqrt(4 * r * r - xx));
                    // if(i==5) pw.println(j);
                }
                //if(i==4) pw.println(mx);
            }
            ans[i]=mx;
        }
        for(int i=1;i<=n;i++) pw.print(ans[i]+"" "");
    }


    long M=(long)1e9+7;
    InputStream is;
    PrintWriter pw;
    String INPUT = """";
    void run() throws Exception {
        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
        pw = new PrintWriter(System.out);
        long s = System.currentTimeMillis();
        solve();
        pw.flush();
        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");
    }

    public static void main(String[] args) throws Exception { new A().run(); }

    private byte[] inbuf = new byte[1024];
    public int lenbuf = 0, ptrbuf = 0;

    private int readByte() {
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }

    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }

    private double nd() { return Double.parseDouble(ns()); }
    private char nc() { return (char)skip(); }

    private String ns() {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    private char[] ns(int n) {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }

    private char[][] nm(int n, int m) {
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }

    private int[] na(int n) {
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }

    private int ni() {
        int num = 0, b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }

        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }

    private long nl() {
        long num = 0;
        int b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }

        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }

    private void tr(Object... o) { if(INPUT.length() > 0)System.out.println(Arrays.deepToString(o)); }
}",0908_C,CODEFORCES,2973,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"import java.util.*;
import java.io.*;
 
public class Main{
	
	public static void main (String[] args) {
		Scanner scan = new Scanner(System.in);
		
		int n = scan.nextInt(), min[] = new int[n];
		boolean used[] = new boolean[n];
		HashSet<Integer> set = new HashSet<>();
		
		
		for (int i = 0; i < n; i++) {
			min[i] = scan.nextInt();
		}
		
		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
					if (min[i] > min[j]) {
						if (min[i] % min[j] == 0)
							min[i] = min[j];
					}
					else if (min[j] % min[i] == 0)
							min[j] = min[i];
				}
		}
		
		for (int i = 0; i < n; i++) {
			set.add(min[i]);
		}
		
		System.out.print(set.size());
	}
}",1209_A,CODEFORCES,3531,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"import java.util.*;

import java.io.*;
import java.math.*;
import java.awt.geom.*;

import static java.lang.Math.*;

public class Solution implements Runnable {

	long mod1 = (long) 1e9 + 7;
	int mod2 = 998244353;

	public void solve() throws Exception {
		int n=sc.nextInt();
		int arr[]=new int[n+1];
		for(int i=1;i<=n;i++) arr[i]=sc.nextInt();
		int indices[]=new int[n+1];
		for(int i=1;i<=n;i++) {
			indices[arr[i]]=i;
		}
		int winorlose[]=new int[n+1];
		winorlose[n] = -1;
		for(int i=n-1;i>=1;i--) {
			int index=indices[i];
			winorlose[i]=-1;
			
			for(int j=index;j<=n;j+=i) {
				
				if(arr[j]>i && winorlose[arr[j]]!=0) {
					if(winorlose[arr[j]]==-1) {
						winorlose[i]=1;
					}
				}
			}
			for(int j=index;j>=1;j-=i) {
//				if(i==2) {
//					out.println(j+"" ""+arr[j]);
//				}
				if(arr[j]>i && winorlose[arr[j]]!=0) {
					if(winorlose[arr[j]]==-1) {
						winorlose[i]=1;
					}
				}
			}
		}
		for(int i=1;i<=n;i++) 
		{
			if(winorlose[arr[i]]==1) {
				out.print(""A"");
			}
			else out.print(""B"");
		}
	}

	static void sort(int[] a) {
		ArrayList<Integer> l = new ArrayList<>();
		for (int i : a)
			l.add(i);
		Collections.sort(l);
		for (int i = 0; i < a.length; i++)
			a[i] = l.get(i);
	}

	static long gcd(long a, long b) {
		if (a == 0)
			return b;
		return gcd(b % a, a);
	}

	static long ncr(int n, int r, long p) {
		if (r > n)
			return 0l;
		if (r > n - r)
			r = n - r;

		long C[] = new long[r + 1];

		C[0] = 1;

		for (int i = 1; i <= n; i++) {

			for (int j = Math.min(i, r); j > 0; j--)
				C[j] = (C[j] + C[j - 1]) % p;
		}
		return C[r] % p;
	}

	public long power(long x, long y, long p) {
		long res = 1;
		// out.println(x+"" ""+y);
		x = x % p;
		if (x == 0)
			return 0;

		while (y > 0) {
			if ((y & 1) == 1)
				res = (res * x) % p;
			y = y >> 1;
			x = (x * x) % p;
		}
		return res;
	}

	static Throwable uncaught;

	BufferedReader in;
	FastScanner sc;
	PrintWriter out;

	@Override
	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			sc = new FastScanner(in);
			solve();
		} catch (Throwable uncaught) {
			Solution.uncaught = uncaught;
		} finally {
			out.close();
		}
	}

	public static void main(String[] args) throws Throwable {
		Thread thread = new Thread(null, new Solution(), """", (1 << 26));
		thread.start();
		thread.join();
		if (Solution.uncaught != null) {
			throw Solution.uncaught;
		}
	}

}

class FastScanner {

	BufferedReader in;
	StringTokenizer st;

	public FastScanner(BufferedReader in) {
		this.in = in;
	}

	public String nextToken() throws Exception {
		while (st == null || !st.hasMoreTokens()) {
			st = new StringTokenizer(in.readLine());
		}
		return st.nextToken();
	}

	public int nextInt() throws Exception {
		return Integer.parseInt(nextToken());
	}

	public int[] readArray(int n) throws Exception {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public long nextLong() throws Exception {
		return Long.parseLong(nextToken());
	}

	public double nextDouble() throws Exception {
		return Double.parseDouble(nextToken());
	}

}",1033_C,CODEFORCES,2875,Permutation Game,"After a long day, Alice and Bob decided to play a little game. The game board consists of $$$n$$$ cells in a straight line, numbered from $$$1$$$ to $$$n$$$, where each cell contains a number $$$a_i$$$ between $$$1$$$ and $$$n$$$. Furthermore, no two cells contain the same number. 
A token is placed in one of the cells. They take alternating turns of moving the token around the board, with Alice moving first. The current player can move from cell $$$i$$$ to cell $$$j$$$ only if the following two conditions are satisfied: 
Whoever is unable to make a move, loses. For each possible starting position, determine who wins if they both play optimally. It can be shown that the game is always finite, i.e. there always is a winning strategy for one of the players.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of numbers.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$). Furthermore, there are no pair of indices $$$i \neq j$$$ such that $$$a_i = a_j$$$.
","input
Print $$$s$$$ — a string of $$$n$$$ characters, where the $$$i$$$-th character represents the outcome of the game if the token is initially placed in the cell $$$i$$$. If Alice wins, then $$$s_i$$$ has to be equal to ""A""; otherwise, $$$s_i$$$ has to be equal to ""B"". 
output
In the first sample, if Bob puts the token on the number (not position): 
","bruteforce, dp, games",4
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;


public class Main {

	static class Task {
		
		int NN = 1000006;
		int MOD = 998244353;
		int INF = 2000000000;
		long INFINITY = 1000000000000000000L;
		
		long [][] a;
		long [][] w, w1;
		long [][] dp;
		
		int countBit(int num) {
			int ret = 0;
			while(num > 0) {
				if((num&1)!=0)
					++ret;
				num >>= 1;
			}
			return ret;
		}
		
		long rec(int at, int mask, int n, int start) {
			long ans = -INFINITY;
			if(dp[at][mask] != -1)
				return dp[at][mask];
			if(countBit(mask) == n) {
				return dp[at][mask] = w1[start][at];
			}
			for(int i=0;i < n;++i) {
				if(((mask>>i)&1)==0) {
					ans = Math.max(ans, 
							Math.min(w[at][i], rec(i, mask | (1<<i), n, start)));
				}
			}
			return dp[at][mask] = ans;
		}
		
		public void solve(InputReader in, PrintWriter out) {
			int n  = in.nextInt(), m = in.nextInt();
			dp = new long[n][1<<n];
			a = new long[n][m];
			w = new long[n][n];
			w1 = new long[n][n];
			for(int i=0;i<n;++i) {
				for(int j=0;j<m;++j) {
					a[i][j] = in.nextLong();
				}
			}
			for(int i=0;i<n;++i) {
				for(int j=0;j<n;++j) {
					w[i][j] = INFINITY;
					if(i == j)
						continue;
					for(int k=0;k<m;++k) {
						w[i][j] = Math.min(w[i][j], Math.abs(a[j][k] - a[i][k]));
					}
				}
			}
			for(int i=0;i<n;++i) {
				for(int j=0;j<n;++j) {
					w1[i][j] = INFINITY;
					for(int k=1;k<m;++k) {
						w1[i][j] = Math.min(w1[i][j], Math.abs(a[i][k] - a[j][k - 1]));
					}
				}
			}
			long ans = 0;
			for(int start = 0;start < n;++start) {
				for(int i=0;i<n;++i) {
					for(int j=0;j<(1<<n);++j)
						dp[i][j] = -1;
				}
				ans = Math.max(ans, rec(start, 1<<start, n, start));
			}
			out.println(ans);
		}
		
		class Pair {
			Integer first, second;
			public Pair() {
			}
			public Pair(int first, int second) {
				this.first = first;
				this.second = second;
			}
			@Override
			public int hashCode() {
				final int prime = 31;
				int result = 1;
				result = prime * result + getOuterType().hashCode();
				result = prime * result + first;
				result = prime * result + second;
				return result;
			}
			@Override
			public boolean equals(Object obj) {
				if (this == obj)
					return true;
				if (obj == null)
					return false;
				if (getClass() != obj.getClass())
					return false;
				Pair other = (Pair) obj;
				if (!getOuterType().equals(other.getOuterType()))
					return false;
				if (first != other.first)
					return false;
				if (second != other.second)
					return false;
				return true;
			}
			private Task getOuterType() {
				return Task.this;
			}
			
		}
		
	}
	
	static void prepareIO(boolean isFileIO) {
		Task solver = new Task();
		// Standard IO
		if(!isFileIO) {
			InputStream inputStream = System.in;
	        OutputStream outputStream = System.out;
	        InputReader in = new InputReader(inputStream);
	        PrintWriter out = new PrintWriter(outputStream);
	        solver.solve(in, out);
	        out.close();
		}
        // File IO
		else {
			String IPfilePath = System.getProperty(""user.home"") + ""/Downloads/ip.in"";
	        String OPfilePath = System.getProperty(""user.home"") + ""/Downloads/op.out"";
	        InputReader fin = new InputReader(IPfilePath);
	        PrintWriter fout = null;
	        try {
				fout = new PrintWriter(new File(OPfilePath));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
	        solver.solve(fin, fout);
	        fout.close();
		}
	}
	
	public static void main(String[] args) {
        prepareIO(false);
	}
	
	static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        
        public InputReader(String filePath) {
        	File file = new File(filePath);
            try {
				reader = new BufferedReader(new FileReader(file));
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
            tokenizer = null;
        }
        
        public String nextLine() {
        	String str = """";
        	try {
				str = reader.readLine();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
        	return str;
        }
        
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
        	return Double.parseDouble(next());
        }
        
    }

}",1102_F,CODEFORCES,4663,Elongated Matrix,"You are given a matrix $$$a$$$, consisting of $$$n$$$ rows and $$$m$$$ columns. Each cell contains an integer in it.
You can change the order of rows arbitrarily (including leaving the initial order), but you can't change the order of cells in a row. After you pick some order of rows, you traverse the whole matrix the following way: firstly visit all cells of the first column from the top row to the bottom one, then the same for the second column and so on. During the traversal you write down the sequence of the numbers on the cells in the same order you visited them. Let that sequence be $$$s_1, s_2, \dots, s_{nm}$$$. 
The traversal is $$$k$$$-acceptable if for all $$$i$$$ ($$$1 \le i \le nm - 1$$$) $$$|s_i - s_{i + 1}| \ge k$$$.
Find the maximum integer $$$k$$$ such that there exists some order of rows of matrix $$$a$$$ that it produces a $$$k$$$-acceptable traversal.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 16$$$, $$$1 \le m \le 10^4$$$, $$$2 \le nm$$$) — the number of rows and the number of columns, respectively.
Each of the next $$$n$$$ lines contains $$$m$$$ integers ($$$1 \le a_{i, j} \le 10^9$$$) — the description of the matrix.
Print a single integer $$$k$$$ — the maximum number such that there exists some order of rows of matrix $$$a$$$ that it produces an $$$k$$$-acceptable traversal.
In the first example you can rearrange rows as following to get the $$$5$$$-acceptable traversal:
Then the sequence $$$s$$$ will be $$$[5, 10, 4, 9, 3, 8, 3, 9]$$$. Each pair of neighbouring elements have at least $$$k = 5$$$ difference between them.
","input
In the second example the maximum $$$k = 0$$$, any order is $$$0$$$-acceptable.
output
In the third example the given order is already $$$3$$$-acceptable, you can leave it as it is.
","binarysearch, bitmasks, bruteforce, dp, graphs",7
"/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.* ;
import java.io.* ;
import java.math.* ;
/************************
 *                      *
 *    Lord Klotski      *
 *                      *
 ***********************/
public class C
{
    static int[] arr ; static int L ;
    public static void rotate()
    {
        int tmp = arr[0] ;
        for (int i = 1 ; i < L ; i ++)
            arr[i-1] = arr[i] ;
        arr[L-1] = tmp ;
    }

    public static void main(String[] args)
    {
        Scanner input = new Scanner(System.in) ;

        L = input.nextInt() ; String s = input.next() ;
        arr = new int[L]; for (int i = 0 ; i < L ; i ++) {arr[i] = s.charAt(i) == 'H' ? 1 : 0 ;}

        // want to find longest sequence of 1s
        // then rotate to head
        int count = 99999 ;
        for (int A = 0; A < L ; A ++)
        {
            int[] tmp = new int[L] ; System.arraycopy(arr, 0, tmp, 0, arr.length);
            int ans = 0 ;
            for (int i = 0 ; i < L ; i ++)
            {
                if (tmp[i] == 1) continue ;
                for (int j = L-1 ; j > i ; j --)
                {
                    if (tmp[j] == 0) continue ;
                    ans ++ ;
                    tmp[i] = 1 ; tmp[j] = 0 ;
                    //System.out.println(""SWAP "" + i + "" "" + j);
                    //for (int k = 0 ; k < L ; k ++)
                    //    System.out.print(arr[k]);
                    //System.out.println("""");
                    break;
                }
            }
            count = Math.min(count,ans) ;
            rotate() ;
        }
        // rotate until j is at the front
        System.out.println(count);

    }
}
",0046_C,CODEFORCES,1602,Hamsters and Tigers,"Today there is going to be an unusual performance at the circus — hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.
The first line contains number n (2 ≤ n ≤ 1000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols ""H"" and ""T"". The ""H""s correspond to hamsters and the ""T""s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.
","input
Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.
output
In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then — the tiger in position 9 with the hamster in position 7.
",twopointers,3
"import java.io.*;
import java.util.*;

public class Solution {
	
	private BufferedReader in;
	private PrintWriter out;
	private StringTokenizer st;

	void solve() throws IOException {
		int n = nextInt();
		int k = nextInt();
		ArrayList<Integer> ps = new ArrayList<Integer>();
		boolean[] prime = new boolean[n + 1];
		Arrays.fill(prime, true);
		prime[0] = prime[1] = false;
		for (int i = 2; i <= n; ++i) {
			if (prime[i]) {
				ps.add(i);
				for (int j = 2 * i; j <= n; j += i) {
					prime[j] = false;
				}
			}
		}
		for (int i = 0; i < ps.size() - 1; ++i) {
			int t = ps.get(i) + ps.get(i + 1) + 1;
			if (t <= n && prime[t]) {
				--k;
			}
		}
//		System.out.println(k);
		out.println(k <= 0 ? ""YES"" : ""NO"");
	}

	Solution() throws IOException {
		in = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		
		eat("""");
		
		solve();
		
		in.close();
		out.close();
	}
	
	private void eat(String str) {
		st = new StringTokenizer(str);
	}
	
	String next() throws IOException {
		while (!st.hasMoreTokens()) {
			String line = in.readLine();
			if (line == null) {
				return null;
			}
			eat(line);
		}
		return st.nextToken();
	}
	
	int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
	
	long nextLong() throws IOException {
		return Long.parseLong(next());
	}
	
	double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}

	public static void main(String[] args) throws IOException {
		new Solution();
	}
}
",0017_A,CODEFORCES,1538,Noldbach problem,"Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least k prime numbers from 2 to n inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.
Two prime numbers are called neighboring if there are no other prime numbers between them.
You are to help Nick, and find out if he is right or wrong.
The first line of the input contains two integers n (2 ≤ n ≤ 1000) and k (0 ≤ k ≤ 1000).
","input
Output YES if at least k prime numbers from 2 to n inclusively can be expressed as it was described above. Otherwise output NO.
output
In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.
","bruteforce, math, numbertheory",3
"import java.io.*;
import java.util.*;

public class Solution {

    public static void main(String[] args) throws Exception {
        MyReader reader = new MyReader(System.in);
//        MyReader reader = new MyReader(new FileInputStream(""input.txt""));
        MyWriter writer = new MyWriter(System.out);
        new Solution().run(reader, writer);
        writer.close();
    }

    private void run(MyReader reader, MyWriter writer) throws IOException, InterruptedException {
        int n = reader.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = reader.nextString().charAt(0);
        }
        long[][] d = new long[n + 1][n + 1];
        d[0][0] = 1;
        long mod = 1_000_000_007;
        for (int i = 1; i < n; i++) {
            for (int j = n - 1; j >= 0; j--) {
                if (a[i - 1] == 'f') {
                    d[i][j + 1] = d[i - 1][j];
                } else {
                    d[i][j] = (d[i - 1][j] + d[i][j + 1]) % mod;
                }
            }
        }
        long ans = 0;
        for (int i = 0; i <= n; i++) {
            ans += d[n - 1][i];
        }
        writer.print(ans % mod);
    }

    static class MyReader {

        final BufferedInputStream in;
        final int bufSize = 1 << 16;
        final byte buf[] = new byte[bufSize];
        int i = bufSize;
        int k = bufSize;
        boolean end = false;
        final StringBuilder str = new StringBuilder();

        MyReader(InputStream in) {
            this.in = new BufferedInputStream(in, bufSize);
        }

        int nextInt() throws IOException {
            return (int) nextLong();
        }

        int[] nextIntArray(int n) throws IOException {
            int[] m = new int[n];
            for (int i = 0; i < n; i++) {
                m[i] = nextInt();
            }
            return m;
        }

        int[][] nextIntMatrix(int n, int m) throws IOException {
            int[][] a = new int[n][0];
            for (int j = 0; j < n; j++) {
                a[j] = nextIntArray(m);
            }
            return a;
        }

        long nextLong() throws IOException {
            int c;
            long x = 0;
            boolean sign = true;
            while ((c = nextChar()) <= 32) ;
            if (c == '-') {
                sign = false;
                c = nextChar();
            }
            if (c == '+') {
                c = nextChar();
            }
            while (c >= '0') {
                x = x * 10 + (c - '0');
                c = nextChar();
            }
            return sign ? x : -x;
        }

        long[] nextLongArray(int n) throws IOException {
            long[] m = new long[n];
            for (int i = 0; i < n; i++) {
                m[i] = nextLong();
            }
            return m;
        }

        int nextChar() throws IOException {
            if (i == k) {
                k = in.read(buf, 0, bufSize);
                i = 0;
            }
            return i >= k ? -1 : buf[i++];
        }

        String nextString() throws IOException {
            if (end) {
                return null;
            }
            str.setLength(0);
            int c;
            while ((c = nextChar()) <= 32 && c != -1) ;
            if (c == -1) {
                end = true;
                return null;
            }
            while (c > 32) {
                str.append((char) c);
                c = nextChar();
            }
            return str.toString();
        }

        String nextLine() throws IOException {
            if (end) {
                return null;
            }
            str.setLength(0);
            int c = nextChar();
            while (c != '\n' && c != '\r' && c != -1) {
                str.append((char) c);
                c = nextChar();
            }
            if (c == -1) {
                end = true;
                if (str.length() == 0) {
                    return null;
                }
            }
            if (c == '\r') {
                nextChar();
            }
            return str.toString();
        }

        char[] nextCharArray() throws IOException {
            return nextString().toCharArray();
        }

        char[][] nextCharMatrix(int n) throws IOException {
            char[][] a = new char[n][0];
            for (int i = 0; i < n; i++) {
                a[i] = nextCharArray();
            }
            return a;
        }
    }

    static class MyWriter {

        final BufferedOutputStream out;
        final int bufSize = 1 << 16;
        final byte buf[] = new byte[bufSize];
        int i = 0;
        final byte c[] = new byte[30];
        static final String newLine = System.getProperty(""line.separator"");

        MyWriter(OutputStream out) {
            this.out = new BufferedOutputStream(out, bufSize);
        }

        void print(long x) throws IOException {
            int j = 0;
            if (i + 30 >= bufSize) {
                flush();
            }
            if (x < 0) {
                buf[i++] = (byte) ('-');
                x = -x;
            }
            while (j == 0 || x != 0) {
                c[j++] = (byte) (x % 10 + '0');
                x /= 10;
            }
            while (j-- > 0)
                buf[i++] = c[j];
        }

        void print(int[] m) throws IOException {
            for (int a : m) {
                print(a);
                print(' ');
            }
        }

        void print(long[] m) throws IOException {
            for (long a : m) {
                print(a);
                print(' ');
            }
        }

        void print(String s) throws IOException {
            for (int i = 0; i < s.length(); i++) {
                print(s.charAt(i));
            }
        }

        void print(char x) throws IOException {
            if (i == bufSize) {
                flush();
            }
            buf[i++] = (byte) x;
        }

        void print(char[] m) throws IOException {
            for (char c : m) {
                print(c);
            }
        }

        void println(String s) throws IOException {
            print(s);
            println();
        }

        void println() throws IOException {
            print(newLine);
        }

        void flush() throws IOException {
            out.write(buf, 0, i);
            out.flush();
            i = 0;
        }

        void close() throws IOException {
            flush();
            out.close();
        }
    }
}",0909_C,CODEFORCES,3077,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Gaurav
 */import java.io.*;
public class a23 {
    public static void main(String arg[])throws IOException
    {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));




          String s=br.readLine();int max=0;
          for(int i=0;i<s.length();i++)
          {
              for(int j=i+1;j<=s.length();j++)
              {
                  String g=s.substring(i,j);
                  //System.out.println(g);
                  if(max<g.length())
                  for(int k=i+1;k<=s.length()-g.length();k++)
                  {
                      //System.out.println(s.substring(k,k+g.length()));
                      if(g.compareTo(s.substring(k,k+g.length()))==0)
                      {
                          max=g.length();
                          break;
                      }
                      }
              }
          }
          System.out.println(max);
}
}
",0023_A,CODEFORCES,3792,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class A
{
    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer st = null;

    private void solve() throws IOException
    {
        int n = nextInt();
        int k = nextInt();
        int p[] = new int[n];
        int t[] = new int[n];
        for(int i = 0; i < n; i++)
        {
            p[i] = nextInt();
            t[i] = nextInt();
        }
        
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                if(p[i] < p[j] || (p[i] == p[j] && t[i] > t[j]))
                {
                    int tmp = p[i];
                    p[i] = p[j];
                    p[j] = tmp;
                    tmp = t[i];
                    t[i] = t[j];
                    t[j] = tmp;
                }
            }
            
        }
        
        int pN = p[k - 1];
        int tN = t[k - 1];
        int counter = 0;
        for(int i = 0; i < n; i++)
        {
            if(p[i] == pN && t[i] == tN)
            {
                counter++;
            }
            
        }
        
        System.out.println(counter);
    }

    String nextToken() throws IOException
    {
        if (st == null || !st.hasMoreTokens())
        {
            st = new StringTokenizer(bf.readLine());
        }
        
        return st.nextToken();
    }

    int nextInt() throws IOException
    {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException
    {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException
    {
        return Double.parseDouble(nextToken());
    }

    public static void main(String args[]) throws IOException
    {
        new A().solve();
    }
    
}",0166_A,CODEFORCES,2515,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"import java.io.*;
import java.util.*;

public class E2 {
    static ArrayList<Integer> primes;
    static int[] mind;
    final static int MAXA = (int) 1e7;

    public static void main(String[] args) throws IOException {
        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(f.readLine());
        int t = Integer.parseInt(st.nextToken());
        primes = new ArrayList<>();
        mind = new int[MAXA + 1];
        for (int i = 2; i <= MAXA; i++) {
            if (mind[i] == 0) {
                primes.add(i);
                mind[i] = i;
            }
            for (int x : primes) {
                if (x > mind[i] || x * i > MAXA) break;
                mind[x * i] = x;
            }
        }
        int[] count = new int[MAXA + 1];
        for (int on8y = 0; on8y < t; on8y++) {
            st = new StringTokenizer(f.readLine());
            int n = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());
            int[] a = new int[n];
            Arrays.fill(a, 1);
            st = new StringTokenizer(f.readLine());
            for (int i = 0; i < n; i++) {
                int x = Integer.parseInt(st.nextToken());
                int cnt = 0;
                int last = 0;
                while (x > 1) {
                    int p = mind[x];
                    if (last == p) cnt++;
                    else {
                        if (cnt % 2 == 1) a[i] *= last;
                        last = p;
                        cnt = 1;
                    }
                    x /= p;
                }
                if (cnt % 2 == 1) a[i] *= last;
            }
            int[][] mnleft = new int[n][k + 1];
            for (int j = 0; j < k + 1; j++) {
                int l = n;
                int now = 0;
                for (int i = n - 1; i >= 0; i--) {
                    while (l - 1 >= 0 && now + ((count[a[l - 1]] > 0) ? 1 : 0) <= j) {
                        l--;
                        now += (count[a[l]] > 0) ? 1 : 0;
                        count[a[l]]++;
                    }
                    mnleft[i][j] = l;
                    if (count[a[i]] > 1) now--;
                    count[a[i]]--;
                }
            }
            int[][] dp = new int[n + 1][k + 1];
            for (int i = 0; i < n + 1; i++) {
                Arrays.fill(dp[i], (int) 1e9 + 1);
            }
            for (int i = 0; i < k + 1; i++) dp[0][i] = 0;
            for (int i = 1; i <= n; i++) {
                for (int j = 0; j <= k; j++) {
                    if (j > 0) dp[i][j] = dp[i][j - 1];
                    for (int lst = 0; lst <= j; lst++) {
                        dp[i][j] = Math.min(dp[i][j], dp[mnleft[i - 1][lst]][j - lst] + 1);
                    }
                }
            }
            int ans = (int) 1e9 + 1;
            for (int c : dp[n]) ans = Math.min(ans, c);
            System.out.println(ans);

        }
    }
}


",1497_E2,CODEFORCES,4090,Square-Free Division (hard version),"This is the hard version of the problem. The only difference is that in this version $$$0 \leq k \leq 20$$$.
There is an array $$$a_1, a_2, \ldots, a_n$$$ of $$$n$$$ positive integers. You should divide it into a minimal number of continuous segments, such that in each segment there are no two numbers (on different positions), whose product is a perfect square.
Moreover, it is allowed to do at most $$$k$$$ such operations before the division: choose a number in the array and change its value to any positive integer.
What is the minimum number of continuous segments you should use if you will make changes optimally?
The first line contains a single integer $$$t$$$ $$$(1 \le t \le 1000)$$$  — the number of test cases.
The first line of each test case contains two integers $$$n$$$, $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$0 \leq k \leq 20$$$).
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 10^7$$$).
It's guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \cdot 10^5$$$.
For each test case print a single integer  — the answer to the problem.
","input
In the first test case it is possible to change the array this way: $$$[\underline{3}, 6, 2, 4, \underline{5}]$$$ (changed elements are underlined). After that the array does not need to be divided, so the answer is $$$1$$$.
output
In the second test case it is possible to change the array this way: $$$[6, 2, \underline{3}, 8, 9, \underline{5}, 3, 6, \underline{10}, \underline{11}, 7]$$$. After that such division is optimal: 
","datastructures, dp, greedy, math, numbertheory, twopointers",6
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Codeforces {
    
    static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader() 
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 

    public static void main(String[] args) {
        FastReader input = new FastReader();
        long n = input.nextLong();
        long K = input.nextLong();
        long root = (long) Math.sqrt(8 * (K+n) + 9);
        if (root * root != 8 * (K+n) + 9){
            root++;
            if (root * root != 8 * (K+n) + 9) root -= 2;
        }
        System.out.println(n - (root - 3) / 2);
        
        
    }
}",1195_B,CODEFORCES,1439,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import java.util.Scanner;


public class Prob023A
{
    public static void main( String[] Args )
    {
        Scanner scan = new Scanner( System.in );
        String s = scan.next();

        all: for ( int x = s.length() - 1; x >= 0; x-- )
            for ( int y = 0; x + y <= s.length(); y++ )
            {
                String sub = s.substring( y, y + x );
                if ( s.indexOf( sub, y + 1 ) >= 0 )
                {
                    System.out.println( x );
                    break all;
                }
            }
    }
}
",0023_A,CODEFORCES,3694,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

public class CF008C {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int x = s.nextInt();
        int y = s.nextInt();
        int n = s.nextInt();
        int[] xx = new int[n+1];
        int[] yy = new int[n+1];
        for(int i = 0;i<n;i++){
            xx[i] = s.nextInt();
            yy[i] = s.nextInt();
        }
//        int[][] dp = new int[n][n];
//        for(int i = 0;i<n;i++){
//            Arrays.fill(dp[i],-1);
//        }
        xx[n] = x;
        yy[n] = y;
        int[][] dp = new int[n + 1][n + 1];
        for (int i = 0; i <= n; i++)
            for (int j = i + 1; j <= n; j++) {
                int dx = xx[i] - xx[j];
                int dy = yy[i] - yy[j];
                dp[i][j] = dx * dx + dy * dy;
            }
            int[] aa = new int[1 << n];
            int[] bb = new int[1 << n];
            for (int k = 1; k < 1 << n; k++) {
                int a = -1;
                for (int b = 0; b < n; b++)
                    if ((k & 1 << b) > 0) {
                        a = b;
                        break;
                    }
                int l = k ^ 1 << a;
                int d = dp[a][n] + dp[a][n];
                aa[k] = aa[l] + d;
                bb[k] = l;
                for (int b = a + 1; b < n; b++)
                    if ((k & 1 << b) > 0) {
                        l = k ^ 1 << a ^ 1 << b;
                        d = dp[a][n] + dp[b][n] + dp[a][b];
                        if (aa[l] + d < aa[k]) {
                            aa[k] = aa[l] + d;
                            bb[k] = l;
                        }
                    }
            }
            int k = (1 << n) - 1;
            System.out.println(aa[k]);
            StringBuilder sb = new StringBuilder();
            sb.append(0);
            while (k != 0) {
                int l = bb[k];
                int m = k ^ l;
                for (int b = 0; b < n; b++)
                    if ((m & 1 << b) > 0)
                        sb.append(' ').append(b + 1);
                sb.append(' ').append(0);
                k = l;
            }
            System.out.println(sb);
        }
//        int[] distFromOrigin = new int[n];
////        HashMap<Integer,Boolean> map = new HashMap<>();
//        for(int i=0;i<n;i++){
//            distFromOrigin[i] = (int) (Math.pow((xCoord[i] - x),2) + Math.pow(yCoord[i] - y,2));
////            map.put(i,true);
//        }
//        System.out.println(0);
//        long sum = 0;
//        String str = ""0 "";
//
//        while(!map.isEmpty()){
//            int first = 0;
//            int second = Integer.MIN_VALUE;
//            if(map.size() == 1){
//                first = new ArrayList<Integer>(map.keySet()).get(0) + 1;
//                int min = distFromOrigin[first - 1] + distFromOrigin[first - 1];
//                sum += min;
//                map.remove(first - 1);
//            }else {
//                int min = Integer.MAX_VALUE;
//
//                for (int i = 0; i < n; i++) {
//                    for (int j = 0; j <= i; j++) {
//                        if (map.containsKey(i) && map.containsKey(j) && distFromOrigin[i] + distFromOrigin[j] + dp[i][j] < min) {
//                            min = distFromOrigin[i] + distFromOrigin[j] + dp[i][j];
//                            first = i + 1;
//                            if(i == j){
//                                second = Integer.MIN_VALUE;
//                            }else {
//                                second = j + 1;
//                            }
//                        }
//                    }
//                }
//                sum += min;
//                map.remove(first - 1);
//                if(second != Integer.MIN_VALUE){
//                    map.remove(second - 1);
//                }
//            }
//            if(second == Integer.MIN_VALUE){
//                str = str + first + "" "";
//            }else{
//                if(map.size() == 0) {
//                    str = str + first + "" "" + second + "" "";
//                }else{
//                    str = str + first + "" "" + second + "" 0 "";
//                }
//            }
////            System.out.print(first + "" "" + second + "" "");
//        }
//        System.out.println(sum);
//        System.out.println(str + ""0"");
//        int[] ans = new int[(int)Math.pow(2,n)];
//        Arrays.fill(ans,Integer.MAX_VALUE);
//        for(int i = 0;i<Math.pow(2,n);i++){
//            for(int j = 0;j<n;j++){
//                //I can't figure out how to do that.
//            }
//        }
//        System.out.print(sum);
//        System.out.print(0);


    private static int calculateDistanceBetweenIandJ(int[] xCoord, int[] yCoord, int i, int j) {
        int length = (int) (Math.pow((xCoord[i] - xCoord[j]),2) + Math.pow(yCoord[i] - yCoord[j], 2));
        return length;
    }
}
",0008_C,CODEFORCES,4339,Looking for Order,"Girl Lena likes it when everything is in order, and looks for order everywhere. Once she was getting ready for the University and noticed that the room was in a mess — all the objects from her handbag were thrown about the room. Of course, she wanted to put them back into her handbag. The problem is that the girl cannot carry more than two objects at a time, and cannot move the handbag. Also, if he has taken an object, she cannot put it anywhere except her handbag — her inherent sense of order does not let her do so.
You are given the coordinates of the handbag and the coordinates of the objects in some Сartesian coordinate system. It is known that the girl covers the distance between any two objects in the time equal to the squared length of the segment between the points of the objects. It is also known that initially the coordinates of the girl and the handbag are the same. You are asked to find such an order of actions, that the girl can put all the objects back into her handbag in a minimum time period.
The first line of the input file contains the handbag's coordinates xs, ys. The second line contains number n (1 ≤ n ≤ 24) — the amount of objects the girl has. The following n lines contain the objects' coordinates. All the coordinates do not exceed 100 in absolute value. All the given positions are different. All the numbers are integer.
","input
In the first line output the only number — the minimum time the girl needs to put the objects into her handbag. 
output
In the second line output the possible optimum way for Lena. Each object in the input is described by its index number (from 1 to n), the handbag's point is described by number 0. The path should start and end in the handbag's point. If there are several optimal paths, print any of them. 
","bitmasks, dp",7
"import java.io.*;
import java.lang.reflect.Array;
import java.util.*;
 
public class Main {
 
	private BufferedReader input;
	private PrintWriter output;
	private StringTokenizer stoken;
 
	String fin = ""input"";
	String fout = ""output"";
 
 
	private void solve() {

		long a = nextInt();
		
		long res = (a / 2) * 3;

		output.print(res);
		
	}
 
 
 
	Main() throws IOException {
		//input = new BufferedReader(new FileReader(fin + "".txt""));
		//output = new PrintWriter(new FileWriter(fout + "".txt""));
		input = new BufferedReader(new InputStreamReader(System.in));
		output = new PrintWriter(System.out);
 
 
		solve();
 
		input.close();
		output.flush();
		output.close();
	}
 
 
	int nextInt() {
		return Integer.parseInt(nextToken());
	}
 
	long nextLong() {
		return Long.parseLong(nextToken());
	}
 
	double nextFloat() {
		return Float.parseFloat(nextToken());
	}
 
	double nextDouble() {
		return Double.parseDouble(nextToken());
	}
 
	String nextToken() {
		while ((stoken == null) || (!stoken.hasMoreTokens())) {
			try {
				String line = input.readLine();
				stoken = new StringTokenizer(line);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return stoken.nextToken();
	}
 
 
 
	public static void main(String[] args) throws IOException {
		new Main();
	}
 
}


class Tarif {
	public int abPlata;
	public int tMin;
	public int price;
	public long res;
}",0084_A,CODEFORCES,58,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"import java.util.*;
import java.io.*;
import java.awt.Point;
import java.math.BigInteger;

public class stacks {

	public static void main(String[] args) throws Exception {
		FastIO sc = new FastIO(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		
		int n = sc.nextInt();
		int m = sc.nextInt();
		
		long remove = 0;
		
		int[] heights = new int[n+1];
		
		for(int i = 0; i < n; i++) {
			heights[i] = sc.nextInt();
			remove += heights[i];
		}
		
		Arrays.sort(heights);
		//System.out.println(Arrays.toString(heights));
		long keep = 0;
		for(int i = n; i> 0; i--) {
			if(heights[i-1] >= heights[i]) {
				heights[i-1] = heights[i]-1;
			}
			keep += heights[i] - heights[i-1];
		}
		//System.out.println(Arrays.toString(heights));
		
		pw.println(remove - keep);
		pw.close();
	}

	static class FastIO {

		//Is your Fast I/O being bad?

		InputStream dis;
		byte[] buffer = new byte[1 << 17];
		int pointer = 0;

		public FastIO(String fileName) throws Exception {
			dis = new FileInputStream(fileName);
		}

		public FastIO(InputStream is) throws Exception {
			dis = is;
		}

		int nextInt() throws Exception {
			int ret = 0;

			byte b;
			do {
				b = nextByte();
			} while (b <= ' ');
			boolean negative = false;
			if (b == '-') {
				negative = true;
				b = nextByte();
			}
			while (b >= '0' && b <= '9') {
				ret = 10 * ret + b - '0';
				b = nextByte();
			}

			return (negative) ? -ret : ret;
		}

		long nextLong() throws Exception {
			long ret = 0;

			byte b;
			do {
				b = nextByte();
			} while (b <= ' ');
			boolean negative = false;
			if (b == '-') {
				negative = true;
				b = nextByte();
			}
			while (b >= '0' && b <= '9') {
				ret = 10 * ret + b - '0';
				b = nextByte();
			}

			return (negative) ? -ret : ret;
		}

		byte nextByte() throws Exception {
			if (pointer == buffer.length) {
				dis.read(buffer, 0, buffer.length);
				pointer = 0;
			}
			return buffer[pointer++];
		}

		String next() throws Exception {
			StringBuffer ret = new StringBuffer();

			byte b;
			do {
				b = nextByte();
			} while (b <= ' ');
			while (b > ' ') {
				ret.appendCodePoint(b);
				b = nextByte();
			}

			return ret.toString();
		}

	}
}
",1061_B,CODEFORCES,2888,Views Matter,"You came to the exhibition and one exhibit has drawn your attention. It consists of $$$n$$$ stacks of blocks, where the $$$i$$$-th stack consists of $$$a_i$$$ blocks resting on the surface.
The height of the exhibit is equal to $$$m$$$. Consequently, the number of blocks in each stack is less than or equal to $$$m$$$.
There is a camera on the ceiling that sees the top view of the blocks and a camera on the right wall that sees the side view of the blocks.
Find the maximum number of blocks you can remove such that the views for both the cameras would not change.
Note, that while originally all blocks are stacked on the floor, it is not required for them to stay connected to the floor after some blocks are removed. There is no gravity in the whole exhibition, so no block would fall down, even if the block underneath is removed. It is not allowed to move blocks by hand either.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 100\,000$$$, $$$1 \le m \le 10^9$$$) — the number of stacks and the height of the exhibit.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le m$$$) — the number of blocks in each stack from left to right.
Print exactly one integer — the maximum number of blocks that can be removed.
","input
The following pictures illustrate the first example and its possible solution.
output
Blue cells indicate removed blocks. There are $$$10$$$ blue cells, so the answer is $$$10$$$.
","greedy, implementation, sortings",4
"import java.io.*;
import java.util.*;

public class practice {

		public static void main(String[] args) throws FileNotFoundException {			
			Scanner scn = new Scanner(new FileReader(""input.txt""));
			PrintWriter out = new PrintWriter(new File(""output.txt""));
		 int n=scn.nextInt(),m=scn.nextInt(),k=scn.nextInt();
		 int[][] inf=new int[k][2];
		 for(int i=0;i<k;i++){
			 inf[i][0]=scn.nextInt();inf[i][1]=scn.nextInt();
		 }
		 int ans=0,x=1,y=1;
		 for(int i=1;i<=n;i++){
			 for(int j=1;j<=m;j++){
				 int temp=Integer.MAX_VALUE;
				 for(int l=0;l<k;l++){
					temp=Math.min(temp, Math.abs(i-inf[l][0])+Math.abs(j-inf[l][1])); 
				 }
				 if(temp>ans){
					 ans=temp;x=i;y=j;
				 }
			 }
		 }
		 out.print(x+ "" "" + y);
	   	 out.close();
		}
	}

",0035_C,CODEFORCES,3946,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"import java.io.*;
import java.util.Scanner;
import java.lang.String;
public class A23 {
    public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    String s = in.nextLine();
    int i=0,j=0,n=0,t=0,count=0;
    n=s.length();
    String s1=""y"",s2=""yu6j"";
    for(t=1;t<n;t++)
        {
        for(i=0;i<t;i++)
            {
            s1=s.substring(i,i+n-t);
            for(j=i+1;j<=t;j++)
                {
                s2=s.substring(j,j+n-t);
                if(s1.equalsIgnoreCase(s2))
                    {
                    count++;break;
                    }
                if(count==1) break;
                }
            if(count==1) break;
            }
        if(count==1) break;
        }
	if(n==0)
		{
	  System.out.println(""0"");
		}
	else
	{
    if(count==1)
    {
    System.out.println(s1.length());
    }
    else  System.out.println(""0"");
    }
	}
}",0023_A,CODEFORCES,3767,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.io.*;
import java.util.*;

public class Codeforces913F {
	public static void main(String[] args) throws IOException {
		Scanner input = new Scanner(System.in);
		int n = input.nextInt();
		int a = input.nextInt();
		int b = input.nextInt();
		input.close();
		final int mod = 998244353;
		
		int frac = multiply(a, inverse(b, mod), mod);
		int reverse = (mod+1-frac)%mod;
		
		int[] fracpower = new int[n+1];
		int[] reversepower = new int[n+1];
		fracpower[0] = 1;
		reversepower[0] = 1;
		for (int i = 1; i <= n; i++) {
			fracpower[i] = multiply(fracpower[i-1], frac, mod);
			reversepower[i] = multiply(reversepower[i-1], reverse, mod);
		}
		
		int[][] dp1 = new int[n+1][n+1];
		dp1[2][1] = 1;
		for (int i = 3; i <= n; i++) {
			for (int j = 1; j < i; j++) {
				if (j == 1) {
					dp1[i][j] = fracpower[i-1];
				}
				else {
					dp1[i][j] = multiply(dp1[i-1][j-1], fracpower[i-j], mod);
				}
				if (j == i-1) {
					dp1[i][j] += reversepower[i-1];
					dp1[i][j] %= mod;
				}
				else {
					dp1[i][j] += multiply(dp1[i-1][j], reversepower[j], mod);
					dp1[i][j] %= mod;
				}
			}
		}
		
		int[][] dp2 = new int[n+1][n+1];
		dp2[1][1] = 1;
		dp2[2][1] = 1;
		dp2[2][2] = 0;
		for (int i = 3; i <= n; i++) {
			int val = 0;
			for (int j = 1; j < i; j++) {
				dp2[i][j] = multiply(dp2[j][j], dp1[i][j], mod);
				val += dp2[i][j];
				val %= mod;
			}
			dp2[i][i] = (mod+1-val)%mod;
		}
		
		/*for (int i = 2; i <= n; i++) {
			for (int j = 1; j <= i; j++) {
				System.out.print(dp2[i][j] + "" "");
			}
			System.out.println();
		}*/
		
		int[] EV = new int[n+1];
		EV[1] = 0;
		EV[2] = 1;
		for (int i = 3; i <= n; i++) {
			int val = 0;
			for (int j = 1; j < i; j++) {
				int r = j*(i-j) + (j*(j-1))/2 + EV[i-j] + EV[j];
				r %= mod;
				val += multiply(dp2[i][j], r, mod);
				val %= mod;
			}
			val += multiply((i*(i-1))/2, dp2[i][i], mod);
			val %= mod;
			
			int s = (mod+1-dp2[i][i])%mod;
			EV[i] = multiply(val, inverse(s, mod), mod);
		}
		
		System.out.println(EV[n]);
	}
	
	public static int multiply(int a, int b, int mod) {
		long x = (long)a*(long)b;
		return (int) (x%mod);
	}
	
	public static int inverse (int a, int n) {
		int m = n;
		int r1 = 1;
		int r2 = 0;
		int r3 = 0;
		int r4 = 1;
		while ((a > 0) && (n > 0)) {
			if (n >= a) {
				r3 -= r1*(n/a);
				r4 -= r2*(n/a);
				n = n%a;
			}
			else {
				int tmp = a;
				a = n;
				n = tmp;
				tmp = r1;
				r1 = r3;
				r3 = tmp;
				tmp = r2;
				r2 = r4;
				r4 = tmp;
			}
		}
		if (a == 0) {
			if (r3 >= 0)
				return (r3%m);
			else
				return (m+(r3%m));
		}
		else {
			if (r1 >= 0)
				return (r1%m);
			else
				return (m+(r1%m));
		}

	}
}",0913_F,CODEFORCES,3245,Strongly Connected Tournament,"There is a chess tournament in All-Right-City. n players were invited to take part in the competition. The tournament is held by the following rules:
The players are enumerated with integers from 1 to n. The enumeration was made using results of a previous tournament. It is known that player i wins player j (i < j) with probability p.
You need to help to organize the tournament. Find the expected value of total number of games played by all the players. 
It can be shown that the answer can be represented as , where P and Q are coprime integers and . Print the value of P·Q - 1 modulo 998244353.
If you are not familiar with any of the terms above, you can read about them here.
The first line of input contains a single integer n (2 ≤ n ≤ 2000) — the number of players.
The second line contains two integers a and b (1 ≤ a < b ≤ 100) — the numerator and the denominator of fraction .
In the only line print the expected value of total number of games played by all the players. Print the answer using the format above.
In the first example the expected value is 4.
","input
In the second example the expected value is .
output
In the third example the expected value is .
","dp, graphs, math, probabilities",5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            int n = in.nextInt();
            int r = in.nextInt();
            int[] xs = new int[n];
            for (int i = 0; i < n; i++) xs[i] = in.nextInt();
            double[] ys = new double[n];
            for (int i = 0; i < n; i++) {
                int x = xs[i];
                double y = r;
                for (int j = 0; j < i; j++) {
                    y = Math.max(y, calc(xs[j], ys[j], x, r));
                }
                ys[i] = y;
            }
            for (int i = 0; i < n; i++) {
                out.printf(""%.10f "", ys[i]);
            }
            out.println();
        }

        private double calc(int x, double y, int x1, int r) {
            int dx = Math.abs(x - x1);
            if (dx > 2 * r) return 0;
            double dy = Math.sqrt(4 * r * r - dx * dx);
            return y + dy;
        }

    }

    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        public Scanner(InputStream in) {
            br = new BufferedReader(new InputStreamReader(in), 32768);
        }

        public String nextLine() {
            try {
                return br.readLine();
            } catch (IOException e) {
                return null;
            }
        }

        public boolean hasNext() {
            while (st == null || !st.hasMoreTokens()) {
                String s = nextLine();
                if (s == null)
                    return false;
                st = new StringTokenizer(s);
            }
            return true;
        }

        public String next() {
            hasNext();
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",0908_C,CODEFORCES,2948,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"import java.util.HashMap;

import java.util.Map;

import java.util.Scanner;



public class forces {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);



		int n = sc.nextInt();

		

		while (n-- > 0) {

			String coor = sc.next();

			String str = """";

			if (coor.matches(""R[0-9]+C[0-9]+"")) {

				String temp[] = coor.replaceAll(""R|C"", "" "").trim().split("" "");

				int a = new Integer(temp[1]);

				while (a > 0) {

					a--;

					str = (char)(a%26 + 'A') + str;

					a /= 26;

				}

				System.out.println(str+temp[0]);

			} else {

				String temp1 = coor.replaceAll(""[0-9]"", """");

				int num = 0;

				for(int i = 0; i<temp1.length(); i++) {

					num = num * 26 + temp1.charAt(i) - 'A' + 1;

				}

				System.out.println(""R"" + coor.replaceAll(""[A-Z]"", """") + ""C"" + num);

			}

		}

	}

}

",0001_B,CODEFORCES,1478,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math",3
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        E solver = new E();
        solver.solve(1, in, out);
        out.close();
    }

    static class E {
        public void solve(int testNumber, FastScanner in, PrintWriter out) {
            int n = in.ni(), K = in.ni();
            long mod = 998244353;
            long[][] dp = new long[n + 1][n + 1];
            for (int lim = 1; lim <= n; lim++) {
                long sum = 1;
                dp[0][lim] = 1;
                for (int i = 1; i <= n; i++) {
                    dp[i][lim] = (dp[i][lim] + sum) % mod;
                    sum = (sum + dp[i][lim]) % mod;
                    if (i >= lim)
                        sum = (sum - dp[i - lim][lim] + mod) % mod;
                }
            }
            long ans = 0;
            for (int k = 1; k < Math.min(K, n + 1); k++) {
                long h = dp[n][k] - dp[n][k - 1];
                int lim = K / k;
                if (K % k == 0)
                    lim--;
                if (lim > n)
                    lim = n;
                ans += dp[n][lim] * h % mod;
            }
            out.println(2 * ans % mod);
        }

    }

    static class FastScanner {
        private BufferedReader in;
        private StringTokenizer st;

        public FastScanner(InputStream stream) {
            in = new BufferedReader(new InputStreamReader(stream));
        }

        public String ns() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    String rl = in.readLine();
                    if (rl == null) {
                        return null;
                    }
                    st = new StringTokenizer(rl);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        public int ni() {
            return Integer.parseInt(ns());
        }

    }
}

",1027_E,CODEFORCES,3293,Inverse Coloring,"You are given a square board, consisting of $$$n$$$ rows and $$$n$$$ columns. Each tile in it should be colored either white or black.
Let's call some coloring beautiful if each pair of adjacent rows are either the same or different in every position. The same condition should be held for the columns as well.
Let's call some coloring suitable if it is beautiful and there is no rectangle of the single color, consisting of at least $$$k$$$ tiles.
Your task is to count the number of suitable colorings of the board of the given size.
Since the answer can be very large, print it modulo $$$998244353$$$.
A single line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 500$$$, $$$1 \le k \le n^2$$$) — the number of rows and columns of the board and the maximum number of tiles inside the rectangle of the single color, respectively.
Print a single integer — the number of suitable colorings of the board of the given size modulo $$$998244353$$$.
Board of size $$$1 \times 1$$$ is either a single black tile or a single white tile. Both of them include a rectangle of a single color, consisting of $$$1$$$ tile.
","input
Here are the beautiful colorings of a board of size $$$2 \times 2$$$ that don't include rectangles of a single color, consisting of at least $$$3$$$ tiles:
output
The rest of beautiful colorings of a board of size $$$2 \times 2$$$ are the following:
","combinatorics, dp, math",5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author George Marcus
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        long N = in.nextLong();
        long K = in.nextLong();

        if(N == 1) {
            out.println(0);
            return;
        }
        if(N <= K) {
            out.println(1);
            return;
        }

        long st = 1;
        long dr = K - 1;
        long m;
        long ans = -1;

        while(st <= dr) {
            m = (st + dr) / 2;

            if(get(m, K) <= N) {
                ans = m;
                st = m + 1;
            }
            else dr = m - 1;
        }

        N -= get(ans, K);

        if(ans == -1 || (ans == K - 1 && N > 0) ) {
            out.println(-1);
            return;
        }
        if(N > 0)
            ans++;

        out.println(ans);
    }

    private long get(long p, long K) {
        long sum = (K - p + 1 + K) * p / 2;
        long extra = p - 1;
        return sum - extra;
    }
}

class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public long nextLong() {
        return Long.parseLong(nextString());
    }

    public String nextString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuffer res = new StringBuffer();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    private boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    }

",0287_B,CODEFORCES,916,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.util.Scanner;

public class _0555Antipalindrome {
	
	
	static boolean isPalindrome(String s) {
		return s.equals(new StringBuilder(s).reverse().toString());
	}
	
	static int largestSubString(String str) {
	//	System.out.println(str);
		if(!isPalindrome(str)) {
			return str.length();
		}
		if(str.length()==1) {
			return 0;
		}
		
		int input1=largestSubString(str.substring(1));
		int input2=largestSubString(str.substring(0,str.length()-1));
		return Math.max(input1, input2);
	}
	

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		String s=sc.nextLine();
		String temp=s.replaceAll(s.charAt(0)+"""","""");
		if(temp.length()==0) {
			System.out.println(0);
		}
		else {
		System.out.println(largestSubString(s));
		}
		
	}

}
",0981_A,CODEFORCES,1875,Antipalindrome,"A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.
A substring $$$s[l \ldots r]$$$ ($$$1 \leq l \leq r \leq |s|$$$) of a string $$$s = s_{1}s_{2} \ldots s_{|s|}$$$ is the string $$$s_{l}s_{l + 1} \ldots s_{r}$$$.
Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $$$s$$$ is changed into its longest substring that is not a palindrome. If all the substrings of $$$s$$$ are palindromes, she skips the word at all.
Some time ago Ann read the word $$$s$$$. What is the word she changed it into?
The first line contains a non-empty string $$$s$$$ with length at most $$$50$$$ characters, containing lowercase English letters only.
If there is such a substring in $$$s$$$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $$$0$$$.
Note that there can be multiple longest substrings that are not palindromes, but their length is unique.
""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $$$3$$$.
","input
The string ""uffuw"" is one of the longest non-palindrome substrings (of length $$$5$$$) of the string ""wuffuw"", so the answer for the second example is $$$5$$$.
output
All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $$$0$$$.
","bruteforce, implementation, strings",3
"//package round8;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;

public class C {
	InputStream is;
	PrintWriter out;
	String INPUT = """";
	
	void solve()
	{
		int x = ni(), y = ni();
		int n = ni();
		int[][] co = new int[n][];
		for(int i = 0;i < n;i++){
			co[i] = new int[]{ni()-x, ni()-y};
		}
		
		int[] c1 = new int[n];
		int[][] c2 = new int[n][n];
		for(int i = 0;i < n;i++){
			c1[i] = (co[i][0]*co[i][0]+co[i][1]*co[i][1])*2;
		}
		for(int i = 0;i < n;i++){
			for(int j = i+1;j < n;j++){
				c2[i][j] = c2[j][i] = (co[i][0]*co[i][0]+co[i][1]*co[i][1])+(co[j][0]*co[j][0]+co[j][1]*co[j][1])+(co[j][0]-co[i][0])*(co[j][0]-co[i][0])+(co[j][1]-co[i][1])*(co[j][1]-co[i][1]);
			}
		}
		
		int[] dp = new int[1<<n];
		int[] prev = new int[1<<n];
		prev[0] = -1;
		for(int i = 1;i < 1<<n;i++){
			int a = Integer.numberOfTrailingZeros(i);
			dp[i] = c1[a] + dp[i^1<<a];
			prev[i] = 1<<a;
			for(int j = a+1;j < n;j++){
				if(i<<31-j<0){
					int v = dp[i^1<<a^1<<j] + c2[a][j];
					if(v < dp[i]){
						dp[i] = v;
						prev[i] = 1<<a^1<<j;
					}
				}
			}
		}
		out.println(dp[(1<<n)-1]);
		int cur = (1<<n)-1;
		out.print(""0"");
		while(true){
			int targ;
			if(prev[cur] == -1){
				targ = cur;
			}else{
				targ = prev[cur];
				cur ^= prev[cur];
			}
			int a = Integer.numberOfTrailingZeros(targ);
			int b = Integer.numberOfTrailingZeros(targ&targ-1);
			if(targ == 1<<a){
				out.print("" "" + (a+1));
			}else{
				out.print("" "" + (a+1));
				out.print("" "" + (b+1));
			}
			out.print("" 0"");
			if(cur == 0)break;
		}
		out.println();
	}
	
	void run() throws Exception
	{
//		int n = 24, m = 99999;
//		Random gen = new Random();
//		StringBuilder sb = new StringBuilder();
//		sb.append(0 + "" "" + 0  + "" "" + n + "" "");
//		for(int i = 0;i < n;i++){
//			sb.append(gen.nextInt(100) + "" "");
//			sb.append(gen.nextInt(100) + "" "");
//		}
//		INPUT = sb.toString();
		
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception
	{
		new C().run();
	}
	
	public int ni()
	{
		try {
			int num = 0;
			boolean minus = false;
			while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));
			if(num == '-'){
				num = 0;
				minus = true;
			}else{
				num -= '0';
			}
			
			while(true){
				int b = is.read();
				if(b >= '0' && b <= '9'){
					num = num * 10 + (b - '0');
				}else{
					return minus ? -num : num;
				}
			}
		} catch (IOException e) {
		}
		return -1;
	}
	
	public long nl()
	{
		try {
			long num = 0;
			boolean minus = false;
			while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));
			if(num == '-'){
				num = 0;
				minus = true;
			}else{
				num -= '0';
			}
			
			while(true){
				int b = is.read();
				if(b >= '0' && b <= '9'){
					num = num * 10 + (b - '0');
				}else{
					return minus ? -num : num;
				}
			}
		} catch (IOException e) {
		}
		return -1;
	}
	
	public String ns()
	{
		try{
			int b = 0;
			StringBuilder sb = new StringBuilder();
			while((b = is.read()) != -1 && (b == '\r' || b == '\n' || b == ' '));
			if(b == -1)return """";
			sb.append((char)b);
			while(true){
				b = is.read();
				if(b == -1)return sb.toString();
				if(b == '\r' || b == '\n' || b == ' ')return sb.toString();
				sb.append((char)b);
			}
		} catch (IOException e) {
		}
		return """";
	}
	
	public char[] ns(int n)
	{
		char[] buf = new char[n];
		try{
			int b = 0, p = 0;
			while((b = is.read()) != -1 && (b == ' ' || b == '\r' || b == '\n'));
			if(b == -1)return null;
			buf[p++] = (char)b;
			while(p < n){
				b = is.read();
				if(b == -1 || b == ' ' || b == '\r' || b == '\n')break;
				buf[p++] = (char)b;
			}
			return Arrays.copyOf(buf, p);
		} catch (IOException e) {
		}
		return null;
	}
	
	
	double nd() { return Double.parseDouble(ns()); }
	boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",0008_C,CODEFORCES,4316,Looking for Order,"Girl Lena likes it when everything is in order, and looks for order everywhere. Once she was getting ready for the University and noticed that the room was in a mess — all the objects from her handbag were thrown about the room. Of course, she wanted to put them back into her handbag. The problem is that the girl cannot carry more than two objects at a time, and cannot move the handbag. Also, if he has taken an object, she cannot put it anywhere except her handbag — her inherent sense of order does not let her do so.
You are given the coordinates of the handbag and the coordinates of the objects in some Сartesian coordinate system. It is known that the girl covers the distance between any two objects in the time equal to the squared length of the segment between the points of the objects. It is also known that initially the coordinates of the girl and the handbag are the same. You are asked to find such an order of actions, that the girl can put all the objects back into her handbag in a minimum time period.
The first line of the input file contains the handbag's coordinates xs, ys. The second line contains number n (1 ≤ n ≤ 24) — the amount of objects the girl has. The following n lines contain the objects' coordinates. All the coordinates do not exceed 100 in absolute value. All the given positions are different. All the numbers are integer.
","input
In the first line output the only number — the minimum time the girl needs to put the objects into her handbag. 
output
In the second line output the possible optimum way for Lena. Each object in the input is described by its index number (from 1 to n), the handbag's point is described by number 0. The path should start and end in the handbag's point. If there are several optimal paths, print any of them. 
","bitmasks, dp",7
"import java.io.*;
import java.util.*;
import java.math.*;

public class A {
	static BufferedReader in;
	static PrintWriter out;
	static StringTokenizer st;
	static Random  rnd;

	void solve() throws IOException {
		int n = nextInt();

		int[] arr = new int[n];
		Integer[] arrCopy = new Integer[n];

		for (int i = 0; i < n; i++)
			arr[i] = arrCopy[i] = nextInt();

		Arrays.sort(arrCopy);

		int bad = 0;

		for (int i = 0; i < n; i++)
			if (arr[i] != arrCopy[i])
				++bad;

		boolean fail = bad > 2;

		out.println(!fail ? ""YES"" : ""NO"");
	}

	public static void main(String[] args) {
		new A().run();
	}

	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);

			rnd = new Random();

			solve();

			out.close();
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(42);
		}
	}

	String nextToken() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			String line = in.readLine();

			if (line == null)
				return null;

			st = new StringTokenizer(line);
		}

		return st.nextToken();
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}",0220_A,CODEFORCES,2598,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;


public class ProblemA {

	public static void main(String[] args) throws Exception{
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter writer = new PrintWriter(System.out);
		int n = Integer.parseInt(reader.readLine());
		String [] split = reader.readLine().split(""\\s+"");
		int value;
		int [] count = new int[2];
		int [] pos = new int[2];
		for(int i = 0; i < split.length; i++){
			value = Integer.parseInt(split[i]);
			count[value % 2] ++;
			pos[value % 2] = i + 1;
		}
		writer.println((count[0] == 1) ? pos[0] : pos[1]);
		writer.flush();
		writer.close();
	}

}
",0025_A,CODEFORCES,1557,IQ test,"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given n numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given n numbers finds one that is different in evenness.
","input
The first line contains integer n (3 ≤ n ≤ 100) — amount of numbers in the task. The second line contains n space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.
output
Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.
",bruteforce,3
"import java.util.*;
public class TestClass
{
   public static void main(String args[])
   {
   	Scanner in = new Scanner(System.in);
   	int n = in.nextInt();
   	int m = in.nextInt();
   	int k = in.nextInt();
   	int arr[] = new int[n+1];
   	for(int i =0;i<n;i++)
   	 arr[i+1]= in.nextInt();
   	
   	long sum[] = new long [n+1];
   	
   	for(int i=1;i<=n;i++)
   	 sum[i]=sum[i-1]+arr[i];
   	
    long dp[] = new long[n+1];

    for(int i =1;i<=n;i++)
    {
      for(int j=i;j>i-m&&j>=1;j--)
      {
        long val = sum[i]-sum[j-1]+dp[j-1]-k;
        dp[i]= Math.max(dp[i],val);
      }	
    }
    long max =0;
    for(int i =1;i<=n;i++)
     max=Math.max(max,dp[i]);
    
    System.out.println(max);
     
   }	
}",1197_D,CODEFORCES,3440,Yet Another Subarray Problem,"You are given an array $$$a_1, a_2, \dots , a_n$$$ and two integers $$$m$$$ and $$$k$$$.
You can choose some subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$. 
The cost of subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$ is equal to $$$\sum\limits_{i=l}^{r} a_i - k \lceil \frac{r - l + 1}{m} \rceil$$$, where $$$\lceil x \rceil$$$ is the least integer greater than or equal to $$$x$$$. 
The cost of empty subarray is equal to zero.
For example, if $$$m = 3$$$, $$$k = 10$$$ and $$$a = [2, -4, 15, -3, 4, 8, 3]$$$, then the cost of some subarrays are:
Your task is to find the maximum cost of some subarray (possibly empty) of array $$$a$$$.
The first line contains three integers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \le n \le 3 \cdot 10^5, 1 \le m \le 10, 1 \le k \le 10^9$$$).
","input
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$).
output
Print the maximum cost of some subarray of array $$$a$$$.
","dp, greedy, math",5
"import java.text.DecimalFormat;
import java.util.Scanner;

/**
 *
 * @author Alvaro
 */
public class Main{
    public static int n;
    public static double [] dp;
    public static double [][] p;
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        dp = new double[1<<n];
        p = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                p[i][j]= in.nextDouble();                
            }
        }
        for (int i = 0; i <(1<<n); i++) {
            dp[i] = -1;            
        }
        dp[(1<<n)-1]=1;
        DecimalFormat d = new DecimalFormat(""0.000000"");
        System.out.print(d.format(f(1<<0)));
        for (int i = 1; i < n; i++) {
            System.out.print("" ""+d.format(f(1<<i)));
        }
    }
    
    public static double f(int mask) {
        if(dp[mask]>-0.5) return dp[mask];
        dp[mask] = 0;
        int vivos = 1;
        for (int i = 0; i < n; i++) 
            if((mask>>i)%2==1) vivos++;
        double pares = (vivos*(vivos-1))/2;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if((mask&(1<<i))!=0&&(mask&(1<<j))==0){
                    dp[mask]+=f(mask|(1<<j))*p[i][j]/pares;
                }
            }
            
        }
        return dp[mask];
                
    }
       
}
",0016_E,CODEFORCES,4466,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"import java.util.*;
import java.io.*;

public class A
{
    public static void main(String[] args)
    {
        Kattio io = new Kattio(System.in);

        int n = io.getInt();
        int ans = 0;
        int V = n;
        int A = n;

        A -= n/2;
        ans += n/2;

        V -= A;
        ans += A;

        A -= n/2;
        ans += n/2;

        io.println(ans);
        io.flush();
    }
}


class Kattio extends PrintWriter {
    public Kattio(InputStream i) {
	super(new BufferedOutputStream(System.out));
	r = new BufferedReader(new InputStreamReader(i));
    }
    public Kattio(InputStream i, OutputStream o) {
	super(new BufferedOutputStream(o));
	r = new BufferedReader(new InputStreamReader(i));
    }

    public boolean hasMoreTokens() {
	return peekToken() != null;
    }

    public int getInt() {
	return Integer.parseInt(nextToken());
    }

    public double getDouble() { 
	return Double.parseDouble(nextToken());
    }

    public long getLong() {
	return Long.parseLong(nextToken());
    }

    public String getWord() {
	return nextToken();
    }



    private BufferedReader r;
    private String line;
    private StringTokenizer st;
    private String token;

    private String peekToken() {
	if (token == null) 
	    try {
		while (st == null || !st.hasMoreTokens()) {
		    line = r.readLine();
		    if (line == null) return null;
		    st = new StringTokenizer(line);
		}
		token = st.nextToken();
	    } catch (IOException e) { }
	return token;
    }

    private String nextToken() {
	String ans = peekToken();
	token = null;
	return ans;
    }
}
",0084_A,CODEFORCES,62,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"import java.io.*;
import java.util.*;
import java.math.*;

public class D {
	static byte[] buf = new byte[1<<26];
    static int bp = -1;	
	
	public static void main(String[] args) throws IOException {

		/**/
		DataInputStream in = new DataInputStream(System.in);
		/*/
		DataInputStream in = new DataInputStream(new FileInputStream(""src/d.in""));
		/**/
		
		in.read(buf, 0, 1<<26);
		
		int n = nni();
		int m = nni();
		int k = nni();
		
		if (k%2==1) {
			for (int i = 0; i < n; ++i) {
				StringBuilder ans = new StringBuilder();
				String sp = """";
				for (int j = 0; j < m; ++j) {
					ans.append(sp+""-1"");
					sp = "" "";
				}
				System.out.println(ans);
			}
			return;
		}
		
		int[][] lr = new int[n][m-1];
		int[][] ud = new int[n-1][m];
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < m-1; ++j) {
				lr[i][j] = nni();
			}
		}
		for (int i = 0; i < n-1; ++i) {
			for (int j = 0; j < m; ++j) {
				ud[i][j] = nni();
			}
		}
		
		int[][][] ans = new int[k/2+1][n][m];
		
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < m; ++j) {
				for (int q = 1; q <= k/2; ++q) {
					ans[q][i][j] = 123456789;
				}
			}
		}
		
		for (int uq = 0; uq < k/2; ++uq) {
			for (int ui = 0; ui < n; ++ui) {
				for (int uj = 0; uj < m; ++uj) {
					int w = ans[uq][ui][uj];
					if (ui>0 && w+ud[ui-1][uj]<ans[uq+1][ui-1][uj]) {
						ans[uq+1][ui-1][uj] = w+ud[ui-1][uj];
					}
					if (ui<n-1 && w+ud[ui][uj]<ans[uq+1][ui+1][uj]) {
						ans[uq+1][ui+1][uj] = w+ud[ui][uj];
					}
					if (uj>0 && w+lr[ui][uj-1]<ans[uq+1][ui][uj-1]) {
						ans[uq+1][ui][uj-1] = w+lr[ui][uj-1];
					}
					if (uj<m-1 && w+lr[ui][uj]<ans[uq+1][ui][uj+1]) {
						ans[uq+1][ui][uj+1] = w+lr[ui][uj];
					}
				}
			}
		}
		
		for (int i = 0; i < n; ++i) {
			StringBuilder as = new StringBuilder();
			String sp = """";
			for (int j = 0; j < m; ++j) {
				as.append(sp+ans[k/2][i][j]*2);
				sp = "" "";
			}
			System.out.println(as);
		}
	}
	
	public static int nni() {
        int ret = 0;
        byte b = buf[++bp];
        while (true) {
            ret = ret*10+b-'0';
            b = buf[++bp];
            if (b<'0'||b>'9') {
            	while (buf[bp+1]=='\r'||buf[bp+1]=='\n'||buf[bp+1]==' ') {++bp;}
            	break;
            }
        }
        return ret;
    }
}",1517_D,CODEFORCES,4170,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import java.io.*;
import java.util.*;
import java.math.*;

public class A {
    public static void main(String[] args) { 
        OutputStream outputStream = System.out;
        PrintWriter out = new PrintWriter(outputStream);

        Application solver = new Application();
        solver.solve(System.in, out);

        out.close();
    }
}


class Application {
    int max(int a, int b) { return a > b ? a : b; }
    public void solve(InputStream in, PrintWriter out) {
        Scanner scanner = new Scanner(in);

        int n = scanner.nextInt();
        int n1 = n/10;
        int n2 = (n/100)*10+(n%10);
        int m = max(max(n1, n2), n);

        out.println(m);
    }
}
",0313_A,CODEFORCES,343,Ilya and Bank Account,"Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.
Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.
Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.
The single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.
In a single line print an integer — the maximum state of the bank account that Ilya can get. 
","input
In the first test sample Ilya doesn't profit from using the present.
output
In the second test sample you can delete digit 1 and get the state of the account equal to 0.
","implementation, numbertheory",1
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.StringTokenizer;


public class D {

	static StringTokenizer st;
	static BufferedReader br;
	static PrintWriter pw;
	public static void main(String[] args) throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
		int n = nextInt();
		int[]a = new int[n+1];
		for (int i = 1; i <= n; i++) {
			a[i] = nextInt();
		}
		int inv = 0;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j < i; j++) {
				if (a[j] > a[i])
					inv++;
			}
		}
		int m = nextInt();
		boolean odd = inv % 2==1;
		for (int i = 0; i < m; i++) {
			int left = nextInt();
			int right = nextInt();
			long k = right-left+1;
			if (k*(k-1)/2 % 2==1)
				odd = !odd;
			if (odd)
				pw.println(""odd"");
			else
				pw.println(""even"");
		}
		pw.close();
	}
	private static int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
	private static long nextLong() throws IOException {
		return Long.parseLong(next());
	}
	private static double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}
	private static String next() throws IOException {
		while (st==null || !st.hasMoreTokens())
			st = new StringTokenizer(br.readLine());
		return st.nextToken();
	}
}",0911_D,CODEFORCES,3230,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.io.*;
import java.util.*;

public class E implements Runnable {
	public static void main (String[] args) {new Thread(null, new E(), ""_cf"", 1 << 28).start();}
	
	long oo = (long)2e18;
	
	public void run() {
		FastScanner fs = new FastScanner();
		PrintWriter out = new PrintWriter(System.out);
		System.err.println(""Go!"");

		int t = fs.nextInt();
		while(t-->0) {
			int n = fs.nextInt();
			long k = fs.nextLong();
			long toCut = 1, numSquares = 1, free = 0;
			int cuts = 0;
			while(true) {
				if(cuts >= n) {
					k = oo;
					break;
				}
				k -= toCut;
				if(k < 0) {
					k = oo;
					break;
				}
				cuts++;
				try {
					free = Math.addExact(free, Math.multiplyExact(numSquares, getVal(n-cuts)));
				} catch (Exception e) {
					k = 0;
					break;
				}
				if(free >= k) {
					k = 0;
					break;
				}
				toCut += (1L<<cuts);
				numSquares += (1L<<(cuts+1));
			}
			if(k == 0) {
				out.printf(""YES %d\n"", n-cuts);
			}
			else {
				out.printf(""NO\n"");
			}
		}
		
		out.close();
	}
	
	long getVal(int n) {
		if(n > 31) return oo;
		long last = 0, cur = 0;
		for(int i = 1; i <= n; i++) {
			cur = 1 + 4*last;
			last = cur;
		}
		return cur;
	}
	
	class FastScanner {
		public int BS = 1<<16;
		public char NC = (char)0;
		byte[] buf = new byte[BS];
		int bId = 0, size = 0;
		char c = NC;
		double num = 1;
		BufferedInputStream in;

		public FastScanner() {
			in = new BufferedInputStream(System.in, BS);
		}

		public FastScanner(String s) throws FileNotFoundException {
			in = new BufferedInputStream(new FileInputStream(new File(s)), BS);
		}

		public char nextChar(){
			while(bId==size) {
				try {
					size = in.read(buf);
				}catch(Exception e) {
					return NC;
				}                
				if(size==-1)return NC;
				bId=0;
			}
			return (char)buf[bId++];
		}

		public int nextInt() {
			return (int)nextLong();
		}

		public long nextLong() {
			num=1;
			boolean neg = false;
			if(c==NC)c=nextChar();
			for(;(c<'0' || c>'9'); c = nextChar()) {
				if(c=='-')neg=true;
			}
			long res = 0;
			for(; c>='0' && c <='9'; c=nextChar()) {
				res = (res<<3)+(res<<1)+c-'0';
				num*=10;
			}
			return neg?-res:res;
		}

		public double nextDouble() {
			double cur = nextLong();
			return c!='.' ? cur:cur+nextLong()/num;
		}

		public String next() {
			StringBuilder res = new StringBuilder();
			while(c<=32)c=nextChar();
			while(c>32) {
				res.append(c);
				c=nextChar();
			}
			return res.toString();
		}

		public String nextLine() {
			StringBuilder res = new StringBuilder();
			while(c<=32)c=nextChar();
			while(c!='\n') {
				res.append(c);
				c=nextChar();
			}
			return res.toString();
		}

		public boolean hasNext() {
			if(c>32)return true;
			while(true) {
				c=nextChar();
				if(c==NC)return false;
				else if(c>32)return true;
			}
		}
		
		public int[] nextIntArray(int n) {
			int[] res = new int[n];
			for(int i = 0; i < n; i++) res[i] = nextInt();
			return res;
		}
		
	}

	
}",1080_D,CODEFORCES,1288,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"import java.util.*;
public class a {
	public static void main(String[] args){
		Scanner br = new Scanner(System.in);
		long n = br.nextLong();
		System.out.println(""25"");
	}
}
",0630_A,CODEFORCES,520,Again Twenty Five!,"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. ""Do I give such a hard task?"" — the HR manager thought. ""Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.""
Could you pass the interview in the machine vision company in IT City?
","input
The only line of the input contains a single integer n (2 ≤ n ≤ 2·1018) — the power in which you need to raise number 5.
output
Output the last two digits of 5n without spaces between them.
",numbertheory,1
"import java.io.PrintWriter;
import java.util.Scanner;

public class n122A {
    Scanner in;
    PrintWriter out;

    void solve() {
        int n = in.nextInt();
        boolean good = false;
        if (n % 4 == 0) {
            good = true;
        }
        if (n % 7 == 0) {
            good = true;
        }
        if (n % 44 == 0) {
            good = true;
        }
        if (n % 47 == 0) {
            good = true;
        }
        if (n % 74 == 0) {
            good = true;
        }
        if (n % 77 == 0) {
            good = true;
        }
        if (n % 444 == 0) {
            good = true;
        }
        if (n % 447 == 0) {
            good = true;
        }
        if (n % 474 == 0) {
            good = true;
        }
        if (n % 477 == 0) {
            good = true;
        }
        if (n % 744 == 0) {
            good = true;
        }
        if (n % 747 == 0) {
            good = true;
        }
        if (n % 774 == 0) {
            good = true;
        }
        if (n % 777 == 0) {
            good = true;
        }
        if (good) {
            out.println(""YES"");
        } else {
            out.println(""NO"");
        }
    }

    void run() {
        in = new Scanner(System.in);
        out = new PrintWriter(System.out);
        try {
            solve();
        } finally {
            out.close();
        }
    }

    public static void main(String[] args) {
        new n122A().run();

    }

}
",0122_A,CODEFORCES,134,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory",1
"import javax.swing.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.StringTokenizer;

public class A {

    public static void main(String[] args) {
        FastScanner scanner = new FastScanner();
        long x = scanner.nextLong();
        long k = scanner.nextLong();
        if (x==0) {
            System.out.println(""0"");
            return;
        }
        BigInteger M = BigInteger.valueOf(1000_000_000L+7);
        BigInteger modus = BigInteger.valueOf(x).multiply(BigInteger.valueOf(2)).subtract(BigInteger.ONE).mod(M);
        BigInteger operandi = BigInteger.valueOf(2).modPow(BigInteger.valueOf(k), M);
        BigInteger result = modus.multiply(operandi).mod(M).add(BigInteger.ONE).mod(M);
        System.out.println(result);
    }

    public static long gcd(long a, long b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }

    public static long lcm(long a, long b, long gcd) {
        return a * (b / gcd);
    }


    public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}
",0992_C,CODEFORCES,1208,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

public class Main 
{
	static ArrayList<Integer> Unique(ArrayList<Integer> x)
	{
		TreeSet<Integer> tmp=new TreeSet<Integer>();
		tmp.addAll(x);
		x.clear();
		x.addAll(tmp);
		return x;
	}
	public static void main(String[] args) 
	{
		InputReader in = new InputReader();
//		Scanner in=new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		while(in.hasNext())
		{
			long n=in.nextLong();
			out.println(""25"");
		}
		out.close();
	}
}

class node
{
	ArrayList<Integer> v=new ArrayList<Integer>();
	node(){}
	void push(Integer a)
	{
		v.add(a);
	}
}

class InputReader 
{
	BufferedReader buf;
	StringTokenizer tok;
	InputReader() 
	{
		buf = new BufferedReader(new InputStreamReader(System.in));
	}

	boolean hasNext() 
	{
		while (tok == null || !tok.hasMoreElements()) 
		{
			try 
			{
				tok = new StringTokenizer(buf.readLine());
			} 
			catch (Exception e) 
			{
				return false;
			}
		}
		return true;
	}

	String next() 
	{
		if (hasNext())
			return tok.nextToken();
		return null;
	}

	int nextInt() 
	{
		return Integer.parseInt(next());
	}

	long nextLong() 
	{
		return Long.parseLong(next());
	}

	double nextDouble() 
	{
		return Double.parseDouble(next());
	}

	BigInteger nextBigInteger() 
	{
		return new BigInteger(next());
	}

	BigDecimal nextBigDecimal() 
	{
		return new BigDecimal(next());
	}
}",0630_A,CODEFORCES,546,Again Twenty Five!,"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. ""Do I give such a hard task?"" — the HR manager thought. ""Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.""
Could you pass the interview in the machine vision company in IT City?
","input
The only line of the input contains a single integer n (2 ≤ n ≤ 2·1018) — the power in which you need to raise number 5.
output
Output the last two digits of 5n without spaces between them.
",numbertheory,1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 * Created by Egor on 13/10/14.
 */
public class Task287B {

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(System.out);
        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());
        long n = Long.parseLong(tokenizer.nextToken());
        long k = Long.parseLong(tokenizer.nextToken());

        long leftBound = -1;
        long rightBound = k - 1;
//        long current = 0;

        if (n > k * (k - 1) / 2 + 1) {
            writer.println(-1);
            writer.close();
            System.exit(0);
        }

        while (rightBound - leftBound > 1) {
            long mid = (rightBound + leftBound) / 2;
            if ((k * 2 - 1 - mid) * mid / 2 >= n - 1) {
                rightBound = mid;
            } else {
                leftBound = mid;
            }
        }

//        if (n - current >= 0 && n - current != 1) {
        writer.println(rightBound);
//        } else {
//            writer.println(-1);
//        }
        writer.close();
    }

}
",0287_B,CODEFORCES,957,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = in.nextInt();
            }
            int inv = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < i; j++) {
                    if (a[j] > a[i]) {
                        inv++;
                    }
                }
            }
            int m = in.nextInt();
            for (int i = 0; i < m; i++) {
                int l = in.nextInt();
                int r = in.nextInt();
                int s = (r - l + 1) * (r - l) / 2;
                inv = (inv + s) % 2;
                out.println(inv % 2 == 0 ? ""even"" : ""odd"");
            }
        }

    }

    static class InputReader {
        private BufferedReader reader;
        private StringTokenizer stt;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream));
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                return null;
            }
        }

        public String next() {
            while (stt == null || !stt.hasMoreTokens()) {
                stt = new StringTokenizer(nextLine());
            }
            return stt.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",0911_D,CODEFORCES,3241,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.util.Scanner;



public class C {

	

	public static void main(String[] args) {

		new C();

	}



	C() {

		

		Scanner in = new Scanner(System.in);

		

		long n = in.nextLong(), s = in.nextLong();

		long lo = 1, hi = 1000000000000000000L;

		

		while(lo<hi){

			//System.out.println(lo+"" ""+hi);

			//STUPID STUPID DUMB

			long mid = (lo+hi)/2;

			if(reallyBig(mid,s))

				hi = mid;

			else

				lo = mid+1;

		}

		

		//System.out.println(lo+"" ""+hi);

		if(!reallyBig(lo,s))

			System.out.println(0);

		else

			System.out.println(Math.max(n-lo+1,0));

			

		//System.out.println(reallyBig(100000000000000009L,100000000000000000L));



		in.close();



	}

	

	boolean reallyBig(long n, long s){

		int sum = 0;

		long temp = n;

		while(temp>0){

			sum += temp%10;

			temp/=10;

		}

		return n-sum>=s;

	}

	

}



/*



12 1



25 20



10 9



1000000000000000000 1000000000000000000



1000000000000000000 100000000000000000



 */



















",0817_C,CODEFORCES,1097,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"import java.io.*;
import java.math.BigInteger;
import java.util.*;
public class Main {
    static int inf = (int) 1e9;
    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(System.out);
        int n = nextInt();
        int k = nextInt();
        long l = -1;
        long r = 100000;
        while(l != r - 1) {
            long mid = (l + r) / 2;
            if (mid * (mid + 1) / 2 - (n - mid) > k) r = mid;
            else l = mid;
        }
        pw.println(n - l);
        pw.close();
    }

    static BufferedReader br;
    static StringTokenizer st = new StringTokenizer("""");
    static PrintWriter pw;

    static String next() throws IOException {
        while (!st.hasMoreTokens()) st = new StringTokenizer(br.readLine());
        return st.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    static long nextLong() throws IOException {
        return Long.parseLong(next());
    }
    static Double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }
}",1195_B,CODEFORCES,1382,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStreamReader;

public class B1177 {

	public static void main(String[] args) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader(""F:/books/input.txt""));
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		Long n = Long.parseLong(br.readLine());
		long[] p = new long[15];
		int i;
		p[0]=1;
		for(i=1;i<15;p[i]=p[i-1]*10,i++);
		for(i=1;i*p[i-1]*9L<n;n-=i*p[i-1]*9L,i++);
		n--;
		int v = (int) (n%i);
		n/=i;
		n+=p[i-1];
		String s = n.toString();
		System.out.println(s.charAt(v));
	}

}
",1177_B,CODEFORCES,1330,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"

import java.awt.Point;
import java.io.*;
import java.math.BigInteger;
import java.util.*;

import static java.lang.Math.*;

public class A implements Runnable{
    
    final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"")!=null;
    BufferedReader in;
    PrintWriter out;
    StringTokenizer tok = new StringTokenizer("""");
    
    void init() throws FileNotFoundException{
        if (ONLINE_JUDGE){
            in = new BufferedReader(new InputStreamReader(System.in));
            out = new PrintWriter(System.out);
        }else{
            in = new BufferedReader(new FileReader(""input.txt""));
            out = new PrintWriter(""output.txt"");
        }
    }
    
    String readString() throws IOException{
        while(!tok.hasMoreTokens()){
            tok = new StringTokenizer(in.readLine());
        }
        return tok.nextToken();
    }
    
    int readInt() throws IOException{
        return Integer.parseInt(readString());
    }
    
    long readLong() throws IOException{
        return Long.parseLong(readString());
    }
    
    double readDouble() throws IOException{
        return Double.parseDouble(readString());
    }
    
    public static void main(String[] args){
        new Thread(null, new A(), """", 256 * (1L << 20)).start();
    }
    
    public void run(){
        try{
            long t1 = System.currentTimeMillis();
            init();
            solve();
            out.close();
            long t2 = System.currentTimeMillis();
            System.err.println(""Time = ""+(t2-t1));
        }catch (Exception e){
            e.printStackTrace(System.err);
            System.exit(-1);
        }
    }
    
    void solve() throws IOException{
        int n = readInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++){
            a[i] = readInt();
        }
        Arrays.sort(a);
        a[n-1] = a[n-1] == 1? 2:1;
        Arrays.sort(a);
        for (int i = 0; i < n; i++){
            out.print(a[i] + "" "");
        }
    }
}

",0135_A,CODEFORCES,2390,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings",4
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in Actual solution is at the top
 *
 * @author ilyakor
 */
public class Main {

  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    InputReader in = new InputReader(inputStream);
    OutputWriter out = new OutputWriter(outputStream);
    TaskE1 solver = new TaskE1();
    int testCount = Integer.parseInt(in.next());
    for (int i = 1; i <= testCount; i++) {
      solver.solve(i, in, out);
    }
    out.close();
  }

  static class TaskE1 {

    public void solve(int testNumber, InputReader in, OutputWriter out) {
      int n = in.nextInt();
      int m = in.nextInt();
      int[][] d = new int[2][1 << n];
      int[] buf = new int[1 << n];
      int[][] a = new int[m][n];
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          a[j][i] = in.nextInt();
        }
      }
      for (int i = 0; i < m; ++i) {
        int[] prev = d[i % 2], nx = d[(i + 1) % 2];
        for (int shift = 0; shift < n; ++shift) {
          int[] b = new int[n];
          for (int j = 0; j < n; ++j) {
            b[j] = a[i][(j + shift) % n];
          }
          System.arraycopy(prev, 0, buf, 0, prev.length);
          for (int mask = 0; mask < (1 << n); ++mask) {
            int val0 = buf[mask];
            for (int j = 0; j < n; ++j) {
              if ((mask >> j) % 2 == 0) {
                int val = val0 + b[j];
                int nm = mask ^ (1 << j);
                if (val > buf[nm]) {
                  buf[nm] = val;
                }
              }
            }
          }
          for (int mask = 0; mask < (1 << n); ++mask) {
            if (nx[mask] < buf[mask]) {
              nx[mask] = buf[mask];
            }
          }
        }
      }
      out.printLine(d[m % 2][(1 << n) - 1]);
    }

  }

  static class OutputWriter {

    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; i++) {
        if (i != 0) {
          writer.print(' ');
        }
        writer.print(objects[i]);
      }
    }

    public void printLine(Object... objects) {
      print(objects);
      writer.println();
    }

    public void close() {
      writer.close();
    }

  }

  static class InputReader {

    private InputStream stream;
    private byte[] buffer = new byte[10000];
    private int cur;
    private int count;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public static boolean isSpace(int c) {
      return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public int read() {
      if (count == -1) {
        throw new InputMismatchException();
      }
      try {
        if (cur >= count) {
          cur = 0;
          count = stream.read(buffer);
          if (count <= 0) {
            return -1;
          }
        }
      } catch (IOException e) {
        throw new InputMismatchException();
      }
      return buffer[cur++];
    }

    public int readSkipSpace() {
      int c;
      do {
        c = read();
      } while (isSpace(c));
      return c;
    }

    public String nextToken() {
      int c = readSkipSpace();
      StringBuilder sb = new StringBuilder();
      while (!isSpace(c)) {
        sb.append((char) c);
        c = read();
      }
      return sb.toString();
    }

    public String next() {
      return nextToken();
    }

    public int nextInt() {
      int sgn = 1;
      int c = readSkipSpace();
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') {
          throw new InputMismatchException();
        }
        res = res * 10 + c - '0';
        c = read();
      } while (!isSpace(c));
      res *= sgn;
      return res;
    }

  }
}

",1209_E1,CODEFORCES,4744,Rotate Columns (easy version),"This is an easier version of the next problem. The difference is only in constraints.
You are given a rectangular $$$n \times m$$$ matrix $$$a$$$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want (possibly zero). You can perform this operation to a column multiple times.
After you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $$$i$$$-th row it is equal $$$r_i$$$. What is the maximal possible value of $$$r_1+r_2+\ldots+r_n$$$?
The first line contains an integer $$$t$$$ ($$$1 \le t \le 40$$$), the number of test cases in the input.
The first line of each test case contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 4$$$, $$$1 \le m \le 100$$$) — the number of rows and the number of columns in the given matrix $$$a$$$. 
Each of the following $$$n$$$ lines contains $$$m$$$ integers, the elements of $$$a$$$ ($$$1 \le a_{i, j} \le 10^5$$$).
Print $$$t$$$ integers: answers for all test cases in the order they are given in the input.
","input
In the first test case, you can shift the third column down by one, this way there will be $$$r_1 = 5$$$ and $$$r_2 = 7$$$.
output
In the second case you can don't rotate anything at all, this way there will be $$$r_1 = r_2 = 10$$$ and $$$r_3 = 9$$$.
","bitmasks, bruteforce, dp, greedy, sortings",7
"import java.util.*;

public class Solution
{
    public static void main(String[] args)
    {
        new Solution().calc();
    }

    void calc()
    {
        Scanner cin = new Scanner(System.in);
        String s = cin.next();
        int ret = 0;
        for (int i = 0; i < s.length(); i++)
        {
            for (int j = i + 1; j < s.length(); j++)
            {
                for (int k = 0; j + k < s.length(); k++)
                {
                    if (s.charAt(i + k) != s.charAt(j + k)) break;
                    ret = Math.max(k + 1, ret);
                }
            }
        }
        System.out.println(ret);
    }
}
",0023_A,CODEFORCES,3770,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import java.util.*;
import java.io.*;

public class A
{
	static class T
	{
		public int s,p;
	}
	public static void main(String args[]) throws Exception
	{
		InputReader sc=new InputReader(System.in);
		int n=sc.readInt(),k=sc.readInt(),i,j,z;
		T m[]=new T[n];
		for(i=0;i<n;i++) {m[i]=new T();m[i].s=sc.readInt();m[i].p=sc.readInt();}
		for(i=0;i<n;i++) for(j=i+1;j<n;j++)	if(m[i].s<m[j].s){z=m[i].s;m[i].s=m[j].s;m[j].s=z;z=m[i].p;m[i].p=m[j].p;m[j].p=z;}
		for(i=0;i<n;i++) for(j=i+1;j<n;j++)	if(m[i].s==m[j].s&&m[i].p>m[j].p){z=m[i].s;m[i].s=m[j].s;m[j].s=z;z=m[i].p;m[i].p=m[j].p;m[j].p=z;}
		k--;int s=m[k].s,p=m[k].p,res=0;
		for(i=0;i<n;i++){if(m[i].s==s&&m[i].p==p)res++;}
		System.out.println(res);
	}
}
class InputReader {
	private boolean finished = false;
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int peek() {
		if (numChars == -1)
			return -1;
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				return -1;
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public long readLong() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuffer res = new StringBuffer();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	private boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	private String readLine0() {
		StringBuffer buf = new StringBuffer();
		int c = read();
		while (c != '\n' && c != -1) {
			if (c != '\r')
				buf.appendCodePoint(c);
			c = read();
		}
		return buf.toString();
	}

	public String readLine() {
		String s = readLine0();
		while (s.trim().length() == 0)
			s = readLine0();
		return s;
	}

	public String readLine(boolean ignoreEmptyLines) {
		if (ignoreEmptyLines)
			return readLine();
		else
			return readLine0();
	}

	public char readCharacter() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		return (char) c;
	}

	public double readDouble() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		double res = 0;
		while (!isSpaceChar(c) && c != '.') {
			if (c == 'e' || c == 'E')
				return res * Math.pow(10, readInt());
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		}
		if (c == '.') {
			c = read();
			double m = 1;
			while (!isSpaceChar(c)) {
				if (c == 'e' || c == 'E')
					return res * Math.pow(10, readInt());
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				m /= 10;
				res += (c - '0') * m;
				c = read();
			}
		}
		return res * sgn;
	}

	public boolean isExhausted() {
		int value;
		while (isSpaceChar(value = peek()) && value != -1)
			read();
		return value == -1;
	}

	public String next() {
		return readString();
	}
}",0166_A,CODEFORCES,2498,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"import java.io.*;
import java.util.*;

public class Main {
	static Scanner in;
	static PrintWriter out;
//	static StreamTokenizer in; static int next() throws Exception {in.nextToken(); return (int) in.nval;}

	public static void main(String[] args) throws Exception {
		in = new Scanner(System.in);
		out = new PrintWriter(System.out);
//		in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));

		int n = in.nextInt();

		double[][] p = new double[n][n];
		for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) p[i][j] = in.nextDouble();

		double[] q = new double[1 << n];
		q[(1 << n) - 1] = 1;
		for (int mask = (1 << n) - 1; mask > 0; mask--) {
			int count = 0;

			for (int t = 0; t < n; t++) if (((1 << t) & mask) != 0) count++;
			if (count <= 1) continue;
			count = count*(count - 1)/2;

			for (int t = 0; t < n; t++) if (((1 << t) & mask) != 0)
				for (int s = 0; s < t; s++) if (((1 << s) & mask) != 0) {
					q[mask - (1 << t)] += q[mask] / count * p[s][t];
					q[mask - (1 << s)] += q[mask] / count * p[t][s];
				}
		}

		for (int i = 0; i < n; i++) out.print(q[1 << i] + "" "");

		out.close();
	}
}",0016_E,CODEFORCES,4509,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"import java.util.*;
import java.io.*;

public class Template {
	public static void main(String[] args) throws IOException {
		st = new StringTokenizer(rd.readLine());
		n = Long.parseLong(st.nextToken());
		m = Long.parseLong(st.nextToken());
		k = Long.parseLong(st.nextToken());
		long s = n - m;
		s = Math.min(s, m / (k - 1));
		s = Math.min(s, n / k);
		long score = 0;
		score = (s * (k - 1))%P;
		long n1 = n - k * s, m1 = m - (k - 1) * s;
		sc = 0;
	//	rec(n, m);
	//	System.out.println(sc);
		if (m1 == n1) {
			score = (score + full(m1)) % P;
			System.out.println(score);
			return;
		}
			score = (score + m1) % P;
			System.out.println(score);
	}

	static long full(long N) {
		long x = N / k, r = N - x * k;
		long powTwo = powMod(2, x + 1) - 2 + 2*P;
		powTwo %= P;
		powTwo = (powTwo * k) % P;
		powTwo = (powTwo + r) % P;
		return powTwo;
	}
	
	static long sc = 0;
	
	static void rec(long N, long M){
		if(N==M){ sc = (sc + full(N))%P; return; }
		if(N>=k && M>=k-1){
			sc = (sc + (k-1))%P;
			rec(N-k, M-(k-1));
			return;
		}
		sc = (sc + M)%P;
	}

	static long powMod(long a, long p) {
		if (p == 0)
			return 1L;
		long h = powMod(a, (p >> 1));
		h = (h * h) % P;
		return p % 2 == 0 ? h : (a * h) % P;
	}

	static long n, m, k;

	static long P = 1000000009;

	static StringTokenizer st;
	static BufferedReader rd = new BufferedReader(new InputStreamReader(
			System.in));
	static PrintWriter pw = new PrintWriter(System.out);

}
",0338_A,CODEFORCES,991,Quiz,"Manao is taking part in a quiz. The quiz consists of n consecutive questions. A correct answer gives one point to the player. The game also has a counter of consecutive correct answers. When the player answers a question correctly, the number on this counter increases by 1. If the player answers a question incorrectly, the counter is reset, that is, the number on it reduces to 0. If after an answer the counter reaches the number k, then it is reset, and the player's score is doubled. Note that in this case, first 1 point is added to the player's score, and then the total score is doubled. At the beginning of the game, both the player's score and the counter of consecutive correct answers are set to zero.
Manao remembers that he has answered exactly m questions correctly. But he does not remember the order in which the questions came. He's trying to figure out what his minimum score may be. Help him and compute the remainder of the corresponding number after division by 1000000009 (109 + 9).
The single line contains three space-separated integers n, m and k (2 ≤ k ≤ n ≤ 109; 0 ≤ m ≤ n).
Print a single integer — the remainder from division of Manao's minimum possible score in the quiz by 1000000009 (109 + 9).
Sample 1. Manao answered 3 questions out of 5, and his score would double for each two consecutive correct answers. If Manao had answered the first, third and fifth questions, he would have scored as much as 3 points.
","input
Sample 2. Now Manao answered 4 questions. The minimum possible score is obtained when the only wrong answer is to the question 4.
output
Also note that you are asked to minimize the score and not the remainder of the score modulo 1000000009. For example, if Manao could obtain either 2000000000 or 2000000020 points, the answer is 2000000000 mod 1000000009, even though 2000000020 mod 1000000009 is a smaller number.
","greedy, math, numbertheory",2
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int V = in.nextInt();
        int E = in.nextInt();
        boolean [][] G = new boolean [V][V];
        for (int i = 0; i < E; i++) {
            int u = in.nextInt()-1;
            int v = in.nextInt()-1;
            G[u][v] = true;
            G[v][u] = true;
        }
        
        int pset = 1 << V;
        
        long [][] dp = new long [pset][V];
        long cycles = 0;
        
        for (int set = 1; set < pset; set++) {
            int bit = Integer.bitCount(set);
            int src = first(set);
            
            if (bit == 1) {
                dp[set][src] = 1;
            }
            else if(bit > 1) {
                for (int i = 0; i < V; i++) {
                    if(i == src) continue;
                    // Check if i is in set
                    if ((set & (1 << i)) != 0) {
                        int S_1 = set ^ (1 << i);
                        for (int v = 0; v < V; v++) {
                            if (G[v][i] == true) {
                                dp[set][i] += dp[S_1][v];
                            }
                        }
                    }
                    //Count Cycles:
                    if (bit >= 3 && G[src][i]) {
                        cycles += dp[set][i];
                    }   
                }
                
            }
                    
                    
        }
        System.out.println(cycles/2);
    }
    
    public static int first(int n) {
        int cnt = 0;
        while ((n & 1) != 1) {
            cnt++;
            n >>= 1;
        }
        return cnt;
    }
}",0011_D,CODEFORCES,4426,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import java.io.*;
import java.util.*;

public class AA {
	static class O implements Comparable<O> {
		int problems;
		int penalty;

		public O(int p, int pp) {
			problems = p;
			penalty = pp;
		}

		public int compareTo(O arg0) {
			if (problems == arg0.problems) {
				return penalty - arg0.penalty;
			}
			return -(problems - arg0.problems);
		}

	}

	public static void main(String[] args) throws IOException {
		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		String s = r.readLine();
		String[] sp = s.split(""[ ]+"");
		int n = new Integer(sp[0]), k = new Integer(sp[1]) - 1;
		O[] arr = new O[n];
		for (int i = 0; i < arr.length; i++) {
			s = r.readLine();
			sp = s.split(""[ ]+"");
			arr[i] = new O(new Integer(sp[0]), new Integer(sp[1]));
		}
		Arrays.sort(arr);

		int res = 1;

		int i = k + 1;
		while (i < arr.length && arr[i].problems == arr[k].problems
				&& arr[i].penalty == arr[k].penalty) {
			i++;
			res++;
		}

		i = k - 1;
		while (i >= 0 && arr[i].problems == arr[k].problems
				&& arr[i].penalty == arr[k].penalty) {
			i--;
			res++;
		}
		System.out.println(res);

	}
}
",0166_A,CODEFORCES,2499,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"import java.util.Scanner;


public class Task5d {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		double a = sc.nextDouble();
		double v = sc.nextDouble();
		double l = sc.nextDouble();
		double d = sc.nextDouble();
		double w = sc.nextDouble();
		double t = 0;
		if (w >= v) {
			double t1 = v / a;
			double s1 = a * t1 * t1 / 2;
			if (s1 > l) {
				t = Math.sqrt(2 * l / a);
			} else {
				t = t1 + (l - s1) / v;
			}
		} else {
			double t2 = Math.sqrt(2 * d / a);
			if (a * t2 <= w) {
				double t1 = v / a;
				double s1 = a * t1 * t1 / 2;
				if (s1 > l) {
					t = Math.sqrt(2 * l / a);
				} else {
					t = t1 + (l - s1) / v;
				}
			} else {
				double tup = v / a;
				double tdown = (v - w) / a;
				double sup = a * tup * tup / 2;
				double sdown = v * tdown - a * tdown * tdown / 2;
				if (sup + sdown <= d) {
					double tmax = (d - sup - sdown) / v;
					t = tup + tmax + tdown;					
				} else {
					double tw = w / a;
					double sw = a * tw * tw / 2;
					double sl = (d - sw) / 2;
					double dis = w * w + 2 * a * sl;
					double tu1 = (- w - Math.sqrt(dis)) / a;
					if (tu1 < 0) {
						tu1 = (- w + Math.sqrt(dis)) / a;
					}
					t = tw + 2 * tu1;
				}
				double sreup = w * tdown + a * tdown * tdown / 2;
				if (sreup <= l - d) {
					t += tdown;
					t += (l - d - sreup) / v;
				} else {
					double dis = w * w - 2 * a * (d - l);
					double tu1 = (- w - Math.sqrt(dis)) / a;
					if (tu1 < 0) {
						tu1 = (- w + Math.sqrt(dis)) / a;
					}
					t += tu1;
				}
			}
		}
		System.out.println(t);
	}

}
",0005_D,CODEFORCES,13,Follow Traffic Rules,"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.
It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km/h2, and has maximum speed of v km/h. The road has the length of l km, and the speed sign, limiting the speed to w km/h, is placed d km (1 ≤ d < l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.
The car can enter Bercouver at any speed.
","input
The first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).
output
Print the answer with at least five digits after the decimal point.
","implementation, math",1
"import java.util.Scanner;

public class TaskD {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int n = s.nextInt();
		int[] a = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = s.nextInt();
		}
		int m = s.nextInt();

		int inv = 0;
		// count inversions
		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
				if (a[i] > a[j]) {
					inv++;
				}
			}
		}

		boolean odd = (inv % 2 == 1);

		for (int i = 0; i < m; i++) {
			int l = s.nextInt();
			int r = s.nextInt() + 1; // r excluding, l including
			int num = (r - l)*(r - l - 1)/2;
			if (num % 2 == 1) {
				odd = !odd;
			}
			System.out.println((odd) ? ""odd"" : ""even"");
		}
	}

}
",0911_D,CODEFORCES,3240,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.*;

public class A {

	public static void main(String[] args) {
		JS in = new JS();
		int n = in.nextInt();
		int m1 = 0;
		int s1 = 0;
		int l1 = 0;
		int ss1 = 0;
		int sss1 = 0;
		int ssss1 = 0;
		int ll1 = 0;
		int lll1 = 0;
		int llll1 = 0;
		
		int m2 = 0;
		int s2 = 0;
		int l2 = 0;
		int ss2 = 0;
		int sss2 = 0;
		int ssss2 = 0;
		int ll2 = 0;
		int lll2 = 0;
		int llll2 = 0;
		for(int i = 0; i < n; i++) {
			String s = in.next();
			if(s.equals(""S"")) s1++;
			else if(s.equals(""M""))m1++;
			else if(s.equals(""L""))l1++;
			else if(s.equals(""XS"")) ss1++;
			else if(s.equals(""XXS"")) sss1++;
			else if(s.equals(""XXXS"")) ssss1++;
			else if(s.equals(""XL"")) ll1++;
			else if(s.equals(""XXL"")) lll1++;
			else if(s.equals(""XXXL"")) llll1++;
		}
		for(int i = 0; i < n; i++) {
			String s = in.next();
			if(s.equals(""S"")) s2++;
			else if(s.equals(""M""))m2++;
			else if(s.equals(""L""))l2++;
			else if(s.equals(""XS"")) ss2++;
			else if(s.equals(""XXS"")) sss2++;
			else if(s.equals(""XXXS"")) ssss2++;
			else if(s.equals(""XL"")) ll2++;
			else if(s.equals(""XXL"")) lll2++;
			else if(s.equals(""XXXL"")) llll2++;
		}
		
		int res = 0;
		int res1 = 0;

		
		res1 += Math.abs(m2-m1);
		res1 += Math.abs(s2-s1);
		res1 += Math.abs(l2-l1);
		res += res1/2;
		res1 = 0;
		
		res1 += Math.abs(ss2-ss1);
		res1 += Math.abs(ll2-ll1);
		res += res1/2;
		res1 = 0;
		
		res1 += Math.abs(sss2-sss1);
		res1 += Math.abs(lll2-lll1);
		res += res1/2;
		res1 = 0;
		
		res1 += Math.abs(ssss2-ssss1);
		res1 += Math.abs(llll2-llll1);
		res += res1/2;
		res1 = 0;
		System.out.println(res);
		
		
	}
	

	static class JS{
		public int BS = 1<<16;
		public char NC = (char)0;
		byte[] buf = new byte[BS];
		int bId = 0, size = 0;
		char c = NC;
		double num = 1;
		BufferedInputStream in;
		
		public JS() {
			in = new BufferedInputStream(System.in, BS);
		}
		
		public JS(String s) throws FileNotFoundException {
			in = new BufferedInputStream(new FileInputStream(new File(s)), BS);
		}
		
		public char nextChar(){
			while(bId==size) {
				try {
					size = in.read(buf);
				}catch(Exception e) {
					return NC;
				}				
				if(size==-1)return NC;
				bId=0;
			}
			return (char)buf[bId++];
		}
		
		public int nextInt() {
			return (int)nextLong();
		}
		
		public long nextLong() {
			num=1;
			boolean neg = false;
			if(c==NC)c=nextChar();
			for(;(c<'0' || c>'9'); c = nextChar()) {
				if(c=='-')neg=true;
			}
			long res = 0;
			for(; c>='0' && c <='9'; c=nextChar()) {
				res = (res<<3)+(res<<1)+c-'0';
				num*=10;
			}
			return neg?-res:res;
		}
		
		public double nextDouble() {
			double cur = nextLong();
			return c!='.' ? cur:cur+nextLong()/num;
		}
		
		public String next() {
			StringBuilder res = new StringBuilder();
			while(c<=32)c=nextChar();
			while(c>32) {
				res.append(c);
				c=nextChar();
			}
			return res.toString();
		}
		
		public String nextLine() {
			StringBuilder res = new StringBuilder();
			while(c<=32)c=nextChar();
			while(c!='\n') {
				res.append(c);
				c=nextChar();
			}
			return res.toString();
		}

		public boolean hasNext() {
			if(c>32)return true;
			while(true) {
				c=nextChar();
				if(c==NC)return false;
				else if(c>32)return true;
			}
		}
	}
}
",1000_A,CODEFORCES,1926,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation",3
"import java.util.*;
public class maximus {
	static long GCD(long a,long b){
	if(b==0)return a;
	return GCD(b,a%b);	
	}
public static void main(String [] args){
  Scanner in=new Scanner(System.in);
  long n=in.nextInt();
  if(n<=2){
  System.out.print(n);
  return;	
  }
  if(n%2==1){
  System.out.print((n*(n-1)*(n-2)));
  return;
  }
  if(n%2==0 && n<=6){
  System.out.print(n*(n-1)*(n-2)/2);
  return;	
  }
  long temp=(n*(n-1)*(n-3))/GCD(n,n-3);
  System.out.print(Math.max((n-1)*(n-2)*(n-3),temp));
  }
}",0235_A,CODEFORCES,217,LCM Challenge,"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.
But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than n. Can you help me to find the maximum possible least common multiple of these three integers?
The first line contains an integer n (1 ≤ n ≤ 106) — the n mentioned in the statement.
Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than n.
The least common multiple of some positive integers is the least positive integer which is multiple for each of them.
","input
The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.
output
For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.
",numbertheory,1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class ToyArmy {

	/**
	 * @param args
	 * @throws IOException 
	 * @throws NumberFormatException 
	 */
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		System.out.println(n / 2 * 3);
	}

}
",0084_A,CODEFORCES,91,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"import java.util.*;
import java.lang.*;
import java.io.*;
public class Codechef{
    static PrintWriter out = new PrintWriter(System.out);
    
    static boolean check(long x, long k){
        long dup = x;
        long sm = 0L;
        while(dup>0){
            sm += dup%10;
            dup /= 10;
        }
        return(x-sm>=k);
    }
    
	public static void main (String[] args) throws java.lang.Exception {
	    InputReader sc = new InputReader(System.in);
	    long n = sc.nextLong(), k = sc.nextLong();
	    long lo=1, hi=n+1;
	    while(lo<hi){
	        long mid = lo + (hi-lo)/2;
	        if(check(mid,k)) hi = mid;
	        else lo = mid+1;
	    }
	    out.println(n-lo+1);
	    out.close();
	}
	
	public static class InputReader {
        private static final int BUFFER_LENGTH = 1 << 12;
        private InputStream stream;
        private byte[] buf = new byte[BUFFER_LENGTH];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        private int next() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public char nextChar() {
            return (char) skipWhileSpace();
        }

        public String nextToken() {
            int c = skipWhileSpace();
            StringBuilder res = new StringBuilder();
            do {
                res.append((char) c);
                c = next();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public int nextInt() {
            return (int) nextLong();
        }

        public long nextLong() {
            int c = skipWhileSpace();
            long sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = next();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = next();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            return Double.valueOf(nextToken());
        }

        int skipWhileSpace() {
            int c = next();
            while (isSpaceChar(c)) {
                c = next();
            }
            return c;
        }

        boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
    }
}",0817_C,CODEFORCES,1123,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"import java.util.Scanner;

public class MainA {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n  = sc.nextInt();
        
        int count = 0;
        
        count = n/2;
        
        count = count + (n - n/2);
        
        n = n - n/2;
            
        count = count + n;  

        
        System.out.println(count);
        
    }
}
",0084_A,CODEFORCES,71,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"import java.util.*;
import java.lang.*;
import java.io.*;
import java.awt.*;

// U KNOW THAT IF THIS DAY WILL BE URS THEN NO ONE CAN DEFEAT U HERE................
//JUst keep faith in ur strengths .................................................. 


// ASCII = 48 + i ;// 2^28 = 268,435,456  > 2* 10^8 // log 10 base 2 = 3.3219 
// odd:: (x^2+1)/2 , (x^2-1)/2 ; x>=3// even:: (x^2/4)+1 ,(x^2/4)-1  x >=4 
// FOR ANY ODD NO N : N,N-1,N-2
//ALL ARE PAIRWISE COPRIME 
//THEIR COMBINED LCM IS PRODUCT OF ALL THESE NOS

// two consecutive odds are always coprime to each other
// two consecutive even have always gcd  = 2 ;

// Rectangle r = new Rectangle(int x , int y,int widht,int height) 
//Creates a rect. with bottom left cordinates as (x, y) and top right as ((x+width),(y+height))

//BY DEFAULT Priority Queue is MIN in nature in java
//to use as max , just push with negative sign and change sign after removal 

 public class Main
{
     
    // static int[] arr = new int[100002] ; 
    // static int[] dp = new int[100002] ;  
    
     static PrintWriter out;
    
	static class FastReader{
		BufferedReader br;
		StringTokenizer st;
		public FastReader(){
			br=new BufferedReader(new InputStreamReader(System.in));
			out=new PrintWriter(System.out);
		}
		String next(){
			while(st==null || !st.hasMoreElements()){
				try{
					st= new StringTokenizer(br.readLine());
				}
				catch (IOException e){
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}
		int nextInt(){
			return Integer.parseInt(next());
		}
		long nextLong(){
			return Long.parseLong(next());
		}
		double nextDouble(){
			return Double.parseDouble(next());
		}
		String nextLine(){
			String str = """";
			try{
				str=br.readLine();
			}
			catch(IOException e){
				e.printStackTrace();
			}
			return str;
		}
	}
	


////////////////////////////////////////////////////////////////////////////////////
 public static int countDigit(long n) 
    { 
        return (int)Math.floor(Math.log10(n) + 1); 
    } 

///////////////////////////////////////////////////////////////////////////////////////// 
 
 public static int sumOfDigits(long n)
 {
  
  if( n< 0)return -1 ;
  
  int sum = 0;
  
  while( n > 0)
  {
      sum = sum + (int)( n %10) ;
      
      n /= 10 ;
  }
     
  return sum ;  
 
 
 
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////////////

public static long arraySum(int[] arr , int start , int end)
{
    long ans = 0 ;
    
    for(int i = start ; i <= end  ; i++)ans += arr[i] ;
    
    return ans  ;
}

/////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////

public static void swapArray(int[] arr , int start , int end)
{
    while(start < end)
    {
        int temp = arr[start] ;
        arr[start] = arr[end];
        arr[end] = temp;
        start++ ;end-- ;
    }
}


//////////////////////////////////////////////////////////////////////////////////

static long factorial(long a)
{
    if(a== 0L || a==1L)return 1L ;
    
    return a*factorial(a-1L) ;
}

///////////////////////////////////////////////////////////////////////////////


public static int[][] rotate(int[][] input){

int n =input.length;
int m = input[0].length ;
int[][] output = new int [m][n];

for (int i=0; i<n; i++)
	for (int j=0;j<m; j++)
		output [j][n-1-i] = input[i][j];
return output;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////// ////////////////////////////////////////////////   

public static boolean isPowerOfTwo(long n) 
{ 
    if(n==0) 
    return false; 
  
if(((n ) & (n-1)) == 0 ) return true ;
else return false  ;

} 

/////////////////////////////////////////////////////////////////////////////////////

 
/////////////////////////////////////////////////////////////////////////////////// 

public static String reverse(String input)
{
  StringBuilder str  = new StringBuilder("""") ;
   
    for(int i =input.length()-1 ; i >= 0  ; i-- )
    {
        str.append(input.charAt(i));
    }
    
return str.toString() ;
}
///////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////
public static boolean isPossibleTriangle(int a  ,int b , int c)
{
      if( a + b > c && c+b > a && a +c > b)return true  ;
      else return false  ;
}


////////////////////////////////////////////////////////////////////////////////////////////
static long xnor(long num1, long num2) {
		if (num1 < num2) {
			long temp = num1;
			num1 = num2;
			num2 = temp;
		}
		num1 = togglebit(num1);
		return num1 ^ num2;
	}

	static long togglebit(long n) {
		if (n == 0)
			return 1;
		long i = n;
		n |= n >> 1;
		n |= n >> 2;
		n |= n >> 4;
		n |= n >> 8;
		n |= n >> 16;
		return i ^ n;
	}

///////////////////////////////////////////////////////////////////////////////////////////////

public static int xorOfFirstN(int n)
{
 
 
 if( n % 4 ==0)return n ;
 
 else if( n % 4 == 1)return 1 ;
 
 else if( n % 4 == 2)return n+1 ;
 
 else return 0 ;
 
    
}
//////////////////////////////////////////////////////////////////////////////////////////////

public static int gcd(int a, int b )
{

if(b==0)return a ;

else return gcd(b,a%b) ; 

}


public static long gcd(long a, long b )
{

if(b==0)return a ;

else return gcd(b,a%b) ; 

}

////////////////////////////////////////////////////////////////////////////////////

public static int lcm(int a, int b ,int c , int d )
{

int temp = lcm(a,b , c) ;


 
 int ans = lcm(temp ,d ) ;

return ans  ;


}

///////////////////////////////////////////////////////////////////////////////////////////

public static int lcm(int a, int b ,int c )
{

int temp = lcm(a,b) ;

int ans =  lcm(temp ,c) ;

return ans  ;


}

////////////////////////////////////////////////////////////////////////////////////////
    
public static int lcm(int a , int b )
{

int gc = gcd(a,b);

return (a/gc)*b ;
}


public static long lcm(long a , long b )
{

long gc = gcd(a,b);

return (a/gc)*b;
}


///////////////////////////////////////////////////////////////////////////////////////////
static boolean isPrime(long n)
{
      if(n==1)
      {
            return false  ;
      }
      
      boolean ans =  true  ;
      
      for(long i = 2L; i*i <= n ;i++)
      {
            if(n% i ==0)
            {
                  ans = false  ;break ;
            }
      }
      
      
      return ans  ;
} 

static boolean isPrime(int n)
{
      if(n==1)
      {
            return false  ;
      }
      
      boolean ans =  true  ;
      
      for(int i = 2; i*i <= n ;i++)
      {
            if(n% i ==0)
            {
                  ans = false  ;break ;
            }
      }
      
      
      return ans  ;
}      


///////////////////////////////////////////////////////////////////////////

static int sieve =  1000000 ;

 
static boolean[] prime =  new boolean[sieve + 1] ;

public static void sieveOfEratosthenes() 
    { 
        // FALSE == prime
        
        // TRUE ==  COMPOSITE
        
        // FALSE== 1
       
        
        // time complexity = 0(NlogLogN)== o(N)
        
        // gives prime nos bw 1 to N
        
        for(int i = 4; i<= sieve ; i++)
        {
            prime[i] = true  ;
            i++ ;
        }
        
        for(int p = 3; p*p <= sieve; p++) 
        { 
           
            if(prime[p] == false) 
            { 
                
                for(int i = p*p; i <= sieve; i += p) 
                    prime[i] = true; 
            } 
            
            p++ ;
        } 
          
       
       
    
    } 
 
///////////////////////////////////////////////////////////////////////////////////


public static void sortD(int[] arr , int s  , int e)
{
      sort(arr ,s , e) ;
      
      int i =s ; int j = e  ;
      
      while( i < j)
      {
            int temp = arr[i] ;
            arr[i] =arr[j] ;
            arr[j] = temp ;
            i++ ; j-- ;
      }
      
      
      
      return ;
}


/////////////////////////////////////////////////////////////////////////////////////////

public static long countSubarraysSumToK(long[] arr ,long sum )
    {
      HashMap<Long,Long> map = new HashMap<>() ;
       
      int n = arr.length ;
       
      long prefixsum = 0 ;
       
      long count = 0L ;
      for(int i  = 0; i < n ; i++)
      {
          prefixsum  = prefixsum +  arr[i] ;
           
          if(sum == prefixsum)count = count+1 ;
           
          if(map.containsKey(prefixsum -sum))
          {
              count = count + map.get(prefixsum -sum) ;
          }
          
          
          if(map.containsKey(prefixsum ))
          {
              map.put(prefixsum , map.get(prefixsum) +1 );
          }
          
          else{
              map.put(prefixsum , 1L );
          }
           
           
      }
        
        
        
      return count  ;  
        
    }

///////////////////////////////////////////////////////////////////////////////////////////////


// KMP ALGORITHM : TIME COMPL:O(N+M) 
// FINDS THE OCCURENCES OF PATTERN AS A  SUBSTRING IN STRING
//RETURN THE ARRAYLIST OF INDEXES 
// IF SIZE OF LIST IS ZERO MEANS PATTERN IS NOT PRESENT IN STRING


public static ArrayList<Integer> kmpAlgorithm(String str , String pat)
     {
        ArrayList<Integer> list =new ArrayList<>();
        
        int n = str.length() ;
        int m = pat.length() ;
        
        String q = pat + ""#"" + str ;
        
        int[] lps  =new int[n+m+1] ;
        
         longestPefixSuffix(lps, q,(n+m+1)) ;
         
         
         for(int i =m+1 ; i < (n+m+1) ; i++ )
         {
             if(lps[i] == m)
             {
                 list.add(i-2*m) ;
             }
         }
        
        return list ; 
         
        
    }
    

public static void longestPefixSuffix(int[] lps ,String str , int n)
    {
        lps[0] =  0 ;
        
        for(int i = 1  ; i<= n-1; i++)
        {
          int l = lps[i-1] ;
           
          while( l > 0 && str.charAt(i) != str.charAt(l))
          {
              l = lps[l-1] ;
          }
           
          if(str.charAt(i) == str.charAt(l))
          {
              l++ ;
          }
            
           
          lps[i] = l ; 
        }
        
    }
    
     

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

 // CALCULATE TOTIENT Fn FOR ALL VALUES FROM 1 TO n
    // TOTIENT(N) = count of nos less than n and grater than 1 whose gcd with n is 1 
    // or n and the no  will be coprime in nature
    //time : O(n*(log(logn)))
    
    public static void eulerTotientFunction(int[] arr ,int n )
    {
      
      for(int i = 1; i <= n  ;i++)arr[i] =i  ;
      
      
      for(int i= 2 ; i<= n ;i++)
      {
          if(arr[i] == i)
          {
              arr[i] =i-1 ;
              
              for(int j =2*i ; j<= n  ; j+= i )
              {
                  arr[j] = (arr[j]*(i-1))/i ;
              }
              
          }
      }
        
      return  ;  
        
    }
	
/////////////////////////////////////////////////////////////////////////////////////////////
public static long nCr(int n,int k)
{
    long ans=1L;
    k=k>n-k?n-k:k;
    int j=1;
    for(;j<=k;j++,n--)
    {
        if(n%j==0)
        {
            ans*=n/j;
        }else
        if(ans%j==0)
        {
            ans=ans/j*n;
        }else
        {
            ans=(ans*n)/j;
        }
    }
    return ans;
}

///////////////////////////////////////////////////////////////////////////////////////////

public static ArrayList<Integer> allFactors(int n)
{   
      ArrayList<Integer> list = new ArrayList<>() ;
      
    for(int i = 1; i*i <= n ;i++)
    {
          if( n % i == 0)
          {
              if(i*i == n)
              {
                    list.add(i) ;
              }
              else{
                    list.add(i) ;
                    list.add(n/i) ;
                    
              }
          }
    }
      
     return list ; 
      
      
}


public static ArrayList<Long> allFactors(long n)
{   
      ArrayList<Long> list = new ArrayList<>() ;
      
    for(long i = 1L; i*i <= n ;i++)
    {
          if( n % i == 0)
          {
              if(i*i == n)
              {
                    list.add(i) ;
              }
              else{
                    list.add(i) ;
                    list.add(n/i) ;
                    
              }
          }
    }
      
     return list ; 
      
      
}
////////////////////////////////////////////////////////////////////////////////////////////////////

  static final int MAXN = 1000001; 
       
    
    static int spf[] = new int[MAXN]; 
   
    static void sieve() 
    { 
        spf[1] = 1; 
        for (int i=2; i<MAXN; i++) 
       
           
            spf[i] = i; 
       
       
        for (int i=4; i<MAXN; i+=2) 
            spf[i] = 2; 
       
        for (int i=3; i*i<MAXN; i++) 
        { 
           
            if (spf[i] == i) 
            { 
               
                for (int j=i*i; j<MAXN; j+=i) 
       
                    if (spf[j]==j) 
                        spf[j] = i; 
            } 
        } 
    } 
       

    static ArrayList<Integer> getPrimeFactorization(int x) 
    { 
        ArrayList<Integer> ret = new ArrayList<Integer>(); 
        while (x != 1) 
        { 
            ret.add(spf[x]); 
            x = x / spf[x]; 
        } 
        return ret; 
    } 
       
 //////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////
   
public static void merge(int arr[], int l, int m, int r)
    {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;
 
        /* Create temp arrays */
        int L[] = new int[n1];
        int R[] = new int[n2];
 
       //Copy data to temp arrays
        for (int i=0; i<n1; ++i)
            L[i] = arr[l + i];
        for (int j=0; j<n2; ++j)
            R[j] = arr[m + 1+ j];
 
 
        /* Merge the temp arrays */
 
        // Initial indexes of first and second subarrays
        int i = 0, j = 0;
 
        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2)
        {
            if (L[i] <= R[j])
            {
                arr[k] = L[i];
                i++;
            }
            else
            {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
 
        /* Copy remaining elements of L[] if any */
        while (i < n1)
        {
            arr[k] = L[i];
            i++;
            k++;
        }
 
        /* Copy remaining elements of R[] if any */
        while (j < n2)
        {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
 
    // Main function that sorts arr[l..r] using
    // merge()
  public static void sort(int arr[], int l, int r)
    {
        if (l < r)
        {
            // Find the middle point
            int m = (l+r)/2;
 
            // Sort first and second halves
            sort(arr, l, m);
            sort(arr , m+1, r);
 
            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

public static void sort(long arr[], int l, int r)
    {
        if (l < r)
        {
            // Find the middle point
            int m = (l+r)/2;
 
            // Sort first and second halves
            sort(arr, l, m);
            sort(arr , m+1, r);
 
            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }


public static void merge(long arr[], int l, int m, int r)
    {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;
 
        /* Create temp arrays */
        long L[] = new long[n1];
        long R[] = new long[n2];
 
        //Copy data to temp arrays
        for (int i=0; i<n1; ++i)
            L[i] = arr[l + i];
        for (int j=0; j<n2; ++j)
            R[j] = arr[m + 1+ j];
 
 
        /* Merge the temp arrays */
 
        // Initial indexes of first and second subarrays
        int i = 0, j = 0;
 
        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2)
        {
            if (L[i] <= R[j])
            {
                arr[k] = L[i];
                i++;
            }
            else
            {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
 
        /* Copy remaining elements of L[] if any */
        while (i < n1)
        {
            arr[k] = L[i];
            i++;
            k++;
        }
 
        /* Copy remaining elements of R[] if any */
        while (j < n2)
        {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
 

 /////////////////////////////////////////////////////////////////////////////////////////
 
	public static long knapsack(int[] weight,long value[],int maxWeight){

        
        int n=  value.length ;
        
	
	//dp[i] stores the profit with KnapSack capacity ""i"" 
  long []dp = new long[maxWeight+1]; 
      
    //initially profit with 0 to W KnapSack capacity is 0 
    Arrays.fill(dp, 0); 
  
    // iterate through all items 
    for(int i=0; i < n; i++)  
      
        //traverse dp array from right to left 
        for(int j = maxWeight; j >= weight[i]; j--) 
            dp[j] = Math.max(dp[j] , value[i] + dp[j - weight[i]]); 
              
    /*above line finds out maximum of dp[j](excluding ith element value) 
    and val[i] + dp[j-wt[i]] (including ith element value and the 
    profit with ""KnapSack capacity - ith element weight"") */
    return dp[maxWeight]; 
	}

///////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


// to return max sum of any subarray in given array
public static long kadanesAlgorithm(long[] arr)
{
    
    if(arr.length == 0)return  0 ;
    
      long[] dp = new long[arr.length] ;
      
      dp[0] = arr[0] ;
      long max =  dp[0] ;
      
      
      for(int i = 1; i <  arr.length ; i++)
      {
            if(dp[i-1] > 0)
            {
                  dp[i] = dp[i-1] + arr[i] ;
            }
            else{
                  dp[i] = arr[i] ;
            }
            
            if(dp[i] >  max)max = dp[i] ;
            
      }
      
      return max  ;
      
}
/////////////////////////////////////////////////////////////////////////////////////////////
public static long kadanesAlgorithm(int[] arr)
{
     if(arr.length == 0)return  0 ;
    
      long[] dp = new long[arr.length] ;
      
      dp[0] = arr[0] ;
      long max =  dp[0] ;
      
      
      for(int i = 1; i <  arr.length ; i++)
      {
            if(dp[i-1] > 0)
            {
                  dp[i] = dp[i-1] + arr[i] ;
            }
            else{
                  dp[i] = arr[i] ;
            }
            
            if(dp[i] >  max)max = dp[i] ;
            
      }
      
      return max  ;
      
}

      
///////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

//TO GENERATE ALL(DUPLICATE ALSO EXIST) PERMUTATIONS OF A STRING


// JUST CALL generatePermutation( str,  start,  end) start :inclusive ,end : exclusive 

//Function for swapping the characters at position I with character at position j  
    public static String swapString(String a, int i, int j) {  
        char[] b =a.toCharArray();  
        char ch;  
        ch = b[i];  
        b[i] = b[j];  
        b[j] = ch;  
        return String.valueOf(b);  
    }  
      
//Function for generating different permutations of the string  
    public static void generatePermutation(String str, int start, int end)  
    {  
        //Prints the permutations  
        if (start == end-1)  
            System.out.println(str);  
        else  
        {  
            for (int i = start; i < end; i++)  
            {  
                //Swapping the string by fixing a character  
                str = swapString(str,start,i);  
                //Recursively calling function generatePermutation() for rest of the characters   
                generatePermutation(str,start+1,end);  
                //Backtracking and swapping the characters again.  
                str = swapString(str,start,i);  
            }  
        }  
    }  



////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////

public static long factMod(long n, long mod) {
    if (n <= 1) return 1;
    long ans = 1;
    for (int i = 1; i <= n; i++) {
      ans = (ans * i) % mod;
    }
    return ans;
  }


/////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

public static long power(int a  ,int b)
    {
        //time comp : o(logn) 
        
        long x = (long)(a) ;
         long n = (long)(b) ;
        
        if(n==0)return 1 ;
        if(n==1)return x;
        
        long ans =1L  ;
       
      while(n>0)
      {
          if(n % 2 ==1)
          {
              ans = ans *x ;
          }
           
          n = n/2L ;
           
          x =  x*x ;
           
      }
       
      return ans ;
    }
    
    public static long power(long a  ,long b)
    {
        //time comp : o(logn) 
        
        long x = (a) ;
         long n = (b) ;
        
        if(n==0)return 1L ;
        if(n==1)return x;
        
        long ans =1L  ;
       
      while(n>0)
      {
          if(n % 2 ==1)
          {
              ans = ans *x ;
          }
           
          n = n/2L ;
           
          x =  x*x ;
           
      }
       
      return ans ;
    }

    
    
    

////////////////////////////////////////////////////////////////////////////////////////////////////
public static long powerMod(long x, long n, long mod) {
    //time comp : o(logn)
    
    if(n==0)return 1L ;
        if(n==1)return x;
        
    
    long ans = 1;
    while (n > 0) {
      if (n % 2 == 1) ans = (ans * x) % mod;
      x = (x * x) % mod;
      n /= 2;
    }
    return ans;
  }
 
//////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////

/*
lowerBound - finds largest element equal or less than value paased
upperBound - finds smallest element equal or more than value passed

if not present return -1;

*/

public static long lowerBound(long[] arr,long k)
	{
		long ans=-1;
		
		int start=0;
		int end=arr.length-1;
		
		while(start<=end)
		{
			int mid=(start+end)/2;
			
			if(arr[mid]<=k)
			{
				ans=arr[mid];
				start=mid+1;
			}
			else
			{
				end=mid-1;
			}
			
		}
		
		return ans;
		
	}
	
	public static int lowerBound(int[] arr,int k)
	{
		int ans=-1;
		
		int start=0;
		int end=arr.length-1;
		
		while(start<=end)
		{
			int mid=(start+end)/2;
			
			if(arr[mid]<=k)
			{
				ans=arr[mid];
				start=mid+1;
			}
			else
			{
				end=mid-1;
			}
			
		}
		
		return ans;
		
	}
	
	
	public static long upperBound(long[] arr,long k)
	{
		long ans=-1;
		
		int start=0;
		int end=arr.length-1;
		
		while(start<=end)
		{
			int mid=(start+end)/2;
			
			if(arr[mid]>=k)
			{
				ans=arr[mid];
				end=mid-1;
			}
			else
			{
				start=mid+1;
			}
			
		}
		
		return ans;
	}
	
	
	public static int upperBound(int[] arr,int k)
	{
		int ans=-1;
		
		int start=0;
		int end=arr.length-1;
		
		while(start<=end)
		{
			int mid=(start+end)/2;
			
			if(arr[mid]>=k)
			{
				ans=arr[mid];
				end=mid-1;
			}
			else
			{
				start=mid+1;
			}
			
		}
		
		return ans;
	}
	

//////////////////////////////////////////////////////////////////////////////////////////

public static void printArray(int[] arr , int si ,int ei)
{
    for(int i = si  ; i  <= ei ; i++)
    {
        out.print(arr[i] +"" "") ;
    }
    
}

public static void printArrayln(int[] arr , int si ,int ei)
{
    for(int i = si  ; i  <= ei ; i++)
    {
        out.print(arr[i] +"" "") ;
    }
    out.println() ;
}


public static void printLArray(long[] arr , int si , int ei)
{
    for(int i = si ; i  <= ei ; i++)
    {
        out.print(arr[i] +"" "") ;
    }
   
}




public static void printLArrayln(long[] arr , int si , int ei)
{
    for(int i = si ; i  <= ei ; i++)
    {
        out.print(arr[i] +"" "") ;
    }
    out.println() ;
   
}

public static void printtwodArray(int[][] ans)
{
    for(int i = 0; i< ans.length ; i++)
    {
        for(int j  = 0 ; j <  ans[0].length ; j++)out.print(ans[i][j] +"" "");
        out.println() ;
    }
    out.println() ;
   
}

  
   static long modPow(long a, long x, long p) {
    //calculates a^x mod p in logarithmic time.
    long res = 1L;
    while(x > 0) {
        if( x % 2 != 0) {
            res = (res * a) % p;
        }
        a = (a * a) % p;
        x /= 2;
    }
    return res;
}
 
 
 
  static long modInverse(long a, long p) {
    //calculates the modular multiplicative of a mod p.
    //(assuming p is prime).
    return modPow(a, p-2, p);
}
 
 static long[] factorial =  new long[1000001] ;
 
 static void modfac(long mod)
 {
     factorial[0]=1L ; factorial[1]=1L ;
     
     for(int i = 2; i<= 1000000 ;i++)
     {
         factorial[i] = factorial[i-1] *(long)(i) ;
          factorial[i] = factorial[i] % mod ;
     }
    
     
 }
 

 
 
 
static long modBinomial(long n, long r, long p) {
// calculates C(n,r) mod p (assuming p is prime).
 
  if(n < r) return 0L ; 
 
    long num = factorial[(int)(n)] ;
    
    long den = (factorial[(int)(r)]*factorial[(int)(n-r)]) %  p ;
    
    
    long ans  = num*(modInverse(den,p)) ;
    
    ans = ans % p ;
    
    return ans  ;
 
    
}
 
 
 static void update(int val , long[] bit ,int n)
 {
     for( ; val <= n ; val += (val &(-val)) )
     {
         bit[val]++ ;
     }
    
     
 }
 
 
 static long query(int val , long[] bit , int n)
 {
     long ans = 0L; 
     for( ; val >=1 ; val-=(val&(-val))  )ans += bit[val];
     
     return ans ;
 }



static int countSetBits(long n) 
    { 
        int count = 0; 
        while (n > 0) { 
            n = (n) & (n - 1L); 
            count++; 
        } 
        return count; 
    } 


static int abs(int x)
{
    if(x < 0)x = -1*x ;
    
    return x ;
}


static long abs(long x)
{
    if(x < 0)x = -1L*x ;
    
    return x ;

}

////////////////////////////////////////////////////////////////////////////////////////////////
static void p(int val)
{
    out.print(val) ;
}

static void p()
{
    out.print("" "") ;
}

static void pln(int val)
{
    out.println(val) ;
}

static void pln()
{
    out.println() ;
}


static void p(long val)
{
    out.print(val) ;
}



static void pln(long val)
{
    out.println(val) ;
}

////////////////////////////////////////////////////////////////////////////////////////////

 // calculate total no of nos greater than or equal to key in  sorted array arr
 
static  int bs(int[] arr, int s ,int e  ,int key)
{
    if( s> e)return 0 ;
    
     int mid = (s+e)/2 ;
        
        if(arr[mid] <key)
        {
            return bs(arr ,mid+1,e , key) ;
            
        }
        
        
        else{
            
             return bs(arr ,s ,mid-1, key)  + e-mid+1;
            
            
        }
}
 
// static ArrayList<Integer>[] adj ;
// static int mod= 1000000007 ;


 



//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

public static void solve()
{
FastReader scn = new FastReader() ;

//Scanner scn = new Scanner(System.in);
//int[] store = {2 ,3, 5 , 7  ,11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 } ;

// product of first 11 prime nos is greater than 10 ^ 12;
//sieve() ;
//ArrayList<Integer> arr[] = new ArrayList[n] ;
ArrayList<Integer> list = new ArrayList<>() ;
ArrayList<Long> lista = new ArrayList<>() ;
ArrayList<Long> listb = new ArrayList<>() ;
// ArrayList<Integer> lista = new ArrayList<>() ;
// ArrayList<Integer> listb = new ArrayList<>() ;
//ArrayList<String> lists = new ArrayList<>() ;

HashMap<Integer,Integer> map = new HashMap<>() ;
//HashMap<Long,Long> map = new HashMap<>() ;
HashMap<Integer,Integer> mapx  = new HashMap<>() ;
HashMap<Integer,Integer> mapy  = new HashMap<>() ;
//HashMap<String,Integer> maps = new HashMap<>() ;
//HashMap<Integer,Boolean> mapb = new HashMap<>() ;
//HashMap<Point,Integer> point = new HashMap<>() ; 

 Set<Integer> set = new HashSet<>() ;
 Set<Integer> setx = new HashSet<>() ;
 Set<Integer> sety = new HashSet<>() ;

StringBuilder sb =new StringBuilder("""") ;

//Collections.sort(list);

//if(map.containsKey(arr[i]))map.put(arr[i] , map.get(arr[i]) +1 ) ;
//else map.put(arr[i],1) ;

// if(map.containsKey(temp))map.put(temp , map.get(temp) +1 ) ;
// else map.put(temp,1) ;

//int bit  =Integer.bitCount(n);
// gives total no of set bits in n;

// Arrays.sort(arr, new Comparator<Pair>() {
// 			@Override
// 			public int compare(Pair a, Pair b) {
// 				if (a.first != b.first) {
// 					return a.first - b.first; // for increasing order of first
// 				}
// 				return a.second - b.second ; //if first is same then sort on second basis
// 			}
// 		});


int testcase = 1;
 testcase = scn.nextInt() ;
for(int testcases =1  ; testcases <= testcase ;testcases++)
{
    
 //if(map.containsKey(arr[i]))map.put(arr[i],map.get(arr[i])+1) ;else map.put(arr[i],1) ;
 //if(map.containsKey(temp))map.put(temp,map.get(temp)+1) ;else map.put(temp,1) ;
 
 //adj = new ArrayList[n] ;

// for(int i = 0; i< n; i++)
// {
//     adj[i] = new ArrayList<Integer>();
// }

// long n = scn.nextLong() ;
//String s = scn.next() ;


long n = scn.nextLong() ;
long m = scn.nextLong() ;
long k = scn.nextLong() ;

if( n < m)
{
    n =n^m ;
    m =n^m ;
    n =n^m ;
}


if(k < n)pln(-1) ;

else{
    
    long ans = 0 ;
    
    
    
    
    if( n % 2 == 0 && m % 2 == 0 && k% 2 == 0)
    {
        ans = k ;
    }
    
    else if( n % 2 == 0 && m % 2 == 0 && k% 2 == 1)
    {
        ans = k-2  ;
    }
    
    else if( n % 2 == 1 && m % 2 == 1 && k% 2 == 0)
    {
        ans = k-2  ;
    }
    
     else if( n % 2 == 1 && m % 2 == 1 && k% 2 == 1)
    {
        ans =  k;
    }
    
    else{
         ans =k-1  ;
        
    }
    
    
    pln(Math.max(ans , 0 ) ) ;
    
    
    
    
    
}

//out.println(ans) ;
//out.println(ans+"" ""+in) ;

//out.println(""Case #"" + testcases + "": ""  + ans ) ;
//out.println(""@"") ;
set.clear() ;
sb.delete(0 , sb.length()) ;
list.clear() ;lista.clear() ;listb.clear() ;
map.clear() ;
mapx.clear() ;
mapy.clear() ;
setx.clear() ;sety.clear() ;

} // test case  end loop


out.flush() ;  
} // solve fn ends


public static void main (String[] args) throws java.lang.Exception
{
  

solve() ;
      
}


}
  
 class Pair 
{
  int first ;
  
int second  ;
  
  
 
    
      
@Override
	public String toString() {
	
	String ans = """" ;
	ans  += this.first ;
	ans += "" "";
	ans += this.second ;
	
	return ans  ;
	}


}

",1036_B,CODEFORCES,2057,Diagonal Walking v,"Mikhail walks on a Cartesian plane. He starts at the point $$$(0, 0)$$$, and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $$$(0, 0)$$$, he can go to any of the following points in one move: 
If Mikhail goes from the point $$$(x1, y1)$$$ to the point $$$(x2, y2)$$$ in one move, and $$$x1 \ne x2$$$ and $$$y1 \ne y2$$$, then such a move is called a diagonal move.
Mikhail has $$$q$$$ queries. For the $$$i$$$-th query Mikhail's target is to go to the point $$$(n_i, m_i)$$$ from the point $$$(0, 0)$$$ in exactly $$$k_i$$$ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in $$$k_i$$$ moves.
Note that Mikhail can visit any point any number of times (even the destination point!).
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 10^4$$$) — the number of queries.
Then $$$q$$$ lines follow. The $$$i$$$-th of these $$$q$$$ lines contains three integers $$$n_i$$$, $$$m_i$$$ and $$$k_i$$$ ($$$1 \le n_i, m_i, k_i \le 10^{18}$$$) — $$$x$$$-coordinate of the destination point of the query, $$$y$$$-coordinate of the destination point of the query and the number of moves in the query, correspondingly.
Print $$$q$$$ integers. The $$$i$$$-th integer should be equal to -1 if Mikhail cannot go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in exactly $$$k_i$$$ moves described above. Otherwise the $$$i$$$-th integer should be equal to the the maximum number of diagonal moves among all possible movements.
One of the possible answers to the first test case: $$$(0, 0) \to (1, 0) \to (1, 1) \to (2, 2)$$$.
","input
One of the possible answers to the second test case: $$$(0, 0) \to (0, 1) \to (1, 2) \to (0, 3) \to (1, 4) \to (2, 3) \to (3, 2) \to (4, 3)$$$.
output
In the third test case Mikhail cannot reach the point $$$(10, 1)$$$ in 9 moves.
",math,3
"import java.io.*;
import java.util.*;

public class E {

	static final int P = 1_000_000_007;

	void submit() {
		int m = nextInt();
		int n = nextInt();

		int[][] ways = new int[m + 10][];
		for (int i = 0; i < ways.length; i++) {
			ways[i] = new int[i + 1];
			ways[i][0] = ways[i][i] = 1;
			for (int j = 1; j < i; j++) {
				ways[i][j] = (ways[i - 1][j] + ways[i - 1][j - 1]) % P;
			}
		}

		int[] bell = new int[m + 1];
		bell[0] = 1;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j <= i; j++) {
				bell[i + 1] += (int) ((long) bell[j] * ways[i][j] % P);
				if (bell[i + 1] >= P) {
					bell[i + 1] -= P;
				}
			}
		}

		char[][] f = new char[n][];
		for (int i = 0; i < n; i++) {
			f[i] = nextToken().toCharArray();
		}
		
		HashMap<Long, Integer> map = new HashMap<>();
		
		for (int i = 0; i < m; i++) {
			long key = 0;
			for (int j = 0; j < n; j++) {
				key *= 2;
				if (f[j][i] == '1') {
					key++;
				}
			}
			map.merge(key, 1, Integer::sum);
		}
		
		int ans = 1;
		for (int size : map.values()) {
			ans = (int)((long)ans * bell[size] % P);
		}
		
		out.println(ans);
	}

	void preCalc() {

	}

	void stress() {

	}

	void test() {

	}

	E() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		preCalc();
		submit();
		// stress();
		// test();
		out.close();
	}

	static final Random rng = new Random();

	static int rand(int l, int r) {
		return l + rng.nextInt(r - l + 1);
	}

	public static void main(String[] args) throws IOException {
		new E();
	}

	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;

	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
		return st.nextToken();
	}

	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	int nextInt() {
		return Integer.parseInt(nextToken());
	}

	long nextLong() {
		return Long.parseLong(nextToken());
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}
}
",0908_E,CODEFORCES,3024,New Year and Entity Enumeration,"You are given an integer m.
Let M = 2m - 1.
You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m.
A set of integers S is called ""good"" if the following hold. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.
Count the number of good sets S, modulo 109 + 7.
The first line will contain two integers m and n (1 ≤ m ≤ 1 000, 1 ≤ n ≤ min(2m, 50)).
The next n lines will contain the elements of T. Each line will contain exactly m zeros and ones. Elements of T will be distinct.
","input
Print a single integer, the number of good sets modulo 109 + 7. 
output
An example of a valid set S is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.
","bitmasks, combinatorics, dp, math",5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Vadim Semenov
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static final class TaskC {
        private static final int MODULO = 1_000_000_000 + 7;

        public void solve(int __, InputReader in, PrintWriter out) {
            long qty = in.nextLong();
            long months = in.nextLong();
            if (qty == 0) {
                out.println(0);
                return;
            }
            qty %= MODULO;
            long pow = pow(2, months + 1);
            qty = (qty * pow) % MODULO;
            long sub = (pow - 2 + MODULO) % MODULO * pow(2, MODULO - 2) % MODULO;
            qty = (qty - sub + MODULO) % MODULO;
            out.println(qty);
        }

        private long pow(long base, long power) {
            long result = 1;
            while (power > 0) {
                if ((power & 1) != 0) {
                    result = (result * base) % MODULO;
                }
                base = (base * base) % MODULO;
                power >>>= 1;
            }
            return result;
        }

    }

    static class InputReader {
        private final BufferedReader reader;
        private StringTokenizer tokenizer;

        public InputReader(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(readLine());
            }
            return tokenizer.nextToken();
        }

        public String readLine() {
            String line;
            try {
                line = reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            return line;
        }

    }
}

",0992_C,CODEFORCES,1181,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;


public class A {

    /**
     * @param args
     */
    public static void main(String[] args) {
        HomeWorks hw = new HomeWorks();
        hw.sol();
        hw.print();
    }

}

class HomeWorks {
    HomeWorks(){
        Scanner scr = new Scanner(System.in);
        
        n = scr.nextInt();
        a = scr.nextInt();
        b = scr.nextInt();
        h = new int[n];
        
        for (int i = 0; i < n; i++){
            h[i] = scr.nextInt();
        }
        scr.close();
    }
    
    void sol() {
        Arrays.sort(h);
        int Vasya = h[b-1];
        int Petya = h[b]; 
        
        ans = Petya - Vasya;
        if (ans < 0){
            ans = 0;
        }
        
    }
    
    void print(){
        PrintWriter pw = new PrintWriter(System.out);
        pw.println(ans);
        pw.flush();
        pw.close();
    }
    
    int ans;
    
    int[] h;
    
    int n;
    int a;
    int b;
}
",0169_A,CODEFORCES,2539,Chores,"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do n chores. Each chore is characterized by a single parameter — its complexity. The complexity of the i-th chore equals hi.
As Petya is older, he wants to take the chores with complexity larger than some value x (hi > x) to leave to Vasya the chores with complexity less than or equal to x (hi ≤ x). The brothers have already decided that Petya will do exactly a chores and Vasya will do exactly b chores (a + b = n).
In how many ways can they choose an integer x so that Petya got exactly a chores and Vasya got exactly b chores?
The first input line contains three integers n, a and b (2 ≤ n ≤ 2000; a, b ≥ 1; a + b = n) — the total number of chores, the number of Petya's chores and the number of Vasya's chores.
The next line contains a sequence of integers h1, h2, ..., hn (1 ≤ hi ≤ 109), hi is the complexity of the i-th chore. The numbers in the given sequence are not necessarily different.
All numbers on the lines are separated by single spaces.
Print the required number of ways to choose an integer value of x. If there are no such ways, print 0.
","input
In the first sample the possible values of x are 3, 4 or 5.
output
In the second sample it is impossible to find such x, that Petya got 3 chores and Vasya got 4.
",sortings,4
"import java.util.*;
import java.math.*;
import java.io.PrintStream;
import static java.lang.Math.*;

public class Task275A {

    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        long l = in.nextLong();
        long r = in.nextLong();

        if (l % 2 == 1) {
            l++;
        }

        if (r - l < 2) {
            out.print(-1);
        }
        else {
            out.print(l + "" "" + (l + 1) + "" "" + (l + 2));
        }
    }

}",0483_A,CODEFORCES,491,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"
import java.io.*;
import java.util.*;
import java.text.*;

public class FollowTrafficRules
{
	public Scanner in = new Scanner(System.in);
	public PrintStream out = System.out;

	public double len, d, w, vmax, a;
	
	DecimalFormat fmt = new DecimalFormat(""0.0000000000000000"");
	
	public void main()
	{
		a = in.nextDouble();
		vmax = in.nextDouble();
		len = in.nextDouble();
		d = in.nextDouble();
		w = in.nextDouble();
		
		out.println(fmt.format(T()));
	}//end public void main()
	
	public double T()
	{
		double t, s;
		
		double t1, s1;
		t1 = vmax / a;
		s1 = vmax*vmax/(2.0*a);
		
		double t3, s3;
		t3 = w/a;
		s3 = w*w/(2.0*a);
				
		if(w >= vmax)
		{
			if(s1 < len)
			{
				return t1 + (len - s1)/vmax;
			}
			else
			{
				return Math.sqrt(2.0*len/a);
			}			
		}
		else
		{
			//w < vmax
			
			double t2, s2, v2;
			t2 = Math.sqrt(2.0*d/a);
			v2 = a*t2;
			
			double tx, vx;
			vx = Math.sqrt((2.0*a*d + w*w)/2.0);
			tx = vx / a;	
			
			//vmax > w

			//v2 > vx > w
			
			if(v2 < w)
			{
				if(v2 > vmax)
				{
					//v2 > vmax > w
					if(vmax > vx)
					{
						return tx + (vx - w)/a + T2(w);
					}
					else
					{
						double ty, sy;
						ty = (vmax - w)/a;
						sy = ty * (vmax + w)/2.0;
						return t1 + ty + (d - s1 - sy)/vmax + T2(w);
					}
				}
				else
				{
					//v2 < w, v2 <= vmax
					return t2 + T2(v2);					
				}
			}
			else if(v2 > vmax) //v2 >= w, vmax > w
			{
				//v2 > vmax > w
				if(vmax > vx)
				{
					return tx + (vx - w)/a + T2(w);
				}
				else
				{
					double ty, sy;
					ty = (vmax - w)/a;
					sy = ty * (vmax + w)/2.0;
					return t1 + ty + (d - s1 - sy)/vmax + T2(w);
				}
			}
			else  //vmax >= v2 >= w
			{
				//out.println(""Questionable."");
				//return binary() + T2(w);
				
				//return  t3 + (d-s3)/w + T2(w);

				return tx + (vx - w)/a + T2(w);
			}
		}
	}
	
	public double binary()
	{
		double low, high, t, s;
		low = 0.0; high = vmax/a;
		
		for(int c=0;c<50;++c)
		{
			t = (low+high)/2;
			s = (a*t*t)/2 + ((a*t - w)/a)*(a*t + w)/2.0;
			
			if(s > d) high = t;
			else low = t;
		}
		t = (low+high)/2;
		return t + (a*t - w)/a;
	}
	
/*
	public double T()
	{
		double t1, s1, tx, sx, vx, ty, vy, sz, tz;
		t1 = vmax / a;
		s1 = a*t1*t1 / 2.0;
		
		vx = Math.sqrt((2.0*a*d + w*w)/2.0);
		tx = vx / a;
		
		if(s1 < d)
		{
			//reaches vmax
			if(vx < vmax)
			{
				//stops at vx
				return tx + (vx - w)/a + T2(w);
			}
			else //vx >= vmax
			{
				//stops at vmax
				if(w > vmax)
				{
					return t1 + (d - s1)/vmax + T2(vmax);
				}
				else
				{
					tz = (vmax - w)/a;
					sz = ((vmax + w)/2.0) * tz;
					
					return t1 + (d-sz-s1)/vmax + tz + T2(w);					
				}
			}
		}
		else //s1 >= d
		{
			//never reaches vmax
			vy = Math.sqrt(2.0*d*a);
			ty = vy / a;
			if(vx < vy)
			{
				//stops at vx
				return tx + (vx - w)/a + T2(w);
			}
			else //vx >= vy
			{
				if(w < vy)
				{
					return w/a + (d - w*w/(2.0*a))/w + T2(w);
				}
				else //w >= vy
				{
					//goes to vy, accelerate all the way
					return ty + T2(vy);		
				}
			}
		}
	}
*/	
	public double T2(double v0)
	{
		//v0 <= min(w, vmax)
		
		double t1, s1;
		t1 = (vmax - v0)/a;
		s1 = ((vmax + v0)/2.0)*t1;
		
		if(s1 < len-d)
		{
			//reaches vmax
			return t1 + (len-d-s1)/vmax;
		}
		else //s1 >= len - d
		{
			//does not reach vmax
			return (-v0 + Math.sqrt(v0*v0 + 2*a*(len-d)))/a;
		}
	}
	
	public static void main(String[] args)
	{
		(new FollowTrafficRules()).main();
	}
}",0005_D,CODEFORCES,35,Follow Traffic Rules,"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.
It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km/h2, and has maximum speed of v km/h. The road has the length of l km, and the speed sign, limiting the speed to w km/h, is placed d km (1 ≤ d < l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.
The car can enter Bercouver at any speed.
","input
The first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).
output
Print the answer with at least five digits after the decimal point.
","implementation, math",1
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;
/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.readInt();
            int[] a = IOUtils.readIntArray(in, n);
            MiscUtils.decreaseByOne(a);
            int m = in.readInt();
            int parity = inversions(a) % 2;
            boolean[] lengthToParityFlip = new boolean[n + 1];
            for (int length = 1; length < lengthToParityFlip.length; length++) {
                lengthToParityFlip[length] = (((length * (length - 1) / 2) % 2) == 1);
            }
            for (int query = 0; query < m; query++) {
                int l = in.readInt() - 1, r = in.readInt() - 1;
                int length = r - l + 1;
                if (lengthToParityFlip[length]) {
                    parity ^= 1;
                }
                out.printLine(parity == 0 ? ""even"" : ""odd"");
            }
        }

        private int inversions(int[] a) {
            int res = 0;
            for (int j = 0; j < a.length; j++) {
                for (int i = j + 1; i < a.length; i++) {
                    if (a[i] < a[j]) {
                        res++;
                    }
                }
            }
            return res;
        }
    }
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void printLine(Object... objects) {
            print(objects);
            writer.println();
        }

        public void close() {
            writer.close();
        }
    }
    static class MiscUtils {
        public static void decreaseByOne(int[]... arrays) {
            for (int[] array : arrays) {
                for (int i = 0; i < array.length; i++) {
                    array[i]--;
                }
            }
        }
    }
    static class IOUtils {
        public static int[] readIntArray(InputReader in, int size) {
            int[] array = new int[size];
            for (int i = 0; i < size; i++) {
                array[i] = in.readInt();
            }
            return array;
        }
    }
}

",0911_D,CODEFORCES,3163,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.util.*;
import java.lang.*;
import java.io.*;
import java.awt.*;

// U KNOW THAT IF THIS DAY WILL BE URS THEN NO ONE CAN DEFEAT U HERE................
//JUst keep faith in ur strengths .................................................. 


// ASCII = 48 + i ;// 2^28 = 268,435,456  > 2* 10^8 // log 10 base 2 = 3.3219 
// odd:: (x^2+1)/2 , (x^2-1)/2 ; x>=3// even:: (x^2/4)+1 ,(x^2/4)-1  x >=4 
// FOR ANY ODD NO N : N,N-1,N-2
//ALL ARE PAIRWISE COPRIME 
//THEIR COMBINED LCM IS PRODUCT OF ALL THESE NOS

// two consecutive odds are always coprime to each other
// two consecutive even have always gcd  = 2 ;

// Rectangle r = new Rectangle(int x , int y,int widht,int height) 
//Creates a rect. with bottom left cordinates as (x, y) and top right as ((x+width),(y+height))

//BY DEFAULT Priority Queue is MIN in nature in java
//to use as max , just push with negative sign and change sign after removal 

// We can make a sieve of max size 1e7 .(no time or space issue) 
// In 1e7 starting nos we have about 66*1e4 prime nos 

 public class Main
{
     
    // static int[] arr = new int[100002] ; 
    // static int[] dp = new int[100002] ;  
    
     static PrintWriter out;
    
	static class FastReader{
		BufferedReader br;
		StringTokenizer st;
		public FastReader(){
			br=new BufferedReader(new InputStreamReader(System.in));
			out=new PrintWriter(System.out);
		}
		String next(){
			while(st==null || !st.hasMoreElements()){
				try{
					st= new StringTokenizer(br.readLine());
				}
				catch (IOException e){
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}
		int nextInt(){
			return Integer.parseInt(next());
		}
		long nextLong(){
			return Long.parseLong(next());
		}
		double nextDouble(){
			return Double.parseDouble(next());
		}
		String nextLine(){
			String str = """";
			try{
				str=br.readLine();
			}
			catch(IOException e){
				e.printStackTrace();
			}
			return str;
		}
	}
	


////////////////////////////////////////////////////////////////////////////////////
 public static int countDigit(long n) 
    { 
        return (int)Math.floor(Math.log10(n) + 1); 
    } 

///////////////////////////////////////////////////////////////////////////////////////// 
 
 public static int sumOfDigits(long n)
 {
  
  if( n< 0)return -1 ;
  
  int sum = 0;
  
  while( n > 0)
  {
      sum = sum + (int)( n %10) ;
      
      n /= 10 ;
  }
     
  return sum ;  
 
 
 
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////////////

public static long arraySum(int[] arr , int start , int end)
{
    long ans = 0 ;
    
    for(int i = start ; i <= end  ; i++)ans += arr[i] ;
    
    return ans  ;
}

/////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////

public static void swapArray(int[] arr , int start , int end)
{
    while(start < end)
    {
        int temp = arr[start] ;
        arr[start] = arr[end];
        arr[end] = temp;
        start++ ;end-- ;
    }
}


//////////////////////////////////////////////////////////////////////////////////

static long factorial(long a)
{
    if(a== 0L || a==1L)return 1L ;
    
    return a*factorial(a-1L) ;
}

///////////////////////////////////////////////////////////////////////////////


public static int[][] rotate(int[][] input){

int n =input.length;
int m = input[0].length ;
int[][] output = new int [m][n];

for (int i=0; i<n; i++)
	for (int j=0;j<m; j++)
		output [j][n-1-i] = input[i][j];
return output;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////// ////////////////////////////////////////////////   

public static boolean isPowerOfTwo(long n) 
{ 
    if(n==0) 
    return false; 
  
if(((n ) & (n-1)) == 0 ) return true ;
else return false  ;

} 

/////////////////////////////////////////////////////////////////////////////////////

 
/////////////////////////////////////////////////////////////////////////////////// 

public static String reverse(String input)
{
  StringBuilder str  = new StringBuilder("""") ;
   
    for(int i =input.length()-1 ; i >= 0  ; i-- )
    {
        str.append(input.charAt(i));
    }
    
return str.toString() ;
}
///////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////
public static boolean isPossibleTriangle(int a  ,int b , int c)
{
      if( a + b > c && c+b > a && a +c > b)return true  ;
      else return false  ;
}


////////////////////////////////////////////////////////////////////////////////////////////
static long xnor(long num1, long num2) {
		if (num1 < num2) {
			long temp = num1;
			num1 = num2;
			num2 = temp;
		}
		num1 = togglebit(num1);
		return num1 ^ num2;
	}

	static long togglebit(long n) {
		if (n == 0)
			return 1;
		long i = n;
		n |= n >> 1;
		n |= n >> 2;
		n |= n >> 4;
		n |= n >> 8;
		n |= n >> 16;
		return i ^ n;
	}

///////////////////////////////////////////////////////////////////////////////////////////////

public static int xorOfFirstN(int n)
{
 
 
 if( n % 4 ==0)return n ;
 
 else if( n % 4 == 1)return 1 ;
 
 else if( n % 4 == 2)return n+1 ;
 
 else return 0 ;
 
    
}
//////////////////////////////////////////////////////////////////////////////////////////////

public static int gcd(int a, int b )
{

if(b==0)return a ;

else return gcd(b,a%b) ; 

}


public static long gcd(long a, long b )
{

if(b==0)return a ;

else return gcd(b,a%b) ; 

}

////////////////////////////////////////////////////////////////////////////////////

public static int lcm(int a, int b ,int c , int d )
{

int temp = lcm(a,b , c) ;


 
 int ans = lcm(temp ,d ) ;

return ans  ;


}

///////////////////////////////////////////////////////////////////////////////////////////

public static int lcm(int a, int b ,int c )
{

int temp = lcm(a,b) ;

int ans =  lcm(temp ,c) ;

return ans  ;


}

////////////////////////////////////////////////////////////////////////////////////////
    
public static int lcm(int a , int b )
{

int gc = gcd(a,b);

return (a/gc)*b ;
}


public static long lcm(long a , long b )
{

long gc = gcd(a,b);

return (a/gc)*b;
}


///////////////////////////////////////////////////////////////////////////////////////////
static boolean isPrime(long n)
{
      if(n==1)
      {
            return false  ;
      }
      
      boolean ans =  true  ;
      
      for(long i = 2L; i*i <= n ;i++)
      {
            if(n% i ==0)
            {
                  ans = false  ;break ;
            }
      }
      
      
      return ans  ;
} 

static boolean isPrime(int n)
{
      if(n==1)
      {
            return false  ;
      }
      
      boolean ans =  true  ;
      
      for(int i = 2; i*i <= n ;i++)
      {
            if(n% i ==0)
            {
                  ans = false  ;break ;
            }
      }
      
      
      return ans  ;
}      


///////////////////////////////////////////////////////////////////////////

static int sieve =  1000000 ;

 
static boolean[] prime =  new boolean[sieve + 1] ;

public static void sieveOfEratosthenes() 
    { 
        // FALSE == prime
        
        // TRUE ==  COMPOSITE
        
        // FALSE== 1
       
        
        // time complexity = 0(NlogLogN)== o(N)
        
        // gives prime nos bw 1 to N
        
        for(int i = 4; i<= sieve ; i++)
        {
            prime[i] = true  ;
            i++ ;
        }
        
        for(int p = 3; p*p <= sieve; p++) 
        { 
           
            if(prime[p] == false) 
            { 
                
                for(int i = p*p; i <= sieve; i += p) 
                    prime[i] = true; 
            } 
            
            p++ ;
        } 
          
       
       
    
    } 
 
///////////////////////////////////////////////////////////////////////////////////


public static void sortD(int[] arr , int s  , int e)
{
      sort(arr ,s , e) ;
      
      int i =s ; int j = e  ;
      
      while( i < j)
      {
            int temp = arr[i] ;
            arr[i] =arr[j] ;
            arr[j] = temp ;
            i++ ; j-- ;
      }
      
      
      
      return ;
}


/////////////////////////////////////////////////////////////////////////////////////////

public static long countSubarraysSumToK(long[] arr ,long sum )
    {
      HashMap<Long,Long> map = new HashMap<>() ;
       
      int n = arr.length ;
       
      long prefixsum = 0 ;
       
      long count = 0L ;
      for(int i  = 0; i < n ; i++)
      {
          prefixsum  = prefixsum +  arr[i] ;
           
          if(sum == prefixsum)count = count+1 ;
           
          if(map.containsKey(prefixsum -sum))
          {
              count = count + map.get(prefixsum -sum) ;
          }
          
          
          if(map.containsKey(prefixsum ))
          {
              map.put(prefixsum , map.get(prefixsum) +1 );
          }
          
          else{
              map.put(prefixsum , 1L );
          }
           
           
      }
        
        
        
      return count  ;  
        
    }

///////////////////////////////////////////////////////////////////////////////////////////////


// KMP ALGORITHM : TIME COMPL:O(N+M) 
// FINDS THE OCCURENCES OF PATTERN AS A  SUBSTRING IN STRING
//RETURN THE ARRAYLIST OF INDEXES 
// IF SIZE OF LIST IS ZERO MEANS PATTERN IS NOT PRESENT IN STRING


public static ArrayList<Integer> kmpAlgorithm(String str , String pat)
     {
        ArrayList<Integer> list =new ArrayList<>();
        
        int n = str.length() ;
        int m = pat.length() ;
        
        String q = pat + ""#"" + str ;
        
        int[] lps  =new int[n+m+1] ;
        
         longestPefixSuffix(lps, q,(n+m+1)) ;
         
         
         for(int i =m+1 ; i < (n+m+1) ; i++ )
         {
             if(lps[i] == m)
             {
                 list.add(i-2*m) ;
             }
         }
        
        return list ; 
         
        
    }
    

public static void longestPefixSuffix(int[] lps ,String str , int n)
    {
        lps[0] =  0 ;
        
        for(int i = 1  ; i<= n-1; i++)
        {
          int l = lps[i-1] ;
           
          while( l > 0 && str.charAt(i) != str.charAt(l))
          {
              l = lps[l-1] ;
          }
           
          if(str.charAt(i) == str.charAt(l))
          {
              l++ ;
          }
            
           
          lps[i] = l ; 
        }
        
    }
    
     

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

 // CALCULATE TOTIENT Fn FOR ALL VALUES FROM 1 TO n
    // TOTIENT(N) = count of nos less than n and grater than 1 whose gcd with n is 1 
    // or n and the no  will be coprime in nature
    //time : O(n*(log(logn)))
    
    public static void eulerTotientFunction(int[] arr ,int n )
    {
      
      for(int i = 1; i <= n  ;i++)arr[i] =i  ;
      
      
      for(int i= 2 ; i<= n ;i++)
      {
          if(arr[i] == i)
          {
              arr[i] =i-1 ;
              
              for(int j =2*i ; j<= n  ; j+= i )
              {
                  arr[j] = (arr[j]*(i-1))/i ;
              }
              
          }
      }
        
      return  ;  
        
    }
	
/////////////////////////////////////////////////////////////////////////////////////////////
public static long nCr(int n,int k)
{
    long ans=1L;
    k=k>n-k?n-k:k;
    int j=1;
    for(;j<=k;j++,n--)
    {
        if(n%j==0)
        {
            ans*=n/j;
        }else
        if(ans%j==0)
        {
            ans=ans/j*n;
        }else
        {
            ans=(ans*n)/j;
        }
    }
    return ans;
}

///////////////////////////////////////////////////////////////////////////////////////////

public static ArrayList<Integer> allFactors(int n)
{   
      ArrayList<Integer> list = new ArrayList<>() ;
      
    for(int i = 1; i*i <= n ;i++)
    {
          if( n % i == 0)
          {
              if(i*i == n)
              {
                    list.add(i) ;
              }
              else{
                    list.add(i) ;
                    list.add(n/i) ;
                    
              }
          }
    }
      
     return list ; 
      
      
}


public static ArrayList<Long> allFactors(long n)
{   
      ArrayList<Long> list = new ArrayList<>() ;
      
    for(long i = 1L; i*i <= n ;i++)
    {
          if( n % i == 0)
          {
              if(i*i == n)
              {
                    list.add(i) ;
              }
              else{
                    list.add(i) ;
                    list.add(n/i) ;
                    
              }
          }
    }
      
     return list ; 
      
      
}
////////////////////////////////////////////////////////////////////////////////////////////////////

  static final int MAXN = 1000001; 
       
    
    static int spf[] = new int[MAXN]; 
   
    static void sieve() 
    { 
        spf[1] = 1; 
        for (int i=2; i<MAXN; i++) 
       
           
            spf[i] = i; 
       
       
        for (int i=4; i<MAXN; i+=2) 
            spf[i] = 2; 
       
        for (int i=3; i*i<MAXN; i++) 
        { 
           
            if (spf[i] == i) 
            { 
               
                for (int j=i*i; j<MAXN; j+=i) 
       
                    if (spf[j]==j) 
                        spf[j] = i; 
            } 
        } 
    } 
       

    static ArrayList<Integer> getPrimeFactorization(int x) 
    { 
        ArrayList<Integer> ret = new ArrayList<Integer>(); 
        while (x != 1) 
        { 
            ret.add(spf[x]); 
            x = x / spf[x]; 
        } 
        return ret; 
    } 
       
 //////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////
   
public static void merge(int arr[], int l, int m, int r)
    {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;
 
        /* Create temp arrays */
        int L[] = new int[n1];
        int R[] = new int[n2];
 
       //Copy data to temp arrays
        for (int i=0; i<n1; ++i)
            L[i] = arr[l + i];
        for (int j=0; j<n2; ++j)
            R[j] = arr[m + 1+ j];
 
 
        /* Merge the temp arrays */
 
        // Initial indexes of first and second subarrays
        int i = 0, j = 0;
 
        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2)
        {
            if (L[i] <= R[j])
            {
                arr[k] = L[i];
                i++;
            }
            else
            {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
 
        /* Copy remaining elements of L[] if any */
        while (i < n1)
        {
            arr[k] = L[i];
            i++;
            k++;
        }
 
        /* Copy remaining elements of R[] if any */
        while (j < n2)
        {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
 
    // Main function that sorts arr[l..r] using
    // merge()
  public static void sort(int arr[], int l, int r)
    {
        if (l < r)
        {
            // Find the middle point
            int m = (l+r)/2;
 
            // Sort first and second halves
            sort(arr, l, m);
            sort(arr , m+1, r);
 
            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

public static void sort(long arr[], int l, int r)
    {
        if (l < r)
        {
            // Find the middle point
            int m = (l+r)/2;
 
            // Sort first and second halves
            sort(arr, l, m);
            sort(arr , m+1, r);
 
            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }


public static void merge(long arr[], int l, int m, int r)
    {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;
 
        /* Create temp arrays */
        long L[] = new long[n1];
        long R[] = new long[n2];
 
        //Copy data to temp arrays
        for (int i=0; i<n1; ++i)
            L[i] = arr[l + i];
        for (int j=0; j<n2; ++j)
            R[j] = arr[m + 1+ j];
 
 
        /* Merge the temp arrays */
 
        // Initial indexes of first and second subarrays
        int i = 0, j = 0;
 
        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2)
        {
            if (L[i] <= R[j])
            {
                arr[k] = L[i];
                i++;
            }
            else
            {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
 
        /* Copy remaining elements of L[] if any */
        while (i < n1)
        {
            arr[k] = L[i];
            i++;
            k++;
        }
 
        /* Copy remaining elements of R[] if any */
        while (j < n2)
        {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
 

 /////////////////////////////////////////////////////////////////////////////////////////
 
	public static long knapsack(int[] weight,long value[],int maxWeight){

        
        int n=  value.length ;
        
	
	//dp[i] stores the profit with KnapSack capacity ""i"" 
  long []dp = new long[maxWeight+1]; 
      
    //initially profit with 0 to W KnapSack capacity is 0 
    Arrays.fill(dp, 0); 
  
    // iterate through all items 
    for(int i=0; i < n; i++)  
      
        //traverse dp array from right to left 
        for(int j = maxWeight; j >= weight[i]; j--) 
            dp[j] = Math.max(dp[j] , value[i] + dp[j - weight[i]]); 
              
    /*above line finds out maximum of dp[j](excluding ith element value) 
    and val[i] + dp[j-wt[i]] (including ith element value and the 
    profit with ""KnapSack capacity - ith element weight"") */
    return dp[maxWeight]; 
	}

///////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


// to return max sum of any subarray in given array
public static long kadanesAlgorithm(long[] arr)
{
    
    if(arr.length == 0)return  0 ;
    
      long[] dp = new long[arr.length] ;
      
      dp[0] = arr[0] ;
      long max =  dp[0] ;
      
      
      for(int i = 1; i <  arr.length ; i++)
      {
            if(dp[i-1] > 0)
            {
                  dp[i] = dp[i-1] + arr[i] ;
            }
            else{
                  dp[i] = arr[i] ;
            }
            
            if(dp[i] >  max)max = dp[i] ;
            
      }
      
      return max  ;
      
}
/////////////////////////////////////////////////////////////////////////////////////////////
public static long kadanesAlgorithm(int[] arr)
{
     if(arr.length == 0)return  0 ;
    
      long[] dp = new long[arr.length] ;
      
      dp[0] = arr[0] ;
      long max =  dp[0] ;
      
      
      for(int i = 1; i <  arr.length ; i++)
      {
            if(dp[i-1] > 0)
            {
                  dp[i] = dp[i-1] + arr[i] ;
            }
            else{
                  dp[i] = arr[i] ;
            }
            
            if(dp[i] >  max)max = dp[i] ;
            
      }
      
      return max  ;
      
}

      
///////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

//TO GENERATE ALL(DUPLICATE ALSO EXIST) PERMUTATIONS OF A STRING


// JUST CALL generatePermutation( str,  start,  end) start :inclusive ,end : exclusive 

//Function for swapping the characters at position I with character at position j  
    public static String swapString(String a, int i, int j) {  
        char[] b =a.toCharArray();  
        char ch;  
        ch = b[i];  
        b[i] = b[j];  
        b[j] = ch;  
        return String.valueOf(b);  
    }  
      
//Function for generating different permutations of the string  
    public static void generatePermutation(String str, int start, int end)  
    {  
        //Prints the permutations  
        if (start == end-1)  
            System.out.println(str);  
        else  
        {  
            for (int i = start; i < end; i++)  
            {  
                //Swapping the string by fixing a character  
                str = swapString(str,start,i);  
                //Recursively calling function generatePermutation() for rest of the characters   
                generatePermutation(str,start+1,end);  
                //Backtracking and swapping the characters again.  
                str = swapString(str,start,i);  
            }  
        }  
    }  



////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////

public static long factMod(long n, long mod) {
    if (n <= 1) return 1;
    long ans = 1;
    for (int i = 1; i <= n; i++) {
      ans = (ans * i) % mod;
    }
    return ans;
  }


/////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

public static long power(int a  ,int b)
    {
        //time comp : o(logn) 
        
        long x = (long)(a) ;
         long n = (long)(b) ;
        
        if(n==0)return 1 ;
        if(n==1)return x;
        
        long ans =1L  ;
       
      while(n>0)
      {
          if(n % 2 ==1)
          {
              ans = ans *x ;
          }
           
          n = n/2L ;
           
          x =  x*x ;
           
      }
       
      return ans ;
    }
    
    public static long power(long a  ,long b)
    {
        //time comp : o(logn) 
        
        long x = (a) ;
         long n = (b) ;
        
        if(n==0)return 1L ;
        if(n==1)return x;
        
        long ans =1L  ;
       
      while(n>0)
      {
          if(n % 2 ==1)
          {
              ans = ans *x ;
          }
           
          n = n/2L ;
           
          x =  x*x ;
           
      }
       
      return ans ;
    }

    
    
    

////////////////////////////////////////////////////////////////////////////////////////////////////
public static long powerMod(long x, long n, long mod) {
    //time comp : o(logn)
    
    if(n==0)return 1L ;
        if(n==1)return x;
        
    
    long ans = 1;
    while (n > 0) {
      if (n % 2 == 1) ans = (ans * x) % mod;
      x = (x * x) % mod;
      n /= 2;
    }
    return ans;
  }
 
//////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////

/*
lowerBound - finds largest element equal or less than value paased
upperBound - finds smallest element equal or more than value passed

if not present return -1;

*/

public static long lowerBound(long[] arr,long k)
	{
		long ans=-1;
		
		int start=0;
		int end=arr.length-1;
		
		while(start<=end)
		{
			int mid=(start+end)/2;
			
			if(arr[mid]<=k)
			{
				ans=arr[mid];
				start=mid+1;
			}
			else
			{
				end=mid-1;
			}
			
		}
		
		return ans;
		
	}
	
	public static int lowerBound(int[] arr,int k)
	{
		int ans=-1;
		
		int start=0;
		int end=arr.length-1;
		
		while(start<=end)
		{
			int mid=(start+end)/2;
			
			if(arr[mid]<=k)
			{
				ans=arr[mid];
				start=mid+1;
			}
			else
			{
				end=mid-1;
			}
			
		}
		
		return ans;
		
	}
	
	
	public static long upperBound(long[] arr,long k)
	{
		long ans=-1;
		
		int start=0;
		int end=arr.length-1;
		
		while(start<=end)
		{
			int mid=(start+end)/2;
			
			if(arr[mid]>=k)
			{
				ans=arr[mid];
				end=mid-1;
			}
			else
			{
				start=mid+1;
			}
			
		}
		
		return ans;
	}
	
	
	public static int upperBound(int[] arr,int k)
	{
		int ans=-1;
		
		int start=0;
		int end=arr.length-1;
		
		while(start<=end)
		{
			int mid=(start+end)/2;
			
			if(arr[mid]>=k)
			{
				ans=arr[mid];
				end=mid-1;
			}
			else
			{
				start=mid+1;
			}
			
		}
		
		return ans;
	}
	

//////////////////////////////////////////////////////////////////////////////////////////

public static void printArray(int[] arr , int si ,int ei)
{
    for(int i = si  ; i  <= ei ; i++)
    {
        out.print(arr[i] +"" "") ;
    }
    
}

public static void printArrayln(int[] arr , int si ,int ei)
{
    for(int i = si  ; i  <= ei ; i++)
    {
        out.print(arr[i] +"" "") ;
    }
    out.println() ;
}


public static void printLArray(long[] arr , int si , int ei)
{
    for(int i = si ; i  <= ei ; i++)
    {
        out.print(arr[i] +"" "") ;
    }
   
}




public static void printLArrayln(long[] arr , int si , int ei)
{
    for(int i = si ; i  <= ei ; i++)
    {
        out.print(arr[i] +"" "") ;
    }
    out.println() ;
   
}

public static void printtwodArray(int[][] ans)
{
    for(int i = 0; i< ans.length ; i++)
    {
        for(int j  = 0 ; j <  ans[0].length ; j++)out.print(ans[i][j] +"" "");
        out.println() ;
    }
    out.println() ;
   
}

  
   static long modPow(long a, long x, long p) {
    //calculates a^x mod p in logarithmic time.
    
    a = a % p ;
    
    if(a == 0)return 0L ;
    
    
    long res = 1L;
    while(x > 0) {
        if( x % 2 != 0) {
            res = (res * a) % p;
        }
        a = (a * a) % p;
        x =x/2;
    }
    return res;
}
 
 
 
  static long modInverse(long a, long p) {
    //calculates the modular multiplicative of a mod p.
    //(assuming p is prime).
    return modPow(a, p-2, p);
}
 
 static long[] factorial =  new long[1000001] ;
 
 static void modfac(long mod)
 {
     factorial[0]=1L ; factorial[1]=1L ;
     
     for(int i = 2; i<= 1000000 ;i++)
     {
         factorial[i] = factorial[i-1] *(long)(i) ;
          factorial[i] = factorial[i] % mod ;
     }
    
     
 }
 

 
 
 
static long modBinomial(long n, long r, long p) {
// calculates C(n,r) mod p (assuming p is prime).
 
  if(n < r) return 0L ; 
 
    long num = factorial[(int)(n)] ;
    
    long den = (factorial[(int)(r)]*factorial[(int)(n-r)]) %  p ;
    
    
    long ans  = num*(modInverse(den,p)) ;
    
    ans = ans % p ;
    
    return ans  ;
 
    
}
 
 
 static void update(int val , long[] bit ,int n)
 {
     for( ; val <= n ; val += (val &(-val)) )
     {
         bit[val]++ ;
     }
    
     
 }
 
 
 static long query(int val , long[] bit , int n)
 {
     long ans = 0L; 
     for( ; val >=1 ; val-=(val&(-val))  )ans += bit[val];
     
     return ans ;
 }



static int countSetBits(long n) 
    { 
        int count = 0; 
        while (n > 0) { 
            n = (n) & (n - 1L); 
            count++; 
        } 
        return count; 
    } 


static int abs(int x)
{
    if(x < 0)x = -1*x ;
    
    return x ;
}


static long abs(long x)
{
    if(x < 0)x = -1L*x ;
    
    return x ;

}

////////////////////////////////////////////////////////////////////////////////////////////////
static void p(int val)
{
    out.print(val) ;
}

static void p()
{
    out.print("" "") ;
}

static void pln(int val)
{
    out.println(val) ;
}

static void pln()
{
    out.println() ;
}


static void p(long val)
{
    out.print(val) ;
}



static void pln(long val)
{
    out.println(val) ;
}

////////////////////////////////////////////////////////////////////////////////////////////

 // calculate total no of nos greater than or equal to key in  sorted array arr
 
static  int bs(int[] arr, int s ,int e  ,int key)
{
    if( s> e)return 0 ;
    
     int mid = (s+e)/2 ;
        
        if(arr[mid] <key)
        {
            return bs(arr ,mid+1,e , key) ;
            
        }
        
        
        else{
            
             return bs(arr ,s ,mid-1, key)  + e-mid+1;
            
            
        }
}
 
// static ArrayList<Integer>[] adj ;
// static int mod= 1000000007 ;


 



//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

public static void solve()
{
FastReader scn = new FastReader() ;

//Scanner scn = new Scanner(System.in);
//int[] store = {2 ,3, 5 , 7  ,11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 } ;

// product of first 11 prime nos is greater than 10 ^ 12;
//sieve() ;
//ArrayList<Integer> arr[] = new ArrayList[n] ;
ArrayList<Integer> list = new ArrayList<>() ;
ArrayList<Long> lista = new ArrayList<>() ;
ArrayList<Long> listb = new ArrayList<>() ;
// ArrayList<Integer> lista = new ArrayList<>() ;
// ArrayList<Integer> listb = new ArrayList<>() ;
//ArrayList<String> lists = new ArrayList<>() ;

HashMap<Integer,ArrayList<Pair>> map = new HashMap<>() ;
//HashMap<Long,Long> map = new HashMap<>() ;
HashMap<Integer,Integer> mapx  = new HashMap<>() ;
HashMap<Integer,Integer> mapy  = new HashMap<>() ;
//HashMap<String,Integer> maps = new HashMap<>() ;
//HashMap<Integer,Boolean> mapb = new HashMap<>() ;
//HashMap<Point,Integer> point = new HashMap<>() ; 

 Set<Integer> set = new HashSet<>() ;
 Set<Integer> setx = new HashSet<>() ;
 Set<Integer> sety = new HashSet<>() ;

StringBuilder sb =new StringBuilder("""") ;

//Collections.sort(list);

//if(map.containsKey(arr[i]))map.put(arr[i] , map.get(arr[i]) +1 ) ;
//else map.put(arr[i],1) ;

// if(map.containsKey(temp))map.put(temp , map.get(temp) +1 ) ;
// else map.put(temp,1) ;

//int bit  =Integer.bitCount(n);
// gives total no of set bits in n;

// Arrays.sort(arr, new Comparator<Pair>() {
// 			@Override
// 			public int compare(Pair a, Pair b) {
// 				if (a.first != b.first) {
// 					return a.first - b.first; // for increasing order of first
// 				}
// 				return a.second - b.second ; //if first is same then sort on second basis
// 			}
// 		});


int testcase = 1;
 //testcase = scn.nextInt() ;
for(int testcases =1  ; testcases <= testcase ;testcases++)
{
    
 //if(map.containsKey(arr[i]))map.put(arr[i],map.get(arr[i])+1) ;else map.put(arr[i],1) ;
 //if(map.containsKey(temp))map.put(temp,map.get(temp)+1) ;else map.put(temp,1) ;
 
 //adj = new ArrayList[n] ;

// for(int i = 0; i< n; i++)
// {
//     adj[i] = new ArrayList<Integer>();
// }

// long n = scn.nextLong() ;
//String s = scn.next() ;

int n= scn.nextInt() ;
int[] arr= new int[n] ;

for(int i=0; i < n;i++)
{
    arr[i]= scn.nextInt();
}

for(int r= 0 ; r < n ;r++)
{
    int sum = 0 ;
    for(int l =r ;l>= 0 ;l--)
    {
       sum = sum + arr[l] ;
       
       if(map.containsKey(sum))
       {
           map.get(sum).add(new Pair(l,r)) ;
       }
       else{
           
           map.put(sum,new ArrayList<Pair>());
            map.get(sum).add(new Pair(l,r)) ;
       }
    }
}


 ArrayList<Pair> ans = null ;
 
 int bestcount = 0 ;

for(int x : map.keySet())
{
    
    ArrayList<Pair> curr = map.get(x) ;
    ArrayList<Pair> now = new ArrayList<Pair>() ;
    
    int r=-1  ;
    
    int count = 0 ;
    
    for(Pair seg : curr)
    {
        
        
      if(seg.first > r)
      {
          count++ ;
          now.add(seg) ;
          r= seg.second  ;
      }
        
        
    }
    
    
    if(count > bestcount)
    {
        ans = now ;
        bestcount = count  ;
    }
    
    
}


pln(bestcount) ;

if(bestcount >0)
{
for(Pair x :  ans)
{
    out.println((x.first+1) +"" "" +( x.second+1)) ;
}
}









//out.println(ans) ;
//out.println(ans+"" ""+in) ;

//out.println(""Case #"" + testcases + "": ""  + ans ) ;
//out.println(""@"") ;
set.clear() ;
sb.delete(0 , sb.length()) ;
list.clear() ;lista.clear() ;listb.clear() ;
map.clear() ;
mapx.clear() ;
mapy.clear() ;
setx.clear() ;sety.clear() ;

} // test case  end loop


out.flush() ;  
} // solve fn ends


public static void main (String[] args) throws java.lang.Exception
{
  

solve() ;
      
}


}
  
 class Pair 
{
  int first ;
  
int second  ;
  
  
 
   public Pair(int l , int r)
   {
       first = l ;second = r ;
   }
      
@Override
	public String toString() {
	
	String ans = """" ;
	ans  += this.first ;
	ans += "" "";
	ans += this.second ;
	
	return ans  ;
	}


}

",1141_F2,CODEFORCES,3378,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.InputMismatchException;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.TreeSet;

/**
 * Actual solution is at the top, in class Solver
 */
public class Main implements Runnable {
	private static String[] args;

	public static void main(String[] args) {
		Main.args = args;
		new Thread(null, new Main(), ""MyRunThread"", 1 << 26).start();
	}

	@Override
	public void run() {
		long time_beg = -1;
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		if (args.length > 0 && args[0].equals(""outside"")) {
			time_beg = System.currentTimeMillis();
			try {
				inputStream = new FileInputStream(""IO/in.txt"");
//				outputStream = new FileOutputStream(""IO/out.txt"");
			} catch (Exception e) {
				System.err.println(e);
				System.exit(1);
			}
		} else {
			try {
//				inputStream = new FileInputStream(""file_name"");
//				outputStream = new FileOutputStream(""file_name"");
			} catch (Exception e) {
				System.err.println(e);
				System.exit(1);
			}
		}

		Solver s = new Solver();
		s.in = new InputReader(inputStream);
		s.out = new OutputWriter(outputStream);
		if (args.length > 0 && args[0].equals(""outside"")) {
			s.debug = new DebugWriter(s.out);
		}

		s.solve();
		s.out.close();

		if (args.length > 0 && args[0].equals(""outside"")) {
			s.debug.close();
			System.err.printf(""*** Total time: %.3f ***\n"", (System.currentTimeMillis() - time_beg) / 1000.0);
		}
	}
}

final class Solver {
	InputReader in;
	OutputWriter out;
	DebugWriter debug;

	public void solve() {
		int n = in.readInt();
		int[] mas = new int[n];
		int[] sorted = new int[n];
		
		for (int i = 0; i < n; ++i)
			sorted[i] = mas[i] = in.readInt();

		Random rnd = new Random(System.nanoTime());
		for (int i = 1; i < n; ++i) {
			int j = rnd.nextInt(i);
			int tmp = sorted[j];
			sorted[j] = sorted[i];
			sorted[i] = tmp;
		}

		Arrays.sort(sorted);

		int id1 = -1;

		for (int i = 0; i < n; ++i)
			if (mas[i] != sorted[i]) {
				id1 = i;
				break;
			}

		int id2 = -1;

		for (int i = n - 1; i >= 0; --i)
			if (mas[i] != sorted[i]) {
				id2 = i;
				break;
			}

		if (id1 != -1 && id2 != -1 && id1 != id2) {
			int tmp = mas[id1];
			mas[id1] = mas[id2];
			mas[id2] = tmp;
		}

		for (int i = 0; i < n; ++i)
			if (mas[i] != sorted[i]) {
				out.printLine(""NO"");
				return;
			}
		out.printLine(""YES"");
	}
}
class InputReader {
	private boolean finished = false;

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	private int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int peek() {
		if (numChars == -1)
			return -1;
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				return -1;
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public long readLong() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	public static boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	private String readLine0() {
		StringBuilder buf = new StringBuilder();
		int c = read();
		while (c != '\n' && c != -1) {
			if (c != '\r')
				buf.appendCodePoint(c);
			c = read();
		}
		return buf.toString();
	}

	public String readLine() {
		String s = readLine0();
		while (s.trim().length() == 0)
			s = readLine0();
		return s;
	}

	public String readLine(boolean ignoreEmptyLines) {
		if (ignoreEmptyLines)
			return readLine();
		else
			return readLine0();
	}

	public BigInteger readBigInteger() {
		try {
			return new BigInteger(readString());
		} catch (NumberFormatException e) {
			throw new InputMismatchException();
		}
	}

	public char readCharacter() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		return (char) c;
	}

	public double readDouble() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		double res = 0;
		while (!isSpaceChar(c) && c != '.') {
			if (c == 'e' || c == 'E')
				return res * Math.pow(10, readInt());
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		}
		if (c == '.') {
			c = read();
			double m = 1;
			while (!isSpaceChar(c)) {
				if (c == 'e' || c == 'E')
					return res * Math.pow(10, readInt());
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				m /= 10;
				res += (c - '0') * m;
				c = read();
			}
		}
		return res * sgn;
	}

	public boolean isExhausted() {
		int value;
		while (isSpaceChar(value = peek()) && value != -1)
			read();
		return value == -1;
	}
}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void print(Object... objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void printLine(Object... objects) {
		print(objects);
		writer.println();
	}

	public void printFormat(String format, Object... objects) {
		writer.printf(format, objects);
	}


	public void print(char[] objects) {
		writer.print(objects);
	}

	public void printLine(char[] objects) {
		writer.println(objects);
	}

	public void printLine(char[][] objects) {
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
	}


	public void print(int[] objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void printLine(int[] objects) {
		print(objects);
		writer.println();
	}

	public void printLine(int[][] objects) {
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
	}


	public void print(long[] objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void printLine(long[] objects) {
		print(objects);
		writer.println();
	}

	public void printLine(long[][] objects) {
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
	}


	public void print(double[] objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void printLine(double[] objects) {
		print(objects);
		writer.println();
	}

	public void printLine(double[][] objects) {
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
	}


	public void print(byte[] objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void printLine(byte[] objects) {
		print(objects);
		writer.println();
	}

	public void printLine(byte[][] objects) {
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
	}


	public void print(boolean[] objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void printLine(boolean[] objects) {
		print(objects);
		writer.println();
	}

	public void printLine(boolean[][] objects) {
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
	}


	public void close() {
		writer.close();
	}

	public void flush() {
		writer.flush();
	}
}

class DebugWriter {
	private final OutputWriter writer;

	public DebugWriter(OutputWriter writer) {
		this.writer = writer;
	}

	private void printDebugMessage() {
		writer.print(""debug:\t"");
	}


	public void printLine(Object... objects) {
		flush();
		printDebugMessage();
		writer.printLine(objects);
		flush();
	}

	public void printFormat(String format, Object... objects) {
		flush();
		printDebugMessage();
		writer.printFormat(format, objects);
		flush();
	}


	public void printLine(char[] objects) {
		flush();
		printDebugMessage();
		writer.printLine(objects);
		flush();
	}

	public void printLine(char[][] objects) {
		flush();
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
		flush();
	}


	public void printLine(double[] objects) {
		flush();
		printDebugMessage();
		writer.printLine(objects);
		flush();
	}

	public void printLine(double[][] objects) {
		flush();
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
		flush();
	}


	public void printLine(int[] objects) {
		flush();
		printDebugMessage();
		writer.printLine(objects);
		flush();
	}

	public void printLine(int[][] objects) {
		flush();
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
		flush();
	}


	public void printLine(long[] objects) {
		flush();
		printDebugMessage();
		writer.printLine(objects);
		flush();
	}

	public void printLine(long[][] objects) {
		flush();
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
		flush();
	}


	public void printLine(byte[] objects) {
		flush();
		printDebugMessage();
		writer.printLine(objects);
		flush();
	}

	public void printLine(byte[][] objects) {
		flush();
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
		flush();
	}


	public void printLine(boolean[] objects) {
		flush();
		printDebugMessage();
		writer.printLine(objects);
		flush();
	}

	public void printLine(boolean[][] objects) {
		flush();
		for (int i = 0; i < objects.length; ++i)
			printLine(objects[i]);
		flush();
	}


	public void flush() {
		writer.flush();
	}

	public void close() {
		writer.close();
	}
}
",0220_A,CODEFORCES,2621,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"import java.util.*;
import java.math.*;
import java.io.*;

public class Main
	{
	public static void main(String args[]) throws IOException
		{
		BufferedReader c=new BufferedReader(new InputStreamReader(System.in));
		String S[]=c.readLine().split("" "");
		int N=Integer.parseInt(S[0]);
		int K=Integer.parseInt(S[1]);
		int A[]=parseArray(c.readLine(),N);
		shuffle(A);
		Arrays.sort(A);
		
		TreeMap<Long,Long> T=new TreeMap<Long, Long>();
		int ans=0;
		for(int i=0;i<N;i++)
			T.put((long)A[i],1L);
		//System.out.println(Arrays.toString(A));
		if(K==1)
			{
			System.out.println(N);
			return;
			}
		else
			{
			for(int i=0;i<N;i++)
				{
				if(A[i]%K==0&&T.containsKey((long)A[i]/K))		//A[i] is not start of a chain
					continue;
				//System.out.println(""considering ""+A[i]);
				int chainSize=0;
				long init=A[i];
				while(T.containsKey(init))
					{
					chainSize++;
					init=init*K;
					}
				//System.out.println(""\t""+chainSize);
				ans+=(chainSize+1)/2;
				}
			}
		System.out.println(ans);
		}
	/** 
	 * Knuth's shuffle. Generate a random permutation of an array
	 */
	public static int[] shuffle(int A[])
		{
		int N=A.length;
		for(int i=1;i<N;i++)
			{
			int j=(int) (Math.random()*100000)%(i+1); // 0<=j<=i;
			int temp=A[i];
			A[i]=A[j];
			A[j]=temp;
			}
		return A;
		}
	// Parse an integer array of size N from a string s
	public static int[] parseArray(String s,int N)
		{
		int A[]=new int[N];
		StringTokenizer st=new StringTokenizer(s);
		for(int i=0;i<N;i++)
			A[i]=Integer.parseInt(st.nextToken());
		return A;
		}
	}",0274_A,CODEFORCES,2694,k-Multiple Free Set,"A k-multiple free set is a set of integers where there is no pair of integers where one is equal to another integer multiplied by k. That is, there are no two integers x and y (x < y) from the set, such that y = x·k.
You're given a set of n distinct positive integers. Your task is to find the size of it's largest k-multiple free subset.
The first line of the input contains two integers n and k (1 ≤ n ≤ 105, 1 ≤ k ≤ 109). The next line contains a list of n distinct positive integers a1, a2, ..., an (1 ≤ ai ≤ 109).
All the numbers in the lines are separated by single spaces.
","input
On the only line of the output print the size of the largest k-multiple free subset of {a1, a2, ..., an}.
output
In the sample input one of the possible maximum 2-multiple free subsets is {4, 5, 6}.
","binarysearch, greedy, sortings",4
"import java.util.InputMismatchException;
import java.math.BigInteger;
import java.io.*;
import java.util.*;

/**
 * Generated by Contest helper plug-in
 * Actual solution is at the bottom
 */

public class Main {
	public static void main(String[] args) {
		InputReader in = new StreamInputReader(System.in);
		PrintWriter out = new PrintWriter(System.out);
		run(in, out);
	}

	public static void run(InputReader in, PrintWriter out) {
		Solver solver = new Task();
		solver.solve(1, in, out);
		Exit.exit(in, out);
	}
}

abstract class InputReader {
	private boolean finished = false;

	public abstract int read();

	public long readLong() {
		return new BigInteger(readString()).longValue();
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuffer res = new StringBuffer();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	private boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public void setFinished(boolean finished) {
		this.finished = finished;
	}

	public abstract void close();
}

class StreamInputReader extends InputReader {
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar, numChars;

	public StreamInputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public void close() {
		try {
			stream.close();
		} catch (IOException ignored) {
		}
	}
}

class Exit {
	private Exit() {
	}

	public static void exit(InputReader in, PrintWriter out) {
		in.setFinished(true);
		in.close();
		out.close();
	}
}

interface Solver {
	public void solve(int testNumber, InputReader in, PrintWriter out);
}

class Task implements Solver {
	public void solve(int testNumber, InputReader in, PrintWriter out) {
		int n = in.readInt();
		int a = in.readInt();
		int b = in.readInt();
		
		if (a==b) {
			b = 0;
		}
		
		boolean[] where = new boolean[n];
		
		HashSet<Integer> set = new HashSet<Integer>();
		HashMap<Integer,Integer> indexmap = new HashMap<Integer,Integer>();
		
		for (int i = 0; i<n; i++) {
			int x = in.readInt();
			indexmap.put(x, i);
			set.add(x);
		}
		
		while (set.size() > 0) {
			int size = set.size();
			HashSet<Integer> todo = new HashSet<Integer>();
			HashSet<Integer> used = new HashSet<Integer>();
			for (int x : set) {
				if (used.contains(x))
					continue;
				int ax = a-x;
				int bx = b-x;
				
				if ((set.contains(ax) && !used.contains(ax)) && (set.contains(bx) && !used.contains(bx))) {
					todo.add(x);
				} else if (set.contains(ax) && !used.contains(ax)) {
					used.add(x);
					used.add(ax);
					todo.remove(ax);
					
					//chain
					bx = b-ax;
					while (set.contains(bx) && !used.contains(bx)) {
						x = bx;
						ax = a-x;
						if (!set.contains(ax) || used.contains(ax)) {
							System.out.println(""NO"");
							return;
						}
						todo.remove(x);
						todo.remove(ax);
						used.add(x);
						used.add(ax);
						bx = b-ax;
					}
					
				} else if (set.contains(bx) && !used.contains(bx)) {
					used.add(x);
					used.add(bx);
					todo.remove(bx);
					where[indexmap.get(bx)] = true;
					where[indexmap.get(x)] = true;
					
					//chain
					ax = a-bx;
					while (set.contains(ax) && !used.contains(ax)) {
						x = ax;
						bx = b-x;
						if (!set.contains(bx) || used.contains(bx)) {
							System.out.println(""NO"");
							return;
						}
						todo.remove(x);
						todo.remove(bx);
						used.add(x);
						used.add(bx);
						where[indexmap.get(bx)] = true;
						where[indexmap.get(x)] = true;
						ax = a-bx;
					}
					
				} else {
					System.out.println(""NO"");
					return;
				}
			}
			set = todo;
			if (set.size() == size) {
				System.out.println(""Set size constant!!"");
				break;
			}
		}
		
		System.out.println(""YES"");
		for (int i = 0; i<n; i++)
			if (where[i])
				System.out.print(""1 "");
			else
				System.out.print(""0 "");
	}
}

class num {
	
	
}

///

",0468_B,CODEFORCES,1694,Two Sets,"Little X has n distinct integers: p1, p2, ..., pn. He wants to divide all of them into two sets A and B. The following two conditions must be satisfied:
Help Little X divide the numbers into two sets or determine that it's impossible.
The first line contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The next line contains n space-separated distinct integers p1, p2, ..., pn (1 ≤ pi ≤ 109).
If there is a way to divide the numbers into two sets, then print ""YES"" in the first line. Then print n integers: b1, b2, ..., bn (bi equals either 0, or 1), describing the division. If bi equals to 0, then pi belongs to set A, otherwise it belongs to set B.
","input
If it's impossible, print ""NO"" (without the quotes).
output
It's OK if all the numbers are in the same set, and the other one is empty.
","2-sat, dfsandsimilar, dsu, graphmatchings, greedy",3
"//stan hu tao
//join nct ridin by first year culture reps
import static java.lang.Math.max;
import static java.lang.Math.min;
import static java.lang.Math.abs;
import static java.lang.System.out;
import java.util.*;
import java.io.*;
import java.math.*;

public class x1209E
{
    public static void main(String hi[]) throws Exception
    {
        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(infile.readLine());
        int T = Integer.parseInt(st.nextToken());
        StringBuilder sb = new StringBuilder();
        while(T-->0)
        {
            st = new StringTokenizer(infile.readLine());
            int N = Integer.parseInt(st.nextToken());
            int M = Integer.parseInt(st.nextToken());
            int[][] grid = new int[N][M];
            for(int r=0; r < N; r++)
                grid[r] = readArr(M, infile, st);
            ArrayList<Integer> ls = new ArrayList<Integer>();
            for(int i=0; i < M; i++)
                ls.add(i);
            Collections.sort(ls, (x,y) -> {
                int m1 = grid[0][x];
                int m2 = grid[0][y];
                for(int r=1; r < N; r++)
                {
                    m1 = max(m1, grid[r][x]);
                    m2 = max(m2, grid[r][y]);
                }
                return m2-m1;
            });
            int[][] newgrid = new int[N][M];
            for(int r=0; r < N; r++)
                for(int c=0; c < M; c++)
                    newgrid[r][c] = grid[r][ls.get(c)];
            M = min(M, N);
            int[][] sums = new int[M][1<<N];
            for(int i=1; i < M; i++)
                for(int mask=0; mask < 1<<N; mask++)
                {
                    //try all shifts
                    for(int head=0; head < N; head++)
                    {
                        int temp = 0;
                        for(int b=0; b < N; b++)
                        {
                            int nb = b+head;
                            if(nb >= N)
                                nb -= N;
                            if((mask&(1<<nb)) > 0)
                                temp += newgrid[b][i];
                        }
                        sums[i][mask] = max(sums[i][mask], temp);
                    }
                }
            int[][] dp = new int[M][1<<N];
            for(int mask=0; mask < 1<<N; mask++)
                for(int b=0; b < N; b++)
                    if((mask&(1<<b)) > 0)
                        dp[0][mask] += newgrid[b][0];
            for(int i=1; i < M; i++)
                for(int mask=0; mask < 1<<N; mask++)
                    for(int pmask=mask; pmask >= 0; pmask=(pmask-1)&mask)
                    {
                        dp[i][mask] = max(dp[i][mask], dp[i-1][pmask]+sums[i][mask-pmask]);
                        if(pmask == 0)
                            break;
                    }
            sb.append(dp[M-1][(1<<N)-1]+""\n"");
        }
        System.out.print(sb);
    }
    public static int[] readArr(int N, BufferedReader infile, StringTokenizer st) throws Exception
    {
        int[] arr = new int[N];
        st = new StringTokenizer(infile.readLine());
        for(int i=0; i < N; i++)
            arr[i] = Integer.parseInt(st.nextToken());
        return arr;
    }
}",1209_E1,CODEFORCES,4740,Rotate Columns (easy version),"This is an easier version of the next problem. The difference is only in constraints.
You are given a rectangular $$$n \times m$$$ matrix $$$a$$$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want (possibly zero). You can perform this operation to a column multiple times.
After you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $$$i$$$-th row it is equal $$$r_i$$$. What is the maximal possible value of $$$r_1+r_2+\ldots+r_n$$$?
The first line contains an integer $$$t$$$ ($$$1 \le t \le 40$$$), the number of test cases in the input.
The first line of each test case contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 4$$$, $$$1 \le m \le 100$$$) — the number of rows and the number of columns in the given matrix $$$a$$$. 
Each of the following $$$n$$$ lines contains $$$m$$$ integers, the elements of $$$a$$$ ($$$1 \le a_{i, j} \le 10^5$$$).
Print $$$t$$$ integers: answers for all test cases in the order they are given in the input.
","input
In the first test case, you can shift the third column down by one, this way there will be $$$r_1 = 5$$$ and $$$r_2 = 7$$$.
output
In the second case you can don't rotate anything at all, this way there will be $$$r_1 = r_2 = 10$$$ and $$$r_3 = 9$$$.
","bitmasks, bruteforce, dp, greedy, sortings",7
"import java.util.Scanner;
public class Counterexample {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc= new Scanner(System.in);
		long l=sc.nextLong(),r=sc.nextLong();
		if (l%2==0&&r-l>=2) System.out.print(l+"" ""+(l+1)+"" ""+(l+2));
		else if (l%2==1&&r-l>=3) System.out.print((l+1)+"" ""+(l+2)+"" ""+(l+3));
		else System.out.print(""-1"");
	}

}
",0483_A,CODEFORCES,492,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"import java.util.*;
import java.io.*;

public class SameSumBlock {
	static BufferedReader br;
	static StringTokenizer tokenizer;

	public static void main(String[] args) throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
		int n = nextInt();
		int[] arr = new int[n];
		int[] pSum = new int[n];
		for(int i = 0; i< n; i++) {
			arr[i] = nextInt();
			if(i != 0)
				pSum[i] += pSum[i - 1];
			pSum[i] += arr[i];
		}
		ArrayList<Interval> sorted = new ArrayList<Interval>();
		for(int i = 0; i < n; i++)
			sorted.add(new Interval(pSum[i],0, i));
		for(int i = 1; i < n; i++) {
			for(int j = i; j < n; j++) {
				sorted.add(new Interval(pSum[j] - pSum[i - 1], i, j));
			}
		}
		sorted.sort(null);
		int i = 0;
		int max = 0, idx = 0, end = 0;
		while(i < sorted.size()) {
			int last = i;
			int curr = 1;
			int start = i;
			sorted.get(i).marked = true;
			while(i < sorted.size() - 1 && sorted.get(i).val == sorted.get(i + 1).val) {
				i++;
				if(sorted.get(i).l > sorted.get(last).r) {
					sorted.get(i).marked = true;
					curr++;
					last = i;
				}
			}
			if(curr > max) {
				max = curr;
				idx = start;
				end = i;
			}
			i++;
		}
		System.out.println(max);
		for(int j = idx; j <= end; j++) {
			if(sorted.get(j).marked)
				System.out.println(sorted.get(j).l + 1 + "" "" + (sorted.get(j).r + 1));
		}
	}

	public static String next() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens()) {
			String line = br.readLine();
			if (line == null)
				throw new IOException();
			tokenizer = new StringTokenizer(line);
		}
		return tokenizer.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
}
class Interval implements Comparable<Interval> {
	int val, l, r;
	boolean marked;
	public Interval(int val, int l, int r) {
		super();
		this.val = val;
		this.l = l;
		this.r = r;
	}

	@Override
	public int compareTo(Interval o) {
		if(val != o.val)
			return val - o.val;
		return r - o.r;
	}
	
}",1141_F2,CODEFORCES,3420,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"import java.io.*;
import java.util.*;

public class B {
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

    static FastReader s = new FastReader();
    static PrintWriter out = new PrintWriter(System.out);

    private static int[] rai(int n) {
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = s.nextInt();
        }
        return arr;
    }

    private static int[][] rai(int n, int m) {
        int[][] arr = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                arr[i][j] = s.nextInt();
            }
        }
        return arr;
    }

    private static long[] ral(int n) {
        long[] arr = new long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = s.nextLong();
        }
        return arr;
    }

    private static long[][] ral(int n, int m) {
        long[][] arr = new long[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                arr[i][j] = s.nextLong();
            }
        }
        return arr;
    }

    private static int ri() {
        return s.nextInt();
    }

    private static long rl() {
        return s.nextLong();
    }

    private static String rs() {
        return s.next();
    }

    static int gcd(int a,int b)
    {
        if(b==0)
        {
            return a;
        }
        return gcd(b,a%b);
    }

    static long gcd(long a,long b)
    {
        if(b==0)
        {
            return a;
        }
        return gcd(b,a%b);
    }
    static boolean isPrime(int n) {
        //check if n is a multiple of 2
        if(n==1)
        {
            return false;
        }
        if(n==2)
        {
            return true;
        }
        if (n % 2 == 0) return false;
        //if not, then just check the odds
        for (int i = 3; i <= Math.sqrt(n); i += 2) {
            if (n % i == 0)
                return false;
        }
        return true;
    }
    static boolean[] sieveOfEratosthenes(int n)
    {
        // Create a boolean array ""prime[0..n]"" and initialize
        // all entries it as true. A value in prime[i] will
        // finally be false if i is Not a prime, else true.
        boolean prime[] = new boolean[n+1];
        for(int i=0;i<n;i++)
            prime[i] = true;

        for(int p = 2; p*p <=n; p++)
        {
            // If prime[p] is not changed, then it is a prime
            if(prime[p] == true)
            {
                // Update all multiples of p
                for(int i = p*p; i <= n; i += p)
                    prime[i] = false;
            }
        }
        return prime;
    }


    public static void main(String[] args) {
        StringBuilder ans = new StringBuilder();
        int t = ri();
//        int t=1;
        while (t-- > 0)
        {
            long n=rl();
            if(n%2==1)
            {
                ans.append(""NO\n"");
                continue;
            }

            if(n%4==0)
            {
                long val = n/4;

                long sq = (long) Math.sqrt(val);
                if(sq*sq == val)
                {
                    ans.append(""YES\n"");
                    continue;
                }
            }
            if(n%2==0)
            {
                long val = n/2;
                long sq = (long) Math.sqrt(val);
                if(sq*sq == val)
                {
                    ans.append(""YES\n"");
                    continue;
                }
            }
            ans.append(""NO\n"");

        }
        out.print(ans.toString());
        out.flush();

    }


}
",1515_B,CODEFORCES,2207,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",3
"
import java.util.Scanner;

/**
 *
 * @author igor_kz
 */
public class C46 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int number = in.nextInt();
        String s = in.next();
        int cH = 0;
        int n = s.length();
        for (int i = 0 ; i < n ; i++)
            if (s.charAt(i) == 'H') cH++;
        String ss = """";
        for (int i = 0 ; i < cH ; i++)
            ss += ""H"";
        for (int i = 0 ; i < n - cH ; i++)
            ss += ""T"";
        int res = Integer.MAX_VALUE;
        for (int i = 0 ; i < n ; i++) {
            int cur = countDifference(ss , s);
            res = Math.min(res , cur);
            ss = ss.substring(1) + ss.charAt(0);
        }
        System.out.println(res);
    }

    public static int countDifference(String ss, String s) {
        int cnt = 0;
        for (int i = 0 ; i < ss.length() ; i++)
            if (ss.charAt(i) != s.charAt(i)) cnt++;
        return cnt / 2;
    }
}
",0046_C,CODEFORCES,1636,Hamsters and Tigers,"Today there is going to be an unusual performance at the circus — hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.
The first line contains number n (2 ≤ n ≤ 1000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols ""H"" and ""T"". The ""H""s correspond to hamsters and the ""T""s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.
","input
Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.
output
In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then — the tiger in position 9 with the hamster in position 7.
",twopointers,3
"import java.io.*;
import java.util.*;

public class Solution {


	private StringTokenizer st;
	private BufferedReader in;
	private PrintWriter out;

	public void solve() throws IOException {
		int n = nextInt();
		int[] a = new int[n];
		for (int i = 0; i < n; ++i) {
			a[i] = nextInt();
		}
		int[] b = a.clone();
		Arrays.sort(b);
		int diff = 0;
		for (int i = 0; i < n; ++i) {
			if (a[i] != b[i]) {
				diff++;
			}
		}
		out.println(diff <= 2 ? ""YES"" : ""NO"");
	}

	public void run() throws IOException {
		in = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		eat("""");
		
		solve();
		
		out.close();
	}
	
	void eat(String s) {
		st = new StringTokenizer(s);
	}
	
	String next() throws IOException {
		while (!st.hasMoreTokens()) {
			String line = in.readLine();
			if (line == null) {
				return null;
			}
			eat(line);
		}
		return st.nextToken();
	}
	
	int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
	
	long nextLong() throws IOException {
		return Long.parseLong(next());
	}
	
	double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}
	
	public static void main(String[] args) throws IOException {
		Locale.setDefault(Locale.US);
		new Solution().run();
	}
	
}",0220_A,CODEFORCES,2592,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"import java.util.Scanner;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Comparator;
import java.util.Set;

public class Main {
    public static final long mod = 998244353;
    public static final int N = 20000 + 7;

    public static long qpow(long x, long n) {
        x %= mod;
        if (x == 1)
            return 1;
        long ans = 1;
        while (n > 0) {
            if (n % 2 == 1)
                ans = (ans * x) % mod;
            x = x * x % mod;
            n /= 2;
        }
        return ans % mod;
    }

    public static long get_inv(long x) {
        return qpow(x, mod - 2);
    }

    public static void main(String[] args) {
        Scanner stdin = new Scanner(System.in);
        long[] s = new long[3005];
        long[] c = new long[3005];
        int n = stdin.nextInt();
        for (int i = 1; i <= n; i++) {
            s[i] = stdin.nextLong();
        }
        for (int i = 1; i <= n; i++) {
            c[i] = stdin.nextLong();
        }
        boolean flag = false;
        long ans = mod * 10000;
        for (int j = 1; j <= n; j++) {
            long Min1 = mod, Min2 = mod;
            for (int i = 1; i <= j - 1; i++) {
                if (s[i] < s[j]) {
                    Min1 = Math.min(Min1, c[i]);
                }
            }
            for (int k = j + 1; k <= n; k++) {
                if (s[j] < s[k]) {
                    Min2 = Math.min(Min2, c[k]);
                }
            }
            if (Min1 != mod && Min2 != mod) {
                flag = true;
                ans = Math.min(ans, c[j] + Min1 + Min2);
            }
        }
        System.out.println((flag == true) ? ans : ""-1"");
        stdin.close();
    }
}
 		  	 	 								  	 	 	   		",0987_C,CODEFORCES,3267,Three displays,"It is the middle of 2018 and Maria Stepanovna, who lives outside Krasnokamensk (a town in Zabaikalsky region), wants to rent three displays to highlight an important problem.
There are $$$n$$$ displays placed along a road, and the $$$i$$$-th of them can display a text with font size $$$s_i$$$ only. Maria Stepanovna wants to rent such three displays with indices $$$i < j < k$$$ that the font size increases if you move along the road in a particular direction. Namely, the condition $$$s_i < s_j < s_k$$$ should be held.
The rent cost is for the $$$i$$$-th display is $$$c_i$$$. Please determine the smallest cost Maria Stepanovna should pay.
The first line contains a single integer $$$n$$$ ($$$3 \le n \le 3\,000$$$) — the number of displays.
The second line contains $$$n$$$ integers $$$s_1, s_2, \ldots, s_n$$$ ($$$1 \le s_i \le 10^9$$$) — the font sizes on the displays in the order they stand along the road.
The third line contains $$$n$$$ integers $$$c_1, c_2, \ldots, c_n$$$ ($$$1 \le c_i \le 10^8$$$) — the rent costs for each display.
If there are no three displays that satisfy the criteria, print -1. Otherwise print a single integer — the minimum total rent cost of three displays with indices $$$i < j < k$$$ such that $$$s_i < s_j < s_k$$$.
","input
In the first example you can, for example, choose displays $$$1$$$, $$$4$$$ and $$$5$$$, because $$$s_1 < s_4 < s_5$$$ ($$$2 < 4 < 10$$$), and the rent cost is $$$40 + 10 + 40 = 90$$$.
output
In the second example you can't select a valid triple of indices, so the answer is -1.
","bruteforce, dp, implementation",5
"import java.io.*;
import java.text.*;
import java.util.*;

public class CottageVillage {

	static BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;

	static String LINE() throws Exception { return stdin.readLine(); }
	static String TOKEN() throws Exception {
		while (st == null || !st.hasMoreTokens())st = new StringTokenizer(LINE());
		return st.nextToken();
	}
	static int INT() throws Exception {return Integer.parseInt(TOKEN());}
	static long LONG() throws Exception {return Long.parseLong(TOKEN());}
	static double DOUBLE() throws Exception {return Double.parseDouble(TOKEN());}

	static DecimalFormat DF = new DecimalFormat(""0.000"",new DecimalFormatSymbols(Locale.ENGLISH));
	
	public static final double EPSILON = 1E-9;
	
	public static void main(String[] args) throws Exception {
		int N = INT(), T = INT();
		House[] list = new House[N];
		for(int i = 0;i<N;i++) {
			list[i] = new House(INT(),INT());
		}
		Arrays.sort(list);
		int cnt = 2;
		for(int i = 1;i<N;i++) {
			int room = list[i].center-list[i-1].center;
			if(2*T<2*room-list[i].side-list[i-1].side)cnt += 2;
			else if(2*T==2*room-list[i].side-list[i-1].side)cnt++;
		}
		System.out.println(cnt);
		
	}
	
	private static class House implements Comparable<House> {
		int center, side;
		House(int c, int s) {
			this.center = c;
			this.side = s;
		}
		public int compareTo(House h) {
			return this.center-h.center;
		}
	}

}
",0015_A,CODEFORCES,2242,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"import java.io.*;
import java.util.*;


public class f{

   public static void main(String[] args) {
      MyScanner sc = new MyScanner();
      out = new PrintWriter(new BufferedOutputStream(System.out));
      
      int n = sc.nextInt();
      int m = sc.nextInt();
      int[][] arr = new int[n][m];
      for(int i=0; i<n; i++) {
          for(int j=0; j<m; j++) {
              arr[i][j] = sc.nextInt();
          }
      }
      if(n==1) {
          int min = Integer.MAX_VALUE;
          for(int i=0; i<m-1; i++) {
              min = Math.min(min, Math.abs(arr[0][i]-arr[0][i+1]));
          }
          out.println(min);
          out.close();
      }
      int[][] adj = new int[n][n];
      int[][] edgeadj = new int[n][n];
      for(int i=0; i<n; i++) {
          for(int j=i+1; j<n; j++) {
              int min = Integer.MAX_VALUE;
              for(int k=0; k<m; k++) {
                  min = Math.min(min, Math.abs(arr[i][k]-arr[j][k]));
              }
              adj[i][j]=min;
              adj[j][i]=min;
              int min1 = Integer.MAX_VALUE;
              int min2 = Integer.MAX_VALUE;
              for(int k=0; k<m-1; k++) {
                  min1 = Math.min(min1, Math.abs(arr[i][k]-arr[j][k+1]));
                  min2 = Math.min(min2, Math.abs(arr[i][k+1]-arr[j][k]));
              }
              edgeadj[i][j]=min1;
              edgeadj[j][i]=min2;
          }
      }
      int power = (int)Math.pow(2,n);
      int[][][] dp = new int[power][n][n];
      for(int i=0; i<n; i++) {
          dp[(int)Math.pow(2,i)][i][i] = Integer.MAX_VALUE;
      }
      for(int bit=0; bit<power; bit++) {
          for(int j=0; j<n; j++) {
              for(int k=0; k<n; k++) {
                  if((bit & (1<<j))>0 && (bit & (1<<k))>0 && j!=k) {
                      int temp = bit;
                      temp &= ~(1<<k);
                      int ans = 0;
                      for(int l=0; l<n; l++) {
                          if((temp & (1<<l))>0) {
                              int min = Math.min(dp[temp][j][l], adj[l][k]);
                              ans = Math.max(ans, min);
                          }
                      }
                      if(j!=k) {
                          dp[bit][j][k] = ans;
                      }
                    // out.println(bit + "" "" + j + "" "" + k + "" "" + dp[bit][j][k]);
                  }
              }
          }
      }
      int answer = 0;
      for(int i=0; i<n; i++) {
          for(int j=0; j<n; j++) {
              if(i!=j) {
                int ans = Math.min(dp[power-1][i][j], edgeadj[i][j]);
                answer = Math.max(answer, ans);
              }
          }
      }
    //   for(int i=0; i<n; i++) {
    //       for(int j=0; j<n; j++) {
    //           out.println(dp[power-1][i][j]+"" ""+edgeadj[i][j]);
    //       }
    //   }
      out.println(answer);
      
      // Start writing your solution here. -------------------------------------
   
      /*
      int n      = sc.nextInt();        // read input as integer
      long k     = sc.nextLong();       // read input as long
      double d   = sc.nextDouble();     // read input as double
      String str = sc.next();           // read input as String
      String s   = sc.nextLine();       // read whole line as String

      int result = 3*n;
      out.println(result);                    // print via PrintWriter
      */

      // Stop writing your solution here. -------------------------------------
      out.close();
   }

   //-----------PrintWriter for faster output---------------------------------
   public static PrintWriter out;
      
   //-----------MyScanner class for faster input----------
   public static class MyScanner {
      BufferedReader br;
      StringTokenizer st;
 
      public MyScanner() {
         br = new BufferedReader(new InputStreamReader(System.in));
      }
 
      String next() {
          while (st == null || !st.hasMoreElements()) {
              try {
                  st = new StringTokenizer(br.readLine());
              } catch (IOException e) {
                  e.printStackTrace();
              }
          }
          return st.nextToken();
      }
 
      int nextInt() {
          return Integer.parseInt(next());
      }
 
      long nextLong() {
          return Long.parseLong(next());
      }
 
      double nextDouble() {
          return Double.parseDouble(next());
      }
 
      String nextLine(){
          String str = """";
	  try {
	     str = br.readLine();
	  } catch (IOException e) {
	     e.printStackTrace();
	  }
	  return str;
      }

   }
   //--------------------------------------------------------
}",1102_F,CODEFORCES,4682,Elongated Matrix,"You are given a matrix $$$a$$$, consisting of $$$n$$$ rows and $$$m$$$ columns. Each cell contains an integer in it.
You can change the order of rows arbitrarily (including leaving the initial order), but you can't change the order of cells in a row. After you pick some order of rows, you traverse the whole matrix the following way: firstly visit all cells of the first column from the top row to the bottom one, then the same for the second column and so on. During the traversal you write down the sequence of the numbers on the cells in the same order you visited them. Let that sequence be $$$s_1, s_2, \dots, s_{nm}$$$. 
The traversal is $$$k$$$-acceptable if for all $$$i$$$ ($$$1 \le i \le nm - 1$$$) $$$|s_i - s_{i + 1}| \ge k$$$.
Find the maximum integer $$$k$$$ such that there exists some order of rows of matrix $$$a$$$ that it produces a $$$k$$$-acceptable traversal.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 16$$$, $$$1 \le m \le 10^4$$$, $$$2 \le nm$$$) — the number of rows and the number of columns, respectively.
Each of the next $$$n$$$ lines contains $$$m$$$ integers ($$$1 \le a_{i, j} \le 10^9$$$) — the description of the matrix.
Print a single integer $$$k$$$ — the maximum number such that there exists some order of rows of matrix $$$a$$$ that it produces an $$$k$$$-acceptable traversal.
In the first example you can rearrange rows as following to get the $$$5$$$-acceptable traversal:
Then the sequence $$$s$$$ will be $$$[5, 10, 4, 9, 3, 8, 3, 9]$$$. Each pair of neighbouring elements have at least $$$k = 5$$$ difference between them.
","input
In the second example the maximum $$$k = 0$$$, any order is $$$0$$$-acceptable.
output
In the third example the given order is already $$$3$$$-acceptable, you can leave it as it is.
","binarysearch, bitmasks, bruteforce, dp, graphs",7
"import java.io.*;
import java.util.*;
public class a {
public static void main(String[] args) throws IOException {
	input.init(System.in);
	PrintWriter out = new PrintWriter(System.out);
	long n = input.nextLong();
	if(n == 1) out.println(5);
	else out.println(25);
	out.close();
}

public static class input {
	static BufferedReader reader;
	static StringTokenizer tokenizer;

	static void init(InputStream input) {
		reader = new BufferedReader(new InputStreamReader(input));
		tokenizer = new StringTokenizer("""");
	}

	static String next() throws IOException {
		while (!tokenizer.hasMoreTokens())
			tokenizer = new StringTokenizer(reader.readLine());
		return tokenizer.nextToken();
	}

	static int nextInt() throws IOException {
		return Integer.parseInt(next());
	}

	static double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}

	static long nextLong() throws IOException {
		return Long.parseLong(next());
	}
}
}

",0630_A,CODEFORCES,560,Again Twenty Five!,"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. ""Do I give such a hard task?"" — the HR manager thought. ""Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.""
Could you pass the interview in the machine vision company in IT City?
","input
The only line of the input contains a single integer n (2 ≤ n ≤ 2·1018) — the power in which you need to raise number 5.
output
Output the last two digits of 5n without spaces between them.
",numbertheory,1
"import java.math.*;
import java.util.*;
import java.io.*;

public class Main {
    void solve(){
        int n=ni();
        int c1[]=new int[9];
        int c2[]=new int[9];
        for(int i=0;i<n;i++){
            String s=ns();
            if(s.equals(""M"")) c1[0]++;
            else if(s.equals(""S"")) c1[1]++;
            else if(s.equals(""L"")) c1[2]++;
            else if(s.equals(""XS"")) c1[3]++;
            else if(s.equals(""XL"")) c1[4]++;
            else if(s.equals(""XXS"")) c1[5]++;
            else if(s.equals(""XXL"")) c1[6]++;
            else if(s.equals(""XXXS"")) c1[7]++;
            else if(s.equals(""XXXL"")) c1[8]++;
        }
        for(int i=0;i<n;i++){
            String s=ns();
            if(s.equals(""M"")) c2[0]++;
            else if(s.equals(""S"")) c2[1]++;
            else if(s.equals(""L"")) c2[2]++;
            else if(s.equals(""XS"")) c2[3]++;
            else if(s.equals(""XL"")) c2[4]++;
            else if(s.equals(""XXS"")) c2[5]++;
            else if(s.equals(""XXL"")) c2[6]++;
            else if(s.equals(""XXXS"")) c2[7]++;
            else if(s.equals(""XXXL"")) c2[8]++;
        }
        int ans=0;
        for(int i=0;i<9;i++){
            if(c2[i]<c1[i]) ans+=c1[i]-c2[i];
        }
        pw.println(ans);


    }
    long M=(long)1e9+7;
    InputStream is;
    PrintWriter pw;
    String INPUT = """";
    void run() throws Exception {
        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
        pw = new PrintWriter(System.out);
        long s = System.currentTimeMillis();
        solve();
        pw.flush();
        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");
    }

    public static void main(String[] args) throws Exception { new Main().run(); }

    private byte[] inbuf = new byte[1024];
    public int lenbuf = 0, ptrbuf = 0;

    private int readByte() {
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }

    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }

    private double nd() { return Double.parseDouble(ns()); }
    private char nc() { return (char)skip(); }

    private String ns() {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    private char[] ns(int n) {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }

    private char[][] nm(int n, int m) {
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }

    private int[] na(int n) {
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }

    private int ni() {
        int num = 0, b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }

        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }

    private long nl() {
        long num = 0;
        int b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }

        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }

    private void tr(Object... o) { if(INPUT.length() > 0)System.out.println(Arrays.deepToString(o)); }
}",1000_A,CODEFORCES,1934,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation",3
"import java.util.*;
import java.io.*;
public class MyClass {
    public static void main(String args[]) {
        Scanner sc =  new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt(), st=0, sum=0;
        int arr[] = new int[26];
        String str = sc.next();
        for(int i=0; i<n; i++) {
            arr[str.charAt(i)-97] += 1;
        }
        for(int i=0; i<26; i++) {
            if(arr[i] > 0) {
                st += 1;
                sum += (i+1);
                if(st == k)
                    break;
                i += 1;    
            }
        }
        if(st == k) 
            System.out.println(sum);
        else
            System.out.println(-1);
        sc.close();
    }
}",1011_A,CODEFORCES,2026,Stages,"Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string — concatenation of letters, which correspond to the stages.
There are $$$n$$$ stages available. The rocket must contain exactly $$$k$$$ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.
For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z' — $$$26$$$ tons.
Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.
The first line of input contains two integers — $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 50$$$) – the number of available stages and the number of stages to use in the rocket.
The second line contains string $$$s$$$, which consists of exactly $$$n$$$ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.
Print a single integer — the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.
In the first example, the following rockets satisfy the condition:
Rocket ""adx"" has the minimal weight, so the answer is $$$29$$$.
","input
In the second example, target rocket is ""belo"". Its weight is $$$2+5+12+15=34$$$.
output
In the third example, $$$n=k=2$$$, so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.
","greedy, implementation, sortings",3
"import java.util.*;
import java.io.*;
import java.lang.*;
import java.math.*;
public class F {
    public static int mod = 998244353;
    public static void main(String[] args) throws Exception {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        // Scanner scan = new Scanner(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        int n = Integer.parseInt(bf.readLine());

        StringTokenizer st = new StringTokenizer(bf.readLine());
        int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());

        int total_neg = 0;
        int[] neg_before = new int[n];
        for(int i=0; i<n; i++) {
          neg_before[i] = total_neg;
          if(a[i] == -1) total_neg++;
        }
        Set<Integer> vals = new HashSet<Integer>();
        for(int i=1; i<=n; i++) vals.add(i);
        for(int i=0; i<n; i++) if(a[i] != -1) vals.remove(a[i]);

        int total_not_in = vals.size();
        int[] arr = new int[total_not_in];
        int counter = 0;
        for(int i : vals) {
          arr[counter] = i;
          counter++;
        }
        Arrays.sort(arr);


        long ans = 0;
        for(int i=0; i<n; i++) {
          if(a[i] != -1) {
            int below = neg_before[i];
            int above = total_neg - below;

            int index = Arrays.binarySearch(arr, a[i]);
            index = 0-(index+1);
            long p_less = frac(index, total_neg);
            long p_above = (1+mod-p_less)%mod;
            ans += (p_less * above % mod + p_above * below) % mod;

            // probability less is index/total_neg
            // above * p_less + below*p_above
          }
        }

        ans += frac((int)(1L*total_neg*(total_neg-1)/2 % mod), 2);

        int[] arr_2 = new int[n-total_not_in];
        int counter_2 = 0;
        for(int i=0; i<n; i++) {
          if(a[i] != -1) {
            arr_2[counter_2] = a[i];
            counter_2++;
          }
        }

        int[] t = new int[arr_2.length];
        long inv_count = mergeSort(arr_2, t, 0, arr_2.length-1);

        ans += inv_count;

        ans %= mod;

        out.println(ans);

        // int n = Integer.parseInt(st.nextToken());
        // int n = scan.nextInt();

        out.close(); System.exit(0);
    }
    public static int exp(int base, int e) {
      if(e == 0) return 1;
      if(e == 1) return base;
      int val = exp(base, e/2);
      int ans = (int)(1L*val*val % mod);
      if(e % 2 == 1)
        ans = (int)(1L*ans*base % mod);
      return ans;
    }
    public static int inv(int base) {
      return exp(base, mod-2);
    }
    public static long frac(int p, int q) {
      return (1L*p*inv(q) % mod);
    }

    public static long mergeSort(int[] a, int[] t, int l, int r)
    {
        int mid = 0;
        long inv_count = 0;
        if (r > l) {
            mid = (r + l) / 2;
            inv_count = mergeSort(a, t, l, mid);
            inv_count += mergeSort(a, t, mid + 1, r);
            inv_count += merge(a, t, l, mid + 1, r);
        }
        return inv_count;
    }

    public static long merge(int[] a, int[] t, int l, int mid, int r)
    {
        int i, j, k;
        long inv_count = 0;
        i = l;
        j = mid;
        k = l;
        while ((i <= mid - 1) && (j <= r)) {
            if (a[i] <= a[j]) {
                t[k++] = a[i++];
            }
            else {
                t[k++] = a[j++];
                inv_count = inv_count + (mid - i);
            }
        }
        while (i <= mid - 1)
            t[k++] = a[i++];
        while (j <= r)
            t[k++] = a[j++];
        for (i = l; i <= r; i++)
            a[i] = t[i];
        return inv_count;
    }
}
",1096_F,CODEFORCES,2906,Inversion Expectation,"A permutation of size $$$n$$$ is an array of size $$$n$$$ such that each integer from $$$1$$$ to $$$n$$$ occurs exactly once in this array. An inversion in a permutation $$$p$$$ is a pair of indices $$$(i, j)$$$ such that $$$i > j$$$ and $$$a_i < a_j$$$. For example, a permutation $$$[4, 1, 3, 2]$$$ contains $$$4$$$ inversions: $$$(2, 1)$$$, $$$(3, 1)$$$, $$$(4, 1)$$$, $$$(4, 3)$$$.
You are given a permutation $$$p$$$ of size $$$n$$$. However, the numbers on some positions are replaced by $$$-1$$$. Let the valid permutation be such a replacement of $$$-1$$$ in this sequence back to numbers from $$$1$$$ to $$$n$$$ in such a way that the resulting sequence is a permutation of size $$$n$$$.
The given sequence was turned into a valid permutation randomly with the equal probability of getting each valid permutation.
Calculate the expected total number of inversions in the resulting valid permutation.
It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the length of the sequence.
The second line contains $$$n$$$ integers $$$p_1, p_2, \dots, p_n$$$ ($$$-1 \le p_i \le n$$$, $$$p_i \ne 0$$$) — the initial sequence.
It is guaranteed that all elements not equal to $$$-1$$$ are pairwise distinct.
Print a single integer — the expected total number of inversions in the resulting valid permutation.
It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.
In the first example two resulting valid permutations are possible:
The expected value is $$$\frac{2 \cdot 1 + 3 \cdot 1}{2} = 2.5$$$.
","input
In the second example no $$$-1$$$ are present, thus the only valid permutation is possible — the given one. It has $$$0$$$ inversions.
output
In the third example there are two resulting valid permutations — one with $$$0$$$ inversions and one with $$$1$$$ inversion.
","dp, math, probabilities",4
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Stack;
import java.util.StringTokenizer;

public class TwoSets {
    static int n, a, b;
    static HashSet<Integer> arr = new HashSet<Integer>();
    static HashSet<Integer> visited = new HashSet<Integer>();
    static HashMap<Integer, Integer> result = new HashMap<Integer, Integer>();

    static void dfs(int x, int parent, int len) {
        stack.push(x);
        visited.add(x);
        int children = 0;
        if (a - x > 0) {
            if (a - x != parent && arr.contains(a - x)) {
                dfs(a - x, x, len + 1);
                children++;
            }
        }
        if (b - x > 0) {
            if (b - x != parent && arr.contains(b - x)) {
                dfs(b - x, x, len + 1);
                children++;
            }
        }
        if (children == 0) {
            if (len % 2 == 1) {
                System.out.println(""NO"");
                System.exit(0);
            } else {
                while (!stack.isEmpty()) {
                    int first = stack.pop();
                    int second = stack.pop();
                    if (first == a - second) {
                        result.put(first, 0);
                        result.put(second, 0);
                    } else {
                        result.put(first, 1);
                        result.put(second, 1);
                    }

                }
            }
        }
    }

    static Stack<Integer> stack = new Stack<Integer>();

    public static void main(String[] args) {
        InputReader r = new InputReader(System.in);
        n = r.nextInt();
        a = r.nextInt();
        b = r.nextInt();
        int[] list = new int[n];
        for (int i = 0; i < n; i++) {
            list[i] = r.nextInt();
            arr.add(list[i]);
        }
        for (int x : arr) {
            if (!visited.contains(x)) {
                if (arr.contains(a - x) && arr.contains(b - x))
                    continue;
                if (arr.contains(a - x) || arr.contains(b - x)) {
                    dfs(x, -1, 1);
                } else {
                    System.out.println(""NO"");
                    System.exit(0);
                }
            }
        }
        PrintWriter out = new PrintWriter(System.out);
        out.println(""YES"");
        for (int i = 0; i < list.length; i++) {
            if (result.get(list[i]) == null)
                out.println(0);
            else
                out.println(result.get(list[i]));
        }
        out.close();

    }

    static class InputReader {
        private BufferedReader reader;
        private StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream));
            tokenizer = null;
        }

        public InputReader(FileReader stream) {
            reader = new BufferedReader(stream);
            tokenizer = null;
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                return null;
            }
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }
    }
}
",0468_B,CODEFORCES,1708,Two Sets,"Little X has n distinct integers: p1, p2, ..., pn. He wants to divide all of them into two sets A and B. The following two conditions must be satisfied:
Help Little X divide the numbers into two sets or determine that it's impossible.
The first line contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The next line contains n space-separated distinct integers p1, p2, ..., pn (1 ≤ pi ≤ 109).
If there is a way to divide the numbers into two sets, then print ""YES"" in the first line. Then print n integers: b1, b2, ..., bn (bi equals either 0, or 1), describing the division. If bi equals to 0, then pi belongs to set A, otherwise it belongs to set B.
","input
If it's impossible, print ""NO"" (without the quotes).
output
It's OK if all the numbers are in the same set, and the other one is empty.
","2-sat, dfsandsimilar, dsu, graphmatchings, greedy",3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;


public class A {
	
	static class Scanner{
		BufferedReader br=null;
		StringTokenizer tk=null;
		public Scanner(){
			br=new BufferedReader(new InputStreamReader(System.in));
		}
		public String next() throws IOException{
			while(tk==null || !tk.hasMoreTokens())
				tk=new StringTokenizer(br.readLine());
			return tk.nextToken();
		}
		public int nextInt() throws NumberFormatException, IOException{
			return Integer.valueOf(next());
		}
		public double nextDouble() throws NumberFormatException, IOException{
			return Double.valueOf(next());
		}
	}
	
	public static void main(String args[]) throws NumberFormatException, IOException{
		Scanner sc=new Scanner();
		int N=sc.nextInt();
		int M=sc.nextInt();
		int K=sc.nextInt();
		int[] array=new int[N];
		for(int i=0;i<N;i++)
			array[i]=sc.nextInt();
		Arrays.sort(array);
		int val=K;
		int index=N - 1;
		while(index>=0 && val<M){
			val--;
			val+=array[index];
			index--;
		}
		if (val<M)
			System.out.println(""-1"");
		else
			System.out.println((N - 1) - index);
	}

}
",0257_A,CODEFORCES,2668,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings",4
"import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNext()) {
            int n = in.nextInt();
            int sum = 0;
            int[] v = new int[n + 1];
            for(int i=1; i<=n; i++) {
                int t = in.nextInt();
                sum += t;
                v[i] = v[i - 1] + t;
            }
            double half = sum / 2.0;
            for(int i=1; i<=n; i++) {
                if(v[i] >= half) {
                    System.out.println(i);
                    break;
                }
            }
        }
        in.close();
    }

}

    		        	   				  	    		",0962_A,CODEFORCES,1850,Equator,"Polycarp has created his own training plan to prepare for the programming contests. He will train for $$$n$$$ days, all days are numbered from $$$1$$$ to $$$n$$$, beginning from the first.
On the $$$i$$$-th day Polycarp will necessarily solve $$$a_i$$$ problems. One evening Polycarp plans to celebrate the equator. He will celebrate it on the first evening of such a day that from the beginning of the training and to this day inclusive he will solve half or more of all the problems.
Determine the index of day when Polycarp will celebrate the equator.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of days to prepare for the programming contests.
The second line contains a sequence $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10\,000$$$), where $$$a_i$$$ equals to the number of problems, which Polycarp will solve on the $$$i$$$-th day.
Print the index of the day when Polycarp will celebrate the equator.
","input
In the first example Polycarp will celebrate the equator on the evening of the second day, because up to this day (inclusive) he will solve $$$4$$$ out of $$$7$$$ scheduled problems on four days of the training.
output
In the second example Polycarp will celebrate the equator on the evening of the third day, because up to this day (inclusive) he will solve $$$6$$$ out of $$$12$$$ scheduled problems on six days of the training.
",implementation,3
"/*
 * Institute DA-IICT
 */

import java.io.*;
import java.math.*;
import java.util.*;

public class C
{
	
	InputStream in;
	PrintWriter out;
	
	void solve() 
	{
		int n=ni();
		long dp[]=new long[n+1];
		
		dp[0]=1;
		for (int i=0;i<n;)
		{
			i++;
			if (nc()=='f')
			{
				//boolean flag=i==1;
				i++;
				int k=1;
				while (nc()!='s')
				{
					i++;k++;
				}
				//long dp1[]=Arrays.copyOf(dp, n+1);
				for (int j=n-1;j>=0;j--)
				{
					dp[j]=add(dp[j],dp[j+1]);
				}
				
				for (int j=n;j>=k;j--)
				{
					dp[j]=dp[j-k];
				}
				for (int j=0;j<k;j++)
					dp[j]=0;
			}
			else
			{
				for (int j=n-1;j>=0;j--)
				{
					dp[j]=add(dp[j],dp[j+1]);
				}
			}
			//tr(dp);
		}
		long sum=0;
		for (int i=0;i<=n;i++)
			sum=add(sum,dp[i]);
		out.println(sum);
	}
	
	class LazyPropagation
		{
			long tree[];
			long lazy[];
			long A[];
			public LazyPropagation(int n,long arr[]) 
			{
				tree=new long[4*n];
				lazy=new long[4*n];
				A=arr;
				buildSum(1,1,n);
			}
			
			public LazyPropagation(int n) 
			{
				tree=new long[4*n];
				lazy=new long[4*n];
			}
			
			void buildSum(int node,int start,int end)
			{
				if (start==end)
				{
					tree[node]=A[start];
				}
				else
				{
					int mid=(start+end)>>1;
					buildSum(node*2, start, mid);
					buildSum(node*2+1, mid+1, end);
					tree[node]=tree[node*2]+tree[2*node+1];
				}
			}
			
			void updateRangeSum(int node, int start, int end,int l,int r,long val)
			{
				if (lazy[node]!=0)
				{
					tree[node]=add(tree[node],mul((end-start+1),lazy[node]));
					if (start!=end)
					{
						lazy[2*node]=add(lazy[2*node],lazy[node]);
						lazy[node*2+1]=add(lazy[2*node+1],lazy[node]);
					}
					lazy[node]=0;
				}
				if (start>end||start>r||end<l)
					return;
				
				if (start>=l&&end<=r)
				{
					tree[node]=add(tree[node],mul((end-start+1),val));
					if (start!=end)
					{
						lazy[2*node]=add(lazy[2*node],val);
						lazy[node*2+1]=add(lazy[2*node+1],val);
					}
					return;
				}
				int mid=(start+end)>>1;
				updateRangeSum(node*2, start, mid, l, r, val);
				updateRangeSum(node*2+1, mid+1, end, l, r, val);
				tree[node]=add(tree[node*2],tree[node*2+1]);
				
			}
			
			long queryRangeSum(int node,int start,int end,int l,int r)
			{
				if (start>r||end<l||start>end)
					return 0;
				if (lazy[node]!=0)
				{
					tree[node]=add(tree[node],mul((end-start+1),lazy[node]));
					if (start!=end)
					{
						lazy[2*node]=add(lazy[2*node],lazy[node]);
						lazy[node*2+1]=add(lazy[2*node+1],lazy[node]);
					}
					lazy[node]=0;
				}
				
				if (start>=l&&end<=r)
					return tree[node];
				
				int mid=(start+end)>>1;
				return add(queryRangeSum(node*2, start, mid, l, r),queryRangeSum(node*2+1, mid+1, end, l, r));
			}
		}
	
	long mod=(long)1e9+7;
	long add(long a,long b)
	{
		long x=(a+b);
		while(x>=mod) x-=mod;
		return x;
		
	}
	
	
	long sub(long a,long b)
	{
		long x=(a-b);
		while(x<0) x+=mod;
		return x;
		
	}
	
	
	long mul(long a,long b)
	{
		a%=mod;
		b%=mod;
		long x=(a*b);
		return x%mod;
		
	}
	
	void run() throws Exception {
		String INPUT = ""C:/Users/ayubs/Desktop/input.txt"";
		in = oj ? System.in : new FileInputStream(INPUT);
		out = new PrintWriter(System.out);
		
			long s = System.currentTimeMillis();
			solve();
			out.flush();
			tr(System.currentTimeMillis() - s + ""ms"");
	}
	public static void main(String[] args) throws Exception {
		new C().run();
	}
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte() {
		if (lenbuf == -1)
			throw new InputMismatchException();
		if (ptrbuf >= lenbuf) {
			ptrbuf = 0;
			try {
				lenbuf = in.read(inbuf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (lenbuf <= 0)
				return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean inSpaceChar(int c) {
		return !(c >= 33 && c <= 126);
	}
	
	private int skip() {
		int b;
		while ((b = readByte()) != -1 && inSpaceChar(b))
			;
		return b;
	}
	
	private double nd() {
		return Double.parseDouble(ns());
	}
	
	private char nc() {
		return (char) skip();
	}
	
	private String ns() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!(inSpaceChar(b))) { // when nextLine, (inSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n) {
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while (p < n && !(inSpaceChar(b))) {
			buf[p++] = (char) b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m) {
		char[][] map = new char[n][];
		for (int i = 0; i < n; i++)
			map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = ni();
		return a;
	}
	
	private int ni() {
		int num = 0, b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}
		
		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl() {
		long num = 0;
		int b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}
		
		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	
	private void tr(Object... o) {
		if (!oj)
			System.out.println(Arrays.deepToString(o));
	}
	
}
",0909_C,CODEFORCES,3130,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"import java.util.Map;
import java.io.OutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.util.TreeMap;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n = in.readInt();
        int a = in.readInt();
        int b = in.readInt();
        TreeMap<Integer, Integer> mp = new TreeMap<Integer, Integer>();
        for (int i = 0; i < n; ++i) {
            mp.put(in.readInt(), i);
        }
        int aname = 0;
        int bname = 1;
        if (a > b) {
            int t = a;
            a = b;
            b = t;
            aname = 1;
            bname = 0;
        }
        int[] res = new int[n];
        while (mp.size() > 0) {
            Map.Entry<Integer, Integer> e = mp.firstEntry();
            int val = e.getKey();
            if (mp.containsKey(b - val)) {
                res[mp.get(val)] = res[mp.get(b - val)] = bname;
                mp.remove(val);
                mp.remove(b - val);
            } else if (mp.containsKey(a - val)) {
                res[mp.get(val)] = res[mp.get(a - val)] = aname;
                mp.remove(val);
                mp.remove(a - val);
            } else {
                break;
            }
        }
        if (mp.size() > 0) {
            out.println(""NO"");
        } else {
            out.println(""YES"");
            for (int i = 0; i < n; ++i) {
                if (i > 0) out.print("" "");
                out.print(res[i]);
            }
            out.println();
        }
    }
}

class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        // InputMismatchException -> UnknownError
        if (numChars == -1)
            throw new UnknownError();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new UnknownError();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        } else if (c == '+') {
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public static boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

}

",0468_B,CODEFORCES,1700,Two Sets,"Little X has n distinct integers: p1, p2, ..., pn. He wants to divide all of them into two sets A and B. The following two conditions must be satisfied:
Help Little X divide the numbers into two sets or determine that it's impossible.
The first line contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The next line contains n space-separated distinct integers p1, p2, ..., pn (1 ≤ pi ≤ 109).
If there is a way to divide the numbers into two sets, then print ""YES"" in the first line. Then print n integers: b1, b2, ..., bn (bi equals either 0, or 1), describing the division. If bi equals to 0, then pi belongs to set A, otherwise it belongs to set B.
","input
If it's impossible, print ""NO"" (without the quotes).
output
It's OK if all the numbers are in the same set, and the other one is empty.
","2-sat, dfsandsimilar, dsu, graphmatchings, greedy",3
"import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;
/* Name of the class has to be ""Main"" only if the class is public. */
public class Codechef
{
    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	static ArrayList<ArrayList<Integer>> list;
    static HashSet<Integer> hs;
    static ArrayList<Integer> tmp;
    //int n=Integer.parseInt(br.readLine());
    //int n=Integer.parseInt(st.nextToken());
    //StringTokenizer st = new StringTokenizer(br.readLine());
    public static double cal(int a,double b,int x,int r)
    {
        r*=2;
        double dis=(r*r) - Math.pow(Math.abs(a-x),2);
        
        dis=Math.sqrt(dis);
        
        dis+=b;
        
        return dis;
        
    }
	public static void main (String[] args) throws java.lang.Exception
	{
	    int n,r;
	    StringTokenizer st = new StringTokenizer(br.readLine());
	    n=Integer.parseInt(st.nextToken());
	    r=Integer.parseInt(st.nextToken());
	    
	    int arr[] = new int[n+1];
	    double cen[] = new double[n+1];
	    
	    int i,j;
	    
	    for(i=1;i<=n;i++)
	    cen[i]=-1.0;
	    
	    st = new StringTokenizer(br.readLine());
	    for(i=1;i<=n;i++)arr[i]=Integer.parseInt(st.nextToken());
	    
	    for(i=1;i<=n;i++)
	    {
	        int f=0;
	        double max=-1.0;
	        for(j=1;j<=n;j++)
	        {
	            if(i!=j && cen[j]!=-1.0 && (Math.abs(arr[i]-arr[j])<=2*r))
	            {
	                max=Math.max(max,cal(arr[j],cen[j],arr[i],r));
	                f=1;
	                
	            }
	        }
	       // System.out.println(i+"" ""+max);
	        if(f==1)
	        cen[i]=max;
	        else
	        cen[i]=r*1.0;
	    }
	    for(i=1;i<=n;i++)
	    System.out.print(cen[i]+"" "");
	}
}
",0908_C,CODEFORCES,2965,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"//david alexander
import java.util.*;

public class Subtract {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int a,b;
		String answer = """";
		while(n!=0){
			a = sc.nextInt();
			b = sc.nextInt();
			answer += solve(a,b) + ""\n"";
			n--;
		}
		System.out.println(answer);
	}
	
	public static int solve(int a, int b){
		int count = 0;
		int div;
		int mod;
		while(true){
			if(a >= b){
				div = a/b;
				mod = a%b;
				count += div;
				if(mod==0){
					return count;
				}
				else{
					a = mod;
				}
			}
			else{
				div = b/a;
				mod = b%a;
				count += div;
				if(mod==0){
					return count;
				}
				else{
					b = mod;
				}
			}
		}
	}
}
",0267_A,CODEFORCES,270,Subtractions,"You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).
You've got some number of pairs (ai, bi). How many operations will be performed for each of them?
","input
The first line contains the number of pairs n (1  ≤  n  ≤  1000). Then follow n lines, each line contains a pair of positive integers ai, bi (1  ≤  ai,  bi  ≤  109).
output
Print the sought number of operations for each pair on a single line.
","math, numbertheory",1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;
import java.util.TreeSet;

public class TheyAreEverywhere {
    static StringTokenizer st;
    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in), 325678);
    static int[] id = new int[100000];

    public static void main(String[] args) throws IOException {
        int n = in();
        String s = next();
        int total = 0;
        int[] seq = new int[n];
        boolean[] c = new boolean[100000];
        for (int i = 0; i < n; i++) {
            seq[i] = s.charAt(i);
            if (!c[seq[i]]) {
                total++;
                c[seq[i]] = true;
            }
        }

        Arrays.fill(id, -1);
        int best = Integer.MAX_VALUE;
        TreeSet<Integer> q = new TreeSet<Integer>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return id[o1] - id[o2];
            }
        });
        for (int i = 0; i < n; i++) {
            q.remove(seq[i]);
            id[seq[i]] = i;
            q.add(seq[i]);
            if (q.size() == total) {
                //System.out.println(""best: i="" + i + "" id="" + id[q.first()]);
                best = Math.min(best, i - id[q.first()] + 1);
            }
            //System.out.println(""i=""+i+"" "" +q.toString());
        }

        System.out.println(best);

    }

    public static int in() throws IOException {
        return Integer.parseInt(next());
    }

    public static long inl() throws IOException {
        return Long.parseLong(next());
    }

    public static String next() throws IOException {
        if (st == null || !st.hasMoreTokens())
            st = new StringTokenizer(bf.readLine());
        return st.nextToken();
    }

}
",0701_C,CODEFORCES,1788,They Are Everywhere,"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.
There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 
Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. 
The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.
The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. 
Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. 
In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.
","input
In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 
output
In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.
","binarysearch, strings, twopointers",3
"import java.util.*;
import java.math.*;
import java.io.*;

public class CF1068A {
	public CF1068A() {
		FS scan = new FS();
		long n = scan.nextLong(), m = scan.nextLong(), k = scan.nextLong(), l = scan.nextLong();
		long ceil = (k + l + m - 1) / m;
		if(k + l <= n && ceil * m <= n) System.out.println(ceil);
		else System.out.println(-1);
	}
	class FS {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer("""");
		public String next() {
			while(!st.hasMoreTokens()) {
				try { st = new StringTokenizer(br.readLine()); }
				catch(Exception e) { e.printStackTrace(); }
			}
			return st.nextToken();
		}
		public int nextInt() { return Integer.parseInt(next()); }
		public long nextLong() { return Long.parseLong(next()); }
	}
	public static void main(String[] args) { new CF1068A(); }
}
",1068_A,CODEFORCES,699,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math,1
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.FilterInputStream;
import java.io.BufferedInputStream;
import java.util.Random;
import java.io.InputStream;

/**
 * @author khokharnikunj8
 */

public class Main {
    public static void main(String[] args) {
        new Thread(null, new Runnable() {
            public void run() {
                new Main().solve();
            }
        }, ""1"", 1 << 26).start();
    }

    void solve() {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        ScanReader in = new ScanReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        E2RotateColumnsHardVersion solver = new E2RotateColumnsHardVersion();
        int testCount = in.scanInt();
        for (int i = 1; i <= testCount; i++)
            solver.solve(i, in, out);
        out.close();
    }

    static class E2RotateColumnsHardVersion {
        int[][] dp;
        int[] cur;

        public void solve(int testNumber, ScanReader in, PrintWriter out) {
            int n = in.scanInt();
            int m = in.scanInt();
            int[][] ar = new int[n][m];
            int[][] max = new int[m][2];
            for (int i = 0; i < n; i++)
                for (int j = 0; j < m; j++)
                    ar[i][j] = in.scanInt();
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) max[i][0] = Math.max(max[i][0], ar[j][i]);
                max[i][1] = i;
            }
            CodeHash.shuffle(max);
            Arrays.sort(max, (o1, o2) -> -o1[0] + o2[0]);
            dp = new int[2][1 << n];
            cur = new int[1 << n];
            for (int i = 0; i < Math.min(m, n); i++) {
                Arrays.fill(dp[i & 1], 0);
                for (int k = 0; k < n; k++) {
                    System.arraycopy(dp[(i - 1) & 1], 0, cur, 0, 1 << n);
                    for (int l = 0; l < n; l++) {
                        for (int j = 0; j < 1 << n; j++) {
                            if ((j & (1 << l)) == 0) {
                                cur[j ^ (1 << l)] = Math.max(cur[j ^ (1 << l)], cur[j] + ar[(k + l) % n][max[i][1]]);
                            }
                        }
                    }
                    for (int j = 0; j < 1 << n; j++) dp[i & 1][j] = Math.max(dp[i & 1][j], cur[j]);
                }
            }
            out.println(dp[Math.min(n, m) & 1 ^ 1][(1 << n) - 1]);
        }

    }

    static class CodeHash {
        public static void shuffle(int[][] ar) {
            Random rd = new Random(new Random().nextInt());
            for (int i = 0; i < ar.length; i++) {
                int index = rd.nextInt(ar.length);
                int[] temp = ar[i];
                ar[i] = ar[index];
                ar[index] = temp;
            }
        }

    }

    static class ScanReader {
        private byte[] buf = new byte[4 * 1024];
        private int index;
        private BufferedInputStream in;
        private int total;

        public ScanReader(InputStream inputStream) {
            in = new BufferedInputStream(inputStream);
        }

        private int scan() {
            if (index >= total) {
                index = 0;
                try {
                    total = in.read(buf);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (total <= 0) return -1;
            }
            return buf[index++];
        }

        public int scanInt() {
            int integer = 0;
            int n = scan();
            while (isWhiteSpace(n)) n = scan();
            int neg = 1;
            if (n == '-') {
                neg = -1;
                n = scan();
            }
            while (!isWhiteSpace(n)) {
                if (n >= '0' && n <= '9') {
                    integer *= 10;
                    integer += n - '0';
                    n = scan();
                }
            }
            return neg * integer;
        }

        private boolean isWhiteSpace(int n) {
            if (n == ' ' || n == '\n' || n == '\r' || n == '\t' || n == -1) return true;
            else return false;
        }

    }
}

",1209_E2,CODEFORCES,4813,Rotate Columns (hard version),"This is a harder version of the problem. The difference is only in constraints.
You are given a rectangular $$$n \times m$$$ matrix $$$a$$$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want (possibly zero). You can perform this operation to a column multiple times.
After you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $$$i$$$-th row it is equal $$$r_i$$$. What is the maximal possible value of $$$r_1+r_2+\ldots+r_n$$$?
The first line contains an integer $$$t$$$ ($$$1 \le t \le 40$$$), the number of test cases in the input.
The first line of each test case contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 12$$$, $$$1 \le m \le 2000$$$) — the number of rows and the number of columns in the given matrix $$$a$$$. 
Each of the following $$$n$$$ lines contains $$$m$$$ integers, the elements of $$$a$$$ ($$$1 \le a_{i, j} \le 10^5$$$).
Print $$$t$$$ integers: answers for all test cases in the order they are given in the input.
","input
In the first test case you can shift the third column down by one, this way there will be $$$r_1 = 5$$$ and $$$r_2 = 7$$$.
output
In the second case you can don't rotate anything at all, this way there will be $$$r_1 = r_2 = 10$$$ and $$$r_3 = 9$$$.
","bitmasks, dp, greedy, sortings",7
"import static java.util.Arrays.*;
import static java.lang.Math.*;
import static java.math.BigInteger.*;
import java.util.*;
import java.math.*;
import java.io.*;

public class A implements Runnable
{
    String file = ""input"";
    
    boolean TEST = System.getProperty(""ONLINE_JUDGE"") == null;
    
    void solve() throws IOException
    {
        int n = nextInt();
        int[] a = new int[n];
        for(int i = 0; i < n; i++) a[i] = nextInt();
        int[] b = a.clone();
        qsort(b);
        //sortInt(b);
        int count = 0;
        for(int i = 0; i < a.length; i++)
            if(a[i] != b[i]) count++;
        if(count == 0 || count == 2) out.println(""YES"");
        else out.println(""NO"");
    }
    
    void qsort(int[] a)
    {
        List<Integer> as = new ArrayList<Integer>();
        for(int x : a) as.add(x);
        Collections.shuffle(as);
        int j = 0;
        for(int x : as) a[j++] = x;
        sort(a);
    }
    
    Random rnd = new Random();
    
    void sortInt(int[] a)
    {
        sortInt(a, 0, a.length - 1);
    }
    
    void sortInt(int[] a, int from, int to)
    {
        if(from >= to) return;
        int i = from - 1;
        int p = rnd.nextInt(to - from + 1) + from;
        int t = a[p]; a[p] = a[to]; a[to] = t;
        for(int j = from; j < to; j++)
            if(a[j] <= a[to])
            {
                i++;
                t = a[i]; a[i] = a[j]; a[j] = t;
            }
        t = a[i + 1]; a[i + 1] = a[to]; a[to] = t;
        sortInt(a, i + 2, to);
        while(i >= 0 && a[i] == a[i + 1]) i--;
        sortInt(a, from, i);
        
    }
    
    String next() throws IOException
    {
        while(st == null || !st.hasMoreTokens()) st = new StringTokenizer(input.readLine());
        return st.nextToken();
    }
    
    int nextInt() throws IOException
    {
        return Integer.parseInt(next());
    }
    
    long nextLong() throws IOException
    {
        return Long.parseLong(next());
    }
    
    double nextDouble() throws IOException
    {
        return Double.parseDouble(next());
    }
    
    void print(Object... o)
    {
        System.out.println(deepToString(o));
    }
    
    void gcj(Object o)
    {
        String s = String.valueOf(o);
        out.println(""Case #"" + test + "": "" + s);
        System.out.println(""Case #"" + test + "": "" + s);
    }
    
    BufferedReader input;
    PrintWriter out;
    StringTokenizer st;
    int test;
    
    void init() throws IOException
    {
        if(TEST) input = new BufferedReader(new FileReader(file + "".in"")); 
        else input = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(new BufferedOutputStream(System.out));
    }
    
    public static void main(String[] args) throws IOException
    {
        new Thread(null, new A(), """", 1 << 22).start();
    }
    
    public void run()
    {
        try
        {
            init();
            if(TEST) 
            {
                int runs = nextInt();
                for(int i = 0; i < runs; i++) solve();
            }
            else solve();
            out.close();        
        }
        catch(Exception e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }
}",0220_A,CODEFORCES,2612,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;

	static void solve() {
		int n = ir.nextInt();
		int t = ir.nextInt();
		int[][] a = new int[n][];
		for (int i = 0; i < n; i++)
			a[i] = ir.nextIntArray(2);
		long[] f = fact(15);
		long res = 0;
		for (int i = 0; i < 1 << n; i++) {
			int[] ct = new int[4];
			int tot = 0;
			for (int j = 0; j < n; j++) {
				if (((1 << j) & i) != 0) {
					tot += a[j][0];
					ct[a[j][1]]++;
				}
			}
			if (tot != t)
				continue;
			long[][][][] dp = new long[ct[1] + 1][ct[2] + 1][ct[3] + 1][4];
			dp[0][0][0][0] = 1;
			for (int j = 0; j < ct[1] + ct[2] + ct[3]; j++) {
				for (int k = 0; k <= ct[1]; k++) {
					for (int l = 0; l <= ct[2]; l++) {
						if (k + l > j || j - k - l > ct[3])
							continue;
						for (int m = 0; m <= 3; m++) {
							for (int o = 0; o <= 3; o++) {
								if (m == o)
									continue;
								if (o == 1 && k == ct[1])
									continue;
								if (o == 2 && l == ct[2])
									continue;
								if (o == 3 && j - k - l == ct[3])
									continue;

								if (o == 1) {
									dp[k + 1][l][j - k - l][1] = add(dp[k + 1][l][j - k - l][1],
											dp[k][l][j - k - l][m]);
								}
								if (o == 2) {
									dp[k][l + 1][j - k - l][2] = add(dp[k][l + 1][j - k - l][2],
											dp[k][l][j - k - l][m]);
								}
								if (o == 3) {
									dp[k][l][j - k - l + 1][3] = add(dp[k][l][j - k - l + 1][3],
											dp[k][l][j - k - l][m]);
								}

							}
						}
					}
				}
			}
			for (int m = 0; m <= 3; m++)
				res = add(res, mul(mul(f[ct[1]], f[ct[2]]), mul(f[ct[3]], dp[ct[1]][ct[2]][ct[3]][m])));
		}
		out.println(res);
	}

	static long mod = (long) 1e9 + 7;

	static long add(long a, long b) {
		return (a + b) % mod;
	}

	static long sub(long a, long b) {
		long d = a - b;
		while (d < 0)
			d += mod;
		return d;
	}

	static long mul(long a, long b) {
		return a * b % mod;
	}

	static long div(long a, long b) {
		return a * mod_inverse(b) % mod;
	}

	private static long[] fact(int n) {
		long[] ret = new long[n + 1];
		ret[0] = 1 % mod;
		for (int i = 1; i <= n; i++) {
			ret[i] = mul(ret[i - 1], i);
		}
		return ret;
	}

	private static long[] factInv(int n) {
		long[] ret = new long[n + 1];
		ret[0] = 1;
		for (int i = 1; i <= n; i++) {
			ret[i] = div(ret[i - 1], i);
		}
		return ret;
	}

	public static long comb(int n, int m, long[] fact, long[] factInv) {
		long ret = fact[n];
		ret = mul(ret, factInv[m]);
		ret = mul(ret, factInv[n - m]);
		return ret;
	}

	public static long[][] stirling(int n) {
		long[][] ret = new long[n + 1][n + 1];
		ret[0][0] = 1;
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= i; j++)
				ret[i][j] = add(ret[i - 1][j - 1], mul(ret[i - 1][j], j));
		return ret;
	}

	public static long mod_inverse(long a) {
		long[] ret = extgcd(a, mod);
		return add(mod, ret[0] % mod);
	}

	public static long[] extgcd(long a, long b) {
		long[] ret = new long[3];
		ret[2] = _extgcd(a, b, ret);
		return ret;
	}

	private static long _extgcd(long a, long b, long[] x) {
		long g = a;
		x[0] = 1;
		x[1] = 0;
		if (b != 0) {
			g = _extgcd(b, a % b, x);
			long temp = x[0];
			x[0] = x[1];
			x[1] = temp;
			x[1] -= (a / b) * x[0];
		}
		return g;
	}

	static long modpow(long a, long n) {
		long res = 1;
		while (n > 0) {
			if ((n & 1) != 0)
				res = res * a % mod;
			a = a * a % mod;
			n >>= 1;
		}
		return res;
	}

	public static void main(String[] args) {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		out.println(Arrays.deepToString(o));
	}
}
",1185_G1,CODEFORCES,4706,Playlist for Polycarp (easy version),"The only difference between easy and hard versions is constraints.
Polycarp loves to listen to music, so he never leaves the player, even on the way home from the university. Polycarp overcomes the distance from the university to the house in exactly $$$T$$$ minutes.
In the player, Polycarp stores $$$n$$$ songs, each of which is characterized by two parameters: $$$t_i$$$ and $$$g_i$$$, where $$$t_i$$$ is the length of the song in minutes ($$$1 \le t_i \le 15$$$), $$$g_i$$$ is its genre ($$$1 \le g_i \le 3$$$).
Polycarp wants to create such a playlist so that he can listen to music all the time on the way from the university to his home, and at the time of his arrival home, the playlist is over. Polycarp never interrupts songs and always listens to them from beginning to end. Thus, if he started listening to the $$$i$$$-th song, he would spend exactly $$$t_i$$$ minutes on its listening. Polycarp also does not like when two songs of the same genre play in a row (i.e. successively/adjacently) or when the songs in his playlist are repeated.
Help Polycarpus count the number of different sequences of songs (their order matters), the total duration is exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different.
The first line of the input contains two integers $$$n$$$ and $$$T$$$ ($$$1 \le n \le 15, 1 \le T \le 225$$$) — the number of songs in the player and the required total duration, respectively.
Next, the $$$n$$$ lines contain descriptions of songs: the $$$i$$$-th line contains two integers $$$t_i$$$ and $$$g_i$$$ ($$$1 \le t_i \le 15, 1 \le g_i \le 3$$$) — the duration of the $$$i$$$-th song and its genre, respectively.
Output one integer — the number of different sequences of songs, the total length of exactly $$$T$$$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different. Since the answer may be huge, output it modulo $$$10^9 + 7$$$ (that is, the remainder when dividing the quantity by $$$10^9 + 7$$$).
In the first example, Polycarp can make any of the $$$6$$$ possible playlist by rearranging the available songs: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$ and $$$[3, 2, 1]$$$ (indices of the songs are given).
","input
In the second example, the first and second songs cannot go in succession (since they have the same genre). Thus, Polycarp can create a playlist in one of $$$2$$$ possible ways: $$$[1, 3, 2]$$$ and $$$[2, 3, 1]$$$ (indices of the songs are given).
output
In the third example, Polycarp can make the following playlists: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$, $$$[3, 2, 1]$$$, $$$[1, 4]$$$, $$$[4, 1]$$$, $$$[2, 3, 4]$$$ and $$$[4, 3, 2]$$$ (indices of the songs are given).
","bitmasks, combinatorics, dp",7
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; ++i) a[i] = in.nextInt();
            boolean[] done = new boolean[n];
            int res = 0;
            while (true) {
                int bi = -1;
                for (int i = 0; i < n; ++i)
                    if (!done[i]) {
                        if (bi < 0 || a[i] < a[bi]) bi = i;
                    }
                if (bi < 0) break;
                ++res;
                for (int i = 0; i < n; ++i) if (!done[i] && a[i] % a[bi] == 0) done[i] = true;
            }
            out.println(res);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",1209_A,CODEFORCES,3591,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

public class c {
	
	static boolean seq[];
	static long memo[][], mod = (long)1e9 + 7;
	static long go(int n, int d) {
		long ans = 0;
		if(d < 0) return 0;
		if(n == seq.length) return 1;
		int f = 1;
		if(n > 0) f = seq[n-1]?1:0;
		if(memo[n][d] != -1) return memo[n][d];
		if(f == 0) {
			ans += go(n + 1, d + (seq[n]?1:0));
			ans %= mod;
			ans += go(n, d-1);
			ans %= mod;
		}
		if(f == 1) {
			ans += go(n + 1, d + (seq[n]?1:0));
			ans %= mod;
		}
		return memo[n][d] = ans;
	}
	
	public static void main(String args[]) throws IOException {
		FastScanner in = new FastScanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		//BEGIN HERE
		int n = in.nextInt();
		seq = new boolean[n];
		for (int i = 0; i  < n; i++ ) {
			seq[i] = (in.next().charAt(0) == 'f');
		}
		memo = new long[n][n+1];
		for(int i = 0; i < n; i++) {
				Arrays.fill(memo[i], -1);
		}
		System.out.println(go(0, 0));
		out.close();
	}

	static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(InputStream i) {
			br = new BufferedReader(new InputStreamReader(i));
			st = null;
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public String nextLine() throws IOException {
			if (st == null) {
				st = new StringTokenizer(br.readLine());
			}
			String line = st.nextToken(""\n"");
			st = null;
			return line;
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}
	}

	public static class combinatorics {
		static long modInv(long a, long b) {
			return 1 < a ? b - modInv(b % a, a) * b / a : 1;
		}

		static long factorial[], mod;

		combinatorics(int n, long MOD) {
			mod = MOD;
			factorial = new long[n + 1];
			factorial[0] = 1;
			for (int i = 1; i <= n; i++) {
				factorial[i] = i * factorial[i - 1];
				factorial[i] %= mod;
			}
		}

		static long nCr(int n, int r) {
			if (r > n)
				return 0;
			return (factorial[n] * modInv((factorial[n - r] * factorial[r]) % mod, mod)) % mod;
		}
	}

	public static class DisjointSet {
		int p[], r[], s[];
		int numDisjoint;

		DisjointSet(int N) {
			numDisjoint = N;
			r = new int[N];
			s = new int[N];
			p = new int[N];
			for (int i = 0; i < N; i++)
				p[i] = i;
		}

		int findSet(int i) {
			return (p[i] == i) ? i : (p[i] = findSet(p[i]));
		}

		boolean isSameSet(int i, int j) {
			return findSet(i) == findSet(j);
		}

		void unionSet(int i, int j) {
			if (!isSameSet(i, j)) // if from different set
			{
				numDisjoint--;
				int x = findSet(i), y = findSet(j);
				if (r[x] > r[y]) {
					p[y] = x; // rank keeps the tree short
					s[x] += s[y];
				} else {
					p[x] = y;
					if (r[x] == r[y])
						r[y]++;
					s[y] += s[x];
				}
			}
		}

		int sizeOfSet(int i) {
			return s[findSet(i)];
		}
	};

}
",0909_C,CODEFORCES,3096,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"// Working program using Reader Class
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main2
{
    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public Reader(String file_name) throws IOException
        {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public String readLine() throws IOException
        {
            byte[] buf = new byte[64]; // line length
            int cnt = 0, c;
            while ((c = read()) != -1)
            {
                if (c == '\n')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
            if (neg)
                return -ret;
            return ret;
        }

        public double nextDouble() throws IOException
        {
            double ret = 0, div = 1;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();

            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');

            if (c == '.')
            {
                while ((c = read()) >= '0' && c <= '9')
                {
                    ret += (c - '0') / (div *= 10);
                }
            }

            if (neg)
                return -ret;
            return ret;
        }

        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
    }


    public static void main(String[] args) throws IOException
    {
        Reader z = new Reader();
        long n=z.nextLong(), k=z.nextLong(), x;
        x=9L+8L*(k+n);
        x=(long) Math.sqrt(x);
        x=(x-3)/2;
        System.out.println(n-x);
    }
}",1195_B,CODEFORCES,1413,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class LookingForOrder {
	static int[][] pos;
	static int[] dp;
	static int[] nextstate;
	static int[][] dist;
	static int r;
	static int v;

	static void print(int mask) {
		if (mask < v) {
			int c = 0;
			int x = mask ^ nextstate[mask];
			for (int i = 0; i < dist.length - 1; i++) {
				if((x & (1<<i))>0) {
					System.out.print(i+1 + "" "");
					c++;
				}
			}
			System.out.print(""0 "");
			print(nextstate[mask]);
		}
	}

	static int distace(int x1, int x2, int y1, int y2) {
		return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
	}

	static int solve(int mask) {
		if (mask == v) {
			nextstate[mask] = r;

			return 0;
		}
		if (nextstate[mask] != 0) {
			return dp[mask];
		}

		dp[mask] = (int) 1e9;
		for (int i = 1; i < pos.length; i++) {
			int u = (1 << (i - 1));
			int z = mask | u;
			if ((mask & u) == 0) {
				int x = 2 * dist[i][0] + solve(z);
				if (dp[mask] > x) {
					dp[mask] = x;
					nextstate[mask] = z;
				}

				for (int j = 1; j < pos.length; j++) {
					int m = (1 << j - 1);
					int y = z | m;
					if ((z & m) == 0) {
						x = dist[i][0] + solve(y) + dist[i][j] + dist[j][0];

						if (dp[mask] > x) {
							dp[mask] = x;
							nextstate[mask]= y;
						}

					}
				}
				break;
			}
		}
		return dp[mask];
	}

	public static void main(String[] args) {
		InputReader0 in = new InputReader0(System.in);
		int x = in.nextInt(), y = in.nextInt();
		int n = in.nextInt();
		r = 1 << n;
		v = r - 1;
		dp = new int[r];
		nextstate = new int[r];
		pos = new int[n + 1][2];
		pos[0][0] = x;
		pos[0][1] = y;
		for (int i = 1; i < pos.length; i++) {
			pos[i][0] = in.nextInt();
			pos[i][1] = in.nextInt();
		}
		dist = new int[n + 1][n + 1];
		for (int i = 0; i < dist.length; i++) {
			for (int j = i + 1; j < dist.length; j++) {
				dist[i][j] = dist[j][i] = distace(pos[i][0], pos[j][0], pos[i][1], pos[j][1]);
			}
		}

		System.out.println(solve(0));
		System.out.print(""0 "");
		print(0);
	}

}

class InputReader0 {
	BufferedReader reader;
	StringTokenizer tokenizer;

	public InputReader0(InputStream stream) {
		reader = new BufferedReader(new InputStreamReader(stream));
		tokenizer = null;
	}

	public String next() {
		while (tokenizer == null || !tokenizer.hasMoreTokens()) {
			try {
				tokenizer = new StringTokenizer(reader.readLine());
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
		return tokenizer.nextToken();
	}

	public long nextLong() {
		return Long.parseLong(next());
	}

	public int nextInt() {
		return Integer.parseInt(next());
	}

}",0008_C,CODEFORCES,4350,Looking for Order,"Girl Lena likes it when everything is in order, and looks for order everywhere. Once she was getting ready for the University and noticed that the room was in a mess — all the objects from her handbag were thrown about the room. Of course, she wanted to put them back into her handbag. The problem is that the girl cannot carry more than two objects at a time, and cannot move the handbag. Also, if he has taken an object, she cannot put it anywhere except her handbag — her inherent sense of order does not let her do so.
You are given the coordinates of the handbag and the coordinates of the objects in some Сartesian coordinate system. It is known that the girl covers the distance between any two objects in the time equal to the squared length of the segment between the points of the objects. It is also known that initially the coordinates of the girl and the handbag are the same. You are asked to find such an order of actions, that the girl can put all the objects back into her handbag in a minimum time period.
The first line of the input file contains the handbag's coordinates xs, ys. The second line contains number n (1 ≤ n ≤ 24) — the amount of objects the girl has. The following n lines contain the objects' coordinates. All the coordinates do not exceed 100 in absolute value. All the given positions are different. All the numbers are integer.
","input
In the first line output the only number — the minimum time the girl needs to put the objects into her handbag. 
output
In the second line output the possible optimum way for Lena. Each object in the input is described by its index number (from 1 to n), the handbag's point is described by number 0. The path should start and end in the handbag's point. If there are several optimal paths, print any of them. 
","bitmasks, dp",7
"import java.util.*;
import java.io.*;
import java.text.*;
public class B1195 {

	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		long x =sc.nextInt();
		long y =sc.nextInt();
		long m = (-3+Math.round(Math.sqrt(9+8*(x+y))))/2;
		long e = x-m;
		pw.println(e);
		pw.flush();
	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public Scanner(FileReader r) {
			br = new BufferedReader(r);
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public double nextDouble() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder(""0"");
			double res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder(""0"");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

	}
}
",1195_B,CODEFORCES,1386,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"/*
 * code together
 * code better
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.HashMap;
import java.util.Scanner;

public class Main {
	
	
	static int x[]=new int[1005];
	static double ans[]=new double[1005];
	static int nn,r;
	public static void main(String[] args) throws IOException {
		StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		Scanner sc=new Scanner(System.in);
		int huiwoqingchun=0;
		nn=sc.nextInt();
		r=sc.nextInt();
		for(int i=1;i<=nn;i++) {
			x[i]=sc.nextInt();
		}
		//HashMap<, V>
		ans[1]=r;
		int lajitimu=0;
		for(int i=2;i<=nn;i++) {
			ans[i]=r;
			for(int j=1;j<i;j++) {
				if(Math.abs(x[j]-x[i])>2*r)
					continue;
				ans[i]=Math.max(ans[i], ans[j]+Math.sqrt(4*r*r-(x[j]-x[i])*(x[j]-x[i])));
			}
		}
		double buzhidaoganma=0;
		for(int c=1;c<=nn;c++)
			System.out.printf(""%.12f "",ans[c]);
	}
}

",0908_C,CODEFORCES,2985,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.List;
import java.util.StringTokenizer;
import java.util.HashMap;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {

    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        F2BlokiRavnoiSummiUslozhnennayaRedakciya solver = new F2BlokiRavnoiSummiUslozhnennayaRedakciya();
        solver.solve(1, in, out);
        out.close();
    }

    static class F2BlokiRavnoiSummiUslozhnennayaRedakciya {

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int[] sum = new int[n];
            int prev = 0;
            for (int i = 0; i < n; i++) {
                sum[i] = in.nextInt() + prev;
                prev = sum[i];
            }

            HashMap<Integer, List<Pair<Integer, Integer>>> blocks = new HashMap<>();

            int max = 0;
            int maxS = 0;
            for (int i = 0; i < n; i++) {
                for (int h = i; h >= 0; h--) {
                    int s = sum[i];
                    if (h > 0) {
                        s -= sum[h - 1];
                    }
                    blocks.putIfAbsent(s, new ArrayList<>());
                    List<Pair<Integer, Integer>> l = blocks.get(s);
                    if (l.isEmpty() || l.get(l.size() - 1).sc < h) {
                        l.add(new Pair<>(h, i));
                    }
                    if (l.size() > max) {
                        max = l.size();
                        maxS = s;
                    }
                }
            }

            out.println(max);
            for (int i = 0; i < max; i++) {
                out.println(String.format(""%d %d"", blocks.get(maxS).get(i).fs + 1, blocks.get(maxS).get(i).sc + 1));
            }
        }
    }

    static class InputReader {

        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
    }

    static class Pair<T, K> {

        T fs;
        K sc;

        public Pair(T fs, K sc) {
            this.fs = fs;
            this.sc = sc;
        }
    }
}

",1141_F2,CODEFORCES,3406,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"import java.io.*;
import java.util.*;

public class  zz{
	static int mod=(int)1e9+7;
    public static void main(String[] args) throws Exception{
        //MScanner sc = new MScanner(""chess.in"");
        MScanner sc = new MScanner(System.in);
        PrintWriter pw=new PrintWriter(System.out);
        int n=sc.nextInt();
        //int[]in=new int[n];for(int i=0;i<n;i++)in[i]=sc.nextInt();
        int k=sc.nextInt();
        int x=(-3+(int)Math.sqrt(9+4*1.0*(2*k*1.0+2*n*1.0)))/2;
        pw.println(n-x);
        pw.flush();
    }
    static class pair implements Comparable<pair>{
    	String t;int d;int idx;
    	pair(String x,int y,int i){
    		t=x;d=y;idx=i;
    	}
    	@Override
    	public int compareTo(pair o) {
    		if(t.compareTo(o.t)!=0) {
    			return t.compareTo(o.t);
    		}
    		return o.d-d;
    	}
    	 
    	public boolean equals(pair o) {
    		if(this.compareTo(o)==0)return true;
    		return false;
    	}
    	public String toString() {
    		return ""(""+t+"" ""+d+"")"";
    	}
    }
    static class MScanner {
		StringTokenizer st;
		BufferedReader br;
 
		public MScanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}
 
		public MScanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}
 
		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}
 
		public String nextLine() throws IOException {
			return br.readLine();
		}
 
		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}
 
		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}
 
		public char nextChar() throws IOException {
			return next().charAt(0);
		}
 
		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}
 
		public boolean ready() throws IOException {
			return br.ready();
		}
 
		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
}",1195_B,CODEFORCES,1411,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;
import java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;
import java.security.AccessControlException;import java.util.Arrays;import java.util.Collection;
import java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Objects;
import java.util.Scanner;import java.util.TreeMap;import java.util.function.Function;
import java.util.stream.Collectors;import java.util.stream.IntStream;import java.util.stream.LongStream;
import java.util.stream.Stream;public class _p000909A {static public void main(final String[] args) 
throws IOException{p000909A._main(args);}
static private class p000909A extends Solver{public p000909A(){nameIn=""in/1000/p000909A.in"";
singleTest=true;}@Override public void solve()throws IOException{String n=sc.next();
String s=sc.next();sc.nextLine();StringBuilder res=new StringBuilder();res.append(n.subSequence(0,
1));for(int i=1;i<n.length()&& n.charAt(i)<s.charAt(0);i++){res.append(n.charAt(i));
}res.append(s.charAt(0));pw.println(res.toString());}static public void _main(String[]
args)throws IOException{new p000909A().run();}}static private class Pair<K,V>{private 
K k;private V v;public Pair(final K t,final V u){this.k=t;this.v=u;}public K getKey()
{return k;}public V getValue(){return v;}}static private abstract class Solver{protected 
String nameIn=null;protected String nameOut=null;protected boolean singleTest=false;
protected boolean preprocessDebug=false;protected boolean doNotPreprocess=false;
protected PrintStream debugPrintStream=null;protected Scanner sc=null;protected 
PrintWriter pw=null;final static String SPACE="" "";final static String SPACES=""\\s+"";
private void process()throws IOException{if(!singleTest){int t=lineToIntArray()[0];
while(t-->0){solve();}}else{solve();}}abstract protected void solve()throws IOException;
protected String[]lineToArray()throws IOException{return sc.nextLine().trim().split(SPACES);
}protected int[]lineToIntArray()throws IOException{return Arrays.stream(lineToArray()).mapToInt(Integer::valueOf).toArray();
}protected long[]lineToLongArray()throws IOException{return Arrays.stream(lineToArray()).mapToLong(Long::valueOf).toArray();
}protected void run()throws IOException{boolean done=false;try{if(nameIn!=null && 
new File(nameIn).exists()){try(FileInputStream fis=new FileInputStream(nameIn);PrintWriter 
pw0=select_output();){done=true;sc=new Scanner(fis);pw=pw0;process();}}}catch(IOException 
ex){}catch(AccessControlException ex){}if(!done){try(PrintWriter pw0=select_output();
){sc=new Scanner(System.in);pw=pw0;process();}}}private PrintWriter select_output()
throws FileNotFoundException{if(nameOut!=null){return new PrintWriter(nameOut);}
return new PrintWriter(System.out);}public static Map<Integer,List<Integer>>mapi(final 
int[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<Integer,List<Integer>>(),
(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));
}else{res.get(a[i]).add(i);}},Map::putAll);}public static Map<Long,List<Integer>>
mapi(final long[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<Long,
List<Integer>>(),(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));
}else{res.get(a[i]).add(i);}},Map::putAll);}public static<T>Map<T,List<Integer>>
mapi(final T[]a){return IntStream.range(0,a.length).collect(()->new TreeMap<T,List<Integer>>(),
(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],Stream.of(i).collect(Collectors.toList()));
}else{res.get(a[i]).add(i);}},Map::putAll);}public static<T>Map<T,List<Integer>>
mapi(final T[]a,Comparator<T>cmp){return IntStream.range(0,a.length).collect(()->
new TreeMap<T,List<Integer>>(cmp),(res,i)->{if(!res.containsKey(a[i])){res.put(a[i],
Stream.of(i).collect(Collectors.toList()));}else{res.get(a[i]).add(i);}},Map::putAll
);}public static Map<Integer,List<Integer>>mapi(final IntStream a){int[]i=new int[]{0};
return a.collect(()->new TreeMap<Integer,List<Integer>>(),(res,v)->{if(!res.containsKey(v))
{res.put(v,Stream.of(i[0]).collect(Collectors.toList()));}else{res.get(v).add(i[0]);
}i[0]++;},Map::putAll);}public static Map<Long,List<Integer>>mapi(final LongStream 
a){int[]i=new int[]{0};return a.collect(()->new TreeMap<Long,List<Integer>>(),(res,
v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));
}else{res.get(v).add(i[0]);}i[0]++;},Map::putAll);}public static<T>Map<T,List<Integer>>
mapi(final Stream<T>a,Comparator<T>cmp){int[]i=new int[]{0};return a.collect(()->
new TreeMap<T,List<Integer>>(cmp),(res,v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));
}else{res.get(v).add(i[0]);}},Map::putAll);}public static<T>Map<T,List<Integer>>
mapi(final Stream<T>a){int[]i=new int[]{0};return a.collect(()->new TreeMap<T,List<Integer>>(),
(res,v)->{if(!res.containsKey(v)){res.put(v,Stream.of(i[0]).collect(Collectors.toList()));
}else{res.get(v).add(i[0]);}},Map::putAll);}public static List<int[]>listi(final 
int[]a){return IntStream.range(0,a.length).mapToObj(i->new int[]{a[i],i}).collect(Collectors.toList());
}public static List<long[]>listi(final long[]a){return IntStream.range(0,a.length).mapToObj(i
->new long[]{a[i],i}).collect(Collectors.toList());}public static<T>List<Pair<T,
Integer>>listi(final T[]a){return IntStream.range(0,a.length).mapToObj(i->new Pair<T,
Integer>(a[i],i)).collect(Collectors.toList());}public static List<int[]>listi(final 
IntStream a){int[]i=new int[]{0};return a.mapToObj(v->new int[]{v,i[0]++}).collect(Collectors.toList());
}public static List<long[]>listi(final LongStream a){int[]i=new int[]{0};return 
a.mapToObj(v->new long[]{v,i[0]++}).collect(Collectors.toList());}public static<T>
List<Pair<T,Integer>>listi(final Stream<T>a){int[]i=new int[]{0};return a.map(v->
new Pair<T,Integer>(v,i[0]++)).collect(Collectors.toList());}public static String 
join(final int[]a){return Arrays.stream(a).mapToObj(Integer::toString).collect(Collectors.joining(SPACE));
}public static String join(final long[]a){return Arrays.stream(a).mapToObj(Long::toString).collect(Collectors.joining(SPACE));
}public static<T>String join(final T[]a){return Arrays.stream(a).map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));
}public static<T>String join(final T[]a,final Function<T,String>toString){return 
Arrays.stream(a).map(v->toString.apply(v)).collect(Collectors.joining(SPACE));}public 
static<T>String join(final Collection<T>a){return a.stream().map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));
}public static<T>String join(final Collection<T>a,final Function<T,String>toString)
{return a.stream().map(v->toString.apply(v)).collect(Collectors.joining(SPACE));
}public static<T>String join(final Stream<T>a){return a.map(v->Objects.toString(v)).collect(Collectors.joining(SPACE));
}public static<T>String join(final Stream<T>a,final Function<T,String>toString){
return a.map(v->toString.apply(v)).collect(Collectors.joining(SPACE));}public static
<T>String join(final IntStream a){return a.mapToObj(Integer::toString).collect(Collectors.joining(SPACE));
}public static<T>String join(final LongStream a){return a.mapToObj(Long::toString).collect(Collectors.joining(SPACE));
}public static List<Integer>list(final int[]a){return Arrays.stream(a).mapToObj(Integer::valueOf).collect(Collectors.toList());
}public static List<Integer>list(final IntStream a){return a.mapToObj(Integer::valueOf).collect(Collectors.toList());
}public static List<Long>list(final long[]a){return Arrays.stream(a).mapToObj(Long::valueOf).collect(Collectors.toList());
}public static List<Long>list(final LongStream a){return a.mapToObj(Long::valueOf).collect(Collectors.toList());
}public static<T>List<T>list(final Stream<T>a){return a.collect(Collectors.toList());
}public static<T>List<T>list(final T[]a){return Arrays.stream(a).collect(Collectors.toList());
}}}
",0909_A,CODEFORCES,1821,Generate Login,"The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.
You are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).
As a reminder, a prefix of a string s is its substring which occurs at the beginning of s: ""a"", ""ab"", ""abc"" etc. are prefixes of string ""{abcdef}"" but ""b"" and 'bc"" are not. A string a is alphabetically earlier than a string b, if a is a prefix of b, or a and b coincide up to some position, and then a has a letter that is alphabetically earlier than the corresponding letter in b: ""a"" and ""ab"" are alphabetically earlier than ""ac"" but ""b"" and ""ba"" are alphabetically later than ""ac"".
","input
The input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive. 
output
Output a single string — alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.
","bruteforce, greedy, sortings",3
"import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;
 
 
public class q5 {
	
	
 
	public static void main(String[] args) throws IOException {
	
		Reader.init(System.in);
		PrintWriter out=new PrintWriter(System.out);
		long a=Reader.nextLong();
		long b=Reader.nextLong();
		a^=b;
		boolean found=false;
		long ans=0;
		for(int i=59;i>=0;i--) {
			long v=(long)Math.pow(2, i);
			if((v&a)!=0) found=true;
			if(found) ans+=v;
		}
		out.print(ans);
		out.flush();
	}
	
	
	
}

class Seg{
	int[] st,arr;
	
	Seg(int n, int[] a){
		st=new int[4*n];
		arr=a;
	}
	
	void build(int index, int left, int right, int val) {
		if(left==right) {
			st[index]=arr[left];
		}
		else {
			int mid=(left+right)/2;
			build(2*index+1,left,mid,1-val);
			build(2*index+2,mid+1,right,1-val);
			if(val==0) {
				st[index]=st[2*index+1]|st[2*index+2];
			}
			else {
				st[index]=st[2*index+1]^st[2*index+2];
			}
		}
	}
	
	void update(int index, int left, int right, int pos,int val) {
		if(left==right) {
			st[index]=arr[pos];
		}
		else {
			int mid=(left+right)/2;
			if(pos<=mid) {
				update(2*index+1,left,mid,pos,1-val);
			}
			else {
				
				update(2*index+2,mid+1,right,pos,1-val);
			}
			
			if(val==0) {
				st[index]=st[2*index+1]|st[2*index+2];
			}
			else {
				st[index]=st[2*index+1]^st[2*index+2];
			}
		}
	}
	
	
}


 
 
class Reader {
    static BufferedReader reader;
    static StringTokenizer tokenizer;
    /** call this method to initialize reader for InputStream */
    static void init() throws IOException {
    	 reader = new BufferedReader(
                 new FileReader(""input.txt""));
    tokenizer = new StringTokenizer("""");
    }
    static void init(InputStream input) {
        reader = new BufferedReader(
                     new InputStreamReader(input) );
        tokenizer = new StringTokenizer("""");
    }
    /** get next word */
    static String nextLine() throws IOException{
    	return reader.readLine();
    }
    static String next() throws IOException {
        while ( ! tokenizer.hasMoreTokens() ) {
            //TODO add check for eof if necessary
            tokenizer = new StringTokenizer(
                   reader.readLine() );
        }
        return tokenizer.nextToken();
    }
    static int nextInt() throws IOException {
        return Integer.parseInt( next() );
    }
    static long nextLong() throws IOException {
        return Long.parseLong( next() );
    }
    static double nextDouble() throws IOException {
        return Double.parseDouble( next() );
    }
}",0276_D,CODEFORCES,853,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Edu_23C {

	public static void main(String[] args) throws IOException {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer inputData = new StringTokenizer(reader.readLine());
		long bound = Long.parseLong(inputData.nextToken());
		long s = Long.parseLong(inputData.nextToken());
		if(bound < s){
			System.out.println(0);
			return;
		}

		long cur = s;
		while (cur <= bound && s + digitSum(cur) > cur) {
			cur++;
		}
		System.out.println(bound - cur + 1);
	}

	static int digitSum(long inp) {
		int sum = 0;
		while (inp != 0) {
			sum += inp % 10;
			inp /= 10;
		}
		return sum;
	}

}
",0817_C,CODEFORCES,1102,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"//package round15;


import java.io.BufferedOutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringReader;
import java.util.Arrays;
import java.util.Scanner;

public class A {
	private Scanner in;
	private PrintWriter out;
	
	public void solve()
	{
		int n = ni();
		int t = ni();
		Pair[] p = new Pair[n];
		for(int i = 0;i < n;i++){
			p[i] = new Pair();
			p[i].x = ni();
			p[i].a = ni();
		}
		Arrays.sort(p);
		
		int ct = 2;
		for(int i = 0;i < n - 1;i++){
			float d = p[i + 1].x - (float)p[i + 1].a / 2 - p[i].x - (float)p[i].a / 2;
			if(Math.abs(d - t) < EPS){
				ct++;
			}else if(d > t){
				ct += 2;
			}
		}
		
		out.println(ct);
	}

	double EPS = 0.0001;
	
	private static class Pair implements Comparable<Pair>
	{
		public int x;
		public int a;
		
		@Override
		public int compareTo(Pair o) {
			return x - o.x;
		}
	}	
	public void run() throws Exception
	{
//		in = new Scanner(new StringReader(""2 3 0 4 5 2""));
		in = new Scanner(System.in);
		System.setOut(new PrintStream(new BufferedOutputStream(System.out)));
		out = new PrintWriter(System.out);
		
//		int n = in.nextInt();
		int n = 1;
		for(int i = 1;i <= n;i++){
			long t = System.currentTimeMillis();
			solve();
			out.flush();
//			System.err.printf(""%04d/%04d %7d%n"", i, n, System.currentTimeMillis() - t);
		}
	}
	
	
	public static void main(String[] args) throws Exception
	{
		new A().run();
	}
	
	private int ni() { return Integer.parseInt(in.next()); }
	private static void tr(Object... o) { System.out.println(o.length == 1 ? o[0] : Arrays.toString(o)); }
}
",0015_A,CODEFORCES,2301,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"import java.io.*;
import java.math.*;         /* Author : Life Lover */
import java.util.*;

public class Main {

    static FastReader in;
    static PrintWriter o;

    public static void solve() {
        int q = in.nextInt();
        char[] temp1 = new char[(int) 2e5 + 3];
        char[] temp2 = new char[(int) 2e5 + 3];
        char[] temp3 = new char[(int) 2e5 + 3];
        for (int i = 0; i < (int) 2e5 + 3; i++) {
            if (i % 3 == 0) temp1[i] = 'R';
            if (i % 3 == 1) temp1[i] = 'G';
            if (i % 3 == 2) temp1[i] = 'B';
            if (i % 3 == 0) temp2[i] = 'G';
            if (i % 3 == 1) temp2[i] = 'B';
            if (i % 3 == 2) temp2[i] = 'R';
            if (i % 3 == 0) temp3[i] = 'B';
            if (i % 3 == 1) temp3[i] = 'R';
            if (i % 3 == 2) temp3[i] = 'G';
        }

        while (q-- > 0) {
            int n = in.nextInt();
            int k = in.nextInt();
            String str = in.next();

            int[] dp1 = new int[n];
            int[] dp2 = new int[n];
            int[] dp3 = new int[n];
            for (int i = 0; i < n; i++) {
                if (str.charAt(i) != temp1[i]) dp1[i]++;
                if (str.charAt(i) != temp2[i]) dp2[i]++;
                if (str.charAt(i) != temp3[i]) dp3[i]++;
            }
            for (int i = 1; i < n; i++) {
                dp1[i] += dp1[i-1];
                dp2[i] += dp2[i-1];
                dp3[i] += dp3[i-1];
            }
//            for (int i = 0; i < n; i++) {
//                o.println(dp1[i] + "" "" + dp2[i] + "" "" + dp3[i]);
//            }
//            o.println(dp1[k-1] + "" "" + dp2[k-1] + "" "" + dp3[k-1]);
            int ans = Math.min(dp1[k-1], Math.min(dp2[k-1], dp3[k-1]));
            for (int i = k; i < n; i++) {
              //  o.println(dp1[i-k] + "" "" + dp2[i-k] + "" "" + dp3[i-k]);
                ans = Math.min(ans, dp1[i] - dp1[i-k]);
                ans = Math.min(ans, dp2[i] -  dp2[i-k]);
                ans = Math.min(ans, dp3[i] - dp3[i-k]);
            }
            o.println(ans);
        }
        o.close();
        return;
    }

    public static void main(String[] args) {
        in = new FastReader();
        o = new PrintWriter(System.out);
        solve();
        return;
    }


    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        int[] readArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = nextInt();
            return a;
        }

        long[] readLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++) a[i] = nextLong();
            return a;
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

}",1196_D2,CODEFORCES,3434,RGB Substring (hard version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2 \cdot 10^5$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2 \cdot 10^5$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
","datastructures, dp, implementation, twopointers",5
"import java.io.*;
import java.util.*;

public class Main {

    public void solve() throws IOException {
        int n = nextInt();
        output.println(n / 2 * 3);
    }

    public void run() throws IOException {
        input = new BufferedReader(new InputStreamReader(System.in));
        output = new PrintWriter(System.out);
        solve();
        input.close();
        output.close();
    }

    BufferedReader input;
    PrintWriter output;
    StringTokenizer tok;

    String nextToken() throws IOException {
        while(tok == null || !tok.hasMoreTokens())
            tok = new StringTokenizer(input.readLine());

        return tok.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.valueOf(nextToken());
    }

    long nextLong() throws IOException {
        return Long.valueOf(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.valueOf(nextToken());
    }

    public static void main(String[] args) throws IOException {
        new Main().run();
    }
}
",0084_A,CODEFORCES,80,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"import java.util.Scanner;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.io.PrintWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author codeKNIGHT
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		Scanner in = new Scanner(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskA solver = new TaskA();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskA {
	public void solve(int testNumber, Scanner in, PrintWriter out) {
        int n=in.nextInt(),i,sum=0;
        int a[]=new int[n];
        for(i=0;i<n;i++)  {

            a[i]=in.nextInt();
            sum+=a[i];
        }
        Arrays.sort(a);
        int s=0,c=0;
        for(i=n-1;i>=0;i--)
        {
            if(s>sum)
                break;
            s+=a[i];
            sum-=a[i];
            
                        c++;
        }
        out.println(c);
	}
}

",0160_A,CODEFORCES,2464,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings",4
"import java.io.PrintWriter;
import java.util.*;

/**
 * Created by trung.pham on 28/12/17.
 */
public class C_Round_455_Div2 {
    static long[][]dp;

    static  long MOD =(long) 1e9 + 7;
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int n = in.nextInt();
        char[]data = new char[n];
        dp = new long[n][n];
        for(long []a : dp){
            Arrays.fill(a,-1);
        }
        for(int i = 0; i < n; i++){
            data[i] = in.next().charAt(0);
        }
        out.println(cal(0, 0, data));

        out.close();
    }

    static long cal(int index, int nested, char[]data ){
        //System.out.println(index + "" "" + nested);
        if(index + 1 == data.length){
            return 1;
        }
        if(dp[index][nested] != -1){
            return dp[index][nested];
        }
        long result = 0;
        boolean isLoop = data[index] == 'f';
        if(isLoop){
            result = cal(index + 1, nested + 1, data);
        }else{
            result = cal(index + 1, nested, data);
            if(nested > 0){
                result += cal(index, nested - 1, data);
                result %= MOD;
            }
        }
       // System.out.println(result + "" "" + index + "" "" + nested);
        return dp[index][nested]= result;

    }
}
",0909_C,CODEFORCES,3134,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"import java.io.*;
import java.util.*;
 

public class Main {
		
	public static void main(String[] args) throws java.lang.Exception {
		BufferedReader kek = new BufferedReader(new InputStreamReader(System.in));
		//Scanner skek = new Scanner(System.in);
		PrintWriter outkek = new PrintWriter(System.out);

		String[] input = kek.readLine().split("" "");
		int X0 = Integer.parseInt(input[0]), Y0 = Integer.parseInt(input[1]), N = Integer.parseInt(kek.readLine());
		
		int[] xCoords = new int[N + 1];
		int[] yCoords = new int[N + 1];
		int[][] distances = new int[N + 1][N + 1]; 
		xCoords[N] = X0;
		yCoords[N] = Y0;
		
		for(int i = 0; i < N; i++){
			input = kek.readLine().split("" "");
			xCoords[i] = Integer.parseInt(input[0]);
			yCoords[i] = Integer.parseInt(input[1]);
		}
		
		for(int i = 0; i <= N; i++){
			for(int j = i + 1; j <= N; j++){
				int temp = xCoords[i] - xCoords[j];
				int temp2 = yCoords[i] - yCoords[j];
				distances[i][j] = (temp * temp) + (temp2 * temp2);
			}
		}
		
		int[] aa = new int[1 << N];
		int[] bb = new int[1 << N];
		
		for(int i = 1; i < 1 << N; i++){
			int a = -1;
			for(int j = 0; j < N; j++){
				if((i & 1 << j) > 0){
					a = j;
					break;
				}
			}
			
			int l = i ^ 1 << a;
			int dist = distances[a][N] + distances[a][N];
			aa[i] = aa[l] + dist;
			bb[i] = l;
			
			for(int k = a + 1; k < N; k++){
				if((i & 1 << k) > 0) {
					l = i ^ 1 << a ^ 1 << k;
					dist = distances[a][N] + distances[k][N] + distances[a][k];
					if(aa[l] + dist < aa[i]){
						aa[i] = aa[l] + dist;
						bb[i] = l;
					}
				}
			}
		}
		
		int fin = (1 << N) - 1;
		outkek.println(aa[fin]);
		outkek.print('0');
		while (fin != 0){
			int temp1 = bb[fin];
			int temp2 = fin ^ temp1;
			for(int i = 0; i < N; i++){
				if((temp2 & 1 << i) > 0){
					outkek.print("" "" + (i + 1));
				}
			}
			outkek.print("" 0"");
			fin = temp1;
		}
		kek.close();
		outkek.close();
	}	
	
}
",0008_C,CODEFORCES,4338,Looking for Order,"Girl Lena likes it when everything is in order, and looks for order everywhere. Once she was getting ready for the University and noticed that the room was in a mess — all the objects from her handbag were thrown about the room. Of course, she wanted to put them back into her handbag. The problem is that the girl cannot carry more than two objects at a time, and cannot move the handbag. Also, if he has taken an object, she cannot put it anywhere except her handbag — her inherent sense of order does not let her do so.
You are given the coordinates of the handbag and the coordinates of the objects in some Сartesian coordinate system. It is known that the girl covers the distance between any two objects in the time equal to the squared length of the segment between the points of the objects. It is also known that initially the coordinates of the girl and the handbag are the same. You are asked to find such an order of actions, that the girl can put all the objects back into her handbag in a minimum time period.
The first line of the input file contains the handbag's coordinates xs, ys. The second line contains number n (1 ≤ n ≤ 24) — the amount of objects the girl has. The following n lines contain the objects' coordinates. All the coordinates do not exceed 100 in absolute value. All the given positions are different. All the numbers are integer.
","input
In the first line output the only number — the minimum time the girl needs to put the objects into her handbag. 
output
In the second line output the possible optimum way for Lena. Each object in the input is described by its index number (from 1 to n), the handbag's point is described by number 0. The path should start and end in the handbag's point. If there are several optimal paths, print any of them. 
","bitmasks, dp",7
"
import java.io.*;
import java.lang.reflect.Array;
import java.util.*;
import java.util.Map.Entry;

public class Template {

    String fileName = """";
    long INF = Long.MAX_VALUE / 3;
    int MODULO = 1000*1000*1000+7;
    long[] fenwik;
    int BORDER = 1000*1000+100;
    void solve() throws IOException {
        int n = readInt();
        int[] a = new int[n];
        for(int i=0; i<n; ++i){
            a[i] = readInt();
        }
        fenwik = new long[BORDER];
        long ans = 0;
        for(int i=n-1;i>=0;--i){
            ans+=sumFenwik(a[i]);
            incFenwik(a[i],1);
        }
        boolean even = ans % 2 == 0;
        int m = readInt();
        for(int i=0; i<m; ++i){
            int l = readInt();
            int r = readInt();

            if(((r-l+1)/2)%2==1){
                even = !even;
            }

            out.println(even?""even"":""odd"");
        }
    }

    void incFenwik(int i, int delta){
        for(;i<BORDER;i = i|(i+1)){
            fenwik[i]+=delta;
        }
    }

    long sumFenwik(int r){
        long sum = 0;
        for(;r>=0;r = (r&(r+1))-1){
            sum+=fenwik[r];
        }
        return sum;
    }

    int gcd(int a, int b){
        return b == 0 ? a : gcd(b, a%b);
     }

    long binPow(long a, long b, long m) {
        if (b == 0) {
            return 1;
        }
        if (b % 2 == 1) {
            return ((a % m) * (binPow(a, b - 1, m) % m)) % m;
        } else {
            long c = binPow(a, b / 2, m);
            return (c * c) % m;
        }

    }
    class Fenwik {
        long[] t;
        int length;

        Fenwik(int[] a) {
            length = a.length + 100;
            t = new long[length];

            for (int i = 0; i < a.length; ++i) {
                inc(i, a[i]);
            }
        }

        void inc(int ind, int delta) {
            for (; ind < length; ind = ind | (ind + 1)) {
                t[ind] += delta;
            }
        }

        long getSum(int r) {
            long sum = 0;
            for (; r >= 0; r = (r & (r + 1)) - 1) {
                sum += t[r];
            }
            return sum;
        }
    }

    class SegmentTree {
        int[] t;

        SegmentTree(int[] a) {
            int n = a.length - 1;
            t = new int[n * 4];
            build(a, 1, 1, n);
        }

        void build(int[] a, int v, int tl, int tr) {
            if (tl == tr) {
                t[v] = a[tl];
                return;
            }

            int mid = (tr + tl) / 2;

            build(a, 2 * v, tl, mid);
            build(a, 2 * v + 1, mid + 1, tr);

            t[v] = Math.max(t[2 * v], t[2 * v + 1]);
        }

        void update(int v, int tl, int tr, int pos, int value) {
            if (tl == tr) {
                t[v] = value;
                return;
            }

            int mid = (tl + tr) / 2;

            if (pos <= mid) {
                update(2 * v, tl, mid, pos, value);
            } else {
                update(2 * v + 1, mid + 1, tr, pos, value);
            }

            t[v] = Math.max(t[2 * v], t[2 * v + 1]);
        }

        int getMax(int v, int tl, int tr, int l, int r) {
            if (l > r) {
                return -1000 * 1000;
            }
            if (tl == tr) {
                return t[v];
            }

            if (l == tl && r == tr) {
                return t[v];
            }

            int mid = (tl + tr) / 2;

            int max1 = getMax(2 * v, tl, mid, l, Math.min(mid, r));
            int max2 = getMax(2 * v + 1, mid + 1, tr, Math.max(mid + 1, l), r);

            return Math.max(max1, max2);
        }
    }

    public static void main(String[] args) throws NumberFormatException, IOException {
        // TODO Auto-generated method stub
        new Template().run();
    }

    void run() throws NumberFormatException, IOException {
        solve();
        out.close();
    };

    BufferedReader in;
    PrintWriter out;

    StringTokenizer tok;
    String delim = "" "";
    Random rnd = new Random();

    Template() throws FileNotFoundException {
        try {
            in = new BufferedReader(new FileReader(""input.txt""));
            out = new PrintWriter(""output.txt"");
        } catch (Exception e) {
            if (fileName.isEmpty()) {
                in = new BufferedReader(new InputStreamReader(System.in));
                out = new PrintWriter(System.out);
            } else {
                in = new BufferedReader(new FileReader(fileName + "".in""));
                out = new PrintWriter(fileName + "".out"");
            }

        }
        tok = new StringTokenizer("""");
    }

    String readLine() throws IOException {
        return in.readLine();
    }

    String readString() throws IOException {
        while (!tok.hasMoreTokens()) {
            String nextLine = readLine();
            if (null == nextLine) {
                return null;
            }

            tok = new StringTokenizer(nextLine);
        }
        return tok.nextToken();
    }

    int readInt() throws NumberFormatException, IOException {
        return Integer.parseInt(readString());
    }

    long readLong() throws NumberFormatException, IOException {
        return Long.parseLong(readString());
    }

    double readDouble() throws NumberFormatException, IOException {
        return Double.parseDouble(readString());
    }
}
",0911_D,CODEFORCES,3235,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.ArrayList;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		FastScanner in = new FastScanner(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskD solver = new TaskD();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskD {
        ArrayList<Integer>[] g;
        int n, m;
        boolean[][] have;
        int[] x;
        int[] y;
        boolean[] used;
        int stop;
        

        public void solve(int testNumber, FastScanner in, PrintWriter out) {
                n = in.nextInt();
                g = new ArrayList[n];
                for (int i = 0; i < n; i++)
                        g[i] = new ArrayList<>();
                have = new boolean[n][n];
                m = in.nextInt();
                for (int i = 0; i < m; i++) {
                        int a = in.nextInt();
                        int b = in.nextInt();
                        --a;
                        --b;
                        g[a].add(b);
                        have[a][b] = true;
                }
                int res = Integer.MAX_VALUE;
                for (int center = 0; center < n; center++)
                        res = Math.min(res, solve(center));
                out.print(res);
        }

        int solve(int v) {
                stop = v;
                int withV = 0;
                int add = 0;
                for (int i = 0; i < n; i++)
                        if (i != v)
                                if (have[v][i])
                                        withV++;
                                else
                                        add++;
                for (int i = 0; i < n; i++)
                        if (i != v)
                                if (have[i][v])
                                        withV++;
                                else
                                        add++;
                if (have[v][v])
                        withV++;
                else
                        add++;
                x = new int[n];
                y = new int[n];
                used = new boolean[n];
                Arrays.fill(x, -1);
                Arrays.fill(y, -1);
                int matched = 0;
                for (int i = 0; i < n; i++)
                        if (i != v && x[i] == -1) {
                                Arrays.fill(used, false);
                                if (dfs(i))
                                        matched++;
                        }
                add += n - 1 - matched;
                add += m - withV - matched;
                return add;
        }
        
        boolean dfs(int v) {
                if (used[v])
                        return false;
                used[v] = true;
                for (int to : g[v])
                        if (to != stop && y[to] == -1) {
                                x[v] = to;
                                y[to] = v;
                                return true;
                        }
                for (int to : g[v])
                        if (to != stop && dfs(y[to])) {
                                x[v] = to;
                                y[to] = v;
                                return true;
                        }
                return false;
        }
}

class FastScanner {
        BufferedReader reader;
        StringTokenizer tokenizer;

        public FastScanner(InputStream inputStream)  {
                reader = new BufferedReader(new InputStreamReader(inputStream));
        }

        public String nextToken() {
                while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                        String line;
                        try {
                                line = reader.readLine();
                        } catch (IOException e) {
                                return null;
                        }
                        tokenizer = new StringTokenizer(line);
                }
                return tokenizer.nextToken();
        }

        public int nextInt() {
                return Integer.parseInt(nextToken());
        }

        }

",0387_D,CODEFORCES,3997,George and Interesting Graph,"George loves graphs. Most of all, he loves interesting graphs. We will assume that a directed graph is interesting, if it meets the following criteria: 
However, not everything's that simple. George got a directed graph of n vertices and m arcs as a present. The graph didn't have any multiple arcs. As George loves interesting graphs, he wants to slightly alter the presented graph and transform it into an interesting one. In one alteration he can either remove an arbitrary existing arc from the graph or add an arbitrary arc to the graph. 
George wonders: what is the minimum number of changes that he needs to obtain an interesting graph from the graph he's got as a present? Help George and find the answer to the question.
The first line contains two space-separated integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ 1000) — the number of vertices and arcs in the presented graph.
Each of the next m lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n) — the descriptions of the graph's arcs. Pair (ai, bi) means that the graph contains an arc from vertex number ai to vertex number bi. It is guaranteed that the presented graph doesn't contain multiple arcs.
Assume that the grah vertices are numbered 1 through n.
Print a single integer — the answer to George's question.
","input
For more information about directed graphs, please visit: http://en.wikipedia.org/wiki/Directed_graph
output
In the first sample the graph already is interesting, its center is vertex 3.
",graphmatchings,6
"import java.io.*;
import java.util.*;

/*

 */
public class A {
	static FastReader sc=null;
	
	public static void main(String[] args) {
		sc=new FastReader();
		int n=sc.nextInt();
		char line[]=sc.next().toCharArray();
		int sum=0;
		for(char e:line)sum+=(e-'0');
		boolean po=false;
		outer:for(int i=1;i<=sum;i++) {
			if(sum%i==0) {
				int ans=sum/i;
				int j=0,curr=0,c=0;
				//System.out.println(""ans ""+ans);
				while(j<n) {
					curr+=line[j]-'0';
					if(curr==ans) {
						curr=0;
						c++;
					}
					else if(curr>ans)continue outer;
					j++;
				}
				//System.out.println(""curr ""+curr);
				if(curr==0 && c>1) {
					po=true;
					break;
				}
				
			}
		}
		System.out.println((po || (sum==0 && line.length>1))?""YES"":""NO"");
		
		
		
	}
	
	
	
	

	
	
	
	
	
	
	static int[] reverse(int a[]) {
		ArrayList<Integer> al=new ArrayList<>();
		for(int i:a)al.add(i);
		Collections.sort(al,Collections.reverseOrder());
		for(int i=0;i<a.length;i++)a[i]=al.get(i);
		return a;
	}
	static int gcd(int a,int b) {
		if(b==0)return a;
		else return gcd(b,a%b);
	}
	static long gcd(long a,long b) {
		if(b==0)return a;
		else return gcd(b,a%b);
	}
	
	static void ruffleSort(int a[]) {
		ArrayList<Integer> al=new ArrayList<>();
		for(int i:a)al.add(i);
		Collections.sort(al);
		for(int i=0;i<a.length;i++)a[i]=al.get(i);
	}
	
	
	static void print(long a[]) {
		for(long e:a) {
			System.out.print(e+"" "");
		}
		System.out.println();
	}
	static void print(char a[]) {
		for(char e:a) {
			System.out.print(e+"" "");
		}
		System.out.println();
	}
	
	
	static void print(int a[]) {
		for(int e:a) {
			System.out.print(e+"" "");
		}
		System.out.println();
	}
	static void print(double a[]) {
		for(double e:a) {
			System.out.print(e+"" "");
		}
		System.out.println();
	}
	
	static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader() 
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
        int[] readArray(int n) {
    		int a[]=new int [n];
    		for(int i=0;i<n;i++) {
    			a[i]=sc.nextInt();
    		}
    		return a;
    	}
    } 
}






",1030_C,CODEFORCES,3305,Vasya and Golden Ticket,"Recently Vasya found a golden ticket — a sequence which consists of $$$n$$$ digits $$$a_1a_2\dots a_n$$$. Vasya considers a ticket to be lucky if it can be divided into two or more non-intersecting segments with equal sums. For example, ticket $$$350178$$$ is lucky since it can be divided into three segments $$$350$$$, $$$17$$$ and $$$8$$$: $$$3+5+0=1+7=8$$$. Note that each digit of sequence should belong to exactly one segment.
Help Vasya! Tell him if the golden ticket he found is lucky or not.
The first line contains one integer $$$n$$$ ($$$2 \le n \le 100$$$) — the number of digits in the ticket.
The second line contains $$$n$$$ digits $$$a_1 a_2 \dots a_n$$$ ($$$0 \le a_i \le 9$$$) — the golden ticket. Digits are printed without spaces.
If the golden ticket is lucky then print ""YES"", otherwise print ""NO"" (both case insensitive).
","input
In the first example the ticket can be divided into $$$7$$$, $$$34$$$ and $$$52$$$: $$$7=3+4=5+2$$$.
output
In the second example it is impossible to divide ticket into segments with equal sum.
",implementation,5
"import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        FastScanner in = new FastScanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        new Main().run(in, out);
        out.close();
    }

    public static long mod = 17352642619633L;

    void run(FastScanner in, PrintWriter out) {
        // kth digit
        long K = in.nextLong();

        // which number encompasses the Kth digit

        long lo = 1;
        long hi = (long)1e12+1;

        while (lo < hi) {
            long m = (lo+hi)>>1;
            long d = numDigitsLte(m);
            if (d <= K) {
                lo = m+1;
            } else {
                hi = m;
            }
        }

        // 123[1]1391 = m digits
        long numDigits = numDigitsLte(lo);
        if (numDigitsLte(lo-1) == K) {
            out.println((((lo-1)%10)+10)%10);
        } else {
            int offset = (int)(numDigits-K);

            // out.print(lo + "" "");
            List<Long> digits = new ArrayList<>();
            while (lo > 0) {
                digits.add(lo%10);
                lo /= 10;
            }
            // backwards
            // before : 1[2]3456
            // in list: 6543[2]1
            // offset = 4
            out.println(digits.get(offset));

        }
    }

    static long[] dig = new long[15];
    static {
        for (int i = 1; i < dig.length; i++) {
            dig[i] = 9 * (long)Math.pow(10, i-1) * i;
        }

        for (int i = 1; i < dig.length; i++) {
            dig[i] += dig[i-1];
        }
    }

    long numDigitsLte(long m) {
        if (m <= 9) return m;

        int numDigits = 0;
        long M = m;
        while (M > 0) {
            numDigits++;
            M /= 10;
        }

        long ret = dig[numDigits-1];
        ret += (m-(long)Math.pow(10, numDigits-1)+1)*numDigits;
        return ret;

        // digits below
        // 9 + 90 + 900
        // [1-9], [10-99], [100-999]
        // 9, 90*2, 900*3, ...
        // 9999..

        // 9138
        // [1-1000), [1000,9138]
    }

    static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(InputStream in) {
            br = new BufferedReader(new InputStreamReader(in));
            st = null;
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }
    }
}
",1177_B,CODEFORCES,1299,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"//بسم الله الرحمن الرحيم
import java.util.*;
import java.lang.*;
import java.nio.*;
import java.io.*;
public class as {
	static class Reader 
    { 
        final private int BUFFER_SIZE = 1 << 16; 
        private DataInputStream din; 
        private byte[] buffer; 
        private int bufferPointer, bytesRead; 
  
        public Reader() 
        { 
            din = new DataInputStream(System.in); 
            buffer = new byte[BUFFER_SIZE]; 
            bufferPointer = bytesRead = 0; 
        } 
  
        public Reader(String file_name) throws IOException 
        { 
            din = new DataInputStream(new FileInputStream(file_name)); 
            buffer = new byte[BUFFER_SIZE]; 
            bufferPointer = bytesRead = 0; 
        } 
  
        public String readLine() throws IOException 
        { 
            byte[] buf = new byte[100000000]; // line length 
            int cnt = 0, c; 
            while ((c = read()) != -1) 
            { 
                if (c == '\n') 
                    break; 
                buf[cnt++] = (byte) c; 
            } 
            return new String(buf, 0, cnt); 
        } 
  
        public int nextInt() throws IOException 
        { 
            int ret = 0; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
            do
            { 
                ret = ret * 10 + c - '0'; 
            }  while ((c = read()) >= '0' && c <= '9'); 
  
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        public long nextLong() throws IOException 
        { 
            long ret = 0; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
            do { 
                ret = ret * 10 + c - '0'; 
            } 
            while ((c = read()) >= '0' && c <= '9'); 
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        public double nextDouble() throws IOException 
        { 
            double ret = 0, div = 1; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
  
            do { 
                ret = ret * 10 + c - '0'; 
            } 
            while ((c = read()) >= '0' && c <= '9'); 
  
            if (c == '.') 
            { 
                while ((c = read()) >= '0' && c <= '9') 
                { 
                    ret += (c - '0') / (div *= 10); 
                } 
            } 
  
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        private void fillBuffer() throws IOException 
        { 
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); 
            if (bytesRead == -1) 
                buffer[0] = -1; 
        } 
  
        private byte read() throws IOException 
        { 
            if (bufferPointer == bytesRead) 
                fillBuffer(); 
            return buffer[bufferPointer++]; 
        } 
  
        public void close() throws IOException 
        { 
            if (din == null) 
                return; 
            din.close(); 
        } 
    } 
	/////////////////////////////////////////////////////////////
	public static void main(String[] args) throws Exception {
		Reader sc=new Reader();
		StringBuilder finalAnswer=new StringBuilder();
		//finalAnswer.append(1).append('\n');
		int t=sc.nextInt();
		while(t-->0) {
			int count=0;
			int n=sc.nextInt();
			if(n==2 || n==4) {
				finalAnswer.append(""YES"").append('\n');
				count++;
			}
			if(n%2==0 && count==0){
				n/=2;
				if((int)Math.sqrt(n)*(int)Math.sqrt(n)==n) {
					finalAnswer.append(""YES"").append('\n');
					count++;
				}
				else {
					n*=2;
				}
			}
			if(n%4==0 && count==0) {
				n/=4;
				if((int)Math.sqrt(n)*(int)Math.sqrt(n)==n) {
					finalAnswer.append(""YES"").append('\n');
					count++;
				}
			}
			if(count==0){
				finalAnswer.append(""NO"").append('\n');
			}
		}
		System.out.println(finalAnswer);
	}
	/////////////////////////////////////////////////////////
	
	public static long gcd(long a, long b)
	{
	    while (b > 0)
	    {
	        long temp = b;
	        b = a % b; // % is remainder
	        a = temp;
	    }
	    return a;
	}
	public static long lcm(long a, long b)
	{
	    return a * (b / gcd(a, b));
	}
	static boolean containsDigit(int number, int digit)
	{
	    while (number > 0)
	    {
	        int curr_digit = number % 10;
	        if (curr_digit == digit) return true;
	        number /= 10;
	    }

	    return false;
	}
	static boolean isPalindrome(String s) {
		  int n = s.length();
		  for (int i = 0; i < (n/2); ++i) {
		     if (s.charAt(i) != s.charAt(n - i - 1)) {
		         return false;
		     }
		  }

		  return true;
	}
	void sieveOfEratosthenes(int n)
    {
        // Create a boolean array 
        // ""prime[0..n]"" and
        // initialize all entries 
        // it as true. A value in
        // prime[i] will finally be 
        // false if i is Not a
        // prime, else true.
        boolean prime[] = new boolean[n + 1];
        for (int i = 0; i <= n; i++)
            prime[i] = true;
 
        for (int p = 2; p * p <= n; p++) 
        {
            // If prime[p] is not changed, then it is a
            // prime
            if (prime[p] == true) 
            {
                // Update all multiples of p
                for (int i = p * p; i <= n; i += p)
                    prime[i] = false;
            }
        }
 
        // Print all prime numbers
        for (int i = 2; i <= n; i++)
        {
            if (prime[i] == true)
                System.out.print(i + "" "");
        }
    }
}

",1515_B,CODEFORCES,2182,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",3
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;

public class CFFF {
	static PrintWriter out;
	static final int oo = 987654321;
	static final long mod = (long)(1e9)+9;
	public static void main(String[] args) {
		MScanner sc = new MScanner();
		out = new PrintWriter(System.out);

		long N = sc.nextLong();
		long M = sc.nextLong();
		long K = sc.nextLong();
		
		if(M<=N-N/K)
			out.println(M);
		else{
			long ans = (fastModExpo(2,M-(N-N%K)/K*(K-1)-N%K+1,mod)-2)*K+M-(M-(N-N%K)/K*(K-1)-N%K)*K;
			out.println((mod+ans)%mod);
		}		
		out.close();
	}
	static long fastModExpo(int base, long pow, long mod) {
		if (pow == 0) 
			return 1L;
		if ((pow & 1) == 1)
			return (base*fastModExpo(base, pow - 1,mod))%mod;
		long temp = fastModExpo(base, pow / 2, mod);
		return (temp*temp)%mod;
	}

	static class MScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public MScanner() {
			stream = System.in;
			// stream = new FileInputStream(new File(""dec.in""));

		}

		int read() {
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars) {
				curChar = 0;
				try {
					numChars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (numChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		int[] nextInt(int N) {
			int[] ret = new int[N];
			for (int a = 0; a < N; a++)
				ret[a] = nextInt();
			return ret;
		}

		int[][] nextInt(int N, int M) {
			int[][] ret = new int[N][M];
			for (int a = 0; a < N; a++)
				ret[a] = nextInt(M);
			return ret;
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		long[] nextLong(int N) {
			long[] ret = new long[N];
			for (int a = 0; a < N; a++)
				ret[a] = nextLong();
			return ret;
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		double[] nextDouble(int N) {
			double[] ret = new double[N];
			for (int a = 0; a < N; a++)
				ret[a] = nextDouble();
			return ret;
		}

		String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		String[] next(int N) {
			String[] ret = new String[N];
			for (int a = 0; a < N; a++)
				ret[a] = next();
			return ret;
		}

		String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}

		String[] nextLine(int N) {
			String[] ret = new String[N];
			for (int a = 0; a < N; a++)
				ret[a] = nextLine();
			return ret;
		}

	}
}
",0338_A,CODEFORCES,975,Quiz,"Manao is taking part in a quiz. The quiz consists of n consecutive questions. A correct answer gives one point to the player. The game also has a counter of consecutive correct answers. When the player answers a question correctly, the number on this counter increases by 1. If the player answers a question incorrectly, the counter is reset, that is, the number on it reduces to 0. If after an answer the counter reaches the number k, then it is reset, and the player's score is doubled. Note that in this case, first 1 point is added to the player's score, and then the total score is doubled. At the beginning of the game, both the player's score and the counter of consecutive correct answers are set to zero.
Manao remembers that he has answered exactly m questions correctly. But he does not remember the order in which the questions came. He's trying to figure out what his minimum score may be. Help him and compute the remainder of the corresponding number after division by 1000000009 (109 + 9).
The single line contains three space-separated integers n, m and k (2 ≤ k ≤ n ≤ 109; 0 ≤ m ≤ n).
Print a single integer — the remainder from division of Manao's minimum possible score in the quiz by 1000000009 (109 + 9).
Sample 1. Manao answered 3 questions out of 5, and his score would double for each two consecutive correct answers. If Manao had answered the first, third and fifth questions, he would have scored as much as 3 points.
","input
Sample 2. Now Manao answered 4 questions. The minimum possible score is obtained when the only wrong answer is to the question 4.
output
Also note that you are asked to minimize the score and not the remainder of the score modulo 1000000009. For example, if Manao could obtain either 2000000000 or 2000000020 points, the answer is 2000000000 mod 1000000009, even though 2000000020 mod 1000000009 is a smaller number.
","greedy, math, numbertheory",2
"
import java.util.Scanner;

public class BDigitSequence {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        long k = scan.nextLong();

        long digits = 1;
        long counter = 9L;

        while(k > counter * digits) {
            k -= counter * digits;
            counter *= 10;
            digits++;
        }

        long num = (long)(Math.ceil((double)k/digits));
        String s = String.valueOf((long)Math.pow(10,digits-1) - 1 + num );

        System.out.println(s.charAt((int)((k+digits-1)%digits)));
    }
}
",1177_B,CODEFORCES,1311,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"import java.util.*;
import java.io.*;
import java.lang.*;
import java.math.*;
public class B {
    public static PrintWriter out;
    public static BufferedReader bf;
    public static int n;
    public static int[] a;
    public static void main(String[] args) throws Exception {
        bf = new BufferedReader(new InputStreamReader(System.in));
        // Scanner scan = new Scanner(System.in);
        out = new PrintWriter(new OutputStreamWriter(System.out));
        n = Integer.parseInt(bf.readLine());
        a = new int[n];
        Arrays.fill(a, Integer.MAX_VALUE);
        if((n/2) % 2 != 0) {
          out.println(""! "" + (-1));
          out.flush();
          out.close(); System.exit(0);
        }

        ask(0);
        ask(opp(0));

        int low = 0;
        int high = opp(0);
        while(true) {
          int test = (low + high)/2;
          ask(test);
          ask(opp(test));
          int l_1 = a[low];
          int l_2 = a[test];
          int r_1 = a[opp(low)];
          int r_2 = a[opp(test)];
          if(1L*(l_1 - r_1)*(l_2 - r_2) < 0L) {
            high = test;
          }
          else low = test;
        }

        // StringTokenizer st = new StringTokenizer(bf.readLine());
        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());
        // int n = Integer.parseInt(st.nextToken());
        // int n = scan.nextInt();

        //out.close(); System.exit(0);
    }
    public static int ask(int i) throws Exception { // 0 thru n-1;
      out.println(""? "" + (i+1));
      out.flush();
      int k = Integer.parseInt(bf.readLine());
      a[i] = k;
      if(a[i] == a[opp(i)]) {
        out.println(""! "" + (i+1));
        out.flush();
        out.close(); System.exit(0);
      }

      return k;
    }
    public static int opp(int k) {
      return ((k + n/2) % n);
    }
}
",1019_B,CODEFORCES,1249,The hat,"This is an interactive problem.
Imur Ishakov decided to organize a club for people who love to play the famous game «The hat». The club was visited by n students, where n is even. Imur arranged them all in a circle and held a draw to break the students in pairs, but something went wrong. The participants are numbered so that participant i and participant i + 1 (1 ≤ i ≤ n - 1) are adjacent, as well as participant n and participant 1. Each student was given a piece of paper with a number in such a way, that for every two adjacent students, these numbers differ exactly by one. The plan was to form students with the same numbers in a pair, but it turned out that not all numbers appeared exactly twice.
As you know, the most convenient is to explain the words to the partner when he is sitting exactly across you. Students with numbers i and  sit across each other. Imur is wondering if there are two people sitting across each other with the same numbers given. Help him to find such pair of people if it exists.
You can ask questions of form «which number was received by student i?», and the goal is to determine whether the desired pair exists in no more than 60 questions.
At the beginning the even integer n (2 ≤ n ≤ 100 000) is given — the total number of students.
You are allowed to ask no more than 60 questions.
To ask the question about the student i (1 ≤ i ≤ n), you should print «? i». Then from standard output you can read the number ai received by student i ( - 109 ≤ ai ≤ 109).
When you find the desired pair, you should print «! i», where i is any student who belongs to the pair (1 ≤ i ≤ n). If you determined that such pair doesn't exist, you should output «! -1». In both cases you should immediately terminate the program.
The query that contains your answer is not counted towards the limit of 60 queries.
Please make sure to flush the standard output after each command. For example, in C++ use function fflush(stdout), in Java call System.out.flush(), in Pascal use flush(output) and stdout.flush() for Python language.
Hacking
Use the following format for hacking:
In the first line, print one even integer n (2 ≤ n ≤ 100 000) — the total number of students.
In the second line print n integers ai ( - 109 ≤ ai ≤ 109) separated by spaces, where ai is the number to give to i-th student. Any two adjacent elements, including n and 1, must differ by 1 or  - 1.
The hacked solution will not have direct access to the sequence ai.
Input-output in statements illustrates example interaction.
","input
In the first sample the selected sequence is 1, 2, 1, 2, 3, 4, 3, 2
output
In the second sample the selection sequence is 1, 2, 3, 2, 1, 0.
","binarysearch, interactive",2
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.StringTokenizer;
import javafx.util.Pair;

public class Solve6 {

    public static void main(String[] args) throws IOException {
        PrintWriter pw = new PrintWriter(System.out);
        new Solve6().solve(pw);
        pw.flush();
        pw.close();
    }

    public void solve(PrintWriter pw) throws IOException {
        FastReader sc = new FastReader();
        int n = sc.nextInt();
        int[] a = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = sc.nextInt();
        }
        HashMap<Integer, LinkedList<Pair<Integer, Integer>>> h = new HashMap();
        for (int i = 1; i <= n; i++) {
            int s = 0;
            for (int j = i; j >= 1; j--) {
                s += a[j];
                LinkedList<Pair<Integer, Integer>> l;
                if (!h.containsKey(s)) {
                    l = new LinkedList();
                } else {
                    l = h.get(s);
                }
                l.add(new Pair(j, i));
                h.put(s, l);
            }
        }
        LinkedList<Pair<Integer, Integer>>[] l = new LinkedList[h.size() + 1];
        for (int i = 1; i <= h.size(); i++) {
            l[i] = new LinkedList();
        }
        int k = 0, max = 0, index = 0;
        for (LinkedList<Pair<Integer, Integer>> temp : h.values()) {
            k++;
            int i = 0, size = 0;
            for (Pair<Integer, Integer> pair : temp) {
                if (pair.getKey() > i) {
                    i = pair.getValue();
                    l[k].add(pair);
                    size++;
                    if (size > max) {
                        max = size;
                        index = k;
                    }
                }
            }
        }
        pw.println(l[index].size());
        for (Pair<Integer, Integer> pair : l[index]) {
            pw.println(pair.getKey() + "" "" + pair.getValue());
        }
    }

    static class FastReader {

        StringTokenizer st;
        BufferedReader br;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        public boolean hasNext() throws IOException {
            String s = br.readLine();
            if (s == null || s.isEmpty()) {
                return false;
            }
            st = new StringTokenizer(s);
            return true;
        }

        public String next() throws IOException {
            if (st == null || !st.hasMoreTokens()) {
                String s = br.readLine();
                if (s.isEmpty()) {
                    return null;
                }
                st = new StringTokenizer(s);
            }
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }
    }
}
",1141_F2,CODEFORCES,3409,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"import java.util.*;
import java.math.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------

public class a{ 
     static int[] count,count1,count2;
     static Node[] nodes;
     static long[] arr;
     static int[] dp;
     static char[] ch,ch1;
     static long[] darr,farr;
     static char[][] mat,mat1;
     static int[][] space;
     static boolean[][] vis;
     static long x,h;
     static long maxl;
     static double dec;
     static long mx = (long)1e10;
     static String s;
     static long minl;
     static int start_row;
     static int start_col;     
     static int end_row;     
     static int end_col;     
     static long mod = 998244353;
     // static int minl = -1;
     // static long n;
     static int n,n1,n2,q,r1,c1,r2,c2;
     static long a;
     static long b;
     static long c;
     static long d;
     static long y,z;
     static int m;
     static long k;
     static FastScanner sc;
     static String[] str,str1;
     static Set<Long> set,set1,set2;
     static SortedSet<Long> ss;
     static List<Long> list,list1,list2,list3;
     static PriorityQueue<Integer> pq,pq1;
     static LinkedList<Node> ll;
     static Map<Integer,List<Integer>> map1;
     static Map<Long,Integer> map;
     static StringBuilder sb,sb1,sb2;
     static int index;
     static long ans;
     static long[] sum;
     static int[] dx = {0,-1,0,1,-1,1,-1,1};
     static int[] dy = {-1,0,1,0,-1,-1,1,1};

     // public static void solve(){

     //    FastScanner sc = new FastScanner();
     //    // int t = sc.nextInt();
     //    int t = 1;
     //    for(int tt = 0 ; tt < t ; tt++){
     //        n = sc.nextInt();
     //        m = sc.nextInt();
     //        // sb = new StringBuilder();
     //        // map = new HashMap<>();
     //        q = sc.nextInt();
     //        // ch = sc.next().toCharArray();
     //        // boolean ans = false;
     //        int charge = n;
     //        int prev = 0;
     //        for(int j = 0 ; j < m ; j++){

     //            int l = sc.nextInt();
     //            int r = sc.nextInt();
     //            charge = Math.max(0,charge - (l-prev));
     //            if(charge <= 0){
     //                System.out.println(""No"");
     //                return;
     //            }
     //            charge = Math.min(n,charge + (r-l));
     //            prev = r;
          
     //        }

     //        charge = Math.max(0,charge - (q-prev));
     //        if(charge > 0){
     //            System.out.println(""Yes"");
     //        }
     //        else{
     //            System.out.println(""No"");
     //        }

     //    }
        
        
     // }

     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------
  
     public static void solve(){

        ruffleSort(arr);
        a = arr[0];
        b = arr[1];
        c = arr[2];

        if(a == 1){
            System.out.println(""YES"");
            return;
        }

        if(a == 2 && b == 2){
            System.out.println(""YES"");
            return;
        }

        if(a == 3 && a == b && b == c){
            System.out.println(""YES"");
            return;
        }

        if(a == 2 && b == c && c == 4){
            System.out.println(""YES"");
            return;
        }

        System.out.println(""NO"");
        return;

     }
        
     public static void main(String[] args) {

            sc = new FastScanner();
            // Scanner sc = new Scanner(System.in);
            // int t = sc.nextInt();
            int t = 1;
            // int l = 1;
            while(t > 0){
                
                // n = sc.nextInt();
                // n = sc.nextLong();
                // k = sc.nextLong();
                // a = sc.nextLong();
                // b = sc.nextLong();
                // c = sc.nextLong();
                // d = sc.nextLong();

                // x = sc.nextLong();
                // y = sc.nextLong();
                
                // n = sc.nextLong();
                // n = sc.nextInt();
                n = 3;
                // n1 = sc.nextInt();

                // m = sc.nextInt();
                // q = sc.nextInt();

                // k = sc.nextLong();
                // s = sc.next();

                // ch = sc.next().toCharArray();
                // ch1 = sc.next().toCharArray();

                arr = new long[n];
                for(int i = 0 ; i < n ; i++){
                    arr[i] = sc.nextLong();
                }
                // x = sc.nextLong();
                // y = sc.nextLong();
                // ch = sc.next().toCharArray();
                // m = n;
                // darr = new long[m];
                // for(int i = 0 ; i < m ; i++){
                //     darr[i] = ch[i]-'0';
                // }

                // farr = new int[n];
                // for(int i = 0; i < n ; i++){
                //     farr[i] = sc.nextInt();
                // }

                // mat = new int[n][n];
                // for(int i = 0 ; i < n ; i++){
                //     for(int j = 0 ;  j < n ; j++){
                //         mat[i][j] = sc.nextInt();
                //     }
                // }

                // m = n;
                // mat = new char[n][m];
                // for(int i = 0 ; i < n ; i++){
                //     String s = sc.next();
                //     for(int j = 0 ; j < m ; j++){
                //         mat[i][j] = s.charAt(j);
                //     }
                // }

                // m = n;
                // mat1 = new char[n][m];
                // for(int i = 0 ; i < n ; i++){
                //     String s = sc.next();
                //     for(int j = 0 ; j < m ; j++){
                //         mat1[i][j] = s.charAt(j);
                //     }
                // }

                // str = new String[n];
                // for(int i = 0 ; i < n ; i++)
                //     str[i] = sc.next();

                // nodes = new Node[n];
                // for(int i = 0 ; i < n ;i++)
                //     nodes[i] = new Node(sc.nextInt(),(i));

                // System.out.println(solve()?""YES"":""NO"");
                 solve();       
                 // System.out.println(solve());
                 t -= 1;
            }

     }

     // public static dfs(int i){

     //    if(count[i] == 1)
     //        return;
     //    list = map.get(i);
     //    for(Integer j : list){
     //        if(j == i)
     //            continue;
     //        dfs(j);
     //    }
     // }

    public static int log(long n,long base){

         if(n == 0 || n == 1)
             return 0;

         if(n == base)
             return 1;

         double num = Math.log(n);
         double den = Math.log(base);

         if(den == 0)
             return 0;

         return (int)(num/den);
     }

    public static boolean isPrime(long n) { 
    // Corner cases 
        if (n <= 1)  
            return false; 

        if (n <= 3)  
            return true; 
      
        // This is checked so that we can skip  
        // middle five numbers in below loop 
        if (n%2 == 0 || n%3 == 0) 
            return false; 
      
        for (int i=5; i*i<=n; i=i+6) 
            if (n%i == 0 || n%(i+2) == 0) 
               return false; 
      
        return true; 
    } 

     public static long gcd(long a,long b){

        if(b%a == 0){
            return a;
        }
        return gcd(b%a,a);

     }

     public static void swap(int i,int j){
         char temp = ch[j];
         ch[j] = ch[i];
         ch[i] = temp;
     } 

    static final Random random=new Random();
    
    static void ruffleSort(long[] a) {
        int n=a.length;//shuffle, then sort 
        for (int i=0; i<n; i++) {
            int oi=random.nextInt(n);
            long temp=a[oi];
            a[oi]=a[i]; a[i]=temp;
        }
        Arrays.sort(a);
    }

    static class Node{
        Integer first;
        Integer second;
        Node(Integer f,Integer s){
            this.first = f;
            this.second = s;
        }
    }

     static class FastScanner {

                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
                StringTokenizer st=new StringTokenizer("""");
                String next() {
                        while (!st.hasMoreTokens())
                                try {
                                        st=new StringTokenizer(br.readLine());
                                } catch (IOException e) {
                                        e.printStackTrace();
                                }
                        return st.nextToken();
                }
                
                int nextInt() {
                        return Integer.parseInt(next());
                }
                int[] readArray(int n) {
                        int[] a=new int[n];
                        for (int i=0; i<n; i++) a[i]=nextInt();
                        return a;
                }
                long nextLong() {
                        return Long.parseLong(next());
                }
        }

}",0911_C,CODEFORCES,566,Three Garlands,"Mishka is decorating the Christmas tree. He has got three garlands, and all of them will be put on the tree. After that Mishka will switch these garlands on.
When a garland is switched on, it periodically changes its state — sometimes it is lit, sometimes not. Formally, if i-th garland is switched on during x-th second, then it is lit only during seconds x, x + ki, x + 2ki, x + 3ki and so on.
Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland. Formally, Mishka wants to choose three integers x1, x2 and x3 (not necessarily distinct) so that he will switch on the first garland during x1-th second, the second one — during x2-th second, and the third one — during x3-th second, respectively, and during each second starting from max(x1, x2, x3) at least one garland will be lit.
Help Mishka by telling him if it is possible to do this!
The first line contains three integers k1, k2 and k3 (1 ≤ ki ≤ 1500) — time intervals of the garlands.
If Mishka can choose moments of time to switch on the garlands in such a way that each second after switching the garlands on at least one garland will be lit, print YES.
Otherwise, print NO.
","input
In the first example Mishka can choose x1 = 1, x2 = 2, x3 = 1. The first garland will be lit during seconds 1, 3, 5, 7, ..., the second — 2, 4, 6, 8, ..., which already cover all the seconds after the 2-nd one. It doesn't even matter what x3 is chosen. Our choice will lead third to be lit during seconds 1, 4, 7, 10, ..., though.
output
In the second example there is no way to choose such moments of time, there always be some seconds when no garland is lit.
","bruteforce, constructivealgorithms",1
"import java.io.*;
import java.util.*;
public class A {
    public static void main(String[] args)throws Throwable {
        MyScanner sc=new MyScanner();
        PrintWriter pw=new PrintWriter(System.out);

        int n=sc.nextInt();
        int d=sc.nextInt();
        int [] a=new int [n];
        for(int i=0;i<n;i++)
            a[i]=sc.nextInt();
        int ans=2;
        for(int i=0;i<n-1;i++){
            if(a[i+1]-a[i]<2*d)
                continue;
            if(a[i+1]-a[i]==2*d)
                ans++;
            else
                ans+=2;
        }
        pw.println(ans);
        pw.flush();
        pw.close();
    }

    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;
        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        String next() {while (st == null || !st.hasMoreElements()) {
            try {st = new StringTokenizer(br.readLine());}
            catch (IOException e) {e.printStackTrace();}}
            return st.nextToken();}
        int nextInt() {return Integer.parseInt(next());}
        long nextLong() {return Long.parseLong(next());}
        double nextDouble() {return Double.parseDouble(next());}
        String nextLine(){String str = """";
            try {str = br.readLine();}
            catch (IOException e) {e.printStackTrace();}
            return str;}
    }
}",1004_A,CODEFORCES,1987,Sonya and Hotels,"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.
The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $$$n$$$ hotels, where the $$$i$$$-th hotel is located in the city with coordinate $$$x_i$$$. Sonya is a smart girl, so she does not open two or more hotels in the same city.
Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $$$d$$$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 
Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $$$n$$$ hotels to the new one is equal to $$$d$$$.
The first line contains two integers $$$n$$$ and $$$d$$$ ($$$1\leq n\leq 100$$$, $$$1\leq d\leq 10^9$$$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.
The second line contains $$$n$$$ different integers in strictly increasing order $$$x_1, x_2, \ldots, x_n$$$ ($$$-10^9\leq x_i\leq 10^9$$$) — coordinates of Sonya's hotels.
Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $$$d$$$.
","input
In the first example, there are $$$6$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$-6$$$, $$$5$$$, $$$6$$$, $$$12$$$, $$$13$$$, and $$$19$$$.
output
In the second example, there are $$$5$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$2$$$, $$$6$$$, $$$13$$$, $$$16$$$, and $$$21$$$.
",implementation,3
"import java.io.InputStreamReader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author vadimmm
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskD solver = new TaskD();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskD {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        long l = in.nextLong();
        long r = in.nextLong();
        /*
        long max = 1;
        boolean good = false;
        for (int i = 0; i < 62; ++i) {
            max <<= 1;
            if (max > r) {
                max >>= 1;
                if (max >= l) {
                    good = true;
                }
                break;
            }
        }
        if (good) {
            if (max - 1 >= l)
                out.println(max ^ (max - 1));
            else
                out.println(max ^ r);
            return;
        }
        */
        boolean[][] answer = new boolean[2][100];
        int cur = 0;
        while (r > 0) {
            answer[0][cur] = (r % 2 != 0);
            ++cur;
            r >>= 1;
        }
        cur = 0;
        while (l > 0) {
            answer[1][cur] = (l % 2 != 0);
            ++cur;
            l >>= 1;
        }
        int old = -1;
        for (int i = 63; i >= 0; --i) {
            if (answer[0][i] && !answer[1][i]) {
                old = i;
                break;
            }
        }
        if (old == -1) {
            out.println(0);
            return;
        }
        long a = 1;
        for (int i = 0; i < old; ++i) {
            a <<= 1;
            a += 1;
        }
        out.println(a);
    }
}

class InputReader {

    private static BufferedReader bufferedReader;
    private static StringTokenizer stringTokenizer;

    public InputReader(InputStream inputStream) {
        bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        stringTokenizer = null;
    }

    public String next() {
        while(stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {
            try {
                stringTokenizer = new StringTokenizer(bufferedReader.readLine());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return stringTokenizer.nextToken();
    }

    public long nextLong() {
        return Long.parseLong(next());
    }

    }

",0276_D,CODEFORCES,822,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import java.util.*;
import java.io.*;
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] arr = new int[n];
        HashMap<Integer, Integer> map = new HashMap<>();
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            int x = Integer.parseInt(st.nextToken());
            arr[i] = x;
            if (!map.containsKey(x)) {
                map.put(x, 1);
            } else {
                map.replace(x, map.get(x) + 1);
            }
        }
        int[] power = new int[31];
        for (int i = 0; i < 31; i++) {
            power[i] = 1 << i; // 0 100=4 1000=8 10000=16
        }
        int c = 0;
        for (int i = 0; i < n; i++) {
        boolean f = false;
        for (int j = 0; j <= 30; j++) {
        int check = power[j] - arr[i];
                if ((map.containsKey(check) && check != arr[i])) {
                f = true; break;}
                if((map.containsKey(check) && check == arr[i] && map.get(check) >=2)) {
                    f = true; break;
                }
            }
            if (!f) {
                c++;
            }
        }
        System.out.println(c);
    }
}",1005_C,CODEFORCES,2852,Summarize to the Power of Two,"A sequence $$$a_1, a_2, \dots, a_n$$$ is called good if, for each element $$$a_i$$$, there exists an element $$$a_j$$$ ($$$i \ne j$$$) such that $$$a_i+a_j$$$ is a power of two (that is, $$$2^d$$$ for some non-negative integer $$$d$$$).
For example, the following sequences are good:
Note that, by definition, an empty sequence (with a length of $$$0$$$) is good.
For example, the following sequences are not good:
You are given a sequence $$$a_1, a_2, \dots, a_n$$$. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements.
The first line contains the integer $$$n$$$ ($$$1 \le n \le 120000$$$) — the length of the given sequence.
The second line contains the sequence of integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
","input
Print the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all $$$n$$$ elements, make it empty, and thus get a good sequence.
output
In the first example, it is enough to delete one element $$$a_4=5$$$. The remaining elements form the sequence $$$[4, 7, 1, 4, 9]$$$, which is good.
","bruteforce, greedy, implementation",4
"
/**
 * @author: Mehul Raheja
 */
import java.util.*;
import java.io.*;

public class indent {

    /*
        Runtime = O()
     */
    static int N, M, K;
    static String s;
    static StringTokenizer st;
    static int[] d;

    static long MOD = (int)1e9 + 7;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        char[] d = new char[N];
        for (int i = 0; i < N; i++) {
            d[i] = br.readLine().charAt(0);
        }

        long[][] dp = new long[N][N];
        boolean det = d[0] == 'f';
        //Arrays.fill(dp[0], 1);
        dp[0][0] = 1;
        
        for (int i = 1; i < N; i++) {
           // System.out.println(Arrays.toString(dp[i-1]));
            long sum = 0;

            for (int j = 0; j < N; j++) {
                sum = (dp[i - 1][j]%MOD + sum%MOD + MOD) % MOD;
            }
            
           // System.out.println(sum);

            if (d[i] == 'f') {
                if(det){
                    for (int j = 1; j < N; j++) {
                        dp[i][j] = dp[i-1][j-1]%MOD;
                    }
                    continue;
                }
                
                for (int j = 0; j < N; j++) {
                    dp[i][j] = sum%MOD;
                    sum -= dp[i - 1][j]%MOD;

                }
                det = true;
                
                //System.out.println(Arrays.toString(dp[i]));
            } else if (d[i] == 's') {
               // System.out.println(""HERE1"" + det);
                
                if(det){
                    //System.out.println(""HERE2"");
                    det = false;
                    for (int j = 1; j < N; j++) {
                        dp[i][j] = dp[i-1][j-1]%MOD;
                    }
                   //System.out.println(""HERE "" + Arrays.toString(dp[i]));
                    continue;
                }
                
                //System.out.println(""HERE3"" + sum);
                for (int j = 0; j < N; j++) {
                    dp[i][j] = sum%MOD;

                    sum = ((sum - dp[i - 1][j])%MOD + MOD)%MOD;

                }
                
            }
            //System.out.println(Arrays.toString(dp[i]));
        }
        //System.out.println(Arrays.toString(dp[dp.length-1]));
        
        long ans = 0;
        for (long e: dp[dp.length-1]) {
            ans = (ans + e + MOD) % MOD;
        }
        System.out.println(ans);

//        boolean det = false;
//        int maxlayer = 1;
//        long ans = 1;
//        for (int i = 0; i < N; i++) {
//            if (d[i] == 'f') {
//                if (!det) {
//                    //System.out.println(""HERE"" + maxlayer);
//                    ans = ans * maxlayer;
//                }
//                det = true;
//                maxlayer++;
//                //System.out.println(""HERE"");
//            } else if (d[i] == 's') {
//                if (det) {
//                    det = false;
//                    continue;
//                }
//                det = false;
//                System.out.println(maxlayer);
//                ans = ans * maxlayer;
//            }
//        }
//
//        System.out.println(ans);
    }
}
",0909_C,CODEFORCES,3053,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"/**
 * BaZ :D
 */
import java.util.*;
import java.io.*;
import static java.lang.Math.*;

public class Main
{
    static MyScanner scan;
    static PrintWriter pw;
    static long MOD = 1_000_000_007;
    static long INF = 1_000_000_000_000_000_000L;
    static long inf = 2_000_000_000;
    public static void main(String[] args) {
        new Thread(null, null, ""BaZ"", 1 << 27) {
            public void run() {
                try {
                    solve();
                } catch (Exception e) {
                    e.printStackTrace();
                    System.exit(1);
                }
            }
        }.start();
    }
    static int n,m,need,a[][],dp[][][],real[][];
    static void solve() throws IOException
    {
        //initIo(true);
        initIo(false);
        StringBuilder sb = new StringBuilder();
        int t = ni();
        while(t-->0) {
            n = ni();
            m = ni();
            a = new int[n][m];
            for(int i=0;i<n;++i) {
                for(int j=0;j<m;++j) {
                    a[i][j] = ni();
                }
            }
            need = min(n,m);
            Pair max_in_cols[] = new Pair[m];
            for(int COL=0;COL<m;++COL) {
                int max = 0;
                for(int i=0;i<n;++i) {
                    max = max(max, a[i][COL]);
                }
                max_in_cols[COL] = new Pair(max, COL);
            }
            real = new int[n][need];
            Arrays.sort(max_in_cols);
            for(int i=0;i<need;++i) {
                int COL = max_in_cols[m-1-i].y;
                for(int j=0;j<n;++j) {
                    real[j][i] = a[j][COL];
                }
            }
//            pl(""need : ""+need);
//            pa(""Real"", real);
            dp = new int[need][n+1][(1<<n)];
            for(int i=0;i<need;++i) {
                for(int j=0;j<=n;++j) {
                    for(int k=0;k<(1<<n);++k) {
                        dp[i][j][k] = -1;
                    }
                }
            }
            pl(f(0, n, 0));
        }
        pw.flush();
        pw.close();
    }
    static int f(int idx, int bias, int mask) {
        //pl(""idx: ""+idx+"" bias : ""+bias + "" mask : ""+mask);
        if(idx==need) {
            return 0;
        }
        if(dp[idx][bias][mask]!=-1) {
            return dp[idx][bias][mask];
        }

        //didn't fix bias yet
        if(bias==n) {
            int max = 0;
            for(int b=0;b<n;++b) {
                max = max(max, f(idx, b, mask));
            }
            //pl(""maxxxxxxx : ""+max);
            dp[idx][bias][mask] = max;
            return max;
        }
        else {
            int max = f(idx+1, n, mask);
            for(int i=0;i<n;++i) {
                if((mask&(1<<i))==0) {
                    max = max(max, real[(i-bias+n)%n][idx] + f(idx, bias, mask | (1<<i)));
                }
            }
            //pl(""max : ""+max);
            dp[idx][bias][mask] = max;
            return max;
        }
    }
    static class Pair implements Comparable<Pair>
    {
        int x,y;
        Pair(int x,int y)
        {
            this.x=x;
            this.y=y;
        }
        public int compareTo(Pair other)
        {
            if(this.x!=other.x)
                return this.x-other.x;
            return this.y-other.y;
        }
        public String toString()
        {
            return ""(""+x+"",""+y+"")"";
        }
    }
    static void initIo(boolean isFileIO) throws IOException {
        scan = new MyScanner(isFileIO);
        if(isFileIO) {
            pw = new PrintWriter(""/Users/amandeep/Desktop/output.txt"");
        }
        else {
            pw = new PrintWriter(System.out, true);
        }
    }
    static int ni() throws IOException
    {
        return scan.nextInt();
    }
    static long nl() throws IOException
    {
        return scan.nextLong();
    }
    static double nd() throws IOException
    {
        return scan.nextDouble();
    }
    static String ne() throws IOException
    {
        return scan.next();
    }
    static String nel() throws IOException
    {
        return scan.nextLine();
    }
    static void pl()
    {
        pw.println();
    }
    static void p(Object o)
    {
        pw.print(o+"" "");
    }
    static void pl(Object o)
    {
        pw.println(o);
    }
    static void psb(StringBuilder sb)
    {
        pw.print(sb);
    }
    static void pa(String arrayName, Object arr[])
    {
        pl(arrayName+"" : "");
        for(Object o : arr)
            p(o);
        pl();
    }
    static void pa(String arrayName, int arr[])
    {
        pl(arrayName+"" : "");
        for(int o : arr)
            p(o);
        pl();
    }
    static void pa(String arrayName, long arr[])
    {
        pl(arrayName+"" : "");
        for(long o : arr)
            p(o);
        pl();
    }
    static void pa(String arrayName, double arr[])
    {
        pl(arrayName+"" : "");
        for(double o : arr)
            p(o);
        pl();
    }
    static void pa(String arrayName, char arr[])
    {
        pl(arrayName+"" : "");
        for(char o : arr)
            p(o);
        pl();
    }
    static void pa(String listName, List list)
    {
        pl(listName+"" : "");
        for(Object o : list)
            p(o);
        pl();
    }
    static void pa(String arrayName, Object[][] arr) {
        pl(arrayName+"" : "");
        for(int i=0;i<arr.length;++i) {
            for(Object o : arr[i])
                p(o);
            pl();
        }
    }
    static void pa(String arrayName, int[][] arr) {
        pl(arrayName+"" : "");
        for(int i=0;i<arr.length;++i) {
            for(int o : arr[i])
                p(o);
            pl();
        }
    }
    static void pa(String arrayName, long[][] arr) {
        pl(arrayName+"" : "");
        for(int i=0;i<arr.length;++i) {
            for(long o : arr[i])
                p(o);
            pl();
        }
    }
    static void pa(String arrayName, char[][] arr) {
        pl(arrayName+"" : "");
        for(int i=0;i<arr.length;++i) {
            for(char o : arr[i])
                p(o);
            pl();
        }
    }
    static void pa(String arrayName, double[][] arr) {
        pl(arrayName+"" : "");
        for(int i=0;i<arr.length;++i) {
            for(double o : arr[i])
                p(o);
            pl();
        }
    }
    static class MyScanner
    {
        BufferedReader br;
        StringTokenizer st;
        MyScanner(boolean readingFromFile) throws IOException
        {
            if(readingFromFile) {
                br = new BufferedReader(new FileReader(""/Users/amandeep/Desktop/input.txt""));
            }
            else {
                br = new BufferedReader(new InputStreamReader(System.in));
            }
        }
        String nextLine()throws IOException
        {
            return br.readLine();
        }
        String next() throws IOException
        {
            if(st==null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }
        int nextInt() throws IOException
        {
            return Integer.parseInt(next());
        }
        long nextLong() throws IOException
        {
            return Long.parseLong(next());
        }
        double nextDouble() throws IOException
        {
            return Double.parseDouble(next());
        }
    }
}",1209_E1,CODEFORCES,4781,Rotate Columns (easy version),"This is an easier version of the next problem. The difference is only in constraints.
You are given a rectangular $$$n \times m$$$ matrix $$$a$$$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want (possibly zero). You can perform this operation to a column multiple times.
After you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $$$i$$$-th row it is equal $$$r_i$$$. What is the maximal possible value of $$$r_1+r_2+\ldots+r_n$$$?
The first line contains an integer $$$t$$$ ($$$1 \le t \le 40$$$), the number of test cases in the input.
The first line of each test case contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 4$$$, $$$1 \le m \le 100$$$) — the number of rows and the number of columns in the given matrix $$$a$$$. 
Each of the following $$$n$$$ lines contains $$$m$$$ integers, the elements of $$$a$$$ ($$$1 \le a_{i, j} \le 10^5$$$).
Print $$$t$$$ integers: answers for all test cases in the order they are given in the input.
","input
In the first test case, you can shift the third column down by one, this way there will be $$$r_1 = 5$$$ and $$$r_2 = 7$$$.
output
In the second case you can don't rotate anything at all, this way there will be $$$r_1 = r_2 = 10$$$ and $$$r_3 = 9$$$.
","bitmasks, bruteforce, dp, greedy, sortings",7
"import static java.lang.Math.*;

import static java.util.Arrays.*;

import java.util.*;

import java.io.*;



public class Main {



	void solve() {

		int R = sc.nextInt();

		int C = sc.nextInt();

		int K = sc.nextInt();

		int[] x = new int[K];

		int[] y = new int[K];

		for (int i = 0; i < K; i++) {

			x[i] = sc.nextInt();

			y[i] = sc.nextInt();

		}



		int best = -1;

		int bestX = 0;

		int bestY = 0;



		for (int r = 1; r <= R; r++) for (int c = 1; c <= C; c++) {

			int here = R + C;

			for (int i = 0; i < K; i++) {

				int t = abs(r - x[i]) + abs(c - y[i]);

				here = min(here, t);

			}

			if (best < here){

				best = here;

				bestX = r;

				bestY = c;

			}

		}



		out.println(bestX + "" "" + bestY);

	}



	void print(int[] a) {

		out.print(a[0]);

		for (int i = 1; i < a.length; i++) out.print("" "" + a[i]);

		out.println();

	}



	static void tr(Object... os) {

		System.err.println(deepToString(os));

	}



	public static void main(String[] args) throws Exception {

		new Main().run();

	}



	MyScanner sc = null;

	PrintWriter out = null;

	public void run() throws Exception {

//		sc = new MyScanner(System.in);

//		out = new PrintWriter(System.out);

		sc = new MyScanner(new FileInputStream(new File(""input.txt"")));

		out = new PrintWriter(new File(""output.txt""));

		for (;sc.hasNext();) {

			solve();

			out.flush();

		}

		out.close();

	}



	class MyScanner {

		String line;

		BufferedReader reader;

		StringTokenizer tokenizer;



		public MyScanner(InputStream stream) {

			reader = new BufferedReader(new InputStreamReader(stream));

			tokenizer = null;

		}

		public void eat() {

			while (tokenizer == null || !tokenizer.hasMoreTokens()) {

				try {

					line = reader.readLine();

					if (line == null) {

						tokenizer = null;

						return;

					}

					tokenizer = new StringTokenizer(line);

				} catch (IOException e) {

					throw new RuntimeException(e);

				}

			}

		}

		public String next() {

			eat();

			return tokenizer.nextToken();

		}

		public String nextLine() {

			try {

				return reader.readLine();

			} catch (IOException e) {

				throw new RuntimeException(e);

			}

		}

		public boolean hasNext() {

			eat();

			return (tokenizer != null && tokenizer.hasMoreElements());

		}

		public int nextInt() {

			return Integer.parseInt(next());

		}

		public long nextLong() {

			return Long.parseLong(next());

		}

		public double nextDouble() {

			return Double.parseDouble(next());

		}

		public int[] nextIntArray(int n) {

			int[] a = new int[n];

			for (int i = 0; i < n; i++) a[i] = nextInt();

			return a;

		}

	}

}

",0035_C,CODEFORCES,3918,Fire Again,"After a terrifying forest fire in Berland a forest rebirth program was carried out. Due to it N rows with M trees each were planted and the rows were so neat that one could map it on a system of coordinates so that the j-th tree in the i-th row would have the coordinates of (i, j). However a terrible thing happened and the young forest caught fire. Now we must find the coordinates of the tree that will catch fire last to plan evacuation.
The burning began in K points simultaneously, which means that initially K trees started to burn. Every minute the fire gets from the burning trees to the ones that aren’t burning and that the distance from them to the nearest burning tree equals to 1.
Find the tree that will be the last to start burning. If there are several such trees, output any.
The first input line contains two integers N, M (1 ≤ N, M ≤ 2000) — the size of the forest. The trees were planted in all points of the (x, y) (1 ≤ x ≤ N, 1 ≤ y ≤ M) type, x and y are integers.
The second line contains an integer K (1 ≤ K ≤ 10) — amount of trees, burning in the beginning. 
","input
The third line contains K pairs of integers: x1, y1, x2, y2, ..., xk, yk (1 ≤ xi ≤ N, 1 ≤ yi ≤ M) — coordinates of the points from which the fire started. It is guaranteed that no two points coincide.
output
Output a line with two space-separated integers x and y — coordinates of the tree that will be the last one to start burning. If there are several such trees, output any.
","bruteforce, dfsandsimilar, shortestpaths",6
"//package com.example.programming;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Scanner;


public class CodeforcesProblems {


    static class Pair {
        public Pair(int key, int val) {
            this.key = key;
            this.val = val;
        }
        int key;
        int val;
    }


    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        //String[] strings = br.readLine().split("" "");
        int n = Integer.parseInt(br.readLine());

        String[] strings = br.readLine().split("" "");
        int[] arr = new int[n];
        for(int i = 0; i<n; i++) {
            arr[i] = Integer.parseInt(strings[i]);
        }


        HashMap<Integer, ArrayList<Pair>> segments = new HashMap<>();
        for(int r = 0; r<arr.length; r++) {
            int sum = 0;
            for(int l = r; l>=0; l--) {
                sum += arr[l];
                ArrayList<Pair> pairs = segments.get(sum);
                if(pairs == null) {
                    pairs = new ArrayList<>();
                    segments.put(sum, pairs);
                }
                pairs.add(new Pair(l, r));
            }
        }

        int res = 0;
        ArrayList<Pair> result = new ArrayList<>();
        for(ArrayList<Pair> pairs: segments.values()) {
            ArrayList<Pair> temp = new ArrayList<>();
            int count = 0;
            int r = -1;
            for(Pair p : pairs) {
                if(p.key>r) {
                    count++;
                    temp.add(p);
                    r = p.val;
                }
            }
            if(count>res) {
                res = count;
                result = temp;
            }
        }
        System.out.println(res);
        StringBuilder sb = new StringBuilder();
        for(Pair p : result){
            sb.append(p.key+1).append(' ').append(p.val+1).append('\n');
        }
        System.out.print(sb);
    }
}
",1141_F2,CODEFORCES,3407,Same Sum Blocks (Hard),"This problem is given in two editions, which differ exclusively in the constraints on the number $$$n$$$.
You are given an array of integers $$$a[1], a[2], \dots, a[n].$$$ A block is a sequence of contiguous (consecutive) elements $$$a[l], a[l+1], \dots, a[r]$$$ ($$$1 \le l \le r \le n$$$). Thus, a block is defined by a pair of indices $$$(l, r)$$$.
Find a set of blocks $$$(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$$$ such that:
Write a program to find such a set of blocks.
","input
The first line contains integer $$$n$$$ ($$$1 \le n \le 1500$$$) — the length of the given array. The second line contains the sequence of elements $$$a[1], a[2], \dots, a[n]$$$ ($$$-10^5 \le a_i \le 10^5$$$).
output
In the first line print the integer $$$k$$$ ($$$1 \le k \le n$$$). The following $$$k$$$ lines should contain blocks, one per line. In each line print a pair of indices $$$l_i, r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the bounds of the $$$i$$$-th block. You can print blocks in any order. If there are multiple answers, print any of them.
","datastructures, greedy",5
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;
import java.util.StringTokenizer;

public class CF {
	public static void main(String[] args) throws IOException {
		Scanner sc=new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
         int n=sc.nextInt();
         pw.print(n+n/2);
	pw.close();
	sc.close();
}
}",0084_A,CODEFORCES,64,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"import java.util.*;

public class Main {



	public static void main(String[] args) {

		Scanner kb = new Scanner(System.in);

		int n = kb.nextInt();

		while(n-->0){

			String s = kb.next();

			if(s.matches(""R[0-9]+C[0-9]+"")){

				String[] ss = s.replaceAll(""[R|C]"","" "").trim().split("" "");

				int c = new Integer(ss[1]);

				String ans = """";

				while(c > 0){

					c--;

					ans = (char)(c % 26 + 'A')+ans;

					c/=26;

				}

				System.out.println(ans+""""+ss[0]);

			}else{

				String c = s.replaceAll(""[0-9]"", """");

				String r = s.replaceAll(""[A-Z]"", """");

				int num = 0;

				for(int i = 0 ; i < c.length() ; i++){

					num = num * 26 +(c.charAt(i) - 'A'+1);

				}

				System.out.println(""R""+r+""C""+num);

			}

		}

		

	}

}

",0001_B,CODEFORCES,1461,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math",3
"import java.util.Scanner;
import java.util.ArrayList;
 import java.util.*;
public class Main {
    public static void main(String[] args) {
       
        Scanner sc = new Scanner(System.in);
        int ar[] = new int[26];
        int n = sc.nextInt(), k = sc.nextInt();
        String s = sc.next();
        for(char c : s.toCharArray()){
            int z = c - 'A';
            ar[z]++;
        }
        int m = n;
        for(int i = 0;i<k;i++){
            m = Math.min(m,ar[i]);
        }
        System.out.println(m*k);
       
        
        
        
    }
}
    


	 	 	  	  				   	  	 		   	  	",1038_A,CODEFORCES,2065,Equality,"You are given a string $$$s$$$ of length $$$n$$$, which consists only of the first $$$k$$$ letters of the Latin alphabet. All letters in string $$$s$$$ are uppercase.
A subsequence of string $$$s$$$ is a string that can be derived from $$$s$$$ by deleting some of its symbols without changing the order of the remaining symbols. For example, ""ADE"" and ""BD"" are subsequences of ""ABCDE"", but ""DEA"" is not.
A subsequence of $$$s$$$ called good if the number of occurences of each of the first $$$k$$$ letters of the alphabet is the same.
Find the length of the longest good subsequence of $$$s$$$. 
The first line of the input contains integers $$$n$$$ ($$$1\le n \le 10^5$$$) and $$$k$$$ ($$$1 \le k \le 26$$$).
The second line of the input contains the string $$$s$$$ of length $$$n$$$. String $$$s$$$ only contains uppercase letters from 'A' to the $$$k$$$-th letter of Latin alphabet.
Print the only integer — the length of the longest good subsequence of string $$$s$$$.
","input
In the first example, ""ACBCAB"" (""ACAABCCAB"") is one of the subsequences that has the same frequency of 'A', 'B' and 'C'. Subsequence ""CAB"" also has the same frequency of these letters, but doesn't have the maximum possible length.
output
In the second example, none of the subsequences can have 'D', hence the answer is $$$0$$$.
","implementation, strings",3
"import java.util.*;
import java.io.*;
public class ASimpleTask
{


	/************************ SOLUTION STARTS HERE ***********************/
	
	static long memo[][];
	static int graph[];
	static long hamiltonianPath(int mask , int u) {
	    if(memo[mask][u] != -1) 
	        return memo[mask][u];
	    else if(u == Integer.numberOfTrailingZeros(mask)) // according to our convention A simple path is not allowed to end at the lowest vertex
            return 0;
	    else {
			long sum = 0;
			for(int fromSet = mask ^ (1 << u);fromSet > 0; fromSet ^= Integer.lowestOneBit(fromSet)) {
				int v = Integer.numberOfTrailingZeros(fromSet);
				// System.out.printf(""mask = %s , u = %d , v = %d\n"" , Integer.toBinaryString(mask) , u , v);
				if((graph[u] & (1 << v)) != 0) 
					sum += hamiltonianPath(mask ^ (1 << u), v);
			}
			
			return /*memo[mask][u] = */sum;
		}
	}

	private static void solveBottomUp(FastScanner s1, PrintWriter out){

		int V = s1.nextInt();
		int E = s1.nextInt();
		graph = new int[V];
		long DP[][] = new long[1 << V][V];

		while(E-->0) {
			int u = s1.nextInt() - 1;
			int v = s1.nextInt() - 1;
			graph[u] |= (1 << v);
			graph[v] |= (1 << u);
		}

		for(int i=0;i<V;i++)
			DP[1 << i][i] = 1;

		for(int mask = 1 , end = 1 << V;mask < end;mask++) {
			for(int set = mask;Integer.bitCount(set) > 1;set ^= Integer.highestOneBit(set)) {
				int u = Integer.numberOfTrailingZeros(Integer.highestOneBit(set));
				for(int fromSet = mask ^ (1 << u);fromSet > 0; fromSet ^= Integer.lowestOneBit(fromSet)) {
					int v = Integer.numberOfTrailingZeros(fromSet);
					// System.out.printf(""mask = %s , u = %d , v = %d\n"" , Integer.toBinaryString(mask) , u , v);
					if((graph[u] & (1 << v)) != 0) 
						DP[mask][u] += DP[mask ^ (1 << u)][v];
					
				}
			}
		}

		long totalCycles = 0;
		for(int mask = 1 , end = 1 << V;mask < end;mask++) {
			if(Integer.bitCount(mask) >= 3) {
				int start = Integer.numberOfTrailingZeros(mask);
				for(int set = mask;Integer.bitCount(set) > 1;set ^= Integer.highestOneBit(set)) {
					int u = Integer.numberOfTrailingZeros(Integer.highestOneBit(set));
					if((graph[u] & (1 << start)) != 0)
						totalCycles += DP[mask][u];
				}
			}
		}

		totalCycles /= 2;
/*		for(long l[] : DP)
			out.println(Arrays.toString(l));*/
		out.println(totalCycles);
	}

	private static void solveTopDown(FastScanner s1, PrintWriter out){

		int V = s1.nextInt();
		int E = s1.nextInt();
		graph = new int[V];
		memo = new long[1 << V][V];
		
		for(long l[] : memo)
			Arrays.fill(l, -1);
		
		while(E-->0) {
			int u = s1.nextInt() - 1;
			int v = s1.nextInt() - 1;
			graph[u] |= (1 << v);
			graph[v] |= (1 << u);
		}

		for(int i=0;i<V;i++)
			memo[1 << i][i] = 1;
		
		long totalCycles = 0;
		for(int mask = 1 , end = 1 << V;mask < end;mask++) {
			if(Integer.bitCount(mask) >= 3) {
				int start = Integer.numberOfTrailingZeros(mask);
				for(int set = mask;Integer.bitCount(set) > 1;set ^= Integer.highestOneBit(set)) {
					int u = Integer.numberOfTrailingZeros(Integer.highestOneBit(set));
					if((graph[u] & (1 << start)) != 0)
						totalCycles += hamiltonianPath(mask, u);
				}
			}
		}
		totalCycles /= 2;
		
		out.println(totalCycles);
	}

	/************************ SOLUTION ENDS HERE ************************/





	/************************ TEMPLATE STARTS HERE *********************/

	public static void main(String []args) throws IOException {
		FastScanner in  = new FastScanner(System.in);
		PrintWriter out = 
				new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), false); 
		solveBottomUp(in, out);
		in.close();
		out.close();
	}    

	static class FastScanner{
		BufferedReader reader;
		StringTokenizer st;
		FastScanner(InputStream stream){reader=new BufferedReader(new InputStreamReader(stream));st=null;}	
		String next()
		{while(st == null || !st.hasMoreTokens()){try{String line = reader.readLine();if(line == null){return null;}		    
		st = new StringTokenizer(line);}catch (Exception e){throw new RuntimeException();}}return st.nextToken();}
		String nextLine()  {String s=null;try{s=reader.readLine();}catch(IOException e){e.printStackTrace();}return s;}	    	  	
		int    nextInt()   {return Integer.parseInt(next());}
		long   nextLong()  {return Long.parseLong(next());}		
		double nextDouble(){return Double.parseDouble(next());}
		char   nextChar()  {return next().charAt(0);}
		int[]  nextIntArray(int n)         {int[] a= new int[n];   int i=0;while(i<n){a[i++]=nextInt();}  return a;}
		long[] nextLongArray(int n)        {long[]a= new long[n];  int i=0;while(i<n){a[i++]=nextLong();} return a;}	
		int[]  nextIntArrayOneBased(int n) {int[] a= new int[n+1]; int i=1;while(i<=n){a[i++]=nextInt();} return a;}	    	
		long[] nextLongArrayOneBased(int n){long[]a= new long[n+1];int i=1;while(i<=n){a[i++]=nextLong();}return a;}	    	
		void   close(){try{reader.close();}catch(IOException e){e.printStackTrace();}}				
	}

	/************************ TEMPLATE ENDS HERE ************************/
}",0011_D,CODEFORCES,4434,A Simple Task,"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.
The first line of input contains two integers n and m (1 ≤ n ≤ 19, 0 ≤ m) – respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1 ≤ a, b ≤ n, a ≠ b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.
","input
Output the number of cycles in the given graph.
output
The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.
","bitmasks, dp, graphs",7
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Rustam Musin (PloadyFree@gmail.com)
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskE solver = new TaskE();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskE {
        int n;
        double k;
        boolean[][] g;

        public void solve(int testNumber, InputReader in, OutputWriter out) {
            n = in.readInt();
            k = in.readInt();

            g = new boolean[n][n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    g[i][j] = in.readInt() == 1;
                }
            }

            double answer = solve();
            out.printFormat(""%.20f"", answer);
        }

        private double solve() {
            int firstPartSize = g.length / 2;
            int secondPartSize = g.length - firstPartSize;

            int[] firstPart = findMaxCliqueSize(firstPartSize);

            int m1Full = (1 << firstPartSize) - 1;
            int maxCliqueSize = 1;
            for (int m = 0; m < 1 << secondPartSize; m++) {
                if (isClique(secondPartSize, m, firstPartSize)) {
                    int m1 = m1Full;
                    for (int j = 0; j < secondPartSize; j++) {
                        if (bit(m, j)) {
                            for (int i = 0; i < firstPartSize; i++) {
                                if (bit(m1, i) && !g[i][j + firstPartSize]) {
                                    m1 ^= 1 << i;
                                }
                            }
                        }
                    }
                    int firstCliqueSize = firstPart[m1];
                    int secondCliqueSize = Integer.bitCount(m);
                    int curCliqueSize = firstCliqueSize + secondCliqueSize;
                    if (curCliqueSize > maxCliqueSize) {
                        maxCliqueSize = curCliqueSize;
                    }
                }
            }

            return k * k * (maxCliqueSize - 1) / (2 * maxCliqueSize);
        }

        private int[] findMaxCliqueSize(int size) {
            int[] dp = new int[1 << size];
            for (int m = 1; m < 1 << size; m++) {
                if (isClique(size, m, 0)) {
                    dp[m] = Integer.bitCount(m);
                }
            }
            for (int m = 1; m < 1 << size; m++) {
                for (int i = 0; i < size; i++) {
                    if ((m >> i & 1) == 0) {
                        dp[m | (1 << i)] = Math.max(dp[m | (1 << i)], dp[m]);
                    }
                }
            }
            return dp;
        }

        private boolean isClique(int size, int m, int offset) {
            for (int i = 0; i < size; i++) {
                if (bit(m, i)) {
                    for (int j = i + 1; j < size; j++) {
                        if (bit(m, j) && !g[i + offset][j + offset]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        private boolean bit(int m, int b) {
            return (m >> b & 1) != 0;
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void printFormat(String format, Object... objects) {
            writer.printf(format, objects);
        }

        public void close() {
            writer.close();
        }

    }
}

",0839_E,CODEFORCES,4639,Mother of Dragons,"There are n castles in the Lannister's Kingdom and some walls connect two castles, no two castles are connected by more than one wall, no wall connects a castle to itself. 
Sir Jaime Lannister has discovered that Daenerys Targaryen is going to attack his kingdom soon. Therefore he wants to defend his kingdom. He has k liters of a strange liquid. He wants to distribute that liquid among the castles, so each castle may contain some liquid (possibly zero or non-integer number of liters). After that the stability of a wall is defined as follows: if the wall connects two castles a and b, and they contain x and y liters of that liquid, respectively, then the strength of that wall is x·y.
Your task is to print the maximum possible sum of stabilities of the walls that Sir Jaime Lannister can achieve.
The first line of the input contains two integers n and k (1 ≤ n ≤ 40, 1 ≤ k ≤ 1000).
Then n lines follows. The i-th of these lines contains n integers ai, 1, ai, 2, ..., ai, n (). If castles i and j are connected by a wall, then ai, j = 1. Otherwise it is equal to 0.
It is guaranteed that ai, j = aj, i and ai, i = 0 for all 1 ≤ i, j ≤ n.
Print the maximum possible sum of stabilities of the walls that Sir Jaime Lannister can achieve.
Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.
Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .
","input
In the first sample, we can assign 0.5, 0.5, 0 liters of liquid to castles 1, 2, 3, respectively, to get the maximum sum (0.25).
output
In the second sample, we can assign 1.0, 1.0, 1.0, 1.0 liters of liquid to castles 1, 2, 3, 4, respectively, to get the maximum sum (4.0)
","bruteforce, graphs, math, meet-in-the-middle",7
"import java.io.*;
import java.util.*;
public class Main {
    public static void main(String args[])
    {
        FastReader input=new FastReader();
        PrintWriter out=new PrintWriter(System.out);
        int T=1;
        while(T-->0)
        {
            int n=input.nextInt();
            int a=input.nextInt();
            int b=input.nextInt();
            if(a>1)
            {
                if(b>1)
                {
                    out.println(""NO"");
                }
                else
                {
                    if(n<a)
                    {
                        out.println(""NO"");
                    }
                    else
                    {
                        out.println(""YES"");
                        for(int i=1;i<=a-1;i++)
                        {
                            for(int j=0;j<n;j++)
                            {
                                out.print('0');
                            }
                            out.println();
                        }
                        for(int i=1;i<=n;i++)
                        {
                            if(i<=a)
                            {
                                out.print('0');
                            }
                            else
                            {
                                out.print('1');
                            }
                        }
                        out.println();
                        for(int i=a+1;i<=n;i++)
                        {
                            for(int j=1;j<=n;j++)
                            {
                                if(j==a)
                                {
                                    out.print('1');
                                }
                                else
                                {
                                    out.print('0');
                                }
                            }
                            out.println();
                        }
                    }
                }
            }
            else
            {
                if(b==1)
                {
                    if(n==1)
                    {
                        out.println(""YES"");
                        out.println('0');
                    }
                    else if(n<=3)
                    {
                        out.println(""NO"");
                    }
                    else
                    {
                        out.println(""YES"");
                        for(int i=1;i<=n;i++)
                        {
                            for(int j=1;j<=n;j++)
                            {
                                if(j==i-1 || j==i+1)
                                {
                                    out.print('1');
                                }
                                else
                                {
                                    out.print('0');
                                }
                            }
                            out.println();
                        }
                    }
                }
                else
                {
                    if(n<b)
                    {
                        out.println(""NO"");
                    }
                    else
                    {
                        out.println(""YES"");
                        char ch[][]=new char[n+1][n+1];
                        for(int i=1;i<=b-1;i++)
                        {
                            for(int j=1;j<=n;j++)
                            {
                                if(j==i)
                                {
                                    ch[i][j]='0';
                                    ch[j][i]='0';
                                }
                                else
                                {
                                    ch[i][j]='1';
                                    ch[j][i]='1';
                                }
                            }
                        }
                        for(int i=b;i<=n;i++)
                        {
                            for(int j=b;j<=n;j++)
                            {
                                ch[i][j]='0';
                            }
                        }
                        for(int i=1;i<=n;i++)
                        {
                            for(int j=1;j<=n;j++)
                            {
                                out.print(ch[i][j]);
                            }
                            out.println();
                        }
                    }
                }
            }
        }
        out.close();
    }
    static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;

        public FastReader()
        {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt()
        {
            return Integer.parseInt(next());
        }

        long nextLong()
        {

            return Long.parseLong(next());
        }

        double nextDouble()
        {

            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
}",0990_D,CODEFORCES,3271,Graph And Its Complement,"Given three numbers $$$n, a, b$$$. You need to find an adjacency matrix of such an undirected graph that the number of components in it is equal to $$$a$$$, and the number of components in its complement is $$$b$$$. The matrix must be symmetric, and all digits on the main diagonal must be zeroes.
In an undirected graph loops (edges from a vertex to itself) are not allowed. It can be at most one edge between a pair of vertices.
The adjacency matrix of an undirected graph is a square matrix of size $$$n$$$ consisting only of ""0"" and ""1"", where $$$n$$$ is the number of vertices of the graph and the $$$i$$$-th row and the $$$i$$$-th column correspond to the $$$i$$$-th vertex of the graph. The cell $$$(i,j)$$$ of the adjacency matrix contains $$$1$$$ if and only if the $$$i$$$-th and $$$j$$$-th vertices in the graph are connected by an edge.
A connected component is a set of vertices $$$X$$$ such that for every two vertices from this set there exists at least one path in the graph connecting this pair of vertices, but adding any other vertex to $$$X$$$ violates this rule.
The complement or inverse of a graph $$$G$$$ is a graph $$$H$$$ on the same vertices such that two distinct vertices of $$$H$$$ are adjacent if and only if they are not adjacent in $$$G$$$.
In a single line, three numbers are given $$$n, a, b \,(1 \le n \le 1000, 1 \le a, b \le n)$$$: is the number of vertexes of the graph, the required number of connectivity components in it, and the required amount of the connectivity component in it's complement. 
If there is no graph that satisfies these constraints on a single line, print ""NO"" (without quotes).
","input
Otherwise, on the first line, print ""YES""(without quotes). In each of the next $$$n$$$ lines, output $$$n$$$ digits such that $$$j$$$-th digit of $$$i$$$-th line must be $$$1$$$ if and only if there is an edge between vertices $$$i$$$ and $$$j$$$ in $$$G$$$ (and $$$0$$$ otherwise). Note that the matrix must be symmetric, and all digits on the main diagonal must be zeroes. 
output
If there are several matrices that satisfy the conditions — output any of them.
","constructivealgorithms, graphs, implementation",5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Solver {

    StringTokenizer st;
    BufferedReader in;
    PrintWriter out;

    public static void main(String[] args) throws NumberFormatException, IOException {
        Solver solver = new Solver();
        solver.open();
        solver.solve();
        solver.close();
    }

    public void open() throws IOException {
        in = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);
    }

    public String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(in.readLine());
        }
        return st.nextToken();
    }

    public int nextInt() throws NumberFormatException, IOException {
        return Integer.parseInt(nextToken());
    }

    public long nextLong() throws NumberFormatException, IOException {
        return Long.parseLong(nextToken());
    }

    public double nextDouble() throws NumberFormatException, IOException {
        return Double.parseDouble(nextToken());
    }

    public class result implements Comparable{
        public int t = 0;
        public int p = 0;
        
        public result(int p,int t){
            this.t = t;
            this.p = p;
        }

        @Override
        public int compareTo(Object o) {
            result r = (result)o;
            int out = r.p-p;
            if (out==0) out = t-r.t;
            return out;
        }
        
        
    }
    
    public void solve() throws NumberFormatException, IOException {
        int n = nextInt();
        int k = nextInt();
        
        result[] table = new result[n];
        
        for (int i=0;i<n;i++){
            int p = nextInt();
            int t = nextInt();
            
            table[i] = new result(p,t);
        }
        
        Arrays.sort(table);
        
        int result = 1;
        k--;
        
        for (int i=k-1;i>=0 && table[i].p==table[k].p && table[i].t==table[k].t;i--){
            result++;
        }
        for (int i=k+1;i<n && table[i].p==table[k].p && table[i].t==table[k].t;i++){
            result++;
        }
        out.println(result);
    }

    public void close() {
        out.flush();
        out.close();
    }

}",0166_A,CODEFORCES,2533,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String input = in.nextLine();
        if (input.equals(""1""))
            System.out.println(""NO"");
        else {
            if (checkNum(input))
                System.out.println(""YES"");
            else {
                int i = 2;
                while (i < Integer.parseInt(input)) {
                    if (checkNum(i + """")) {
                        if (Integer.parseInt(input) % i != 0)
                            i++;
                        else
                            break;
                    } else
                        i++;
                }
                if (i == Integer.parseInt(input))
                    System.out.println(""NO"");
                else
                    System.out.println(""YES"");
            }
        }
    }

    public static boolean checkNum(String s) {
        int i = 0;
        int flag = 0;
        while (i < s.length()) {
            if (s.charAt(i) == '4' || s.charAt(i) == '7') {
                flag = 1;
                i++;
            } else
                return false;
        }
        if (flag == 1)
            return true;
        return false;
    }
}
",0122_A,CODEFORCES,105,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory",1
"import java.util.*;
import java.io.*;

public class E
{
	public static void main(String[] args) throws IOException
	{new E();}
	
	FastScanner in = new FastScanner(System.in);
	PrintWriter out = new PrintWriter(System.out);
	
	int n, m, oo = 1 << 28;
	int[] dp, cost;
	int[][] to;
	char[] w;
	
	E() throws IOException
	{
		n = in.nextInt();
		m = in.nextInt();
		w = in.next().toCharArray();
		to = new int[m+1][m+1];
		for (int i = 0; i < n-1; i++)
			if (w[i] != w[i+1])
			{
				to[w[i]-'a'][w[i+1]-'a']++;
				to[w[i+1]-'a'][w[i]-'a']++;
			}

		cost = new int[1 << m];	
		for (int i = 0; i < (1 << m); i++)
			for (int j = 0; j < m; j++)
			{
				if (((1 << j) & i) > 0)
					continue;
				for (int k = 0; k < m; k++)
				{
					if (((1 << k) & i) == 0)
						continue;
					cost[i] += to[j][k];
				}
			}
		
		dp = new int[1 << m];
		Arrays.fill(dp, oo);
		dp[0] = 0;
		for (int i = 1; i < (1 << m); i++)
		{
			for (int j = 0; j < m; j++)
				if (((i >> j) & 1) > 0)
					dp[i] = Math.min(dp[i], dp[i ^ (1 << j)]);
			dp[i] += cost[i];
		}
		out.println(dp[(1 << m)-1]);
		out.close();	
	}
	
	void sort(int[] x)
	{
		int sz = x.length;
		Random r = new Random();
		for (int i = 0; i < sz; i++)
		{
			int j = r.nextInt(sz);
			x[i] = x[j]-(x[i]-(x[j] = x[i]));
		}
		Arrays.sort(x);
	}
	
	class FastScanner {
		BufferedReader br;
		StringTokenizer st;
		public FastScanner(InputStream i) {
		    br = new BufferedReader(new InputStreamReader(i));
		    st = new StringTokenizer("""");
		}		
		public String next() throws IOException {
		    if(st.hasMoreTokens())
		        return st.nextToken();
		    else
		        st = new StringTokenizer(br.readLine());
		    return next();
		}
		public int nextInt() throws IOException {
		    return Integer.parseInt(next());
		}
		public int[] intarr(int n) throws IOException {
			int[] res = new int[n];
			for (int i = 0; i < n; i++)
				res[i] = nextInt();
			return res;
		}
	    public long nextLong() throws IOException {
		    return Long.parseLong(next());
		}
		public double nextDouble() throws IOException {
		    return Double.parseDouble(next());
		}
    }
}",1238_E,CODEFORCES,4846,Keyboard Purchase,"You have a password which you often type — a string $$$s$$$ of length $$$n$$$. Every character of this string is one of the first $$$m$$$ lowercase Latin letters.
Since you spend a lot of time typing it, you want to buy a new keyboard.
A keyboard is a permutation of the first $$$m$$$ Latin letters. For example, if $$$m = 3$$$, then there are six possible keyboards: abc, acb, bac, bca, cab and cba.
Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character $$$s_i$$$ to character $$$s_{i+1}$$$ is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the slowness of this keyboard.
More formaly, the slowness of keyboard is equal to $$$\sum\limits_{i=2}^{n} |pos_{s_{i-1}} - pos_{s_i} |$$$, where $$$pos_x$$$ is position of letter $$$x$$$ in keyboard.
For example, if $$$s$$$ is aacabc and the keyboard is bac, then the total time of typing this password is $$$|pos_a - pos_a| + |pos_a - pos_c| + |pos_c - pos_a| + |pos_a - pos_b| + |pos_b - pos_c|$$$ = $$$|2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3|$$$ = $$$0 + 1 + 1 + 1 + 2 = 5$$$.
Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. 
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 1 \le m \le 20$$$).
The second line contains the string $$$s$$$ consisting of $$$n$$$ characters. Each character is one of the first $$$m$$$ Latin letters (lowercase).
Print one integer – the minimum slowness a keyboard can have.
The first test case is considered in the statement.
","input
In the second test case the slowness of any keyboard is $$$0$$$.
output
In the third test case one of the most suitable keyboards is bacd.
","bitmasks, dp",7
"import java.io.*;
import java.util.*;

public class Main implements Runnable {

	public void _main() throws IOException {
		long a = nextLong();
		long b = nextLong();
		long res = 0;
		while (b > 0) {
			res += a / b;
			long t = a % b;
			a = b;
			b = t;
		}
		out.println(res);
	}


	private BufferedReader in;
	private PrintWriter out;
	private StringTokenizer st;

	private String next() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			String rl = in.readLine();
			if (rl == null)
				return null;
			st = new StringTokenizer(rl);
		}
		return st.nextToken();
	}

	private int nextInt() throws IOException {
		return Integer.parseInt(next());
	}

	private long nextLong() throws IOException {
		return Long.parseLong(next());
	}

	private double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}

	public static void main(String[] args) {
		Locale.setDefault(Locale.UK);
		new Thread(new Main()).start();
	}

	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			//in = new BufferedReader(new FileReader(""a.in""));
			//out = new PrintWriter(new FileWriter(""a.out""));

			_main();

			out.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(202);
		}
	}

}
",0343_A,CODEFORCES,389,Rational Resistance,"Mad scientist Mike is building a time machine in his spare time. To finish the work, he needs a resistor with a certain resistance value.
However, all Mike has is lots of identical resistors with unit resistance R0 = 1. Elements with other resistance can be constructed from these resistors. In this problem, we will consider the following as elements: 
With the consecutive connection the resistance of the new element equals R = Re + R0. With the parallel connection the resistance of the new element equals . In this case Re equals the resistance of the element being connected.
Mike needs to assemble an element with a resistance equal to the fraction . Determine the smallest possible number of resistors he needs to make such an element.
The single input line contains two space-separated integers a and b (1 ≤ a, b ≤ 1018). It is guaranteed that the fraction  is irreducible. It is guaranteed that a solution always exists.
Print a single number — the answer to the problem.
Please do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.
","input
In the first sample, one resistor is enough.
output
In the second sample one can connect the resistors in parallel, take the resulting element and connect it to a third resistor consecutively. Then, we get an element with resistance . We cannot make this element using two resistors.
","math, numbertheory",1
"import java.io.*;

import java.util.Scanner;



public class balls{

	public static void main(String args[]){

		Scanner sc=new Scanner(System.in);

		int a,b,d,i,j,k,x,y,z,t,c=0;

		long m1,m2;

		a=sc.nextInt();

		b=sc.nextInt();

		x=sc.nextInt();

		y=sc.nextInt();

		z=sc.nextInt();

		m1=2l*x+y;

		m2=y+3l*z;

		m1=m1-a;

		m2=m2-b;

		if(m1>0 && m2>0)

			System.out.println(m1+m2);

		else if(m1>0)

			System.out.println(m1);

		else if(m2>0)

			System.out.println(m2);

		else

			System.out.println(""0"");

	}

}		",0912_A,CODEFORCES,574,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation,1
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.IOException;
import java.util.StringTokenizer;
/*
 * @author Tnascimento 
 */

public class MaeDosDragoes {
	public static PrintWriter saida = new PrintWriter(System.out, false);
	public static class Escanear {
        BufferedReader reader;
        StringTokenizer tokenizer;
		public Escanear() {
            this(new InputStreamReader(System.in));
        }
		public Escanear(Reader in) {
            reader = new BufferedReader(in);
        }
        String proximo() {
            if (tokenizer == null || !tokenizer.hasMoreElements()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return tokenizer.nextToken();
        }
        
        int proximoNum() {
            return Integer.parseInt(proximo());
        }
    }



    public static void main(String[] args) {
		Escanear escanear = new Escanear();
        int proximoInt = escanear.proximoNum();
        double proximoDouble = escanear.proximoNum();
        long[] aux = new long[proximoInt];
        for(Integer i = 0; i < proximoInt; i++) {
            for(Integer j =0; j < proximoInt; j++) {
                Integer val = escanear.proximoNum();
                if (val.equals(1) || i.equals(j)) {
				 aux[i] |= 1L << j;
				}
            }
        }

        int esquerda = proximoInt/2;
        int direita = proximoInt - esquerda;

        int[] depois = new int[1 << esquerda];
        int maiorMascara = 1 << esquerda;

        for(int mascara = 1; mascara <maiorMascara; mascara++) {
            int mascaraAtual = mascara;

            for(int j = 0; j < esquerda; j++) {
                if (((1 << j) & mascara) > 0) {
                    mascaraAtual &= aux[j + direita] >> direita;
                    depois[mascara] = Math.max(depois[mascara], depois[mascara ^ (1 << j)]);
                }
            }
            if (mascara == mascaraAtual) {
                depois[mascara] = Math.max(depois[mascara],Integer.bitCount(mascara));
            }
        }
        int auxiliar = 0;
        int mascaraMaxima = 1 << direita;
        for(int mascara = 0; mascara < mascaraMaxima; mascara++) {
            int mascaraCorrente = mascara;
            int mascaraValor = maiorMascara -1;
            for(int j = 0; j < direita; j++) {
                if (((1 << j) & mascara) > 0) {
                    mascaraCorrente &= (aux[j] & (mascaraMaxima-1));
                    mascaraValor &= aux[j] >> direita;
                }
            }
            if (mascaraCorrente != mascara) continue;
            auxiliar = Math.max(auxiliar, Integer.bitCount(mascara) + depois[mascaraValor]);
        }
        proximoDouble/=auxiliar;
        saida.println(proximoDouble * proximoDouble * (auxiliar * (auxiliar-1))/2);
        saida.flush();
    }
}
",0839_E,CODEFORCES,4640,Mother of Dragons,"There are n castles in the Lannister's Kingdom and some walls connect two castles, no two castles are connected by more than one wall, no wall connects a castle to itself. 
Sir Jaime Lannister has discovered that Daenerys Targaryen is going to attack his kingdom soon. Therefore he wants to defend his kingdom. He has k liters of a strange liquid. He wants to distribute that liquid among the castles, so each castle may contain some liquid (possibly zero or non-integer number of liters). After that the stability of a wall is defined as follows: if the wall connects two castles a and b, and they contain x and y liters of that liquid, respectively, then the strength of that wall is x·y.
Your task is to print the maximum possible sum of stabilities of the walls that Sir Jaime Lannister can achieve.
The first line of the input contains two integers n and k (1 ≤ n ≤ 40, 1 ≤ k ≤ 1000).
Then n lines follows. The i-th of these lines contains n integers ai, 1, ai, 2, ..., ai, n (). If castles i and j are connected by a wall, then ai, j = 1. Otherwise it is equal to 0.
It is guaranteed that ai, j = aj, i and ai, i = 0 for all 1 ≤ i, j ≤ n.
Print the maximum possible sum of stabilities of the walls that Sir Jaime Lannister can achieve.
Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.
Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .
","input
In the first sample, we can assign 0.5, 0.5, 0 liters of liquid to castles 1, 2, 3, respectively, to get the maximum sum (0.25).
output
In the second sample, we can assign 1.0, 1.0, 1.0, 1.0 liters of liquid to castles 1, 2, 3, 4, respectively, to get the maximum sum (4.0)
","bruteforce, graphs, math, meet-in-the-middle",7
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
 
/**
 *
 * @author xpeng
 */
import java.util.*;
import java.io.*;
 
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
 
public class Main {
 
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    static StringTokenizer st;
    public static void main(String[] args) throws IOException {
        int t = readInt();
        for (int i = 0; i < t; i++) {
            int n = readInt();
            Stack<Integer> arr = new Stack();//levels
            for (int j = 0; j < n; j++) {
                int num = readInt();
                if (j==0) {
                    arr.add(1);
                    System.out.println(""1"");
                    continue;
                }
                if (num==1) {
                    arr.add(1);
                    String out = """";
                    for (int k = 0; k < arr.size(); k++) {
                        if (k==arr.size()-1) {
                            out+=""1"";
                            break;
                        }
                        out+=arr.get(k)+""."";
                    }
                    System.out.println(out);
                }else{
                    for (int k = arr.size()-1; k >=0; k--) {
                        if (Integer.parseInt(arr.pop()+"""")+1==num) {
                            arr.add(num);
                            break;
                        }
                    }
                    for (int k = 0; k < arr.size(); k++) {
                        if (k==arr.size()-1) {
                            System.out.println(arr.get(k));
                        }else{
                            System.out.print(arr.get(k)+""."");
                        }
                    }
                }
            }
        }
    
    }
    
    static String next() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(br.readLine().trim());
        }
        return st.nextToken();
    }
 
    static long readLong() throws IOException {
        return Long.parseLong(next());
    }
 
    static int readInt() throws IOException {
        return Integer.parseInt(next());
    }
 
    static double readDouble() throws IOException {
        return Double.parseDouble(next());
    }
 
    static char readCharacter() throws IOException {
        return next().charAt(0);
    }
 
    static String readLine() throws IOException {
        return br.readLine().trim();
    }
}
",1523_C,CODEFORCES,3683,Compression and Expansion,"William is a huge fan of planning ahead. That is why he starts his morning routine by creating a nested list of upcoming errands.
A valid nested list is any list which can be created from a list with one item ""1"" by applying some operations. Each operation inserts a new item into the list, on a new line, just after one of existing items $$$a_1 \,.\, a_2 \,.\, a_3 \,.\, \,\cdots\, \,.\,a_k$$$ and can be one of two types: 
When William decided to save a Word document with the list of his errands he accidentally hit a completely different keyboard shortcut from the ""Ctrl-S"" he wanted to hit. It's not known exactly what shortcut he pressed but after triggering it all items in the list were replaced by a single number: the last number originally written in the item number.
William wants you to help him restore a fitting original nested list.
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10$$$). Description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^3$$$), which is the number of lines in the list.
Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ ($$$1 \le a_i \le n$$$), which is what remains of William's nested list.
It is guaranteed that in each test case at least one fitting list exists.
It is guaranteed that the sum of values $$$n$$$ across all test cases does not exceed $$$10^3$$$.
For each test case output $$$n$$$ lines which represent a valid nested list, which could become the data provided to you by William.
If there are multiple answers, print any.
In the second example test case one example of a fitting list is:
1
1.1 
1.1.1
1.1.2
1.2
1.2.1
2
2.1
","input
2.2
output
This list can be produced by using the sequence of operations shown below:  
","bruteforce, datastructures, greedy, implementation, trees",5
"import java.util.*;
import java.io.*;
import java.lang.*;
import java.math.*;
public class A {
    public static void main(String[] args) throws Exception {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        // Scanner scan = new Scanner(System.in);
        // PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        // int n = Integer.parseInt(bf.readLine());
        StringTokenizer st = new StringTokenizer(bf.readLine());
        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());
        int n = Integer.parseInt(st.nextToken());
        int d = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(bf.readLine());
        int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());
        int ans = 2;
        for(int i=0; i<n-1; i++) {
          int diff = a[i+1]-a[i];
          if(diff == 2*d) ans++;
          else if(diff > 2*d) ans += 2;

        }
        System.out.println(ans);
        // int n = scan.nextInt();

        // out.close(); System.exit(0);
    }
}
",1004_A,CODEFORCES,1965,Sonya and Hotels,"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.
The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $$$n$$$ hotels, where the $$$i$$$-th hotel is located in the city with coordinate $$$x_i$$$. Sonya is a smart girl, so she does not open two or more hotels in the same city.
Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $$$d$$$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 
Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $$$n$$$ hotels to the new one is equal to $$$d$$$.
The first line contains two integers $$$n$$$ and $$$d$$$ ($$$1\leq n\leq 100$$$, $$$1\leq d\leq 10^9$$$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.
The second line contains $$$n$$$ different integers in strictly increasing order $$$x_1, x_2, \ldots, x_n$$$ ($$$-10^9\leq x_i\leq 10^9$$$) — coordinates of Sonya's hotels.
Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $$$d$$$.
","input
In the first example, there are $$$6$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$-6$$$, $$$5$$$, $$$6$$$, $$$12$$$, $$$13$$$, and $$$19$$$.
output
In the second example, there are $$$5$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$2$$$, $$$6$$$, $$$13$$$, $$$16$$$, and $$$21$$$.
",implementation,3
"import java.util.*;

public class inversioncounting {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] permutation = new int[n];
		for (int i = 0; i < n; i++) {
			permutation[i] = sc.nextInt();
		}
		int m = sc.nextInt();
		int[][] reverse = new int[m][2];
		for (int i = 0; i < m; i++) {
			reverse[i][0] = sc.nextInt();
			reverse[i][1] = sc.nextInt();
		}
		int counter = 0;
		for (int i = 0; i < n - 1; i++) {
			for (int j = i + 1; j < n; j++) {
				if (permutation[i] > permutation[j]) {
					counter++;
				}
			}
		}
		boolean bayus = true;
		if (counter % 2 == 1) {
			bayus = false;
		}
		for (int i = 0; i < m; i++) {
			int bobib = reverse[i][1] - reverse[i][0] + 1;
			int bafry = nChoose2(bobib);
			if (bafry%2 == 1) {
				bayus = !bayus;
			}
			if (bayus) {
				System.out.println(""even"");
			}
			else {
				System.out.println(""odd"");
			}
		}

	}
	private static int nChoose2 (int n) {
		return (n * (n-1)) / 2;
	}

}
",0911_D,CODEFORCES,3201,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author unknown
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        APaintTheNumbers solver = new APaintTheNumbers();
        solver.solve(1, in, out);
        out.close();
    }

    static class APaintTheNumbers {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.i();
            int[] a = in.ia(n);
            RadixSort.radixSort(a);
            boolean[] flag = new boolean[n];
            int count = 0;
            for (int i = 0; i < n; i++) {
                if (!flag[i]) {
                    ++count;
                    flag[i] = true;
                    for (int j = 0; j < n; j++) {
                        if (!flag[j] && a[j] % a[i] == 0) {
                            flag[j] = true;
                        }
                    }
                }
            }
            out.printLine(count);
        }

    }

    static class RadixSort {
        public static int[] radixSort(int[] f) {
            return radixSort(f, f.length);
        }

        public static int[] radixSort(int[] f, int n) {
            // credits uwi
            int[] to = new int[n];
            {
                int[] b = new int[65537];
                for (int i = 0; i < n; i++) b[1 + (int) (f[i] & 0xffff)]++;
                for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];
                for (int i = 0; i < n; i++) to[b[(int) (f[i] & 0xffff)]++] = f[i];
                int[] d = f;
                f = to;
                to = d;
            }
            {
                int[] b = new int[65537];
                for (int i = 0; i < n; i++) b[1 + (int) (f[i] >>> 16 & 0xffff)]++;
                for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];
                for (int i = 0; i < n; i++) to[b[(int) (f[i] >>> 16 & 0xffff)]++] = f[i];
                int[] d = f;
                f = to;
                to = d;
            }
            return f;
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void printLine(int i) {
            writer.println(i);
        }

    }

    static class InputReader {
        private InputStream is;
        private byte[] inbuf = new byte[1024];
        private int lenbuf = 0;
        private int ptrbuf = 0;

        public InputReader(InputStream is) {
            this.is = is;
        }

        private int readByte() {
            if (lenbuf == -1) throw new InputMismatchException();
            if (ptrbuf >= lenbuf) {
                ptrbuf = 0;
                try {
                    lenbuf = is.read(inbuf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (lenbuf <= 0) return -1;
            }
            return inbuf[ptrbuf++];
        }

        public int[] ia(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = i();
            return a;
        }

        public int i() {
            int num = 0, b;
            boolean minus = false;
            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;
            if (b == '-') {
                minus = true;
                b = readByte();
            }

            while (true) {
                if (b >= '0' && b <= '9') {
                    num = num * 10 + (b - '0');
                } else {
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }

    }
}

",1209_A,CODEFORCES,3486,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
