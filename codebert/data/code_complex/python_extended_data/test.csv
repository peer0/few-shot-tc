content,problem,from,idx,problem_title,problem_description,input_output_specification,tags,label
"import sys
import math


def readlines(type=int):
    return list(map(type, sys.stdin.readline().split()))


def read(type=int):
    return type(sys.stdin.readline().strip())


joint = lambda it, sep="" "": sep.join(
    [str(i) if type(i) != list else sep.join(map(str, i)) for i in it])


def solve_naive(n, k):
    taken = set()
    current_cap = 0
    found = False
    while current_cap != n:
        for c in range(k, 1, -1):
            found = False
            if current_cap == 0:
                if c <= n:
                    current_cap += c
                    taken.add(c)
                    found = True
                    break
            else:
                if c not in taken and c - 1 <= n - current_cap:
                    current_cap += c - 1
                    taken.add(c)
                    found = True
                    break
        if not found:
            break
    return len(taken) if found else -1


def solve(n, k):
    if n == 1:
        return 0
    if k >= n:
        return 1
    else:
        if (3 - 2 * k) ** 2 - 8 * (n - k) < 0:
            return -1
        t = (-math.sqrt((3 - 2 * k) ** 2 - 8 * (n - k)) + (2 * k) - 3) / 2
        if t == 0.0:
            return 2
        if t % 1 == 0:
            return 1 + int(t)
        else:
            # print(f""{t=}"")
            return 2 + int(t)


def main():
    n, k = readlines()
    print(solve(n, k))


if __name__ == ""__main__"":
    main()
",0287_B,CODEFORCES,936,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import math

n=int(input())
k=1
while(n > 9*k*(10**(k-1))):
    n = n - 9*k*(10**(k-1))
    k = k + 1
remainder = n%k
if remainder == 0:
    remainder = k
if k==1:
    quoteint = math.ceil(n/k)
else:
    adder = ""9""*(k-1)
    adder = int(adder)
    quoteint = math.ceil(n/k) + adder
print(str(quoteint)[remainder-1])




    
    
    
        
        
        
    

        
        
        
        
        
        
    


                        
                        
                    
        
 
        
  
    
    
                
                
                
            
            
     
                
    
            
            
        
    
  


    
   
        

  
            
  
    
    
    



            
            
            
    
    
            
   
    

    

            
            
    
    

    
    

        


    

    
    
    









            
            
        
        
        
        
    
        ",1177_B,CODEFORCES,1240,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"n, pos, a, b = map(int,input().split())

lf, rf = a - 1, n - b
if lf == rf == 0:
	print(""0"")
elif lf == 0:
	print(abs(pos-b)+1)
elif rf == 0:
	print(abs(pos-a)+1)
else:
	cl = abs(a-pos) + 1
	cr = abs(b-pos) + 1
	xn = abs(a-b) + 1
	if cl < cr:
		print(cl+xn)
	else:
		print(cr+xn)",0915_B,CODEFORCES,252,Browser,"Luba is surfing the Internet. She currently has n opened tabs in her browser, indexed from 1 to n from left to right. The mouse cursor is currently located at the pos-th tab. Luba needs to use the tabs with indices from l to r (inclusive) for her studies, and she wants to close all the tabs that don't belong to this segment as fast as possible.
Each second Luba can either try moving the cursor to the left or to the right (if the cursor is currently at the tab i, then she can move it to the tab max(i - 1, a) or to the tab min(i + 1, b)) or try closing all the tabs to the left or to the right of the cursor (if the cursor is currently at the tab i, she can close all the tabs with indices from segment [a, i - 1] or from segment [i + 1, b]). In the aforementioned expressions a and b denote the minimum and maximum index of an unclosed tab, respectively. For example, if there were 7 tabs initially and tabs 1, 2 and 7 are closed, then a = 3, b = 6.
What is the minimum number of seconds Luba has to spend in order to leave only the tabs with initial indices from l to r inclusive opened?
The only line of input contains four integer numbers n, pos, l, r (1 ≤ n ≤ 100, 1 ≤ pos ≤ n, 1 ≤ l ≤ r ≤ n) — the number of the tabs, the cursor position and the segment which Luba needs to leave opened.
Print one integer equal to the minimum number of seconds required to close all the tabs outside the segment [l, r].
In the first test Luba can do the following operations: shift the mouse cursor to the tab 2, close all the tabs to the left of it, shift the mouse cursor to the tab 3, then to the tab 4, and then close all the tabs to the right of it.
","input
In the second test she only needs to close all the tabs to the right of the current position of the cursor.
output
In the third test Luba doesn't need to do anything.
",implementation,1
"q=int(input())

for e in range(q):
    x,y,k=map(int,input().split())
    x,y=abs(x),abs(y)
    x,y=max(x,y),min(x,y)
    
    if(x%2!=k%2):
        k-=1
        y-=1
    
    
    if(x>k):
        print(-1)
        continue
    if((x-y)%2):
        k-=1
        x-=1
    print(k)
    
    
    
    ",1036_B,CODEFORCES,474,Diagonal Walking v,"Mikhail walks on a Cartesian plane. He starts at the point $$$(0, 0)$$$, and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $$$(0, 0)$$$, he can go to any of the following points in one move: 
If Mikhail goes from the point $$$(x1, y1)$$$ to the point $$$(x2, y2)$$$ in one move, and $$$x1 \ne x2$$$ and $$$y1 \ne y2$$$, then such a move is called a diagonal move.
Mikhail has $$$q$$$ queries. For the $$$i$$$-th query Mikhail's target is to go to the point $$$(n_i, m_i)$$$ from the point $$$(0, 0)$$$ in exactly $$$k_i$$$ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in $$$k_i$$$ moves.
Note that Mikhail can visit any point any number of times (even the destination point!).
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 10^4$$$) — the number of queries.
Then $$$q$$$ lines follow. The $$$i$$$-th of these $$$q$$$ lines contains three integers $$$n_i$$$, $$$m_i$$$ and $$$k_i$$$ ($$$1 \le n_i, m_i, k_i \le 10^{18}$$$) — $$$x$$$-coordinate of the destination point of the query, $$$y$$$-coordinate of the destination point of the query and the number of moves in the query, correspondingly.
Print $$$q$$$ integers. The $$$i$$$-th integer should be equal to -1 if Mikhail cannot go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in exactly $$$k_i$$$ moves described above. Otherwise the $$$i$$$-th integer should be equal to the the maximum number of diagonal moves among all possible movements.
One of the possible answers to the first test case: $$$(0, 0) \to (1, 0) \to (1, 1) \to (2, 2)$$$.
","input
One of the possible answers to the second test case: $$$(0, 0) \to (0, 1) \to (1, 2) \to (0, 3) \to (1, 4) \to (2, 3) \to (3, 2) \to (4, 3)$$$.
output
In the third test case Mikhail cannot reach the point $$$(10, 1)$$$ in 9 moves.
",math,1
"import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
P=[input().strip() for i in range(n)]
S=[input().split() for i in range(m)]

for i in range(m):
    S[i][1]=int(S[i][1])-1

PDICT=dict()
for i in range(n):
    PDICT[P[i]]=i

E=[]

for i in range(m):
    x=S[i][0]
    LIST=[]

    for j in range(1<<k):
        t=""""
        for l in range(k):
            if (1<<l) & j != 0:
                t+=""_""
            else:
                t+=x[l]

        if t in PDICT:
            LIST.append(PDICT[t])

    if not (S[i][1] in LIST):
        print(""NO"")
        exit()

    else:
        s=S[i][1]
        for l in LIST:
            if l==s:
                continue
            else:
                E.append((s,l))

EDGEIN=[0]*n # その点に入るEDGEの個数
EDGEOUTLIST=[[] for i in range(n)] # EDGEの行き先
for x,y in E:
    EDGEIN[y]+=1
    EDGEOUTLIST[x].append(y)

from collections import deque
QUE = deque()

for i in range(n):
    if EDGEIN[i]==0:
        QUE.append(i) # 行き先のない点をQUEに入れる
        
TOP_SORT=[]
while QUE:
    x=QUE.pop()
    TOP_SORT.append(x) # 行き先がない点を答えに入れる
    for to in EDGEOUTLIST[x]:
        EDGEIN[to]-=1 # 行き先がない点を削除し,そこから一歩先の点のEDGEINを一つ減らす.
        if EDGEIN[to]==0:
            QUE.appendleft(to)

if len(TOP_SORT)==n:
    print(""YES"")
    print(*[i+1 for i in TOP_SORT])
else:
    print(""NO"")
        
",1476_E,CODEFORCES,4734,Pattern Matching,"You are given $$$n$$$ patterns $$$p_1, p_2, \dots, p_n$$$ and $$$m$$$ strings $$$s_1, s_2, \dots, s_m$$$. Each pattern $$$p_i$$$ consists of $$$k$$$ characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string $$$s_j$$$ consists of $$$k$$$ lowercase Latin letters.
A string $$$a$$$ matches a pattern $$$b$$$ if for each $$$i$$$ from $$$1$$$ to $$$k$$$ either $$$b_i$$$ is a wildcard character or $$$b_i=a_i$$$.
You are asked to rearrange the patterns in such a way that the first pattern the $$$j$$$-th string matches is $$$p[mt_j]$$$. You are allowed to leave the order of the patterns unchanged.
Can you perform such a rearrangement? If you can, then print any valid order.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \le n, m \le 10^5$$$, $$$1 \le k \le 4$$$) — the number of patterns, the number of strings and the length of each pattern and string.
Each of the next $$$n$$$ lines contains a pattern — $$$k$$$ characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct.
Each of the next $$$m$$$ lines contains a string — $$$k$$$ lowercase Latin letters, and an integer $$$mt$$$ ($$$1 \le mt \le n$$$) — the index of the first pattern the corresponding string should match.
Print ""NO"" if there is no way to rearrange the patterns in such a way that the first pattern that the $$$j$$$-th string matches is $$$p[mt_j]$$$.
Otherwise, print ""YES"" in the first line. The second line should contain $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ — the order of the patterns. If there are multiple answers, print any of them.
The order of patterns after the rearrangement in the first example is the following: 
Thus, the first string matches patterns ab__, _bcd, _b_d in that order, the first of them is ab__, that is indeed $$$p[4]$$$. The second string matches __b_ and ab__, the first of them is __b_, that is $$$p[2]$$$. The last string matches _bcd and _b_d, the first of them is _bcd, that is $$$p[5]$$$.
The answer to that test is not unique, other valid orders also exist.
","input
In the second example cba doesn't match __c, thus, no valid order exists.
output
In the third example the order (a_, _b) makes both strings match pattern $$$1$$$ first and the order (_b, a_) makes both strings match pattern $$$2$$$ first. Thus, there is no order that produces the result $$$1$$$ and $$$2$$$.
","bitmasks, datastructures, dfsandsimilar, graphs, hashing, sortings, strings",7
"s=input()
n=len(s)
m=n-1;
while m>0:
    f=False
    for i in range(0,n-m):
        for j in range(i+1,n-m+1):
            x=True
            for k in range(0,m):
                if s[i+k]!=s[j+k]:
                    x=False
                    break
            if x:
                f=True
                break
        if f:
            break
    if f:
        break
    m -= 1
print(m)",0023_A,CODEFORCES,3699,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"n, m = map(int, input().split())
b = list(map(int, input().split()))
g = list(map(int, input().split()))
mab = max(b)
mig = min(g)
if mab > mig:
    print(-1)
    exit()

b = sorted(b, reverse=True)
g = sorted(g)
num = 0
j = 0
for i in range(n):
    k = 0
    l = 1
    while j < m and k < m - l and b[i] <= g[j]:
        if b[i] == g[j]:
            l = 0
        num += g[j]
        j += 1
        k += 1
    num += b[i] * (m - k)

print(num)",1159_C,CODEFORCES,2937,The Party and Sweets,"$$$n$$$ boys and $$$m$$$ girls came to the party. Each boy presented each girl some integer number of sweets (possibly zero). All boys are numbered with integers from $$$1$$$ to $$$n$$$ and all girls are numbered with integers from $$$1$$$ to $$$m$$$. For all $$$1 \leq i \leq n$$$ the minimal number of sweets, which $$$i$$$-th boy presented to some girl is equal to $$$b_i$$$ and for all $$$1 \leq j \leq m$$$ the maximal number of sweets, which $$$j$$$-th girl received from some boy is equal to $$$g_j$$$.
More formally, let $$$a_{i,j}$$$ be the number of sweets which the $$$i$$$-th boy give to the $$$j$$$-th girl. Then $$$b_i$$$ is equal exactly to the minimum among values $$$a_{i,1}, a_{i,2}, \ldots, a_{i,m}$$$ and $$$g_j$$$ is equal exactly to the maximum among values $$$b_{1,j}, b_{2,j}, \ldots, b_{n,j}$$$.
You are interested in the minimum total number of sweets that boys could present, so you need to minimize the sum of $$$a_{i,j}$$$ for all $$$(i,j)$$$ such that $$$1 \leq i \leq n$$$ and $$$1 \leq j \leq m$$$. You are given the numbers $$$b_1, \ldots, b_n$$$ and $$$g_1, \ldots, g_m$$$, determine this number. 
The first line contains two integers $$$n$$$ and $$$m$$$, separated with space — the number of boys and girls, respectively ($$$2 \leq n, m \leq 100\,000$$$). The second line contains $$$n$$$ integers $$$b_1, \ldots, b_n$$$, separated by spaces — $$$b_i$$$ is equal to the minimal number of sweets, which $$$i$$$-th boy presented to some girl ($$$0 \leq b_i \leq 10^8$$$). The third line contains $$$m$$$ integers $$$g_1, \ldots, g_m$$$, separated by spaces — $$$g_j$$$ is equal to the maximal number of sweets, which $$$j$$$-th girl received from some boy ($$$0 \leq g_j \leq 10^8$$$).
If the described situation is impossible, print $$$-1$$$. In another case, print the minimal total number of sweets, which boys could have presented and all conditions could have satisfied.
In the first test, the minimal total number of sweets, which boys could have presented is equal to $$$12$$$. This can be possible, for example, if the first boy presented $$$1$$$ and $$$4$$$ sweets, the second boy presented $$$3$$$ and $$$2$$$ sweets and the third boy presented $$$1$$$ and $$$1$$$ sweets for the first and the second girl, respectively. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$12$$$.
","input
In the second test, the boys couldn't have presented sweets in such way, that all statements satisfied.
output
In the third test, the minimal total number of sweets, which boys could have presented is equal to $$$4$$$. This can be possible, for example, if the first boy presented $$$1$$$, $$$1$$$, $$$2$$$ sweets for the first, second, third girl, respectively and the second boy didn't present sweets for each girl. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$4$$$.
","greedy, implementation, math",4
"# problem: XXXX
# idea: XXXX
# import numpy as np


# def almost_difference():
#     n = int(input())
#     if n == 1:
#         return 0
#     # n = 5
#     # array = [1,2,3,1,3]
#     # n = 4
#     # array = [6,6,4,4]
#     x = np.zeros(1000000)
#     # int from 1... -> 10^9
#     # normal array declaration took over 3s. so used array from numpy
#     count_equal = np.zeros(10**9+1)
#     array = [int(el) for el in input().split()]
#     ad_sum = 0
#     prev_sum = 0
#     for i in range(n):
#         # formula from the: XXXX
#         ad_sum = ad_sum + i * array[i] - prev_sum +count_equal[array[i]+1] - count_equal[array[i]-1]
#         count_equal[array[i]] += 1
#         prev_sum += array[i]
 
#     return ad_sum
 
 
# print(almost_difference())



def almost_difference():
    n = int(input())
    if n == 1:
        return 0
    # n = 5
    # array = [1,2,3,1,3]
    # n = 4
    # array = [6,6,4,4]
    # x = np.zeros(1000000)
    # int from 1... -> 10^9
    # normal array declaration took over 3s. so used array from numpy
    dict_equal = dict()
    array = [int(el) for el in input().split()]
    ad_sum = 0
    prev_sum = 0
    for i in range(n):
        if not array[i] in dict_equal.keys():
            dict_equal[array[i]] = 0
        if not array[i]-1 in dict_equal.keys():
            dict_equal[array[i]-1] = 0
        if not array[i]+1 in dict_equal.keys():
            dict_equal[array[i]+1] = 0

        # formula from the: XXXX
        ad_sum = ad_sum + i * array[i] - prev_sum +dict_equal[array[i]+1] - dict_equal[array[i]-1]
        dict_equal[array[i]] += 1
        prev_sum += array[i]
 
    return ad_sum

print(almost_difference())
",0903_D,CODEFORCES,2454,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math",4
"def luck(n):
    if n % 4 == 0 or n % 7 == 0:
        return True
    while n > 0:
        tmp = n % 10
        n = int(n / 10)
        if tmp != 4 and tmp != 7:
            return False

    return True


def lucky(n):
    if luck(n):
        return ""YES""

    for x in range(1, n + 1):
        if n % x == 0 and luck(x):
            return ""YES""

    return ""NO""


n = int(input())

print(lucky(n))",0122_A,CODEFORCES,35,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory",1
"from collections import defaultdict
import sys
import bisect
input=sys.stdin.readline

n,m=map(int,input().split())
a=[int(i) for i in input().split()if i!='\n']
rem=[[] for i in range(m)]
req=n//m
ans=0
for i in range(n):
    rem[a[i]%m].append([a[i],i])
ind=m-1
for i in range(m):
    size=len(rem[i])
    if size>req:
        ind=i
    if size<req:
        ok=False
        for j in range(ind,ind-m,-1):
            while len(rem[j])>req:
                pop,_=rem[j].pop()
                rem[i].append([pop+(i-j)%m,_])
                if len(rem[i])==req:
                    ok=True
                    break
            if ok:
                break
            ind-=1
            
out=[0]*(n)
for i in rem:
    for j in i:
        out[j[1]]=j[0]
print(sum(out)-sum(a))
out=' '.join(map(str,out))
print(out)
                    
                
    
        
        
    
        
    
    
",0999_D,CODEFORCES,1723,Equalize the Remainders,"You are given an array consisting of $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$, and a positive integer $$$m$$$. It is guaranteed that $$$m$$$ is a divisor of $$$n$$$.
In a single move, you can choose any position $$$i$$$ between $$$1$$$ and $$$n$$$ and increase $$$a_i$$$ by $$$1$$$.
Let's calculate $$$c_r$$$ ($$$0 \le r \le m-1)$$$ — the number of elements having remainder $$$r$$$ when divided by $$$m$$$. In other words, for each remainder, let's find the number of corresponding elements in $$$a$$$ with that remainder.
Your task is to change the array in such a way that $$$c_0 = c_1 = \dots = c_{m-1} = \frac{n}{m}$$$.
Find the minimum number of moves to satisfy the above requirement.
The first line of input contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 2 \cdot 10^5, 1 \le m \le n$$$). It is guaranteed that $$$m$$$ is a divisor of $$$n$$$.
The second line of input contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$0 \le a_i \le 10^9$$$), the elements of the array.
","input
In the first line, print a single integer — the minimum number of moves required to satisfy the following condition: for each remainder from $$$0$$$ to $$$m - 1$$$, the number of elements of the array having this remainder equals $$$\frac{n}{m}$$$.
output
In the second line, print any array satisfying the condition and can be obtained from the given array with the minimum number of moves. The values of the elements of the resulting array must not exceed $$$10^{18}$$$.
","datastructures, greedy, implementation",3
"n,k = map(int,input().split())
s = input()
c=0
for i in range(len(s)):
	if s[:i]==s[-i:]:
		c=i
print(s+s[c:]*(k-1))",1029_A,CODEFORCES,3442,Many Equal Substrings,"You are given a string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters and an integer number $$$k$$$.
Let's define a substring of some string $$$s$$$ with indices from $$$l$$$ to $$$r$$$ as $$$s[l \dots r]$$$.
Your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ positions $$$i$$$ such that $$$s[i \dots i + n - 1] = t$$$. In other words, your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
It is guaranteed that the answer is always unique.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 50$$$) — the length of the string $$$t$$$ and the number of substrings.
The second line of the input contains the string $$$t$$$ consisting of exactly $$$n$$$ lowercase Latin letters.
","input
Print such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
output
It is guaranteed that the answer is always unique.
","implementation, strings",5
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, A, B, C, T = rints()
a, ans = rints(), 0
for i in range(n):
    su, cur = A, A
    for j in range(a[i], T):
        cur -= B
        su = max(su, (j - a[i] + 1) * C + cur)

    ans += su
print(ans)
",0964_B,CODEFORCES,1608,Messages,"There are n incoming messages for Vasya. The i-th message is going to be received after ti minutes. Each message has a cost, which equals to A initially. After being received, the cost of a message decreases by B each minute (it can become negative). Vasya can read any message after receiving it at any moment of time. After reading the message, Vasya's bank account receives the current cost of this message. Initially, Vasya's bank account is at 0.
Also, each minute Vasya's bank account receives C·k, where k is the amount of received but unread messages.
Vasya's messages are very important to him, and because of that he wants to have all messages read after T minutes.
Determine the maximum amount of money Vasya's bank account can hold after T minutes.
The first line contains five integers n, A, B, C and T (1 ≤ n, A, B, C, T ≤ 1000).
The second string contains n integers ti (1 ≤ ti ≤ T).
Output one integer  — the answer to the problem.
In the first sample the messages must be read immediately after receiving, Vasya receives A points for each message, n·A = 20 in total.
","input
In the second sample the messages can be read at any integer moment.
output
In the third sample messages must be read at the moment T. This way Vasya has 1, 2, 3, 4 and 0 unread messages at the corresponding minutes, he gets 40 points for them. When reading messages, he receives (5 - 4·3) + (5 - 3·3) + (5 - 2·3) + (5 - 1·3) + 5 =  - 5 points. This is 35 in total.
",math,3
"
def func(u,v,a,l):
    if (v**2-u**2)>=2*a*l:
        return ((u**2+2*a*l)**(1/2)-u)/a
    else:
        t1=(v-u)/a
        t2=(l-(u*t1+a*t1*t1/2))/v
        return t1+t2
def efficient(v,a,w,d):
    if 2*v*v-w*w<=2*a*d:
        t1=v/a
        t2=(v-w)/a
        t3=(d-0.5*a*t1*t1-v*t2+0.5*a*t2*t2)/v
        return t1+t2+t3
    else:
        bound=((2*a*d+w*w)/2)**0.5
        t1=bound/a
        t2=(bound-w)/a
        t3=func(0,w,a,d)
        return t1+t2
        return min(t1+t2,t3)
def main():
    string1=input()
    string2=input()
    arr1=string1.split("" "")
    arr2=string2.split("" "")
    a=int(arr1[0])
    v=int(arr1[1])
    l=int(arr2[0])
    d=int(arr2[1])
    w=int(arr2[2])
    if 2*a*d<=w**2 or v<=w:
        t1=func(0,v,a,l)
        print(""%.8f""%(t1))
    else:
        t1=efficient(v,a,w,d)
        t2=func(w,v,a,l-d)
        print(""%.8f""%(t1+t2))
main()
",0005_D,CODEFORCES,14,Follow Traffic Rules,"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.
It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km/h2, and has maximum speed of v km/h. The road has the length of l km, and the speed sign, limiting the speed to w km/h, is placed d km (1 ≤ d < l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.
The car can enter Bercouver at any speed.
","input
The first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).
output
Print the answer with at least five digits after the decimal point.
","implementation, math",1
"# -*- coding: utf-8 -*-

import sys

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
sys.setrecursionlimit(10 ** 9)
INF = 10 ** 18
MOD = 10 ** 9 + 7

def bisearch_max(mn, mx, func):

    ok = mn
    ng = mx
    while ok+1 < ng:
        mid = (ok+ng) // 2
        if func(mid):
            ok = mid
        else:
            ng = mid
    return ok

def check(m):
    ok = [0] * N
    S = set()
    for i in range(N):
        for j in range(M):
            if A[i][j] >= m:
                ok[i] |= 1<<j
        S.add(ok[i])
    full = (1<<M) - 1
    for bit1 in range(1<<M):
        for bit2 in range(bit1, 1<<M):
            if bit1 in S and bit2 in S:
                if bit1 | bit2 == full:
                    return True
    return False

N, M = MAP()
A = [None] * N
for i in range(N):
    A[i] = LIST()

res = bisearch_max(0, 10**9+1, check)
ok = [0] * N
S = set()
D = {}
for i in range(N):
    for j in range(M):
        if A[i][j] >= res:
            ok[i] |= 1<<j
    S.add(ok[i])
    D[ok[i]] = i + 1
full = (1<<M) - 1
for bit1 in range(1<<M):
    for bit2 in range(bit1, 1<<M):
        if bit1 in S and bit2 in S:
            if bit1 | bit2 == full:
                print(D[bit1], D[bit2])
                exit()
",1288_D,CODEFORCES,4662,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"from math import inf

a=[0,0]
a[0]=[str(c)for c in list(input().strip()) ]
a[1]=[str(X) for X in list(input().strip())]

an = [-inf,-inf,-inf]
if a[0][0]==a[1][0]=='0':
    an[0]=0
elif  a[0][0]!=a[1][0]:
    an[1]=0
x=0
for i in range(1,len(a[0])) :
  #  print(a[0][i],a[1][i],an,x)
    if an[0]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1

            an=[-inf,0 ,-inf]
        elif a[0][i]!=a[1][i]:
            x+=1
            an=[-inf]*3
        else:
            an = [-inf, -inf, -inf]
    elif an[1]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1
            an=[-inf,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            pass
        else:
            an=[-inf,-inf ,-inf]
    else:
        if a[0][i]==a[1][i]=='0':

            an=[0,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            an=[-inf,0,-inf]
        else:
            an=[-inf,-inf ,-inf]

print(x)",0991_D,CODEFORCES,372,Bishwock,"Bishwock is a chess figure that consists of three squares resembling an ""L-bar"". This figure can be rotated by 90, 180 and 270 degrees so it can have four possible states:
Bishwocks don't attack any squares and can even occupy on the adjacent squares as long as they don't occupy the same square. 
Vasya has a board with $$$2\times n$$$ squares onto which he wants to put some bishwocks. To his dismay, several squares on this board are already occupied by pawns and Vasya can't put bishwocks there. However, pawns also don't attack bishwocks and they can occupy adjacent squares peacefully.
Knowing the positions of pawns on the board, help Vasya to determine the maximum amount of bishwocks he can put onto the board so that they wouldn't occupy the same squares and wouldn't occupy squares with pawns.
","input
The input contains two nonempty strings that describe Vasya's board. Those strings contain only symbols ""0"" (zero) that denote the empty squares and symbols ""X"" (uppercase English letter) that denote the squares occupied by pawns. Strings are nonempty and are of the same length that does not exceed $$$100$$$.
output
Output a single integer — the maximum amount of bishwocks that can be placed onto the given board.
","dp, greedy",1
"n, m = map(int, input().split())

a = []


def is_center(a, y, x):
    count1 = count2 = count3 = count4 = 0
    # up
    y1 = y
    x1 = x
    while True:
        y2 = y1 - 1
        if y2 < 0:
            break
        c = a[y2][x]
        if c == ""W"":
            break
        count1 += 1
        y1 = y2

    # down
    y1 = y
    x1 = x
    while True:
        y2 = y1 + 1
        if y2 == n:
            break
        c = a[y2][x]
        if c == ""W"":
            break
        count2 += 1
        y1 = y2

    # left
    y1 = y
    x1 = x
    while True:
        x2 = x1 - 1
        if x2 < 0:
            break
        c = a[y1][x2]
        if c == ""W"":
            break
        count3 += 1
        x1 = x2

    # right
    y1 = y
    x1 = x
    while True:
        x2 = x1 + 1
        if x2 == m:
            break
        c = a[y1][x2]
        if c == ""W"":
            break
        count4 += 1
        x1 = x2

    return count1 == count2 == count3 == count4 and a[y][x] == ""B""


for k in range(n):
    s = input()
    a.append(s)


for y in range(n):
    c = False
    for x in range(m):
        if is_center(a, y, x):
            print(y+1, x+1)
            c = True
            break
    if c:
        break


",1028_A,CODEFORCES,3416,Find Square,"Consider a table of size $$$n \times m$$$, initially fully white. Rows are numbered $$$1$$$ through $$$n$$$ from top to bottom, columns $$$1$$$ through $$$m$$$ from left to right. Some square inside the table with odd side length was painted black. Find the center of this square.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 115$$$) — the number of rows and the number of columns in the table.
","input
The $$$i$$$-th of the next $$$n$$$ lines contains a string of $$$m$$$ characters $$$s_{i1} s_{i2} \ldots s_{im}$$$ ($$$s_{ij}$$$ is 'W' for white cells and 'B' for black cells), describing the $$$i$$$-th row of the table.
output
Output two integers $$$r$$$ and $$$c$$$ ($$$1 \le r \le n$$$, $$$1 \le c \le m$$$) separated by a space — the row and column numbers of the center of the black square.
",implementation,5
"import sys


# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

input = sys.stdin.readline


n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))


ans = float('inf')
for i in range(1, n-1):
    bef = aft = float('inf')
    for j in range(i):
        if a[j] < a[i]:
            bef = min(bef, b[j])
    for j in range(i, n):
        if a[i] < a[j]:
            aft = min(aft, b[j])
    ans = min(ans, b[i]+bef+aft)
print(-1 if ans > 10**9 else ans)




",0987_C,CODEFORCES,3260,Three displays,"It is the middle of 2018 and Maria Stepanovna, who lives outside Krasnokamensk (a town in Zabaikalsky region), wants to rent three displays to highlight an important problem.
There are $$$n$$$ displays placed along a road, and the $$$i$$$-th of them can display a text with font size $$$s_i$$$ only. Maria Stepanovna wants to rent such three displays with indices $$$i < j < k$$$ that the font size increases if you move along the road in a particular direction. Namely, the condition $$$s_i < s_j < s_k$$$ should be held.
The rent cost is for the $$$i$$$-th display is $$$c_i$$$. Please determine the smallest cost Maria Stepanovna should pay.
The first line contains a single integer $$$n$$$ ($$$3 \le n \le 3\,000$$$) — the number of displays.
The second line contains $$$n$$$ integers $$$s_1, s_2, \ldots, s_n$$$ ($$$1 \le s_i \le 10^9$$$) — the font sizes on the displays in the order they stand along the road.
The third line contains $$$n$$$ integers $$$c_1, c_2, \ldots, c_n$$$ ($$$1 \le c_i \le 10^8$$$) — the rent costs for each display.
If there are no three displays that satisfy the criteria, print -1. Otherwise print a single integer — the minimum total rent cost of three displays with indices $$$i < j < k$$$ such that $$$s_i < s_j < s_k$$$.
","input
In the first example you can, for example, choose displays $$$1$$$, $$$4$$$ and $$$5$$$, because $$$s_1 < s_4 < s_5$$$ ($$$2 < 4 < 10$$$), and the rent cost is $$$40 + 10 + 40 = 90$$$.
output
In the second example you can't select a valid triple of indices, so the answer is -1.
","bruteforce, dp, implementation",5
"n=int(input())
w=[int(k) for k in input().split()]
c={w[j]:j+1 for j in range(n)}
#print(c)
res=0
for j in range(1, n+1):
    if w[j-1]==j:
        pass
    else:
        res+=1
        y=w[j-1]
        w[j-1]=j
        w[c[j]-1]=y
        r=c[j]
        c[j]=j
        c[y]=r
if n%2==0:
    if res%2==0:
        print(""Petr"")
    else:
        print(""Um_nik"")
else:
    if res%2:
        print(""Petr"")
    else:
        print(""Um_nik"")
#print(w)",0986_B,CODEFORCES,2571,Petr and Permutations,"Petr likes to come up with problems about randomly generated data. This time problem is about random permutation. He decided to generate a random permutation this way: he takes identity permutation of numbers from $$$1$$$ to $$$n$$$ and then $$$3n$$$ times takes a random pair of different elements and swaps them. Alex envies Petr and tries to imitate him in all kind of things. Alex has also come up with a problem about random permutation. He generates a random permutation just like Petr but swaps elements $$$7n+1$$$ times instead of $$$3n$$$ times. Because it is more random, OK?!
You somehow get a test from one of these problems and now you want to know from which one.
In the first line of input there is one integer $$$n$$$ ($$$10^{3} \le n \le 10^{6}$$$).
In the second line there are $$$n$$$ distinct integers between $$$1$$$ and $$$n$$$ — the permutation of size $$$n$$$ from the test.
It is guaranteed that all tests except for sample are generated this way: First we choose $$$n$$$ — the size of the permutation. Then we randomly choose a method to generate a permutation — the one of Petr or the one of Alex. Then we generate a permutation using chosen method.
If the test is generated via Petr's method print ""Petr"" (without quotes). If the test is generated via Alex's method print ""Um_nik"" (without quotes).
","input
Please note that the sample is not a valid test (because of limitations for $$$n$$$) and is given only to illustrate input/output format. Your program still has to print correct answer to this test to get AC.
output
Due to randomness of input hacks in this problem are forbidden.
","combinatorics, math",4
"string = input()
totalmax = 0;
for x in range(len(string)):
    curr = """"
    for y in string[x:]:
        curr +=y;
        if string[x:].rfind(curr) != string[x:].find(curr):
            totalmax = max(totalmax, len(curr))
            continue
print(totalmax)",0023_A,CODEFORCES,3714,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"n = int(input())
a = list(map(int, input().split()))
idx = list(range(n))
idx.sort(key=lambda i: a[i], reverse=True)
imin = imax = idx[0]
for i in idx[1:]:
    if i == imin - 1 or i == imax + 1:
        imin = min(imin, i)
        imax = max(imax, i)
    else:
        print('NO')
        exit(0)
print('YES')
",1197_B,CODEFORCES,3018,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation",4
"N, K = map(int, input().split())

def in_bounds(k):
    return N <= K*(K+1)//2 - (K-k)*(K-k+1)//2 - k + 1

l = 0
r = K
while l <= r:
    c = (l + r) // 2
    if in_bounds(c):
        r = c - 1
    else:
        l = c + 1
if in_bounds(K):
    print(l)
else:
    print(-1)
",0287_B,CODEFORCES,929,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"k = int(input())
prev=0
nextt=0
NumofDigits=0
#i = 0
#while(summ<(2^12)):
while(True):
    prev = nextt
    nextt = nextt+(9*(10**(NumofDigits-1))*NumofDigits)
    if(k>= prev and k<=nextt):
        break
    NumofDigits=NumofDigits+1
if(NumofDigits==1):
    print(k)
else:
    result = (10**(NumofDigits-1))+int((k-(prev+1))/NumofDigits)
    i=0
    while(True):
        if (k-int(prev+1))%NumofDigits == i:
            break
        i=i+1
    result = str(result)
    print(result[i])",1177_B,CODEFORCES,699,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",1
"first,last=input().split()
username=first[0]
first=first[1:]
while first!="""" and first[0]<last[0]:
    username=username+first[0]
    first=first[1:]
print(username+last[0])",0909_A,CODEFORCES,1529,Generate Login,"The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.
You are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).
As a reminder, a prefix of a string s is its substring which occurs at the beginning of s: ""a"", ""ab"", ""abc"" etc. are prefixes of string ""{abcdef}"" but ""b"" and 'bc"" are not. A string a is alphabetically earlier than a string b, if a is a prefix of b, or a and b coincide up to some position, and then a has a letter that is alphabetically earlier than the corresponding letter in b: ""a"" and ""ab"" are alphabetically earlier than ""ac"" but ""b"" and ""ba"" are alphabetically later than ""ac"".
","input
The input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive. 
output
Output a single string — alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.
","bruteforce, greedy, sortings",3
"import sys
input = sys.stdin.readline
maxn = int(1510)
ST = [0 for _ in range(4 * maxn)]
def update(id, l, r, val):
    if l == r == val:
        ST[id] = 1
        return
    if l > val or r < val:
        return
    mid = int((l + r) / 2)
    update(id * 2, l, mid, val)
    update(id * 2 + 1, mid + 1, r, val)
    ST[id] = ST[id * 2] + ST[id * 2 + 1]
    return
def get(id, l, r, x, y):
    if l > y or r < x:
        return 0
    if x <= l and r <= y:
        return ST[id]
    mid = int((l + r) / 2)
    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)
n, res = int(input()), 0
for x in list(map(int, input().split())):
    res ^= get(1, 1, n, x + 1, n) % 2
    update(1, 1, n, x)
for i in range (int(input())):
    x, y = list(map(int, input().split()))
    if int((y - x) * (y - x + 1) / 2) & 1:
        res ^= 1
    if res:
        print(""odd"")
    else:
        print(""even"")",0911_D,CODEFORCES,3109,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"a = [ord(e) - ord('0') for e in list(input().strip())]
b = [ord(e) - ord('0') for e in list(input().strip())]

a.sort(reverse=True)
h = [0 for i in range(10)]
for x in a:
    h[x] += 1

if len(a) < len(b):
    print(''.join(map(str, a)))
    exit(0)

def gmax(hx):
    s = list(hx)
    res = list()
    for i in range(9, -1, -1):
        while s[i] > 0:
            res.append(i)
            s[i] -= 1
    return res

def gmin(hx):
    s = list(hx)
    res = list()
    for i in range(10):
        while s[i] > 0:
            res.append(i)
            s[i] -= 1
    return res

res = list()

def finalize(x):
    for y in range(x-1, -1, -1):
        if h[y] > 0:
            res.append(y)
            h[y] -= 1
            for i in range(9, -1, -1):
                while h[i] > 0:
                    res.append(i)
                    h[i] -= 1
            return

p = 0
while p < len(a):
    x = b[p]    
    if h[x] > 0:
        hh = list(h)
        hh[x] -= 1
        if b[p+1:] >= gmin(hh): # can make a smaller one with the remainings
            res.append(x)
            h[x] -= 1
        else:
            finalize(x)
            break
    else:
        finalize(x)
        break
    p += 1
print(''.join(map(str, res)))",915C_,CODEFORCES,4231,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"import itertools
n,l,r,x=map(int,input().split())
problems=[int(x) for x in input().split()]
result=0
for i in range(2,n+1):
    for comb in itertools.combinations(problems,i):
        summ = sum(comb)
        mini = min(comb)
        maxx = max(comb)
        if l <= summ <=r and maxx-mini>=x:
            result+=1
print(result)

",0550_B,CODEFORCES,4493,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int,sys.stdin.readline().strip().split()))
a.sort()

if n == 1:
    if a[0] % 2 == 1:
        v = True
    else:
        v = False
else:
    v = True
    c = 0
    for i in range (0, n-1):
        if a[i] == a[i + 1]:
            c = c + 1
            j = i
    if c > 1:
        v = False
    elif c == 1:
        if a[j] == 0:
            v = False
        if j > 0:
            if a[j-1] + 1 == a[j]:
                v = False
    if (sum(a) - (n * (n - 1)) // 2) % 2 == 0:
        v = False

if v == True:
    print(""sjfnb"")
else:
    print(""cslnb"")
    ",1190_B,CODEFORCES,2945,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
",games,4
"from sys import stdin,stdout
from collections import Counter
def ai(): return list(map(int, stdin.readline().split()))
def ei(): return map(int, stdin.readline().split())
def ip(): return  int(stdin.readline().strip())
def op(ans): return stdout.write(str(ans) + '\n') 

n = ip()
s = input()
t = input()
value = {}
li = []
res1 = 0
res2 =res3 = -1
for i in range(n):
	if s[i] != t[i]:
		value[t[i]] = i
		res1 += 1
		li.append(i)
p = sq = False
for i in li:
	if s[i] in value:
		p = True
		res2 = i+1
		f = value[s[i]]
		res3 = f+1
		if s[f] == t[i]:
			sq = True
			break
print(res1-(2 if sq else 1 if p else 0))
print(res2,res3)",0527_B,CODEFORCES,1482,Error Correct System,"Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be ""similar"". After a brief search on the Internet, he learned about the Hamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words ""permanent"" and ""pergament"" is two, as these words differ in the fourth and sixth letters.
Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string S, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.
Help him do this!
The first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.
The second line contains string S.
The third line contains string T.
Each of the lines only contains lowercase Latin letters.
In the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.
In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print ""-1 -1"", if it is not necessary to swap characters.
","input
If there are multiple possible answers, print any of them.
output
In the second test it is acceptable to print i = 2, j = 3.
",greedy,3
"#Winners never quit, quiters never win............................................................................
from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    


def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 

   
#here we go......................
#winners never quit, quitters never win
n,d=map(int,input().split())
x=list(map(int,input().split()))
ans=0
for i in range(1,n):
    diff=x[i]-x[i-1]
    #print(x[i]-d)
    #print(x[i-1]+d,""xnwxnwisj"")
    if diff >= 2*d:
        ans+=min(2,(x[i]-d)-(x[i-1]+d)+1)
        #print(ans,""ans"")
ans+=2
print(ans)",1004_A,CODEFORCES,1756,Sonya and Hotels,"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.
The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $$$n$$$ hotels, where the $$$i$$$-th hotel is located in the city with coordinate $$$x_i$$$. Sonya is a smart girl, so she does not open two or more hotels in the same city.
Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $$$d$$$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 
Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $$$n$$$ hotels to the new one is equal to $$$d$$$.
The first line contains two integers $$$n$$$ and $$$d$$$ ($$$1\leq n\leq 100$$$, $$$1\leq d\leq 10^9$$$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.
The second line contains $$$n$$$ different integers in strictly increasing order $$$x_1, x_2, \ldots, x_n$$$ ($$$-10^9\leq x_i\leq 10^9$$$) — coordinates of Sonya's hotels.
Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $$$d$$$.
","input
In the first example, there are $$$6$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$-6$$$, $$$5$$$, $$$6$$$, $$$12$$$, $$$13$$$, and $$$19$$$.
output
In the second example, there are $$$5$$$ possible cities where Sonya can build a hotel. These cities have coordinates $$$2$$$, $$$6$$$, $$$13$$$, $$$16$$$, and $$$21$$$.
",implementation,3
"'''
      ___           ___                         ___                       ___           ___                         ___
     /\__\         /\  \         _____         /\  \                     /\  \         /\  \                       /\__\
    /:/ _/_        \:\  \       /::\  \        \:\  \       ___         /::\  \       |::\  \         ___         /:/ _/_
   /:/ /\  \        \:\  \     /:/\:\  \        \:\  \     /\__\       /:/\:\__\      |:|:\  \       /\__\       /:/ /\  \
  /:/ /::\  \   ___  \:\  \   /:/  \:\__\   ___ /::\  \   /:/__/      /:/ /:/  /    __|:|\:\  \     /:/  /      /:/ /::\  \
 /:/_/:/\:\__\ /\  \  \:\__\ /:/__/ \:|__| /\  /:/\:\__\ /::\  \     /:/_/:/__/___ /::::|_\:\__\   /:/__/      /:/_/:/\:\__\
 \:\/:/ /:/  / \:\  \ /:/  / \:\  \ /:/  / \:\/:/  \/__/ \/\:\  \__  \:\/:::::/  / \:\~~\  \/__/  /::\  \      \:\/:/ /:/  /
  \::/ /:/  /   \:\  /:/  /   \:\  /:/  /   \::/__/       ~~\:\/\__\  \::/~~/~~~~   \:\  \       /:/\:\  \      \::/ /:/  /
   \/_/:/  /     \:\/:/  /     \:\/:/  /     \:\  \          \::/  /   \:\~~\        \:\  \      \/__\:\  \      \/_/:/  /
     /:/  /       \::/  /       \::/  /       \:\__\         /:/  /     \:\__\        \:\__\          \:\__\       /:/  /
     \/__/         \/__/         \/__/         \/__/         \/__/       \/__/         \/__/           \/__/       \/__/

'''
""""""
░░██▄░░░░░░░░░░░▄██
░▄▀░█▄░░░░░░░░▄█░░█░
░█░▄░█▄░░░░░░▄█░▄░█░
░█░██████████████▄█░
░█████▀▀████▀▀█████░
▄█▀█▀░░░████░░░▀▀███
██░░▀████▀▀████▀░░██
██░░░░█▀░░░░▀█░░░░██
███▄░░░░░░░░░░░░▄███
░▀███▄░░████░░▄███▀░
░░░▀██▄░▀██▀░▄██▀░░░
░░░░░░▀██████▀░░░░░░
░░░░░░░░░░░░░░░░░░░░
""""""
import sys
import math
import collections
import operator as op
from collections import deque
from math import gcd, inf, sqrt, pi, cos, sin, ceil, log2, floor, log
from bisect import bisect_right, bisect_left, bisect

# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

from functools import reduce
from sys import stdin, stdout, setrecursionlimit
setrecursionlimit(2**20)


def ncr(n, r):
    r = min(r, n - r)
    numer = reduce(op.mul, range(n, n - r, -1), 1)
    denom = reduce(op.mul, range(1, r + 1), 1)
    return numer // denom  # or / in Python 2


def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return (list(factors))


def isPowerOfTwo(x):
    return (x and (not(x & (x - 1))))

MOD = 1000000007
PMOD = 998244353
N = 10**18 + 1
LOGN = 30
alp = 'abcdefghijklmnopqrstuvwxyz'
T = 1
# T = int(stdin.readline())
for _ in range(T):
    n, k = list(map(int, stdin.readline().rstrip().split()))
    # n = int(stdin.readline())
    # a = list(map(int, stdin.readline().rstrip().split()))
    # b = list(map(int, stdin.readline().rstrip().split()))
    # s = str(stdin.readline().strip('\n'))
    # s = list(stdin.readline().strip('\n'))
    # m = int(stdin.readline())
    # c = list(map(int, stdin.readline().rstrip().split()))
    det = (int(sqrt(9 + 8 * (n + k)) - 3)) // 2
    print(n - det)
",1195_B,CODEFORCES,1338,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"from sys import stdin, stdout, exit

n = int(input())
a = list(map(int, stdin.readline().split()))

def z(winner):
    return 'sjfnb' if winner == 0 else 'cslnb'

a.sort()
dups = set(a)
if len(dups) < len(a) - 1:
    print(z(1))
    exit()

winner = 0
for i in range(n-1):
    if a[i] == a[i+1]:
        if a[i] == 0 or a[i]-1 in a:
            print(z(1))
            exit()
        winner = 1
        a[i] = a[i] - 1

s = sum(a)
final = n*(n-1) // 2
winner += (s - final) + 1
winner %= 2
print(z(winner))
",1191_D,CODEFORCES,2984,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy",4
"import sys

n, m, k = list(map(int,sys.stdin.readline().strip().split()))
p = list(map(int,sys.stdin.readline().strip().split()))
i = 0
c = 0
d = 0
while i < m:
    c = c + 1
    d2 = d
    x = k*((p[i]-d2-1)//k) + k
    while p[i]-d2 <= x:
        i = i + 1
        d = d + 1
        if i == m:
            break
print(c)

",1190_A,CODEFORCES,2176,Tokitsukaze and Discard Items,"Recently, Tokitsukaze found an interesting game. Tokitsukaze had $$$n$$$ items at the beginning of this game. However, she thought there were too many items, so now she wants to discard $$$m$$$ ($$$1 \le m \le n$$$) special items of them.
These $$$n$$$ items are marked with indices from $$$1$$$ to $$$n$$$. In the beginning, the item with index $$$i$$$ is placed on the $$$i$$$-th position. Items are divided into several pages orderly, such that each page contains exactly $$$k$$$ positions and the last positions on the last page may be left empty.
Tokitsukaze would do the following operation: focus on the first special page that contains at least one special item, and at one time, Tokitsukaze would discard all special items on this page. After an item is discarded or moved, its old position would be empty, and then the item below it, if exists, would move up to this empty position. The movement may bring many items forward and even into previous pages, so Tokitsukaze would keep waiting until all the items stop moving, and then do the operation (i.e. check the special page and discard the special items) repeatedly until there is no item need to be discarded.
Tokitsukaze wants to know the number of operations she would do in total.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \le n \le 10^{18}$$$, $$$1 \le m \le 10^5$$$, $$$1 \le m, k \le n$$$) — the number of items, the number of special items to be discarded and the number of positions in each page.
The second line contains $$$m$$$ distinct integers $$$p_1, p_2, \ldots, p_m$$$ ($$$1 \le p_1 < p_2 < \ldots < p_m \le n$$$) — the indices of special items which should be discarded.
Print a single integer — the number of operations that Tokitsukaze would do in total.
","input
For the first example:
output
For the second example, Tokitsukaze would focus on the second page $$$[6, 7, 8, 9, 10]$$$ and discard all special items at once.
","implementation, twopointers",3
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
johnny=0
 	 	 	 			   		 		  				 				",0990_D,CODEFORCES,3299,Graph And Its Complement,"Given three numbers $$$n, a, b$$$. You need to find an adjacency matrix of such an undirected graph that the number of components in it is equal to $$$a$$$, and the number of components in its complement is $$$b$$$. The matrix must be symmetric, and all digits on the main diagonal must be zeroes.
In an undirected graph loops (edges from a vertex to itself) are not allowed. It can be at most one edge between a pair of vertices.
The adjacency matrix of an undirected graph is a square matrix of size $$$n$$$ consisting only of ""0"" and ""1"", where $$$n$$$ is the number of vertices of the graph and the $$$i$$$-th row and the $$$i$$$-th column correspond to the $$$i$$$-th vertex of the graph. The cell $$$(i,j)$$$ of the adjacency matrix contains $$$1$$$ if and only if the $$$i$$$-th and $$$j$$$-th vertices in the graph are connected by an edge.
A connected component is a set of vertices $$$X$$$ such that for every two vertices from this set there exists at least one path in the graph connecting this pair of vertices, but adding any other vertex to $$$X$$$ violates this rule.
The complement or inverse of a graph $$$G$$$ is a graph $$$H$$$ on the same vertices such that two distinct vertices of $$$H$$$ are adjacent if and only if they are not adjacent in $$$G$$$.
In a single line, three numbers are given $$$n, a, b \,(1 \le n \le 1000, 1 \le a, b \le n)$$$: is the number of vertexes of the graph, the required number of connectivity components in it, and the required amount of the connectivity component in it's complement. 
If there is no graph that satisfies these constraints on a single line, print ""NO"" (without quotes).
","input
Otherwise, on the first line, print ""YES""(without quotes). In each of the next $$$n$$$ lines, output $$$n$$$ digits such that $$$j$$$-th digit of $$$i$$$-th line must be $$$1$$$ if and only if there is an edge between vertices $$$i$$$ and $$$j$$$ in $$$G$$$ (and $$$0$$$ otherwise). Note that the matrix must be symmetric, and all digits on the main diagonal must be zeroes. 
output
If there are several matrices that satisfy the conditions — output any of them.
","constructivealgorithms, graphs, implementation",5
"import math
import copy
def dtb(n): 
    return bin(n).replace(""0b"","""")
def btd(n): 
    return int(n,2) 
t=1
for k in range(t):
    n,kk=map(int,input().split())
    a=list(map(int,input().split()))[:n]
    c=copy.copy(a)
    a.sort(reverse=True)
    b=[]
    f=[]
    ans=0
    for i in range(kk):
        ans+=a[i]
        b.append(a[i])
    count=1    
    x=0
    y=0
    for i in range(n):
        if len(f)==(kk-1):
            y=i
            break
        if c[i] in b:
            f.append(i-x+1)
            x=i+1
            b.remove(c[i])
            
    f.append(n-y)        
    print(ans)    
    for i in f:
        print(i,end="" "")
        ",1006_B,CODEFORCES,2712,Polycarp's Practice,"Polycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.
Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.
The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\max\limits_{l \le i \le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.
You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.
For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the number of problems and the number of days, respectively.
The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).
In the first line of the output print the maximum possible total profit.
In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \dots, t_k$$$ ($$$t_1 + t_2 + \dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.
If there are many possible answers, you may print any of them.
The first example is described in the problem statement.
","input
In the second example there is only one possible distribution.
output
In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.
","greedy, implementation, sortings",4
"d={}
n=int(input())
for _ in range(n):
    a,b=map(int,input().split())
    d[a]=b
m=int(input())
for _ in range(m):
    a,b=map(int,input().split())
    if(a in d and b>d[a]):
        d[a]=b
    elif(a not in d):
        d[a]=b
s=0
for i in d:
    s+=d[i]
print(s)
",0981_B,CODEFORCES,2535,Businessmen Problems,"Two famous competing companies ChemForces and TopChemist decided to show their sets of recently discovered chemical elements on an exhibition. However they know that no element should be present in the sets of both companies.
In order to avoid this representatives of both companies decided to make an agreement on the sets the companies should present. The sets should be chosen in the way that maximizes the total income of the companies.
All elements are enumerated with integers. The ChemForces company has discovered $$$n$$$ distinct chemical elements with indices $$$a_1, a_2, \ldots, a_n$$$, and will get an income of $$$x_i$$$ Berland rubles if the $$$i$$$-th element from this list is in the set of this company.
The TopChemist company discovered $$$m$$$ distinct chemical elements with indices $$$b_1, b_2, \ldots, b_m$$$, and it will get an income of $$$y_j$$$ Berland rubles for including the $$$j$$$-th element from this list to its set.
In other words, the first company can present any subset of elements from $$$\{a_1, a_2, \ldots, a_n\}$$$ (possibly empty subset), the second company can present any subset of elements from $$$\{b_1, b_2, \ldots, b_m\}$$$ (possibly empty subset). There shouldn't be equal elements in the subsets.
Help the representatives select the sets in such a way that no element is presented in both sets and the total income is the maximum possible.
The first line contains a single integer $$$n$$$ ($$$1 \leq n \leq 10^5$$$)  — the number of elements discovered by ChemForces.
The $$$i$$$-th of the next $$$n$$$ lines contains two integers $$$a_i$$$ and $$$x_i$$$ ($$$1 \leq a_i \leq 10^9$$$, $$$1 \leq x_i \leq 10^9$$$)  — the index of the $$$i$$$-th element and the income of its usage on the exhibition. It is guaranteed that all $$$a_i$$$ are distinct.
The next line contains a single integer $$$m$$$ ($$$1 \leq m \leq 10^5$$$)  — the number of chemicals invented by TopChemist.
The $$$j$$$-th of the next $$$m$$$ lines contains two integers $$$b_j$$$ and $$$y_j$$$, ($$$1 \leq b_j \leq 10^9$$$, $$$1 \leq y_j \leq 10^9$$$)  — the index of the $$$j$$$-th element and the income of its usage on the exhibition. It is guaranteed that all $$$b_j$$$ are distinct.
Print the maximum total income you can obtain by choosing the sets for both companies in such a way that no element is presented in both sets.
","input
In the first example ChemForces can choose the set ($$$3, 7$$$), while TopChemist can choose ($$$1, 2, 4$$$). This way the total income is $$$(10 + 2) + (4 + 4 + 4) = 24$$$.
output
In the second example ChemForces can choose the only element $$$10^9$$$, while TopChemist can choose ($$$14, 92, 35$$$). This way the total income is $$$(239) + (15 + 65 + 89) = 408$$$.
",sortings,4
"import itertools

n = int(input())
boards = []
for i in range(4):
    boards.append([])
    for j in range(n):
        boards[-1].append(list(map(int, list(input()))))
    if i < 3: input()

ans = n * n * 4


def check_board(corner, board):
    ans = 0
    for i in range(n):
        for j in range(n):
            if board[i][j] != corner:
                ans += 1
            corner = 1 - corner
    return ans


def solve(corner, p):
    ans = check_board(corner, boards[p[0]])
    ans += check_board(1- corner, boards[p[1]])
    ans += check_board(1 - corner, boards[p[2]])
    ans += check_board(corner, boards[p[3]])

    return ans


for p in itertools.permutations(range(4), 4):
    ans = min(ans, solve(1, p))
    ans = min(ans, solve(0, p))

print(ans)",0961_C,CODEFORCES,3178,Chessboard,"Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into 4 pieces, each of size n by n, n is always odd. And what's even worse, some squares were of wrong color. j-th square of the i-th row of k-th piece of the board has color ak, i, j; 1 being black and 0 being white. 
Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be 2n by 2n. You are allowed to move pieces but not allowed to rotate or flip them.
The first line contains odd integer n (1 ≤ n ≤ 100) — the size of all pieces of the board. 
","input
Then 4 segments follow, each describes one piece of the board. Each consists of n lines of n characters; j-th one of i-th line is equal to 1 if the square is black initially and 0 otherwise. Segments are separated by an empty line.
output
Print one number — minimum number of squares Magnus should recolor to be able to obtain a valid chessboard.
","bitmasks, bruteforce, implementation",5
"n, a, b = [int(i) for i in input().split()]
lst = sorted([int(i) for i in input().split()])
print(lst[b]-lst[b-1])
",0169_A,CODEFORCES,2355,Chores,"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do n chores. Each chore is characterized by a single parameter — its complexity. The complexity of the i-th chore equals hi.
As Petya is older, he wants to take the chores with complexity larger than some value x (hi > x) to leave to Vasya the chores with complexity less than or equal to x (hi ≤ x). The brothers have already decided that Petya will do exactly a chores and Vasya will do exactly b chores (a + b = n).
In how many ways can they choose an integer x so that Petya got exactly a chores and Vasya got exactly b chores?
The first input line contains three integers n, a and b (2 ≤ n ≤ 2000; a, b ≥ 1; a + b = n) — the total number of chores, the number of Petya's chores and the number of Vasya's chores.
The next line contains a sequence of integers h1, h2, ..., hn (1 ≤ hi ≤ 109), hi is the complexity of the i-th chore. The numbers in the given sequence are not necessarily different.
All numbers on the lines are separated by single spaces.
Print the required number of ways to choose an integer value of x. If there are no such ways, print 0.
","input
In the first sample the possible values of x are 3, 4 or 5.
output
In the second sample it is impossible to find such x, that Petya got 3 chores and Vasya got 4.
",sortings,4
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}
b = [0]

for i in range(n):
    for p in b:
        d = gcd(p, l[i])
        cost = a[p] + c[i]
        if d not in a:
            a[d] = cost
            b.append(d)
        elif a[d] > cost: a[d] = cost

if 1 not in a: a[1] = -1
print(a[1])

                                                                                                                                                                                                                                                       ",0512_B,CODEFORCES,4399,Fox And Jumping,"Fox Ciel is playing a game. In this game there is an infinite long tape with cells indexed by integers (positive, negative and zero). At the beginning she is standing at the cell 0.
There are also n cards, each card has 2 attributes: length li and cost ci. If she pays ci dollars then she can apply i-th card. After applying i-th card she becomes able to make jumps of length li, i. e. from cell x to cell (x - li) or cell (x + li).
She wants to be able to jump to any cell on the tape (possibly, visiting some intermediate cells). For achieving this goal, she wants to buy some cards, paying as little money as possible. 
If this is possible, calculate the minimal cost.
The first line contains an integer n (1 ≤ n ≤ 300), number of cards.
The second line contains n numbers li (1 ≤ li ≤ 109), the jump lengths of cards.
The third line contains n numbers ci (1 ≤ ci ≤ 105), the costs of cards.
If it is impossible to buy some cards and become able to jump to any cell, output -1. Otherwise output the minimal cost of buying such set of cards.
","input
In first sample test, buying one card is not enough: for example, if you buy a card with length 100, you can't jump to any cell whose index is not a multiple of 100. The best way is to buy first and second card, that will make you be able to jump to any cell.
output
In the second sample test, even if you buy all cards, you can't jump to any cell whose index is not a multiple of 10, so you should output -1.
","datastructures, dp, math, numbertheory, shortestpaths",7
"def f(l):
    n,m = l #1129
    return ['5'*282,'4'*281+'5']

l = list(map(int,input().split()))
[print(r) for r in f(l)]
",1028_B,CODEFORCES,427,Unnatural Conditions,"Let $$$s(x)$$$ be sum of digits in decimal representation of positive integer $$$x$$$. Given two integers $$$n$$$ and $$$m$$$, find some positive integers $$$a$$$ and $$$b$$$ such that 
The only line of input contain two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1129$$$).
","input
Print two lines, one for decimal representation of $$$a$$$ and one for decimal representation of $$$b$$$. Both numbers must not contain leading zeros and must have length no more than $$$2230$$$.
output
In the first sample, we have $$$n = 6$$$ and $$$m = 5$$$. One valid solution is $$$a = 6$$$, $$$b = 7$$$. Indeed, we have $$$s(a) = 6 \ge n$$$ and $$$s(b) = 7 \ge n$$$, and also $$$s(a + b) = s(13) = 4 \le m$$$.
","constructivealgorithms, math",1
"def solve(a, b):
    m = max(a, b)
    n = min(a, b)
    if n == 0:
        return 0
    if m == n:
        return 1
    elif m % n == 0:
        return m // n
    k = m // n
    return k + solve(n, m - n * k)


for _ in range(int(input())):
    a, b = map(int, input().split())
    print(solve(a, b))",0267_A,CODEFORCES,91,Subtractions,"You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).
You've got some number of pairs (ai, bi). How many operations will be performed for each of them?
","input
The first line contains the number of pairs n (1  ≤  n  ≤  1000). Then follow n lines, each line contains a pair of positive integers ai, bi (1  ≤  ai,  bi  ≤  109).
output
Print the sought number of operations for each pair on a single line.
","math, numbertheory",1
"#a, b = map(int, input().split())
def interact(c, d): return max(min((a ^ c) - (b ^ d), 1), -1)

def main():
	def ask(c, d):
		#return interact(c, d)
		print(""?"", c, d, flush = True)
		return int(input())

	relative = ask(0, 0)
	curA = 0
	curB = 0

	for i in range(29, -1, -1):
		q1 = ask(curA ^ 2 ** i, curB)
		q2 = ask(curA, curB ^ 2 ** i)
	
		if q1 == q2:
			if relative == 1:
				curA ^= 2 ** i
			else:
				curB ^= 2 ** i
			relative = q1
		elif q2 == 1:
			curA ^= 2 ** i
			curB ^= 2 ** i
	return curA, curB
print(""!"", *main())",1088_D,CODEFORCES,654,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",1
"n, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

new_arr = []
for i in range(n - 1):
	new_arr.append(arr[i + 1] - arr[i])

new_arr.sort()
print(sum(new_arr[:n - k]))
",1197_C,CODEFORCES,3035,Array Splitting,"You are given a sorted array $$$a_1, a_2, \dots, a_n$$$ (for each index $$$i > 1$$$ condition $$$a_i \ge a_{i-1}$$$ holds) and an integer $$$k$$$.
You are asked to divide this array into $$$k$$$ non-empty consecutive subarrays. Every element in the array should be included in exactly one subarray. 
Let $$$max(i)$$$ be equal to the maximum in the $$$i$$$-th subarray, and $$$min(i)$$$ be equal to the minimum in the $$$i$$$-th subarray. The cost of division is equal to $$$\sum\limits_{i=1}^{k} (max(i) - min(i))$$$. For example, if $$$a = [2, 4, 5, 5, 8, 11, 19]$$$ and we divide it into $$$3$$$ subarrays in the following way: $$$[2, 4], [5, 5], [8, 11, 19]$$$, then the cost of division is equal to $$$(4 - 2) + (5 - 5) + (19 - 8) = 13$$$.
Calculate the minimum cost you can obtain by dividing the array $$$a$$$ into $$$k$$$ non-empty consecutive subarrays. 
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 3 \cdot 10^5$$$).
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$ 1 \le a_i \le 10^9$$$, $$$a_i \ge a_{i-1}$$$). 
","input
Print the minimum cost you can obtain by dividing the array $$$a$$$ into $$$k$$$ nonempty consecutive subarrays. 
output
In the first test we can divide array $$$a$$$ in the following way: $$$[4, 8, 15, 16], [23], [42]$$$. 
","greedy, sortings",4
"n=int(input())
a=[int(x) for x in input().split()]
pro=n*(n-1)//2
dic={}
for item in a:
    if item not in dic:
        dic[item]=1
    else:
        dic[item]+=1
counter=0
for item in dic:
    if 0 in dic and dic[0]>=2:
        print('cslnb')
        break
    if dic[item]>2:
        print('cslnb')
        break
    elif dic[item]==2:
        if counter==1 or item-1 in dic:
            print('cslnb')
            break
        else:
            counter=1
else:
    if (sum(a)-pro)%2==1:
        print('sjfnb')
    else:
        print('cslnb')
",1191_D,CODEFORCES,2215,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy",3
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)

def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))
import math


def main():
    # something
    n = getN()
    nums = getList()
    nums.sort()
    margins = [num - i for i, num in enumerate(nums)]
    for m in margins:
        if m < 0:
            print(""cslnb"")
            return
    flag = False
    if len(nums) > 1:
        if nums[0] == nums[1]:
                flag = True
    for a, b, c in zip(nums, nums[1:], nums[2:]):
        if b == c:
            if a == b or b - a == 1:
                print(""cslnb"")
                return
            if flag:
                print(""cslnb"")
                return
            flag = True


    # if nums[0] == 0 and nums[1] == 0:
    #     print(""cslnb"")
    #     return
    # print(""duel"")
    margin = sum(margins)
    # print(margin)
    # print(nums)
    if margin % 2 == 1:
        print(""sjfnb"")
    else:
        print(""cslnb"")


if __name__ == ""__main__"":
    main()

",1191_D,CODEFORCES,2982,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy",4
"a= int(input())
i=1
amount=a
while amount>i*((10**i)-(10**(i-1))):
    amount =amount - i*((10**i)-(10**(i-1)))
    i=i+1  
x= amount//i
y=amount%i
# print(amount)
# print(i)
# print(x)
# print(y)
if y==0: 
    if i==1:
        print(x%10)
    else:
        print((10**(i-1) + x -1)%10)
else:
    if i==1:
        print(x%10)
    else:
        print(((10**(i-1) + x)//(10**(i-y)))%10)",1177_B,CODEFORCES,1269,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"import math

def get_digit(x, pos):
    s = []
    
    while x > 0:
        s.append(x%10)
        x //= 10
        
    return s[::-1][pos]    

def find_digit(x):
    n     = 0
    next_ = 9 * (10**n) * (n+1)
    
    while next_ <= x:
        x -= next_
   
        n += 1
        next_ = 9 * (10**n) * (n+1)
    
    if x == 0:
        return 9
    
    pos_ = 10 ** n + math.ceil(x / (n+1)) - 1
    
    return get_digit(pos_, (x-1)%(n+1))

# 123456789101112131415
k = int(input())
print(find_digit(k))",1177_B,CODEFORCES,1319,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

n, m = map(int, input().split())

MAX = 0
MIN = 10**18
for i in range(n):
    l = i*(i+1)//2
    r = (n-1-i)*(n-1-i+1)//2
    MAX= max(MAX, l+r)
    MIN = min(MIN, l+r)

ans = 0
for i in range(m):
    x, d = map(int, input().split())
    ans += n*x
    if d  >= 0:
        ans += d*MAX
    else:
        ans += d*MIN
print(ans/n)
",1009_C,CODEFORCES,1795,Annoying Present,"Alice got an array of length $$$n$$$ as a birthday present once again! This is the third year in a row! 
And what is more disappointing, it is overwhelmengly boring, filled entirely with zeros. Bob decided to apply some changes to the array to cheer up Alice.
Bob has chosen $$$m$$$ changes of the following form. For some integer numbers $$$x$$$ and $$$d$$$, he chooses an arbitrary position $$$i$$$ ($$$1 \le i \le n$$$) and for every $$$j \in [1, n]$$$ adds $$$x + d \cdot dist(i, j)$$$ to the value of the $$$j$$$-th cell. $$$dist(i, j)$$$ is the distance between positions $$$i$$$ and $$$j$$$ (i.e. $$$dist(i, j) = |i - j|$$$, where $$$|x|$$$ is an absolute value of $$$x$$$).
For example, if Alice currently has an array $$$[2, 1, 2, 2]$$$ and Bob chooses position $$$3$$$ for $$$x = -1$$$ and $$$d = 2$$$ then the array will become $$$[2 - 1 + 2 \cdot 2,~1 - 1 + 2 \cdot 1,~2 - 1 + 2 \cdot 0,~2 - 1 + 2 \cdot 1]$$$ = $$$[5, 2, 1, 3]$$$. Note that Bob can't choose position $$$i$$$ outside of the array (that is, smaller than $$$1$$$ or greater than $$$n$$$).
Alice will be the happiest when the elements of the array are as big as possible. Bob claimed that the arithmetic mean value of the elements will work fine as a metric.
What is the maximum arithmetic mean value Bob can achieve?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 10^5$$$) — the number of elements of the array and the number of changes.
Each of the next $$$m$$$ lines contains two integers $$$x_i$$$ and $$$d_i$$$ ($$$-10^3 \le x_i, d_i \le 10^3$$$) — the parameters for the $$$i$$$-th change.
","input
Print the maximal average arithmetic mean of the elements Bob can achieve.
output
Your answer is considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$.
","greedy, math",3
"from collections import defaultdict
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
c = list(map(int, input().split()))
f = list(map(int, input().split()))
h = [0] + list(map(int, input().split()))
cnt1 = defaultdict(lambda : 0)
for i in c:
    cnt1[i] += 1
cnt2 = defaultdict(lambda : 0)
for i in f:
    cnt2[i] += 1
ans = 0
for i in cnt2:
    c1, c2 = cnt1[i], cnt2[i]
    dp0 = [0]
    l = 1
    for _ in range(c2):
        dp = [0] * (l + k)
        for i in range(l):
            dp0i = dp0[i]
            for j in range(k + 1):
                dp[i + j] = max(dp[i + j], dp0i + h[j])
        l += k
        dp0 = dp
    ans += dp[min(c1, k * c2)]
print(ans)",0999_F,CODEFORCES,3772,Cards and Joy,"There are $$$n$$$ players sitting at the card table. Each player has a favorite number. The favorite number of the $$$j$$$-th player is $$$f_j$$$.
There are $$$k \cdot n$$$ cards on the table. Each card contains a single integer: the $$$i$$$-th card contains number $$$c_i$$$. Also, you are given a sequence $$$h_1, h_2, \dots, h_k$$$. Its meaning will be explained below.
The players have to distribute all the cards in such a way that each of them will hold exactly $$$k$$$ cards. After all the cards are distributed, each player counts the number of cards he has that contains his favorite number. The joy level of a player equals $$$h_t$$$ if the player holds $$$t$$$ cards containing his favorite number. If a player gets no cards with his favorite number (i.e., $$$t=0$$$), his joy level is $$$0$$$.
Print the maximum possible total joy levels of the players after the cards are distributed. Note that the sequence $$$h_1, \dots, h_k$$$ is the same for all the players.
The first line of input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 500, 1 \le k \le 10$$$) — the number of players and the number of cards each player will get.
The second line contains $$$k \cdot n$$$ integers $$$c_1, c_2, \dots, c_{k \cdot n}$$$ ($$$1 \le c_i \le 10^5$$$) — the numbers written on the cards.
The third line contains $$$n$$$ integers $$$f_1, f_2, \dots, f_n$$$ ($$$1 \le f_j \le 10^5$$$) — the favorite numbers of the players.
The fourth line contains $$$k$$$ integers $$$h_1, h_2, \dots, h_k$$$ ($$$1 \le h_t \le 10^5$$$), where $$$h_t$$$ is the joy level of a player if he gets exactly $$$t$$$ cards with his favorite number written on them. It is guaranteed that the condition $$$h_{t - 1} < h_t$$$ holds for each $$$t \in [2..k]$$$.
Print one integer — the maximum possible total joy levels of the players among all possible card distributions.
In the first example, one possible optimal card distribution is the following:
","input
Thus, the answer is $$$2 + 6 + 6 + 7 = 21$$$.
output
In the second example, no player can get a card with his favorite number. Thus, the answer is $$$0$$$.
",dp,6
"
def make_number(b,chars):
	if len(chars) == 0:
		return """"
	target = chars[0]
	for i in chars:
		if int(b[0]) <= int(i):
			break
		target = i
	chars.remove(target)
	return target + """".join(chars[::-1])


def find_number(b,chars):
	backup_chars = list(chars)
	if len(b) == 1:
		return chars[0]
	elif b[0] in chars:
		chars.remove(b[0])
		num = b[0] + find_number(b[1:],chars)
		if min(num,b) == b and b != num:
			return make_number(b,backup_chars)
		else:
			return num

	else:
		return make_number(b,backup_chars)

a,b = str(input()), str(input())
chars = [i for i in a]
chars.sort()

if len(a) < len(b):
	print("""".join(chars[::-1]))
else:
	print(find_number(b,chars))",915C_,CODEFORCES,4249,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"import sys
lines = int(sys.stdin.readline())
dp = [0] * lines
f = 1
dp[0] = 1

for i in range(lines):
  char_in = sys.stdin.readline()[0]
  if char_in == 'f':
    f += 1
  else:
    # num ways to write the statements
    # the more for loops, the more we can combination
    # any single statement can be the indent of anything previously
    # sum over previous, but also update all of previous
    for j in range(1, f):
      dp[j] = (dp[j] + dp[j- 1]) % 1000000007
print(dp[f - 1])",0909_C,CODEFORCES,3074,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"T = int(input())
for ti in range(T):
    s = input().strip()
    t = input().strip()
    N = len(t)
    for i in range(1, N+1):
        # t1 : [0,i), t2 : [i,N)に分割
        dp = [[0]+[-1]*i for _ in range(len(s)+1)]
        for l, c in enumerate(s):
            for j in range(i+1):
                dp[l+1][j] = dp[l][j]
                # t1[0:j]を構成した時にt2はどこまで構成できるか
                # cをt2に使う
                if dp[l][j] != -1:
                    if i+dp[l][j] < N and t[i+dp[l][j]] == c:
                        dp[l+1][j] = dp[l][j]+1
#                    print(l+1, i+dp[l][j], c, t[i+dp[l][j+1]])
                # cをt1に使う
                if j != 0 and c == t[j-1]:
                    dp[l+1][j] = max(dp[l+1][j], dp[l][j-1])
#                    print(l+1, j+1, dp[l][j])
#        print(ti, i, dp, dp[-1][i])
        if dp[-1][i] == N-i:
            print(""YES"")
            break
    else:
        print(""NO"")

",1303_E,CODEFORCES,3807,Erase Subsequences,"You are given a string $$$s$$$. You can build new string $$$p$$$ from $$$s$$$ using the following operation no more than two times: 
Of course, initially the string $$$p$$$ is empty. 
For example, let $$$s = \text{ababcd}$$$. At first, let's choose subsequence $$$s_1 s_4 s_5 = \text{abc}$$$ — we will get $$$s = \text{bad}$$$ and $$$p = \text{abc}$$$. At second, let's choose $$$s_1 s_2 = \text{ba}$$$ — we will get $$$s = \text{d}$$$ and $$$p = \text{abcba}$$$. So we can build $$$\text{abcba}$$$ from $$$\text{ababcd}$$$.
Can you build a given string $$$t$$$ using the algorithm above?
The first line contains the single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of test cases.
Next $$$2T$$$ lines contain test cases — two per test case. The first line contains string $$$s$$$ consisting of lowercase Latin letters ($$$1 \le |s| \le 400$$$) — the initial string.
The second line contains string $$$t$$$ consisting of lowercase Latin letters ($$$1 \le |t| \le |s|$$$) — the string you'd like to build.
","input
It's guaranteed that the total length of strings $$$s$$$ doesn't exceed $$$400$$$.
output
Print $$$T$$$ answers — one per test case. Print YES (case insensitive) if it's possible to build $$$t$$$ and NO (case insensitive) otherwise.
","dp, strings",6
"x=input()
x,k=x.split()
x=int(x)
k=int(k)
mul=pow(2,k+1,1000000007)
y=(x%1000000007*mul)%1000000007
ans=y
if x!=0:
    ans=(ans%1000000007-(pow(2,k,1000000007)-1)%1000000007)%1000000007
    
print(ans)",0992_C,CODEFORCES,1117,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import sys

SIZE = 105
a = SIZE * [0]
b = SIZE * [0]


lr = input().split()
l = int(lr.pop(0))
r = int(lr.pop(0))

if l == r:
    print(0)

else:
    len1 = 0
    len2 = 0
    while l != 0:
        a[len1] = l % 2
        l = int(l/2)
        len1 += 1

    while r != 0:
        b[len2] = r % 2
        r = int(r/2)
        len2 += 1

    tag = 0
    for i in range(max(len1, len2)-1, 0, -1):
        if b[i] == 1 and a[i] == 0:
            tag = i
            break

    print(pow(2, tag+1)-1)

    				   		 	 					 		 	 			",0276_D,CODEFORCES,861,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"n, U = list(map(int, input().split()))
E = list(map(int, input().split()))

ind_i = 0
prev_ind_k = ind_i + 2

maxi_efficiency = -1
turn = 0
for ind_i in range(0, n - 2):
    ind_j = ind_i + 1
    prev_ind_k = max(prev_ind_k, ind_i + 2)
    Ei = E[ind_i]
    Ej = E[ind_j]
    for ind_k in range(prev_ind_k, n + 1):
        # print(""ind_i, ind_k"", ind_i, ind_k)
        if ind_k == n:
            prev_ind_k = n - 1
            break
        Ek = E[ind_k]
        if (Ek - Ei) > U:
            prev_ind_k = ind_k - 1
            break

        efficiency = (Ek - Ej) / (Ek - Ei)
        # print(""efficiency : "", efficiency)
        if efficiency > maxi_efficiency:
            # print(ind_i, ind_k)
            maxi_efficiency = efficiency

print(maxi_efficiency)

# if (ind_i == n-3 and ind_j == n-2 and ind_k == n-1):
#     break


# n, U = list(map(int, input().split()))
# E = list(map(int, input().split()))

# ind_i = 0
# ind_k = 2

# maxi_efficiency = -1
# turn = 0
# while ind_i < n - 2 and ind_k < n:
#     # print(""ind_i, ind_j : "", ind_i, ind_k)
#     ind_j = ind_i + 1
#     Ei = E[ind_i]
#     Ej = E[ind_j]
#     Ek = E[ind_k]
#     if (Ek - Ei) > U:
#         # print(""too much"")
#         ind_i += 1
#         ind_k = max(ind_k, ind_i + 2)
#         continue
#     else:
#         efficiency = (Ek - Ej) / (Ek - Ei)
#         # print(""efficiency : "", efficiency)
#         if efficiency > maxi_efficiency:
#             print(ind_i, ind_k)
#             maxi_efficiency = efficiency
#         ind_k += 1

# print(maxi_efficiency)

# if (ind_i == n-3 and ind_j == n-2 and ind_k == n-1):
#     break


# n, U = list(map(int, input().split()))
# E = list(map(int, input().split()))

# ind_i = 0

# maxi_efficiency = -1
# turn = 0
# while ind_i < n - 3:
#     ind_j = ind_i + 1
#     Ei = E[ind_i]
#     Ej = E[ind_j]
#     for ind_k in range(ind_j + 1, n):
#         Ek = E[ind_k]
#         if (Ek - Ei) > U:
#             break

#         efficiency = (Ek - Ej) / (Ek - Ei)
#         # print(""efficiency : "", efficiency)
#         if efficiency > maxi_efficiency:
#             maxi_efficiency = efficiency

#     ind_i += 1

# print(maxi_efficiency)

# # if (ind_i == n-3 and ind_j == n-2 and ind_k == n-1):
# #     break
",0957_C,CODEFORCES,2476,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers",4
"#!/usr/bin/python3
import sys
input = sys.stdin.readline
n, m = map(int, input().split())

MOD = m
MAX_N = 10**3

# Construct factorial table
fac = [1] + [0] * MAX_N
for i in range(1, MAX_N+1):
    fac[i] = fac[i-1] * (i) % MOD

fac_inv = [1] + [0] * MAX_N
# Femrmat's little theorem says a**(p-1) mod p == 1
# then, a * a**(p-2) mod p == 1
# it means that a**(p-2) is the inverse element
# Here, Get 1 / n! first
fac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)
for i in range(MAX_N, 1, -1):
    fac_inv[i-1] = fac_inv[i] * i % MOD

def mod_nCr(n, r):
    if n < r or n < 0 or r < 0:
        return 0
    tmp = fac_inv[n-r] * fac_inv[r] % MOD
    return tmp * fac[n] % MOD

pow2 = [0] * (n+1)
pow2[0] = 1
for i in range(1, n+1):
    pow2[i] = pow2[i-1] * 2 % MOD

table = [[0] * 500 for _ in range(500)]
for i in range(500):
    for j in range(i+1):
        table[i][j] = mod_nCr(i, j)

# dp[i-th][j used]
dp = [[0] * (n+1) for _ in range(n)]
for i in range(n):
    dp[i][i+1] = pow2[i]
for i in range(n-1):
    for j in range(i // 2 + 1, n-1):
        if dp[i][j] == 0:
            continue
        dp[i][j] %= MOD
        for k in range(1, n-j):
            if i + k + 1 >= n:
                break
            # create new
            dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k]

ans = sum(dp[-1]) % MOD
print(ans)",1515_E,CODEFORCES,4046,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"n = int(input())
m = input().split()
t = []
for i in range(n):
    m[i] = int(m[i])
    if i == 0:
        t.append(m[i]+1)
    else:
        t.append(max(t[i-1], m[i]+1))
s = t[n-1] - m[n-1] - 1
for i in range(n-2, -1, -1):
    if t[i] < t[i+1]-1:
        t[i] = t[i+1]-1
    s += t[i] - m[i] - 1
print(s)",0924_C,CODEFORCES,1561,Riverside Curio,"Arkady decides to observe a river for n consecutive days. The river's water level on each day is equal to some real value.
Arkady goes to the riverside each day and makes a mark on the side of the channel at the height of the water level, but if it coincides with a mark made before, no new mark is created. The water does not wash the marks away. Arkady writes down the number of marks strictly above the water level each day, on the i-th day this value is equal to mi.
Define di as the number of marks strictly under the water level on the i-th day. You are to find out the minimum possible sum of di over all days. There are no marks on the channel before the first day.
The first line contains a single positive integer n (1 ≤ n ≤ 105) — the number of days.
The second line contains n space-separated integers m1, m2, ..., mn (0 ≤ mi < i) — the number of marks strictly above the water on each day.
Output one single integer — the minimum possible sum of the number of marks strictly below the water level among all days.
In the first example, the following figure shows an optimal case.
","input
Note that on day 3, a new mark should be created because if not, there cannot be 3 marks above water on day 4. The total number of marks underwater is 0 + 0 + 2 + 0 + 3 + 1 = 6.
output
In the second example, the following figure shows an optimal case.
","datastructures, dp, greedy",3
"for ctr in range(1):
    s=input().strip()
    for l in range(len(s),0,-1):
        k=[]
        for i in range(0,len(s)-l+1):
            k.append(s[i:i+l])
        if len(k)!=len(list(set(k))):
            print(l)
            exit()
    print(0)
    
",0023_A,CODEFORCES,3753,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"n, m = map(int,input().split())
X = []
for i in range(n):
    a = input()
    U = [char for char in a]
    X.append(U)
nums = []
for i in range(m):
    t = 0 
    for j in range(n):
        t += int(X[j][i])
    nums.append(t)

for i in range(n):
    ok = True 
    for j in range(m):
        if X[i][j] == '1':
            if nums[j]>1:
                continue 
            else:
                ok = False 
    if ok == True:
        print(""YES"")
        quit()
print(""NO"")",0985_B,CODEFORCES,3238,Switches and Lamps,"You are given n switches and m lamps. The i-th switch turns on some subset of the lamps. This information is given as the matrix a consisting of n rows and m columns where ai, j = 1 if the i-th switch turns on the j-th lamp and ai, j = 0 if the i-th switch is not connected to the j-th lamp.
Initially all m lamps are turned off.
Switches change state only from ""off"" to ""on"". It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards.
It is guaranteed that if you push all n switches then all m lamps will be turned on.
Your think that you have too many switches and you would like to ignore one of them. 
Your task is to say if there exists such a switch that if you will ignore (not use) it but press all the other n - 1 switches then all the m lamps will be turned on.
The first line of the input contains two integers n and m (1 ≤ n, m ≤ 2000) — the number of the switches and the number of the lamps.
The following n lines contain m characters each. The character ai, j is equal to '1' if the i-th switch turns on the j-th lamp and '0' otherwise.
","input
It is guaranteed that if you press all n switches all m lamps will be turned on.
output
Print ""YES"" if there is a switch that if you will ignore it and press all the other n - 1 switches then all m lamps will be turned on. Print ""NO"" if there is no such switch.
",implementation,5
"x,y,z,t1,t2,t3 = map(int, input().split())
stairs = abs(x - y) * t1
lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3
print('YES' if lift <= stairs else 'NO')",1054_A,CODEFORCES,504,Elevator or Stairs?,"Masha lives in a multi-storey building, where floors are numbered with positive integers. Two floors are called adjacent if their numbers differ by one. Masha decided to visit Egor. Masha lives on the floor $$$x$$$, Egor on the floor $$$y$$$ (not on the same floor with Masha).
The house has a staircase and an elevator. If Masha uses the stairs, it takes $$$t_1$$$ seconds for her to walk between adjacent floors (in each direction). The elevator passes between adjacent floors (in each way) in $$$t_2$$$ seconds. The elevator moves with doors closed. The elevator spends $$$t_3$$$ seconds to open or close the doors. We can assume that time is not spent on any action except moving between adjacent floors and waiting for the doors to open or close. If Masha uses the elevator, it immediately goes directly to the desired floor.
Coming out of the apartment on her floor, Masha noticed that the elevator is now on the floor $$$z$$$ and has closed doors. Now she has to choose whether to use the stairs or use the elevator. 
If the time that Masha needs to get to the Egor's floor by the stairs is strictly less than the time it will take her using the elevator, then she will use the stairs, otherwise she will choose the elevator.
Help Mary to understand whether to use the elevator or the stairs.
The only line contains six integers $$$x$$$, $$$y$$$, $$$z$$$, $$$t_1$$$, $$$t_2$$$, $$$t_3$$$ ($$$1 \leq x, y, z, t_1, t_2, t_3 \leq 1000$$$) — the floor Masha is at, the floor Masha wants to get to, the floor the elevator is located on, the time it takes Masha to pass between two floors by stairs, the time it takes the elevator to pass between two floors and the time it takes for the elevator to close or open the doors.
It is guaranteed that $$$x \ne y$$$.
If the time it will take to use the elevator is not greater than the time it will take to use the stairs, print «YES» (without quotes), otherwise print «NO> (without quotes).
You can print each letter in any case (upper or lower).
In the first example:
If Masha goes by the stairs, the time she spends is $$$4 \cdot 4 = 16$$$, because she has to go $$$4$$$ times between adjacent floors and each time she spends $$$4$$$ seconds. 
If she chooses the elevator, she will have to wait $$$2$$$ seconds while the elevator leaves the $$$4$$$-th floor and goes to the $$$5$$$-th. After that the doors will be opening for another $$$1$$$ second. Then Masha will enter the elevator, and she will have to wait for $$$1$$$ second for the doors closing. Next, the elevator will spend $$$4 \cdot 2 = 8$$$ seconds going from the $$$5$$$-th floor to the $$$1$$$-st, because the elevator has to pass $$$4$$$ times between adjacent floors and spends $$$2$$$ seconds each time. And finally, it will take another $$$1$$$ second before the doors are open and Masha can come out. 
Thus, all the way by elevator will take $$$2 + 1 + 1 + 8 + 1 = 13$$$ seconds, which is less than $$$16$$$ seconds, so Masha has to choose the elevator.
","input
In the second example, it is more profitable for Masha to use the stairs, because it will take $$$13$$$ seconds to use the elevator, that is more than the $$$10$$$ seconds it will takes to go by foot.
output
In the third example, the time it takes to use the elevator is equal to the time it takes to walk up by the stairs, and is equal to $$$12$$$ seconds. That means Masha will take the elevator.
",implementation,1
"from collections import *
from itertools import *
from random import  *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from sys import *
from re import *
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]


z, zz = input, lambda: list(map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())


def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer): stdout.write(str(answer))


dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]


###########################---Test-Case---#################################
""""""
 If you Know me , Then you probably don't know me !
""""""
###########################---START-CODING---##############################


n,l,r,x = zzz()
arr = zzz()
cnt=0
for i in range(2,2**n):
    b = bin(i)[2:]
    b='0'*(n-len(b))+b
    s,mx,mi =0, float('-inf'),float('inf')
    for j in range(n):
        if b[j]=='1':
            mx=max(mx,arr[j])
            mi=min(mi,arr[j])
            s+=arr[j]
    if s>=l and s<=r and mx-mi>=x:
        cnt+=1
print(cnt)
",0550_B,CODEFORCES,4428,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"l = list(sorted(list(map(int,input().split()))))
if min(l) == 1 or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==4 and l[2]==4) or(l[0]==2 and l[1] == 2):
    print(""Yes"")
else:
    print(""No"")",0911_C,CODEFORCES,187,Three Garlands,"Mishka is decorating the Christmas tree. He has got three garlands, and all of them will be put on the tree. After that Mishka will switch these garlands on.
When a garland is switched on, it periodically changes its state — sometimes it is lit, sometimes not. Formally, if i-th garland is switched on during x-th second, then it is lit only during seconds x, x + ki, x + 2ki, x + 3ki and so on.
Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland. Formally, Mishka wants to choose three integers x1, x2 and x3 (not necessarily distinct) so that he will switch on the first garland during x1-th second, the second one — during x2-th second, and the third one — during x3-th second, respectively, and during each second starting from max(x1, x2, x3) at least one garland will be lit.
Help Mishka by telling him if it is possible to do this!
The first line contains three integers k1, k2 and k3 (1 ≤ ki ≤ 1500) — time intervals of the garlands.
If Mishka can choose moments of time to switch on the garlands in such a way that each second after switching the garlands on at least one garland will be lit, print YES.
Otherwise, print NO.
","input
In the first example Mishka can choose x1 = 1, x2 = 2, x3 = 1. The first garland will be lit during seconds 1, 3, 5, 7, ..., the second — 2, 4, 6, 8, ..., which already cover all the seconds after the 2-nd one. It doesn't even matter what x3 is chosen. Our choice will lead third to be lit during seconds 1, 4, 7, 10, ..., though.
output
In the second example there is no way to choose such moments of time, there always be some seconds when no garland is lit.
","bruteforce, constructivealgorithms",1
"if __name__ == '__main__':    
    nums = input().split()
    n = int(nums[0])
    v = int(nums[1])

    if n < v+2:
        print(n - 1)
    else:
        print(int(v-1 + (n-v)*(n-v+1)/2))",1113_A,CODEFORCES,681,Sasha and His Trip,"Sasha is a very happy guy, that's why he is always on the move. There are $$$n$$$ cities in the country where Sasha lives. They are all located on one straight line, and for convenience, they are numbered from $$$1$$$ to $$$n$$$ in increasing order. The distance between any two adjacent cities is equal to $$$1$$$ kilometer. Since all roads in the country are directed, it's possible to reach the city $$$y$$$ from the city $$$x$$$ only if $$$x < y$$$. 
Once Sasha decided to go on a trip around the country and to visit all $$$n$$$ cities. He will move with the help of his car, Cheetah-2677. The tank capacity of this model is $$$v$$$ liters, and it spends exactly $$$1$$$ liter of fuel for $$$1$$$ kilometer of the way. At the beginning of the journey, the tank is empty. Sasha is located in the city with the number $$$1$$$ and wants to get to the city with the number $$$n$$$. There is a gas station in each city. In the $$$i$$$-th city, the price of $$$1$$$ liter of fuel is $$$i$$$ dollars. It is obvious that at any moment of time, the tank can contain at most $$$v$$$ liters of fuel.
Sasha doesn't like to waste money, that's why he wants to know what is the minimum amount of money is needed to finish the trip if he can buy fuel in any city he wants. Help him to figure it out!
The first line contains two integers $$$n$$$ and $$$v$$$ ($$$2 \le n \le 100$$$, $$$1 \le v \le 100$$$)  — the number of cities in the country and the capacity of the tank.
Print one integer — the minimum amount of money that is needed to finish the trip.
","input
In the first example, Sasha can buy $$$2$$$ liters for $$$2$$$ dollars ($$$1$$$ dollar per liter) in the first city, drive to the second city, spend $$$1$$$ liter of fuel on it, then buy $$$1$$$ liter for $$$2$$$ dollars in the second city and then drive to the $$$4$$$-th city. Therefore, the answer is $$$1+1+2=4$$$.
output
In the second example, the capacity of the tank allows to fill the tank completely in the first city, and drive to the last city without stops in other cities.
","dp, greedy, math",1
"# from collections import deque

n = int(input())
a = [int(x) for x in input().split()]

a_reverse = a.copy()
status = []
for i in range(n):
    a_reverse[a[i]-1] = i
    status.append(None)


pos = a_reverse[n-1]
status[pos] = False
fails = set()
fails.add(pos)
for i in range(n-1,0,-1):
    i_ = i-1
    pos = a_reverse[i_]
    for k in range((pos+1)%i-1,n,i):
        if k == pos:
            continue
        if k in fails:
            status[pos] = True
            break
    if not status[pos]:
        status[pos] = False
        fails.add(pos)


# BAAAABAB
# ABAAAABBBAABAAB


# status = []
# for i in range(n):
#     status.append(None)

# queue = deque()

# def eval_(pos):
#     pos_status = status[pos]
#     for i in range(n):
#         if i == pos:
#             continue
#         if status[i] != None:
#             continue
#         if  a[i] > a[pos]:
#             continue
#         if (abs(i - pos) % a[i]) == 0:
#             status[i] = not pos_status
#             queue.append(i)

# pos = a.index(n)
# status[pos] = False
# queue.append(pos)
#
# while len(queue) != 0:
#     item = queue.popleft()
#     eval_(item)
#
# print(status)
#
result = """"
for i in status:
    if i == True:
        result=result+""A""
    else:
        result=result+""B""

print(result)




",1033_C,CODEFORCES,3490,Permutation Game,"After a long day, Alice and Bob decided to play a little game. The game board consists of $$$n$$$ cells in a straight line, numbered from $$$1$$$ to $$$n$$$, where each cell contains a number $$$a_i$$$ between $$$1$$$ and $$$n$$$. Furthermore, no two cells contain the same number. 
A token is placed in one of the cells. They take alternating turns of moving the token around the board, with Alice moving first. The current player can move from cell $$$i$$$ to cell $$$j$$$ only if the following two conditions are satisfied: 
Whoever is unable to make a move, loses. For each possible starting position, determine who wins if they both play optimally. It can be shown that the game is always finite, i.e. there always is a winning strategy for one of the players.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of numbers.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$). Furthermore, there are no pair of indices $$$i \neq j$$$ such that $$$a_i = a_j$$$.
","input
Print $$$s$$$ — a string of $$$n$$$ characters, where the $$$i$$$-th character represents the outcome of the game if the token is initially placed in the cell $$$i$$$. If Alice wins, then $$$s_i$$$ has to be equal to ""A""; otherwise, $$$s_i$$$ has to be equal to ""B"". 
output
In the first sample, if Bob puts the token on the number (not position): 
","bruteforce, dp, games",5
"x, y, z, t1, t2, t3 = map( int, input().split() )
elevator = t2 * ( abs( x - y ) + abs( z - x ) ) + 3 * t3
stairs = t1 * abs( x - y )
if elevator > stairs:
    print( 'NO' )
else:
    print( 'YES' )
",1054_A,CODEFORCES,508,Elevator or Stairs?,"Masha lives in a multi-storey building, where floors are numbered with positive integers. Two floors are called adjacent if their numbers differ by one. Masha decided to visit Egor. Masha lives on the floor $$$x$$$, Egor on the floor $$$y$$$ (not on the same floor with Masha).
The house has a staircase and an elevator. If Masha uses the stairs, it takes $$$t_1$$$ seconds for her to walk between adjacent floors (in each direction). The elevator passes between adjacent floors (in each way) in $$$t_2$$$ seconds. The elevator moves with doors closed. The elevator spends $$$t_3$$$ seconds to open or close the doors. We can assume that time is not spent on any action except moving between adjacent floors and waiting for the doors to open or close. If Masha uses the elevator, it immediately goes directly to the desired floor.
Coming out of the apartment on her floor, Masha noticed that the elevator is now on the floor $$$z$$$ and has closed doors. Now she has to choose whether to use the stairs or use the elevator. 
If the time that Masha needs to get to the Egor's floor by the stairs is strictly less than the time it will take her using the elevator, then she will use the stairs, otherwise she will choose the elevator.
Help Mary to understand whether to use the elevator or the stairs.
The only line contains six integers $$$x$$$, $$$y$$$, $$$z$$$, $$$t_1$$$, $$$t_2$$$, $$$t_3$$$ ($$$1 \leq x, y, z, t_1, t_2, t_3 \leq 1000$$$) — the floor Masha is at, the floor Masha wants to get to, the floor the elevator is located on, the time it takes Masha to pass between two floors by stairs, the time it takes the elevator to pass between two floors and the time it takes for the elevator to close or open the doors.
It is guaranteed that $$$x \ne y$$$.
If the time it will take to use the elevator is not greater than the time it will take to use the stairs, print «YES» (without quotes), otherwise print «NO> (without quotes).
You can print each letter in any case (upper or lower).
In the first example:
If Masha goes by the stairs, the time she spends is $$$4 \cdot 4 = 16$$$, because she has to go $$$4$$$ times between adjacent floors and each time she spends $$$4$$$ seconds. 
If she chooses the elevator, she will have to wait $$$2$$$ seconds while the elevator leaves the $$$4$$$-th floor and goes to the $$$5$$$-th. After that the doors will be opening for another $$$1$$$ second. Then Masha will enter the elevator, and she will have to wait for $$$1$$$ second for the doors closing. Next, the elevator will spend $$$4 \cdot 2 = 8$$$ seconds going from the $$$5$$$-th floor to the $$$1$$$-st, because the elevator has to pass $$$4$$$ times between adjacent floors and spends $$$2$$$ seconds each time. And finally, it will take another $$$1$$$ second before the doors are open and Masha can come out. 
Thus, all the way by elevator will take $$$2 + 1 + 1 + 8 + 1 = 13$$$ seconds, which is less than $$$16$$$ seconds, so Masha has to choose the elevator.
","input
In the second example, it is more profitable for Masha to use the stairs, because it will take $$$13$$$ seconds to use the elevator, that is more than the $$$10$$$ seconds it will takes to go by foot.
output
In the third example, the time it takes to use the elevator is equal to the time it takes to walk up by the stairs, and is equal to $$$12$$$ seconds. That means Masha will take the elevator.
",implementation,1
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def matching(n,m,path):
    # Hopkrocft Karp O(EV^0.5)
    match1 = [-1]*n
    match2 = [-1]*m
    for node in range(n):
        for nei in path[node]:
            if match2[nei] == -1:
                match1[node] = nei
                match2[nei] = node
                break
    while 1:
        bfs = [node for node in range(n) if match1[node] == -1]
        depth = [-1]*n
        for node in bfs:
            depth[node] = 0

        for node in bfs:
            for nei in path[node]:
                next_node = match2[nei]
                if next_node == -1:
                    break
                if depth[next_node] == -1:
                    depth[next_node] = depth[node]+1
                    bfs.append(next_node)
            else:
                continue
            break
        else:
            break
        pointer = [len(c) for c in path]
        dfs = [node for node in range(n) if depth[node] == 0]
        while dfs:
            node = dfs[-1]
            while pointer[node]:
                pointer[node] -= 1
                nei = path[node][pointer[node]]
                next_node = match2[nei]
                if next_node == -1:
                    while nei != -1:
                        node = dfs.pop()
                        match2[nei],match1[node],nei = node,nei,match1[node]
                    break
                elif depth[node]+1 == depth[next_node]:
                    dfs.append(next_node)
                    break
            else:
                dfs.pop()
    return n-match1.count(-1)

def main():
    n,m = map(int,input().split())
    edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)]
    ans = float(""inf"")
    for centre in range(n):
        path = [[] for _ in range(n)]
        cost = 2*n-1
        extra = m
        for u,v in edg:
            if u == centre or v == centre:
                cost -= 1
                extra -= 1
            else:
                path[u].append(v)
        maxMatch = matching(n,n,path)
        extra -= maxMatch
        cost += n-1-maxMatch+extra
        ans = min(ans,cost)
    print(ans)

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",0387_D,CODEFORCES,3767,George and Interesting Graph,"George loves graphs. Most of all, he loves interesting graphs. We will assume that a directed graph is interesting, if it meets the following criteria: 
However, not everything's that simple. George got a directed graph of n vertices and m arcs as a present. The graph didn't have any multiple arcs. As George loves interesting graphs, he wants to slightly alter the presented graph and transform it into an interesting one. In one alteration he can either remove an arbitrary existing arc from the graph or add an arbitrary arc to the graph. 
George wonders: what is the minimum number of changes that he needs to obtain an interesting graph from the graph he's got as a present? Help George and find the answer to the question.
The first line contains two space-separated integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ 1000) — the number of vertices and arcs in the presented graph.
Each of the next m lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n) — the descriptions of the graph's arcs. Pair (ai, bi) means that the graph contains an arc from vertex number ai to vertex number bi. It is guaranteed that the presented graph doesn't contain multiple arcs.
Assume that the grah vertices are numbered 1 through n.
Print a single integer — the answer to George's question.
","input
For more information about directed graphs, please visit: http://en.wikipedia.org/wiki/Directed_graph
output
In the first sample the graph already is interesting, its center is vertex 3.
",graphmatchings,6
"import sys
from array import array  # noqa: F401


def readline(): return sys.stdin.buffer.readline().decode('utf-8')


n, k = map(int, readline().split())
mod = 998244353

if k == 1:
    print(0)
    exit()


dp1 = [array('i', [0])*n for _ in range(n)]
dp2 = [array('i', [0])*n for _ in range(n)]
dp1[0][0] = 1

for i in range(n-1):
    for j in range(i+1):
        for l in range(j+1):
            dp2[j][0] += dp1[j][l]
            if dp2[j][0] >= mod:
                dp2[j][0] -= mod

            dp2[j+1 if j == l else j][l+1] += dp1[j][l]
            if dp2[j+1 if j == l else j][l+1] >= mod:
                dp2[j+1 if j == l else j][l+1] -= mod

            dp1[j][l] = 0

    dp1, dp2 = dp2, dp1

ans = 0
for i in range(1, n+1):
    t = (k-1) // i
    if t == 0:
        break

    dps1 = array('i', [0])*(t+1)
    dps2 = array('i', [0])*(t+1)
    dps1[0] = 1

    for j in range(n-1):
        for l in range(min(j+1, t)):
            dps2[0] += dps1[l]
            if dps2[0] >= mod:
                dps2[0] -= mod

            dps2[l+1] += dps1[l]
            if dps2[l+1] >= mod:
                dps2[l+1] -= mod

            dps1[l] = 0

        dps1, dps2 = dps2, dps1

    x = sum(dp1[i-1]) % mod
    ans = (ans + x * sum(dps1[:-1])) % mod

print(ans * 2 % mod)
",1027_E,CODEFORCES,3408,Inverse Coloring,"You are given a square board, consisting of $$$n$$$ rows and $$$n$$$ columns. Each tile in it should be colored either white or black.
Let's call some coloring beautiful if each pair of adjacent rows are either the same or different in every position. The same condition should be held for the columns as well.
Let's call some coloring suitable if it is beautiful and there is no rectangle of the single color, consisting of at least $$$k$$$ tiles.
Your task is to count the number of suitable colorings of the board of the given size.
Since the answer can be very large, print it modulo $$$998244353$$$.
A single line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 500$$$, $$$1 \le k \le n^2$$$) — the number of rows and columns of the board and the maximum number of tiles inside the rectangle of the single color, respectively.
Print a single integer — the number of suitable colorings of the board of the given size modulo $$$998244353$$$.
Board of size $$$1 \times 1$$$ is either a single black tile or a single white tile. Both of them include a rectangle of a single color, consisting of $$$1$$$ tile.
","input
Here are the beautiful colorings of a board of size $$$2 \times 2$$$ that don't include rectangles of a single color, consisting of at least $$$3$$$ tiles:
output
The rest of beautiful colorings of a board of size $$$2 \times 2$$$ are the following:
","combinatorics, dp, math",5
"x,k=map(int,input().split())
print(0 if x==0 else (x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7))",0992_C,CODEFORCES,1013,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"n = int(input())
x, y = map(int, input().split())
na = abs(x - 1) + abs(y - 1)
nb = abs(n - x) + abs(n - y)
if na <= nb:
    print(""white"")
else:
    print(""black"")
",1075_A,CODEFORCES,556,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
b = [abs(x) for x in a] 
if n == 1:
    ans = a[0]
elif all(x > 0 for x in a) or all(x < 0 for x in a):
    b.sort()
    ans = sum(b) - 2 * b[0]
else:
    ans = sum(b)
print(ans)
",1038_D,CODEFORCES,2812,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation",4
"MOD=1000000007

x,k=map(int,raw_input().split())

if x>0:
	ans=(pow(2,k+1,MOD)*x)%MOD
	ans=(ans-pow(2,k,MOD))%MOD
	ans=(ans+1)%MOD
else:
	ans=0

print(ans)",0992_C,CODEFORCES,1033,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"n=int(raw_input())
arr=list(map(int,raw_input().split()))
dict1={}
arr1=[0]*n
for i in range(n):
	arr1[arr[i]-1]=i
for i in range(n):
	dict1[i+1]=[]
for i in range(n):
	for j in range(i-arr[i],-1,-arr[i]):
		if(arr[j]>arr[i]):
			dict1[arr[i]].append(arr[j])
	for j in range(i+arr[i],n,arr[i]):
		if(arr[j]>arr[i]):
			dict1[arr[i]].append(arr[j])
strarr=['.']*n
#print(dict1)
for i in range(n-1,-1,-1):
	if(len(dict1[arr[arr1[i]]])==0):
		strarr[arr1[i]]='B'
	else:
		if(len(dict1[arr[arr1[i]]])==1 and len(dict1[dict1[arr[arr1[i]]][0]])==0):
			strarr[arr1[i]]='A'
		else:
			flag=0
			for j in dict1[arr[arr1[i]]]:
				#print(j)
				#print(arr1[j-1])
				if(strarr[arr1[j-1]]=='B'):
					flag=1
					break
			if(flag==1):
				strarr[arr1[i]]='A'
			else:
				strarr[arr1[i]]='B'
	#print(*strarr)
print("""".join(x for x in strarr))

",1033_C,CODEFORCES,3484,Permutation Game,"After a long day, Alice and Bob decided to play a little game. The game board consists of $$$n$$$ cells in a straight line, numbered from $$$1$$$ to $$$n$$$, where each cell contains a number $$$a_i$$$ between $$$1$$$ and $$$n$$$. Furthermore, no two cells contain the same number. 
A token is placed in one of the cells. They take alternating turns of moving the token around the board, with Alice moving first. The current player can move from cell $$$i$$$ to cell $$$j$$$ only if the following two conditions are satisfied: 
Whoever is unable to make a move, loses. For each possible starting position, determine who wins if they both play optimally. It can be shown that the game is always finite, i.e. there always is a winning strategy for one of the players.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of numbers.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$). Furthermore, there are no pair of indices $$$i \neq j$$$ such that $$$a_i = a_j$$$.
","input
Print $$$s$$$ — a string of $$$n$$$ characters, where the $$$i$$$-th character represents the outcome of the game if the token is initially placed in the cell $$$i$$$. If Alice wins, then $$$s_i$$$ has to be equal to ""A""; otherwise, $$$s_i$$$ has to be equal to ""B"". 
output
In the first sample, if Bob puts the token on the number (not position): 
","bruteforce, dp, games",5
"import sys
import math
from math import *
from collections import Counter,defaultdict
from io import BytesIO, IOBase
from collections import deque


def rec(i,j,k):
	if (i == rl and j == bl) or (i == rl and k == gl) or (k == gl and j == bl):
		return 0
	if dp[i][j][k] != -1:
		return dp[i][j][k]
	else:
		x = r[i]*b[j]
		y = b[j]*g[k]
		z = r[i] * g[k]
		if x>0:
			x += rec(i+1,j+1,k)
		if y>0:
			y += rec(i,j+1,k+1)
		if z>0:
			z += rec(i+1,j,k+1)

		dp[i][j][k] = max(x,y,z)
		return dp[i][j][k]

def main():
	global r,g,b,rl,bl,gl,dp

	rl,bl,gl = list(map(int, input().split()))
	r = list(map(int, input().split())) + [0]
	b = list(map(int, input().split())) + [0]
	g = list(map(int, input().split())) + [0]
	cnt =3
	i =j = k = 0
	ans = 0
	dp=[[[-1 for i in range(gl+1)] for j in range(bl+1)]for k in range(rl+1)] 
	r.sort(reverse = True)
	b.sort(reverse = True)
	g.sort(reverse = True)

	print(rec(i,j,k))
	


main()",1398_D,CODEFORCES,3959,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"import os
import sys
from io import BytesIO, IOBase
import heapq as h 
from bisect import bisect_left, bisect_right
import time
 
from types import GeneratorType
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
from collections import defaultdict as dd, deque as dq, Counter as dc
import math, string
 
start_time = time.time()
 
def getInts():
    return [int(s) for s in input().split()]
 
def getInt():
    return int(input())
 
def getStrs():
    return [s for s in input().split()]
 
def getStr():
    return input()
 
def listStr():
    return list(input())
def getMat(n):
    return [getInts() for _ in range(n)]
def get_ints():return map(int, sys.stdin.readline().split())

n,k=map(int,input().split())
knight=list(map(int,input().split()))
coins=list(map(int,input().split()))
d={};ans=[0]*n
for i in range(n):
  knight[i]=[knight[i],i]
for i in coins:
  d[i]=d.get(i,0)+1
c=coins[:]
#heapq.heapify(c)
knight=sorted(knight,key=lambda x:x[0])
#print(knight)
ans2=[];ans=coins[:]
if k==0:print(*ans)
else:
 for i in range(n):
  ans1=0
  if len(ans2)<k:ans1=sum(ans2)
  else:ans2=sorted(ans2)[-k:];ans1+=sum(ans2)
  #print(ans1)
  ans[knight[i][1]]+=ans1
  ans2.append(coins[knight[i][1]])
 print(*ans)
",0994_B,CODEFORCES,2637,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings",4
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

# ------------------------------


def main():
    for _ in range(N()):
        n, m = RL()
        arr = []
        for _ in range(n): arr.append(RLL())

        larr = [list(i) for i in zip(*arr)]
        larr.sort(key = lambda a: max(a), reverse=1)
        larr = larr[:n]

        res = 0

        def dfs(lst, pos=0):
            nonlocal res
            if pos==min(n, len(larr)):
                res = max(res, sum(lst))
                return

            for i in range(n):
                now = larr[pos][i:n]+larr[pos][0:i]
                nex = [max(now[j], lst[j]) for j in range(n)]
                dfs(nex, pos+1)

        dfs([0]*n)
        print(res)



if __name__ == ""__main__"":
    main()

",1209_E1,CODEFORCES,4621,Rotate Columns (easy version),"This is an easier version of the next problem. The difference is only in constraints.
You are given a rectangular $$$n \times m$$$ matrix $$$a$$$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want (possibly zero). You can perform this operation to a column multiple times.
After you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $$$i$$$-th row it is equal $$$r_i$$$. What is the maximal possible value of $$$r_1+r_2+\ldots+r_n$$$?
The first line contains an integer $$$t$$$ ($$$1 \le t \le 40$$$), the number of test cases in the input.
The first line of each test case contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 4$$$, $$$1 \le m \le 100$$$) — the number of rows and the number of columns in the given matrix $$$a$$$. 
Each of the following $$$n$$$ lines contains $$$m$$$ integers, the elements of $$$a$$$ ($$$1 \le a_{i, j} \le 10^5$$$).
Print $$$t$$$ integers: answers for all test cases in the order they are given in the input.
","input
In the first test case, you can shift the third column down by one, this way there will be $$$r_1 = 5$$$ and $$$r_2 = 7$$$.
output
In the second case you can don't rotate anything at all, this way there will be $$$r_1 = r_2 = 10$$$ and $$$r_3 = 9$$$.
","bitmasks, bruteforce, dp, greedy, sortings",7
"a = input()
b = input()
digits = {}
def greedy(digits,s):
    for i in range(9,-1,-1):
        d = str(i)
        if d in digits:
            while digits[d] > 0:
                s += d
                digits[d] -= 1
    return s
for d in a:
    if d in digits:
        digits[d] += 1
    else:
        digits[d] = 1
if len(a) < len(b):
    print(greedy(digits,""""))
else:
    ind = 0
    cur = """"
    back = False
    done = False
    while 1:
        if ind == len(a) or done == True:
            break
        found = False
        for i in range(9,-1,-1):
            x = str(i)
            if i == int(b[ind]) and x in digits and digits[x] > 0:
                found = True
                digits[x] -= 1
                cur += x
                break
            elif i < int(b[ind]) and x in digits and digits[x] > 0:
                found = True
                done = True
                digits[x] -= 1
                cur += x
                print(greedy(digits,cur))
                break
        if found == False:
            back = True
            break
        ind += 1
    
    if back == False and done == False:
        print(cur)
    elif done == False:
        for i in range(ind-1,-1,-1):
            digits[cur[i]] += 1
            for j in range(9,-1,-1):
                d = str(j)
                if j < int(b[i]) and d in digits and digits[d] > 0:
                    done = True
                    s = cur[:i]
                    s += d
                    digits[d] -= 1
                    print(greedy(digits,s))
                    break
            if done:
                break",915C_,CODEFORCES,4256,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"import sys
input = sys.stdin.readline

############ ---- Input Functions ---- ############
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def cint(c):
    return ord(c) - 96
####################################################

def find_min_weight(n, k, stages):
    n = len(stages)
    min_weight = float('inf')

    def backtrack(s, w, t):
        nonlocal min_weight 

        if t >= k:
            min_weight = min(min_weight, w)
            return

        if s >= n - 1:
            return

        for i in range(s+1, n, 1):
            if stages[i] - stages[s] > 1:
                backtrack(i, w+stages[i], t+1)

    backtrack(0, stages[0], 1)

    if min_weight == float('inf'):
        return -1

    return min_weight    


n, k = inlt()
stages = list(set(map(cint, insr())))
stages.sort()
print(find_min_weight(n, k, stages))
",1011_A,CODEFORCES,1822,Stages,"Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string — concatenation of letters, which correspond to the stages.
There are $$$n$$$ stages available. The rocket must contain exactly $$$k$$$ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.
For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z' — $$$26$$$ tons.
Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.
The first line of input contains two integers — $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 50$$$) – the number of available stages and the number of stages to use in the rocket.
The second line contains string $$$s$$$, which consists of exactly $$$n$$$ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.
Print a single integer — the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.
In the first example, the following rockets satisfy the condition:
Rocket ""adx"" has the minimal weight, so the answer is $$$29$$$.
","input
In the second example, target rocket is ""belo"". Its weight is $$$2+5+12+15=34$$$.
output
In the third example, $$$n=k=2$$$, so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.
","greedy, implementation, sortings",3
"a = input()
b = input()
la = [int(x) for x in a]
res = []
la.sort()
la = la[::-1]
lb = [int(x) for x in b]
cnt = [0] * 20

def check():
    tres = 0
    for x in range(len(res)):
        tres *= 10
        tres += int(res[x])
    return tres <= int(b)
if len(a) < len(b):
    for i in range(len(la)):
        print(la[i], end = '')
    print()
else:
    for i in range(len(la)):
        cnt[la[i]] += 1
    flag = 0
    for i in range(len(lb)):
        if flag == 0 and cnt[lb[i]]:
            res.append(lb[i])
            cnt[lb[i]] -= 1
        else:
            flag = i - 1
            for j in range(lb[i] - 1, -1, -1):
                if cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
                    break
            for j in range(9, -1, -1):
                while cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
            break
    while not check():
        temp = []
        cnt = [0] * 20
        for x in range(flag):
            temp.append(res[x])
            cnt[res[x]] -= 1
        for i in la:
            cnt[i] += 1
        ##print(""cnt = "", cnt)
        res = temp
        ##print(flag, res)
        for v in range(lb[flag] - 1, -1, -1):
            if cnt[v]:
                res.append(v)
                cnt[v] -= 1
                break
        for v in range(9, -1, -1):
            while cnt[v]:
                res.append(v)
                cnt[v] -= 1
        ##print(flag, res)
        flag -= 1
    for i in range(len(res)):
        print(res[i], end = '')
    print()",915C_,CODEFORCES,4221,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"n, s = list(map(int, input().split()))

def sum_of_digits(n):
	ans = 0
	for c in str(n):
		ans += int(c)
	return ans
m = s + 10 - s%10

while m - sum_of_digits(m) < s:
	m += 10
if m <= n:
	print(n - m + 1)
else:
	print(0)
",0817_C,CODEFORCES,978,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"# Nome: Guilherme Lima Hernandez Rincão
# RA: 169052
# B - Adding Reversed Numbers

from operator import xor

r = list(map(int, input().split()))

ms = xor(r[0], r[1])

max = 0
sum = 1

while ms > 0:
    ms >>= 1
    max += sum
    sum <<= 1

print(max)

   			 			 	      		 		 			 			",0276_D,CODEFORCES,853,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"
def construct_tree(n,d, k):
    nodes = []
    edges = []

    if d > n - 1:
        return None
    
    if k == 1 and n > 2:
        return None

    for i in range(1, d+2):
        current_deg = k - 1 if i == 1 or i == d + 1 else k - 2
        current_depth =  min(i-1, d-i+1)
        if current_depth and current_deg:
            nodes.append([i, min(i-1, d-i+1), current_deg])
        if i < d + 1:
            edges.append([i, i+1])

    current_nodes_count = d + 2
    pos = 0
    while current_nodes_count < n + 1:

        if pos >= len(nodes):
            return None

        current = nodes[pos]

        if not current[2]:
            pos += 1
            if pos == len(nodes):
                break
            continue

        if current[1] - 1 and k - 1:
            nodes.append([current_nodes_count, current[1] - 1, k - 1])
        edges.append([current[0], current_nodes_count])
        current[2] -= 1
        current_nodes_count += 1
    
    if current_nodes_count == n + 1:
        return edges
    return None



n, d, k = [int(val) for val in input().split()]
edges = construct_tree(n, d, k)
if edges:
    print('YES')
    print('\n'.join(['{0} {1}'.format(e[0], e[1]) for e in edges]))
else:
    print('NO')

",1003_E,CODEFORCES,3372,Tree Constructing,"You are given three integers $$$n$$$, $$$d$$$ and $$$k$$$.
Your task is to construct an undirected tree on $$$n$$$ vertices with diameter $$$d$$$ and degree of each vertex at most $$$k$$$, or say that it is impossible.
An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Diameter of a tree is the maximum length of a simple path (a path in which each vertex appears at most once) between all pairs of vertices of this tree.
Degree of a vertex is the number of edges incident to this vertex (i.e. for a vertex $$$u$$$ it is the number of edges $$$(u, v)$$$ that belong to the tree, where $$$v$$$ is any other vertex of a tree).
The first line of the input contains three integers $$$n$$$, $$$d$$$ and $$$k$$$ ($$$1 \le n, d, k \le 4 \cdot 10^5$$$).
","input
If there is no tree satisfying the conditions above, print only one word ""NO"" (without quotes).
output
Otherwise in the first line print ""YES"" (without quotes), and then print $$$n - 1$$$ lines describing edges of a tree satisfying the conditions above. Vertices of the tree must be numbered from $$$1$$$ to $$$n$$$. You can print edges and vertices connected by an edge in any order. If there are multiple answers, print any of them.1
","constructivealgorithms, graphs",5
"line1 = str(input());
line2 = str(input());

truePosition = 0;
fakePosition = 0;
questionMarks = 0;
for i in range(len(line1)):
	if line1[i] == ""+"":
		truePosition += 1;
	if line1[i] == ""-"":
		truePosition -= 1;
	if line2[i] == ""+"":
		fakePosition += 1;
	if line2[i] == ""-"":
		fakePosition -= 1;
	if line2[i] == ""?"":
		questionMarks += 1;
		
distanceToMove = abs(truePosition - fakePosition);
#print(""Distance: "", distanceToMove);


def factorial(x):
	if x == 0:
		return 1;
	else:
		return x * factorial(x-1);
		
def probToMove(dist, questionMarks):
	if(dist > questionMarks):
		return float(0);
	reducedDist = questionMarks - dist;
	if(reducedDist % 2 != 0):
		return float(0);
	dist = reducedDist//2 + dist;
	headsFlips = 1;
	headsOrders = factorial(questionMarks) / ((factorial(dist) *factorial(questionMarks-dist)));
	#print(""HeadsFlips:"", headsFlips);
	#print(""headsOrders:"", headsOrders);
	totalPossibilities = 2**questionMarks;
	#print(""totalPossibilities:"", totalPossibilities);
	return headsFlips * headsOrders / totalPossibilities;
	
print(probToMove(distanceToMove, questionMarks));",0476_B,CODEFORCES,4330,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"def max_profit(n,k,l,d):
    a=[]
    p,i=0,-1
    while(len(a)!=k-1):
        p+=1
        i+=1
        if l[i] in d:
            a.append(p)
            p=0
            d.remove(l[i])
    a.append(n-sum(a))
    print(*a)


n,k=map(int,input().split())
l=list(map(int,input().split()))
d=sorted(l,reverse=True)[:k]
print(sum(d))
max_profit(n,k,l,d)",1006_B,CODEFORCES,2718,Polycarp's Practice,"Polycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.
Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.
The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\max\limits_{l \le i \le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.
You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.
For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the number of problems and the number of days, respectively.
The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).
In the first line of the output print the maximum possible total profit.
In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \dots, t_k$$$ ($$$t_1 + t_2 + \dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.
If there are many possible answers, you may print any of them.
The first example is described in the problem statement.
","input
In the second example there is only one possible distribution.
output
In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.
","greedy, implementation, sortings",4
"t = int(input())

def get_max(n):
    ans = 0
    while n:
        ans = 4 * ans + 1
        n = n - 1
        if ans > 10**19:
            break
    return ans

for _ in range(t):
    n, k = map(int, input().split())
    if n == 1:
        if k == 1:
            print(""YES 0"")
        else:
            print(""NO"")
    elif n == 2:
        if k <= 2:
            print(""YES 1"")
        elif k != 3 and k <= 5:
            print(""YES 0"")
        else:
            print(""NO"")
    else:
        siz = n - 1
        l = 1
        cnt = 3
        while siz:
            if l <= k < l+cnt:
                print(""YES {}"".format(siz))
                break
            l = l + cnt
            cnt = 2 * cnt + 1
            siz = siz - 1
        else:
            if k <= get_max(n):
                print(""YES 0"")
            else:
                print(""NO"")
",1080_D,CODEFORCES,2034,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",3
"n=int(input())
a=b=[]
k=0
for _ in range(n): 
	a.append(input())
for i in range(n):
	t=input()
	if t in a:
		a.remove(t)
print(len(a))",1000_A,CODEFORCES,1732,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation",3
"import sys

def main():

    n,k=map(int,sys.stdin.readline().strip().split())
    arr=list(map(int,sys.stdin.readline().strip().split()))
    arr.sort()
    dic={}
    for a in arr:
        if a/k not in dic:
            dic[a]=1
    
    print(len(dic))

main()",0274_A,CODEFORCES,2401,k-Multiple Free Set,"A k-multiple free set is a set of integers where there is no pair of integers where one is equal to another integer multiplied by k. That is, there are no two integers x and y (x < y) from the set, such that y = x·k.
You're given a set of n distinct positive integers. Your task is to find the size of it's largest k-multiple free subset.
The first line of the input contains two integers n and k (1 ≤ n ≤ 105, 1 ≤ k ≤ 109). The next line contains a list of n distinct positive integers a1, a2, ..., an (1 ≤ ai ≤ 109).
All the numbers in the lines are separated by single spaces.
","input
On the only line of the output print the size of the largest k-multiple free subset of {a1, a2, ..., an}.
output
In the sample input one of the possible maximum 2-multiple free subsets is {4, 5, 6}.
","binarysearch, greedy, sortings",4
"import sys

def dp(ri, gi, bi):
    if ri>r or gi>g or bi>b:
        return 0

    if not list_memo[ri][gi][bi]==-1:
        return list_memo[ri][gi][bi]
    
    list_memo[ri][gi][bi] = max(dp(ri+1, gi+1, bi)+r_c[ri]*g_c[gi], dp(ri+1, gi, bi+1)+r_c[ri]*b_c[bi], dp(ri, gi+1, bi+1)+g_c[gi]*b_c[bi])
    return list_memo[ri][gi][bi]


r, g, b = map(int, sys.stdin.readline().split())

r_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)
g_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)
b_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)


list_memo = [[[-1]*(b+1) for _ in range(g+1)] for _ in range(r+1)]

print(dp(0, 0, 0))",1398_D,CODEFORCES,3968,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353
# from sys import stdin
# input = stdin.readline
def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""../output.txt"", ""w"")
except:
    pass

n=L()[0]
if n<6:
    print(-1)
else:
    print(1,2)
    print(1,3)
    print(1,4)
    for i in range(5,n+1):
        print(2,i)
for i in range(1,n):
    print(i,i+1)




endtime = time.time()
# print(f""Runtime of the program is {endtime - starttime}"")",0959_C,CODEFORCES,1582,Mahmoud and Ehab and the wrong algorithm,"Mahmoud was trying to solve the vertex cover problem on trees. The problem statement is:
Given an undirected tree consisting of n nodes, find the minimum number of vertices that cover all the edges. Formally, we need to find a set of vertices such that for each edge (u, v) that belongs to the tree, either u is in the set, or v is in the set, or both are in the set. Mahmoud has found the following algorithm:
The depth of a node in a tree is the number of edges in the shortest path between this node and the root. The depth of the root is 0.
Ehab told Mahmoud that this algorithm is wrong, but he didn't believe because he had tested his algorithm against many trees and it worked, so Ehab asked you to find 2 trees consisting of n nodes. The algorithm should find an incorrect answer for the first tree and a correct answer for the second one.
The only line contains an integer n (2 ≤ n ≤ 105), the number of nodes in the desired trees.
The output should consist of 2 independent sections, each containing a tree. The algorithm should find an incorrect answer for the tree in the first section and a correct answer for the tree in the second. If a tree doesn't exist for some section, output ""-1"" (without quotes) for that section only.
If the answer for a section exists, it should contain n - 1 lines, each containing 2 space-separated integers u and v (1 ≤ u, v ≤ n), which means that there's an undirected edge between node u and node v. If the given graph isn't a tree or it doesn't follow the format, you'll receive wrong answer verdict.
If there are multiple answers, you can print any of them.
In the first sample, there is only 1 tree with 2 nodes (node 1 connected to node 2). The algorithm will produce a correct answer in it so we printed  - 1 in the first section, but notice that we printed this tree in the second section.
","input
In the second sample:
output
In the first tree, the algorithm will find an answer with 4 nodes, while there exists an answer with 3 nodes like this:  In the second tree, the algorithm will find an answer with 3 nodes which is correct: 
","constructivealgorithms, trees",3
"#winners never quit, quiters never win
from collections import deque as de
import math
from collections import Counter as cnt
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    
# A optimized school method based 
# Python3 program to check 
# if a number is prime 


def isPrime(n) : 

	# Corner cases 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	# This is checked so that we can skip 
	# middle five numbers in below loop 
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    # create an empty list and later I will
    # run a for loop with range() function using the append() method to add elements to the list.
    prime_factors = []

    # First get the number of two's that divide number
    # i.e the number of 2's that are in the factors
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2

    # After the above while loop, when number has been
    # divided by all the 2's - so the number must be odd at this point
    # Otherwise it would be perfectly divisible by 2 another time
    # so now that its odd I can skip 2 ( i = i + 2) for each increment
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i


    # Here is the crucial part.
    # First quick refreshment on the two key mathematical conjectures of Prime factorization of any non-Prime number
    # Which is - 1. If n is not a prime number AT-LEAST one Prime factor would be less than sqrt(n)
    # And - 2. If n is not a prime number - There can be AT-MOST 1 prime factor of n greater than sqrt(n).
    # Like 7 is a prime-factor for 14 which is greater than sqrt(14)
    # But if the above loop DOES NOT go beyond square root of the initial n.
    # Then how does that greater than sqrt(n) prime-factor
    # will be captured in my prime factorization function.
    # ANS to that is - in my first for-loop I am dividing n with the prime number if that prime is a factor of n.
    # Meaning, after this first for-loop gets executed completely, the adjusted initial n should become
    # either 1 or greater than 1
    # And if n has NOT become 1 after the previous for-loop, that means that
    # The remaining n is that prime factor which is greater that the square root of initial n.
    # And that's why in the next part of my algorithm, I need to check whether n becomes 1 or not,
    #This code is taken by rohan paul's github
    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
#here we go......................
#winners never quit, quitters never win
n=int(input())
pp=n
nn=n

pl=[]
nl=[]
while pp:
    pp-=1
    pl.append(input())
while nn:
    nn-=1
    nl.append(input())
ans=0
pmc=pl.count(""M"")
mc=nl.count(""M"")
if pmc < mc:
    ans+=mc -pmc
psc=pl.count(""S"")
sc=nl.count(""S"")
if psc < sc:
    ans+=sc -psc

plc=pl.count(""L"")
lc=nl.count(""L"")
if plc < lc:
    ans+=lc -plc

pxlc=pl.count(""XL"")
xlc=nl.count(""XL"")
if pxlc < xlc:
    ans+=xlc -pxlc

pxxlc=pl.count(""XXL"")
xxlc=nl.count(""XXL"")
if pxxlc < xxlc:
    ans+=xxlc -pxxlc

pxxxlc=pl.count(""XXXL"")
xxxlc=nl.count(""XXXL"")
if pxxxlc < xxxlc:
    ans+=xxxlc -pxxxlc

pxsc=pl.count(""XS"")
xsc=nl.count(""XS"")
if pxsc < xsc:
    ans+=xsc -pxsc

pxxsc=pl.count(""XXS"")
xxsc=nl.count(""XXS"")
if pxxsc < xxsc:
    ans+=xxsc -pxxsc

pxxxsc=pl.count(""XXXS"")
xxxsc=nl.count(""XXXS"")
if pxxxsc < xxxsc:
    ans+=xxxsc -pxxxsc
print(ans)

",1000_A,CODEFORCES,1739,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation",3
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

n = int(input())
a = [list(input()) for i in range(n)]
b = [list(input()) for i in range(n)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(n)] for u in range(n)]
    for t in range(n):
        for u in range(n):
            c[t][u] = b[u][n - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')",0958_A1,CODEFORCES,3141,Death Stars (easy),"The stardate is 1977 and the science and art of detecting Death Stars is in its infancy. Princess Heidi has received information about the stars in the nearby solar system from the Rebel spies and now, to help her identify the exact location of the Death Star, she needs to know whether this information is correct. 
Two rebel spies have provided her with the maps of the solar system. Each map is an N × N grid, where each cell is either occupied by a star or empty. To see whether the information is correct, Heidi needs to know whether the two maps are of the same solar system, or if possibly one of the spies is actually an Empire double agent, feeding her false information.
Unfortunately, spies may have accidentally rotated a map by 90, 180, or 270 degrees, or flipped it along the vertical or the horizontal axis, before delivering it to Heidi. If Heidi can rotate or flip the maps so that two of them become identical, then those maps are of the same solar system. Otherwise, there are traitors in the Rebel ranks! Help Heidi find out.
The first line of the input contains one number N (1 ≤ N ≤ 10) – the dimension of each map. Next N lines each contain N characters, depicting the first map: 'X' indicates a star, while 'O' indicates an empty quadrant of space. Next N lines each contain N characters, depicting the second map in the same format.
The only line of output should contain the word Yes if the maps are identical, or No if it is impossible to match them by performing rotations and translations.
","input
In the first test, you can match the first map to the second map by first flipping the first map along the vertical axis, and then by rotating it 90 degrees clockwise.
output
 
",implementation,5
"def occurrences(string, sub):
    count = start = 0
    while True:
        start = string.find(sub, start) + 1
        if start > 0:
            count += 1
        else:
            return count


class CodeforcesTask23ASolution:
    def __init__(self):
        self.result = ''
        self.string = ''

    def read_input(self):
        self.string = input()

    def process_task(self):
        o_max = 0
        for x in range(len(self.string)):
            for y in range(x):
                m = occurrences(self.string, self.string[y:x])
                if m >= 2:
                    o_max = max(x - y, o_max)
        self.result = str(o_max)

    def get_result(self):
        return self.result


if __name__ == ""__main__"":
    Solution = CodeforcesTask23ASolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())
",0023_A,CODEFORCES,3725,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"from sys import stdin,stdout
input=stdin.readline
for _ in range(int(input())):
    x=10**5
    n,k=map(int,input().split())
    s=input()
    ans=10**9
    for i in range(n-k+1):
        x=s[i:i+k]
        m=0
        curr=['R','G','B']
        for l in range(3):
            m=0
            z=l
            for j in x:
                if j!=curr[z]:
                    m+=1
                z+=1
                z%=3
            ans=min(ans,m)
    print(ans)
            ",1196_D1,CODEFORCES,3613,RGB Substring (easy version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2000$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2000$$$ ($$$\sum n \le 2000$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
",implementation,5
"R = lambda: map(int, input().split())

n = int(input())
arr1 = tuple(R())
arr2 = tuple(R())

d = dict()
ans = [0]*n

for i in range(n):
    d[i] = [arr1[i], arr2[i]]

def run():
    for nn in range(n, 0, -1):
        s = list()
        for i in d:
            if d[i][0] == d[i][1] == 0:
                s.append(i)
                ans[i] = nn

        if s:
            for i in s: del d[i]
            for i in d:
                l = r = 0
                for j in s:
                    if j < i:
                        l += 1
                    else:
                        r += 1
                if d[i][0] >= l:
                    d[i][0] -= l
                else:
                    return
                if d[i][1] >= r:
                    d[i][1] -= r
                else:
                    return

        else:
            return

run()

if 0 in ans:
    print('NO')
    # print(*ans, sep=' ')
else:
    print('YES')
    print(*ans, sep=' ')",1054_C,CODEFORCES,3524,Candies Distribution,"There are $$$n$$$ children numbered from $$$1$$$ to $$$n$$$ in a kindergarten. Kindergarten teacher gave $$$a_i$$$ ($$$1 \leq a_i \leq n$$$) candies to the $$$i$$$-th child. Children were seated in a row in order from $$$1$$$ to $$$n$$$ from left to right and started eating candies. 
While the $$$i$$$-th child was eating candies, he calculated two numbers $$$l_i$$$ and $$$r_i$$$ — the number of children seating to the left of him that got more candies than he and the number of children seating to the right of him that got more candies than he, respectively.
Formally, $$$l_i$$$ is the number of indices $$$j$$$ ($$$1 \leq j < i$$$), such that $$$a_i < a_j$$$ and $$$r_i$$$ is the number of indices $$$j$$$ ($$$i < j \leq n$$$), such that $$$a_i < a_j$$$.
Each child told to the kindergarten teacher the numbers $$$l_i$$$ and $$$r_i$$$ that he calculated. Unfortunately, she forgot how many candies she has given to each child. So, she asks you for help: given the arrays $$$l$$$ and $$$r$$$ determine whether she could have given the candies to the children such that all children correctly calculated their values $$$l_i$$$ and $$$r_i$$$, or some of them have definitely made a mistake. If it was possible, find any way how she could have done it.
On the first line there is a single integer $$$n$$$ ($$$1 \leq n \leq 1000$$$) — the number of children in the kindergarten.
On the next line there are $$$n$$$ integers $$$l_1, l_2, \ldots, l_n$$$ ($$$0 \leq l_i \leq n$$$), separated by spaces.
On the next line, there are $$$n$$$ integer numbers $$$r_1, r_2, \ldots, r_n$$$ ($$$0 \leq r_i \leq n$$$), separated by spaces.
If there is no way to distribute the candies to the children so that all of them calculated their numbers correctly, print «NO» (without quotes).
Otherwise, print «YES» (without quotes) on the first line. On the next line, print $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$, separated by spaces — the numbers of candies the children $$$1, 2, \ldots, n$$$ received, respectively. Note that some of these numbers can be equal, but all numbers should satisfy the condition $$$1 \leq a_i \leq n$$$. The number of children seating to the left of the $$$i$$$-th child that got more candies than he should be equal to $$$l_i$$$ and the number of children seating to the right of the $$$i$$$-th child that got more candies than he should be equal to $$$r_i$$$. If there is more than one solution, find any of them.
In the first example, if the teacher distributed $$$1$$$, $$$3$$$, $$$1$$$, $$$2$$$, $$$1$$$ candies to $$$1$$$-st, $$$2$$$-nd, $$$3$$$-rd, $$$4$$$-th, $$$5$$$-th child, respectively, then all the values calculated by the children are correct. For example, the $$$5$$$-th child was given $$$1$$$ candy, to the left of him $$$2$$$ children were given $$$1$$$ candy, $$$1$$$ child was given $$$2$$$ candies and $$$1$$$ child — $$$3$$$ candies, so there are $$$2$$$ children to the left of him that were given more candies than him.
","input
In the second example it is impossible to distribute the candies, because the $$$4$$$-th child made a mistake in calculating the value of $$$r_4$$$, because there are no children to the right of him, so $$$r_4$$$ should be equal to $$$0$$$.
output
In the last example all children may have got the same number of candies, that's why all the numbers are $$$0$$$. Note that each child should receive at least one candy.
","constructivealgorithms, implementation",5
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
Q, = getIntList()
for _ in range(Q):
    N, M, K  = getIntList()
    if max(N,M) >K:
        print(-1)
        continue
    r = K
    if N%2!= K%2:
        r-=1
    if M%2!= K%2:
        r-=1
    print(r)






",1036_B,CODEFORCES,475,Diagonal Walking v,"Mikhail walks on a Cartesian plane. He starts at the point $$$(0, 0)$$$, and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $$$(0, 0)$$$, he can go to any of the following points in one move: 
If Mikhail goes from the point $$$(x1, y1)$$$ to the point $$$(x2, y2)$$$ in one move, and $$$x1 \ne x2$$$ and $$$y1 \ne y2$$$, then such a move is called a diagonal move.
Mikhail has $$$q$$$ queries. For the $$$i$$$-th query Mikhail's target is to go to the point $$$(n_i, m_i)$$$ from the point $$$(0, 0)$$$ in exactly $$$k_i$$$ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in $$$k_i$$$ moves.
Note that Mikhail can visit any point any number of times (even the destination point!).
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 10^4$$$) — the number of queries.
Then $$$q$$$ lines follow. The $$$i$$$-th of these $$$q$$$ lines contains three integers $$$n_i$$$, $$$m_i$$$ and $$$k_i$$$ ($$$1 \le n_i, m_i, k_i \le 10^{18}$$$) — $$$x$$$-coordinate of the destination point of the query, $$$y$$$-coordinate of the destination point of the query and the number of moves in the query, correspondingly.
Print $$$q$$$ integers. The $$$i$$$-th integer should be equal to -1 if Mikhail cannot go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in exactly $$$k_i$$$ moves described above. Otherwise the $$$i$$$-th integer should be equal to the the maximum number of diagonal moves among all possible movements.
One of the possible answers to the first test case: $$$(0, 0) \to (1, 0) \to (1, 1) \to (2, 2)$$$.
","input
One of the possible answers to the second test case: $$$(0, 0) \to (0, 1) \to (1, 2) \to (0, 3) \to (1, 4) \to (2, 3) \to (3, 2) \to (4, 3)$$$.
output
In the third test case Mikhail cannot reach the point $$$(10, 1)$$$ in 9 moves.
",math,1
"

def my_solve(n, m, graph, mask):
	if do_dfs_bool(n,graph,mask.copy()):
		c = get_cyclic(n, graph, mask)
		for u,v in c:
			graph[u].remove(v)
			if not do_dfs_bool(n,graph,mask.copy()):
				return 'YES'
			graph[u].append(v)
		return ""NO""
	return ""YES""

def get_cyclic(n, graph, mask):
	c,v = do_dfs(n,graph,mask)
	path = []
	i = 0
	begin = False
	if c:
		for u in c.keys():
			if c[u] == v:
				begin = True
				path.append((c[u],u))
			elif begin:
				path.append((c[u],u))
		tmp = list(c.keys())
		if len(tmp):
			path.append((tmp[-1],v))
	return path

def do_dfs_bool(n, graph, mask):
	colors = [0]*(n+5)
	for u in graph.keys():
		if not u in mask.keys():
			if dfs_bool(u,graph,mask,colors):
				return True
	return False


def dfs_bool(u, graph, mask,colors):
	colors[u] = 1
	mask[u] = True
	for v in graph[u]:
		if colors[v] == 1:
			return True
		if colors[v] == 0:
			if dfs_bool(v,graph,mask,colors):				
				return True
	colors[u] = 2
	return False

def do_dfs(n, graph, mask):
	colors = [0]*(n+5)
	c = {}
	for u in graph.keys():
		if not u in mask.keys():
			c = {}
			p, v = dfs(u,graph,mask,c,colors)
			if p and v:
				return (p,v)


def dfs(u, graph, mask, c, colors):
	colors[u] = 1
	for v in graph[u]:
		if colors[v] == 1:
			return (c, v)
		if colors[v] == 0:
			c[v] = u
			p,w = dfs(v,graph,mask,c,colors)
			if w:
				return (p,w)
	colors[u] = 2
	if len(c) > 0:
		if u in c.keys():
			del c[u]
	return (c, None)

def test(n, m, edges):
	graph = {}
	mask = {}
	for u,v in edges:
		if u not in graph.keys():
			graph[u] = []
		graph[u].append(v)
		if v not in graph.keys():
			graph[v] = []
	return my_solve(n, m, graph, mask)


if __name__ == '__main__':
	n,m = [int(x) for x in input().split()]
	edges = []
	for i in range(0,m):
		u,v = [int(x) for x in input().split()]
		edges.append((u,v))
	print(test(n, m, edges))",0915_D,CODEFORCES,3120,Almost Acyclic Graph,"You are given a directed graph consisting of n vertices and m edges (each edge is directed, so it can be traversed in only one direction). You are allowed to remove at most one edge from it.
Can you make this graph acyclic by removing at most one edge from it? A directed graph is called acyclic iff it doesn't contain any cycle (a non-empty path that starts and ends in the same vertex).
The first line contains two integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ min(n(n - 1), 100000)) — the number of vertices and the number of edges, respectively.
Then m lines follow. Each line contains two integers u and v denoting a directed edge going from vertex u to vertex v (1 ≤ u, v ≤ n, u ≠ v). Each ordered pair (u, v) is listed at most once (there is at most one directed edge from u to v).
If it is possible to make this graph acyclic by removing at most one edge, print YES. Otherwise, print NO.
","input
In the first example you can remove edge , and the graph becomes acyclic.
output
In the second example you have to remove at least two edges (for example,  and ) in order to make the graph acyclic.
","dfsandsimilar, graphs",5
"import os, sys
from io import BytesIO, IOBase


def main():
    n = rint()
    deg, edges = [0] * n, rints_2d(n - 1)
    for u, v in edges:
        deg[u - 1] += 1
        deg[v - 1] += 1

    coun = [0, deg.count(1), deg.count(2)]

    if n - coun[1] == 1:
        print(f'Yes\n{n - 1}')
        [print(*x) for x in edges]

    elif coun[1] + coun[2] == n:
        print(f'Yes\n1\n{deg.index(1) + 1} {n - deg[::-1].index(1)}')

    elif n - sum(coun) == 1:
        for i in range(n):
            if deg[i] > 2:
                print(f'Yes\n{deg[i]}')
                for j in range(n):
                    if deg[j] == 1:
                        print(i + 1, j + 1)
                exit()
    else:
        print('No')


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",0981_C,CODEFORCES,1680,Useful Decomposition,"Ramesses knows a lot about problems involving trees (undirected connected graphs without cycles)!
He created a new useful tree decomposition, but he does not know how to construct it, so he asked you for help!
The decomposition is the splitting the edges of the tree in some simple paths in such a way that each two paths have at least one common vertex. Each edge of the tree should be in exactly one path.
Help Remesses, find such a decomposition of the tree or derermine that there is no such decomposition.
The first line contains a single integer $$$n$$$ ($$$2 \leq n \leq 10^{5}$$$) the number of nodes in the tree.
Each of the next $$$n - 1$$$ lines contains two integers $$$a_i$$$ and $$$b_i$$$ ($$$1 \leq a_i, b_i \leq n$$$, $$$a_i \neq b_i$$$) — the edges of the tree. It is guaranteed that the given edges form a tree.
If there are no decompositions, print the only line containing ""No"".
Otherwise in the first line print ""Yes"", and in the second line print the number of paths in the decomposition $$$m$$$. 
Each of the next $$$m$$$ lines should contain two integers $$$u_i$$$, $$$v_i$$$ ($$$1 \leq u_i, v_i \leq n$$$, $$$u_i \neq v_i$$$) denoting that one of the paths in the decomposition is the simple path between nodes $$$u_i$$$ and $$$v_i$$$. 
Each pair of paths in the decomposition should have at least one common vertex, and each edge of the tree should be presented in exactly one path. You can print the paths and the ends of each path in arbitrary order.
If there are multiple decompositions, print any.
The tree from the first example is shown on the picture below:  The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.
","input
The tree from the second example is shown on the picture below:  We can show that there are no valid decompositions of this tree.
output
The tree from the third example is shown on the picture below:  The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.
","implementation, trees",3
"l,r=map(int,input().split())
j=r-l+1

# basically two even numbers can never be coprime so we will check can we have three numbers 
# such that we can have 2 even and 1 odd 

# if gap consists number less than 3 then output would be -1
# if gap is of 3 it must start with even like 2-4 we have 2 3 4
# if it starts with 5-7 we can write 5 6 7 
if j==3:
	if l%2==0:
		print(l,l+1,l+2)
	else:
		print(-1)
elif j>3:
	if l%2==0:print(l,l+1,l+2)
	else:print(l+1,l+2,l+3)
else:print(-1)",0483_A,CODEFORCES,159,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"def main():
    def calc(x):
        if x & 1:
            return -x + calc(x - 1)
        return x // 2
    n = int(input())
    for i in range(n):
        a, b = map(int, input().split())
        print(calc(b) - calc(a - 1))    

main()
",1080_B,CODEFORCES,592,Margarite and the best present,"Little girl Margarita is a big fan of competitive programming. She especially loves problems about arrays and queries on them.
Recently, she was presented with an array $$$a$$$ of the size of $$$10^9$$$ elements that is filled as follows: 
That is, the value of the $$$i$$$-th element of the array $$$a$$$ is calculated using the formula $$$a_i = i \cdot (-1)^i$$$.
She immediately came up with $$$q$$$ queries on this array. Each query is described with two numbers: $$$l$$$ and $$$r$$$. The answer to a query is the sum of all the elements of the array at positions from $$$l$$$ to $$$r$$$ inclusive.
Margarita really wants to know the answer to each of the requests. She doesn't want to count all this manually, but unfortunately, she couldn't write the program that solves the problem either. She has turned to you — the best programmer.
Help her find the answers!
The first line contains a single integer $$$q$$$ ($$$1 \le q \le 10^3$$$) — the number of the queries.
Each of the next $$$q$$$ lines contains two integers $$$l$$$ and $$$r$$$ ($$$1 \le l \le r \le 10^9$$$) — the descriptions of the queries.
Print $$$q$$$ lines, each containing one number — the answer to the query. 
In the first query, you need to find the sum of the elements of the array from position $$$1$$$ to position $$$3$$$. The sum is equal to $$$a_1 + a_2 + a_3 = -1 + 2 -3 = -2$$$.
In the second query, you need to find the sum of the elements of the array from position $$$2$$$ to position $$$5$$$. The sum is equal to $$$a_2 + a_3 + a_4 + a_5 = 2 -3 + 4 - 5 = -2$$$.
In the third query, you need to find the sum of the elements of the array from position $$$5$$$ to position $$$5$$$. The sum is equal to $$$a_5 = -5$$$.
","input
In the fourth query, you need to find the sum of the elements of the array from position $$$4$$$ to position $$$4$$$. The sum is equal to $$$a_4 = 4$$$.
output
In the fifth query, you need to find the sum of the elements of the array from position $$$2$$$ to position $$$3$$$. The sum is equal to $$$a_2 + a_3 = 2 - 3 = -1$$$.
",math,1
"from collections import namedtuple
n = int(input())
vertex = namedtuple('vertex', ['degree', 'id'])
a, b, c = [], [], 0

rr = list(map(int, input().split()))

for i in range(n):
    tmp = rr[i]
    v = vertex(tmp, i + 1)
    if tmp > 1:
        a.append(v)
    else:
        b.append(v)
    c += tmp

if c < (n - 1)*2:
    print('NO')
else:
    if len(a) == 0:
        print('YES 1')
        print('1 2')
    else:
        print('YES', len(a) - 1 + min(2, len(b)))
        print(n - 1)
        for i in range(len(a)):
            if i == 0:
                continue
            print(a[i - 1].id, a[i].id)
        if len(b) > 0:
            print(b[0].id, a[0].id)
        if len(b) > 1:
            print(b[1].id, a[-1].id)
        j = 2
        for i in range(len(a)):
            if j >= len(b):
                yes = 1
                break
            k = a[i].degree - 2
            yes = 0
            for t in range(k):
                print(a[i].id, b[j].id)
                j += 1
                if j >= len(b):
                    yes = 1
                    break
            if yes == 1:
                break",1082_D,CODEFORCES,2050,Maximum Diameter Graph,"Graph constructive problems are back! This time the graph you are asked to build should match the following properties.
The graph is connected if and only if there exists a path between every pair of vertices.
The diameter (aka ""longest shortest path"") of a connected undirected graph is the maximum number of edges in the shortest path between any pair of its vertices.
The degree of a vertex is the number of edges incident to it.
Given a sequence of $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ construct a connected undirected graph of $$$n$$$ vertices such that:
Output the resulting graph or report that no solution exists.
The first line contains a single integer $$$n$$$ ($$$3 \le n \le 500$$$) — the number of vertices in the graph.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le n - 1$$$) — the upper limits to vertex degrees.
Print ""NO"" if no graph can be constructed under the given conditions.
Otherwise print ""YES"" and the diameter of the resulting graph in the first line.
The second line should contain a single integer $$$m$$$ — the number of edges in the resulting graph.
The $$$i$$$-th of the next $$$m$$$ lines should contain two integers $$$v_i, u_i$$$ ($$$1 \le v_i, u_i \le n$$$, $$$v_i \neq u_i$$$) — the description of the $$$i$$$-th edge. The graph should contain no multiple edges — for each pair $$$(x, y)$$$ you output, you should output no more pairs $$$(x, y)$$$ or $$$(y, x)$$$.
Here are the graphs for the first two example cases. Both have diameter of $$$2$$$.
$$$d_2 = 2 \le a_2 = 2$$$
$$$d_3 = 1 \le a_3 = 2$$$ 
$$$d_2 = 4 \le a_2 = 4$$$
","input
$$$d_3 = 1 \le a_3 = 1$$$
output
$$$d_4 = 1 \le a_4 = 1$$$ 
","constructivealgorithms, graphs, implementation",3
"# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import random
import itertools
import sys
from typing import List

""""""
created by shhuan at 2020/3/19 13:35

""""""


def check(s, a, b, after):
    ns, na, nb = len(s), len(a), len(b)
    if ns < na + nb:
        return False

    dp = [[0 for _ in range(nb+1)] for _ in range(na+1)]
    for i in range(na+1):
        for j in range(nb+1):
            if i == 0 and j == 0:
                continue
            dp[i][j] = min(after[dp[i-1][j]][a[i-1]] if i > 0 else ns, after[dp[i][j-1]][b[j-1]] if j > 0 else ns) + 1

    return dp[na][nb] <= ns


def solve(s, t):
    ns = len(s)
    after = [[ns for _ in range(26)] for _ in range(ns+2)]
    for i in range(ns-1, -1, -1):
        for j in range(26):
            after[i][j] = after[i+1][j]
        after[i][s[i]] = i

    for i in range(len(t)):
        a, b = t[:i], t[i:]
        if check(s, a, b, after):
            return 'YES'

    return 'NO'


T = int(input())
ans = []
for i in range(T):
    s = input()
    t = input()
    s = [ord(v) - ord('a') for v in s]
    t = [ord(v) - ord('a') for v in t]
    ans.append(solve(s, t))

print('\n'.join(ans))",1303_E,CODEFORCES,3812,Erase Subsequences,"You are given a string $$$s$$$. You can build new string $$$p$$$ from $$$s$$$ using the following operation no more than two times: 
Of course, initially the string $$$p$$$ is empty. 
For example, let $$$s = \text{ababcd}$$$. At first, let's choose subsequence $$$s_1 s_4 s_5 = \text{abc}$$$ — we will get $$$s = \text{bad}$$$ and $$$p = \text{abc}$$$. At second, let's choose $$$s_1 s_2 = \text{ba}$$$ — we will get $$$s = \text{d}$$$ and $$$p = \text{abcba}$$$. So we can build $$$\text{abcba}$$$ from $$$\text{ababcd}$$$.
Can you build a given string $$$t$$$ using the algorithm above?
The first line contains the single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of test cases.
Next $$$2T$$$ lines contain test cases — two per test case. The first line contains string $$$s$$$ consisting of lowercase Latin letters ($$$1 \le |s| \le 400$$$) — the initial string.
The second line contains string $$$t$$$ consisting of lowercase Latin letters ($$$1 \le |t| \le |s|$$$) — the string you'd like to build.
","input
It's guaranteed that the total length of strings $$$s$$$ doesn't exceed $$$400$$$.
output
Print $$$T$$$ answers — one per test case. Print YES (case insensitive) if it's possible to build $$$t$$$ and NO (case insensitive) otherwise.
","dp, strings",6
"n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
arr.sort()
arr=arr+[k]
ans=0
s=0
while ans<n+1:
    s+=arr[-ans-1]
    if s>=m:
        break
    ans+=1
    s-=1
if s>=m:
    print(ans)
else:
    print(""-1"")
",0257_A,CODEFORCES,2387,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings",4
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

####################################---fast-input-output----#########################################


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]


z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())


def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)


dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]


#################################################---Some Rule For Me To Follow---#################################
""""""
    --instants of Reading problem continuously try to understand them.

    --If you Know some-one , Then you probably don't know him !

    --Try & again try

""""""
##################################################---START-CODING---###############################################





    
n = int(z())
a = zzz()

d = {}
power = [2**i for i in range(31)]
ans = []
for i in a:
    d[i] = 0

for num in d.keys():
    for p in power:
        if num+p in d:
            ans = [num, num+p]
            if num+p+p in d:
                print(3)
                ans.append(num+p+p)
                print(*ans)
                exit()
if ans:
    print(2)
    print(*ans)
else:
    print(1)
    print(a[0])

",0988_D,CODEFORCES,2611,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math",4
"def color(x, y):
	# print(f'color(x = {x}, y = {y}) called')
	return 'white' if (x + y) % 2 == 0 else 'black'


def white(x1, y1, x2, y2):
	"""""" x1 <= x2, y1 <= y2 """"""
	# print(f'white(x1 = {x1}, y1 = {y1}, x2 = {x2}, y2 = {y2}) called')
	if x1 > x2 or y1 > y2:
		return 0

	if color(x1, y1) != color(x2, y2):
		return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
	else:
		if color(x1, y1) == color(x1, y2) == color(x2, y1) == 'white':
			return ((x2 - x1 + 1) * (y2 - y1 + 1) + 1) // 2
		elif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'black':
			return ((x2 - x1 + 1) * (y2 - y1 + 1) - 1) // 2
		else:
			return (x2 - x1 + 1) * (y2 - y1 + 1) // 2	


def black(x1, y1, x2, y2):
	"""""" x1 <= x2, y1 <= y2 """"""
	if x1 > x2 or y1 > y2:
		return 0

	return (x2 - x1 + 1) * (y2 - y1 + 1) - white(x1, y1, x2, y2)


def intersect_1D(x1, x2, x3, x4):
	"""""" x1 <= x2, x3 <= x4 """"""
	return max(x1, x3), min(x2, x4)


def intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4):
	"""""" x1 <= x2, x3 <= x4, y1 <= y2, y3 <= y4 """"""
	xl, xr = intersect_1D(x1, x2, x3, x4)
	yl, yr = intersect_1D(y1, y2, y3, y4)
	return xl, yl, xr, yr


for i in range(int(input())):
	n, m = map(int, input().split())
	# print(f'n = {n}, m = {m}')
	x1, y1, x2, y2 = map(int, input().split())
	# print(f'x1 = {x1}, y1 = {y1}, x2 = {x2}, y2 = {y2}')
	x3, y3, x4, y4 = map(int, input().split())
	# print(f'x3 = {x3}, y3 = {y3}, x4 = {x4}, y4 = {y4}')

	w0, b0 = white(1, 1, m, n), black(1, 1, m, n)
	# print(f'w0 = {w0}, b0 = {b0}')

	_b0 = black(x1, y1, x2, y2)
	# print(f'_b0 = {_b0}')
	w1, b1 = w0 + _b0, b0 - _b0

	_w1 = white(x3, y3, x4, y4)
	# print(f'_w1 = {_w1}')
	w2, b2 = w1 - _w1, b1 + _w1

	xl, yl, xr, yr = intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4)
	# print(f'xl = {xl}, yl = {yl}, xr = {xr}, yr = {yr}')
	_b2 = black(xl, yl, xr, yr)
	# print(f'_b2 = {_b2}')
	w3, b3 = w2 - _b2, b2 + _b2

	print(w3, b3)
",1080_C,CODEFORCES,612,Masha and two friends,"Recently, Masha was presented with a chessboard with a height of $$$n$$$ and a width of $$$m$$$.
The rows on the chessboard are numbered from $$$1$$$ to $$$n$$$ from bottom to top. The columns are numbered from $$$1$$$ to $$$m$$$ from left to right. Therefore, each cell can be specified with the coordinates $$$(x,y)$$$, where $$$x$$$ is the column number, and $$$y$$$ is the row number (do not mix up).
Let us call a rectangle with coordinates $$$(a,b,c,d)$$$ a rectangle lower left point of which has coordinates $$$(a,b)$$$, and the upper right one — $$$(c,d)$$$.
The chessboard is painted black and white as follows:
Masha was very happy with the gift and, therefore, invited her friends Maxim and Denis to show off. The guys decided to make her a treat — they bought her a can of white and a can of black paint, so that if the old board deteriorates, it can be repainted. When they came to Masha, something unpleasant happened: first, Maxim went over the threshold and spilled white paint on the rectangle $$$(x_1,y_1,x_2,y_2)$$$. Then after him Denis spilled black paint on the rectangle $$$(x_3,y_3,x_4,y_4)$$$.
To spill paint of color $$$color$$$ onto a certain rectangle means that all the cells that belong to the given rectangle become $$$color$$$. The cell dyeing is superimposed on each other (if at first some cell is spilled with white paint and then with black one, then its color will be black).
Masha was shocked! She drove away from the guests and decided to find out how spoiled the gift was. For this, she needs to know the number of cells of white and black color. Help her find these numbers!
The first line contains a single integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of test cases.
Each of them is described in the following format:
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n,m \le 10^9$$$) — the size of the board.
The second line contains four integers $$$x_1$$$, $$$y_1$$$, $$$x_2$$$, $$$y_2$$$ ($$$1 \le x_1 \le x_2 \le m, 1 \le y_1 \le y_2 \le n$$$) — the coordinates of the rectangle, the white paint was spilled on.
The third line contains four integers $$$x_3$$$, $$$y_3$$$, $$$x_4$$$, $$$y_4$$$ ($$$1 \le x_3 \le x_4 \le m, 1 \le y_3 \le y_4 \le n$$$) — the coordinates of the rectangle, the black paint was spilled on.
Output $$$t$$$ lines, each of which contains two numbers — the number of white and black cells after spilling paint, respectively.
Explanation for examples:
The first picture of each illustration shows how the field looked before the dyes were spilled. The second picture of each illustration shows how the field looked after Maxim spoiled white dye (the rectangle on which the dye was spilled is highlighted with red). The third picture in each illustration shows how the field looked after Denis spoiled black dye (the rectangle on which the dye was spilled is highlighted with red).
In the first test, the paint on the field changed as follows:
In the second test, the paint on the field changed as follows:
In the third test, the paint on the field changed as follows:
","input
In the fourth test, the paint on the field changed as follows:
output
In the fifth test, the paint on the field changed as follows:
",implementation,1
"'''
s = input()
for i in range(len(s)):

    for k in range(i + 1, len(s)+1, 1):
        print(s[i:k])
'''
'''
s = input()
sLen = len(s)
for startInd in range(sLen):
    for endInd in range(startInd + 1, sLen + 1):
        print(s[startInd, endInd])

'''
s = input()
slen = len(s)
ans = 0
for st1 in range(slen - 1):
    for end1 in range(st1 + 1, slen):
        end2 = end1 + 1
        sub1 = s[st1:end1]
        for st2 in range(st1 + 1, slen):
            if end2 > slen:
                break

            sub2 = s[st2:end2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            end2 += 1

print(ans)
",0023_A,CODEFORCES,3755,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"def prime(n):
    j = 3
    while j * j <= n:
        if n % j == 0:
            return False
        j += 2
    return True
ref = [2]
for j in range(3, 1000, 2):
    if prime(j) == True:
        ref.append(j)
def check(n):
    for j in range(1, len(ref) - 1):
        v = n - ref[j] - 1
        if ref[j - 1] == v or ref[j + 1] == v:
            return True
        if j > n:
            break
    return False
arr = []
for j in range(3, 1001, 2):
    if prime(j) == True and check(j) == True:
        arr.append(j)
n, k = [int(j) for j in input().split()]
count = 0
for j in range(2, n + 1):
    if j in arr:
        count += 1
if count >= k:
    print(""YES"")
else:
    print(""NO"")
",0017_A,CODEFORCES,1433,Noldbach problem,"Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least k prime numbers from 2 to n inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.
Two prime numbers are called neighboring if there are no other prime numbers between them.
You are to help Nick, and find out if he is right or wrong.
The first line of the input contains two integers n (2 ≤ n ≤ 1000) and k (0 ≤ k ≤ 1000).
","input
Output YES if at least k prime numbers from 2 to n inclusively can be expressed as it was described above. Otherwise output NO.
output
In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.
","bruteforce, math, numbertheory",3
"def solve(n, a):
    a = sorted(a)
    col = [False for i in range(n)]
    count = 0
    for i in range(n):
        if not col[i]:
            count += 1
            col[i] = True
            for j in range(n):
                if a[j] % a[i] == 0:
                    col[j] = True
    return count
    
n = int(input())
a = list(map(int, input().split()))
print(solve(n, a))",1209_A,CODEFORCES,3668,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"def main():
    n, m, k = [int(v) for v in input().split()]
    dxy = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    # dx = [-1, 1, 0, 0]
    # dy = [0, 0, -1, 1]
    w = [[[0 for d in range(4)] for j in range(m)] for i in range(n)]
    for i in range(n):
        row = [int(v) for v in input().split()]
        for j in range(m-1):
            w[i][j+1][2] = row[j]
            w[i][j][3] = row[j]
    for i in range(n-1):
        row = [int(v) for v in input().split()]
        for j in range(m):
            w[i][j][1] = row[j]
            w[i+1][j][0] = row[j]
    if k % 2 == 1:
        for i in range(n):
            for j in range(m):
                print(-1, end="" "")
            print()
        return
    else:
        k //= 2
    dp = [[[int(40 * 1e6) for d in range(k+1)] for j in range(m)] for i in range(n)]
    for i in range(n):
        for j in range(m):
            dp[i][j][0] = 0
    for d in range(1, k+1):
        for i in range(n):
            for j in range(m):
                for di, (dx, dy) in enumerate(dxy):
                    ii = i + dx
                    jj = j + dy
                    if 0 <= ii < n and 0 <= jj < m:
                        dp[i][j][d] = min(dp[i][j][d], dp[ii][jj][d-1] + w[i][j][di])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k] * 2, end="" "")
        print()

main()

",1517_D,CODEFORCES,4136,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"n=int(input())
s=0
i=1
c=1
while(s<n):
    s+=9*i*c
    c+=1
    i*=10
n=n-s+9*i*(c-1)//10
c=c-1
r=n%c
d=n//c
k=10**(c-1)+d
if(r==0):
    print(int(str(k-1)[-1]))
else:
    print(int(str(k)[r-1]))

",1177_B,CODEFORCES,1295,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"n, pos, l, r = map(int, input().split())
result = abs(pos - l) + r - l + 2
if (l == 1):
    if (abs(pos - r) + 1 < result):
        result = abs(pos - r) + 1
if (r == n):
    if (abs(pos - l) + 1 < result):
        result = abs(pos - l) + 1
if (l == 1 and r == n):
    result = 0
if (abs(pos - r) + r - l + 2 < result):
    result = abs(pos - r) + r - l + 2
print(result)",0915_B,CODEFORCES,243,Browser,"Luba is surfing the Internet. She currently has n opened tabs in her browser, indexed from 1 to n from left to right. The mouse cursor is currently located at the pos-th tab. Luba needs to use the tabs with indices from l to r (inclusive) for her studies, and she wants to close all the tabs that don't belong to this segment as fast as possible.
Each second Luba can either try moving the cursor to the left or to the right (if the cursor is currently at the tab i, then she can move it to the tab max(i - 1, a) or to the tab min(i + 1, b)) or try closing all the tabs to the left or to the right of the cursor (if the cursor is currently at the tab i, she can close all the tabs with indices from segment [a, i - 1] or from segment [i + 1, b]). In the aforementioned expressions a and b denote the minimum and maximum index of an unclosed tab, respectively. For example, if there were 7 tabs initially and tabs 1, 2 and 7 are closed, then a = 3, b = 6.
What is the minimum number of seconds Luba has to spend in order to leave only the tabs with initial indices from l to r inclusive opened?
The only line of input contains four integer numbers n, pos, l, r (1 ≤ n ≤ 100, 1 ≤ pos ≤ n, 1 ≤ l ≤ r ≤ n) — the number of the tabs, the cursor position and the segment which Luba needs to leave opened.
Print one integer equal to the minimum number of seconds required to close all the tabs outside the segment [l, r].
In the first test Luba can do the following operations: shift the mouse cursor to the tab 2, close all the tabs to the left of it, shift the mouse cursor to the tab 3, then to the tab 4, and then close all the tabs to the right of it.
","input
In the second test she only needs to close all the tabs to the right of the current position of the cursor.
output
In the third test Luba doesn't need to do anything.
",implementation,1
"import sys
keta=29
print(""?"",0,0,flush=True)


A00=int(input())
if A00==0:
    ANS=0
    for k in range(keta,-1,-1):
        print(""?"",2**k,0,flush=True)
        if int(input())==-1:
            ANS+=2**k
    print(""!"",ANS,ANS,flush=True)
    sys.exit()


A=0
B=0
for k in range(keta,-1,-1):
    LIST=[]
    print(""?"",2**k+A,B,flush=True)
    LIST.append(int(input()))
    print(""?"",A,2**k+B,flush=True)
    LIST.append(int(input()))

    if LIST[0]!=LIST[1]:
        if LIST[0]==-1:
            A+=2**k
            B+=2**k

    else:
        if A00==1:
            A+=2**k
        else:
            B+=2**k
        A00=LIST[0]
print(""!"",A,B,flush=True)
        
        
",1088_D,CODEFORCES,1222,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",2
"n = int(input())

vertices   = []
for _ in range(n):
  x, w = map(int, input().split())
  vertices.append([x - w, x + w])
vertices = sorted(vertices, key = lambda x: x[1])

ans = 0
border = -(10**9 + 100)
for v in vertices:
  if border <= v[0]:
    ans += 1
    border = v[1]
print(ans)",0528_B,CODEFORCES,2420,Clique Problem,"The clique problem is one of the most well-known NP-complete problems. Under some simplification it can be formulated as follows. Consider an undirected graph G. It is required to find a subset of vertices C of the maximum size such that any two of them are connected by an edge in graph G. Sounds simple, doesn't it? Nobody yet knows an algorithm that finds a solution to this problem in polynomial time of the size of the graph. However, as with many other NP-complete problems, the clique problem is easier if you consider a specific type of a graph.
Consider n distinct points on a line. Let the i-th point have the coordinate xi and weight wi. Let's form graph G, whose vertices are these points and edges connect exactly the pairs of points (i, j), such that the distance between them is not less than the sum of their weights, or more formally: |xi - xj| ≥ wi + wj.
Find the size of the maximum clique in such graph.
The first line contains the integer n (1 ≤ n ≤ 200 000) — the number of points.
Each of the next n lines contains two numbers xi, wi (0 ≤ xi ≤ 109, 1 ≤ wi ≤ 109) — the coordinate and the weight of a point. All xi are different.
Print a single number — the number of vertexes in the maximum clique of the given graph.
","input
If you happen to know how to solve this problem without using the specific properties of the graph formulated in the problem statement, then you are able to get a prize of one million dollars!
output
The picture for the sample test.
","dp, greedy",4
"mod = 1000000007
x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    ans = (pow(2, k + 1, mod) * x % mod - (pow(2, k, mod) - 1 + mod) % mod + mod) % mod
    print(ans)",0992_C,CODEFORCES,1028,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"line = input().split()
line.sort()
a,b,c = line
if a == b and a == c:
    print(0)
elif a == b:
    print(1)
elif b == c:
    print(1)
else:
    if a[1] == b[1] and b[1] == c[1] \
        and int(b[0])-int(a[0]) == 1 and int(c[0])-int(b[0]) == 1:
        print(0)
    elif a[1] == b[1] and int(b[0])-int(a[0]) in [1,2]:
        print(1)
    elif b[1] == c[1] and int(c[0])-int(b[0]) in [1,2]:
        print(1)
    elif a[1] == c[1] and int(c[0])-int(a[0]) in [1,2]:
        print(1)
    else:
        print(2)

",1191_B,CODEFORCES,2967,Tokitsukaze and Mahjong,"Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $$$1$$$ to $$$9$$$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $$$\ldots$$$, 9m, 1p, 2p, $$$\ldots$$$, 9p, 1s, 2s, $$$\ldots$$$, 9s.
In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.
Do you know the minimum number of extra suited tiles she needs to draw so that she can win?
Here are some useful definitions in this game:
Some examples: 
Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.
The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $$$1$$$ to $$$9$$$ and the second character is m, p or s.
Print a single integer — the minimum number of extra suited tiles she needs to draw.
In the first example, Tokitsukaze already has a shuntsu.
","input
In the second example, Tokitsukaze already has a koutsu.
output
In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
","bruteforce, implementation",4
"import sys

def num_ops(low, high):
    if high % low == 0:
        return high // low
    else:
        return (high // low) + num_ops(high % low, low)

def main():
    n = int(sys.stdin.readline().strip())
    for _ in range(n):
        low, high = [int(i) for i in sys.stdin.readline().strip().split()]
        print(num_ops(low, high))




if __name__ == '__main__':
    main()",0267_A,CODEFORCES,102,Subtractions,"You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).
You've got some number of pairs (ai, bi). How many operations will be performed for each of them?
","input
The first line contains the number of pairs n (1  ≤  n  ≤  1000). Then follow n lines, each line contains a pair of positive integers ai, bi (1  ≤  ai,  bi  ≤  109).
output
Print the sought number of operations for each pair on a single line.
","math, numbertheory",1
"import io
import os

from collections import Counter, defaultdict, deque


def solve(N, M, K, right, down):
    if K % 2 == 1:
        return ((""-1 "" * N) + ""\n"") * M

    K //= 2

    inf = float(""inf"")
    R = N
    C = M

    for row in right:
        row.append(inf)
        row.append(inf)
        row.append(inf)
    right.append([inf] * (C + 2))
    right.append([inf] * (C + 2))
    for row in down:
        row.append(inf)
        row.append(inf)
    down.append([inf] * (C + 2))
    down.append([inf] * (C + 2))
    down.append([inf] * (C + 2))

    def right_(r, c):
        return right[r][c - 1]

    def down_(r, c):
        return down[r - 1][c]

    def left(r, c):
        return right[r][c]

    def up(r, c):
        return down[r][c]

    dist = [[inf for i in range(C + 2)] for j in range(R + 2)]
    for r in range(R):
        for c in range(C):
            dist[r][c] = 0
    for k in range(K):
        nextDist = [[inf for i in range(C + 2)] for j in range(R + 2)]
        for r in range(R):
            for c in range(C):
                nextDist[r][c] = min(
                    dist[r][c - 1] + right_(r, c),
                    dist[r][c + 1] + left(r, c),
                    dist[r - 1][c] + down_(r, c),
                    dist[r + 1][c] + up(r, c),
                )
        dist = nextDist
    return ""\n"".join("" "".join(str(2 * dist[r][c]) for c in range(C)) for r in range(R))


DEBUG = False
if DEBUG:
    import random

    random.seed(0)
    for _ in range(1):
        N = 500
        M = 500
        K = 20

        def pack(i, j):
            return i * M + j

        def unpack(ij):
            return divmod(ij, M)

        graph = [[] for i in range(N * M)]

        right = [[random.randint(1, 10 ** 6) for j in range(M - 1)] for i in range(N)]
        down = [[random.randint(1, 10 ** 6) for j in range(M)] for i in range(N - 1)]
        print(""tc"" + str(_))
        ans = solve(N, M, K, right, down)
        # print(ans, ans1)
        # assert ans == ans1

    exit()


if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    def pack(i, j):
        return i * M + j

    def unpack(ij):
        return divmod(ij, M)

    N, M, K = [int(x) for x in input().split()]

    right = [[int(x) for x in input().split()] for i in range(N)]
    down = [[int(x) for x in input().split()] for i in range(N - 1)]

    ans = solve(N, M, K, right, down)
    print(ans)
",1517_D,CODEFORCES,4072,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
ans = [1 for i in range(n)]

s = [l[i] + r[i] for i in range(n)]
order = [i for i in range(n)]

for i in range(n-1):
    m = i
    for j in range(i+1,n):
        if s[m] < s[j]:
            m = j
    t = s[i]
    s[i] = s[m]
    s[m] = t
    t = order[i]
    order[i] = order[m]
    order[m] = t
cur = 1
for i in range(1,n):
    if s[i-1] > s[i]:
        cur += 1
    ans[order[i]] = cur
for i in range(n):
    k = 0
    for j in range(i):
        if ans[j] > ans[i]:
            k += 1
    if l[i] != k:
        print('NO')
        exit()
    k = 0
    for j in range(i+1,n):
        if ans[j] > ans[i]:
            k += 1
    if r[i] != k:
        print('NO')
        exit()

print('YES')
for i in ans:
    print(i, end=' ')",1054_C,CODEFORCES,3505,Candies Distribution,"There are $$$n$$$ children numbered from $$$1$$$ to $$$n$$$ in a kindergarten. Kindergarten teacher gave $$$a_i$$$ ($$$1 \leq a_i \leq n$$$) candies to the $$$i$$$-th child. Children were seated in a row in order from $$$1$$$ to $$$n$$$ from left to right and started eating candies. 
While the $$$i$$$-th child was eating candies, he calculated two numbers $$$l_i$$$ and $$$r_i$$$ — the number of children seating to the left of him that got more candies than he and the number of children seating to the right of him that got more candies than he, respectively.
Formally, $$$l_i$$$ is the number of indices $$$j$$$ ($$$1 \leq j < i$$$), such that $$$a_i < a_j$$$ and $$$r_i$$$ is the number of indices $$$j$$$ ($$$i < j \leq n$$$), such that $$$a_i < a_j$$$.
Each child told to the kindergarten teacher the numbers $$$l_i$$$ and $$$r_i$$$ that he calculated. Unfortunately, she forgot how many candies she has given to each child. So, she asks you for help: given the arrays $$$l$$$ and $$$r$$$ determine whether she could have given the candies to the children such that all children correctly calculated their values $$$l_i$$$ and $$$r_i$$$, or some of them have definitely made a mistake. If it was possible, find any way how she could have done it.
On the first line there is a single integer $$$n$$$ ($$$1 \leq n \leq 1000$$$) — the number of children in the kindergarten.
On the next line there are $$$n$$$ integers $$$l_1, l_2, \ldots, l_n$$$ ($$$0 \leq l_i \leq n$$$), separated by spaces.
On the next line, there are $$$n$$$ integer numbers $$$r_1, r_2, \ldots, r_n$$$ ($$$0 \leq r_i \leq n$$$), separated by spaces.
If there is no way to distribute the candies to the children so that all of them calculated their numbers correctly, print «NO» (without quotes).
Otherwise, print «YES» (without quotes) on the first line. On the next line, print $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$, separated by spaces — the numbers of candies the children $$$1, 2, \ldots, n$$$ received, respectively. Note that some of these numbers can be equal, but all numbers should satisfy the condition $$$1 \leq a_i \leq n$$$. The number of children seating to the left of the $$$i$$$-th child that got more candies than he should be equal to $$$l_i$$$ and the number of children seating to the right of the $$$i$$$-th child that got more candies than he should be equal to $$$r_i$$$. If there is more than one solution, find any of them.
In the first example, if the teacher distributed $$$1$$$, $$$3$$$, $$$1$$$, $$$2$$$, $$$1$$$ candies to $$$1$$$-st, $$$2$$$-nd, $$$3$$$-rd, $$$4$$$-th, $$$5$$$-th child, respectively, then all the values calculated by the children are correct. For example, the $$$5$$$-th child was given $$$1$$$ candy, to the left of him $$$2$$$ children were given $$$1$$$ candy, $$$1$$$ child was given $$$2$$$ candies and $$$1$$$ child — $$$3$$$ candies, so there are $$$2$$$ children to the left of him that were given more candies than him.
","input
In the second example it is impossible to distribute the candies, because the $$$4$$$-th child made a mistake in calculating the value of $$$r_4$$$, because there are no children to the right of him, so $$$r_4$$$ should be equal to $$$0$$$.
output
In the last example all children may have got the same number of candies, that's why all the numbers are $$$0$$$. Note that each child should receive at least one candy.
","constructivealgorithms, implementation",5
"n=int(input())
a=list(map(int,input().split()))
b=0
for i in range(n):
    if a[i]%2==1:
        if i%2==0:
            b+=1
        else:
            b-=1
if n%2==0:
    if b==0:
        print(""YES"")
    else:
        print(""NO"")
else:
    if b==0 or b==1:
        print(""YES"")
    else:
        print(""NO"")",1092_D1,CODEFORCES,2076,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math",3
"import sys
import copy
lines = iter(sys.stdin)

def nexts():
    return next(lines)

def nextint():
    return int(nexts())

def snexts():
    return next(lines).split(' ')

def snextint():
    return map(int, snexts())

def array(length, base=0):
    return [base] * length

def matrix(length, width, base=0):
    return [[base] * width for _ in range(length)]

n, m = snextint()
grid = array(n, [])

for i in range(n):
    grid[i] = list(nexts())

grid2 = copy.deepcopy(grid)

for i in range(1, n - 1):
    for j in range(1, m - 1):
        # print('Attempting on i=%d,j=%d'%(i,j))
        if grid[i - 1][j] == '#' and grid[i - 1][j + 1] == '#' and grid[i][j + 1] == '#' and grid[i + 1][j + 1] == '#' and grid[i + 1][j] == '#' and grid[i + 1][j - 1] == '#' and grid[i][j - 1] == '#' and grid[i - 1][j - 1] == '#':
            grid2[i - 1][j] = '.'
            grid2[i - 1][j + 1] = '.'
            grid2[i][j + 1] = '.'
            grid2[i + 1][j + 1] = '.'
            grid2[i + 1][j] = '.'
            grid2[i + 1][j - 1] = '.'
            grid2[i][j - 1] = '.'
            grid2[i - 1][j - 1] = '.'

match = True
for i in grid2:
    for ch in i:
        if ch == '#':
            match = False
            break

if match:
    print('YES')
else:
    print('NO')",1059_B,CODEFORCES,3541,Forgery,"Student Andrey has been skipping physical education lessons for the whole term, and now he must somehow get a passing grade on this subject. Obviously, it is impossible to do this by legal means, but Andrey doesn't give up. Having obtained an empty certificate from a local hospital, he is going to use his knowledge of local doctor's handwriting to make a counterfeit certificate of illness. However, after writing most of the certificate, Andrey suddenly discovered that doctor's signature is impossible to forge. Or is it?
For simplicity, the signature is represented as an $$$n\times m$$$ grid, where every cell is either filled with ink or empty. Andrey's pen can fill a $$$3\times3$$$ square without its central cell if it is completely contained inside the grid, as shown below.
Determine whether is it possible to forge the signature on an empty $$$n\times m$$$ grid.
The first line of input contains two integers $$$n$$$ and $$$m$$$ ($$$3 \le n, m \le 1000$$$).
Then $$$n$$$ lines follow, each contains $$$m$$$ characters. Each of the characters is either '.', representing an empty cell, or '#', representing an ink filled cell.
If Andrey can forge the signature, output ""YES"". Otherwise output ""NO"".
You can print each letter in any case (upper or lower).
In the first sample Andrey can paint the border of the square with the center in $$$(2, 2)$$$.
In the second sample the signature is impossible to forge.
","input
In the third sample Andrey can paint the borders of the squares with the centers in $$$(2, 2)$$$ and $$$(3, 2)$$$: 
output
In the fourth sample Andrey can paint the borders of the squares with the centers in $$$(3, 3)$$$ and $$$(3, 5)$$$.
",implementation,5
"import sys
import math
import itertools
import functools
import collections
import operator


def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def wr(arr): return ' '.join(map(str, arr))
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=1):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)


n, k = mi()
t = math.ceil(math.sqrt(2 * (n + k) + 2.25) - 1.5)
print(n - t)
",1195_B,CODEFORCES,1398,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"x, k = list(map(int,input().split()))
m = 1000000000 +7
if x!=0:
    p1 = x*2 - 1
    p2 = x*2
    p = (p1 + p2)//2
    print((p*pow(2,k,m) + 1)%m)
else:
    print(x*2)

",0992_C,CODEFORCES,1072,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"n,k=map(int,input().split())
a=list(map(int,input().split()))
d={}
for chr in a:
     if chr not in d:
        d[chr]=1
     else:
        d[chr]+=1
p=list(d.values())
z=k//n
if z==0 :
     print(0)
else:
     o=[]
     if len(a)>=n:
        o.append(1)
     for i in range(2,z+1):
         c=0
         for j in range(len(p)):
             c+=p[j]//i
         if c>=n:
             o.append(i)
     print(max(o))",1011_B,CODEFORCES,2734,Planning The Expedition,"Natasha is planning an expedition to Mars for $$$n$$$ people. One of the important tasks is to provide food for each participant.
The warehouse has $$$m$$$ daily food packages. Each package has some food type $$$a_i$$$.
Each participant must eat exactly one food package each day. Due to extreme loads, each participant must eat the same food type throughout the expedition. Different participants may eat different (or the same) types of food.
Formally, for each participant $$$j$$$ Natasha should select his food type $$$b_j$$$ and each day $$$j$$$-th participant will eat one food package of type $$$b_j$$$. The values $$$b_j$$$ for different participants may be different.
What is the maximum possible number of days the expedition can last, following the requirements above?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 100$$$, $$$1 \le m \le 100$$$) — the number of the expedition participants and the number of the daily food packages available.
The second line contains sequence of integers $$$a_1, a_2, \dots, a_m$$$ ($$$1 \le a_i \le 100$$$), where $$$a_i$$$ is the type of $$$i$$$-th food package.
Print the single integer — the number of days the expedition can last. If it is not possible to plan the expedition for even one day, print 0.
","input
In the first example, Natasha can assign type $$$1$$$ food to the first participant, the same type $$$1$$$ to the second, type $$$5$$$ to the third and type $$$2$$$ to the fourth. In this case, the expedition can last for $$$2$$$ days, since each participant can get two food packages of his food type (there will be used $$$4$$$ packages of type $$$1$$$, two packages of type $$$2$$$ and two packages of type $$$5$$$).
output
In the second example, there are $$$100$$$ participants and only $$$1$$$ food package. In this case, the expedition can't last even $$$1$$$ day.
","binarysearch, bruteforce, implementation",4
"import math
from math import factorial

def combination(n,r):
    return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r))

a = input()
ap = a.count('+')
am = a.count('-')
b = input()
bp = b.count('+')
bm = b.count('-')
n = b.count('?')
x = float(ap - bp)
y = float(am - bm)
if (x < 0 or y < 0 or x+y != n):
    print(0.0)
else:
    print(combination(n,x)/(1<<n))
",0476_B,CODEFORCES,4314,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"import sys
#import random
#import bisect
from collections import deque
#sys.setrecursionlimit(10**6)
from queue import PriorityQueue
from math import gcd
from math import log
from math import ceil
from math import pi
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
mod = 10**9 + 7

n,mod = il()
N = 406

fact = [1 for i in range (N)]
inver = [1 for i in range (N)]
power2 = [1 for i in range (N)]
ncr = [[1 for i in range (N)] for j in range (N)]
dp = [[0 for i in range (N)] for j in range (N)]

def precom() :

    fact[0] = 1
    inver[0] = 1

    for i in range (1,N) :
        fact[i] = (fact[i-1]*i)%mod
        inver[i] = pow(fact[i],mod-2,mod)

    for i in range (N) :
        for j in range (i+1) :
            ncr[i][j] = (((fact[i]*inver[j])%mod)*inver[i-j])%mod

    for i in range(1,N) :
        power2[i] = (power2[i-1]*2)%mod

precom()

dp[0][0] = 1

for i in range (n) :
    for j in range (i+1) :
        k = 1
        while (k+i <= n) :

            dp[i+k+1][j+k] = (dp[i+k+1][j+k] + ((dp[i][j]*power2[k-1])%mod*ncr[j+k][k])%mod)%mod
            
            k += 1

ans = 0

for i in range (n+1) :
    ans = (ans + dp[n+1][i])%mod

print(ans)

    
",1515_E,CODEFORCES,4051,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
import io
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
from collections import Counter
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: max(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=0, func=lambda a, b: a+b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(11)] 
prime[0]=prime[1]=False
#pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p <= n): 
          
        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p): 
                #pp[i]=1
                prime[i] = False
        p += 1
#-----------------------------------DSU--------------------------------------------------
class DSU:
    def __init__(self, R, C):
        #R * C is the source, and isn't a grid square
        self.par = range(R*C + 1)
        self.rnk = [0] * (R*C + 1)
        self.sz = [1] * (R*C + 1)

    def find(self, x):
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]

    def union(self, x, y):
        xr, yr = self.find(x), self.find(y)
        if xr == yr: return
        if self.rnk[xr] < self.rnk[yr]:
            xr, yr = yr, xr
        if self.rnk[xr] == self.rnk[yr]:
            self.rnk[xr] += 1

        self.par[yr] = xr
        self.sz[xr] += self.sz[yr]

    def size(self, x):
        return self.sz[self.find(x)]

    def top(self):
        # Size of component at ephemeral ""source"" node at index R*C,
        # minus 1 to not count the source itself in the size
        return self.size(len(self.sz) - 1) - 1
#---------------------------------Lazy Segment Tree--------------------------------------
# XXXX
class LazySegTree:
    def __init__(self, _op, _e, _mapping, _composition, _id, v):
        def set(p, x):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            _d[p] = x
            for i in range(1, _log + 1):
                _update(p >> i)
 
        def get(p):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            return _d[p]
 
        def prod(l, r):
            assert 0 <= l <= r <= _n
 
            if l == r:
                return _e
 
            l += _size
            r += _size
 
            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push(r >> i)
 
            sml = _e
            smr = _e
            while l < r:
                if l & 1:
                    sml = _op(sml, _d[l])
                    l += 1
                if r & 1:
                    r -= 1
                    smr = _op(_d[r], smr)
                l >>= 1
                r >>= 1
 
            return _op(sml, smr)
 
        def apply(l, r, f):
            assert 0 <= l <= r <= _n
            if l == r:
                return
 
            l += _size
            r += _size
 
            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push((r - 1) >> i)
 
            l2 = l
            r2 = r
            while l < r:
                if l & 1:
                    _all_apply(l, f)
                    l += 1
                if r & 1:
                    r -= 1
                    _all_apply(r, f)
                l >>= 1
                r >>= 1
            l = l2
            r = r2
 
            for i in range(1, _log + 1):
                if ((l >> i) << i) != l:
                    _update(l >> i)
                if ((r >> i) << i) != r:
                    _update((r - 1) >> i)
 
        def _update(k):
            _d[k] = _op(_d[2 * k], _d[2 * k + 1])
 
        def _all_apply(k, f):
            _d[k] = _mapping(f, _d[k])
            if k < _size:
                _lz[k] = _composition(f, _lz[k])
 
        def _push(k):
            _all_apply(2 * k, _lz[k])
            _all_apply(2 * k + 1, _lz[k])
            _lz[k] = _id
 
        _n = len(v)
        _log = _n.bit_length()
        _size = 1 << _log
        _d = [_e] * (2 * _size)
        _lz = [_id] * _size
        for i in range(_n):
            _d[_size + i] = v[i]
        for i in range(_size - 1, 0, -1):
            _update(i)
 
        self.set = set
        self.get = get
        self.prod = prod
        self.apply = apply
 
 
MIL = 1 << 20
 
 
def makeNode(total, count):
    # Pack a pair into a float
    return (total * MIL) + count
 
 
def getTotal(node):
    return math.floor(node / MIL)
 
 
def getCount(node):
    return node - getTotal(node) * MIL
 
 
nodeIdentity = makeNode(0.0, 0.0)
 
 
def nodeOp(node1, node2):
    return node1 + node2
    # Equivalent to the following:
    return makeNode(
        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)
    )
 
 
identityMapping = -1
 
 
def mapping(tag, node):
    if tag == identityMapping:
        return node
    # If assigned, new total is the number assigned times count
    count = getCount(node)
    return makeNode(tag * count, count)
 
 
def composition(mapping1, mapping2):
    # If assigned multiple times, take first non-identity assignment
    return mapping1 if mapping1 != identityMapping else mapping2
#---------------------------------Pollard rho--------------------------------------------
def memodict(f):
    """"""memoization decorator for a function taking a single argument""""""
    class memodict(dict):
        def __missing__(self, key):
            ret = self[key] = f(key)
            return ret
 
    return memodict().__getitem__
 
 
def pollard_rho(n):
    """"""returns a random factor of n""""""
    if n & 1 == 0:
        return 2
    if n % 3 == 0:
        return 3
 
    s = ((n - 1) & (1 - n)).bit_length() - 1
    d = n >> s
    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
        p = pow(a, d, n)
        if p == 1 or p == n - 1 or a % n == 0:
            continue
        for _ in range(s):
            prev = p
            p = (p * p) % n
            if p == 1:
                return math.gcd(prev - 1, n)
            if p == n - 1:
                break
        else:
            for i in range(2, n):
                x, y = i, (i * i + 1) % n
                f = math.gcd(abs(x - y), n)
                while f == 1:
                    x, y = (x * x + 1) % n, (y * y + 1) % n
                    y = (y * y + 1) % n
                    f = math.gcd(abs(x - y), n)
                if f != n:
                    return f
    return n
 
 
@memodict
def prime_factors(n):
    """"""returns a Counter of the prime factorization of n""""""
    if n <= 1:
        return Counter()
    f = pollard_rho(n)
    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)
 
 
def distinct_factors(n):
    """"""returns a list of all distinct factors of n""""""
    factors = [1]
    for p, exp in prime_factors(n).items():
        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]
    return factors
 
 
def all_factors(n):
    """"""returns a sorted list of all distinct factors of n""""""
    small, large = [], []
    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
        if not n % i:
            small.append(i)
            large.append(n // i)
    if small[-1] == large[-1]:
        large.pop()
    large.reverse()
    small.extend(large)
    return small

#---------------------------------Binary Search------------------------------------------
def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res = n
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            res=mid
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=-1
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=mid
            left = mid + 1
    return res
#---------------------------------running code------------------------------------------
t=1
#t=int(input())
for _ in range (t):
    n=int(input())
    #n,m=map(int,input().split())
    a=list(map(int,input().split()))
    #b=list(map(int,input().split()))
    #s=input()
    #n=len(s)
    twopow = [1]*(10**5+69)
    for i in range(1, 10**5+69):
        twopow[i] = (twopow[i-1] * 2) % mod
    count = [0]*100069
    for i in a:
        count[i] += 1
    multiples = [0]*100069
    for i in range(1, 10**5+1):
        for j in range(i, 10**5+1, i):
            multiples[i] += count[j]
    gcd_of = [0]*100069
    for i in range(10**5, 0, -1):
        gcd_of[i] = (twopow[multiples[i]] - 1) % mod
        for j in range(2*i, 10**5+1, i):
            gcd_of[i] -= gcd_of[j]
    print(gcd_of[1] % mod)",0803_F,CODEFORCES,4545,Coprime Subsequences,"Let's call a non-empty sequence of positive integers a1, a2... ak coprime if the greatest common divisor of all elements of this sequence is equal to 1.
Given an array a consisting of n positive integers, find the number of its coprime subsequences. Since the answer may be very large, print it modulo 109 + 7.
Note that two subsequences are considered different if chosen indices are different. For example, in the array [1, 1] there are 3 different subsequences: [1], [1] and [1, 1].
The first line contains one integer number n (1 ≤ n ≤ 100000).
The second line contains n integer numbers a1, a2... an (1 ≤ ai ≤ 100000).
Print the number of coprime subsequences of a modulo 109 + 7.
","input
In the first example coprime subsequences are: 
output
In the second example all subsequences are coprime.
","bitmasks, combinatorics, numbertheory",7
"import sys
input = sys.stdin.readline

class sieve:
  def __init__(self, n):
    self.n = n
    self.sv = [1] * (n + 1)
    self.sv[0] = 0
    self.sv[1] = 0
    for i in range(2, n + 1):
      if self.sv[i]:
        for j in range(i * 2, n + 1, i):
          self.sv[j] = 0
  def isprime(self, x):
    if x > self.n:
      return False
    return self.sv[x] == 1
  def factorize(self, x):
    res = []
    for i in range(2, int(x ** 0.5) + 1):
      if self.sv[i]:
        while x % i == 0:
          x //= i
          res.append(i)
    if x != 1:
      res.append(x)
    return res
  def modlcm(self, a, mod):
    res = [0] * (self.n + 1)
    ex = set()
    for i in range(len(a)):
      f = self.factorize(a[i])
      for j in f:
        if j > self.n:
          ex.add(j)
          continue
        res[j] = max(f.count(j), res[j])
    rres = 1
    for i in range(self.n + 1):
      if res[i] != 0:
        rres *= pow(i, res[i], mod)
        rres %= mod
    for i in ex:
      rres *= i
      rres %= mod
    return rres

sv = sieve(10 ** 4)
for _ in range(int(input())):
  n, k = map(int, input().split())
  a = list(map(int, input().split()))
  for i in range(n):
    x = a[i]
    q = sv.factorize(x)
    s = [1]
    while len(q):
      y = q.pop()
      if y == s[-1]:
        s.pop()
        a[i] //= y ** 2
      else: s.append(y)
  s = [set() for _ in range(k + 1)]
  #print(a)
  dp = [n] * (k + 1)
  dp[0] = 0

  for i in range(n):
    for j in range(k, -1, -1):
      if dp[j] == n: continue
      if a[i] in s[j]:
        if j + 1 <= k and dp[j + 1] > dp[j]:
          dp[j + 1] = dp[j]
          s[j + 1] = s[j]
        dp[j] += 1
        s[j] = set()
        s[j].add(a[i])
      else:
        s[j].add(a[i])
      

    #print(dp, s)

  for j in range(k + 1): dp[j] += len(s[j]) > 0
  print(min(dp))
",1497_E2,CODEFORCES,4016,Square-Free Division (hard version),"This is the hard version of the problem. The only difference is that in this version $$$0 \leq k \leq 20$$$.
There is an array $$$a_1, a_2, \ldots, a_n$$$ of $$$n$$$ positive integers. You should divide it into a minimal number of continuous segments, such that in each segment there are no two numbers (on different positions), whose product is a perfect square.
Moreover, it is allowed to do at most $$$k$$$ such operations before the division: choose a number in the array and change its value to any positive integer.
What is the minimum number of continuous segments you should use if you will make changes optimally?
The first line contains a single integer $$$t$$$ $$$(1 \le t \le 1000)$$$  — the number of test cases.
The first line of each test case contains two integers $$$n$$$, $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$0 \leq k \leq 20$$$).
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 10^7$$$).
It's guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \cdot 10^5$$$.
For each test case print a single integer  — the answer to the problem.
","input
In the first test case it is possible to change the array this way: $$$[\underline{3}, 6, 2, 4, \underline{5}]$$$ (changed elements are underlined). After that the array does not need to be divided, so the answer is $$$1$$$.
output
In the second test case it is possible to change the array this way: $$$[6, 2, \underline{3}, 8, 9, \underline{5}, 3, 6, \underline{10}, \underline{11}, 7]$$$. After that such division is optimal: 
","datastructures, dp, greedy, math, numbertheory, twopointers",6
"from math import factorial,pow
send = input()
received = input()

pos = 0
for p in send:
	pos = pos +1 if p=='+' else pos-1
qcount = 0
curr_pos = 0
for p in received:
	if p=='+':
		curr_pos = curr_pos +1  
	elif(p=='-'):
		curr_pos = curr_pos-1
	if p=='?':
		qcount +=1

if qcount == 0:
	print(""{:.12f}"".format(1.0 if pos==curr_pos else 0.0))
else:
	exp_val_q = abs(pos -curr_pos)
	if exp_val_q%2!=qcount%2 or qcount<exp_val_q:
		print(""{:.12f}"".format(0.0))
	else:
		neg = (qcount - exp_val_q)/2
		posi = qcount - neg
		val = factorial(qcount)/(factorial(neg)*factorial(posi)*pow(2,qcount))
		print(""{:.12f}"".format(val))



",0476_B,CODEFORCES,4339,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"def main():
    n = int(input())
    piles = list(map(int,input().split()))
    piles.sort()
    num = piles[0]
    count = 1
    two = 0
    two_num = 0
    for i in range(1,n):
        if piles[i] == num:
            count += 1
        else:
            #print(count,'hhere')
            if count > 2:
                print('cslnb')
                return
            elif count == 2:
                two_num = num
                two += 1
            num = piles[i]
            count = 1

    if count == 2:
        two_num = num
        two += 1
    if count > 2:
        print('cslnb')
        return
    if two > 1:
        print('cslnb')
        return
    
    #print(two)
    if two == 1:
        if (two_num-1) in piles:
            print('cslnb')
            return

    if n >= 2:
        if piles[0] == piles[1] and piles[0] == 0:
            print('cslnb')
            return
    moves = 0
    curr = 0
    for i in range(n):
        if piles[i] >= curr:
            moves += piles[i]-curr
            piles[i] = curr
            curr += 1

    for i in piles:
        if i > 0:
            moves += 1
            break

    #print(moves)
    if n == 1:
        moves += 1
    if moves%2 != 0:
        print('cslnb')
    else:
        print('sjfnb')
        

main()
",1191_D,CODEFORCES,2994,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy",4
"from collections import*
R=lambda:map(int,input().split())
n,m=R()
a=Counter(R()).values()
i=1
while sum(x//i for x in a)>=n:i+=1
print(i-1)
          ",1011_B,CODEFORCES,2741,Planning The Expedition,"Natasha is planning an expedition to Mars for $$$n$$$ people. One of the important tasks is to provide food for each participant.
The warehouse has $$$m$$$ daily food packages. Each package has some food type $$$a_i$$$.
Each participant must eat exactly one food package each day. Due to extreme loads, each participant must eat the same food type throughout the expedition. Different participants may eat different (or the same) types of food.
Formally, for each participant $$$j$$$ Natasha should select his food type $$$b_j$$$ and each day $$$j$$$-th participant will eat one food package of type $$$b_j$$$. The values $$$b_j$$$ for different participants may be different.
What is the maximum possible number of days the expedition can last, following the requirements above?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 100$$$, $$$1 \le m \le 100$$$) — the number of the expedition participants and the number of the daily food packages available.
The second line contains sequence of integers $$$a_1, a_2, \dots, a_m$$$ ($$$1 \le a_i \le 100$$$), where $$$a_i$$$ is the type of $$$i$$$-th food package.
Print the single integer — the number of days the expedition can last. If it is not possible to plan the expedition for even one day, print 0.
","input
In the first example, Natasha can assign type $$$1$$$ food to the first participant, the same type $$$1$$$ to the second, type $$$5$$$ to the third and type $$$2$$$ to the fourth. In this case, the expedition can last for $$$2$$$ days, since each participant can get two food packages of his food type (there will be used $$$4$$$ packages of type $$$1$$$, two packages of type $$$2$$$ and two packages of type $$$5$$$).
output
In the second example, there are $$$100$$$ participants and only $$$1$$$ food package. In this case, the expedition can't last even $$$1$$$ day.
","binarysearch, bruteforce, implementation",4
"import sys
input = sys.stdin.readline

a,b,c = list(map(int,input().split()))

x = list(map(int,input().split()))
y = list(map(int,input().split()))
z = list(map(int,input().split()))

x.sort(reverse=True)
y.sort(reverse=True)
z.sort(reverse=True)

a+=1
b+=1
c+=1

x = [0] + x
y = [0] + y
z = [0] + z

tmp = [[0]*c for _ in range(b)]
best = [tmp for _ in range(a)]

#print(tmp)
#print(best)
ans = 0

for i in range(a):
    for j in range(b):
        for k in range(c):
            if (i+j+k) % 2 == 0:
                aa,bb,cc = 0,0,0
                if i>0 and j>0:
                    aa = best[i-1][j-1][k] + x[i] * y[j]
                if i>0 and k>0:
                    bb = best[i-1][j][k-1] + x[i] * z[k]
                if j>0 and k>0:
                    cc = best[i][j-1][k-1] + y[j] * z[k]
                
                best[i][j][k] = max(aa,bb,cc)
                ans = max(ans, best[i][j][k])
#print(best)
print(ans)
",1398_D,CODEFORCES,3913,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"a,d=map(int,input().split())
y,g,b=map(int,input().split())
m=y*2+g
n=b*3+g
c=0
if(m>a):
    c+=m-a
if(n>d):
    c+=n-d
print(c)
",0912_A,CODEFORCES,214,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation,1
"n, k = (int(x) for x in input().split())
 
if k > n * 2 or k < 3:
    print(0)
elif n >= k-1:
    print(k - k//2 - 1)
else:
    print(n - k//2)",1023_B,CODEFORCES,413,Pair of Toys,"Tanechka is shopping in the toy shop. There are exactly $$$n$$$ toys in the shop for sale, the cost of the $$$i$$$-th toy is $$$i$$$ burles. She wants to choose two toys in such a way that their total cost is $$$k$$$ burles. How many ways to do that does she have?
Each toy appears in the shop exactly once. Pairs $$$(a, b)$$$ and $$$(b, a)$$$ are considered equal. Pairs $$$(a, b)$$$, where $$$a=b$$$, are not allowed.
The first line of the input contains two integers $$$n$$$, $$$k$$$ ($$$1 \le n, k \le 10^{14}$$$) — the number of toys and the expected total cost of the pair of toys.
Print the number of ways to choose the pair of toys satisfying the condition above. Print 0, if Tanechka can choose no pair of toys in such a way that their total cost is $$$k$$$ burles.
In the first example Tanechka can choose the pair of toys ($$$1, 4$$$) or the pair of toys ($$$2, 3$$$).
In the second example Tanechka can choose only the pair of toys ($$$7, 8$$$).
","input
In the third example choosing any pair of toys will lead to the total cost less than $$$20$$$. So the answer is 0.
output
In the fourth example she can choose the following pairs: $$$(1, 1000000000000)$$$, $$$(2, 999999999999)$$$, $$$(3, 999999999998)$$$, ..., $$$(500000000000, 500000000001)$$$. The number of such pairs is exactly $$$500000000000$$$.
",math,1
"n,m=input().split()
i=j=-1
while(j<0):
    mat=input()
    j=mat.find('B')
    i+=1
    c=mat.count('B')//2+1
print(i+c,j+c)",1028_A,CODEFORCES,3428,Find Square,"Consider a table of size $$$n \times m$$$, initially fully white. Rows are numbered $$$1$$$ through $$$n$$$ from top to bottom, columns $$$1$$$ through $$$m$$$ from left to right. Some square inside the table with odd side length was painted black. Find the center of this square.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 115$$$) — the number of rows and the number of columns in the table.
","input
The $$$i$$$-th of the next $$$n$$$ lines contains a string of $$$m$$$ characters $$$s_{i1} s_{i2} \ldots s_{im}$$$ ($$$s_{ij}$$$ is 'W' for white cells and 'B' for black cells), describing the $$$i$$$-th row of the table.
output
Output two integers $$$r$$$ and $$$c$$$ ($$$1 \le r \le n$$$, $$$1 \le c \le m$$$) separated by a space — the row and column numbers of the center of the black square.
",implementation,5
"s = input()
ans = 2
s1 = s[0:2]
s2 = s[3:5]
s3 = s[6:8]
def func(inp):
    ans = 2
    num = int(inp[0])
    c = inp[1]
    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num + 2)+c) != -1))
    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num - 1)+c) != -1))
    ans = min( ans, 2 - int(s.find(str(num - 1)+c) != -1) - int(s.find(str(num - 2)+c) != -1))
    ans = min( ans, 3 - s.count(inp))
    return ans
ans = min(ans,func(s1))
ans = min(ans,func(s2))
ans = min(ans,func(s3))
print(ans)
",1191_B,CODEFORCES,2203,Tokitsukaze and Mahjong,"Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $$$1$$$ to $$$9$$$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $$$\ldots$$$, 9m, 1p, 2p, $$$\ldots$$$, 9p, 1s, 2s, $$$\ldots$$$, 9s.
In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.
Do you know the minimum number of extra suited tiles she needs to draw so that she can win?
Here are some useful definitions in this game:
Some examples: 
Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.
The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $$$1$$$ to $$$9$$$ and the second character is m, p or s.
Print a single integer — the minimum number of extra suited tiles she needs to draw.
In the first example, Tokitsukaze already has a shuntsu.
","input
In the second example, Tokitsukaze already has a koutsu.
output
In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
","bruteforce, implementation",3
"#!/usr/bin/env python3
import io
import os
import sys

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

def prdbg(*args, **kwargs):
    print(*args, **kwargs)
    pass

def get_str():
    return input().decode().strip()

def rint():
    return map(int, input().split())

def oint():
    return int(input())

def valid(i1,i2,i3):
    if (i1+i2+i3)%2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2\
            or i2 > i1 + i3 or i1 > i2 + i3:
        return False
    return True

def dfs(i1,i2,i3):
    #if not valid(i1, i2, i3):
    if (i1 + i2 + i3) % 2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2 \
                or i2 > i1 + i3 or i1 > i2 + i3:
        return -2
    if dp[i1][i2][i3] != -1:
        return dp[i1][i2][i3]
    ret1 = dfs(i1-1, i2-1, i3)
    if ret1 >= 0 :
        ret1 += a1[i1]*a2[i2]
    ret2 = dfs(i1-1, i2, i3-1)
    if ret2 >= 0:
        ret2 += a1[i1]*a3[i3]
    ret3 = dfs(i1, i2-1, i3-1)
    if ret3 >= 0:
        ret3 += a2[i2]*a3[i3]
    ret = max(ret1, ret2, ret3)
    dp[i1][i2][i3] = ret
    return ret

n1, n2, n3 = rint()
a1, a2, a3 = list(rint()), list(rint()), list(rint())
a1.sort(reverse=True)
a2.sort(reverse=True)
a3.sort(reverse=True)
a1 = [0] + a1
a2 = [0] + a2
a3 = [0] + a3
n1 += 1
n2 += 1
n3 += 1

dp = [[[-1 for i3 in range(n3)] for i2 in range(n2)] for i1 in range(n1)]
dp[1][1][0] = a1[1]*a2[1]
dp[1][0][1] = a1[1]*a3[1]
dp[0][1][1] = a2[1]*a3[1]
dp[0][0][0] = -2

for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            dfs(i1, i2, i3)
ans = -1
for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            ans = max(ans, dp[i1][i2][i3])
#print(a1,a2,a3)
print(ans)
",1398_D,CODEFORCES,3950,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"I = lambda: map(int, input().split())

n, l, r, x = I()
C, k = [*I()], 0

for i in range(2 ** n):
    W = [w for w, b in zip(C, bin(i)[2:].zfill(n)) if b == '1']
    if l <= sum(W) <= r and max(W) - min(W) >= x:
        k += 1

print(k)",0550_B,CODEFORCES,4440,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"from sys import stdin
input=stdin.readline
def check(mid,a,limit):
	res=[]
	s=0
	for r,t,id in a:
		if r>=mid and t+s<=limit:
			res.append(id+1)
			s+=t
		elif t+s>limit:
			break
		if len(res)==mid:
			break
	# print(res,s)
	return res

def f(a,limit):
	a.sort(key=lambda s:s[1])
	ans=None
	lo=0
	hi=len(a)+1
	while lo<=hi:
		mid=(lo+hi)//2
		res=check(mid,a,limit)
		if len(res)>=mid:
			lo=mid+1
			ans=(res,mid)
		else:
			hi=mid-1
	print(ans[1])
	print(ans[1])
	print(*ans[0])


n,limit=map(int,input().strip().split())
q=[]
for i in range(n):
	x,y=map(int,input().strip().split())
	q.append((x,y,i))
f(q,limit)",0913_D,CODEFORCES,2459,Too Easy Problems,"You are preparing for an exam on scheduling theory. The exam will last for exactly T milliseconds and will consist of n problems. You can either solve problem i in exactly ti milliseconds or ignore it and spend no time. You don't need time to rest after solving a problem, either.
Unfortunately, your teacher considers some of the problems too easy for you. Thus, he assigned an integer ai to every problem i meaning that the problem i can bring you a point to the final score only in case you have solved no more than ai problems overall (including problem i).
Formally, suppose you solve problems p1, p2, ..., pk during the exam. Then, your final score s will be equal to the number of values of j between 1 and k such that k ≤ apj.
You have guessed that the real first problem of the exam is already in front of you. Therefore, you want to choose a set of problems to solve during the exam maximizing your final score in advance. Don't forget that the exam is limited in time, and you must have enough time to solve all chosen problems. If there exist different sets of problems leading to the maximum final score, any of them will do.
The first line contains two integers n and T (1 ≤ n ≤ 2·105; 1 ≤ T ≤ 109) — the number of problems in the exam and the length of the exam in milliseconds, respectively.
Each of the next n lines contains two integers ai and ti (1 ≤ ai ≤ n; 1 ≤ ti ≤ 104). The problems are numbered from 1 to n.
In the first line, output a single integer s — your maximum possible final score.
In the second line, output a single integer k (0 ≤ k ≤ n) — the number of problems you should solve.
In the third line, output k distinct integers p1, p2, ..., pk (1 ≤ pi ≤ n) — the indexes of problems you should solve, in any order.
If there are several optimal sets of problems, you may output any of them.
In the first example, you should solve problems 3, 1, and 4. In this case you'll spend 80 + 100 + 90 = 270 milliseconds, falling within the length of the exam, 300 milliseconds (and even leaving yourself 30 milliseconds to have a rest). Problems 3 and 1 will bring you a point each, while problem 4 won't. You'll score two points.
","input
In the second example, the length of the exam is catastrophically not enough to solve even a single problem.
output
In the third example, you have just enough time to solve both problems in 42 + 58 = 100 milliseconds and hand your solutions to the teacher with a smile.
","binarysearch, bruteforce, datastructures, greedy, sortings",4
"import sys

input = sys.stdin.readline

from collections import deque

n,m,k = map(int,input().split())
p = [input().rstrip() for i in range(n)]
idx = {s:i for i,s in enumerate(p)}

def match(s):
    res = []
    for i in range(2**k):
        tmp = []
        for j in range(k):
            if i>>j & 1:
                tmp.append(s[j])
            else:
                tmp.append(""_"")
        res.append("""".join(tmp))
    return set(res)

edge = [[] for i in range(n)]
deg = [0]*n
for i in range(m):
    s,mt = input().rstrip().split()
    mt = int(mt)-1
    t = p[mt]
    M = match(s)
    if t in M:
        for nv in M:
            if nv!=t and nv in idx:
                nv = idx[nv]
                edge[mt].append(nv)
                deg[nv] += 1
    else:
        exit(print(""NO""))

deq = deque([v for v in range(n) if deg[v]==0])
res = []
while deq:
    v = deq.popleft()
    res.append(v+1)
    for nv in edge[v]:
        deg[nv] -= 1
        if deg[nv]==0:
            deq.append(nv)

if len(res)!=n:
    exit(print(""NO""))

print(""YES"")
print(*res)
",1476_E,CODEFORCES,4723,Pattern Matching,"You are given $$$n$$$ patterns $$$p_1, p_2, \dots, p_n$$$ and $$$m$$$ strings $$$s_1, s_2, \dots, s_m$$$. Each pattern $$$p_i$$$ consists of $$$k$$$ characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string $$$s_j$$$ consists of $$$k$$$ lowercase Latin letters.
A string $$$a$$$ matches a pattern $$$b$$$ if for each $$$i$$$ from $$$1$$$ to $$$k$$$ either $$$b_i$$$ is a wildcard character or $$$b_i=a_i$$$.
You are asked to rearrange the patterns in such a way that the first pattern the $$$j$$$-th string matches is $$$p[mt_j]$$$. You are allowed to leave the order of the patterns unchanged.
Can you perform such a rearrangement? If you can, then print any valid order.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \le n, m \le 10^5$$$, $$$1 \le k \le 4$$$) — the number of patterns, the number of strings and the length of each pattern and string.
Each of the next $$$n$$$ lines contains a pattern — $$$k$$$ characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct.
Each of the next $$$m$$$ lines contains a string — $$$k$$$ lowercase Latin letters, and an integer $$$mt$$$ ($$$1 \le mt \le n$$$) — the index of the first pattern the corresponding string should match.
Print ""NO"" if there is no way to rearrange the patterns in such a way that the first pattern that the $$$j$$$-th string matches is $$$p[mt_j]$$$.
Otherwise, print ""YES"" in the first line. The second line should contain $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ — the order of the patterns. If there are multiple answers, print any of them.
The order of patterns after the rearrangement in the first example is the following: 
Thus, the first string matches patterns ab__, _bcd, _b_d in that order, the first of them is ab__, that is indeed $$$p[4]$$$. The second string matches __b_ and ab__, the first of them is __b_, that is $$$p[2]$$$. The last string matches _bcd and _b_d, the first of them is _bcd, that is $$$p[5]$$$.
The answer to that test is not unique, other valid orders also exist.
","input
In the second example cba doesn't match __c, thus, no valid order exists.
output
In the third example the order (a_, _b) makes both strings match pattern $$$1$$$ first and the order (_b, a_) makes both strings match pattern $$$2$$$ first. Thus, there is no order that produces the result $$$1$$$ and $$$2$$$.
","bitmasks, datastructures, dfsandsimilar, graphs, hashing, sortings, strings",7
"def func(n,i):
        if n==3:
                return (str(1*i)+' ')+(str(1*i)+' ')+(str(3*i))
        if n%2==0:
                odd=n//2
        else:
                odd=n//2+1
        q=1*i
        s= (str(q)+' ')*odd
        return s
        
        
from math import log
n=int(input())
if n==3:
        s='1 1 3'
else:
        s=''
        z=1
        while(n>0):
                s=s+func(n,z)
                z=z*2
                if n==3:
                        break
                if n%2==0:
                        odd=n//2
                else:
                        odd=n//2+1
                n=n-odd
print(s)

                
                
",1059_C,CODEFORCES,1161,Sequence Transformation,"Let's call the following process a transformation of a sequence of length $$$n$$$.
If the sequence is empty, the process ends. Otherwise, append the greatest common divisor (GCD) of all the elements of the sequence to the result and remove one arbitrary element from the sequence. Thus, when the process ends, we have a sequence of $$$n$$$ integers: the greatest common divisors of all the elements in the sequence before each deletion.
You are given an integer sequence $$$1, 2, \dots, n$$$. Find the lexicographically maximum result of its transformation.
A sequence $$$a_1, a_2, \ldots, a_n$$$ is lexicographically larger than a sequence $$$b_1, b_2, \ldots, b_n$$$, if there is an index $$$i$$$ such that $$$a_j = b_j$$$ for all $$$j < i$$$, and $$$a_i > b_i$$$.
The first and only line of input contains one integer $$$n$$$ ($$$1\le n\le 10^6$$$).
Output $$$n$$$ integers  — the lexicographically maximum result of the transformation.
","input
In the first sample the answer may be achieved this way:
output
We get the sequence $$$[1, 1, 3]$$$ as the result.
","constructivealgorithms, math",2
"a = input()
b = input()
la = [int(x) for x in a]
res = []
la.sort()
la = la[::-1]
lb = [int(x) for x in b]
cnt = [0] * 20

def check():
    tres = 0
    for x in range(len(res)):
        tres *= 10
        tres += int(res[x])
    return tres <= int(b)
if len(a) < len(b):
    for i in range(len(la)):
        print(la[i], end = '')
    print()
else:
    for i in range(len(la)):
        cnt[la[i]] += 1
    flag = 0
    for i in range(len(lb)):
        if flag == 0 and cnt[lb[i]]:
            res.append(lb[i])
            cnt[lb[i]] -= 1
        else:
            flag = i - 1
            for j in range(lb[i] - 1, -1, -1):
                if cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
                    break
            for j in range(9, -1, -1):
                while cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
            break
    while not check():
        temp = []
        cnt = [0] * 20
        for x in range(flag):
            temp.append(res[x])
            cnt[res[x]] -= 1
        for i in la:
            cnt[i] += 1
        ##print(""cnt = "", cnt)
        res = temp
        ##print(flag, res)
        for v in range(lb[flag] - 1, -1, -1):
            if cnt[v]:
                res.append(v)
                cnt[v] -= 1
                break
        for v in range(9, -1, -1):
            while cnt[v]:
                res.append(v)
                cnt[v] -= 1
        ##print(flag, res)
        flag -= 1
    for i in range(len(res)):
        print(res[i], end = '')
    print()
",915C_,CODEFORCES,4220,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"from sys import stdin
MOD = 1000000007
s = stdin.readline().strip()
n = len(s)
buc = [0] * 101
fac = [0] * (n + 1)
inv = [0] * (n + 1)
dp = [0] * (n + 1)
# temp_dp = [0] * (n+1)
ans = [[0] * 55 for _ in range(55)]


def find(c: 'str') -> 'int':
    if 'A' <= c <= 'Z':
        return ord(c) - ord('A') + 26
    else:
        return ord(c) - ord('a')


def add(a: 'int', b: 'int') -> 'int':
    a += b
    if a >= MOD:
        a -= MOD
    return a


def sub(a: 'int', b: 'int') -> 'int':
    a -= b
    if a < 0:
        a += MOD
    return a


# c = Counter(s)

# # store frequency
# for k in c.keys():
#     buc[find(k)] = c[k]

for i in s:
    buc[find(i)] += 1  # naive count is fater than counter

# compute factorial and inv

fac[0] = 1
for i in range(1, n + 1):
    fac[i] = (fac[i - 1] * i) % MOD
inv[n] = pow(fac[n], MOD - 2, MOD)
for i in range(n - 1, -1, -1):
    inv[i] = (inv[i + 1] * (i + 1)) % MOD

num = pow(fac[n // 2], 2, MOD)
for i in range(0, 52):
    num = (num * inv[buc[i]]) % MOD

dp[0] = 1

for i in range(0, 52):
    if not buc[i]:
        continue
    for j in range(n, buc[i] - 1, -1):
        dp[j] = add(dp[j], dp[j - buc[i]])

for i in range(52):
    ans[i][i] = dp[n // 2]

for i in range(52):
    if not buc[i]:
        continue
    temp_dp = dp.copy()
    for k in range(buc[i], n + 1):
        temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[i]])

    for j in range(i + 1, 52):
        if not buc[j]:
            continue
        for k in range(buc[j], n + 1):
            temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[j]])

        ans[i][j] = (2 * temp_dp[n // 2]) % MOD

        for k in range(n, buc[j] - 1, -1):
            temp_dp[k] = add(temp_dp[k], temp_dp[k - buc[j]])

q = int(input())
l = stdin.read().splitlines()
for i in l:
    x, y = map(int, i.split())
    l, r = find(s[x - 1]), find(s[y - 1])
    if l > r:
        l, r = r, l
    print(num * ans[l][r] % MOD)
",1111_D,CODEFORCES,3793,Destroy the Colony,"There is a colony of villains with several holes aligned in a row, where each hole contains exactly one villain.
Each colony arrangement can be expressed as a string of even length, where the $$$i$$$-th character of the string represents the type of villain in the $$$i$$$-th hole. 
Iron Man can destroy a colony only if the colony arrangement is such that all villains of a certain type either live in the first half of the colony or in the second half of the colony.
His assistant Jarvis has a special power. It can swap villains of any two holes, i.e. swap any two characters in the string; he can do this operation any number of times.
Now Iron Man asks Jarvis $$$q$$$ questions. In each question, he gives Jarvis two numbers $$$x$$$ and $$$y$$$. Jarvis has to tell Iron Man the number of distinct colony arrangements he can create from the original one using his powers such that all villains having the same type as those originally living in $$$x$$$-th hole or $$$y$$$-th hole live in the same half and the Iron Man can destroy that colony arrangement.
Two colony arrangements are considered to be different if there exists a hole such that different types of villains are present in that hole in the arrangements.
The first line contains a string $$$s$$$ ($$$2 \le |s| \le 10^{5}$$$), representing the initial colony arrangement. String $$$s$$$ can have both lowercase and uppercase English letters and its length is even.
The second line contains a single integer $$$q$$$ ($$$1 \le q \le 10^{5}$$$) — the number of questions.
The $$$i$$$-th of the next $$$q$$$ lines contains two integers $$$x_i$$$ and $$$y_i$$$ ($$$1 \le x_i, y_i \le |s|$$$, $$$x_i \ne y_i$$$) — the two numbers given to the Jarvis for the $$$i$$$-th question.
","input
For each question output the number of arrangements possible modulo $$$10^9+7$$$.
output
Consider the first example. For the first question, the possible arrangements are ""aabb"" and ""bbaa"", and for the second question, index $$$1$$$ contains 'a' and index $$$2$$$ contains 'b' and there is no valid arrangement in which all 'a' and 'b' are in the same half.
","combinatorics, dp, math",6
"n,k=input().split()
n=int(n)
k=int(k)

m = 1000000007
# z = (2**k)%m
z = pow(2,k,m)

ans = (((2*z)*(n%m))%m - (z-1))%m
if n==0:
	print(0)
else:
	print(ans)",0992_C,CODEFORCES,1085,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"n = int(input())
ans = 1
for i in range(1, n):
    ans += i * 4
print(ans)",1180_A,CODEFORCES,2148,Alex and a Rhombus,"While playing with geometric figures Alex has accidentally invented a concept of a $$$n$$$-th order rhombus in a cell grid.
A $$$1$$$-st order rhombus is just a square $$$1 \times 1$$$ (i.e just a cell).
A $$$n$$$-th order rhombus for all $$$n \geq 2$$$ one obtains from a $$$n-1$$$-th order rhombus adding all cells which have a common side with it to it (look at the picture to understand it better).
Alex asks you to compute the number of cells in a $$$n$$$-th order rhombus.
The first and only input line contains integer $$$n$$$ ($$$1 \leq n \leq 100$$$) — order of a rhombus whose numbers of cells should be computed.
","input
Print exactly one integer — the number of cells in a $$$n$$$-th order rhombus.
output
Images of rhombus corresponding to the examples are given in the statement.
","dp, implementation, math",3
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    ans = []
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            ans.append('even')
        else:
            ans.append('odd')
    print('\n'.join(ans))

main()",0911_D,CODEFORCES,3106,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

n = mint()
a = [0]*n
dp = [0]*n
for i in range(n):
	a[i] = tuple(mints())
a.sort()
for i in range(n):
	x, p = a[i]
	l = -1
	r = n
	v = x-p
	while r-l > 1:
		c = (l + r)//2
		if a[c][0] >= v:
			r = c
		else:
			l = c
		if l == -1:
			dp[i] = i-l-1
		else:
			dp[i] = i-l-1+dp[l]
#print(dp)
z = 1e9
for i in range(n):
	z = min(z,dp[i]+n-i-1)
print(z)",0608_C,CODEFORCES,1510,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp,3
"n, m, k = map(int,input().split())
line = [int(x) for x in input().split()]
line.sort(reverse = True)
count = 0
if k >=m:
    print(count)
    exit(0)
for i in range(n):
    k += line[i]-1
    count += 1
    if k >= m:
        print(count)
        exit(0)
print(-1)",0257_A,CODEFORCES,2382,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings",4
"n = int(input())
li = list(map(int, input().split()))
x = li.index(max(li))
if li[:x] == sorted(li[:x]) and li[x:] == sorted(li[x:])[::-1]:
    print(""YES"")
else:
    print(""NO"")",1197_B,CODEFORCES,3021,Pillars,"There are $$$n$$$ pillars aligned in a row and numbered from $$$1$$$ to $$$n$$$.
Initially each pillar contains exactly one disk. The $$$i$$$-th pillar contains a disk having radius $$$a_i$$$.
You can move these disks from one pillar to another. You can take a disk from pillar $$$i$$$ and place it on top of pillar $$$j$$$ if all these conditions are met:
When you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.
You may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all $$$n$$$ disks on the same pillar simultaneously?
The first line contains one integer $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — the number of pillars.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_i$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the radius of the disk initially placed on the $$$i$$$-th pillar. All numbers $$$a_i$$$ are distinct.
","input
Print YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).
output
In the first case it is possible to place all disks on pillar $$$3$$$ using the following sequence of actions:
","greedy, implementation",4
"l,r=map(int,input().split())
z=l^r
c=0
if(z==0):
    print(0)
    exit()
while(z):
	c+=1;
	z>>=1;
x='1'*c
print(int(x,2))
	   	  	   		 	 		  	 	  		  		",0276_D,CODEFORCES,870,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"x, k = map(int, input().split())
mo = 1000000007
if (not x):
    print(0)
elif (not k):
    print((x * 2) % mo)
else:
    ans = x * pow(2, k + 1, mo) + 1 - pow(2, k, mo)
    ans %= mo
    ans += mo
    ans %= mo
    print(ans)",0992_C,CODEFORCES,1056,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"# import sys
# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            if i<n[0] and j<n[1]:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + u[0][i]*u[1][j])
            if j<n[1] and k<n[2]:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + u[1][j]*u[2][k])
            if i<n[0] and k<n[2]:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + u[0][i]*u[2][k])
res = max(x for u1 in dp for u2 in u1 for x in u2)
print(res)",1398_D,CODEFORCES,3898,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"n = int(input())
ans = []
mult = 1
while n > 3:
    ans += [mult]*(n-n//2)
    n //= 2
    mult *= 2
if n == 3:
    ans += [mult, mult, mult*3]
elif n == 2:
    ans += [mult, mult*2]
else:
    ans += [mult]
print(*ans)",1059_C,CODEFORCES,1159,Sequence Transformation,"Let's call the following process a transformation of a sequence of length $$$n$$$.
If the sequence is empty, the process ends. Otherwise, append the greatest common divisor (GCD) of all the elements of the sequence to the result and remove one arbitrary element from the sequence. Thus, when the process ends, we have a sequence of $$$n$$$ integers: the greatest common divisors of all the elements in the sequence before each deletion.
You are given an integer sequence $$$1, 2, \dots, n$$$. Find the lexicographically maximum result of its transformation.
A sequence $$$a_1, a_2, \ldots, a_n$$$ is lexicographically larger than a sequence $$$b_1, b_2, \ldots, b_n$$$, if there is an index $$$i$$$ such that $$$a_j = b_j$$$ for all $$$j < i$$$, and $$$a_i > b_i$$$.
The first and only line of input contains one integer $$$n$$$ ($$$1\le n\le 10^6$$$).
Output $$$n$$$ integers  — the lexicographically maximum result of the transformation.
","input
In the first sample the answer may be achieved this way:
output
We get the sequence $$$[1, 1, 3]$$$ as the result.
","constructivealgorithms, math",2
"S = input()

ans = 0
met = set()

for i in range(len(S)):
    for j in range(i, -1, -1):
        if S[j:i+1] in met:
            ans = max(ans, i - j + 1)
        else:
            met.add(S[j:i+1])
            
print(ans)",0023_A,CODEFORCES,3720,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"n=int(input())
l=[int(x) for x in input().split()]
ans=0;
while len(l)>0:
	a=l[0]
	l=l[1:]
	ans+=l.index(a)
	l.remove(a)
print(ans)",0995_B,CODEFORCES,3324,Suit and Tie,"Allen is hosting a formal dinner party. $$$2n$$$ people come to the event in $$$n$$$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $$$2n$$$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.
Help Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 100$$$), the number of pairs of people.
The second line contains $$$2n$$$ integers $$$a_1, a_2, \dots, a_{2n}$$$. For each $$$i$$$ with $$$1 \le i \le n$$$, $$$i$$$ appears exactly twice. If $$$a_j = a_k = i$$$, that means that the $$$j$$$-th and $$$k$$$-th people in the line form a couple.
Output a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.
","input
In the first sample case, we can transform $$$1 1 2 3 3 2 4 4 \rightarrow 1 1 2 3 2 3 4 4 \rightarrow 1 1 2 2 3 3 4 4$$$ in two steps. Note that the sequence $$$1 1 2 3 3 2 4 4 \rightarrow 1 1 3 2 3 2 4 4 \rightarrow 1 1 3 3 2 2 4 4$$$ also works in the same number of steps.
output
The second sample case already satisfies the constraints; therefore we need $$$0$$$ swaps.
","greedy, implementation, math",5
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))
A.sort()

from collections import Counter
C=Counter(A)
dou=0

for c in C:
    dou+=C[c]-1

    if C[c]>=2 and C[c-1]!=0:
        print(""cslnb"")
        sys.exit()
        
if dou>=2:
    print(""cslnb"")
    sys.exit()

ANS=0
for i in range(n):
    if A[i]<i:
        print(""cslnb"")
        sys.exit()
    ANS+=(A[i]-i)%2

if ANS%2==0:
    print(""cslnb"")
    sys.exit()
else:
    print(""sjfnb"")
    sys.exit()
    
    
",1190_B,CODEFORCES,2946,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
",games,4
"l,r = map(int,input().split())
ans = l ^ r
x = bin(ans)[1:]
if ans == 0:
    print(0)
else:
    ptr = -1
    po = 0
    while True:
        if( x[ptr] == '0') :
            ans += 2**po
        po += 1
        ptr-=1
        if( ptr == -len(x)-1 ):
            break

    print(ans)
",0276_D,CODEFORCES,811,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"games,bills = map(int,input().split())
g = list(map(int,input().split()))
b=list(map(int,input().split()))
total = 0
i=0
j=0

while(i < games and j < bills):
    if g[i] <= b[j]:
        total+=1
        i+=1
        j+=1
    elif g[i] > b[j]:
        i+=1
print(total)",1009_A,CODEFORCES,1780,Game Shopping,"Maxim wants to buy some games at the local game shop. There are $$$n$$$ games in the shop, the $$$i$$$-th game costs $$$c_i$$$.
Maxim has a wallet which can be represented as an array of integers. His wallet contains $$$m$$$ bills, the $$$j$$$-th bill has value $$$a_j$$$.
Games in the shop are ordered from left to right, Maxim tries to buy every game in that order.
When Maxim stands at the position $$$i$$$ in the shop, he takes the first bill from his wallet (if his wallet is empty then he proceeds to the next position immediately) and tries to buy the $$$i$$$-th game using this bill. After Maxim tried to buy the $$$n$$$-th game, he leaves the shop.
Maxim buys the $$$i$$$-th game if and only if the value of the first bill (which he takes) from his wallet is greater or equal to the cost of the $$$i$$$-th game. If he successfully buys the $$$i$$$-th game, the first bill from his wallet disappears and the next bill becomes first. Otherwise Maxim leaves the first bill in his wallet (this bill still remains the first one) and proceeds to the next game.
For example, for array $$$c = [2, 4, 5, 2, 4]$$$ and array $$$a = [5, 3, 4, 6]$$$ the following process takes place: Maxim buys the first game using the first bill (its value is $$$5$$$), the bill disappears, after that the second bill (with value $$$3$$$) becomes the first one in Maxim's wallet, then Maxim doesn't buy the second game because $$$c_2 > a_2$$$, the same with the third game, then he buys the fourth game using the bill of value $$$a_2$$$ (the third bill becomes the first one in Maxim's wallet) and buys the fifth game using the bill of value $$$a_3$$$.
Your task is to get the number of games Maxim will buy.
The first line of the input contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the number of games and the number of bills in Maxim's wallet.
The second line of the input contains $$$n$$$ integers $$$c_1, c_2, \dots, c_n$$$ ($$$1 \le c_i \le 1000$$$), where $$$c_i$$$ is the cost of the $$$i$$$-th game.
The third line of the input contains $$$m$$$ integers $$$a_1, a_2, \dots, a_m$$$ ($$$1 \le a_j \le 1000$$$), where $$$a_j$$$ is the value of the $$$j$$$-th bill from the Maxim's wallet.
Print a single integer — the number of games Maxim will buy.
The first example is described in the problem statement.
","input
In the second example Maxim cannot buy any game because the value of the first bill in his wallet is smaller than the cost of any game in the shop.
output
In the third example the values of the bills in Maxim's wallet are large enough to buy any game he encounter until he runs out of bills in his wallet.
",implementation,3
"n,k=map(int,input().split())
 
if k==(n*(n+1))//2:
    print(0)
else:
    left=0
    right=n
    while left<right:
        mid=(left+right)//2
        candies=(mid*(mid+1))//2
        if candies + mid < k + n:
            left=mid+1
        else:
            right=mid
    print(n-left)
            
            ",1195_B,CODEFORCES,1402,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import sys, os
from collections import defaultdict

if os.environ['USERNAME']=='kissz':
    inp=open('in.txt','r').readline
    def debug(*args):
        print(*args,file=sys.stderr)
else:
    inp=input
    def debug(*args):
        pass

# SCRIPT STARTS HERE
def get_hash(s):
    r=0
    for c in s:
        r*=30
        if c!='_':
            r+=ord(c)-96
    return r

def matches(s):
    R=[]
    for i in range(2**k):
        r=0
        for j in range(k):
            if i&(1<<j):
                r+=(ord(s[j])-96)*(30**(k-j-1))
        if pattern_pos[r]>=0:
            #R.append(r)
            R.append(pattern_pos[r])
    return R

n,m,k=map(int,inp().split())
    
pattern_pos=[-1]*(30**k)
#patterns=[0]*(n+1)
for i in range(n):
    p=get_hash(inp().strip())
    pattern_pos[p]=i+1
    #patterns[i+1]=p

parents=[0]*(n+1)    
edges=defaultdict(list)
failed=False
for i in range(m):
    s,l=inp().split()
    l=int(l)
    M=matches(s)
    if l in M:
        for m in M:
            if l==m: continue
            edges[l].append(m)
            parents[m]+=1
    else:
        failed=True
        break

    
if failed:
    print('NO')
else:
    Q=[]
    for i in range(1,n+1):
        if parents[i]==0:
            Q.append(i)
    
    ans=[]
    while Q:
        i=Q.pop()
        ans.append(i)
        for child in edges[i]:
            parents[child]-=1
            if parents[child]==0:
                Q.append(child)
    if len(ans)==n:
        print('YES')
        print(*ans)
    else:
        print('NO')
    ",1476_E,CODEFORCES,4750,Pattern Matching,"You are given $$$n$$$ patterns $$$p_1, p_2, \dots, p_n$$$ and $$$m$$$ strings $$$s_1, s_2, \dots, s_m$$$. Each pattern $$$p_i$$$ consists of $$$k$$$ characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string $$$s_j$$$ consists of $$$k$$$ lowercase Latin letters.
A string $$$a$$$ matches a pattern $$$b$$$ if for each $$$i$$$ from $$$1$$$ to $$$k$$$ either $$$b_i$$$ is a wildcard character or $$$b_i=a_i$$$.
You are asked to rearrange the patterns in such a way that the first pattern the $$$j$$$-th string matches is $$$p[mt_j]$$$. You are allowed to leave the order of the patterns unchanged.
Can you perform such a rearrangement? If you can, then print any valid order.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \le n, m \le 10^5$$$, $$$1 \le k \le 4$$$) — the number of patterns, the number of strings and the length of each pattern and string.
Each of the next $$$n$$$ lines contains a pattern — $$$k$$$ characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct.
Each of the next $$$m$$$ lines contains a string — $$$k$$$ lowercase Latin letters, and an integer $$$mt$$$ ($$$1 \le mt \le n$$$) — the index of the first pattern the corresponding string should match.
Print ""NO"" if there is no way to rearrange the patterns in such a way that the first pattern that the $$$j$$$-th string matches is $$$p[mt_j]$$$.
Otherwise, print ""YES"" in the first line. The second line should contain $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ — the order of the patterns. If there are multiple answers, print any of them.
The order of patterns after the rearrangement in the first example is the following: 
Thus, the first string matches patterns ab__, _bcd, _b_d in that order, the first of them is ab__, that is indeed $$$p[4]$$$. The second string matches __b_ and ab__, the first of them is __b_, that is $$$p[2]$$$. The last string matches _bcd and _b_d, the first of them is _bcd, that is $$$p[5]$$$.
The answer to that test is not unique, other valid orders also exist.
","input
In the second example cba doesn't match __c, thus, no valid order exists.
output
In the third example the order (a_, _b) makes both strings match pattern $$$1$$$ first and the order (_b, a_) makes both strings match pattern $$$2$$$ first. Thus, there is no order that produces the result $$$1$$$ and $$$2$$$.
","bitmasks, datastructures, dfsandsimilar, graphs, hashing, sortings, strings",7
"n,U=list(map(int, input().split(' ')))
a=list(map(int, input().split(' ')))

import bisect
def max_eligible(a,x):
    ind=bisect.bisect_right(a,x)
    if ind <= len(a):
        return a[ind-1]
    else:
        return -1

max_val=-1
for i in range(n-2):
    x = a[i]+U
    val1 = max_eligible(a,x)

    if val1!=-1 and val1!=a[i+1] and val1!=a[i]:
        # print('hi')
        val = (val1-a[i+1]) / (val1-a[i])
        # print(val)
        max_val=max(max_val,val)
    # print(a[i],a[i+1],val1,max_val)
print(max_val)
",0957_C,CODEFORCES,2468,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers",4
"# -*- coding: utf-8 -*-
""""""
Created on Mon Sep  7 22:59:16 2020

@author: Dark Soul
""""""
import math
[l,r]=list(map(int,input().split()))
l=l^r
if l:
    l=int(math.log(l,2))
    l=(1<<(l+1))-1
    print(l)
else:
    print(0)",0276_D,CODEFORCES,879,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import math
send=input()
rcv=input()
d={}
d['+']=0
d['-']=0
for i in range(len(send)):
	d[send[i]]=d[send[i]]+1

flag=1
c=0
for i in range(len(rcv)):
	if rcv[i] in d:
		if d[rcv[i]]==0:
			flag=0
		else:
			d[rcv[i]]=d[rcv[i]]-1
tot=d['+']+d['-']
totComb=2**tot
n=tot
r=d['+']
npr=math.factorial(n)/math.factorial(n-r)
reqComb=npr/math.factorial(r)
#print(totComb)
#print(reqComb)
if flag==0:
	print('0.00000000')
else:
	print(float(reqComb)/totComb)",0476_B,CODEFORCES,4374,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"n,m=map(int,input().split())
arr=[]
for i in range(m):
    arr.append(list(map(int,input().split())))
count=0
for i in range(m):
    count +=arr[i][0] *(n)
    if n %2==1 and arr[i][1] <0:
        count +=(n//2)*(n//2 +1)*arr[i][1]
    if n %2==1 and arr[i][1] >0:
        count +=(n) *(n-1) *arr[i][1]//2
    if n %2==0 and arr[i][1] <0:
        count +=(n//2)*(n//2 -1)*arr[i][1]
        count +=(n//2) *arr[i][1]
    if n %2==0 and arr[i][1] >0:
        count +=(n) *(n-1) *arr[i][1] //2
print(count /n)",1009_C,CODEFORCES,1797,Annoying Present,"Alice got an array of length $$$n$$$ as a birthday present once again! This is the third year in a row! 
And what is more disappointing, it is overwhelmengly boring, filled entirely with zeros. Bob decided to apply some changes to the array to cheer up Alice.
Bob has chosen $$$m$$$ changes of the following form. For some integer numbers $$$x$$$ and $$$d$$$, he chooses an arbitrary position $$$i$$$ ($$$1 \le i \le n$$$) and for every $$$j \in [1, n]$$$ adds $$$x + d \cdot dist(i, j)$$$ to the value of the $$$j$$$-th cell. $$$dist(i, j)$$$ is the distance between positions $$$i$$$ and $$$j$$$ (i.e. $$$dist(i, j) = |i - j|$$$, where $$$|x|$$$ is an absolute value of $$$x$$$).
For example, if Alice currently has an array $$$[2, 1, 2, 2]$$$ and Bob chooses position $$$3$$$ for $$$x = -1$$$ and $$$d = 2$$$ then the array will become $$$[2 - 1 + 2 \cdot 2,~1 - 1 + 2 \cdot 1,~2 - 1 + 2 \cdot 0,~2 - 1 + 2 \cdot 1]$$$ = $$$[5, 2, 1, 3]$$$. Note that Bob can't choose position $$$i$$$ outside of the array (that is, smaller than $$$1$$$ or greater than $$$n$$$).
Alice will be the happiest when the elements of the array are as big as possible. Bob claimed that the arithmetic mean value of the elements will work fine as a metric.
What is the maximum arithmetic mean value Bob can achieve?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 10^5$$$) — the number of elements of the array and the number of changes.
Each of the next $$$m$$$ lines contains two integers $$$x_i$$$ and $$$d_i$$$ ($$$-10^3 \le x_i, d_i \le 10^3$$$) — the parameters for the $$$i$$$-th change.
","input
Print the maximal average arithmetic mean of the elements Bob can achieve.
output
Your answer is considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$.
","greedy, math",3
"s, ans, = input(), 0
sLen = len(s)

for i in range(sLen):
    for till1 in range(i + 1, sLen + 1):
        till2 = till1 + 1
        for j in range(i + 1, sLen + 1):
            if till2 > sLen:
                break
            sub1 = s[i:till1]
            sub2 = s[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)
",0023_A,CODEFORCES,3739,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"from collections import deque

def removeUsed(adj, used):
    to_remove = []
    for s in adj:
        if used[s]: to_remove.append(s)
    for s in to_remove:
        adj.remove(s)

def solve(a, s): # a - adjacenct list [[],[]...], seq
    if s[0] != 0: return False
    q = deque()
    q.append(0)
    i, n, cur = 1, len(a), -1
    used = [False]*n
    used[0] = True
    while i < n:
        if cur == -1:
            cur = q.popleft()
            removeUsed(a[cur], used)
        if not a[cur]:
            cur = -1
            continue
        cur_s = s[i]
        i += 1
        if cur_s not in a[cur]:
            return False # not connected
        a[cur].remove(cur_s)
        q.append(cur_s)
        used[cur_s] = True
    return True

n = int(input())
a = [set() for i in range(n)]
for i in range(n-1):
    u, v = map(int, input().split())
    a[u-1].add(v-1)
    a[v-1].add(u-1)
s = [(x-1) for x in map(int, input().split())]
print(""Yes"" if solve(a, s) else ""No"")
",1037_D,CODEFORCES,1927,Valid BFS?,"The BFS algorithm is defined as follows.
Since the order of choosing neighbors of each vertex can vary, it turns out that there may be multiple sequences which BFS can print.
In this problem you need to check whether a given sequence corresponds to some valid BFS traversal of the given tree starting from vertex $$$1$$$. The tree is an undirected graph, such that there is exactly one simple path between any two vertices.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) which denotes the number of nodes in the tree. 
The following $$$n - 1$$$ lines describe the edges of the tree. Each of them contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x, y \le n$$$) — the endpoints of the corresponding edge of the tree. It is guaranteed that the given graph is a tree.
The last line contains $$$n$$$ distinct integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$) — the sequence to check.
Print ""Yes"" (quotes for clarity) if the sequence corresponds to some valid BFS traversal of the given tree and ""No"" (quotes for clarity) otherwise.
You can print each letter in any case (upper or lower).
Both sample tests have the same tree in them.
","input
In this tree, there are two valid BFS orderings: 
output
The ordering $$$1, 2, 4, 3$$$ doesn't correspond to any valid BFS order.
","dfsandsimilar, graphs, shortestpaths, trees",3
"# cook your dish here
def power(x, y, p) : 
    res = 1     # Initialize result 
  
    # Update x if it is more 
    # than or equal to p 
    x = x % p  
  
    while (y > 0) : 
          
        # If y is odd, multiply 
        # x with result 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
  
        # y must be even now 
        y = y >> 1      # y = y/2 
        x = (x * x) % p 
          
    return res 
    
d,n=map(int,input().split())
ans =power(2,n+1,1000000007);
ans1=power(2,n,1000000007);
if(d==0):
    print(0)
else:
    print(((ans*(d%1000000007))%1000000007 - ans1 +1)%1000000007)",0992_C,CODEFORCES,1123,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"n, m, k = map(int, input().split())
a = list(map(int, input().split()))
sa = [0]*n

ans = 0

for i in range(n):
    sa[i] = a[i] - k
    s = a[i]
    for j in range(i-1, max(-1, i-m-1), -1):
        sa[i] = max(sa[i], sa[j] + s - k)
        s += a[j]
    if i < m:
        sa[i] = max(sa[i], s - k)
    sa[i] = max(sa[i], 0)
    ans = max(ans, sa[i])

print(ans)
",1197_D,CODEFORCES,3642,Yet Another Subarray Problem,"You are given an array $$$a_1, a_2, \dots , a_n$$$ and two integers $$$m$$$ and $$$k$$$.
You can choose some subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$. 
The cost of subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$ is equal to $$$\sum\limits_{i=l}^{r} a_i - k \lceil \frac{r - l + 1}{m} \rceil$$$, where $$$\lceil x \rceil$$$ is the least integer greater than or equal to $$$x$$$. 
The cost of empty subarray is equal to zero.
For example, if $$$m = 3$$$, $$$k = 10$$$ and $$$a = [2, -4, 15, -3, 4, 8, 3]$$$, then the cost of some subarrays are:
Your task is to find the maximum cost of some subarray (possibly empty) of array $$$a$$$.
The first line contains three integers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \le n \le 3 \cdot 10^5, 1 \le m \le 10, 1 \le k \le 10^9$$$).
","input
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$).
output
Print the maximum cost of some subarray of array $$$a$$$.
","dp, greedy, math",5
"inf=10**9

n=int(input())
t=[0]*n
m={}
for j in range(n):


    s=input()


    bal=0
    req=0

    for i in s:
        if i=="")"":
            bal-=1
        else:
            if bal<0:
                req+=bal
                bal=1
            else:
                bal+=1

    if req<0:
        if bal>0:
            req=inf
        else:
            req+=bal
    else:
        req=bal

    t[j]=req

    if req not in m:
        m[req]=1
    else:
        m[req]+=1

res=0

for i in t:
    if i>=0:
        if -i in m:
            res+=m[-i]

print(res)
",0990_C,CODEFORCES,1696,Bracket Sequences Concatenation Problem,"A bracket sequence is a string containing only characters ""("" and "")"".
A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()()"", ""(())"" are regular (the resulting expressions are: ""(1)+(1)"", ""((1+1)+1)""), and "")("" and ""("" are not.
You are given $$$n$$$ bracket sequences $$$s_1, s_2, \dots , s_n$$$. Calculate the number of pairs $$$i, j \, (1 \le i, j \le n)$$$ such that the bracket sequence $$$s_i + s_j$$$ is a regular bracket sequence. Operation $$$+$$$ means concatenation i.e. ""()("" + "")()"" = ""()()()"".
If $$$s_i + s_j$$$ and $$$s_j + s_i$$$ are regular bracket sequences and $$$i \ne j$$$, then both pairs $$$(i, j)$$$ and $$$(j, i)$$$ must be counted in the answer. Also, if $$$s_i + s_i$$$ is a regular bracket sequence, the pair $$$(i, i)$$$ must be counted in the answer.
The first line contains one integer $$$n \, (1 \le n \le 3 \cdot 10^5)$$$ — the number of bracket sequences. The following $$$n$$$ lines contain bracket sequences — non-empty strings consisting only of characters ""("" and "")"". The sum of lengths of all bracket sequences does not exceed $$$3 \cdot 10^5$$$.
In the single line print a single integer — the number of pairs $$$i, j \, (1 \le i, j \le n)$$$ such that the bracket sequence $$$s_i + s_j$$$ is a regular bracket sequence.
","input
In the first example, suitable pairs are $$$(3, 1)$$$ and $$$(2, 2)$$$.
output
In the second example, any pair is suitable, namely $$$(1, 1), (1, 2), (2, 1), (2, 2)$$$.
",implementation,3
"n=int(input())
a=[*map(int,input().split())]
b=[0]*n
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",1033_C,CODEFORCES,3493,Permutation Game,"After a long day, Alice and Bob decided to play a little game. The game board consists of $$$n$$$ cells in a straight line, numbered from $$$1$$$ to $$$n$$$, where each cell contains a number $$$a_i$$$ between $$$1$$$ and $$$n$$$. Furthermore, no two cells contain the same number. 
A token is placed in one of the cells. They take alternating turns of moving the token around the board, with Alice moving first. The current player can move from cell $$$i$$$ to cell $$$j$$$ only if the following two conditions are satisfied: 
Whoever is unable to make a move, loses. For each possible starting position, determine who wins if they both play optimally. It can be shown that the game is always finite, i.e. there always is a winning strategy for one of the players.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of numbers.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$). Furthermore, there are no pair of indices $$$i \neq j$$$ such that $$$a_i = a_j$$$.
","input
Print $$$s$$$ — a string of $$$n$$$ characters, where the $$$i$$$-th character represents the outcome of the game if the token is initially placed in the cell $$$i$$$. If Alice wins, then $$$s_i$$$ has to be equal to ""A""; otherwise, $$$s_i$$$ has to be equal to ""B"". 
output
In the first sample, if Bob puts the token on the number (not position): 
","bruteforce, dp, games",5
"from collections import Counter


if __name__ == ""__main__"":
    n, k = map(int, input().split())
    s = input()
    c = Counter(s)
    min_symbols = min(c[chr(ord(""A"") + i)] for i in range(k))
    print(min_symbols * k)
",1038_A,CODEFORCES,1940,Equality,"You are given a string $$$s$$$ of length $$$n$$$, which consists only of the first $$$k$$$ letters of the Latin alphabet. All letters in string $$$s$$$ are uppercase.
A subsequence of string $$$s$$$ is a string that can be derived from $$$s$$$ by deleting some of its symbols without changing the order of the remaining symbols. For example, ""ADE"" and ""BD"" are subsequences of ""ABCDE"", but ""DEA"" is not.
A subsequence of $$$s$$$ called good if the number of occurences of each of the first $$$k$$$ letters of the alphabet is the same.
Find the length of the longest good subsequence of $$$s$$$. 
The first line of the input contains integers $$$n$$$ ($$$1\le n \le 10^5$$$) and $$$k$$$ ($$$1 \le k \le 26$$$).
The second line of the input contains the string $$$s$$$ of length $$$n$$$. String $$$s$$$ only contains uppercase letters from 'A' to the $$$k$$$-th letter of Latin alphabet.
Print the only integer — the length of the longest good subsequence of string $$$s$$$.
","input
In the first example, ""ACBCAB"" (""ACAABCCAB"") is one of the subsequences that has the same frequency of 'A', 'B' and 'C'. Subsequence ""CAB"" also has the same frequency of these letters, but doesn't have the maximum possible length.
output
In the second example, none of the subsequences can have 'D', hence the answer is $$$0$$$.
","implementation, strings",3
"def solve():
    l, r = map(int, input().split())
    
    ans = l^r
    j = 0
    while 1<<j <= ans:
        ans |= 1<<j
        j += 1

    print(ans)

solve()

",0276_D,CODEFORCES,794,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    

import random
import time
random.seed( int(time.time()) )

bb = random.randint(0, 2**30-1)

hat1 = 0
hat2 = 0
lastresult = None
for i in range(29, -1, -1):
    g1 = hat1 + (1<<i)
    g2 = hat2 + (1<<i)
    
    if lastresult is None:
        print('?',hat1^ bb,hat2)
        t1 = int(input())
    else:
        t1 = lastresult
    if t1!=0:
        print('?',g1^ bb,g2)
        t2 = int(input())
        if t1!=t2:
            if t1==1:
                hat1+= (1<<i)
            else:
                hat2+= (1<<i)
            lastresult = None
            continue
    lastresult = t1
    print('?',g1^ bb,hat2)
    t3 = int(input())
    if t3==1:
        pass
    else:
        hat1+= (1<<i)
        hat2+= (1<<i)
    
print('!', hat1^bb% (2**30), hat2)



",1088_D,CODEFORCES,647,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",1
"import sys, math

def mp():
    return list(map(int, input().split()))

def quer(x1, y1, x2, y2):
    if x1 > x2 or y1 > y2:
        return [0, 0]
    s = (x2 - (x1 - 1)) * (y2 - (y1 - 1))
    if s % 2 == 0:
        return [s // 2, s // 2]
    if (x1 + y1) & 1:
        return [s // 2 + 1, s // 2]
    return [s // 2, s // 2 + 1]
        

def main():
    q = int(input())
    for i in range(q):
        n, m = mp()
        x1, y1, x2, y2 = mp()
        s = quer(1, 1, n, m)
        s1 = quer(x1, y1, x2, y2)
        s[0] -= s1[0]
        s[1] += s1[0]
        
        # print(s[::-1])
        x3, y3, x4, y4 = mp()
        xmn = max(x1, x3)
        xmx = min(x2, x4)
        ymn = max(y1, y3)
        ymx = min(y2, y4)
        s1 = quer(x3, y3, x4, y4)
        s[0] += s1[1]
        s[1] -= s1[1]
        s1 = quer(xmn, ymn, xmx, ymx)
        s[0] += s1[0]
        s[1] -= s1[0]
        print(*s[::-1])
        
debug = 0
if debug:
    file = open(""input.txt"", ""r"")
    input = file.readline
main()
if debug:
    file.close()",1080_C,CODEFORCES,614,Masha and two friends,"Recently, Masha was presented with a chessboard with a height of $$$n$$$ and a width of $$$m$$$.
The rows on the chessboard are numbered from $$$1$$$ to $$$n$$$ from bottom to top. The columns are numbered from $$$1$$$ to $$$m$$$ from left to right. Therefore, each cell can be specified with the coordinates $$$(x,y)$$$, where $$$x$$$ is the column number, and $$$y$$$ is the row number (do not mix up).
Let us call a rectangle with coordinates $$$(a,b,c,d)$$$ a rectangle lower left point of which has coordinates $$$(a,b)$$$, and the upper right one — $$$(c,d)$$$.
The chessboard is painted black and white as follows:
Masha was very happy with the gift and, therefore, invited her friends Maxim and Denis to show off. The guys decided to make her a treat — they bought her a can of white and a can of black paint, so that if the old board deteriorates, it can be repainted. When they came to Masha, something unpleasant happened: first, Maxim went over the threshold and spilled white paint on the rectangle $$$(x_1,y_1,x_2,y_2)$$$. Then after him Denis spilled black paint on the rectangle $$$(x_3,y_3,x_4,y_4)$$$.
To spill paint of color $$$color$$$ onto a certain rectangle means that all the cells that belong to the given rectangle become $$$color$$$. The cell dyeing is superimposed on each other (if at first some cell is spilled with white paint and then with black one, then its color will be black).
Masha was shocked! She drove away from the guests and decided to find out how spoiled the gift was. For this, she needs to know the number of cells of white and black color. Help her find these numbers!
The first line contains a single integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of test cases.
Each of them is described in the following format:
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n,m \le 10^9$$$) — the size of the board.
The second line contains four integers $$$x_1$$$, $$$y_1$$$, $$$x_2$$$, $$$y_2$$$ ($$$1 \le x_1 \le x_2 \le m, 1 \le y_1 \le y_2 \le n$$$) — the coordinates of the rectangle, the white paint was spilled on.
The third line contains four integers $$$x_3$$$, $$$y_3$$$, $$$x_4$$$, $$$y_4$$$ ($$$1 \le x_3 \le x_4 \le m, 1 \le y_3 \le y_4 \le n$$$) — the coordinates of the rectangle, the black paint was spilled on.
Output $$$t$$$ lines, each of which contains two numbers — the number of white and black cells after spilling paint, respectively.
Explanation for examples:
The first picture of each illustration shows how the field looked before the dyes were spilled. The second picture of each illustration shows how the field looked after Maxim spoiled white dye (the rectangle on which the dye was spilled is highlighted with red). The third picture in each illustration shows how the field looked after Denis spoiled black dye (the rectangle on which the dye was spilled is highlighted with red).
In the first test, the paint on the field changed as follows:
In the second test, the paint on the field changed as follows:
In the third test, the paint on the field changed as follows:
","input
In the fourth test, the paint on the field changed as follows:
output
In the fifth test, the paint on the field changed as follows:
",implementation,1
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans)",1398_D,CODEFORCES,3900,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"n, k = map(int, input().split())

def prod(n):
	if n%2:
		return n*((n+1)//2)
	else:
		return (n//2)*(n+1)

def total_count(n, k):
	if k >= n:
		return (0, 0, 1)
	else:
		count = 0
		l = 1; r = k
		s = prod(k)
		while l <= r:
			mid = (l+r)//2
			if n > s - prod(mid) + mid:
				r = mid-1
			else:
				l = mid+1

		n = n - (s - prod(l) + l)
		count += (k-l+1)
		k = l-1
		return (n, k, count)		

if prod(k) - (k-1) < n:
	print(-1)
elif n == 1:
	print(0)
elif k >= n:
	print(1)
else:
	n = n-k
	k = k-2
	count = 1
	while n > 0:
		(n, k, temp) = total_count(n, k)
		count += temp
	print(count)",0287_B,CODEFORCES,933,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"t = int(input())

def sol(n, k):
    p = 1
    q = 1
    acc = 0
    while n > 0 and k >= p:
        k -= p
        n -= 1
        if n >= 40:
            return n
        acc += q*(4**n-1)//3
        if k <= acc:
            return n
        p = 2*p+1
        q = 2*q+3
    return -1

for _ in range(t):
    n, k = (int(v) for v in input().split())
    ans = sol(n, k)
    if ans == -1:
        print(""NO"")
    else:
        print(""YES"", ans)",1080_D,CODEFORCES,1205,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"import math

def find_nCr(n, r):
	return (math.factorial(n) / (math.factorial(r)*math.factorial(n-r)) )

sent = input()
received = input()

final_pos = 0
current_pos = 0
uncertain = 0

for s in sent:
	if s == ""+"":
		final_pos += 1
	else:
		final_pos -= 1

for s in received:
	if s == ""+"":
		current_pos += 1
	elif s == ""-"":
		current_pos -= 1
	else:
		uncertain += 1

if uncertain == 0:
	if final_pos == current_pos:
		print(1)
	else:
		print(0)
else:
	# the uncertain ones can be all plus or all minus or mixture of plus/minus
	# for all plus we go current_pos+uncertain
	# then for each minus (current_pos+uncertain) decreases by 2
	# so positions is a list of all the posible positions we can go
	positions = list(range(current_pos-uncertain, current_pos+uncertain+2, 2))
	
	# print(positions)

	try:
		pos_index = positions.index(final_pos)
		a = find_nCr(uncertain, pos_index)
		b = math.pow(2, uncertain)
		print(a/b)
	except:
		pos_index = -1
		print(0)
",0476_B,CODEFORCES,4369,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"import sys
input = sys.stdin.readline

n, q = map(int, input().split())
for _ in range(q):
    u = int(input())
    s = input()
    for comm in s:
        k = 1
        while True:
            if k & u:
                break
            k <<= 1
        if comm == 'L':
            if k != 1:
                u -= k
                u += (k>>1)
        elif comm == 'R':
            if k != 1:
                u += (k>>1)
        elif comm == 'U':
            nu = u - k
            nu |= (k<<1)
            if nu <= n:
                u = nu
    print(u)",0792_D,CODEFORCES,4539,Paths in a Complete Binary Tree,"T is a complete binary tree consisting of n vertices. It means that exactly one vertex is a root, and each vertex is either a leaf (and doesn't have children) or an inner node (and has exactly two children). All leaves of a complete binary tree have the same depth (distance from the root). So n is a number such that n + 1 is a power of 2.
In the picture you can see a complete binary tree with n = 15.
Vertices are numbered from 1 to n in a special recursive way: we recursively assign numbers to all vertices from the left subtree (if current vertex is not a leaf), then assign a number to the current vertex, and then recursively assign numbers to all vertices from the right subtree (if it exists). In the picture vertices are numbered exactly using this algorithm. It is clear that for each size of a complete binary tree exists exactly one way to give numbers to all vertices. This way of numbering is called symmetric.
You have to write a program that for given n answers q queries to the tree.
Each query consists of an integer number ui (1 ≤ ui ≤ n) and a string si, where ui is the number of vertex, and si represents the path starting from this vertex. String si doesn't contain any characters other than 'L', 'R' and 'U', which mean traverse to the left child, to the right child and to the parent, respectively. Characters from si have to be processed from left to right, considering that ui is the vertex where the path starts. If it's impossible to process a character (for example, to go to the left child of a leaf), then you have to skip it. The answer is the number of vertex where the path represented by si ends.
For example, if ui = 4 and si = «UURL», then the answer is 10.
The first line contains two integer numbers n and q (1 ≤ n ≤ 1018, q ≥ 1). n is such that n + 1 is a power of 2.
The next 2q lines represent queries; each query consists of two consecutive lines. The first of these two lines contains ui (1 ≤ ui ≤ n), the second contains non-empty string si. si doesn't contain any characters other than 'L', 'R' and 'U'.
","input
It is guaranteed that the sum of lengths of si (for each i such that 1 ≤ i ≤ q) doesn't exceed 105.
output
Print q numbers, i-th number must be the answer to the i-th query.
","bitmasks, trees",7
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):#nmbr()):
    r, c=lst()
    a=[input() for i in range(r)]
    pre=[[0 for i in range(c)] for i in range(r)]
    suf=[[0 for i in range(c)] for i in range(r)]
    for i in range(c):
        pre[0][i]=int(a[0][i])
        suf[r-1][i]=int(a[r-1][i])
    for i in range(1, r):
        for j in range(c):
            pre[i][j]=pre[i-1][j]+int(a[i][j])
    # print(*pre, sep='\n')
    for i in range(r-2, -1 ,-1):
        for j in range(c):
            suf[i][j]=suf[i+1][j]+int(a[i][j])
    ans='NO'
    for i in range(r):
        f=1
        for j in range(c):
            up=down=0
            if i-1>=0:up=pre[i-1][j]
            if i+1<r:down=suf[i+1][j]
            if up+down==0:
                f=0
                break
        if f:
            ans=""YES""
            break
    print(ans)
",0985_B,CODEFORCES,3251,Switches and Lamps,"You are given n switches and m lamps. The i-th switch turns on some subset of the lamps. This information is given as the matrix a consisting of n rows and m columns where ai, j = 1 if the i-th switch turns on the j-th lamp and ai, j = 0 if the i-th switch is not connected to the j-th lamp.
Initially all m lamps are turned off.
Switches change state only from ""off"" to ""on"". It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards.
It is guaranteed that if you push all n switches then all m lamps will be turned on.
Your think that you have too many switches and you would like to ignore one of them. 
Your task is to say if there exists such a switch that if you will ignore (not use) it but press all the other n - 1 switches then all the m lamps will be turned on.
The first line of the input contains two integers n and m (1 ≤ n, m ≤ 2000) — the number of the switches and the number of the lamps.
The following n lines contain m characters each. The character ai, j is equal to '1' if the i-th switch turns on the j-th lamp and '0' otherwise.
","input
It is guaranteed that if you press all n switches all m lamps will be turned on.
output
Print ""YES"" if there is a switch that if you will ignore it and press all the other n - 1 switches then all m lamps will be turned on. Print ""NO"" if there is no such switch.
",implementation,5
"from sys import stdin,stdout
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
def fn(p):
    turns=b[p]//14
    a=b.copy();sm=0
    a[p]=0
    for i in range(1,15):
        a[(p+i)%14]+=turns
    rem=b[p]%14
    for i in range(p+1,p+rem+1,1):
        a[(i%14)]+=1
    for i in range(14):
        if a[i]&1==0:
            sm+=a[i]
    # print(a)
    return sm
for _ in range(1):#nmbr()):
    b=lst()
    ans=0
    for i in range(14):
        if b[i]!=0:ans=max(ans,fn(i))
    print(ans)
",0975_B,CODEFORCES,295,Mancala,"Mancala is a game famous in the Middle East. It is played on a board that consists of 14 holes. 
Initially, each hole has $$$a_i$$$ stones. When a player makes a move, he chooses a hole which contains a positive number of stones. He takes all the stones inside it and then redistributes these stones one by one in the next holes in a counter-clockwise direction.
Note that the counter-clockwise order means if the player takes the stones from hole $$$i$$$, he will put one stone in the $$$(i+1)$$$-th hole, then in the $$$(i+2)$$$-th, etc. If he puts a stone in the $$$14$$$-th hole, the next one will be put in the first hole.
After the move, the player collects all the stones from holes that contain even number of stones. The number of stones collected by player is the score, according to Resli.
Resli is a famous Mancala player. He wants to know the maximum score he can obtain after one move.
The only line contains 14 integers $$$a_1, a_2, \ldots, a_{14}$$$ ($$$0 \leq a_i \leq 10^9$$$) — the number of stones in each hole.
It is guaranteed that for any $$$i$$$ ($$$1\leq i \leq 14$$$) $$$a_i$$$ is either zero or odd, and there is at least one stone in the board.
","input
Output one integer, the maximum possible score after one move.
output
In the first test case the board after the move from the hole with $$$7$$$ stones will look like 1 2 2 0 0 0 0 0 0 0 1 1 1 1. Then the player collects the even numbers and ends up with a score equal to $$$4$$$.
","bruteforce, implementation",1
"a, b= list(map(int, input().split()))
c = 1
result = a^b
while c <= result:
    c *= 2
c -= 1
 
print(c)
 		 	   				 		   		   	  	  	",0276_D,CODEFORCES,873,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"import math


n=int(input())

for _ in range(n):
    a,b=map(int,input().split())
    ans=0
    while a>0 and b>0:
        if a>=b:
            ans+=a//b
            a=a%b
        else:
            ans+=b//a
            b=b%a
    print(ans)
        ",0267_A,CODEFORCES,95,Subtractions,"You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).
You've got some number of pairs (ai, bi). How many operations will be performed for each of them?
","input
The first line contains the number of pairs n (1  ≤  n  ≤  1000). Then follow n lines, each line contains a pair of positive integers ai, bi (1  ≤  ai,  bi  ≤  109).
output
Print the sought number of operations for each pair on a single line.
","math, numbertheory",1
"
from sys import stdin
input = stdin.buffer.readline

n,k=map(int,input().split())
arr=[int(x) for x in input().split()]

l=[]
for i in range(n):
    l.append((arr[i],i))

l.sort(reverse=True)

dp=[]
x=0
for i in range(k):
    dp.append(l[i][1])
    x=x+l[i][0]

print(x)
dp.sort()
dp=[-1]+dp

l=len(dp)
for i in range(1,l-1):
    print(dp[i]-dp[i-1],end="" "")
print(n-1-dp[l-2])    ",1006_B,CODEFORCES,2715,Polycarp's Practice,"Polycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.
Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.
The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\max\limits_{l \le i \le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.
You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.
For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the number of problems and the number of days, respectively.
The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).
In the first line of the output print the maximum possible total profit.
In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \dots, t_k$$$ ($$$t_1 + t_2 + \dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.
If there are many possible answers, you may print any of them.
The first example is described in the problem statement.
","input
In the second example there is only one possible distribution.
output
In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.
","greedy, implementation, sortings",4
"import sys
input = sys.stdin.readline

Q=int(input())
LR=[list(map(int,input().split())) for i in range(Q)]

#正:N//2個の和
#負:(N+1)//2個の和

def SUM(i):
    plus=i//2
    minus=(i+1)//2

    P=(2+2*plus)*plus//2
    M=(1+2*minus-1)*minus//2
    return P-M

for l,r in LR:
    print(SUM(r)-SUM(l-1))
",1080_B,CODEFORCES,600,Margarite and the best present,"Little girl Margarita is a big fan of competitive programming. She especially loves problems about arrays and queries on them.
Recently, she was presented with an array $$$a$$$ of the size of $$$10^9$$$ elements that is filled as follows: 
That is, the value of the $$$i$$$-th element of the array $$$a$$$ is calculated using the formula $$$a_i = i \cdot (-1)^i$$$.
She immediately came up with $$$q$$$ queries on this array. Each query is described with two numbers: $$$l$$$ and $$$r$$$. The answer to a query is the sum of all the elements of the array at positions from $$$l$$$ to $$$r$$$ inclusive.
Margarita really wants to know the answer to each of the requests. She doesn't want to count all this manually, but unfortunately, she couldn't write the program that solves the problem either. She has turned to you — the best programmer.
Help her find the answers!
The first line contains a single integer $$$q$$$ ($$$1 \le q \le 10^3$$$) — the number of the queries.
Each of the next $$$q$$$ lines contains two integers $$$l$$$ and $$$r$$$ ($$$1 \le l \le r \le 10^9$$$) — the descriptions of the queries.
Print $$$q$$$ lines, each containing one number — the answer to the query. 
In the first query, you need to find the sum of the elements of the array from position $$$1$$$ to position $$$3$$$. The sum is equal to $$$a_1 + a_2 + a_3 = -1 + 2 -3 = -2$$$.
In the second query, you need to find the sum of the elements of the array from position $$$2$$$ to position $$$5$$$. The sum is equal to $$$a_2 + a_3 + a_4 + a_5 = 2 -3 + 4 - 5 = -2$$$.
In the third query, you need to find the sum of the elements of the array from position $$$5$$$ to position $$$5$$$. The sum is equal to $$$a_5 = -5$$$.
","input
In the fourth query, you need to find the sum of the elements of the array from position $$$4$$$ to position $$$4$$$. The sum is equal to $$$a_4 = 4$$$.
output
In the fifth query, you need to find the sum of the elements of the array from position $$$2$$$ to position $$$3$$$. The sum is equal to $$$a_2 + a_3 = 2 - 3 = -1$$$.
",math,1
"# import itertools
# import bisect
# import math
from collections import defaultdict, Counter
import os
import sys
from io import BytesIO, IOBase

# sys.setrecursionlimit(10 ** 5)
ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())


class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True

    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False

    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1

    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x

    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()

        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k

    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1

        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True

    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi

        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0

        _lists = self._lists
        _mins = self._mins

        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi

        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi

        return pos, idx

    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens

        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True

    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)

    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))

    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value

    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx

    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx

    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)

    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len

    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]

    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)

    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False

    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)

    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))

    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))


def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)


def lcm(a, b): return (a * b) // gcd(a, b)


def main():
    # for _ in "" "" * int(input()):
    w, h, n = mii()
    ws, dws, hs, dhs, hsm, wsm = SortedList([]), defaultdict(int), SortedList([]), defaultdict(int), SortedList(
        []), SortedList([])
    hsm.add(h);
    wsm.add(w);
    hs.add(0);
    ws.add(0);
    hs.add(h);
    ws.add(w);
    dhs[h] = 1;
    dhs[0] = 1;
    dws[0] = 1;
    dws[w] = 1
    for i in range(n):
        t, p = map(str, input().split())
        p = int(p)
        if t == ""H"":
            if dhs[p] == 0:
                hs.add(p)
                dhs[p] = 1
            ind = hs.bisect_left(p)
            pre, nex = hs[ind - 1], hs[ind + 1]
            hsm.__delitem__(hsm.bisect_left(nex - pre));
            hsm.add(p - pre);
            hsm.add(nex - p)
        else:
            if dws[p] == 0:
                ws.add(p)
                dws[p] = 1
            ind = ws.bisect_left(p)
            pre, nex = ws[ind - 1], ws[ind + 1]
            wsm.__delitem__(wsm.bisect_left(nex - pre));
            wsm.add(p - pre);
            wsm.add(nex - p)
        print(wsm[-1] * hsm[-1])
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",0527_C,CODEFORCES,2414,Glass Carving,"Leonid wants to become a glass carver (the person who creates beautiful artworks by cutting the glass). He already has a rectangular w mm  ×  h mm sheet of glass, a diamond glass cutter and lots of enthusiasm. What he lacks is understanding of what to carve and how.
In order not to waste time, he decided to practice the technique of carving. To do this, he makes vertical and horizontal cuts through the entire sheet. This process results in making smaller rectangular fragments of glass. Leonid does not move the newly made glass fragments. In particular, a cut divides each fragment of glass that it goes through into smaller fragments.
After each cut Leonid tries to determine what area the largest of the currently available glass fragments has. Since there appear more and more fragments, this question takes him more and more time and distracts him from the fascinating process.
Leonid offers to divide the labor — he will cut glass, and you will calculate the area of the maximum fragment after each cut. Do you agree?
The first line contains three integers w, h, n (2 ≤ w, h ≤ 200 000, 1 ≤ n ≤ 200 000).
Next n lines contain the descriptions of the cuts. Each description has the form H y or V x. In the first case Leonid makes the horizontal cut at the distance y millimeters (1 ≤ y ≤ h - 1) from the lower edge of the original sheet of glass. In the second case Leonid makes a vertical cut at distance x (1 ≤ x ≤ w - 1) millimeters from the left edge of the original sheet of glass. It is guaranteed that Leonid won't make two identical cuts.
","input
After each cut print on a single line the area of the maximum available glass fragment in mm2.
output
Picture for the first sample test: 
","binarysearch, datastructures, implementation",4
"n,m = map(int,input().split())
xi = list(map(int,input().split()))
ti = list(map(int,input().split()))
ai = [0] * (m+2)
ar = [0] * (m+2)
ar[-1] = 10**11
ar[0] = -100000000000
j = 1
n2 = n + m
for i in range(n2):
    if ti[i] == 1:
        ar[j] = xi[i]
        j += 1
i1 = 0
i2 = 1
for i in range(n2):
        if ti[i] == 1:
            i2 += 1
            i1 += 1
            continue
        num = xi[i] - ar[i1]
        num2 = ar[i2] - xi[i]
        if num <= num2:
            ai[i1] += 1
        else:
            ai[i2] += 1
for i in range(1,m+1):
    print(ai[i],end="" "")
",1075_B,CODEFORCES,2029,Taxi drivers and Lyft,"Palo Alto is an unusual city because it is an endless coordinate line. It is also known for the office of Lyft Level 5.
Lyft has become so popular so that it is now used by all $$$m$$$ taxi drivers in the city, who every day transport the rest of the city residents — $$$n$$$ riders.
Each resident (including taxi drivers) of Palo-Alto lives in its unique location (there is no such pair of residents that their coordinates are the same).
The Lyft system is very clever: when a rider calls a taxi, his call does not go to all taxi drivers, but only to the one that is the closest to that person. If there are multiple ones with the same distance, then to taxi driver with a smaller coordinate is selected.
But one morning the taxi drivers wondered: how many riders are there that would call the given taxi driver if they were the first to order a taxi on that day? In other words, you need to find for each taxi driver $$$i$$$ the number $$$a_{i}$$$ — the number of riders that would call the $$$i$$$-th taxi driver when all drivers and riders are at their home?
The taxi driver can neither transport himself nor other taxi drivers.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n,m \le 10^5$$$) — number of riders and taxi drivers.
The second line contains $$$n + m$$$ integers $$$x_1, x_2, \ldots, x_{n+m}$$$ ($$$1 \le x_1 < x_2 < \ldots < x_{n+m} \le 10^9$$$), where $$$x_i$$$ is the coordinate where the $$$i$$$-th resident lives. 
The third line contains $$$n + m$$$ integers $$$t_1, t_2, \ldots, t_{n+m}$$$ ($$$0 \le t_i \le 1$$$). If $$$t_i = 1$$$, then the $$$i$$$-th resident is a taxi driver, otherwise $$$t_i = 0$$$.
It is guaranteed that the number of $$$i$$$ such that $$$t_i = 1$$$ is equal to $$$m$$$.
Print $$$m$$$ integers $$$a_1, a_2, \ldots, a_{m}$$$, where $$$a_i$$$ is the answer for the $$$i$$$-th taxi driver. The taxi driver has the number $$$i$$$ if among all the taxi drivers he lives in the $$$i$$$-th smallest coordinate (see examples for better understanding).
In the first example, we have only one taxi driver, which means an order from any of $$$n$$$ riders will go to him.
","input
In the second example, the first taxi driver lives at the point with the coordinate $$$2$$$, and the second one lives at the point with the coordinate $$$6$$$. Obviously, the nearest taxi driver to the rider who lives on the $$$3$$$ coordinate is the first one, and to the rider who lives on the coordinate $$$5$$$ is the second one. The rider who lives on the $$$4$$$ coordinate has the same distance to the first and the second taxi drivers, but since the first taxi driver has a smaller coordinate, the call from this rider will go to the first taxi driver.
output
In the third example, we have one rider and the taxi driver nearest to him is the fourth one.
","implementation, sortings",3
"import sys
input = sys.stdin.readline

'''

'''

from heapq import heapify, heappush, heappop

n, k = map(int, input().split())
plst = list(map(int, input().split()))
clst = list(map(int, input().split()))

if k == 0:
    print(*clst)
    sys.exit()

pc = sorted(((p, c, i) for i, (p, c) in enumerate(zip(plst, clst))), key=lambda t: (t[0], t[2]))
res = [0] * n
pq = []
pq_sum = 0
pq_size = 0

for p, c, i in pc:
    if i > 0 and plst[i] == plst[i-1]:
        res[i] = res[i-1]
    else:
        res[i] = pq_sum + c

    # Update pq
    if pq_size < k:
        heappush(pq, c)
        pq_sum += c
        pq_size += 1
    else:
        alt = heappop(pq)
        if alt < c:
            heappush(pq, c)
            pq_sum += c - alt
        else:
            heappush(pq, alt)

print(*res)
",0994_B,CODEFORCES,2635,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings",4
"n = int(input())
s = input()
want = len(set(s))
d = {}
j = 0
count = 0
ans = float(""inf"")
for i in range(n):
    if s[i] not in d:
        d[s[i]] = 0
        count+=1
    d[s[i]]+=1
    if count==want:
        while d[s[j]]>1:
            d[s[j]]-=1
            j+=1
        ans = min(ans,i-j+1)
print(ans)",0701_C,CODEFORCES,1519,They Are Everywhere,"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1.
There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 
Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. 
The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house.
The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. 
Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. 
In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.
","input
In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 
output
In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.
","binarysearch, strings, twopointers",3
"n = int(input())
board = list(map(int, input().strip().split()))
board.insert(0,0)
hashed = [0] * (n+1)
for i in range(n+1):
	hashed[board[i]] = i
answer = ['C'] * (n+1)
for i in range(n,0,-1):	
	flag = 0
	k = hashed[i] - board[hashed[i]]
	while(k > 0):
		if(answer[k] == 'B'):
			flag = 1
			break
		k-=board[hashed[i]]
	k = hashed[i] + board[hashed[i]]
	while(k <= n and k != 0):
		if(answer[k] == 'B'):
			flag = 1
			break
		k+=board[hashed[i]]
	if(flag == 1):
		answer[hashed[i]] = 'A'
	else:
		answer[hashed[i]] = 'B'
answer.pop(0)
print(''.join(answer))
",1033_C,CODEFORCES,2802,Permutation Game,"After a long day, Alice and Bob decided to play a little game. The game board consists of $$$n$$$ cells in a straight line, numbered from $$$1$$$ to $$$n$$$, where each cell contains a number $$$a_i$$$ between $$$1$$$ and $$$n$$$. Furthermore, no two cells contain the same number. 
A token is placed in one of the cells. They take alternating turns of moving the token around the board, with Alice moving first. The current player can move from cell $$$i$$$ to cell $$$j$$$ only if the following two conditions are satisfied: 
Whoever is unable to make a move, loses. For each possible starting position, determine who wins if they both play optimally. It can be shown that the game is always finite, i.e. there always is a winning strategy for one of the players.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of numbers.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$). Furthermore, there are no pair of indices $$$i \neq j$$$ such that $$$a_i = a_j$$$.
","input
Print $$$s$$$ — a string of $$$n$$$ characters, where the $$$i$$$-th character represents the outcome of the game if the token is initially placed in the cell $$$i$$$. If Alice wins, then $$$s_i$$$ has to be equal to ""A""; otherwise, $$$s_i$$$ has to be equal to ""B"". 
output
In the first sample, if Bob puts the token on the number (not position): 
","bruteforce, dp, games",4
"def prime2(n):
    cont = 0
    flag = True
    while flag:
        if n % 2 == 0:
            cont += 1
            n = n/2
        else:
            flag = False
    if n % 4 == 1:
        return [cont, ""L""]
    else:
        return [cont, ""R""]

def arrivo(n,start,char):
    for i in char:
        if (i == ""L"" or i == ""R"") and start % 2 == 1:
            pass
        elif (i == ""U"") and 2*start == n+1:
            pass
        else:
            [power, direc] = prime2(start)
            if i == ""L"":
                start -= 2 ** (power - 1)
            elif i == ""R"":
                start += 2 ** (power - 1)
            else:
                if direc == ""L"":
                    start += 2 ** power
                else:
                    start -= 2 ** power
    return start

if __name__ == '__main__':
    [n,q] = map(int, raw_input().rstrip().split())
    for i in range(q):
        start = int(input())
        char = raw_input()
        print(arrivo(n,start,char))",0792_D,CODEFORCES,4533,Paths in a Complete Binary Tree,"T is a complete binary tree consisting of n vertices. It means that exactly one vertex is a root, and each vertex is either a leaf (and doesn't have children) or an inner node (and has exactly two children). All leaves of a complete binary tree have the same depth (distance from the root). So n is a number such that n + 1 is a power of 2.
In the picture you can see a complete binary tree with n = 15.
Vertices are numbered from 1 to n in a special recursive way: we recursively assign numbers to all vertices from the left subtree (if current vertex is not a leaf), then assign a number to the current vertex, and then recursively assign numbers to all vertices from the right subtree (if it exists). In the picture vertices are numbered exactly using this algorithm. It is clear that for each size of a complete binary tree exists exactly one way to give numbers to all vertices. This way of numbering is called symmetric.
You have to write a program that for given n answers q queries to the tree.
Each query consists of an integer number ui (1 ≤ ui ≤ n) and a string si, where ui is the number of vertex, and si represents the path starting from this vertex. String si doesn't contain any characters other than 'L', 'R' and 'U', which mean traverse to the left child, to the right child and to the parent, respectively. Characters from si have to be processed from left to right, considering that ui is the vertex where the path starts. If it's impossible to process a character (for example, to go to the left child of a leaf), then you have to skip it. The answer is the number of vertex where the path represented by si ends.
For example, if ui = 4 and si = «UURL», then the answer is 10.
The first line contains two integer numbers n and q (1 ≤ n ≤ 1018, q ≥ 1). n is such that n + 1 is a power of 2.
The next 2q lines represent queries; each query consists of two consecutive lines. The first of these two lines contains ui (1 ≤ ui ≤ n), the second contains non-empty string si. si doesn't contain any characters other than 'L', 'R' and 'U'.
","input
It is guaranteed that the sum of lengths of si (for each i such that 1 ≤ i ≤ q) doesn't exceed 105.
output
Print q numbers, i-th number must be the answer to the i-th query.
","bitmasks, trees",7
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################
import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math 


alphabets = list('abcdefghijklmnopqrstuvwxyz')


def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):
    """"""
    L is a list.
    The function returns the power set, but as a list of lists.
    """"""
    cardinality=len(L)
    n=2 ** cardinality
    powerset = []
    
    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
        
    #the function could stop here closing with
    #return powerset

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)
        
    return powerset_orderred
def fastPlrintNextLines(a):
    # 12
    # 3
    # 1
    #like this
    #a is list of strings
    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

#__________________________TEMPLATE__________________OVER_______________________________________________________


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1
# t = int(input())
for _ in range(t):
    n,k = li()
    if k<=n:
        print((k-1)//2)
    else:
        print(max((2*n-k+1)//2,0))
    
    
",1023_B,CODEFORCES,406,Pair of Toys,"Tanechka is shopping in the toy shop. There are exactly $$$n$$$ toys in the shop for sale, the cost of the $$$i$$$-th toy is $$$i$$$ burles. She wants to choose two toys in such a way that their total cost is $$$k$$$ burles. How many ways to do that does she have?
Each toy appears in the shop exactly once. Pairs $$$(a, b)$$$ and $$$(b, a)$$$ are considered equal. Pairs $$$(a, b)$$$, where $$$a=b$$$, are not allowed.
The first line of the input contains two integers $$$n$$$, $$$k$$$ ($$$1 \le n, k \le 10^{14}$$$) — the number of toys and the expected total cost of the pair of toys.
Print the number of ways to choose the pair of toys satisfying the condition above. Print 0, if Tanechka can choose no pair of toys in such a way that their total cost is $$$k$$$ burles.
In the first example Tanechka can choose the pair of toys ($$$1, 4$$$) or the pair of toys ($$$2, 3$$$).
In the second example Tanechka can choose only the pair of toys ($$$7, 8$$$).
","input
In the third example choosing any pair of toys will lead to the total cost less than $$$20$$$. So the answer is 0.
output
In the fourth example she can choose the following pairs: $$$(1, 1000000000000)$$$, $$$(2, 999999999999)$$$, $$$(3, 999999999998)$$$, ..., $$$(500000000000, 500000000001)$$$. The number of such pairs is exactly $$$500000000000$$$.
",math,1
"import sys
input=sys.stdin.buffer.readline

n=int(input())
a=list(map(int,input().split()))
dp=[[0]*(n) for i in range(n)]
for i in range(n):
    dp[i][i]=a[i]
count=1
for i in range(n-1):
    for j in range(n-i-1):
        dp[j][j+count]=dp[j][j+count-1]^dp[j+1][j+count]
    count+=1
count=1
for i in range(n-1):
    for j in range(n-i-1):
        dp[j][j+count]=max(dp[j][j+count],dp[j][j+count-1],dp[j+1][j+count])
    count+=1
for i in range(int(input())):
    l,r=map(int,input().split())
    l-=1
    r-=1
    print(dp[l][r])",0983_B,CODEFORCES,3217,XOR-pyramid,"For an array $$$b$$$ of length $$$m$$$ we define the function $$$f$$$ as 
where $$$\oplus$$$ is bitwise exclusive OR.
For example, $$$f(1,2,4,8)=f(1\oplus2,2\oplus4,4\oplus8)=f(3,6,12)=f(3\oplus6,6\oplus12)=f(5,10)=f(5\oplus10)=f(15)=15$$$
You are given an array $$$a$$$ and a few queries. Each query is represented as two integers $$$l$$$ and $$$r$$$. The answer is the maximum value of $$$f$$$ on all continuous subsegments of the array $$$a_l, a_{l+1}, \ldots, a_r$$$.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 5000$$$) — the length of $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$0 \le a_i \le 2^{30}-1$$$) — the elements of the array.
The third line contains a single integer $$$q$$$ ($$$1 \le q \le 100\,000$$$) — the number of queries.
Each of the next $$$q$$$ lines contains a query represented as two integers $$$l$$$, $$$r$$$ ($$$1 \le l \le r \le n$$$).
Print $$$q$$$ lines — the answers for the queries.
","input
In first sample in both queries the maximum value of the function is reached on the subsegment that is equal to the whole segment.
output
In second sample, optimal segment for first query are $$$[3,6]$$$, for second query — $$$[2,5]$$$, for third — $$$[3,4]$$$, for fourth — $$$[1,2]$$$.
",dp,5
"n, k = map(int,input().split())
s = input()
p = len(s)-1
while s[:p] != s[-p:]:
    p =  p -1
print(s + s[p:]*(k-1))",1029_A,CODEFORCES,3453,Many Equal Substrings,"You are given a string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters and an integer number $$$k$$$.
Let's define a substring of some string $$$s$$$ with indices from $$$l$$$ to $$$r$$$ as $$$s[l \dots r]$$$.
Your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ positions $$$i$$$ such that $$$s[i \dots i + n - 1] = t$$$. In other words, your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
It is guaranteed that the answer is always unique.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 50$$$) — the length of the string $$$t$$$ and the number of substrings.
The second line of the input contains the string $$$t$$$ consisting of exactly $$$n$$$ lowercase Latin letters.
","input
Print such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
output
It is guaranteed that the answer is always unique.
","implementation, strings",5
"n, m = map(int, input().split())
a = sorted(map(int, input().split()))
ans = 0
cur = 0
for b in a:
  if b > cur:
    ans += 1
    cur += 1
  else:
    ans += 1
print(sum(a) - (ans + max(a) - cur))
",1061_B,CODEFORCES,2844,Views Matter,"You came to the exhibition and one exhibit has drawn your attention. It consists of $$$n$$$ stacks of blocks, where the $$$i$$$-th stack consists of $$$a_i$$$ blocks resting on the surface.
The height of the exhibit is equal to $$$m$$$. Consequently, the number of blocks in each stack is less than or equal to $$$m$$$.
There is a camera on the ceiling that sees the top view of the blocks and a camera on the right wall that sees the side view of the blocks.
Find the maximum number of blocks you can remove such that the views for both the cameras would not change.
Note, that while originally all blocks are stacked on the floor, it is not required for them to stay connected to the floor after some blocks are removed. There is no gravity in the whole exhibition, so no block would fall down, even if the block underneath is removed. It is not allowed to move blocks by hand either.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 100\,000$$$, $$$1 \le m \le 10^9$$$) — the number of stacks and the height of the exhibit.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le m$$$) — the number of blocks in each stack from left to right.
Print exactly one integer — the maximum number of blocks that can be removed.
","input
The following pictures illustrate the first example and its possible solution.
output
Blue cells indicate removed blocks. There are $$$10$$$ blue cells, so the answer is $$$10$$$.
","greedy, implementation, sortings",4
"def substraction(a,b):
    if a==0 or b==0:
        return 0
    else:
        if a>b:
            count=a//b
            return substraction(a%b,b)+count
        else:
            count = b//a
            return substraction(a,b%a)+count

t=int(input())
lst=[]
res=[]
for i in range(0,t):
    lst=[int(i) for i in input().split()]
    ele=substraction(lst[0],lst[1])
    res.append(ele)

for i in range(0,t):
    print(res[i])",0267_A,CODEFORCES,99,Subtractions,"You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).
You've got some number of pairs (ai, bi). How many operations will be performed for each of them?
","input
The first line contains the number of pairs n (1  ≤  n  ≤  1000). Then follow n lines, each line contains a pair of positive integers ai, bi (1  ≤  ai,  bi  ≤  109).
output
Print the sought number of operations for each pair on a single line.
","math, numbertheory",1
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
#sys.setrecursionlimit(111111) 
INF=99999999999999999999999999999999
def outIn(x):
    print(x, flush=True)
    return input()
def main():

    mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    ###CODE
    tc = 1
    for _ in range(tc):
        s=rs()
        d=Counter(s)
        if '1' in d:
            news=""""
            for i in s:
                if i!='1':
                    news+=i
            ans=""""
            ind=len(news)
            for i in range(len(news)):
                if news[i]=='2':
                    ind=i
                    break
                
            ans=news[0:ind]+'1'*d['1']+news[ind:]
            ws(ans)
        else:
            ws(s)
                
                
            
                    
                    
                     
                
        
                        

            
            
                    
                
                
        
                
                          
            
        
    
        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",1009_B,CODEFORCES,1793,Minimum Ternary String,"You are given a ternary string (it is a string which consists only of characters '0', '1' and '2').
You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace ""01"" with ""10"" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace ""12"" with ""21"" or vice versa).
For example, for string ""010210"" we can perform the following moves: 
Note than you cannot swap ""02"" $$$\rightarrow$$$ ""20"" and vice versa. You cannot perform any other operations with the given string excluding described above.
You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).
String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \le i \le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.
","input
The first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).
output
Print a single string — the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).
","greedy, implementation",3
"import math as m
a=input()
b=input()
total_sum=0
req_pos=0
unreco=0
for i in a:
    if i=='+':
        total_sum+=1
        req_pos+=1

    elif i=='-':
        total_sum-=1
for i in b:
    if i=='+':
        total_sum-=1
        req_pos-=1

    elif i=='-':
        total_sum+=1
    else:
        unreco+=1
#case 1
if (total_sum==0 and unreco==0):
    print(1.000000000)
elif (abs(total_sum)>unreco or req_pos<0):
    print(0.000000000)
else:
    ans=m.factorial(unreco)/(m.factorial(req_pos)*m.factorial(unreco-req_pos)*(2**unreco))
    print(ans)
    ",0476_B,CODEFORCES,4357,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"a=input()
b=input()

if len(b)>len(a):

    l=[int(i) for i in a]
    l.sort()
    l=l[::-1]
    temp=[str(i) for i in l]
    s=''.join(temp)
    print(s)

else:
    d={}

    for i in a:

        if i not in d:

            d[i]=1
        else:

            d[i]=d[i]+1

  

    def find(i):

        global flag
        if i in d and d[i]>0:

            d[i]=d[i]-1

            return(i)

        for j in range(int(i),-1,-1):

            flag=1

            j=str(j)
            
            if j in d and d[j]>0:

                d[j]=d[j]-1

                return(j)

    def fun(d):

        l=[]
        for i in d:

            if d[i]>0:

                
                l=l+[int(i)]*d[i]
        l.sort()
        l=l[::-1]
        temp=[str(i) for i in l]

        s=''.join(temp)

        return(s)


    def fun2(x):

        global new
        for i in range(x-1,-1,-1):
            
            temp=new[i]
            for j in range(int(temp)-1,-1,-1):

                j=str(j)
                
                if j in d and d[j]>0:

                    new=new[:i]+str(j)
                    d[j]=d[j]-1

                    d[temp]=d[temp]+1

                    return(new)
                
            d[temp]=d[temp]+1

                    

                    

                    
                

            
        

    flag=0
    new=''
    for i in range(len(b)):
        
        if flag==0:

            temp=find(b[i])
            
            if temp==None:
              
                new=fun2(i)
           
                
                new=new+fun(d)

                break


                    

                

            else:
                new=new+temp
            
        else:

            new=new+fun(d)
            break
       

            
    print(new)

",915C_,CODEFORCES,4250,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"n=int(input())
b=[]
for i in range(n):
    b.append(list(map(float,input().split())))

ma=1<<n
dp=[0 for j in range(ma)]
dp[0]=1
for mask in range(1,ma):
    l=n-bin(mask).count(""1"")+1
    res=l*(l-1)//2
    for i in range(n):
        if mask&(1<<i):
            for j in range(n):
                if not mask&(1<<j):

                    dp[mask]+=((dp[mask^(1<<i)]*b[j][i])/res)


ans=[]
for i in range(n):
    ans.append(dp[ma-1-(1<<i)])
print(*ans)

",0016_E,CODEFORCES,4278,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"x1, y1, x2, y2, x3, y3, x4, y4 = [int(s) for s in input().split()]
x11, y11, x22, y22, x33, y33, x44, y44 = [int(s) for s in input().split()]

min_x1 = min(x1, x2, x3, x4)
min_y1 = min(y1, y2, y3, y4)
max_x1 = max(x1, x2, x3, x4)
max_y1 = max(y1, y2, y3, y4)

min_x11 = min(x11, x22, x33, x44)
min_y11 = min(y11, y22, y33, y44)
max_x11 = max(x11, x22, x33, x44)
max_y11 = max(y11, y22, y33, y44)

a = (max_x11 + min_x11) / 2
b = (max_y11 + min_y11) / 2
d2 = (max_x11 - min_x11) / 2

for x in range(min_x1, max_x1 + 1):
    for y in range(min_y1, max_y1 + 1):
        if abs(x - a) + abs(y - b) <= d2:
            print(""yes"")
            exit(0)
print(""no"")
",0994_C,CODEFORCES,401,Two Squares,"You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.
The interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.
The input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order.
The first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees.
All the values are integer and between $$$-100$$$ and $$$100$$$.
Print ""Yes"" if squares intersect, otherwise print ""No"".
You can print each letter in any case (upper or lower).
In the first example the second square lies entirely within the first square, so they do intersect.
","input
In the second sample squares do not have any points in common.
output
Here are images corresponding to the samples:
",bruteforce,1
"#n=int(input())
n,m=map(int,input().split())

vert=[]

for i in range(n):
    v=int(input())
    vert.append(v)

horz=[]

for i in range(m):
    x1,x2,y=map(int,input().split())
    if x1==1:
        horz.append(x2)

vert.sort()
horz.sort()

vert.append(1000000000)

def next(k,a,x):
    while k<len(a) and a[k]<x:
        k+=1
    return k

num=next(0,horz,vert[0])

ans=len(horz)-num

for i in range(1,len(vert)):
    num2=next(num,horz,vert[i])
    t=i+len(horz)-num2
    if t<ans: ans=t
    num=num2

print(ans)




",1075_C,CODEFORCES,2884,The Tower is Going Home,"On a chessboard with a width of $$$10^9$$$ and a height of $$$10^9$$$, the rows are numbered from bottom to top from $$$1$$$ to $$$10^9$$$, and the columns are numbered from left to right from $$$1$$$ to $$$10^9$$$. Therefore, for each cell of the chessboard you can assign the coordinates $$$(x,y)$$$, where $$$x$$$ is the column number and $$$y$$$ is the row number.
Every day there are fights between black and white pieces on this board. Today, the black ones won, but at what price? Only the rook survived, and it was driven into the lower left corner — a cell with coordinates $$$(1,1)$$$. But it is still happy, because the victory has been won and it's time to celebrate it! In order to do this, the rook needs to go home, namely — on the upper side of the field (that is, in any cell that is in the row with number $$$10^9$$$).
Everything would have been fine, but the treacherous white figures put spells on some places of the field before the end of the game. There are two types of spells: 
Let's recall that the rook is a chess piece that in one move can move to any point that is in the same row or column with its initial position. In our task, the rook can move from the cell $$$(r_0,c_0)$$$ into the cell $$$(r_1,c_1)$$$ only under the condition that $$$r_1 = r_0$$$ or $$$c_1 = c_0$$$ and there is no blocking lines or blocking segments between these cells (For better understanding, look at the samples).
Fortunately, the rook can remove spells, but for this it has to put tremendous efforts, therefore, it wants to remove the minimum possible number of spells in such way, that after this it can return home. Find this number!
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$0 \le n,m \le 10^5$$$) — the number of vertical and horizontal spells.
Each of the following $$$n$$$ lines contains one integer $$$x$$$ ($$$1 \le x < 10^9$$$) — the description of the vertical spell. It will create a blocking line between the columns of $$$x$$$ and $$$x+1$$$.
Each of the following $$$m$$$ lines contains three integers $$$x_1$$$, $$$x_2$$$ and $$$y$$$ ($$$1 \le x_{1} \le x_{2} \le 10^9$$$, $$$1 \le y < 10^9$$$) — the numbers that describe the horizontal spell. It will create a blocking segment that passes through the top sides of the cells that are in the row with the number $$$y$$$, in columns from $$$x_1$$$ to $$$x_2$$$ inclusive.
It is guaranteed that all spells are different, as well as the fact that for each pair of horizontal spells it is true that the segments that describe them do not have common points.
In a single line print one integer — the minimum number of spells the rook needs to remove so it can get from the cell $$$(1,1)$$$ to at least one cell in the row with the number $$$10^9$$$
In the first sample, in order for the rook return home, it is enough to remove the second horizontal spell.
In the second sample, in order for the rook to return home, it is enough to remove the only vertical spell. If we tried to remove just one of the horizontal spells, it would not allow the rook to get home, because it would be blocked from above by one of the remaining horizontal spells (either first one or second one), and to the right it would be blocked by a vertical spell.
In the third sample, we have two horizontal spells that go through the whole field. These spells can not be bypassed, so we need to remove both of them.
","input
In the fourth sample, we have no spells, which means that we do not need to remove anything.
output
In the fifth example, we can remove the first vertical and third horizontal spells.
",twopointers,4
"n,k=map(int, input().split())
a=list(map(int, input().split()))
i=0
d=0
x=-1
y=-1
s=[0]*(10**5+1)
for j in range (len(a)):
    s[a[j]]+=1
    i+=1
    if s[a[j]]==1:
        d+=1
    if i==1:
        x=j+1
    if d==k:
        y=j+1
        break
while k!=1 and s[a[x-1]]-1!=0:
    s[a[x-1]]-=1
    x+=1
if x==-1 or y==-1:
    x=-1
    y=-1
print(x,y)",0224_B,CODEFORCES,1460,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers",3
"N = 405
n, m = map(int, input().split())
dp = [[0]*N for _ in range(N)]
c = [[1]*N for _ in range(N)]
p = [0]*N


p[0] = 1
for i in range(1, N):
    p[i] = (p[i-1]*2) % m
for i in range(1, N):
    for j in range(1, i):
        c[i][j] = (c[i-1][j-1] + c[i-1][j]) % m


dp[0][0] = 1
for i in range(2, n+2):
    for x in range(1, (n-1)//2 + 2):
        for k in range(1, i):
            dp[i][x] = (dp[i][x] + ((dp[i-k-1][x-1]*p[k-1]) % m) * c[i-x][k]) % m
ans = 0
for i in range(1, (n-1)//2 + 2):
    ans = (ans + dp[n+1][i]) % m
print(ans)",1515_E,CODEFORCES,4049,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"from collections import defaultdict
from sys import stdin
input=stdin.readline
t=int(input())
for _ in range(t):
  n=int(input())
  a=list(map(int,input().split()))
  dd=defaultdict(int)
  for i in range(n):
    dd[a[i]]+=1
  l=[]
  for aa in a:
    if dd[aa]>=2:
      l.append(aa)
      dd[aa]-=2
  l.sort()
  ans=[-1,-1,-1,-1]
  m=10**18
  for i in range(len(l)-1):
    x=(4*(l[i]+l[i+1])**2)/(l[i]*l[i+1])
    if x<m:
      ans=[l[i],l[i],l[i+1],l[i+1]]
      m=x
  print(*ans)",1027_C,CODEFORCES,2766,Minimum Value Rectangle,"You have $$$n$$$ sticks of the given lengths.
Your task is to choose exactly four of them in such a way that they can form a rectangle. No sticks can be cut to pieces, each side of the rectangle must be formed by a single stick. No stick can be chosen multiple times. It is guaranteed that it is always possible to choose such sticks.
Let $$$S$$$ be the area of the rectangle and $$$P$$$ be the perimeter of the rectangle. 
The chosen rectangle should have the value $$$\frac{P^2}{S}$$$ minimal possible. The value is taken without any rounding.
If there are multiple answers, print any of them.
Each testcase contains several lists of sticks, for each of them you are required to solve the problem separately.
The first line contains a single integer $$$T$$$ ($$$T \ge 1$$$) — the number of lists of sticks in the testcase.
Then $$$2T$$$ lines follow — lines $$$(2i - 1)$$$ and $$$2i$$$ of them describe the $$$i$$$-th list. The first line of the pair contains a single integer $$$n$$$ ($$$4 \le n \le 10^6$$$) — the number of sticks in the $$$i$$$-th list. The second line of the pair contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_j \le 10^4$$$) — lengths of the sticks in the $$$i$$$-th list.
It is guaranteed that for each list there exists a way to choose four sticks so that they form a rectangle.
The total number of sticks in all $$$T$$$ lists doesn't exceed $$$10^6$$$ in each testcase.
Print $$$T$$$ lines. The $$$i$$$-th line should contain the answer to the $$$i$$$-th list of the input. That is the lengths of the four sticks you choose from the $$$i$$$-th list, so that they form a rectangle and the value $$$\frac{P^2}{S}$$$ of this rectangle is minimal possible. You can print these four lengths in arbitrary order.
If there are multiple answers, print any of them.
There is only one way to choose four sticks in the first list, they form a rectangle with sides $$$2$$$ and $$$7$$$, its area is $$$2 \cdot 7 = 14$$$, perimeter is $$$2(2 + 7) = 18$$$. $$$\frac{18^2}{14} \approx 23.143$$$.
","input
The second list contains subsets of four sticks that can form rectangles with sides $$$(1, 2)$$$, $$$(2, 8)$$$ and $$$(1, 8)$$$. Their values are $$$\frac{6^2}{2} = 18$$$, $$$\frac{20^2}{16} = 25$$$ and $$$\frac{18^2}{8} = 40.5$$$, respectively. The minimal one of them is the rectangle $$$(1, 2)$$$.
output
You can choose any four of the $$$5$$$ given sticks from the third list, they will form a square with side $$$5$$$, which is still a rectangle with sides $$$(5, 5)$$$.
",greedy,4
"L1=list(map(int, input().split()))
numList=list(map(int, input().split()))
length=L1[0]
targetnumber=L1[1]
pos=numList.index(targetnumber)
pos_r=pos+1
rem=0
right={0:1}
left={0:1}
while pos_r<=length-1:
    if numList[pos_r]>targetnumber:
        rem+=1
    else:
        rem-=1
    if rem not in right:
        right[rem]=1
    else:
        right[rem]+=1
    pos_r+=1
pos_l=pos-1
rem=0
while pos_l>=0:
    if numList[pos_l]>targetnumber:
        rem+=1
    else:
        rem-=1
    if rem not in left:
        left[rem]=1
    else:
        left[rem]+=1
    pos_l-=1
sum=0
for number_l in left:
    if number_l*(-1) in right:
        sum += (left[number_l] * right[(-1) * number_l])
    if 1-number_l in right:
        sum += (left[number_l] * right[1-number_l])
print(sum)",1005_E1,CODEFORCES,2708,Median on Segments (Permutations Edition),"You are given a permutation $$$p_1, p_2, \dots, p_n$$$. A permutation of length $$$n$$$ is a sequence such that each integer between $$$1$$$ and $$$n$$$ occurs exactly once in the sequence.
Find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of the median of $$$p_l, p_{l+1}, \dots, p_r$$$ is exactly the given number $$$m$$$.
The median of a sequence is the value of the element which is in the middle of the sequence after sorting it in non-decreasing order. If the length of the sequence is even, the left of two middle elements is used.
For example, if $$$a=[4, 2, 7, 5]$$$ then its median is $$$4$$$ since after sorting the sequence, it will look like $$$[2, 4, 5, 7]$$$ and the left of two middle elements is equal to $$$4$$$. The median of $$$[7, 1, 2, 9, 6]$$$ equals $$$6$$$ since after sorting, the value $$$6$$$ will be in the middle of the sequence.
Write a program to find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of the median of $$$p_l, p_{l+1}, \dots, p_r$$$ is exactly the given number $$$m$$$.
The first line contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 2\cdot10^5$$$, $$$1 \le m \le n$$$) — the length of the given sequence and the required value of the median.
The second line contains a permutation $$$p_1, p_2, \dots, p_n$$$ ($$$1 \le p_i \le n$$$). Each integer between $$$1$$$ and $$$n$$$ occurs in $$$p$$$ exactly once.
","input
Print the required number.
output
In the first example, the suitable pairs of indices are: $$$(1, 3)$$$, $$$(2, 2)$$$, $$$(2, 3)$$$ and $$$(2, 4)$$$.
",sortings,4
"a , b = list(map(int, input().split()))
x, y, z = list(map(int, input().split()))
ans = 0
p = a - ((x*2) + y)
q = b - ((z*3) + y)
# print(p, q)
if (p < 0 and q < 0):
    print(abs(p) + abs(q))
elif (p < 0):
    print(abs(p))
elif (q < 0):
    print(abs(q))
else:
    print(0)",0912_A,CODEFORCES,206,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation,1
"import sys


def ask(c, d):
    print(""? {} {}"".format(c, d))
    return int(input())


c = d = 0


def solve(mi, base):
    def solve_same():
        global c, d
        print(""# solve_same"", file=sys.stderr)
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d)
            res2 = ask(c, d ^ bit)
            if res1 == -1 and res2 == 1:
                c |= bit
                d |= bit

    def solve1():
        global c, d
        print(""# solve1"", file=sys.stderr)
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == -1:
                # a[i] == 1, b[i] == 0
                c |= bit
                return solve(i - 1, ask(c, d))
            else:
                # a[i] == b[i]
                res2 = ask(c ^ bit, d)
                if res2 == -1:
                    # a[i] == b[i] == 1
                    c |= bit
                    d |= bit

    def solve2():
        global c, d
        print(""# solve2"", file=sys.stderr)
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == 1:
                # a[i] == 0, b[i] == 1
                d |= bit
                return solve(i - 1, ask(c, d))
            else:
                # a[i] == b[i]
                res2 = ask(c, d ^ bit)
                if res2 == 1:
                    # a[i] == b[i] == 1
                    c |= bit
                    d |= bit

    if base == 0:
        solve_same()
    elif base == 1:
        solve1()
    else:
        solve2()


solve(29, ask(0, 0))
print(""! {} {}"".format(c, d))
",1088_D,CODEFORCES,1215,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",2
"def Sort(x):
	if len(x) == 1:
		return x
		
	a = Sort(x[:len(x) // 2])
	b = Sort(x[len(x) // 2:])
	
	c = []
	i = 0
	j = 0
	while (i < len(a))and(j < len(b)):
		if a[i] < b[j]:
			c.append(a[i])
			i += 1
		else:
			c.append(b[j])
			j += 1
	
	c = c + b[j:]
	c = c + a[i:]
	
	return c

input()
m = [int(i) for i in input().split(' ')]

newm = Sort(m)
count = 0
for i in range(len(m)):
 if newm[i] != m[i]:
  count += 1

if count / 2 <= 1:
 print('YES')
else:
 print('NO')
    	   				  	  	 		  				   	",0220_A,CODEFORCES,2373,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]
 
d = [[] for _ in range(n)]
for j, v in enumerate(b):
	e[v][j] = j
	d[j].append(j)
 
for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)
 
a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
				 		  					  	 					 	 	 			",1312_E,CODEFORCES,3869,Array Shrinking,"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation any number of times:
After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array $$$a$$$ you can get?
The first line contains the single integer $$$n$$$ ($$$1 \le n \le 500$$$) — the initial length of the array $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$) — the initial array $$$a$$$.
Print the only integer — the minimum possible length you can get after performing the operation described above any number of times.
In the first test, this is one of the optimal sequences of operations: $$$4$$$ $$$3$$$ $$$2$$$ $$$2$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$\rightarrow$$$ $$$5$$$ $$$3$$$.
","input
In the second test, this is one of the optimal sequences of operations: $$$3$$$ $$$3$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$5$$$ $$$4$$$ $$$\rightarrow$$$ $$$6$$$ $$$4$$$.
output
In the third and fourth tests, you can't perform the operation at all.
","dp, greedy",6
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
T, = getIntList()
#print(N)

MAXN = 10**18 + 10
def getUpper(N):
    z = 1
    r = 0
    for i in range(N):
        r+=z
        z*=4
        if r>MAXN:
            break
    return r
for _ in range(T):
    N,K = getIntList()
    tk = K
    z = 1
    for i in range(N):
        tk -= z
        z*= 4
        if tk<0: break
    if tk>0:
        print('NO')
        continue
    nowcut =  0
    nt = 1
    nowupper = 0
    ok = False
    for i in range(N):
        nt *=2
        nowcut += nt-1
        
        if nowcut >K: break
        t = (nt *2 - 3)
        tu  = t * getUpper(N-1-i)
        nowupper += tu
        dprint('bound', nowcut, nowcut+nowupper)
        if nowcut<=K<= nowcut+nowupper:
            ok = True
            break
    if ok:
        print('YES', N-1-i)
    else:
        print(""NO"")


",1080_D,CODEFORCES,1168,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"entrada = input().split()

l = int(entrada[0])
r = int(entrada[1])

pop = l ^ r
result = 1

while (result <= pop):
    result = result << 1

print(result - 1)
		  				  		 	  	    					 		",0276_D,CODEFORCES,836,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"string = input().strip()
mx = 0

for i in range(len(string)):
    for j in range(i+1, len(string)):
        m = 0
        while(j+m < len(string) and string[i+m] == string[j+m]):
            m += 1
        mx = max(mx, m)

print(mx)",0023_A,CODEFORCES,3732,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"n=int(input())
l=[]
for i in range(n):
    s=str(input())
    l.append(s)
print(6-n)  
if ""purple"" not in l:
    print(""Power"")
if ""green"" not in l:
    print(""Time"")
if ""red"" not in l:
    print(""Reality"")
if ""blue"" not in l:
    print(""Space"")
if ""orange"" not in l:
    print(""Soul"")
if ""yellow"" not in l:
    print(""Mind"")
",0987_A,CODEFORCES,345,Infinity Gauntlet,"You took a peek on Thanos wearing Infinity Gauntlet. In the Gauntlet there is a place for six Infinity Gems:
Using colors of Gems you saw in the Gauntlet determine the names of absent Gems.
In the first line of input there is one integer $$$n$$$ ($$$0 \le n \le 6$$$) — the number of Gems in Infinity Gauntlet.
In next $$$n$$$ lines there are colors of Gems you saw. Words used for colors are: purple, green, blue, orange, red, yellow. It is guaranteed that all the colors are distinct. All colors are given in lowercase English letters.
In the first line output one integer $$$m$$$ ($$$0 \le m \le 6$$$) — the number of absent Gems.
Then in $$$m$$$ lines print the names of absent Gems, each on its own line. Words used for names are: Power, Time, Space, Soul, Reality, Mind. Names can be printed in any order. Keep the first letter uppercase, others lowercase.
","input
In the first sample Thanos already has Reality, Power, Mind and Soul Gems, so he needs two more: Time and Space.
output
In the second sample Thanos doesn't have any Gems, so he needs all six.
",implementation,1
"import sys

def ints():
    return map(int, input().split())

n, m, k = ints()
right = []
for i in range(n):
    right.append(list(ints()))
down = []
for i in range(n-1):
    down.append(list(ints()))

INF = int(1e8)

def around(r, c):
    a = []
    for i, j in [[r-1, c], [r, c+1], [r+1, c], [r, c-1]]:
        if not (i < 0 or i >= n or j < 0 or j >= m):
            a.append([i, j])
    return a

def mink(dist, si, sj):
    minn = INF
    for i in range(max(0, si-k//2), min(n, si+k//2+1)):
        for j in range(max(0, sj-k//2), min(m, sj+k//2+1)):
            if dist[i][j] < minn:
                minn = dist[i][j]
    return minn

def solve():
    pdist = [[0] * m for i in range(n)]
    if k & 1:
        return [[-1] * m for i in range(n)]
    for step in range(k//2):
        dist = [[0] * m for i in range(n)]
        for i in range(n):
            for j in range(m):
                adist = []
                for ip, jp in around(i, j):
                    if ip == i:
                        if jp > j:
                            w = right[i][j]
                        else:
                            w = right[i][jp]
                    else:
                        if ip > i:
                            w = down[i][j]
                        else:
                            w = down[ip][j]
                    adist.append(pdist[ip][jp] + w)
                dist[i][j] = min(adist)
        pdist = dist
    for i in range(n):
        for j in range(m):
            pdist[i][j] *= 2
    return pdist

for row in solve():
    print(*row)",1517_D,CODEFORCES,4091,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import math
def solve():
    words = input().split()
    people = int(words[0])
    planes_each = int(words[1])
    per = int(words[2])
    sheets = int(words[3])
    sheets_per_person = math.ceil(planes_each/per)
    needed = sheets_per_person*people
    packs = math.ceil(needed/sheets)
    print(packs)

    

# for _ in range(int(input())):
solve()",0965_A,CODEFORCES,288,Paper Airplanes,"To make a paper airplane, one has to use a rectangular piece of paper. From a sheet of standard size you can make $$$s$$$ airplanes.
A group of $$$k$$$ people decided to make $$$n$$$ airplanes each. They are going to buy several packs of paper, each of them containing $$$p$$$ sheets, and then distribute the sheets between the people. Each person should have enough sheets to make $$$n$$$ airplanes. How many packs should they buy?
The only line contains four integers $$$k$$$, $$$n$$$, $$$s$$$, $$$p$$$ ($$$1 \le k, n, s, p \le 10^4$$$) — the number of people, the number of airplanes each should make, the number of airplanes that can be made using one sheet and the number of sheets in one pack, respectively.
Print a single integer — the minimum number of packs they should buy.
","input
In the first sample they have to buy $$$4$$$ packs of paper: there will be $$$12$$$ sheets in total, and giving $$$2$$$ sheets to each person is enough to suit everyone's needs.
output
In the second sample they have to buy a pack for each person as they can't share sheets.
",math,1
"n, k = map(int, input().split())
count = [0] * k
for c in input():
    count[ord(c) - ord(""A"")] += 1
print(k * min(count))

",1038_A,CODEFORCES,1938,Equality,"You are given a string $$$s$$$ of length $$$n$$$, which consists only of the first $$$k$$$ letters of the Latin alphabet. All letters in string $$$s$$$ are uppercase.
A subsequence of string $$$s$$$ is a string that can be derived from $$$s$$$ by deleting some of its symbols without changing the order of the remaining symbols. For example, ""ADE"" and ""BD"" are subsequences of ""ABCDE"", but ""DEA"" is not.
A subsequence of $$$s$$$ called good if the number of occurences of each of the first $$$k$$$ letters of the alphabet is the same.
Find the length of the longest good subsequence of $$$s$$$. 
The first line of the input contains integers $$$n$$$ ($$$1\le n \le 10^5$$$) and $$$k$$$ ($$$1 \le k \le 26$$$).
The second line of the input contains the string $$$s$$$ of length $$$n$$$. String $$$s$$$ only contains uppercase letters from 'A' to the $$$k$$$-th letter of Latin alphabet.
Print the only integer — the length of the longest good subsequence of string $$$s$$$.
","input
In the first example, ""ACBCAB"" (""ACAABCCAB"") is one of the subsequences that has the same frequency of 'A', 'B' and 'C'. Subsequence ""CAB"" also has the same frequency of these letters, but doesn't have the maximum possible length.
output
In the second example, none of the subsequences can have 'D', hence the answer is $$$0$$$.
","implementation, strings",3
"z,zz=input,lambda:list(map(int,z().split()))
zzz=lambda:[int(i) for i in stdin.readline().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from re import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
        
    return 1
def dfs(u,visit,graph):
    visit[u]=True
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)

###########################---Test-Case---#################################
""""""



""""""
###########################---START-CODING---##############################

move,can=zz()
curr=0

for i in range(1,move+1):
    curr+=i
    if curr-(move-i)==can:
        print(move-i)
        break




else:
    print(0)

",1195_B,CODEFORCES,1411,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import os
import io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline 
 
from math import sqrt,ceil
 
max_n=10**7+1
spf = [i for i in range(max_n)]
 
for i in range(4,max_n,2): 
    spf[i]=2
    
for i in range(3,ceil(sqrt(max_n))): 
    if (spf[i]==i):  
        for j in range(i*i,max_n,i):  
            if(spf[j]==j):
                spf[j]=i
                
from collections import Counter,defaultdict
from bisect import insort
 
def f(x):
    c=Counter()
    ans=1
    while(x!=1):
        c[spf[x]]+=1
        x//=spf[x] 
    for i in c:
        if(c[i]%2==1):
            ans*=i
    return(ans)
 
#XXXX
 
t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    a=list(map(int,input().split()))
    for i in range(n):
        a[i]=f(a[i])
    dp_depth=[[n for j in range(k+1)] for i in range(n)] #Maximum length that can be tranversed in list, starting from index i with atmost j repeated elements(default is entire length of list(max possible)
    recent=[n for i in range(k+1)] #Stores position of most recent repeated element in the suffix(default is one more that maximum index(when no sufficient repeats))
    closest=defaultdict(lambda: -1) #Stores index of first repetition for a particular ai 
    for i in range(n-1,-1,-1):
        if(closest[a[i]]>=0):
            insort(recent,closest[a[i]])
            recent.pop()
        dp_depth[i]=recent.copy()
        closest[a[i]]=i 
    dp=[[i for j in range(k+1)] for i in range(n+1)]
    #dp=[[float('inf') for j in range(k+1)] for i in range(n+1)] #Minimum number of sets in the prefix segment upto(and **excluding**) index i after atmost k changes(which is also = number of partitions/splits(number of element changes) upto and **excluding** index i).
    #Note we could have changed the float('inf') to ""i"" but that's tougher to debug.
    dp[0]=[0 for j in range(k+1)] #base case(don't need to divide at all before element at index 0(first element))
    for i in range(n):
        for x in range(k+1): 
            end=dp_depth[i][x] #The end point of our segment(upto and exluding this index position)
            #We are dividing each segment into subsegments: prefix consisting of [0,i), suffix consisting from [i,end)
            #x is the number of partitions/splits(number of elements we change) in the suffix subsegment(Number of repeated elements starting from index i)
            for y in range(k-x+1): #y is the number of partitions/splits(number of elements we change) in the prefix subsegment
                dp[end][x+y]=min(dp[end][x+y],dp[i][y]+1) #after using the previously calculated value dp[i][y](<=y changes), with <= x more ""changes""(equality holds iff end=n) in the suffix segment, this gives an extra set starting from [i,end). So overall, we get number of sets of dp[i][y]+1.
    print(dp[n][k])
                
                
            

",1497_E2,CODEFORCES,4032,Square-Free Division (hard version),"This is the hard version of the problem. The only difference is that in this version $$$0 \leq k \leq 20$$$.
There is an array $$$a_1, a_2, \ldots, a_n$$$ of $$$n$$$ positive integers. You should divide it into a minimal number of continuous segments, such that in each segment there are no two numbers (on different positions), whose product is a perfect square.
Moreover, it is allowed to do at most $$$k$$$ such operations before the division: choose a number in the array and change its value to any positive integer.
What is the minimum number of continuous segments you should use if you will make changes optimally?
The first line contains a single integer $$$t$$$ $$$(1 \le t \le 1000)$$$  — the number of test cases.
The first line of each test case contains two integers $$$n$$$, $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$0 \leq k \leq 20$$$).
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 10^7$$$).
It's guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \cdot 10^5$$$.
For each test case print a single integer  — the answer to the problem.
","input
In the first test case it is possible to change the array this way: $$$[\underline{3}, 6, 2, 4, \underline{5}]$$$ (changed elements are underlined). After that the array does not need to be divided, so the answer is $$$1$$$.
output
In the second test case it is possible to change the array this way: $$$[6, 2, \underline{3}, 8, 9, \underline{5}, 3, 6, \underline{10}, \underline{11}, 7]$$$. After that such division is optimal: 
","datastructures, dp, greedy, math, numbertheory, twopointers",6
"import sys

n, m, k = list(map(int, sys.stdin.readline().strip().split()))
a = list(map(int, sys.stdin.readline().strip().split()))
b = [0] * (n+1)
for i in range (1, n+1):
    b[i] = b[i-1] + m * a[i-1] - k
M = [10 ** 20] * m
ans = 0
for i in range (0, n+1):
    M[i % m] = min([M[i % m], b[i]])
    for j in range (0, m):
        if i > j:
            ans = max([ans, b[i]-M[j]-k*((m*i+m-(i-j))%m)])
    # print(j, M, ans)
print(ans // m)
",1197_D,CODEFORCES,3627,Yet Another Subarray Problem,"You are given an array $$$a_1, a_2, \dots , a_n$$$ and two integers $$$m$$$ and $$$k$$$.
You can choose some subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$. 
The cost of subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$ is equal to $$$\sum\limits_{i=l}^{r} a_i - k \lceil \frac{r - l + 1}{m} \rceil$$$, where $$$\lceil x \rceil$$$ is the least integer greater than or equal to $$$x$$$. 
The cost of empty subarray is equal to zero.
For example, if $$$m = 3$$$, $$$k = 10$$$ and $$$a = [2, -4, 15, -3, 4, 8, 3]$$$, then the cost of some subarrays are:
Your task is to find the maximum cost of some subarray (possibly empty) of array $$$a$$$.
The first line contains three integers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \le n \le 3 \cdot 10^5, 1 \le m \le 10, 1 \le k \le 10^9$$$).
","input
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$).
output
Print the maximum cost of some subarray of array $$$a$$$.
","dp, greedy, math",5
"_, k = [int(x) for x in input().split()]
a = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
c = list(sorted(zip(a, b, range(len(b)))))
d = [0] * len(b)

if k == 0:
    print(' '.join(map(str, b)))
else:
    best = [0] * k
    for pwr, cnt, index in c:
        d[index] = sum(best) + cnt

        if cnt > best[0]:
            for i in range(len(best)):
                if cnt <= best[i]:
                    best.insert(i, cnt)
                    best = best[1:]
                    break
            else:
                best = best[1:] + [cnt]


    print(' '.join(map(str, d)))
",0994_B,CODEFORCES,2644,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings",4
"import sys
n,m=map(int,input().split())
s=[list(input()) for i in range(n)]
u=[[-1 for i in range(m)] for j in range(n)]
d=[[-1 for i in range(m)] for j in range(n)]
l=[[-1 for i in range(m)] for j in range(n)]
r=[[-1 for i in range(m)] for j in range(n)]
for i in range(m):
    acum=0
    for j in range(n):
        if s[j][i]==""."":
            acum=0
        else:
            acum+=1
        u[j][i]=acum
for i in range(m):
    acum=0
    for j in range(n-1,-1,-1):
        if s[j][i]==""."":
            acum=0
        else:
            acum+=1
        d[j][i]=acum
for i in range(n):
    acum=0
    for j in range(m):
        if s[i][j]==""."":
            acum=0
        else:
            acum+=1
        l[i][j]=acum
for i in range(n):
    acum=0
    for j in range(m-1,-1,-1):
        if s[i][j]==""."":
            acum=0
        else:
            acum+=1
        r[i][j]=acum
ans=[]
t1=[[0 for i in range(m)] for j in range(n)]
t2=[[0 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        d1=min(l[i][j],r[i][j],u[i][j],d[i][j])-1
        if d1>0:
            ans.append([i+1,j+1,d1])
            t1[i+d1][j]+=1
            t1[i-d1][j]-=1
            t2[i][j-d1]+=1
            t2[i][j+d1]-=1
dp=[['.' for i in range(m)] for j in range(n)]
for i in range(n):
    acum=0
    for j in range(m):
        acum+=t2[i][j]
        if acum!=0 or t2[i][j]!=0:
            dp[i][j]='*'
for i in range(m):
    acum=0
    for j in range(n):
        acum+=t1[j][i]
        if acum!=0 or t1[j][i]!=0 :
            dp[j][i]='*'           
if dp!=s:
    print(-1)
    sys.exit()
print(len(ans))
for i in ans:
    print(*i)
        
        
",1015_E2,CODEFORCES,3393,Stars Drawing (Hard Edition),"A star is a figure of the following type: an asterisk character '*' in the center of the figure and four rays (to the left, right, top, bottom) of the same positive length. The size of a star is the length of its rays. The size of a star must be a positive number (i.e. rays of length $$$0$$$ are not allowed).
Let's consider empty cells are denoted by '.', then the following figures are stars:
You are given a rectangular grid of size $$$n \times m$$$ consisting only of asterisks '*' and periods (dots) '.'. Rows are numbered from $$$1$$$ to $$$n$$$, columns are numbered from $$$1$$$ to $$$m$$$. Your task is to draw this grid using any number of stars or find out that it is impossible. Stars can intersect, overlap or even coincide with each other. The number of stars in the output can't exceed $$$n \cdot m$$$. Each star should be completely inside the grid. You can use stars of same and arbitrary sizes.
In this problem, you do not need to minimize the number of stars. Just find any way to draw the given grid with at most $$$n \cdot m$$$ stars.
The first line of the input contains two integers $$$n$$$ and $$$m$$$ ($$$3 \le n, m \le 1000$$$) — the sizes of the given grid.
The next $$$n$$$ lines contains $$$m$$$ characters each, the $$$i$$$-th line describes the $$$i$$$-th row of the grid. It is guaranteed that grid consists of characters '*' and '.' only.
If it is impossible to draw the given grid using stars only, print ""-1"".
Otherwise in the first line print one integer $$$k$$$ ($$$0 \le k \le n \cdot m$$$) — the number of stars needed to draw the given grid. The next $$$k$$$ lines should contain three integers each — $$$x_j$$$, $$$y_j$$$ and $$$s_j$$$, where $$$x_j$$$ is the row index of the central star character, $$$y_j$$$ is the column index of the central star character and $$$s_j$$$ is the size of the star. Each star should be completely inside the grid.
","input
In the first example the output 
output
is also correct.
","binarysearch, dp, greedy",5
"n,k=list(map(int,input().split()))
a=list(map(int,input().split()))
b=[]
for i in range(11):
    c={}
    for j in range(n):
        d=(a[j]*(10**i))%k
        if d in c.keys():
            c[d]+=1
        else:
            c[d]=1
    b.append(c)

s=0
for i in range(n):
    c=a[i]%k
    d=(k-c)%k
    if d in b[len(str(a[i]))]:
        s+=b[len(str(a[i]))][d]
    if (a[i]*(10**len(str(a[i]))))%k==d:
        s-=1
print(s)",1029_D,CODEFORCES,2778,Concatenated Multiples,"You are given an array $$$a$$$, consisting of $$$n$$$ positive integers.
Let's call a concatenation of numbers $$$x$$$ and $$$y$$$ the number that is obtained by writing down numbers $$$x$$$ and $$$y$$$ one right after another without changing the order. For example, a concatenation of numbers $$$12$$$ and $$$3456$$$ is a number $$$123456$$$.
Count the number of ordered pairs of positions $$$(i, j)$$$ ($$$i \neq j$$$) in array $$$a$$$ such that the concatenation of $$$a_i$$$ and $$$a_j$$$ is divisible by $$$k$$$.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$2 \le k \le 10^9$$$).
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
Print a single integer — the number of ordered pairs of positions $$$(i, j)$$$ ($$$i \neq j$$$) in array $$$a$$$ such that the concatenation of $$$a_i$$$ and $$$a_j$$$ is divisible by $$$k$$$.
In the first example pairs $$$(1, 2)$$$, $$$(1, 3)$$$, $$$(2, 3)$$$, $$$(3, 1)$$$, $$$(3, 4)$$$, $$$(4, 2)$$$, $$$(4, 3)$$$ suffice. They produce numbers $$$451$$$, $$$4510$$$, $$$110$$$, $$$1045$$$, $$$1012$$$, $$$121$$$, $$$1210$$$, respectively, each of them is divisible by $$$11$$$.
","input
In the second example all $$$n(n - 1)$$$ pairs suffice.
output
In the third example no pair is sufficient.
","implementation, math",4
"n=int(input())
m=int(input())
a=list(map(int, input().split()))
b=list(map(int, input().split()))
curr=m
f=0
if b[0]!=1:
    curr+=(curr)/(b[0]-1)
else:
    f=1
for i in range(n-1,-1,-1):
    if a[i]!=1:
        curr+=(curr)/(a[i]-1)
    else:
        f=1
    if i>0:
        if b[i]!=1:
            curr+=(curr)/(b[i]-1)
        else:
            f=1
if f:
    print(-1)
else:
    print(curr-m)
",1010_A,CODEFORCES,1812,Fly,"Natasha is going to fly on a rocket to Mars and return to Earth. Also, on the way to Mars, she will land on $$$n - 2$$$ intermediate planets. Formally: we number all the planets from $$$1$$$ to $$$n$$$. $$$1$$$ is Earth, $$$n$$$ is Mars. Natasha will make exactly $$$n$$$ flights: $$$1 \to 2 \to \ldots n \to 1$$$.
Flight from $$$x$$$ to $$$y$$$ consists of two phases: take-off from planet $$$x$$$ and landing to planet $$$y$$$. This way, the overall itinerary of the trip will be: the $$$1$$$-st planet $$$\to$$$ take-off from the $$$1$$$-st planet $$$\to$$$ landing to the $$$2$$$-nd planet $$$\to$$$ $$$2$$$-nd planet $$$\to$$$ take-off from the $$$2$$$-nd planet $$$\to$$$ $$$\ldots$$$ $$$\to$$$ landing to the $$$n$$$-th planet $$$\to$$$ the $$$n$$$-th planet $$$\to$$$ take-off from the $$$n$$$-th planet $$$\to$$$ landing to the $$$1$$$-st planet $$$\to$$$ the $$$1$$$-st planet.
The mass of the rocket together with all the useful cargo (but without fuel) is $$$m$$$ tons. However, Natasha does not know how much fuel to load into the rocket. Unfortunately, fuel can only be loaded on Earth, so if the rocket runs out of fuel on some other planet, Natasha will not be able to return home. Fuel is needed to take-off from each planet and to land to each planet. It is known that $$$1$$$ ton of fuel can lift off $$$a_i$$$ tons of rocket from the $$$i$$$-th planet or to land $$$b_i$$$ tons of rocket onto the $$$i$$$-th planet. 
For example, if the weight of rocket is $$$9$$$ tons, weight of fuel is $$$3$$$ tons and take-off coefficient is $$$8$$$ ($$$a_i = 8$$$), then $$$1.5$$$ tons of fuel will be burnt (since $$$1.5 \cdot 8 = 9 + 3$$$). The new weight of fuel after take-off will be $$$1.5$$$ tons. 
Please note, that it is allowed to burn non-integral amount of fuel during take-off or landing, and the amount of initial fuel can be non-integral as well.
Help Natasha to calculate the minimum mass of fuel to load into the rocket. Note, that the rocket must spend fuel to carry both useful cargo and the fuel itself. However, it doesn't need to carry the fuel which has already been burnt. Assume, that the rocket takes off and lands instantly.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 1000$$$) — number of planets.
The second line contains the only integer $$$m$$$ ($$$1 \le m \le 1000$$$) — weight of the payload.
The third line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 1000$$$), where $$$a_i$$$ is the number of tons, which can be lifted off by one ton of fuel.
The fourth line contains $$$n$$$ integers $$$b_1, b_2, \ldots, b_n$$$ ($$$1 \le b_i \le 1000$$$), where $$$b_i$$$ is the number of tons, which can be landed by one ton of fuel. 
It is guaranteed, that if Natasha can make a flight, then it takes no more than $$$10^9$$$ tons of fuel.
If Natasha can fly to Mars through $$$(n - 2)$$$ planets and return to Earth, print the minimum mass of fuel (in tons) that Natasha should take. Otherwise, print a single number $$$-1$$$.
It is guaranteed, that if Natasha can make a flight, then it takes no more than $$$10^9$$$ tons of fuel.
The answer will be considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$. Formally, let your answer be $$$p$$$, and the jury's answer be $$$q$$$. Your answer is considered correct if $$$\frac{|p - q|}{\max{(1, |q|)}} \le 10^{-6}$$$.
Let's consider the first example.
","input
Initially, the mass of a rocket with fuel is $$$22$$$ tons.
output
In the second case, the rocket will not be able even to take off from Earth.
","binarysearch, math",3
"from sys import stdout
N,M=map(int,input().split())
if M%2==0 and N%2==0:
    for m in range (1,M//2+1): 
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
elif M%2==0 and N%2==1:
    for m in range (1,M//2+1): 
        for i in range (1,N+1):
            stdout.write(str(i)+' '+str(m)+'\n')
            stdout.write(str(N+1-i)+' '+str(M+1-m)+'\n')
else:
    for m in range (1,(M+1)//2): 
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
    if N%2==0:
        for i in range (1,N//2+1):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
    else:
        for i in range (1,(N+1)//2):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
        stdout.write(str((N+1)//2)+' '+str((M+1)//2)+'\n')",1179_B,CODEFORCES,3594,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms,5
"n = int(input())
a = {}
ans = 0
sum = 0
i = 0
for t in map(int, input().split()):
    sum += t
    a[t] = a.get(t, 0) + 1

    ans += (i - a.get(t, 0) - a.get(t - 1, 0) - a.get(t + 1, 0) + 1) * t - (sum - a.get(t, 0) * t - a.get(t - 1, 0) * (t - 1) - a.get(t + 1, 0) * (t + 1))
    i += 1
            
print(ans)
",0903_D,CODEFORCES,2449,Almost Difference,"Let's denote a function 

You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
The first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. 
","input
Print one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.
output
In the first example:
","datastructures, math",4
"from sys import stdin,stdout
input=stdin.readline

def count(audrey,imba,banget):
    return((imba-audrey-1)%(banget-1))
 
n,q=map(int,input().split())
L=list(map(int,input().split()))
maxi=max(L)
indexmax=L.index(maxi)
P=[]
for i in range(indexmax):
    P.append((L[0],L[1]))
    if L[0]<L[1]:
        L.append(L.pop(0))
    else:
        L.append(L.pop(1))
Y=tuple(L[1:])
for p in range(q):
    m=int(input())
    if m<=indexmax:
        print(str(P[m-1][0])+' '+str(P[m-1][1]))
    else:
        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",1179_A,CODEFORCES,2145,Valeriy and Deque,"Recently, on the course of algorithms and data structures, Valeriy learned how to use a deque. He built a deque filled with $$$n$$$ elements. The $$$i$$$-th element is $$$a_i$$$ ($$$i$$$ = $$$1, 2, \ldots, n$$$). He gradually takes the first two leftmost elements from the deque (let's call them $$$A$$$ and $$$B$$$, respectively), and then does the following: if $$$A > B$$$, he writes $$$A$$$ to the beginning and writes $$$B$$$ to the end of the deque, otherwise, he writes to the beginning $$$B$$$, and $$$A$$$ writes to the end of the deque. We call this sequence of actions an operation.
For example, if deque was $$$[2, 3, 4, 5, 1]$$$, on the operation he will write $$$B=3$$$ to the beginning and $$$A=2$$$ to the end, so he will get $$$[3, 4, 5, 1, 2]$$$.
The teacher of the course, seeing Valeriy, who was passionate about his work, approached him and gave him $$$q$$$ queries. Each query consists of the singular number $$$m_j$$$ $$$(j = 1, 2, \ldots, q)$$$. It is required for each query to answer which two elements he will pull out on the $$$m_j$$$-th operation.
Note that the queries are independent and for each query the numbers $$$A$$$ and $$$B$$$ should be printed in the order in which they will be pulled out of the deque.
Deque is a data structure representing a list of elements where insertion of new elements or deletion of existing elements can be made from both sides.
The first line contains two integers $$$n$$$ and $$$q$$$ ($$$2 \leq n \leq 10^5$$$, $$$0 \leq q \leq 3 \cdot 10^5$$$) — the number of elements in the deque and the number of queries. The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$, where $$$a_i$$$ $$$(0 \leq a_i \leq 10^9)$$$ — the deque element in $$$i$$$-th position. The next $$$q$$$ lines contain one number each, meaning $$$m_j$$$ ($$$1 \leq m_j \leq 10^{18}$$$).
For each teacher's query, output two numbers $$$A$$$ and $$$B$$$ — the numbers that Valeriy pulls out of the deque for the $$$m_j$$$-th operation.
","input
So, $$$2$$$ we write to the beginning of the deque, and $$$1$$$ — to the end.
output
We get the following status of the deque: $$$[2, 3, 4, 5, 1]$$$.
","datastructures, implementation",3
"n, s = map(int, input().split())
ans = s // n
s %= n
if s != 0:
    ans += 1
print(ans)
",1061_A,CODEFORCES,520,Coins,"You have unlimited number of coins with values $$$1, 2, \ldots, n$$$. You want to select some set of coins having the total value of $$$S$$$. 
It is allowed to have multiple coins with the same value in the set. What is the minimum number of coins required to get sum $$$S$$$?
The only line of the input contains two integers $$$n$$$ and $$$S$$$ ($$$1 \le n \le 100\,000$$$, $$$1 \le S \le 10^9$$$)
Print exactly one integer — the minimum number of coins required to obtain sum $$$S$$$.
In the first example, some of the possible ways to get sum $$$11$$$ with $$$3$$$ coins are: 
It is impossible to get sum $$$11$$$ with less than $$$3$$$ coins.
","input
In the second example, some of the possible ways to get sum $$$16$$$ with $$$3$$$ coins are: 
output
It is impossible to get sum $$$16$$$ with less than $$$3$$$ coins.
","greedy, implementation, math",1
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def main():
    inf = -float(""inf"")
    for _ in range(int(input())):
        n,m = map(int,input().split())
        a = [list(map(int,input().split())) for _ in range(n)]
        y = 1<<n
        dp = [[0]+[inf]*(y-1) for _ in range(m+1)]
        for i in range(1,m+1):
            for shift in range(n):
                for mask1 in range(y):
                    for mask2 in range(y):
                        new = mask1^mask2
                        if new&mask1:
                            continue
                        mm,add = 1,0
                        for x in range(n):
                            if mm&new:
                                tt = x+shift
                                if tt >= n:
                                    tt -= n
                                add += a[tt][i-1]
                            mm <<= 1
                        dp[i][mask2] = max(dp[i][mask2],dp[i-1][mask1]+add)
        print(dp[m][y-1])

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",1209_E1,CODEFORCES,4608,Rotate Columns (easy version),"This is an easier version of the next problem. The difference is only in constraints.
You are given a rectangular $$$n \times m$$$ matrix $$$a$$$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want (possibly zero). You can perform this operation to a column multiple times.
After you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $$$i$$$-th row it is equal $$$r_i$$$. What is the maximal possible value of $$$r_1+r_2+\ldots+r_n$$$?
The first line contains an integer $$$t$$$ ($$$1 \le t \le 40$$$), the number of test cases in the input.
The first line of each test case contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 4$$$, $$$1 \le m \le 100$$$) — the number of rows and the number of columns in the given matrix $$$a$$$. 
Each of the following $$$n$$$ lines contains $$$m$$$ integers, the elements of $$$a$$$ ($$$1 \le a_{i, j} \le 10^5$$$).
Print $$$t$$$ integers: answers for all test cases in the order they are given in the input.
","input
In the first test case, you can shift the third column down by one, this way there will be $$$r_1 = 5$$$ and $$$r_2 = 7$$$.
output
In the second case you can don't rotate anything at all, this way there will be $$$r_1 = r_2 = 10$$$ and $$$r_3 = 9$$$.
","bitmasks, bruteforce, dp, greedy, sortings",7
"# import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""ot.out"",""w"")

A,B=map(int,input().split())
x,y,z=map(int,input().split())
summ=0
y1=0
b1=0
y1=(x*2)+y

b1=y+(3*z)

summ=0
if y1>A:
	summ+=y1-A
if b1>B:
	summ+=b1-B
print(summ)",0912_A,CODEFORCES,205,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation,1
"s = input()

def palindrome(s):
    i=0
    j=len(s)-1
    p=True
    while i<=j:
        if s[i]!=s[j]:
            p=False
            break
        i+=1
        j-=1
    return p

ans=0
for i in range(len(s)):
    for j in range(len(s)-1, i,-1):
        if not palindrome(s[i:j+1]):
            ans=max(ans, len(s[i:j+1]))
            break

print(ans)






",0981_A,CODEFORCES,1672,Antipalindrome,"A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.
A substring $$$s[l \ldots r]$$$ ($$$1 \leq l \leq r \leq |s|$$$) of a string $$$s = s_{1}s_{2} \ldots s_{|s|}$$$ is the string $$$s_{l}s_{l + 1} \ldots s_{r}$$$.
Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $$$s$$$ is changed into its longest substring that is not a palindrome. If all the substrings of $$$s$$$ are palindromes, she skips the word at all.
Some time ago Ann read the word $$$s$$$. What is the word she changed it into?
The first line contains a non-empty string $$$s$$$ with length at most $$$50$$$ characters, containing lowercase English letters only.
If there is such a substring in $$$s$$$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $$$0$$$.
Note that there can be multiple longest substrings that are not palindromes, but their length is unique.
""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $$$3$$$.
","input
The string ""uffuw"" is one of the longest non-palindrome substrings (of length $$$5$$$) of the string ""wuffuw"", so the answer for the second example is $$$5$$$.
output
All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $$$0$$$.
","bruteforce, implementation, strings",3
"import sys
 
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
def li(): return [int(i) for i in input().split()]
def lli(rows): return [li() for _ in range(rows)]
def si(): return input()
def ii(): return int(input())
def ins(): return input().split()


n,m=MI()
posf=(n*(n-1))//2
if(n%2!=0):
    negf=(n//2)*(n//2+1)
else:
    negf=(n//2)*(n//2-1)+n//2
ans=0
for i in range(m):
    x,d=MI()
    ans+=n*x
    if(d>=0):
        ans+=posf*d
    else:
        ans+=negf*d
print(ans/n)",1009_C,CODEFORCES,1798,Annoying Present,"Alice got an array of length $$$n$$$ as a birthday present once again! This is the third year in a row! 
And what is more disappointing, it is overwhelmengly boring, filled entirely with zeros. Bob decided to apply some changes to the array to cheer up Alice.
Bob has chosen $$$m$$$ changes of the following form. For some integer numbers $$$x$$$ and $$$d$$$, he chooses an arbitrary position $$$i$$$ ($$$1 \le i \le n$$$) and for every $$$j \in [1, n]$$$ adds $$$x + d \cdot dist(i, j)$$$ to the value of the $$$j$$$-th cell. $$$dist(i, j)$$$ is the distance between positions $$$i$$$ and $$$j$$$ (i.e. $$$dist(i, j) = |i - j|$$$, where $$$|x|$$$ is an absolute value of $$$x$$$).
For example, if Alice currently has an array $$$[2, 1, 2, 2]$$$ and Bob chooses position $$$3$$$ for $$$x = -1$$$ and $$$d = 2$$$ then the array will become $$$[2 - 1 + 2 \cdot 2,~1 - 1 + 2 \cdot 1,~2 - 1 + 2 \cdot 0,~2 - 1 + 2 \cdot 1]$$$ = $$$[5, 2, 1, 3]$$$. Note that Bob can't choose position $$$i$$$ outside of the array (that is, smaller than $$$1$$$ or greater than $$$n$$$).
Alice will be the happiest when the elements of the array are as big as possible. Bob claimed that the arithmetic mean value of the elements will work fine as a metric.
What is the maximum arithmetic mean value Bob can achieve?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 10^5$$$) — the number of elements of the array and the number of changes.
Each of the next $$$m$$$ lines contains two integers $$$x_i$$$ and $$$d_i$$$ ($$$-10^3 \le x_i, d_i \le 10^3$$$) — the parameters for the $$$i$$$-th change.
","input
Print the maximal average arithmetic mean of the elements Bob can achieve.
output
Your answer is considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$.
","greedy, math",3
"import sys
import heapq
input = sys.stdin.readline
n = int(input())
w = [int(z) for z in input().split()]; s = input()

idx = []
for i in range(n):
    idx.append((w[i], i+1))

idx.sort()
heapq.heapify(idx)
ones = []
heapq.heapify(ones)
res = []
for i in range(2*n):
    if s[i] == '0':
        l = idx[0]
        heapq.heappop(idx)
        res.append(l[1])
        heapq.heappush(ones, [-l[0], l[1]])
    else:
        l = ones[0]
        heapq.heappop(ones)
        res.append(l[1])
res = ' '.join([str(i) for i in res])
sys.stdout.write(res)",0982_B,CODEFORCES,2555,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation",4
"'''input
3 2
1 2 1
3 4
'''
from sys import stdin, setrecursionlimit
from bisect import bisect_right

setrecursionlimit(15000)


def get_gdict(arr):
	gdict = dict()
	for i in range(len(arr)):
		if arr[i] in gdict:
			gdict[arr[i]] += 1
		else:
			gdict[arr[i]] = 1
	return gdict


def initial_check(barr, garr):
	for i in garr:
		if i < barr[-1]:
			return False
	return True


# main starts
n, m = list(map(int, stdin.readline().split()))
barr = list(map(int, stdin.readline().split()))
garr = list(map(int, stdin.readline().split()))
barr.sort()
garr.sort()
ans = 0
gdict = get_gdict(garr)
if initial_check(barr, garr):
	count  = m
	b = n - 1
	g = m - 1
	while count  > 0:
		tempb = [barr[b]] * (m)
		
		for i in range(len(tempb)):
			if count <= 0:
				for j in range(i, m):
					ans += tempb[b]
				break

			if tempb[i] in gdict:
				gdict[tempb[i]] -= 1
				ans += (tempb[i])
				count -= 1
				if gdict[tempb[i]] == 0:
					del gdict[tempb[i]]
			else:
				if i == 0:	
					ans += (tempb[i])
					continue
				for k in range(g, -1, -1):
					if garr[k] in gdict:
						ans += garr[g]
						g = k - 1
						count -= 1
						break
				
				
		b -= 1

	while b >= 0:
		ans += m * (barr[b])
		b -= 1
	print(ans)

else:
	print(-1)",1159_C,CODEFORCES,3795,The Party and Sweets,"$$$n$$$ boys and $$$m$$$ girls came to the party. Each boy presented each girl some integer number of sweets (possibly zero). All boys are numbered with integers from $$$1$$$ to $$$n$$$ and all girls are numbered with integers from $$$1$$$ to $$$m$$$. For all $$$1 \leq i \leq n$$$ the minimal number of sweets, which $$$i$$$-th boy presented to some girl is equal to $$$b_i$$$ and for all $$$1 \leq j \leq m$$$ the maximal number of sweets, which $$$j$$$-th girl received from some boy is equal to $$$g_j$$$.
More formally, let $$$a_{i,j}$$$ be the number of sweets which the $$$i$$$-th boy give to the $$$j$$$-th girl. Then $$$b_i$$$ is equal exactly to the minimum among values $$$a_{i,1}, a_{i,2}, \ldots, a_{i,m}$$$ and $$$g_j$$$ is equal exactly to the maximum among values $$$b_{1,j}, b_{2,j}, \ldots, b_{n,j}$$$.
You are interested in the minimum total number of sweets that boys could present, so you need to minimize the sum of $$$a_{i,j}$$$ for all $$$(i,j)$$$ such that $$$1 \leq i \leq n$$$ and $$$1 \leq j \leq m$$$. You are given the numbers $$$b_1, \ldots, b_n$$$ and $$$g_1, \ldots, g_m$$$, determine this number. 
The first line contains two integers $$$n$$$ and $$$m$$$, separated with space — the number of boys and girls, respectively ($$$2 \leq n, m \leq 100\,000$$$). The second line contains $$$n$$$ integers $$$b_1, \ldots, b_n$$$, separated by spaces — $$$b_i$$$ is equal to the minimal number of sweets, which $$$i$$$-th boy presented to some girl ($$$0 \leq b_i \leq 10^8$$$). The third line contains $$$m$$$ integers $$$g_1, \ldots, g_m$$$, separated by spaces — $$$g_j$$$ is equal to the maximal number of sweets, which $$$j$$$-th girl received from some boy ($$$0 \leq g_j \leq 10^8$$$).
If the described situation is impossible, print $$$-1$$$. In another case, print the minimal total number of sweets, which boys could have presented and all conditions could have satisfied.
In the first test, the minimal total number of sweets, which boys could have presented is equal to $$$12$$$. This can be possible, for example, if the first boy presented $$$1$$$ and $$$4$$$ sweets, the second boy presented $$$3$$$ and $$$2$$$ sweets and the third boy presented $$$1$$$ and $$$1$$$ sweets for the first and the second girl, respectively. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$12$$$.
","input
In the second test, the boys couldn't have presented sweets in such way, that all statements satisfied.
output
In the third test, the minimal total number of sweets, which boys could have presented is equal to $$$4$$$. This can be possible, for example, if the first boy presented $$$1$$$, $$$1$$$, $$$2$$$ sweets for the first, second, third girl, respectively and the second boy didn't present sweets for each girl. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $$$4$$$.
","greedy, implementation, math",6
"import sys

f = sys.stdin

def line():
    return f.readline().strip().split()

def powers(limit):
    size = limit+1
    p = [1]*size
    for n in range(1,size):
        p[n] = (2*p[n-1]) % M
        
    return p

def binomials(limit):
    size = limit+1
    bc = [[0 for k in range(size)] for n in range(size)]
    for n in range(size):
        bc[n][0]=1
    
    for n in range(1,size):
        for k in range(1,n+1):
            bc[n][k] = bc[n-1][k-1] + bc[n-1][k]
            bc[n][k] %= M
    
    return bc

def solve():
    
#     dp = [[0 for _ in range(N)] for _ in range(N)]
#     dp[0][0]=1
#     
#     for i in range(1,N):
#         for k in range(1,i):
#             for j in range(1,i):
#                 dp[i][j] += BC[j+1][i-k] * dp[k-1][j-1-(i-k-1)] * POW[i-k-1]
#                 dp[i][j] %= M
#         dp[i][i] = POW[i]

    size = N+1
    dp = [[0 for _ in range(size)] for _ in range(size)]
    dp[1][0]=1
    
    for i in range(2,size):
        for k in range(1,i):
            for j in range(1,k):
                dp[i][j] += BC[i-j][k-j] * dp[k-1][j-1] * POW[i-k-1]
                dp[i][j] %= M
        dp[i][0] = POW[i-1]

    res=0
    for j in range(0,N-1):
        res = (res + dp[N][j]) % M

    return str(res)

T = 1
for test in range(1,T+1):
    N,M = map(int,line())
    
    BC = binomials(N)
    POW = powers(N)
    
    print(solve())
    
f.close()",1515_E,CODEFORCES,4057,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"N, MOD = map(int, input().split())
dp = [[0]*(N+2) for i in range(N+2)]
dp[0][0] = 1
limit = 1000
frac = [1]*limit
for i in range(2,limit):
    frac[i] = i * frac[i-1]%MOD
fraci = [None]*limit
fraci[-1] = pow(frac[-1], MOD -2, MOD)
for i in range(-2, -limit-1, -1):
    fraci[i] = fraci[i+1] * (limit + i + 1) % MOD
bb = [1, 2]
for i in range(1000):
    bb.append(bb[-1] *2 %MOD)
for ln in range(N+1):
    for cnt in range(ln//2, ln+1):
        for k in range(1, N-ln+1):
            cmb = frac[cnt+k] * (fraci[cnt]*fraci[k]%MOD)%MOD
            dp[ln+k+1][cnt+k] += dp[ln][cnt] * (bb[k-1] * cmb % MOD) %MOD
            dp[ln+k+1][cnt+k] %= MOD
R = 0
for x in dp[N+1][:N+1]:
    R = (R+x)%MOD
print(R)
",1515_E,CODEFORCES,4055,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"n=int(input())
a,b=map(int,input().split())
white=abs(a-1)+abs(b-1)
black=abs(n-a)+abs(n-b)
if white<=black:
    print(""White"")
else:
    print(""Black"")",1075_A,CODEFORCES,553,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"def read():
    return [c == '1' for c in input()]
n = int(input())
a, b = read(), read()

res = 0

i = 0
while i + 1 < n:
    if a[i] != b[i] and a[i] != a[i+1] and b[i] != b[i+1]:
        a[i] = b[i]
        a[i+1] = b[i+1]
        res += 1
        i += 2
    else:
        i += 1

for i in range(n):
    if a[i] != b[i]:
        res += 1

print(res)",1037_C,CODEFORCES,1918,Equalize,"You are given two binary strings $$$a$$$ and $$$b$$$ of the same length. You can perform the following two operations on the string $$$a$$$:
Find the minimum cost to make the string $$$a$$$ equal to $$$b$$$. It is not allowed to modify string $$$b$$$.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^6$$$) — the length of the strings $$$a$$$ and $$$b$$$.
The second and third lines contain strings $$$a$$$ and $$$b$$$ respectively.
Both strings $$$a$$$ and $$$b$$$ have length $$$n$$$ and contain only '0' and '1'.
Output the minimum cost to make the string $$$a$$$ equal to $$$b$$$.
In the first example, one of the optimal solutions is to flip index $$$1$$$ and index $$$3$$$, the string $$$a$$$ changes in the following way: ""100"" $$$\to$$$ ""000"" $$$\to$$$ ""001"". The cost is $$$1 + 1 = 2$$$.
","input
The other optimal solution is to swap bits and indices $$$1$$$ and $$$3$$$, the string $$$a$$$ changes then ""100"" $$$\to$$$ ""001"", the cost is also $$$|1 - 3| = 2$$$.
output
In the second example, the optimal solution is to swap bits at indices $$$2$$$ and $$$3$$$, the string $$$a$$$ changes as ""0101"" $$$\to$$$ ""0011"". The cost is $$$|2 - 3| = 1$$$.
","dp, greedy, strings",3
"n, m = map(int, input().split())
tc = [0]*m
ps = []
for _ in range(n):
    temp = input()
    psa = [0]*m
    for i in range(m):
        if temp[i] == '1':
            psa[i] += 1
            tc[i] += 1
    ps.append(psa)
ans = 'NO'

for i in ps:
    c = 0
    for j in range(m):
        if tc[j]-i[j] > 0:
            c += 1
    if c == m:
        ans = 'YES'
        break

print(ans)
",0985_B,CODEFORCES,3249,Switches and Lamps,"You are given n switches and m lamps. The i-th switch turns on some subset of the lamps. This information is given as the matrix a consisting of n rows and m columns where ai, j = 1 if the i-th switch turns on the j-th lamp and ai, j = 0 if the i-th switch is not connected to the j-th lamp.
Initially all m lamps are turned off.
Switches change state only from ""off"" to ""on"". It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards.
It is guaranteed that if you push all n switches then all m lamps will be turned on.
Your think that you have too many switches and you would like to ignore one of them. 
Your task is to say if there exists such a switch that if you will ignore (not use) it but press all the other n - 1 switches then all the m lamps will be turned on.
The first line of the input contains two integers n and m (1 ≤ n, m ≤ 2000) — the number of the switches and the number of the lamps.
The following n lines contain m characters each. The character ai, j is equal to '1' if the i-th switch turns on the j-th lamp and '0' otherwise.
","input
It is guaranteed that if you press all n switches all m lamps will be turned on.
output
Print ""YES"" if there is a switch that if you will ignore it and press all the other n - 1 switches then all m lamps will be turned on. Print ""NO"" if there is no such switch.
",implementation,5
"import os, sys
from io import BytesIO, IOBase


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0.0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [tuple([i] + inp(dtype)) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
get_bit = lambda x, i: (x >> i) & 1

n = int(input())
a, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1

if n == 1:
    exit(print(1))

for i in range(n):
    for j in range(i + 1, n):
        masks[big ^ (1 << j)] += a[i][j]
        masks[big ^ (1 << i)] += a[j][i]

for _ in range(2, n):
    tem = dict()
    for msk in masks:
        for bit in range(18):
            if get_bit(msk, bit):
                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]
    masks = tem

su = sum(masks.values())
print(*[masks[1 << i] / su for i in range(n)])
",0016_E,CODEFORCES,4282,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"val=10**9
n,m=map(int,input().split())
arr1=[]
for i in range(n):
    x=int(input())
    arr1.append(x)
arr1.append(val)
arr2=[]
ans=val
finalval=0
arr1.sort()
for i in range(m):
    x1,x2,y=map(int,input().split())
    if(x1==1):
        if(x2==val):
            finalval+=1
        else:
            if(len(arr1)>0 and x2>=arr1[0]):
                arr2.append(x2)
arr2.sort()
i=0
j=0
while(i<len(arr1) and j<len(arr2)):
    if(arr1[i]>arr2[j]):
        j+=1
    elif(arr1[i]==arr2[j]):
        temp1=len(arr2)-j
        #print(temp1,'1')
        ans=min(i+temp1,ans)
        i+=1
    else:
        temp1=len(arr2)-j
        #print(temp1,'2')
        ans=min(i+temp1,ans)
        i+=1
    #print(ans+finalval)
ans=min(i,ans)
print(ans+finalval)



",1075_C,CODEFORCES,2886,The Tower is Going Home,"On a chessboard with a width of $$$10^9$$$ and a height of $$$10^9$$$, the rows are numbered from bottom to top from $$$1$$$ to $$$10^9$$$, and the columns are numbered from left to right from $$$1$$$ to $$$10^9$$$. Therefore, for each cell of the chessboard you can assign the coordinates $$$(x,y)$$$, where $$$x$$$ is the column number and $$$y$$$ is the row number.
Every day there are fights between black and white pieces on this board. Today, the black ones won, but at what price? Only the rook survived, and it was driven into the lower left corner — a cell with coordinates $$$(1,1)$$$. But it is still happy, because the victory has been won and it's time to celebrate it! In order to do this, the rook needs to go home, namely — on the upper side of the field (that is, in any cell that is in the row with number $$$10^9$$$).
Everything would have been fine, but the treacherous white figures put spells on some places of the field before the end of the game. There are two types of spells: 
Let's recall that the rook is a chess piece that in one move can move to any point that is in the same row or column with its initial position. In our task, the rook can move from the cell $$$(r_0,c_0)$$$ into the cell $$$(r_1,c_1)$$$ only under the condition that $$$r_1 = r_0$$$ or $$$c_1 = c_0$$$ and there is no blocking lines or blocking segments between these cells (For better understanding, look at the samples).
Fortunately, the rook can remove spells, but for this it has to put tremendous efforts, therefore, it wants to remove the minimum possible number of spells in such way, that after this it can return home. Find this number!
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$0 \le n,m \le 10^5$$$) — the number of vertical and horizontal spells.
Each of the following $$$n$$$ lines contains one integer $$$x$$$ ($$$1 \le x < 10^9$$$) — the description of the vertical spell. It will create a blocking line between the columns of $$$x$$$ and $$$x+1$$$.
Each of the following $$$m$$$ lines contains three integers $$$x_1$$$, $$$x_2$$$ and $$$y$$$ ($$$1 \le x_{1} \le x_{2} \le 10^9$$$, $$$1 \le y < 10^9$$$) — the numbers that describe the horizontal spell. It will create a blocking segment that passes through the top sides of the cells that are in the row with the number $$$y$$$, in columns from $$$x_1$$$ to $$$x_2$$$ inclusive.
It is guaranteed that all spells are different, as well as the fact that for each pair of horizontal spells it is true that the segments that describe them do not have common points.
In a single line print one integer — the minimum number of spells the rook needs to remove so it can get from the cell $$$(1,1)$$$ to at least one cell in the row with the number $$$10^9$$$
In the first sample, in order for the rook return home, it is enough to remove the second horizontal spell.
In the second sample, in order for the rook to return home, it is enough to remove the only vertical spell. If we tried to remove just one of the horizontal spells, it would not allow the rook to get home, because it would be blocked from above by one of the remaining horizontal spells (either first one or second one), and to the right it would be blocked by a vertical spell.
In the third sample, we have two horizontal spells that go through the whole field. These spells can not be bypassed, so we need to remove both of them.
","input
In the fourth sample, we have no spells, which means that we do not need to remove anything.
output
In the fifth example, we can remove the first vertical and third horizontal spells.
",twopointers,4
"from math import inf
n, m, k = map(int, input().split())
horizontal = []
vertical = []
for _ in range(n):
    horizontal.append(list(map(int, input().split())))
for _ in range(n - 1):
    vertical.append(list(map(int, input().split())))
if k & 1:
    ans = [""-1""] * m
    for _ in range(n):
        print(*ans)
else:
    grid = [[0 for i in range(m)] for j in range(n)]
    for _ in range(k // 2):
        X = [[inf for i in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                if i >= 1:
                    X[i][j] = min(2 * vertical[i - 1][j] + grid[i - 1][j], X[i][j])
                if i < n - 1:
                    X[i][j] = min(2 * vertical[i][j] + grid[i + 1][j], X[i][j])
                if j >= 1:
                    X[i][j] = min(2 * horizontal[i][j - 1] + grid[i][j - 1], X[i][j])
                if j < m - 1:
                    X[i][j] = min(2 * horizontal[i][j] + grid[i][j + 1], X[i][j])
        #print(X)
        grid = X[:]
    for _ in range(n):
        print(*grid[_])
",1517_D,CODEFORCES,4159,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"n = int(input())

dp = [0] * 1000007

majak = [0] * 1000007



q = 1000007

p = 0

for i in range(n):

    a, b = map(int, input().split())

    q = min(q, a)

    majak[a] = b



dp[q] = 1

ma = 1

for i in range(q + 1, 1000003, 1):

    if(majak[i] == 0):

        dp[i] = dp[i - 1]

    else:

        dp[i] = dp[i - majak[i] - 1] + 1

        ma = max(ma, dp[i])



print(n - ma)



# Made By Mostafa_Khaled",0608_C,CODEFORCES,1507,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp,3
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    a.sort()
    if a[-2]>n-2:
        print(n-2)
    else:
        print(a[-2]-1)",1197_A,CODEFORCES,3007,DIY Wooden Ladder,"Let's denote a $$$k$$$-step ladder as the following structure: exactly $$$k + 2$$$ wooden planks, of which
Note that neither the base planks, nor the steps planks are required to be equal.
For example, ladders $$$1$$$ and $$$3$$$ are correct $$$2$$$-step ladders and ladder $$$2$$$ is a correct $$$1$$$-step ladder. On the first picture the lengths of planks are $$$[3, 3]$$$ for the base and $$$[1]$$$ for the step. On the second picture lengths are $$$[3, 3]$$$ for the base and $$$[2]$$$ for the step. On the third picture lengths are $$$[3, 4]$$$ for the base and $$$[2, 3]$$$ for the steps. 
You have $$$n$$$ planks. The length of the $$$i$$$-th planks is $$$a_i$$$. You don't have a saw, so you can't cut the planks you have. Though you have a hammer and nails, so you can assemble the improvised ""ladder"" from the planks.
The question is: what is the maximum number $$$k$$$ such that you can choose some subset of the given planks and assemble a $$$k$$$-step ladder using them?
The first line contains a single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of queries. The queries are independent.
Each query consists of two lines. The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^5$$$) — the number of planks you have.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^5$$$) — the lengths of the corresponding planks.
It's guaranteed that the total number of planks from all queries doesn't exceed $$$10^5$$$.
Print $$$T$$$ integers — one per query. The $$$i$$$-th integer is the maximum number $$$k$$$, such that you can choose some subset of the planks given in the $$$i$$$-th query and assemble a $$$k$$$-step ladder using them.
Print $$$0$$$ if you can't make even $$$1$$$-step ladder from the given set of planks.
","input
Examples for the queries $$$1-3$$$ are shown at the image in the legend section.
output
The Russian meme to express the quality of the ladders:
","greedy, math, sortings",4
"def inp1():
    return int(input())
def inp2():
    return list(map(int,input().split()))
def inp3():
    return map(int,input().split())
if 1:
#for _ range(int(input(()))):
    n=inp1()
    x=int(n**0.5)
    i=0
    y=n
    ans=[]
    while(i<n):
          arr=[]
          for j in range(x):
              if y==0:
                  break
              arr.append(y)
              y-=1
              i+=1
              if y==0:
                  break
          arr=arr[::-1]
          for j in arr:
              ans.append(j)
    print(*ans)
",1017_C,CODEFORCES,1853,The Phone Number,"Mrs. Smith is trying to contact her husband, John Smith, but she forgot the secret phone number!
The only thing Mrs. Smith remembered was that any permutation of $$$n$$$ can be a secret phone number. Only those permutations that minimize secret value might be the phone of her husband.
The sequence of $$$n$$$ integers is called a permutation if it contains all integers from $$$1$$$ to $$$n$$$ exactly once.
The secret value of a phone number is defined as the sum of the length of the longest increasing subsequence (LIS) and length of the longest decreasing subsequence (LDS). 
A subsequence $$$a_{i_1}, a_{i_2}, \ldots, a_{i_k}$$$ where $$$1\leq i_1 < i_2 < \ldots < i_k\leq n$$$ is called increasing if $$$a_{i_1} < a_{i_2} < a_{i_3} < \ldots < a_{i_k}$$$. If $$$a_{i_1} > a_{i_2} > a_{i_3} > \ldots > a_{i_k}$$$, a subsequence is called decreasing. An increasing/decreasing subsequence is called longest if it has maximum length among all increasing/decreasing subsequences.
For example, if there is a permutation $$$[6, 4, 1, 7, 2, 3, 5]$$$, LIS of this permutation will be $$$[1, 2, 3, 5]$$$, so the length of LIS is equal to $$$4$$$. LDS can be $$$[6, 4, 1]$$$, $$$[6, 4, 2]$$$, or $$$[6, 4, 3]$$$, so the length of LDS is $$$3$$$.
Note, the lengths of LIS and LDS can be different.
So please help Mrs. Smith to find a permutation that gives a minimum sum of lengths of LIS and LDS.
The only line contains one integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the length of permutation that you need to build.
Print a permutation that gives a minimum sum of lengths of LIS and LDS. 
If there are multiple answers, print any.
","input
In the first sample, you can build a permutation $$$[3, 4, 1, 2]$$$. LIS is $$$[3, 4]$$$ (or $$$[1, 2]$$$), so the length of LIS is equal to $$$2$$$. LDS can be ony of $$$[3, 1]$$$, $$$[4, 2]$$$, $$$[3, 2]$$$, or $$$[4, 1]$$$. The length of LDS is also equal to $$$2$$$. The sum is equal to $$$4$$$. Note that $$$[3, 4, 1, 2]$$$ is not the only permutation that is valid.
output
In the second sample, you can build a permutation $$$[2, 1]$$$. LIS is $$$[1]$$$ (or $$$[2]$$$), so the length of LIS is equal to $$$1$$$. LDS is $$$[2, 1]$$$, so the length of LDS is equal to $$$2$$$. The sum is equal to $$$3$$$. Note that permutation $$$[1, 2]$$$ is also valid.
","constructivealgorithms, greedy",3
"n,q = map(int, raw_input().split())
nums = list(map(int, raw_input().split()))
""""""
algo:
store the combos until the maximum element reaches the front of the deque
then the order of the rest of the deque only changes by 2nd element going to end
so let cutoff = number of operation which causes the max element to reach front
if mj <= cutoff then output mjth combo stored
if mj > cutoff  then output = (max, (mj-cutoff-1)%(len-1)+1)
""""""

m = max(nums)#max element
# print(nums)
# print(m)
ab = []
while nums[0] < m:
    ab.append([nums[0], nums[1]])
    nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0))
# print(ab)

for i in range(q):
    mj = int(input())
    a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1]))
    print(a + "" "" + b)
",1179_A,CODEFORCES,2143,Valeriy and Deque,"Recently, on the course of algorithms and data structures, Valeriy learned how to use a deque. He built a deque filled with $$$n$$$ elements. The $$$i$$$-th element is $$$a_i$$$ ($$$i$$$ = $$$1, 2, \ldots, n$$$). He gradually takes the first two leftmost elements from the deque (let's call them $$$A$$$ and $$$B$$$, respectively), and then does the following: if $$$A > B$$$, he writes $$$A$$$ to the beginning and writes $$$B$$$ to the end of the deque, otherwise, he writes to the beginning $$$B$$$, and $$$A$$$ writes to the end of the deque. We call this sequence of actions an operation.
For example, if deque was $$$[2, 3, 4, 5, 1]$$$, on the operation he will write $$$B=3$$$ to the beginning and $$$A=2$$$ to the end, so he will get $$$[3, 4, 5, 1, 2]$$$.
The teacher of the course, seeing Valeriy, who was passionate about his work, approached him and gave him $$$q$$$ queries. Each query consists of the singular number $$$m_j$$$ $$$(j = 1, 2, \ldots, q)$$$. It is required for each query to answer which two elements he will pull out on the $$$m_j$$$-th operation.
Note that the queries are independent and for each query the numbers $$$A$$$ and $$$B$$$ should be printed in the order in which they will be pulled out of the deque.
Deque is a data structure representing a list of elements where insertion of new elements or deletion of existing elements can be made from both sides.
The first line contains two integers $$$n$$$ and $$$q$$$ ($$$2 \leq n \leq 10^5$$$, $$$0 \leq q \leq 3 \cdot 10^5$$$) — the number of elements in the deque and the number of queries. The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$, where $$$a_i$$$ $$$(0 \leq a_i \leq 10^9)$$$ — the deque element in $$$i$$$-th position. The next $$$q$$$ lines contain one number each, meaning $$$m_j$$$ ($$$1 \leq m_j \leq 10^{18}$$$).
For each teacher's query, output two numbers $$$A$$$ and $$$B$$$ — the numbers that Valeriy pulls out of the deque for the $$$m_j$$$-th operation.
","input
So, $$$2$$$ we write to the beginning of the deque, and $$$1$$$ — to the end.
output
We get the following status of the deque: $$$[2, 3, 4, 5, 1]$$$.
","datastructures, implementation",3
"import itertools

n = int(input())
a = []
for i in range(4):
    a.append([input() for _ in range(n)])
    if i < 3:
        assert input() == ''

best = 4*n*n
for p in itertools.permutations(a):
    for s in range(2):
        count = 0
        for i in range(4):
            for r in range(n):
                for c in range(n):
                    if p[i][r][c] != str((s + (i//2 + r) + (i % 2 + c)) % 2):
                        count += 1
        best = min(best, count)
print(best)
",0961_C,CODEFORCES,3167,Chessboard,"Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into 4 pieces, each of size n by n, n is always odd. And what's even worse, some squares were of wrong color. j-th square of the i-th row of k-th piece of the board has color ak, i, j; 1 being black and 0 being white. 
Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be 2n by 2n. You are allowed to move pieces but not allowed to rotate or flip them.
The first line contains odd integer n (1 ≤ n ≤ 100) — the size of all pieces of the board. 
","input
Then 4 segments follow, each describes one piece of the board. Each consists of n lines of n characters; j-th one of i-th line is equal to 1 if the square is black initially and 0 otherwise. Segments are separated by an empty line.
output
Print one number — minimum number of squares Magnus should recolor to be able to obtain a valid chessboard.
","bitmasks, bruteforce, implementation",5
"import sys
input = sys.stdin.readline
q = int(input())
for i in range(q):
    n, k = map(int, input().split())
    s = input()
    R, G, B = 0, 0, 0
    ans = float('inf')
    for j in range(n):
        if j % 3 == 0:
            if s[j] == 'R':
                G += 1
                B += 1
            elif s[j] == 'G':
                R += 1
                B += 1
            else:
                R += 1
                G += 1
        elif j % 3 == 1:
            if s[j] == 'R':
                G += 1
                R += 1
            elif s[j] == 'G':
                G += 1
                B += 1
            else:
                R += 1
                B += 1
        else:
            if s[j] == 'R':
                R += 1
                B += 1
            elif s[j] == 'G':
                R += 1
                G += 1
            else:
                G += 1
                B += 1
        if j >= k - 1:
            ans = min(ans, R, G, B)
            if (j - k + 1) % 3 == 0:
                if s[j - k + 1] == 'R':
                    G -= 1
                    B -= 1
                elif s[j - k + 1] == 'G':
                    R -= 1
                    B -= 1
                else:
                    R -= 1
                    G -= 1
            elif (j - k + 1) % 3 == 1:
                if s[j - k + 1] == 'R':
                    G -= 1
                    R -= 1
                elif s[j - k + 1] == 'G':
                    G -= 1
                    B -= 1
                else:
                    R -= 1
                    B -= 1
            else:
                if s[j - k + 1] == 'R':
                    R -= 1
                    B -= 1
                elif s[j - k + 1] == 'G':
                    R -= 1
                    G -= 1
                else:
                    G -= 1
                    B -= 1

    print(ans)",1196_D1,CODEFORCES,2238,RGB Substring (easy version),"The only difference between easy and hard versions is the size of the input.
You are given a string $$$s$$$ consisting of $$$n$$$ characters, each character is 'R', 'G' or 'B'.
You are also given an integer $$$k$$$. Your task is to change the minimum number of characters in the initial string $$$s$$$ so that after the changes there will be a string of length $$$k$$$ that is a substring of $$$s$$$, and is also a substring of the infinite string ""RGBRGBRGB ..."".
A string $$$a$$$ is a substring of string $$$b$$$ if there exists a positive integer $$$i$$$ such that $$$a_1 = b_i$$$, $$$a_2 = b_{i + 1}$$$, $$$a_3 = b_{i + 2}$$$, ..., $$$a_{|a|} = b_{i + |a| - 1}$$$. For example, strings ""GBRG"", ""B"", ""BR"" are substrings of the infinite string ""RGBRGBRGB ..."" while ""GR"", ""RGR"" and ""GGG"" are not.
You have to answer $$$q$$$ independent queries.
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 2000$$$) — the number of queries. Then $$$q$$$ queries follow.
The first line of the query contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 2000$$$) — the length of the string $$$s$$$ and the length of the substring.
The second line of the query contains a string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B'.
It is guaranteed that the sum of $$$n$$$ over all queries does not exceed $$$2000$$$ ($$$\sum n \le 2000$$$).
For each query print one integer — the minimum number of characters you need to change in the initial string $$$s$$$ so that after changing there will be a substring of length $$$k$$$ in $$$s$$$ that is also a substring of the infinite string ""RGBRGBRGB ..."".
","input
In the first example, you can change the first character to 'R' and obtain the substring ""RG"", or change the second character to 'R' and obtain ""BR"", or change the third, fourth or fifth character to 'B' and obtain ""GB"".
output
In the second example, the substring is ""BRG"".
",implementation,3
"import sys
input = lambda : sys.stdin.readline().rstrip()


sys.setrecursionlimit(2*10**5+10)
write = lambda x: sys.stdout.write(x+""\n"")
debug = lambda x: sys.stderr.write(x+""\n"")
writef = lambda x: print(""{:.12f}"".format(x))


# zeta mebius
def zeta_super(val, n):
    # len(val)==2^n
    out = val[:]
    for i in range(n):
        for j in range(1<<n):
            if not j>>i&1:
                out[j] += out[j^(1<<i)]
    return out

n = int(input())
a = list(map(int, input().split()))
m = max(a).bit_length()
M = 10**9+7
v = [0]*(1<<m)
for item in a:
    v[item] += 1
v2 = [1]
for i in range(n+1):
    v2.append(v2[-1]*2%M)
nv = zeta_super(v, m)
ans = 0
for b in range(1<<m):
    ans += (v2[nv[b]]-1)*pow(-1, bin(b).count(""1""))
    ans %= M
print(ans%M)",0449_D,CODEFORCES,4296,Jzzhu and Numbers,"Jzzhu have n non-negative integers a1, a2, ..., an. We will call a sequence of indexes i1, i2, ..., ik (1 ≤ i1 < i2 < ... < ik ≤ n) a group of size k. 
Jzzhu wonders, how many groups exists such that ai1 & ai2 & ... & aik = 0 (1 ≤ k ≤ n)? Help him and print this number modulo 1000000007 (109 + 7). Operation x & y denotes bitwise AND operation of two numbers.
","input
The first line contains a single integer n (1 ≤ n ≤ 106). The second line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 106).
output
Output a single integer representing the number of required groups modulo 1000000007 (109 + 7).
","bitmasks, combinatorics, dp",7
"
l,r = list(map(int,input().split()))
f = 0
def gcd(a,b):
    if b == 0:
        return a
    return gcd(b,a%b)
for a in range(l,r+1):
    for b in range(a+1,r+1):
        for c in range(b+1,r+1):
        
           if (gcd(a,b) == 1) and (gcd(b,c) == 1) and (gcd(a,c)!=1):
                print(a,b,c)
                f = 1
                break
        if f == 1:
            break
    if f == 1:
        break
else:
    print(-1)

        
    
    
",0483_A,CODEFORCES,160,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"
from sys import stdin,stdout,setrecursionlimit
stdin.readline
def mp(): return list(map(int, stdin.readline().strip().split()))
def it():return int(stdin.readline().strip())
from collections import defaultdict as dd,Counter as C,deque
from math import ceil,gcd,sqrt,factorial,log2,floor	
from bisect import bisect_right as br,bisect_left as bl
import heapq

def solve(a,b):
	if a == 0:
		return 0
	return b//a + solve(b%a,a)
print(solve(*mp()))

",0343_A,CODEFORCES,134,Rational Resistance,"Mad scientist Mike is building a time machine in his spare time. To finish the work, he needs a resistor with a certain resistance value.
However, all Mike has is lots of identical resistors with unit resistance R0 = 1. Elements with other resistance can be constructed from these resistors. In this problem, we will consider the following as elements: 
With the consecutive connection the resistance of the new element equals R = Re + R0. With the parallel connection the resistance of the new element equals . In this case Re equals the resistance of the element being connected.
Mike needs to assemble an element with a resistance equal to the fraction . Determine the smallest possible number of resistors he needs to make such an element.
The single input line contains two space-separated integers a and b (1 ≤ a, b ≤ 1018). It is guaranteed that the fraction  is irreducible. It is guaranteed that a solution always exists.
Print a single number — the answer to the problem.
Please do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.
","input
In the first sample, one resistor is enough.
output
In the second sample one can connect the resistors in parallel, take the resulting element and connect it to a third resistor consecutively. Then, we get an element with resistance . We cannot make this element using two resistors.
","math, numbertheory",1
"n,m=map(int,input().split())
count=[0]*n
a=list(map(int,input().split()))
for i in range(m):
    count[a[i]-1]+=1
print(min(count))",0961_A,CODEFORCES,3159,Tetris,"You are given a following process. 
There is a platform with $$$n$$$ columns. $$$1 \times 1$$$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 
When all of the $$$n$$$ columns have at least one square in them, the bottom row is being removed. You will receive $$$1$$$ point for this, and all the squares left will fall down one row. 
You task is to calculate the amount of points you will receive.
The first line of input contain 2 integer numbers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 1000$$$) — the length of the platform and the number of the squares.
The next line contain $$$m$$$ integer numbers $$$c_1, c_2, \dots, c_m$$$ ($$$1 \le c_i \le n$$$) — column in which $$$i$$$-th square will appear.
Print one integer — the amount of points you will receive.
In the sample case the answer will be equal to $$$2$$$ because after the appearing of $$$6$$$-th square will be removed one row (counts of the squares on the platform will look like $$$[2~ 3~ 1]$$$, and after removing one row will be $$$[1~ 2~ 0]$$$).
","input
After the appearing of $$$9$$$-th square counts will be $$$[2~ 3~ 1]$$$, and after removing one row it will look like $$$[1~ 2~ 0]$$$.
output
So the answer will be equal to $$$2$$$.
",implementation,5
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

# ------------------------------

def main():
    n, k = RLL()
    dp = [[0]*4 for _ in range(k+2)]
    dp[1][0] = 1
    dp[1][3] = 1
    dp[2][1] = 1
    dp[2][2] = 1

    for i in range(2, n+1):
        new = [[0]*4 for _ in range(k+2)]
        for j in range(1, k+2):
            for l in range(4):
                new[j][l] += dp[j][l]
                if l==0 or l==3:
                    new[j][l]+=dp[j-1][l^3]
                    new[j][l]+=(dp[j][1]+dp[j][2])
                elif l==1 or l==2:
                    new[j][l]+=(dp[j-1][0]+dp[j-1][3])
                    if j-2>=0: new[j][l]+=dp[j-2][l^3]
                new[j][l] = new[j][l]%mod
        dp = new
    print(sum(dp[k])%mod)

if __name__ == ""__main__"":
    main()

",1051_D,CODEFORCES,4575,Bicolorings,"You are given a grid, consisting of $$$2$$$ rows and $$$n$$$ columns. Each cell of this grid should be colored either black or white.
Two cells are considered neighbours if they have a common border and share the same color. Two cells $$$A$$$ and $$$B$$$ belong to the same component if they are neighbours, or if there is a neighbour of $$$A$$$ that belongs to the same component with $$$B$$$.
Let's call some bicoloring beautiful if it has exactly $$$k$$$ components.
Count the number of beautiful bicolorings. The number can be big enough, so print the answer modulo $$$998244353$$$.
The only line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 1000$$$, $$$1 \le k \le 2n$$$) — the number of columns in a grid and the number of components required.
","input
Print a single integer — the number of beautiful bicolorings modulo $$$998244353$$$.
output
One of possible bicolorings in sample $$$1$$$:
","bitmasks, dp",7
"import sys
readline = sys.stdin.readline


def gcd(a, b):
    while b:
        a, b = b, a%b
    return a


def prsh(N):
    prime = [2]
    for L in range(3,N):
        for p in prime:
            if not L % p:
                break
            if p > L**(1/2):
                prime.append(L)
                break
    return prime
limit = 59
prime = prsh(limit+1)
C = set([tuple()])
Cp = []
for i in range(2, limit+1):
    if i >= 30 and i in prime:
        Cp.append(i)
        continue
    for k in C.copy():
        if all(gcd(ki, i) == 1 for ki in k):
            kn = tuple(list(k) + [i])
            C.add(kn)

INF = 10**9+7

N = int(readline())
A = list(map(int, readline().split()))
Ao = A[:]
A.sort()
ans = INF
Ans = None
for ci in C:
    tc = [1]*(N-len(ci)) + list(ci) + Cp
    for j in range(8):
        res = 0
        for a, t in zip(A, tc[j:]):
            res += abs(a-t)
        if ans > res:
            ans = res
            Ans = tc[j:j+N]
buc = [[] for _ in range(limit+1)]
for a, an in zip(A, Ans):
    buc[a].append(an)
AA = []
for ao in Ao:
    AA.append(buc[ao].pop())

#print(ans)
print(*AA)",0453_B,CODEFORCES,4298,Little Pony and Harmony Chest,"Princess Twilight went to Celestia and Luna's old castle to research the chest from the Elements of Harmony.
A sequence of positive integers bi is harmony if and only if for every two elements of the sequence their greatest common divisor equals 1. According to an ancient book, the key of the chest is a harmony sequence bi which minimizes the following expression:
You are given sequence ai, help Princess Twilight to find the key.
","input
The first line contains an integer n (1 ≤ n ≤ 100) — the number of elements of the sequences a and b. The next line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 30).
output
Output the key — sequence bi that minimizes the sum described above. If there are multiple optimal sequences, you can output any of them.
","bitmasks, bruteforce, dp",7
"# import os

n = int(input())

gems = {'purple':'Power', 'green':'Time', 'blue': 'Space',
    'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}

gems_in = []
for _ in range(n):
    gems_in.append(input())

print(6-len(gems_in))
r = list(set(gems) - set(gems_in))
for gem in r:
    print(gems[gem])
",0987_A,CODEFORCES,339,Infinity Gauntlet,"You took a peek on Thanos wearing Infinity Gauntlet. In the Gauntlet there is a place for six Infinity Gems:
Using colors of Gems you saw in the Gauntlet determine the names of absent Gems.
In the first line of input there is one integer $$$n$$$ ($$$0 \le n \le 6$$$) — the number of Gems in Infinity Gauntlet.
In next $$$n$$$ lines there are colors of Gems you saw. Words used for colors are: purple, green, blue, orange, red, yellow. It is guaranteed that all the colors are distinct. All colors are given in lowercase English letters.
In the first line output one integer $$$m$$$ ($$$0 \le m \le 6$$$) — the number of absent Gems.
Then in $$$m$$$ lines print the names of absent Gems, each on its own line. Words used for names are: Power, Time, Space, Soul, Reality, Mind. Names can be printed in any order. Keep the first letter uppercase, others lowercase.
","input
In the first sample Thanos already has Reality, Power, Mind and Soul Gems, so he needs two more: Time and Space.
output
In the second sample Thanos doesn't have any Gems, so he needs all six.
",implementation,1
"import io,os
# input = sys.stdin.buffer.readline
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
n,m=map(lambda x:int(x), input().split())
A = []
for _ in range(n):
    scores = list(map(lambda x:int(x), input().split()))
    A.append(scores)

def solve(n,m,A):
    # O(31*( 5*n + 4**5 ))
    # all index from 0
    ans = ()
    nstats = 2**m
    def judge(finalScore):
        nonlocal ans
        seen = {}
        for i,scores in enumerate(A):
            sta = 0
            for e in scores:
                sta=sta*2+(e>=finalScore)
            # example [1,2,3,4,1], finalScore=3
            # sta = 0b00110
            seen[sta]=i
        
        for i in range(nstats):
            for j in range(nstats):
                if ((i|j) == nstats-1) and i in seen and j in seen:
                    ans = (seen[i], seen[j])
                    return True

        return False
    
    l=0
    r=2**31-1
    while l<r:
        m=l+(r-l)//2
        if not judge(m):
            r=m
        else:
            l=m+1
    # Highest score is l-1
    print(ans[0]+1,ans[1]+1) # answer index start from 1

solve(n,m,A)
",1288_D,CODEFORCES,4643,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
M=1000001
for i in range(N):
    dp[i+M] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+M*k], dp[j+k+M*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+M*i] = u+1;break


#print(dp)
dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp[j+(i+1-j)*M] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",1312_E,CODEFORCES,3831,Array Shrinking,"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation any number of times:
After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array $$$a$$$ you can get?
The first line contains the single integer $$$n$$$ ($$$1 \le n \le 500$$$) — the initial length of the array $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$) — the initial array $$$a$$$.
Print the only integer — the minimum possible length you can get after performing the operation described above any number of times.
In the first test, this is one of the optimal sequences of operations: $$$4$$$ $$$3$$$ $$$2$$$ $$$2$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$\rightarrow$$$ $$$5$$$ $$$3$$$.
","input
In the second test, this is one of the optimal sequences of operations: $$$3$$$ $$$3$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$5$$$ $$$4$$$ $$$\rightarrow$$$ $$$6$$$ $$$4$$$.
output
In the third and fourth tests, you can't perform the operation at all.
","dp, greedy",6
"n, s = map(int, input().split())
res = 0
for i in range(n, 0, -1):
    res += s//i
    s = s % i
print(res)",1061_A,CODEFORCES,1985,Coins,"You have unlimited number of coins with values $$$1, 2, \ldots, n$$$. You want to select some set of coins having the total value of $$$S$$$. 
It is allowed to have multiple coins with the same value in the set. What is the minimum number of coins required to get sum $$$S$$$?
The only line of the input contains two integers $$$n$$$ and $$$S$$$ ($$$1 \le n \le 100\,000$$$, $$$1 \le S \le 10^9$$$)
Print exactly one integer — the minimum number of coins required to obtain sum $$$S$$$.
In the first example, some of the possible ways to get sum $$$11$$$ with $$$3$$$ coins are: 
It is impossible to get sum $$$11$$$ with less than $$$3$$$ coins.
","input
In the second example, some of the possible ways to get sum $$$16$$$ with $$$3$$$ coins are: 
output
It is impossible to get sum $$$16$$$ with less than $$$3$$$ coins.
","greedy, implementation, math",3
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr()):
    n=nmbr()
    l=sorted(zip(lst(),range(n)))
    p=0;ans=[0]*(2*n)
    st=[0]*n;ln=0
    s=input()
    for i in range(2*n):
        # print(st)
        ch=s[i]
        if ch=='0':
            st[ln]=p
            ans[i]=l[p][1]+1
            ln+=1
            p+=1
        else:
            ans[i]=l[st[ln-1]][1]+1
            ln-=1
    print(*ans)",0982_B,CODEFORCES,2547,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation",4
"n = int(input())
a = list(map(int, input().split()))
ans = float('inf')
for i in range(n):
    ans = min(ans, a[i] // max(i,  n - i - 1))
print(ans)",1159_B,CODEFORCES,2121,Expansion coefficient of the array,"Let's call an array of non-negative integers $$$a_1, a_2, \ldots, a_n$$$ a $$$k$$$-extension for some non-negative integer $$$k$$$ if for all possible pairs of indices $$$1 \leq i, j \leq n$$$ the inequality $$$k \cdot |i - j| \leq min(a_i, a_j)$$$ is satisfied. The expansion coefficient of the array $$$a$$$ is the maximal integer $$$k$$$ such that the array $$$a$$$ is a $$$k$$$-extension. Any array is a 0-expansion, so the expansion coefficient always exists.
You are given an array of non-negative integers $$$a_1, a_2, \ldots, a_n$$$. Find its expansion coefficient.
The first line contains one positive integer $$$n$$$ — the number of elements in the array $$$a$$$ ($$$2 \leq n \leq 300\,000$$$). The next line contains $$$n$$$ non-negative integers $$$a_1, a_2, \ldots, a_n$$$, separated by spaces ($$$0 \leq a_i \leq 10^9$$$).
Print one non-negative integer — expansion coefficient of the array $$$a_1, a_2, \ldots, a_n$$$.
","input
In the first test, the expansion coefficient of the array $$$[6, 4, 5, 5]$$$ is equal to $$$1$$$ because $$$|i-j| \leq min(a_i, a_j)$$$, because all elements of the array satisfy $$$a_i \geq 3$$$. On the other hand, this array isn't a $$$2$$$-extension, because $$$6 = 2 \cdot |1 - 4| \leq min(a_1, a_4) = 5$$$ is false.
output
In the second test, the expansion coefficient of the array $$$[0, 1, 2]$$$ is equal to $$$0$$$ because this array is not a $$$1$$$-extension, but it is $$$0$$$-extension.
","implementation, math",3
"mod = 1000000000+7
def fp(x ,y):
    if y == 1:
        return x
    if y == 0:
        return 1
    t = fp(x,y//2)%mod
    if y%2 == 1:
        return (t*t*x)
    else:
        return (t*t)

def inv(x):
    return fp(x%mod,mod-2)%mod

n,k=list(map(int,input().split()))
if not n:
    print(0)
    exit()
if not k:
    print( (2*n)%mod )
    exit()
numberOfPro =fp(2,k)
last = n*numberOfPro
first = (n-1)*numberOfPro+1
sumOfLast = (last)*(last+1)*inv(2)
sumOfFirst = first*(first-1)*inv(2)
num = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)
print(num%mod)
",0992_C,CODEFORCES,1130,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"def get_input_list():
	return list(map(int, input().split()))

n = int(input())
l = get_input_list()
r = get_input_list()

a = [0 for _ in range(n)]
m = []
m_ = []
for i in range(n):
	m.append(l[i] + r[i])
	m_.append(l[i] + r[i])
m.sort()
ma = m[-1] + 1

for i in range(n):
	a[i] = ma - m_[i]

l_ = []
r_ = []
for i in range(n):
	c = 0
	d = 0
	for j in range(i+1):
		if a[j] > a[i]:
			c += 1
	for j in range(i,n):
		if a[j] > a[i]:
			d += 1
	l_.append(c)
	r_.append(d)
res = True
for i in range(n):
	if l[i] != l_[i] or r[i] != r_[i]:
		res = False
		break
if res:
	print(""YES"")
	for i in range(n):
		a[i] = str(a[i])
	print("" "".join(a))
else:
	print(""NO"")",1054_C,CODEFORCES,3522,Candies Distribution,"There are $$$n$$$ children numbered from $$$1$$$ to $$$n$$$ in a kindergarten. Kindergarten teacher gave $$$a_i$$$ ($$$1 \leq a_i \leq n$$$) candies to the $$$i$$$-th child. Children were seated in a row in order from $$$1$$$ to $$$n$$$ from left to right and started eating candies. 
While the $$$i$$$-th child was eating candies, he calculated two numbers $$$l_i$$$ and $$$r_i$$$ — the number of children seating to the left of him that got more candies than he and the number of children seating to the right of him that got more candies than he, respectively.
Formally, $$$l_i$$$ is the number of indices $$$j$$$ ($$$1 \leq j < i$$$), such that $$$a_i < a_j$$$ and $$$r_i$$$ is the number of indices $$$j$$$ ($$$i < j \leq n$$$), such that $$$a_i < a_j$$$.
Each child told to the kindergarten teacher the numbers $$$l_i$$$ and $$$r_i$$$ that he calculated. Unfortunately, she forgot how many candies she has given to each child. So, she asks you for help: given the arrays $$$l$$$ and $$$r$$$ determine whether she could have given the candies to the children such that all children correctly calculated their values $$$l_i$$$ and $$$r_i$$$, or some of them have definitely made a mistake. If it was possible, find any way how she could have done it.
On the first line there is a single integer $$$n$$$ ($$$1 \leq n \leq 1000$$$) — the number of children in the kindergarten.
On the next line there are $$$n$$$ integers $$$l_1, l_2, \ldots, l_n$$$ ($$$0 \leq l_i \leq n$$$), separated by spaces.
On the next line, there are $$$n$$$ integer numbers $$$r_1, r_2, \ldots, r_n$$$ ($$$0 \leq r_i \leq n$$$), separated by spaces.
If there is no way to distribute the candies to the children so that all of them calculated their numbers correctly, print «NO» (without quotes).
Otherwise, print «YES» (without quotes) on the first line. On the next line, print $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$, separated by spaces — the numbers of candies the children $$$1, 2, \ldots, n$$$ received, respectively. Note that some of these numbers can be equal, but all numbers should satisfy the condition $$$1 \leq a_i \leq n$$$. The number of children seating to the left of the $$$i$$$-th child that got more candies than he should be equal to $$$l_i$$$ and the number of children seating to the right of the $$$i$$$-th child that got more candies than he should be equal to $$$r_i$$$. If there is more than one solution, find any of them.
In the first example, if the teacher distributed $$$1$$$, $$$3$$$, $$$1$$$, $$$2$$$, $$$1$$$ candies to $$$1$$$-st, $$$2$$$-nd, $$$3$$$-rd, $$$4$$$-th, $$$5$$$-th child, respectively, then all the values calculated by the children are correct. For example, the $$$5$$$-th child was given $$$1$$$ candy, to the left of him $$$2$$$ children were given $$$1$$$ candy, $$$1$$$ child was given $$$2$$$ candies and $$$1$$$ child — $$$3$$$ candies, so there are $$$2$$$ children to the left of him that were given more candies than him.
","input
In the second example it is impossible to distribute the candies, because the $$$4$$$-th child made a mistake in calculating the value of $$$r_4$$$, because there are no children to the right of him, so $$$r_4$$$ should be equal to $$$0$$$.
output
In the last example all children may have got the same number of candies, that's why all the numbers are $$$0$$$. Note that each child should receive at least one candy.
","constructivealgorithms, implementation",5
"n = int(input())
a = list(map(int, input().split()))
max_el = -1;
er = -1;
for i in range(len(a)):
    if a[i] - max_el > 1:
        er = i + 1;
        break
    if a[i] > max_el:
        max_el = a[i]

print(er)
",1054_B,CODEFORCES,1958,Appending Mex,"Initially Ildar has an empty array. He performs $$$n$$$ steps. On each step he takes a subset of integers already added to the array and appends the mex of this subset to the array. 
The mex of an multiset of integers is the smallest non-negative integer not presented in the multiset. For example, the mex of the multiset $$$[0, 2, 3]$$$ is $$$1$$$, while the mex of the multiset $$$[1, 2, 1]$$$ is $$$0$$$.
More formally, on the step $$$m$$$, when Ildar already has an array $$$a_1, a_2, \ldots, a_{m-1}$$$, he chooses some subset of indices $$$1 \leq i_1 < i_2 < \ldots < i_k < m$$$ (possibly, empty), where $$$0 \leq k < m$$$, and appends the $$$mex(a_{i_1}, a_{i_2}, \ldots a_{i_k})$$$ to the end of the array.
After performing all the steps Ildar thinks that he might have made a mistake somewhere. He asks you to determine for a given array $$$a_1, a_2, \ldots, a_n$$$ the minimum step $$$t$$$ such that he has definitely made a mistake on at least one of the steps $$$1, 2, \ldots, t$$$, or determine that he could have obtained this array without mistakes.
The first line contains a single integer $$$n$$$ ($$$1 \leq n \leq 100\,000$$$) — the number of steps Ildar made.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 10^9$$$) — the array Ildar obtained.
If Ildar could have chosen the subsets on each step in such a way that the resulting array is $$$a_1, a_2, \ldots, a_n$$$, print $$$-1$$$.
Otherwise print a single integer $$$t$$$ — the smallest index of a step such that a mistake was made on at least one step among steps $$$1, 2, \ldots, t$$$.
In the first example it is possible that Ildar made no mistakes. Here is the process he could have followed.
Thus, he can get the array without mistakes, so the answer is $$$-1$$$.
","input
In the second example he has definitely made a mistake on the very first step, because he could not have obtained anything different from $$$0$$$.
output
In the third example he could have obtained $$$[0, 1, 2]$$$ without mistakes, but $$$239$$$ is definitely wrong.
",implementation,3
"s = input().split(' ')
s1 = s[0]
s2 = s[1]
res = s1[0]
flag = 0
for i in range(1, len(s1)):
    if(s1[i]>=s2[0]):
        res+=s2[0]
        flag = 1
        break
    else:
        res+=s1[i]
if(flag == 0):
    res+=s2[0]
print(res)
",0909_A,CODEFORCES,1528,Generate Login,"The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.
You are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).
As a reminder, a prefix of a string s is its substring which occurs at the beginning of s: ""a"", ""ab"", ""abc"" etc. are prefixes of string ""{abcdef}"" but ""b"" and 'bc"" are not. A string a is alphabetically earlier than a string b, if a is a prefix of b, or a and b coincide up to some position, and then a has a letter that is alphabetically earlier than the corresponding letter in b: ""a"" and ""ab"" are alphabetically earlier than ""ac"" but ""b"" and ""ba"" are alphabetically later than ""ac"".
","input
The input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive. 
output
Output a single string — alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.
","bruteforce, greedy, sortings",3
"import sys, collections

n, k = map(int, sys.stdin.readline().split())
left = 0
right = n + 1
while left < right:
    mid = (left + right) // 2
    candy = n - mid
    total = (candy * (candy + 1)) // 2 - mid
    if total < k:
        right = mid
    elif total > k:
        left = mid + 1
    else:
        print(mid)
        break",1195_B,CODEFORCES,1417,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from collections import Counter
from collections import defaultdict as dd

# sys.setrecursionlimit(100000000)

flush = lambda: stdout.flush()
stdstr = lambda: stdin.readline()
stdint = lambda: int(stdin.readline())
stdpr = lambda x: stdout.write(str(x))
stdmap = lambda: map(int, stdstr().split())
stdarr = lambda: list(map(int, stdstr().split()))

mod = 1000000007

def sieve(n):

    prime = [True for _ in range(n+1)]
    p = 2

    while(p*p <= n):
        if(prime[p] == True):

            for i in range(p*p, n+1, p):
                prime[i] = False

        p += 1

    return prime


# for _ in range(stdint()):
n,k = stdmap()

all = sieve(n)

# print(all)

primes = []

for i in range(1, len(all)):
    if(all[i] == True):
        primes.append(i)

s = Counter(primes)

res = 0

for i in range(len(primes)-1):
    toCheck = primes[i]+primes[i+1]+1

    if(toCheck in s):
        res += 1

if(res >= k):
    print(""YES"")
else:
    print(""NO"")
",0017_A,CODEFORCES,1438,Noldbach problem,"Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least k prime numbers from 2 to n inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.
Two prime numbers are called neighboring if there are no other prime numbers between them.
You are to help Nick, and find out if he is right or wrong.
The first line of the input contains two integers n (2 ≤ n ≤ 1000) and k (0 ≤ k ≤ 1000).
","input
Output YES if at least k prime numbers from 2 to n inclusively can be expressed as it was described above. Otherwise output NO.
output
In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.
","bruteforce, math, numbertheory",3
"from math import *
a,r = map(int,input().split())
x = list(map(int,input().split()))
y = [0]*a
for i in range(a):
    h = r
    for j in range(i):
        if abs(x[i]-x[j])<=2*r:
            h = max(h,sqrt((2*r)**2 - (x[i]-x[j])**2)+y[j])
    y[i] = h
    print(h, end = "" "")
",0908_C,CODEFORCES,3058,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"def main():
    n, k = map(int, input().split())
    n -= 1
    k -= 1
    if n == 0:
        minSplitters = 0
    elif n <= k:
        minSplitters = 1
    elif n > sum_consecutive(k):
        minSplitters = -1
    else:
        minSplitters = min_splitters(n, k)

    print(minSplitters)


def min_splitters(n, k):
    low, high = 1, k
    while low < high:
        mid = (low + high) // 2
        summation = sum_consecutive2(mid, k)
        if summation == n:
            return k - mid + 1
        elif summation > n:
            low = mid + 1
        else:
            high = mid

    return k - low + 2


def sum_consecutive(num):
    return int(0.5 * num * (num + 1))


def sum_consecutive2(num1, num2):
    return sum_consecutive(num2) - sum_consecutive(num1 - 1)


if __name__ == '__main__':
    main()
",0287_B,CODEFORCES,942,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"from collections import Counter
import copy

def solve():
    a,b=list(map(int,input().split()))
    count=0
    if a==b:
        return 1
    while a!=0 and b!=0:
        if a<b:
            count+=(b//a)
            b-=a*(b//a)
        else:
            count+=a//b
            a-=b*(a//b)
    return count


for i in range(int(input())):
        print(solve())

",0267_A,CODEFORCES,105,Subtractions,"You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).
You've got some number of pairs (ai, bi). How many operations will be performed for each of them?
","input
The first line contains the number of pairs n (1  ≤  n  ≤  1000). Then follow n lines, each line contains a pair of positive integers ai, bi (1  ≤  ai,  bi  ≤  109).
output
Print the sought number of operations for each pair on a single line.
","math, numbertheory",1
"k = int(input())
a = 9
for i in range(1,12):
    if k<=a*i:
        a = (a//9)+(k//i)-1
        if k%i!=0:
            b = str(a+1)
            c = (k%i)-1
            print(b[c])
        else:
            b = str(a)
            print(b[-1])
        break
    else:
        k = k-a*i
        a = a*10
",1177_B,CODEFORCES,1236,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"def size_of_group(i):
    return long(9 * 10**(i - 1)) * i

def find_group_data(k, i = 1):
    diff = long(k - (size_of_group(i)))
    if diff <= 0:
        return k, i
    return find_group_data(diff, i + 1)

def get_sequence_number(num):
    """"""XXXX""""""
    k, g = find_group_data(num)
    return str(long(10**(g - 1)) + (k - 1) / g)[(k - 1) % g]

# run program
if __name__ == ""__main__"":
    print(get_sequence_number(long(input())))",1177_B,CODEFORCES,1284,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"
s = [input(), input()]
n = len(s[0])

dp = [[0,0,0] for _ in range(n+1)]

for i in range(n-2,-1,-1):
    dp[i] = [dp[i+1][0]]*3
    vals = [0,0,0,0]
    if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i] == '0':
        vals[0] = dp[i+1][2] + 1
    if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0':
        vals[1] = dp[i+2][0] + 1
    if s[1][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0':
        vals[2] = dp[i+2][0] + 1
    if s[0][i] == '0' and s[1][i] == '0' and s[1][i+1] == '0':
        vals[3] = dp[i+1][1] + 1
    dp[i][1] = max(dp[i+1][0], vals[1])
    dp[i][2] = max(dp[i+1][0], vals[2])
    dp[i][0] = max(dp[i][1], dp[i][2], *vals)

result = max(dp[0])
print(result)
",0991_D,CODEFORCES,387,Bishwock,"Bishwock is a chess figure that consists of three squares resembling an ""L-bar"". This figure can be rotated by 90, 180 and 270 degrees so it can have four possible states:
Bishwocks don't attack any squares and can even occupy on the adjacent squares as long as they don't occupy the same square. 
Vasya has a board with $$$2\times n$$$ squares onto which he wants to put some bishwocks. To his dismay, several squares on this board are already occupied by pawns and Vasya can't put bishwocks there. However, pawns also don't attack bishwocks and they can occupy adjacent squares peacefully.
Knowing the positions of pawns on the board, help Vasya to determine the maximum amount of bishwocks he can put onto the board so that they wouldn't occupy the same squares and wouldn't occupy squares with pawns.
","input
The input contains two nonempty strings that describe Vasya's board. Those strings contain only symbols ""0"" (zero) that denote the empty squares and symbols ""X"" (uppercase English letter) that denote the squares occupied by pawns. Strings are nonempty and are of the same length that does not exceed $$$100$$$.
output
Output a single integer — the maximum amount of bishwocks that can be placed onto the given board.
","dp, greedy",1
"n,m,a,b=[int(x) for x in input().split()]
if n>m:
	if n%m==0:
		print(0)
	else:
		t1=n%m
		print(min(t1*b,(m-t1)*a))
elif n==m:
	print(0)
else:
	print(min(n*b,(m-n)*a))",0990_A,CODEFORCES,1687,Commentary Boxes,"Berland Football Cup starts really soon! Commentators from all over the world come to the event.
Organizers have already built $$$n$$$ commentary boxes. $$$m$$$ regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.
If $$$n$$$ is not divisible by $$$m$$$, it is impossible to distribute the boxes to the delegations at the moment.
Organizers can build a new commentary box paying $$$a$$$ burles and demolish a commentary box paying $$$b$$$ burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.
What is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$)?
The only line contains four integer numbers $$$n$$$, $$$m$$$, $$$a$$$ and $$$b$$$ ($$$1 \le n, m \le 10^{12}$$$, $$$1 \le a, b \le 100$$$), where $$$n$$$ is the initial number of the commentary boxes, $$$m$$$ is the number of delegations to come, $$$a$$$ is the fee to build a box and $$$b$$$ is the fee to demolish a box.
Output the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$). It is allowed that the final number of the boxes is equal to $$$0$$$.
In the first example organizers can build $$$5$$$ boxes to make the total of $$$14$$$ paying $$$3$$$ burles for the each of them.
","input
In the second example organizers can demolish $$$2$$$ boxes to make the total of $$$0$$$ paying $$$7$$$ burles for the each of them.
output
In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get $$$5$$$ boxes.
","implementation, math",3
"d = {}
n = int(input())
for _ in range(n):
	a,x = map(int,input().split())
	d[a] = x
m = int(input())
for _ in range(m):
	b,y = map(int,input().split())
	if b in d:
		d[b] = max(y,d[b])
	else:
		d[b] = y
count = 0
for i in d:
	count += d[i]
print(count)",0981_B,CODEFORCES,2537,Businessmen Problems,"Two famous competing companies ChemForces and TopChemist decided to show their sets of recently discovered chemical elements on an exhibition. However they know that no element should be present in the sets of both companies.
In order to avoid this representatives of both companies decided to make an agreement on the sets the companies should present. The sets should be chosen in the way that maximizes the total income of the companies.
All elements are enumerated with integers. The ChemForces company has discovered $$$n$$$ distinct chemical elements with indices $$$a_1, a_2, \ldots, a_n$$$, and will get an income of $$$x_i$$$ Berland rubles if the $$$i$$$-th element from this list is in the set of this company.
The TopChemist company discovered $$$m$$$ distinct chemical elements with indices $$$b_1, b_2, \ldots, b_m$$$, and it will get an income of $$$y_j$$$ Berland rubles for including the $$$j$$$-th element from this list to its set.
In other words, the first company can present any subset of elements from $$$\{a_1, a_2, \ldots, a_n\}$$$ (possibly empty subset), the second company can present any subset of elements from $$$\{b_1, b_2, \ldots, b_m\}$$$ (possibly empty subset). There shouldn't be equal elements in the subsets.
Help the representatives select the sets in such a way that no element is presented in both sets and the total income is the maximum possible.
The first line contains a single integer $$$n$$$ ($$$1 \leq n \leq 10^5$$$)  — the number of elements discovered by ChemForces.
The $$$i$$$-th of the next $$$n$$$ lines contains two integers $$$a_i$$$ and $$$x_i$$$ ($$$1 \leq a_i \leq 10^9$$$, $$$1 \leq x_i \leq 10^9$$$)  — the index of the $$$i$$$-th element and the income of its usage on the exhibition. It is guaranteed that all $$$a_i$$$ are distinct.
The next line contains a single integer $$$m$$$ ($$$1 \leq m \leq 10^5$$$)  — the number of chemicals invented by TopChemist.
The $$$j$$$-th of the next $$$m$$$ lines contains two integers $$$b_j$$$ and $$$y_j$$$, ($$$1 \leq b_j \leq 10^9$$$, $$$1 \leq y_j \leq 10^9$$$)  — the index of the $$$j$$$-th element and the income of its usage on the exhibition. It is guaranteed that all $$$b_j$$$ are distinct.
Print the maximum total income you can obtain by choosing the sets for both companies in such a way that no element is presented in both sets.
","input
In the first example ChemForces can choose the set ($$$3, 7$$$), while TopChemist can choose ($$$1, 2, 4$$$). This way the total income is $$$(10 + 2) + (4 + 4 + 4) = 24$$$.
output
In the second example ChemForces can choose the only element $$$10^9$$$, while TopChemist can choose ($$$14, 92, 35$$$). This way the total income is $$$(239) + (15 + 65 + 89) = 408$$$.
",sortings,4
"k = int(input())
if k <= 9:
    print(k)
else:
    length = len(str(k))
    s = """"
    num = 0

    for i in range(length - 1):
        num += (9*(10**i))*(i + 1)
        temp = num + (9*(10**(i + 1)))*(i + 2)
        if temp > k:
            length = i + 2
            break

    for i in range(length - 1):
        s = s + ""1""
    #print(s)

    previous_value = 9 * int(s)
    try_value = k - num
    #print(try_value)
    #print(previous_value)
    #print(length)
    if try_value % length == 0:
        div_value = try_value // length
        temp_string = str(previous_value + div_value)
        print(temp_string[len(temp_string) - 1])
    else:
        div_value = (try_value // length) + 1
        temp_string = str(previous_value + div_value)
        differ = (div_value * length) - try_value
        print(temp_string[len(temp_string) - differ - 1])",1177_B,CODEFORCES,1311,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"def quadrant(x, y, rx, ry):
	if x>rx and y>ry:
		return 1
	elif x<rx and y>ry:
		return 2
	elif x<rx and y<ry:
		return 3
	else:
		return 4

n = int(input())

qx, qy = map(int, input().split())
kx, ky = map(int, input().split())
cx, cy = map(int, input().split())

if quadrant(kx, ky, qx, qy) == quadrant(cx, cy, qx, qy):
	print(""YES"")
else:
	print(""NO"")
",1033_A,CODEFORCES,454,King Escape,"Alice and Bob are playing chess on a huge chessboard with dimensions $$$n \times n$$$. Alice has a single piece left — a queen, located at $$$(a_x, a_y)$$$, while Bob has only the king standing at $$$(b_x, b_y)$$$. Alice thinks that as her queen is dominating the chessboard, victory is hers. 
But Bob has made a devious plan to seize the victory for himself — he needs to march his king to $$$(c_x, c_y)$$$ in order to claim the victory for himself. As Alice is distracted by her sense of superiority, she no longer moves any pieces around, and it is only Bob who makes any turns.
Bob will win if he can move his king from $$$(b_x, b_y)$$$ to $$$(c_x, c_y)$$$ without ever getting in check. Remember that a king can move to any of the $$$8$$$ adjacent squares. A king is in check if it is on the same rank (i.e. row), file (i.e. column), or diagonal as the enemy queen. 
Find whether Bob can win or not.
The first line contains a single integer $$$n$$$ ($$$3 \leq n \leq 1000$$$) — the dimensions of the chessboard.
The second line contains two integers $$$a_x$$$ and $$$a_y$$$ ($$$1 \leq a_x, a_y \leq n$$$) — the coordinates of Alice's queen.
The third line contains two integers $$$b_x$$$ and $$$b_y$$$ ($$$1 \leq b_x, b_y \leq n$$$) — the coordinates of Bob's king.
The fourth line contains two integers $$$c_x$$$ and $$$c_y$$$ ($$$1 \leq c_x, c_y \leq n$$$) — the coordinates of the location that Bob wants to get to.
It is guaranteed that Bob's king is currently not in check and the target location is not in check either.
Furthermore, the king is not located on the same square as the queen (i.e. $$$a_x \neq b_x$$$ or $$$a_y \neq b_y$$$), and the target does coincide neither with the queen's position (i.e. $$$c_x \neq a_x$$$ or $$$c_y \neq a_y$$$) nor with the king's position (i.e. $$$c_x \neq b_x$$$ or $$$c_y \neq b_y$$$).
Print ""YES"" (without quotes) if Bob can get from $$$(b_x, b_y)$$$ to $$$(c_x, c_y)$$$ without ever getting in check, otherwise print ""NO"".
You can print each letter in any case (upper or lower).
In the diagrams below, the squares controlled by the black queen are marked red, and the target square is marked blue.
In the first case, the king can move, for instance, via the squares $$$(2, 3)$$$ and $$$(3, 2)$$$. Note that the direct route through $$$(2, 2)$$$ goes through check.
","input
In the second case, the queen watches the fourth rank, and the king has no means of crossing it.
output
In the third case, the queen watches the third file.
","dfsandsimilar, graphs, implementation",1
"import math
def maxor(bawah, atas):
	if bawah == atas:
		return 0
	xor = bawah^atas
	pangkat2 = math.log(xor, 2)
	return 2**int(math.floor(pangkat2)+1) - 1
a=input().split()
print(maxor(int(a[0]),int(a[1])))",0276_D,CODEFORCES,805,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase
from array import array

def main():
    n,M = map(int,input().split())
    comb = [[0]*(n+1) for _ in range(n+1)]
    comb[0][0] = 1
    for i in range(1,n+1):
        for j in range(i+1):
            comb[i][j] = (comb[i-1][j]+comb[i-1][j-1])%M

    dp = [array('i',[0]*(n+1)) for _ in range(n+1)]
    # number of partitions ; number of computer
    for i in range(1,n+1):
        dp[i][0] = pow(2,i-1,M)
    for j in range(1,n+1):
        for i in range(3,n+1):
            for x in range(1,i-1):
                dp[i][j] = (dp[i][j]+dp[i-1-x][j-1]*dp[x][0]*comb[i-j][x])%M
    su = 0
    for i in range(n+1):
        su = (su+dp[n][i])%M
    print(su)

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",1515_E,CODEFORCES,4060,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

from itertools import combinations
ways_to_choose = 0
for length in range(2, n + 1):
    for p in combinations(c, length):
        problemset = sorted(p)
        if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x:
            ways_to_choose += 1

print(ways_to_choose)
",0550_B,CODEFORCES,4498,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"n, k = map(int, input().split())
print((k + n - 1) // n)",1036_A,CODEFORCES,460,Function Height,"You are given a set of $$$2n+1$$$ integer points on a Cartesian plane. Points are numbered from $$$0$$$ to $$$2n$$$ inclusive. Let $$$P_i$$$ be the $$$i$$$-th point. The $$$x$$$-coordinate of the point $$$P_i$$$ equals $$$i$$$. The $$$y$$$-coordinate of the point $$$P_i$$$ equals zero (initially). Thus, initially $$$P_i=(i,0)$$$.
The given points are vertices of a plot of a piecewise function. The $$$j$$$-th piece of the function is the segment $$$P_{j}P_{j + 1}$$$.
In one move you can increase the $$$y$$$-coordinate of any point with odd $$$x$$$-coordinate (i.e. such points are $$$P_1, P_3, \dots, P_{2n-1}$$$) by $$$1$$$. Note that the corresponding segments also change.
For example, the following plot shows a function for $$$n=3$$$ (i.e. number of points is $$$2\cdot3+1=7$$$) in which we increased the $$$y$$$-coordinate of the point $$$P_1$$$ three times and $$$y$$$-coordinate of the point $$$P_5$$$ one time:
Let the area of the plot be the area below this plot and above the coordinate axis OX. For example, the area of the plot on the picture above is 4 (the light blue area on the picture above is the area of the plot drawn on it).
Let the height of the plot be the maximum $$$y$$$-coordinate among all initial points in the plot (i.e. points $$$P_0, P_1, \dots, P_{2n}$$$). The height of the plot on the picture above is 3.
Your problem is to say which minimum possible height can have the plot consisting of $$$2n+1$$$ vertices and having an area equal to $$$k$$$. Note that it is unnecessary to minimize the number of moves.
It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 10^{18}$$$) — the number of vertices in a plot of a piecewise function and the area we need to obtain.
Print one integer — the minimum possible height of a plot consisting of $$$2n+1$$$ vertices and with an area equals $$$k$$$. It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
One of the possible answers to the first example:
The area of this plot is 3, the height of this plot is 1.
","input
There is only one possible answer to the second example:
output
The area of this plot is 12, the height of this plot is 3.
",math,1
"n = int(input())
n = n + n//2

print(n)",0084_A,CODEFORCES,32,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
#sys.setrecursionlimit(200000000)
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
#MOD = 1000000000 + 7
def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])
    


n,U = ilele()
A = alele()
Ans = -1
for i in range(n-2):
    x = A[i]
    y = x  + U
    z = bisect.bisect_left(A,y,lo = i+2,hi = n)
    #print(z)
    if z == n:
        z-=1
    if A[z] <= x +U:
        a = A[z]
    elif A[z-1] <= x +U and z-1 != i+1:
        a = A[z-1]
    else:
        continue
    b = (a - A[i+1])/(a - A[i])
    #rint(b)
    Ans = max(Ans,b)
print(Ans)        
    
        
        
    
",0957_C,CODEFORCES,2477,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers",4
"from math import sin
pi = 3.141592653589793238462643383279502884197
n, r = map(int,input().split())
theta = 2*pi / n
R = r / (1-sin(theta/2))
print(R-r)",1100_C,CODEFORCES,660,NN and the Optical Illusion,"NN is an experienced internet user and that means he spends a lot of time on the social media. Once he found the following image on the Net, which asked him to compare the sizes of inner circles:
It turned out that the circles are equal. NN was very surprised by this fact, so he decided to create a similar picture himself.
He managed to calculate the number of outer circles $$$n$$$ and the radius of the inner circle $$$r$$$. NN thinks that, using this information, you can exactly determine the radius of the outer circles $$$R$$$ so that the inner circle touches all of the outer ones externally and each pair of neighboring outer circles also touches each other. While NN tried very hard to guess the required radius, he didn't manage to do that. 
Help NN find the required radius for building the required picture.
The first and the only line of the input file contains two numbers $$$n$$$ and $$$r$$$ ($$$3 \leq n \leq 100$$$, $$$1 \leq r \leq 100$$$) — the number of the outer circles and the radius of the inner circle respectively.
Output a single number $$$R$$$ — the radius of the outer circle required for building the required picture. 
","input
Your answer will be accepted if its relative or absolute error does not exceed $$$10^{-6}$$$.
output
Formally, if your answer is $$$a$$$ and the jury's answer is $$$b$$$. Your answer is accepted if and only when $$$\frac{|a-b|}{max(1, |b|)} \le 10^{-6}$$$.
","binarysearch, geometry, math",1
"from sys import stdin, stdout
n = int(stdin.readline())
m = int(stdin.readline())
stdout.write(str(m%(1<<n)))",0913_A,CODEFORCES,240,Modular Exponentiation,"The following problem is well-known: given integers n and m, calculate
where 2n = 2·2·...·2 (n factors), and  denotes the remainder of division of x by y.
You are asked to solve the ""reverse"" problem. Given integers n and m, calculate
The first line contains a single integer n (1 ≤ n ≤ 108).
The second line contains a single integer m (1 ≤ m ≤ 108).
Output a single integer — the value of .
","input
In the first example, the remainder of division of 42 by 24 = 16 is equal to 10.
output
In the second example, 58 is divisible by 21 = 2 without remainder, and the answer is 0.
","implementation, math",1
"n=int(input())
a=input()
b=a.count('T')
c=-1
for i in range(n):
    d=0
    for j in range(b):
        d+=int(a[(i+j)%n]=='H')
    if c==-1 or d<c:
        c=d
print(c)",0046_C,CODEFORCES,1450,Hamsters and Tigers,"Today there is going to be an unusual performance at the circus — hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.
The first line contains number n (2 ≤ n ≤ 1000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of n symbols ""H"" and ""T"". The ""H""s correspond to hamsters and the ""T""s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.
","input
Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.
output
In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then — the tiger in position 9 with the hamster in position 7.
",twopointers,3
"'''
    Auther: ghoshashis545 Ashis Ghosh
    College: jalpaiguri Govt Enggineering College

'''
from os import path
import sys
from heapq import heappush,heappop
from functools import cmp_to_key as ctk
from collections import deque,defaultdict as dd
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input().rstrip()
def mi():return map(int,input().split())
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
# mod=1000000007
mod=998244353
inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
    return ord(i)-ord('a')


    
def sod(n):
    s = 0 
    while n:
        s += (n%10)
        n //= 10
    return s

    
def solve():



    n,s = mi()

    def fun(mid):
        return mid - sod(mid) >= s
    
    l = 0
    r = n
    ans = -1
    while l <= r:
        m = l+(r-l)//2
        if fun(m):
            ans = m
            r = m-1
        else:
            l = m+1
    if ans == -1:
        ans = n+1
    print(n-ans+1)







    








        
if __name__ ==""__main__"":

    
    if path.exists('input.txt'):
        sys.stdin=open('input.txt', 'r')
        sys.stdout=open('output.txt','w')
    else:
        input=sys.stdin.readline
    solve()",0817_C,CODEFORCES,1008,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"def solve(mat1: list, mat2: list, K: int) -> list:
    if K % 2 == 1:
        res = [[-1] * n for _ in range(m)]
    else:
        # dp[i][j][k]为从任意地方走到(i, j)且只走k步的最小无聊数
        dp = [[[-1] * (K // 2 + 1) for _ in range(n)] for _ in range(m)]
        for k in range(K // 2 + 1):
            for i in range(m):
                for j in range(n):
                    if k == 0:
                        dp[i][j][k] = 0
                    else:
                        if i > 0 and (dp[i][j][k] == -1 or dp[i - 1][j][k - 1] + mat2[i - 1][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i - 1][j][k - 1] + mat2[i - 1][j]
                        if i < m - 1 and (dp[i][j][k] == -1 or dp[i + 1][j][k - 1] + mat2[i][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i + 1][j][k - 1] + mat2[i][j]
                        if j > 0 and (dp[i][j][k] == -1 or dp[i][j - 1][k - 1] + mat1[i][j - 1] < dp[i][j][k]):
                            dp[i][j][k] = dp[i][j - 1][k - 1] + mat1[i][j - 1]
                        if j < n - 1 and (dp[i][j][k] == -1 or dp[i][j + 1][k - 1] + mat1[i][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i][j + 1][k - 1] + mat1[i][j]
        res = [[-1] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                res[i][j] = 2 * dp[i][j][-1]
    for i in range(m):
        for j in range(n):
            if j < n - 1:
                print(res[i][j], end = ' ')
            else:
                print(res[i][j])
    return
                        


m, n, K = map(int, input().split())
mat1 = []
mat2 = []
for _ in range(m):
    mat1.append(list(map(int, input().split())))
for _ in range(m - 1):
    mat2.append(list(map(int, input().split())))
solve(mat1, mat2, K)
",1517_D,CODEFORCES,4168,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy


def main():
    n = rint()
    a1, a2 = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n))
    for i in range(4):
        if a2.mat in [a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()]:
            exit(print('Yes'))
    print('No')


class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

            if id != None:
                for i in range(r):
                    self.mat[i][i] = 1

    def __add__(self, other):
        mat0 = Matrix(self.r, self.c)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]

        return mat0

    def __mul__(self, other):
        mat0 = Matrix(self.r, other.c)

        for i in range(self.r):
            for j in range(other.c):
                for k in range(self.c):
                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]

        return mat0

    def dot_mul(self, other):
        res = 0
        for i in range(self.r):
            for j in range(self.c):
                res += self.mat[i][j] * other.mat[j][i]

        return res

    def trace(self):
        res = 0
        for i in range(self.r):
            res += self.mat[i][i]

        return res

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def mat_pow(self, mat, p, mod=None):
        sq = Matrix(mat.r, mat.r, id=1)

        while p:
            if p & 1:
                p -= 1
                sq = sq * mat

            p //= 2
            mat = mat * mat

        return sq.mat


# FASTIO REGION
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",0958_A1,CODEFORCES,3124,Death Stars (easy),"The stardate is 1977 and the science and art of detecting Death Stars is in its infancy. Princess Heidi has received information about the stars in the nearby solar system from the Rebel spies and now, to help her identify the exact location of the Death Star, she needs to know whether this information is correct. 
Two rebel spies have provided her with the maps of the solar system. Each map is an N × N grid, where each cell is either occupied by a star or empty. To see whether the information is correct, Heidi needs to know whether the two maps are of the same solar system, or if possibly one of the spies is actually an Empire double agent, feeding her false information.
Unfortunately, spies may have accidentally rotated a map by 90, 180, or 270 degrees, or flipped it along the vertical or the horizontal axis, before delivering it to Heidi. If Heidi can rotate or flip the maps so that two of them become identical, then those maps are of the same solar system. Otherwise, there are traitors in the Rebel ranks! Help Heidi find out.
The first line of the input contains one number N (1 ≤ N ≤ 10) – the dimension of each map. Next N lines each contain N characters, depicting the first map: 'X' indicates a star, while 'O' indicates an empty quadrant of space. Next N lines each contain N characters, depicting the second map in the same format.
The only line of output should contain the word Yes if the maps are identical, or No if it is impossible to match them by performing rotations and translations.
","input
In the first test, you can match the first map to the second map by first flipping the first map along the vertical axis, and then by rotating it 90 degrees clockwise.
output
 
",implementation,5
"n, m, k = list(map(int, input().split()));
a = list(map(int, input().split()));

values = list()

for j in range(n):
    result = a[j];
    sum1 = 0;
    for i in range(m):
        if j-i>=0:
            sum1 = sum1 + a[j-i];
            if sum1 > result:
                result = sum1;
        else:
            continue;
    if j-m>=0:
        result = max(result, sum1 + values[j-m]);
    values.append(max(0, result-k));
print(max(values));
",1197_D,CODEFORCES,3645,Yet Another Subarray Problem,"You are given an array $$$a_1, a_2, \dots , a_n$$$ and two integers $$$m$$$ and $$$k$$$.
You can choose some subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$. 
The cost of subarray $$$a_l, a_{l+1}, \dots, a_{r-1}, a_r$$$ is equal to $$$\sum\limits_{i=l}^{r} a_i - k \lceil \frac{r - l + 1}{m} \rceil$$$, where $$$\lceil x \rceil$$$ is the least integer greater than or equal to $$$x$$$. 
The cost of empty subarray is equal to zero.
For example, if $$$m = 3$$$, $$$k = 10$$$ and $$$a = [2, -4, 15, -3, 4, 8, 3]$$$, then the cost of some subarrays are:
Your task is to find the maximum cost of some subarray (possibly empty) of array $$$a$$$.
The first line contains three integers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \le n \le 3 \cdot 10^5, 1 \le m \le 10, 1 \le k \le 10^9$$$).
","input
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$).
output
Print the maximum cost of some subarray of array $$$a$$$.
","dp, greedy, math",5
"n, t = map(int, input().split())
 
a, v = sorted(list(map(int, input().split())) for i in range(n)), 2
 
for i in range(n - 1):
 
    d = 2 * a[i + 1][0] - a[i + 1][1] - 2 * a[i][0] - a[i][1]
 
    if d > 2 * t:
 
        v += 2
 
    elif d == 2 * t:
 
        v += 1
 
print(v)",0015_A,CODEFORCES,2274,Cottage Village,"A new cottage village called «Flatville» is being built in Flatland. By now they have already built in «Flatville» n square houses with the centres on the Оx-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.
The architect bureau, where Peter works, was commissioned to build a new house in «Flatville». The customer wants his future house to be on the Оx-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.
Peter was given a list of all the houses in «Flatville». Would you help him find the amount of possible positions of the new house?
The first line of the input data contains numbers n and t (1 ≤ n, t ≤ 1000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi — x-coordinate of the centre of the i-th house, and ai — length of its side ( - 1000 ≤ xi ≤ 1000, 1 ≤ ai ≤ 1000).
","input
Output the amount of possible positions of the new house.
output
It is possible for the x-coordinate of the new house to have non-integer value.
","implementation, sortings",4
"i = int(input())
print(int(i/2) * 3)",0084_A,CODEFORCES,34,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"print(0, 0, input())
",0199_A,CODEFORCES,62,Hexadecimal's theorem,"Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.
Let's remember how Fibonacci numbers can be calculated. F0 = 0, F1 = 1, and all the next numbers are Fi = Fi - 2 + Fi - 1.
So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...
If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number n by three not necessary different Fibonacci numbers or say that it is impossible.
The input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.
","input
Output three required numbers: a, b and c. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.
output
If there are multiple answers, print any of them.
","bruteforce, constructivealgorithms, implementation, numbertheory",1
"# -*- coding:utf-8 -*-

""""""

created by shuangquan.huang at 11/26/18

""""""
import math


f = [0] * 100
for i in range(100):
    f[i] = (4**i-1) // 3


def solve(N, K):
    
    if N < 100 and f[N] < K:
        print('NO')
        return
    
    for i in range(99):
        if f[i] <= K < f[i+1]:
            x = K - f[i]
            a = N - i
            
            if x == 0:
                print('YES {}'.format(a))
                return
                
            edge = 2**(i+1) - 1
            others = (2**i-1) ** 2
            if edge == x:
                print('YES {}'.format(a-1))
                return
            
            ans = a
            if edge < x:
                x -= edge
                ans = a-1

            # split others
            for j in range(a + 1):
                if others * f[j] >= x:
                    print('YES {}'.format(ans))
                    return
            print('NO')
            
            return
    
    print('NO')
    
    
T = int(input())

for ti in range(T):
    N, K = map(int, input().split())
    solve(N, K)",1080_D,CODEFORCES,1197,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"def solve(n, a):
    a = sorted(a)
    if n == 1:
        return a[0] > 0 and a[0] % 2 == 1
    same_count = 0
    for i in range(n - 1):
        if a[i] == a[i + 1] == 0:
            return False
        if i < n - 2 and a[i] + 1 == a[i + 1] == a[i + 2]:
            return False
        if a[i] == a[i + 1]:
            same_count += 1
    if same_count > 1:
        return False
    return (sum(a) - n * (n - 1) // 2) % 2 == 1



assert not solve(1, [0])
assert not solve(2, [1, 0])
assert solve(2, [2, 2])
assert solve(3, [2, 3, 1])
assert not solve(4, [1, 1, 2, 2])
assert solve(4, [1, 1, 2, 3])
assert not solve(4, [1, 2, 3, 4])
assert solve(4, [0, 1, 2, 4])
assert solve(5, [0, 1, 2, 3, 5])

n = int(input())
a = map(int, input().split())

r = solve(n, a)
if r:

    print('sjfnb')
else:
    print('cslnb')
",1191_D,CODEFORCES,2997,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy",4
"def mus(x):
    c = 0
    while(x>0):
        c += x%10
        x = x//10
    return c
n,s=map(int,input().split())
ans = s + 10 - s%10
while(ans - mus(ans) < s):
    ans += 10
if ans > n:
    print(0)
else:
    print(n-ans+1)
",0817_C,CODEFORCES,977,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"from sys import stdin
inp = lambda : stdin.readline().strip()

nr, ng, nb = [int(x) for x in inp().split()]

r = [int(x) for x in inp().split()]
g = [int(x) for x in inp().split()]
b = [int(x) for x in inp().split()]
r.sort()
g.sort()
b.sort()
dp = [[[0 for _ in range(201)] for _ in range(201)] for _ in range(201)]
for i in range(nr+1):
    for j in range(ng+1):
        for k in range(nb+1):
            if i and j:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]);
            if i and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]);
            if j and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]);
 
print(dp[nr][ng][nb])",1398_D,CODEFORCES,3939,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"import os
import sys
from math import *
from collections import *

# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase


def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6


def Ceil(a, b):
    return a // b + int(a % b > 0)


def value():
    return tuple(map(int, input().split()))


def array():
    return [int(i) for i in input().split()]


def Int():
    return int(input())


def Str():
    return input()


def arrayS():
    return [i for i in input().split()]


# -------------------------code---------------------------#

n = int(input())
if n == 0:
    print(0)
else:
    print(n // 2 + 1 if n % 2 != 0 else n + 1)
",0979_A,CODEFORCES,315,"Pizza, Pizza, Pizza!!!","Katie, Kuro and Shiro are best friends. They have known each other since kindergarten. That's why they often share everything with each other and work together on some very hard problems.
Today is Shiro's birthday. She really loves pizza so she wants to invite her friends to the pizza restaurant near her house to celebrate her birthday, including her best friends Katie and Kuro.
She has ordered a very big round pizza, in order to serve her many friends. Exactly $$$n$$$ of Shiro's friends are here. That's why she has to divide the pizza into $$$n + 1$$$ slices (Shiro also needs to eat). She wants the slices to be exactly the same size and shape. If not, some of her friends will get mad and go home early, and the party will be over.
Shiro is now hungry. She wants to cut the pizza with minimum of straight cuts. A cut is a straight segment, it might have ends inside or outside the pizza. But she is too lazy to pick up the calculator.
As usual, she will ask Katie and Kuro for help. But they haven't come yet. Could you help Shiro with this problem?
A single line contains one non-negative integer $$$n$$$ ($$$0 \le n \leq 10^{18}$$$) — the number of Shiro's friends. The circular pizza has to be sliced into $$$n + 1$$$ pieces.
A single integer — the number of straight cuts Shiro needs.
","input
To cut the round pizza into quarters one has to make two cuts through the center with angle $$$90^{\circ}$$$ between them.
output
To cut the round pizza into five equal parts one has to make five cuts.
",math,1
"from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
from heapq import *
getcontext().prec = 30
MAX = sys.maxsize
MAXN = 10**5+10
MOD = 10**9+7
def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2: 
        return True    
    if not n & 1: 
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False
    return True

def mhd(a,b):
    return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))

def eld(x,y):
    a = y[0]-x[0]
    b = x[1]-y[1]
    return (a*a+b*b)**0.5

def lgcd(a):
    g = a[0]
    for i in range(1,len(a)):
        g = math.gcd(g,a[i])
    return g

def ms(a):
    msf = -MAX
    meh = 0
    st = en = be = 0
    for i in range(len(a)):
        meh+=a[i]
        if msf<meh:
            msf = meh
            st = be
            en = i
        if meh<0:
            meh = 0
            be = i+1
    return msf,st,en

def ncr(n,r):
    num=den=1
    for i in range(r):
        num = (num*(n-i))%MOD
        den = (den*(i+1))%MOD

    return (num*(pow(den,MOD-2,MOD)))%MOD



def flush():
    return sys.stdout.flush()


def fac(n):
    ans = 1
    for i in range(1,n+1):
        ans*=i
        ans%=MOD
    return ans

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
n = int(input())
a = arrIN()
a.sort()
f = [1]*n
cnt = 0
for i in range(n):
    if f[i]:
        cnt+=1
        for j in range(i,n):
            if f[j] and a[j]%a[i]==0:
                f[j] = 0
        f[i] = 0
print(cnt)



",1209_A,CODEFORCES,3660,Paint the Numbers,"You are given a sequence of integers $$$a_1, a_2, \dots, a_n$$$. You need to paint elements in colors, so that: 
For example, it's fine to paint elements $$$[40, 10, 60]$$$ in a single color, because they are all divisible by $$$10$$$. You can use any color an arbitrary amount of times (in particular, it is allowed to use a color only once). The elements painted in one color do not need to be consecutive.
For example, if $$$a=[6, 2, 3, 4, 12]$$$ then two colors are required: let's paint $$$6$$$, $$$3$$$ and $$$12$$$ in the first color ($$$6$$$, $$$3$$$ and $$$12$$$ are divisible by $$$3$$$) and paint $$$2$$$ and $$$4$$$ in the second color ($$$2$$$ and $$$4$$$ are divisible by $$$2$$$). For example, if $$$a=[10, 7, 15]$$$ then $$$3$$$ colors are required (we can simply paint each element in an unique color).
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$), where $$$n$$$ is the length of the given sequence.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). These numbers can contain duplicates.
Print the minimal number of colors to paint all the given numbers in a valid way.
In the first example, one possible way to paint the elements in $$$3$$$ colors is:
","input
In the second example, you can use one color to paint all the elements.
output
In the third example, one possible way to paint the elements in $$$4$$$ colors is:
","greedy, implementation, math",5
"test=int(input())
first=[]
for i in range(test):
    list_=list(map(int,input().split()))
    sum_=sum(list_)
    first.append(sum_)
first_sum=first[0]
count=0
for i in first:
    if first_sum<i:
        count=count+1 
    else:
        continue
print(count+1)",1017_A,CODEFORCES,1840,The Rank,"John Smith knows that his son, Thomas Smith, is among the best students in his class and even in his school. After the students of the school took the exams in English, German, Math, and History, a table of results was formed.
There are $$$n$$$ students, each of them has a unique id (from $$$1$$$ to $$$n$$$). Thomas's id is $$$1$$$. Every student has four scores correspond to his or her English, German, Math, and History scores. The students are given in order of increasing of their ids.
In the table, the students will be sorted by decreasing the sum of their scores. So, a student with the largest sum will get the first place. If two or more students have the same sum, these students will be sorted by increasing their ids. 
Please help John find out the rank of his son. 
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 1000$$$) — the number of students.
Each of the next $$$n$$$ lines contains four integers $$$a_i$$$, $$$b_i$$$, $$$c_i$$$, and $$$d_i$$$ ($$$0\leq a_i, b_i, c_i, d_i\leq 100$$$) — the grades of the $$$i$$$-th student on English, German, Math, and History. The id of the $$$i$$$-th student is equal to $$$i$$$.
Print the rank of Thomas Smith. Thomas's id is $$$1$$$.
","input
In the first sample, the students got total scores: $$$398$$$, $$$400$$$, $$$398$$$, $$$379$$$, and $$$357$$$. Among the $$$5$$$ students, Thomas and the third student have the second highest score, but Thomas has a smaller id, so his rank is $$$2$$$.
output
In the second sample, the students got total scores: $$$369$$$, $$$240$$$, $$$310$$$, $$$300$$$, $$$300$$$, and $$$0$$$. Among the $$$6$$$ students, Thomas got the highest score, so his rank is $$$1$$$.
",implementation,3
"n = int(input())

arr = list(map(int, input().split()))

solved = False
s = sum(arr)
if s == 0:
	print(""cslnb"")
	solved = True

if not solved:
	n_num = {}

	for item in arr:
		if item in n_num:
			n_num[item] += 1
		else:
			n_num[item] = 1

	if 0 in n_num and n_num[0] >= 2:
		print('cslnb')
		solved = True

	if not solved:
		for key in n_num.keys():
			if n_num[key] >= 3:
				print(""cslnb"")
				solved = True

		ind_pairs = []
		if not solved:
			for key in n_num.keys():
				if n_num[key] == 2:
					ind_pairs.append(key)

			if len(ind_pairs) >= 2:
				print(""cslnb"")
				solved = True
			elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:
				print(""cslnb"")
				solved = True
			else:
				# print('s', s)
				sum_targ = n*(n-1) // 2
				# print('sum_targ', sum_targ)
				dif_sum = s - sum_targ
				# print(""dif_sum"", dif_sum)
				if dif_sum % 2 == 0:
					print(""cslnb"")
				else:
					print(""sjfnb"")",1191_D,CODEFORCES,2219,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy",3
"n, k = map(int, input().split())
teams, freqs = [tuple(int(i) for i in input().split()) for _ in range(n)], {}
teams.sort(key = lambda x: (-x[0], x[1]))
for team in teams:
    freqs[team] = freqs.get(team, 0) + 1
print(freqs[teams[k - 1]])
",0166_A,CODEFORCES,2337,Rank List,"Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.
You know the rules of comparing the results of two given teams very well. Let's say that team a solved pa problems with total penalty time ta and team b solved pb problems with total penalty time tb. Team a gets a higher place than team b in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team a gets a higher place than team b in the final results' table if either pa > pb, or pa = pb and ta < tb. 
It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of x teams that solved the same number of problems with the same penalty time. Let's also say that y teams performed better than the teams from this group. In this case all teams from the group share places y + 1, y + 2, ..., y + x. The teams that performed worse than the teams from this group, get their places in the results table starting from the y + x + 1-th place.
Your task is to count what number of teams from the given list shared the k-th place. 
The first line contains two integers n and k (1 ≤ k ≤ n ≤ 50). Then n lines contain the description of the teams: the i-th line contains two integers pi and ti (1 ≤ pi, ti ≤ 50) — the number of solved problems and the total penalty time of the i-th team, correspondingly. All numbers in the lines are separated by spaces. 
In the only line print the sought number of teams that got the k-th place in the final results' table.
The final results' table for the first sample is: 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.
","input
The final table for the second sample is:
output
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.
","binarysearch, implementation, sortings",4
"n, q = map(int,input().split())
ai = list(map(int,input().split()))
ar  = []
ar3 = []
num = 1
nummm = max(ai)
if ai[0] != nummm:
    num2 = ai[0]
    for i in range(1,n):
        ar3 += [[num2,ai[i]]]
        if ai[i] == nummm:
            ar += [num2]
            num = i+1
            break
        if ai[i] > num2:
            ar += [num2]
            num2 = ai[i]
        else:
            ar += [ai[i]]
ar2 = []
for i in range(num,n):
    ar2 += [ai[i]]
for i in range(len(ar)):
    ar2 += [ar[i]]
num = len(ar3)
for i in range(q):
    m = int(input())
    if m <= num:
        print(ar3[m-1][0],ar3[m-1][1])
    else:
        m -= num
        m -= 1
        print(nummm,ar2[m % (n-1)])
",1180_C,CODEFORCES,2171,Valeriy and Deque,"Recently, on the course of algorithms and data structures, Valeriy learned how to use a deque. He built a deque filled with $$$n$$$ elements. The $$$i$$$-th element is $$$a_i$$$ ($$$i$$$ = $$$1, 2, \ldots, n$$$). He gradually takes the first two leftmost elements from the deque (let's call them $$$A$$$ and $$$B$$$, respectively), and then does the following: if $$$A > B$$$, he writes $$$A$$$ to the beginning and writes $$$B$$$ to the end of the deque, otherwise, he writes to the beginning $$$B$$$, and $$$A$$$ writes to the end of the deque. We call this sequence of actions an operation.
For example, if deque was $$$[2, 3, 4, 5, 1]$$$, on the operation he will write $$$B=3$$$ to the beginning and $$$A=2$$$ to the end, so he will get $$$[3, 4, 5, 1, 2]$$$.
The teacher of the course, seeing Valeriy, who was passionate about his work, approached him and gave him $$$q$$$ queries. Each query consists of the singular number $$$m_j$$$ $$$(j = 1, 2, \ldots, q)$$$. It is required for each query to answer which two elements he will pull out on the $$$m_j$$$-th operation.
Note that the queries are independent and for each query the numbers $$$A$$$ and $$$B$$$ should be printed in the order in which they will be pulled out of the deque.
Deque is a data structure representing a list of elements where insertion of new elements or deletion of existing elements can be made from both sides.
The first line contains two integers $$$n$$$ and $$$q$$$ ($$$2 \leq n \leq 10^5$$$, $$$0 \leq q \leq 3 \cdot 10^5$$$) — the number of elements in the deque and the number of queries. The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$, where $$$a_i$$$ $$$(0 \leq a_i \leq 10^9)$$$ — the deque element in $$$i$$$-th position. The next $$$q$$$ lines contain one number each, meaning $$$m_j$$$ ($$$1 \leq m_j \leq 10^{18}$$$).
For each teacher's query, output two numbers $$$A$$$ and $$$B$$$ — the numbers that Valeriy pulls out of the deque for the $$$m_j$$$-th operation.
","input
So, $$$2$$$ we write to the beginning of the deque, and $$$1$$$ — to the end.
output
We get the following status of the deque: $$$[2, 3, 4, 5, 1]$$$.
","datastructures, implementation",3
"k = int(input())

if k<=9:
    print(k)
else:
    num_arr = [9*(i+1)* 10**i for i in range(11)]

    index = 0

    while True:
        if k<=num_arr[index]:
            break
        else:
            k -= num_arr[index]
            index += 1

    digit = index+1
    k += digit-1


    num = k//digit
    offset = k%digit

    string_num = str(10**(digit-1)+ num-1)

    print(string_num[offset])

",1177_B,CODEFORCES,695,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",1
"n = int(input())
A = [0] + list(map(int,input().split()))

vec = []
for i in range(1, n+1) :
	vec = vec + [[A[i], i]]
list.sort(vec)
list.reverse(vec)
# print(vec)

if vec[0][0] == 1 :
	print(""NO"")
	exit(0)

dia = 0
path = [vec[0][1]]
ans = []
bol, col, idx = 1, 1, 0
for i in vec[1:] :
	# print(i)
	if i[0] != 1 :
		ans = ans + [[path[-1], i[1]]]
		dia = dia+1
		A[path[-1]] = A[path[-1]]-1
		path += [i[1]];
		A[path[-1]] = A[path[-1]]-1
	else :
		if col == 1:
			dia = dia+1
			col = 0
			A[path[0]] -= 1
			ans = ans+ [[path[0], i[1]]]
		elif bol == 1:
			dia = dia+1
			bol = 0
			A[path[-1]] -= 1
			ans = ans + [[path[-1], i[1]]]
		else :
			while idx < len(path) and A[path[idx]] == 0 :
				idx = idx+1
			if idx == len(path) :
				print(""NO"")
				exit(0)
			A[path[idx]] = A[path[idx]] - 1;
			ans = ans + [[path[idx], i[1]]]

print(""YES"", dia)
print(len(ans))
for i in ans :
	print(i[0], i[1])





",1082_D,CODEFORCES,2903,Maximum Diameter Graph,"Graph constructive problems are back! This time the graph you are asked to build should match the following properties.
The graph is connected if and only if there exists a path between every pair of vertices.
The diameter (aka ""longest shortest path"") of a connected undirected graph is the maximum number of edges in the shortest path between any pair of its vertices.
The degree of a vertex is the number of edges incident to it.
Given a sequence of $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ construct a connected undirected graph of $$$n$$$ vertices such that:
Output the resulting graph or report that no solution exists.
The first line contains a single integer $$$n$$$ ($$$3 \le n \le 500$$$) — the number of vertices in the graph.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le n - 1$$$) — the upper limits to vertex degrees.
Print ""NO"" if no graph can be constructed under the given conditions.
Otherwise print ""YES"" and the diameter of the resulting graph in the first line.
The second line should contain a single integer $$$m$$$ — the number of edges in the resulting graph.
The $$$i$$$-th of the next $$$m$$$ lines should contain two integers $$$v_i, u_i$$$ ($$$1 \le v_i, u_i \le n$$$, $$$v_i \neq u_i$$$) — the description of the $$$i$$$-th edge. The graph should contain no multiple edges — for each pair $$$(x, y)$$$ you output, you should output no more pairs $$$(x, y)$$$ or $$$(y, x)$$$.
Here are the graphs for the first two example cases. Both have diameter of $$$2$$$.
$$$d_2 = 2 \le a_2 = 2$$$
$$$d_3 = 1 \le a_3 = 2$$$ 
$$$d_2 = 4 \le a_2 = 4$$$
","input
$$$d_3 = 1 \le a_3 = 1$$$
output
$$$d_4 = 1 \le a_4 = 1$$$ 
","constructivealgorithms, graphs, implementation",4
"# Causes TLE
# C++17 implemention -> 1062c.cpp

MOD = 1000000007

def main():
    buf = input()
    buflist = buf.split()
    n = int(buflist[0])
    q = int(buflist[1])
    buf = input()
    x = buf
    sum_list = [0] # sentinel / one indexing
    for i, deliciousness in enumerate(x):
        sum_list.append(int(deliciousness) + sum_list[i])
    enjoyment_list = [0]
    for i in range(n):
        enjoyment_list.append((enjoyment_list[i] * 2 + 1) % MOD)
    query_list = []
    for i in range(q):
        buf = input()
        buflist = buf.split()
        l = int(buflist[0]) # one indexing
        r = int(buflist[1]) # one indexing
        query_list.append((l, r))
    for i, query in enumerate(query_list):
        l = query[0]
        r = query[1]
        banhmi_count = r - l + 1
        delicious_count = sum_list[r] - sum_list[l - 1]
        non_delicious_count = banhmi_count - delicious_count
        enjoyment = 0
        # main part
        if delicious_count == 0:
            enjoyment = 0
        else:
            enjoyment += enjoyment_list[delicious_count]
            enjoyment += (enjoyment_list[banhmi_count] - enjoyment_list[delicious_count] - enjoyment_list[non_delicious_count])
            enjoyment = enjoyment % MOD
        print(enjoyment)

if __name__ == '__main__':
    main()
",1062_C,CODEFORCES,1994,Banh-mi,"JATC loves Banh-mi (a Vietnamese food). His affection for Banh-mi is so much that he always has it for breakfast. This morning, as usual, he buys a Banh-mi and decides to enjoy it in a special way.
First, he splits the Banh-mi into $$$n$$$ parts, places them on a row and numbers them from $$$1$$$ through $$$n$$$. For each part $$$i$$$, he defines the deliciousness of the part as $$$x_i \in \{0, 1\}$$$. JATC's going to eat those parts one by one. At each step, he chooses arbitrary remaining part and eats it. Suppose that part is the $$$i$$$-th part then his enjoyment of the Banh-mi will increase by $$$x_i$$$ and the deliciousness of all the remaining parts will also increase by $$$x_i$$$. The initial enjoyment of JATC is equal to $$$0$$$.
For example, suppose the deliciousness of $$$3$$$ parts are $$$[0, 1, 0]$$$. If JATC eats the second part then his enjoyment will become $$$1$$$ and the deliciousness of remaining parts will become $$$[1, \_, 1]$$$. Next, if he eats the first part then his enjoyment will become $$$2$$$ and the remaining parts will become $$$[\_, \_, 2]$$$. After eating the last part, JATC's enjoyment will become $$$4$$$.
However, JATC doesn't want to eat all the parts but to save some for later. He gives you $$$q$$$ queries, each of them consisting of two integers $$$l_i$$$ and $$$r_i$$$. For each query, you have to let him know what is the maximum enjoyment he can get if he eats all the parts with indices in the range $$$[l_i, r_i]$$$ in some order.
All the queries are independent of each other. Since the answer to the query could be very large, print it modulo $$$10^9+7$$$.
The first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \le n, q \le 100\,000$$$).
The second line contains a string of $$$n$$$ characters, each character is either '0' or '1'. The $$$i$$$-th character defines the deliciousness of the $$$i$$$-th part.
Each of the following $$$q$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the segment of the corresponding query.
Print $$$q$$$ lines, where $$$i$$$-th of them contains a single integer — the answer to the $$$i$$$-th query modulo $$$10^9 + 7$$$.
","input
In the first example: 
output
In the second example, any order of eating parts leads to the same answer.
","greedy, implementation, math",3
"n = int(input())
game = list(map(int, input().split()))
game.append(-1)
game.sort()
bitSum = game[1] % 2
rep = False
for i in range(1, n):
    bitSum += game[i + 1] % 2
    if game[i] == game[i + 1]:
        if rep:
            print('cslnb')
            exit(0)
        else:
            if game[i - 1] == game[i] - 1:
                print('cslnb')
                exit(0)
            rep = True
Goal = ((n * (n - 1)) / 2) % 2
if (bitSum + Goal) % 2 == 0:
    print('cslnb')
else:
    print('sjfnb')",1190_B,CODEFORCES,2951,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
",games,4
"from sys import stdin
from itertools import combinations
n, l, r , x = map(int, stdin.readline().rstrip().split("" ""))
li = list(map(int, stdin.readline().rstrip().split("" "")))
z = []
ans = 0
for i in range(2, n+1):
    z += list(combinations(li, i))

for i in z:
    a = sorted(i)
    if a[-1]-a[0]>=x and r >= sum(a) >= l:
        ans+=1

print(ans)",0550_B,CODEFORCES,4492,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"S = input()
best = 0
for i in range(len(S)):
    for j in range(i+1, len(S)+1):
        s = S[i:j]
        c = 0
        for k in range(len(S)):
            if S[k:].startswith(s): c += 1
        if c >= 2: 
            best = max(best, len(s))
print(best)",0023_A,CODEFORCES,3693,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n = read_int()
    s = read()
    stones = 0
    for c in s:
        if c == '+':
            stones += 1
        else:
            stones -= 1
            if stones < 0:
                stones = 0
    write(stones)

main()
",1159_A,CODEFORCES,2109,A pile of stones,"Vasya has a pile, that consists of some number of stones. $$$n$$$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.
You are given $$$n$$$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.
The first line contains one positive integer $$$n$$$ — the number of operations, that have been made by Vasya ($$$1 \leq n \leq 100$$$).
The next line contains the string $$$s$$$, consisting of $$$n$$$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $$$i$$$-th operation, $$$s_i$$$ is equal to ""-"" (without quotes), if added, $$$s_i$$$ is equal to ""+"" (without quotes).
Print one integer — the minimal possible number of stones that can be in the pile after these $$$n$$$ operations.
In the first test, if Vasya had $$$3$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$0$$$. It is impossible to have less number of piles, so the answer is $$$0$$$. Please notice, that the number of stones at the beginning can't be less, than $$$3$$$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).
In the second test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$4$$$. It is impossible to have less number of piles because after making $$$4$$$ operations the number of stones in the pile increases on $$$4$$$ stones. So, the answer is $$$4$$$.
","input
In the third test, if Vasya had $$$1$$$ stone in the pile at the beginning, after making operations the number of stones will be equal to $$$1$$$. It can be proved, that it is impossible to have less number of stones after making the operations.
output
In the fourth test, if Vasya had $$$0$$$ stones in the pile at the beginning, after making operations the number of stones will be equal to $$$3$$$.
","implementation, math",3
"n,k=map(int,input().split())
s=[["".""]*n for i in range(4)]
if k%2==0:
  for j in range(1,n-1):
    if k==0:
      break
    s[1][j]=""#""
    s[2][j]=""#""
    k-=2
else:
  cen=n//2
  s[1][cen]=""#""
  k-=1
  for i in range(1,3):
    for j in range(1,cen):
      if k>0:
        k-=2
        s[i][j]=s[i][-j-1]=""#""
if k==0:
  print(""YES"")
  for i in range(4):
    print("""".join(s[i]))
else:
  print(""NO"")",0980_B,CODEFORCES,1664,Marlin,"The city of Fishtopia can be imagined as a grid of $$$4$$$ rows and an odd number of columns. It has two main villages; the first is located at the top-left cell $$$(1,1)$$$, people who stay there love fishing at the Tuna pond at the bottom-right cell $$$(4, n)$$$. The second village is located at $$$(4, 1)$$$ and its people love the Salmon pond at $$$(1, n)$$$.
The mayor of Fishtopia wants to place $$$k$$$ hotels in the city, each one occupying one cell. To allow people to enter the city from anywhere, hotels should not be placed on the border cells.
A person can move from one cell to another if those cells are not occupied by hotels and share a side.
Can you help the mayor place the hotels in a way such that there are equal number of shortest paths from each village to its preferred pond?
The first line of input contain two integers, $$$n$$$ and $$$k$$$ ($$$3 \leq n \leq 99$$$, $$$0 \leq k \leq 2\times(n-2)$$$), $$$n$$$ is odd, the width of the city, and the number of hotels to be placed, respectively.
","input
Print ""YES"", if it is possible to place all the hotels in a way that satisfies the problem statement, otherwise print ""NO"".
output
If it is possible, print an extra $$$4$$$ lines that describe the city, each line should have $$$n$$$ characters, each of which is ""#"" if that cell has a hotel on it, or ""."" if not.
",constructivealgorithms,3
"from math import ceil, log
from heapq import heappop, heappush, heapify
t = 1
for test in range(t):
    n,k = map(int, input().split())
    p = list(map(int, input().split()))
    c = list(map(int, input().split()))
    arr = [i for i in sorted(enumerate(p), key=lambda x:x[1])]
    maxcoins = [0 for i in range(k)]
    heapify(maxcoins)
    ans = list(p)
    tmpSum = 0
    tmpSum2 = 0
    prev = arr[0][1]
    for ind, power in arr:
        if power>prev:
            ans[ind] = tmpSum+c[ind]
            tmpSum2 = tmpSum
        else:
            ans[ind] = tmpSum2+c[ind]
        heappush(maxcoins, c[ind])
        tmpSum+=c[ind]
        tmpSum-=heappop(maxcoins)
    print(*ans)




    

",0994_B,CODEFORCES,2645,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings",4
"ch_0={0:[0,1,2],2:[2],1:[1],3:[1,2,3]}
ch_1={0:[3],3:[0],1:[0,3],2:[0,3]}
ch_2={0:[],3:[],2:[1],1:[2]}
N=998244353
n,k=map(int,input().strip().split("" ""))
dp=[[[0]*4 for j in range(k+5)] for i in range(n+5)]
dp[0][1][3]=1
dp[0][1][0]=1
dp[0][2][1]=1
dp[0][2][2]=1

for i in range(1,n):
    for j in range(1,k+1):
        for mask in range(4):
            for t in ch_0[mask]:
                dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j][t])%N
            if j>1:
                for t in ch_1[mask]:
                    dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-1][t])%N
                if j>2:
                    for t in ch_2[mask]:
                        dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-2][t])%N
ans=0
for mask in range(4):
    ans=(ans+dp[n-1][k][mask])%N
print(ans)
",1051_D,CODEFORCES,4586,Bicolorings,"You are given a grid, consisting of $$$2$$$ rows and $$$n$$$ columns. Each cell of this grid should be colored either black or white.
Two cells are considered neighbours if they have a common border and share the same color. Two cells $$$A$$$ and $$$B$$$ belong to the same component if they are neighbours, or if there is a neighbour of $$$A$$$ that belongs to the same component with $$$B$$$.
Let's call some bicoloring beautiful if it has exactly $$$k$$$ components.
Count the number of beautiful bicolorings. The number can be big enough, so print the answer modulo $$$998244353$$$.
The only line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 1000$$$, $$$1 \le k \le 2n$$$) — the number of columns in a grid and the number of components required.
","input
Print a single integer — the number of beautiful bicolorings modulo $$$998244353$$$.
output
One of possible bicolorings in sample $$$1$$$:
","bitmasks, dp",7
"MAXN = 200001
n, m = map(int, input().split(' '))
s = list(map(int, input().split(' ')))

f = [0 for i in range(n+1)]
count = [0 for i in range(-MAXN, MAXN+1)]

f[0] = 0

last = 0
res = 0

#print(n, m, s)

for i in range(1, n+1):
    if s[i-1] == m:
        for j in range(last, i):
            count[f[j]] += 1
        last = i

    if s[i-1] > m:
        f[i] = f[i-1] - 1
    else:
        f[i] = f[i-1] + 1

    #print(i, last, count[f[i]] + count[f[i]-1])
    res += count[f[i]] + count[f[i]-1]    

#print(f)
print(res)



",1005_E1,CODEFORCES,2705,Median on Segments (Permutations Edition),"You are given a permutation $$$p_1, p_2, \dots, p_n$$$. A permutation of length $$$n$$$ is a sequence such that each integer between $$$1$$$ and $$$n$$$ occurs exactly once in the sequence.
Find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of the median of $$$p_l, p_{l+1}, \dots, p_r$$$ is exactly the given number $$$m$$$.
The median of a sequence is the value of the element which is in the middle of the sequence after sorting it in non-decreasing order. If the length of the sequence is even, the left of two middle elements is used.
For example, if $$$a=[4, 2, 7, 5]$$$ then its median is $$$4$$$ since after sorting the sequence, it will look like $$$[2, 4, 5, 7]$$$ and the left of two middle elements is equal to $$$4$$$. The median of $$$[7, 1, 2, 9, 6]$$$ equals $$$6$$$ since after sorting, the value $$$6$$$ will be in the middle of the sequence.
Write a program to find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of the median of $$$p_l, p_{l+1}, \dots, p_r$$$ is exactly the given number $$$m$$$.
The first line contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 2\cdot10^5$$$, $$$1 \le m \le n$$$) — the length of the given sequence and the required value of the median.
The second line contains a permutation $$$p_1, p_2, \dots, p_n$$$ ($$$1 \le p_i \le n$$$). Each integer between $$$1$$$ and $$$n$$$ occurs in $$$p$$$ exactly once.
","input
Print the required number.
output
In the first example, the suitable pairs of indices are: $$$(1, 3)$$$, $$$(2, 2)$$$, $$$(2, 3)$$$ and $$$(2, 4)$$$.
",sortings,4
"def bs(n, k, lo, hi):
    while lo <= hi: 
        mid = (hi + lo)//2
        summ = ((k * (k + 1))//2 - 1) - (((mid-1) * (mid))//2 -1) - (k-2)
        if summ == n: return k - mid + 1
        elif summ > n: lo = mid + 1            
        elif summ < n: hi = mid - 1
    if summ > n: mid += 1
    return k - mid + 1


def solve():
    n, k = map(int, input().split())
    if n == 1: return 0
    elif (k * (k + 1)//2) - (k-2) <= n: return -1
    elif k >= n: return 1
    else: return bs(n, k, 2, k)

print(solve())",0287_B,CODEFORCES,941,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"# cook your dish here
n=int(input())
l=[int(x) for x in input().strip().split()]
l1=sorted(l)
c=0
for i in range(n):
    if(l[i]!=l1[i]):
        c+=1
if(c<=2):
    print(""YES"")
else:
    print(""NO"")",0220_A,CODEFORCES,2360,Little Elephant and Problem,"The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array a of length n and possibly swapped some elements of the array.
The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array a, only if array a can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.
Help the Little Elephant, determine if he could have accidentally changed the array a, sorted by non-decreasing, himself.
The first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.
Note that the elements of the array are not necessarily distinct numbers.
In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.
In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".
","input
In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".
output
In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".
","implementation, sortings",4
"'''

                            Online Python Compiler.
                Code, Compile, Run and Debug python program online.
Write your code in this editor and press ""Run"" button to execute it.

'''
n,kk=map(int,input().split())
s=input()
if(s==s[::-1] or s!=s[::-1]):
    k=""""
    l=0
    for i in reversed(range(1,n)):
        k=s[i]+k
        #print(k)
        if(s.startswith(k)):
            l=len(k)
    ss=s[l:]
    fs=s+(ss*(kk-1))
    print(fs)
        
",1029_A,CODEFORCES,3445,Many Equal Substrings,"You are given a string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters and an integer number $$$k$$$.
Let's define a substring of some string $$$s$$$ with indices from $$$l$$$ to $$$r$$$ as $$$s[l \dots r]$$$.
Your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ positions $$$i$$$ such that $$$s[i \dots i + n - 1] = t$$$. In other words, your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
It is guaranteed that the answer is always unique.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 50$$$) — the length of the string $$$t$$$ and the number of substrings.
The second line of the input contains the string $$$t$$$ consisting of exactly $$$n$$$ lowercase Latin letters.
","input
Print such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
output
It is guaranteed that the answer is always unique.
","implementation, strings",5
"q = int(input())
for i in range(q):
    x, y, k = map(int, input().split())
    if x > y: x, y = y, x
    m = y
    d = y
    if (y - x) % 2 == 1:
        d -= 1
    if k < m:
        print(-1)
        continue
    r = k - m
    if r % 2 != 0:
        r -= 1
        if d != m:
            d += 1
        else:
            d -= 1
    d += r
    print(d)
",1036_B,CODEFORCES,476,Diagonal Walking v,"Mikhail walks on a Cartesian plane. He starts at the point $$$(0, 0)$$$, and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $$$(0, 0)$$$, he can go to any of the following points in one move: 
If Mikhail goes from the point $$$(x1, y1)$$$ to the point $$$(x2, y2)$$$ in one move, and $$$x1 \ne x2$$$ and $$$y1 \ne y2$$$, then such a move is called a diagonal move.
Mikhail has $$$q$$$ queries. For the $$$i$$$-th query Mikhail's target is to go to the point $$$(n_i, m_i)$$$ from the point $$$(0, 0)$$$ in exactly $$$k_i$$$ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in $$$k_i$$$ moves.
Note that Mikhail can visit any point any number of times (even the destination point!).
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 10^4$$$) — the number of queries.
Then $$$q$$$ lines follow. The $$$i$$$-th of these $$$q$$$ lines contains three integers $$$n_i$$$, $$$m_i$$$ and $$$k_i$$$ ($$$1 \le n_i, m_i, k_i \le 10^{18}$$$) — $$$x$$$-coordinate of the destination point of the query, $$$y$$$-coordinate of the destination point of the query and the number of moves in the query, correspondingly.
Print $$$q$$$ integers. The $$$i$$$-th integer should be equal to -1 if Mikhail cannot go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in exactly $$$k_i$$$ moves described above. Otherwise the $$$i$$$-th integer should be equal to the the maximum number of diagonal moves among all possible movements.
One of the possible answers to the first test case: $$$(0, 0) \to (1, 0) \to (1, 1) \to (2, 2)$$$.
","input
One of the possible answers to the second test case: $$$(0, 0) \to (0, 1) \to (1, 2) \to (0, 3) \to (1, 4) \to (2, 3) \to (3, 2) \to (4, 3)$$$.
output
In the third test case Mikhail cannot reach the point $$$(10, 1)$$$ in 9 moves.
",math,1
"from math import ceil
def test(f):
    for i in range(n):
        if (r1+ f) > f * lift[i]:
            return 0
        f -= (r1 + f) / lift[i]
        if (r1+ f) > f * land[i + 1]:
            return 0
        f -= (r1 + f) / land[i + 1]
    return 1
p=int(input())
total_wgt=int(input());r1=total_wgt
lift=list(map(int,input().split()))
land=list(map(int,input().split()));n=len(land);ans=1e20
lift+=[lift[0]];land+=[land[0]]
l=0.0;r=1e20
for i in range(1000):
  mid=(l+r)/2.0
  #print(mid)
  if test(mid):r=mid
  else:l=mid
if r<1e19:
    print('%.17f' %r)
else:
    print(-1)
",1010_A,CODEFORCES,1818,Fly,"Natasha is going to fly on a rocket to Mars and return to Earth. Also, on the way to Mars, she will land on $$$n - 2$$$ intermediate planets. Formally: we number all the planets from $$$1$$$ to $$$n$$$. $$$1$$$ is Earth, $$$n$$$ is Mars. Natasha will make exactly $$$n$$$ flights: $$$1 \to 2 \to \ldots n \to 1$$$.
Flight from $$$x$$$ to $$$y$$$ consists of two phases: take-off from planet $$$x$$$ and landing to planet $$$y$$$. This way, the overall itinerary of the trip will be: the $$$1$$$-st planet $$$\to$$$ take-off from the $$$1$$$-st planet $$$\to$$$ landing to the $$$2$$$-nd planet $$$\to$$$ $$$2$$$-nd planet $$$\to$$$ take-off from the $$$2$$$-nd planet $$$\to$$$ $$$\ldots$$$ $$$\to$$$ landing to the $$$n$$$-th planet $$$\to$$$ the $$$n$$$-th planet $$$\to$$$ take-off from the $$$n$$$-th planet $$$\to$$$ landing to the $$$1$$$-st planet $$$\to$$$ the $$$1$$$-st planet.
The mass of the rocket together with all the useful cargo (but without fuel) is $$$m$$$ tons. However, Natasha does not know how much fuel to load into the rocket. Unfortunately, fuel can only be loaded on Earth, so if the rocket runs out of fuel on some other planet, Natasha will not be able to return home. Fuel is needed to take-off from each planet and to land to each planet. It is known that $$$1$$$ ton of fuel can lift off $$$a_i$$$ tons of rocket from the $$$i$$$-th planet or to land $$$b_i$$$ tons of rocket onto the $$$i$$$-th planet. 
For example, if the weight of rocket is $$$9$$$ tons, weight of fuel is $$$3$$$ tons and take-off coefficient is $$$8$$$ ($$$a_i = 8$$$), then $$$1.5$$$ tons of fuel will be burnt (since $$$1.5 \cdot 8 = 9 + 3$$$). The new weight of fuel after take-off will be $$$1.5$$$ tons. 
Please note, that it is allowed to burn non-integral amount of fuel during take-off or landing, and the amount of initial fuel can be non-integral as well.
Help Natasha to calculate the minimum mass of fuel to load into the rocket. Note, that the rocket must spend fuel to carry both useful cargo and the fuel itself. However, it doesn't need to carry the fuel which has already been burnt. Assume, that the rocket takes off and lands instantly.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 1000$$$) — number of planets.
The second line contains the only integer $$$m$$$ ($$$1 \le m \le 1000$$$) — weight of the payload.
The third line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 1000$$$), where $$$a_i$$$ is the number of tons, which can be lifted off by one ton of fuel.
The fourth line contains $$$n$$$ integers $$$b_1, b_2, \ldots, b_n$$$ ($$$1 \le b_i \le 1000$$$), where $$$b_i$$$ is the number of tons, which can be landed by one ton of fuel. 
It is guaranteed, that if Natasha can make a flight, then it takes no more than $$$10^9$$$ tons of fuel.
If Natasha can fly to Mars through $$$(n - 2)$$$ planets and return to Earth, print the minimum mass of fuel (in tons) that Natasha should take. Otherwise, print a single number $$$-1$$$.
It is guaranteed, that if Natasha can make a flight, then it takes no more than $$$10^9$$$ tons of fuel.
The answer will be considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$. Formally, let your answer be $$$p$$$, and the jury's answer be $$$q$$$. Your answer is considered correct if $$$\frac{|p - q|}{\max{(1, |q|)}} \le 10^{-6}$$$.
Let's consider the first example.
","input
Initially, the mass of a rocket with fuel is $$$22$$$ tons.
output
In the second case, the rocket will not be able even to take off from Earth.
","binarysearch, math",3
"import sys, os
from io import BytesIO, IOBase
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) 

mod = pow(10, 9) + 7
mod2 = 998244353
        
def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True
 
n, m, k = mp()
hor = [lmp() for i in range(n)]
ver = [lmp() for i in range(n-1)]
if k%2:
    ml = l2d(n, m, -1)
    for i in ml: print(*i)
    exit()
k//=2
dp = [l2d(n, m) for i in range(k+1)]
for f in range(1, k+1):
    for i in range(n):
        for j in range(m):
            a = inf
            if i!=0:
                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])
            if i!=n-1:
                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])
            if j!=0:
                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])
            if j!=m-1:
                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])
            dp[f][i][j] = a
for i in dp[-1]:
    print(*i)",1517_D,CODEFORCES,4111,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"def power(x, y, p) : 
    res = 1     # Initialize result 
  
    # Update x if it is more 
    # than or equal to p 
    x = x % p  
  
    while (y > 0) : 
          
        # If y is odd, multiply 
        # x with result 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
  
        # y must be even now 
        y = y >> 1      # y = y/2 
        x = (x * x) % p 
          
    return res
    
x,k = map(int,input().split())
if x==0:
    print(0)
else:
    ans = power(2,k,1000000007)
    ans = ans * ((2*x)-1)
    ans = ans+1
    ans=ans%1000000007
    print(ans)",0992_C,CODEFORCES,1133,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import bisect
from itertools import accumulate, count
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
 
def input(): return sys.stdin.readline().rstrip(""\r\n"")
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
def SieveOfEratosthenes(n):
    prime = []
    primes = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:
 
        if primes[p] == True:
            prime.append(p)
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    primes[1]=False
    primes[0]=False
    return primes
def primefactors(n):
    fac=[]
    while(n%2==0):
        fac.append(2)
        n=n//2
    for i in range(3,int(math.sqrt(n))+2):
        while(n%i==0):
            fac.append(i)
            n=n//i
    if n>1:
        fac.append(n)
    return fac
def factors(n):
    fac=set()
    fac.add(1)
    fac.add(n)
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            fac.add(i)
            fac.add(n//i)
    return list(fac)
def NcR(n, r):
     
    p = 1
    k = 1
    if (n - r < r):
        r = n - r
 
    if (r != 0):
        while (r):
            p *= n
            k *= r
            m = math.gcd(p, k)
            p //= m
            k //= m
 
            n -= 1
            r -= 1
    else:
        p = 1
    return p
def Log2(x):
    if x == 0:
        return False;
 
    return (math.log10(x) /
            math.log10(2));
def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) ==
            math.floor(Log2(n)));
#--------------------------------------------------------codeby apurva3455/AD18
n, r = map(int, input().split())
x = [int(i) for i in input().split()]
c = []
 
 
for i in range(n):
    k = r
    for x1, j in c:
        d = abs(x[i] - x1)
        if d <= 2 * r:
            k = max(k, j + (4 * r ** 2 - d * d) ** 0.5)
    c.append([x[i], k])
    print(k)
     ",0908_C,CODEFORCES,3048,New Year and Curling,"Carol is currently curling.
She has n disks each with radius r on the 2D plane. 
Initially she has all these disks above the line y = 10100.
She then will slide the disks towards the line y = 0 one by one in order from 1 to n. 
When she slides the i-th disk, she will place its center at the point (xi, 10100). She will then push it so the disk’s y coordinate continuously decreases, and x coordinate stays constant. The disk stops once it touches the line y = 0 or it touches any previous disk. Note that once a disk stops moving, it will not move again, even if hit by another disk. 
Compute the y-coordinates of centers of all the disks after all disks have been pushed.
The first line will contain two integers n and r (1 ≤ n, r ≤ 1 000), the number of disks, and the radius of the disks, respectively.
The next line will contain n integers x1, x2, ..., xn (1 ≤ xi ≤ 1 000) — the x-coordinates of the disks.
Print a single line with n numbers. The i-th number denotes the y-coordinate of the center of the i-th disk. The output will be accepted if it has absolute or relative error at most 10 - 6.
Namely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if  for all coordinates.
","input
The final positions of the disks will look as follows:
output
In particular, note the position of the last disk. 
","bruteforce, geometry, implementation, math",5
"n, l, r, x = map(int, input().split())
arr = list(map(int, input().split()))
res = 0
for j in range(1, 2**n):
    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]
    s = sum(a)
    res += (max(a) - min(a) >= x and s >= l and s <= r)
print(res)
",0550_B,CODEFORCES,4447,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"from sys import stdin, stdout 
input = stdin.readline
 
n,m,K = map(int,input().split())
edges = []
for i in range(n):
    edges.append([[]])
    lis = list(map(int,input().split()))
    for j in range(m-1):
        edges[i][j].append((1,0,lis[j]))
        edges[i].append([])
        edges[i][j+1].append((-1,0,lis[j]))
for i in range(n-1):
    lis = list(map(int,input().split()))
    for j in range(m):
        edges[i][j].append((0,1,lis[j]))
        edges[i+1][j].append((0,-1,lis[j]))

if K%2==1:
    lis = []
    for i in range(n):
        lis.append([-1]*m)
else:
    lis = []
    for i in range(n):
        lis.append([0]*m)
        
    for k in range(1,(K//2)+1):
        new_lis = []
        for i in range(n):
            new_lis.append([0]*m)
        for i in range(n):
            for j in range(m):
                dist = []
                for e in edges[i][j]:
                    # print(e,i,j,lis)
                    dist.append(e[2] + lis[i+e[1]][j+e[0]])
                new_lis[i][j] = min(dist)
        lis = new_lis
    for i in range(n):
        for j in range(m):
            lis[i][j] *= 2
            
for i in lis:
    print(*i)",1517_D,CODEFORCES,4110,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"R,G,B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse =True)
g = sorted(list(map(int, input().split())), reverse =True)
b = sorted(list(map(int, input().split())), reverse =True)
def f(x,y,z):
    m1 = 0
    m2 = 0
    m3 = 0
    if(x<R and y<G):
        if(dpt[x+1][y+1][z]==-1):
            dpt[x+1][y+1][z] = f(x+1,y+1,z)
        m1 = r[x]*g[y] + dpt[x+1][y+1][z]
    if(y<G and z<B):
        if(dpt[x][y+1][z+1]==-1):
            dpt[x][y+1][z+1] = f(x,y+1,z+1)
        m2 = g[y]*b[z] + dpt[x][y+1][z+1]
    if(z<B and x<R):
        if(dpt[x+1][y][z+1]==-1):
            dpt[x+1][y][z+1] = f(x+1,y,z+1)
        m3 = r[x]*b[z] + dpt[x+1][y][z+1]
    dpt[x][y][z] = max(m1,m2,m3)
    return dpt[x][y][z]
dpt = [[[-1 for _ in range(B+1)]for _ in range(G+1)]for _ in range(R+1)]
print(f(0,0,0))",1398_D,CODEFORCES,3912,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"from sys import stdin,stdout
stdout.flush()
def qu(a,b):
    print(""?"",a,b)
    return int(input())
a=0
b=0
big=qu(a,b)
for i in range(29,-1,-1):
    x=2**i
    f=qu(a+x,b)
    l=qu(a,b+x)
    if l==f:
        if big==1:
            a+=x
        else:
            b+=x
        big=f
    elif f==-1:
        a+=x
        b+=x   
print(""!"",a,b)

",1088_D,CODEFORCES,1225,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",2
"a=[]
n=int(input())
for i in range(n):
    l,r=map(int,input().split())
    a.append([l,r,i+1])
a.sort(key=lambda x:(x[0],-x[1]))
r=0
iid=0
f=1
for i in range(n):
    if(r>=a[i][1]):
        f=0
        print(a[i][2],a[iid][2])
        break;
    else:
        r=a[i][1]
        iid=i;
if(f):
    print(""-1 -1"")
",0976_C,CODEFORCES,2512,Nested Segments,"You are given a sequence a1, a2, ..., an of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment ai lies within segment aj.
Segment [l1, r1] lies within segment [l2, r2] iff l1 ≥ l2 and r1 ≤ r2.
Print indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
The first line contains one integer n (1 ≤ n ≤ 3·105) — the number of segments.
Each of the next n lines contains two integers li and ri (1 ≤ li ≤ ri ≤ 109) — the i-th segment.
","input
Print two distinct indices i and j such that segment ai lies within segment aj. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
output
In the first example the following pairs are considered correct:
","greedy, implementation, sortings",4
"#!/usr/bin/python3
#Businessmen Problems
ans={}
for _ in range(int(input())):
    a,b=map(int,input().split())
    ans[a]=b
for _ in range(int(input())):
    a,b=map(int,input().split())
    if a in ans:
        ans[a]=max(ans[a],b)
    else:
        ans[a]=b
print(sum(ans.values()))
",0981_B,CODEFORCES,2530,Businessmen Problems,"Two famous competing companies ChemForces and TopChemist decided to show their sets of recently discovered chemical elements on an exhibition. However they know that no element should be present in the sets of both companies.
In order to avoid this representatives of both companies decided to make an agreement on the sets the companies should present. The sets should be chosen in the way that maximizes the total income of the companies.
All elements are enumerated with integers. The ChemForces company has discovered $$$n$$$ distinct chemical elements with indices $$$a_1, a_2, \ldots, a_n$$$, and will get an income of $$$x_i$$$ Berland rubles if the $$$i$$$-th element from this list is in the set of this company.
The TopChemist company discovered $$$m$$$ distinct chemical elements with indices $$$b_1, b_2, \ldots, b_m$$$, and it will get an income of $$$y_j$$$ Berland rubles for including the $$$j$$$-th element from this list to its set.
In other words, the first company can present any subset of elements from $$$\{a_1, a_2, \ldots, a_n\}$$$ (possibly empty subset), the second company can present any subset of elements from $$$\{b_1, b_2, \ldots, b_m\}$$$ (possibly empty subset). There shouldn't be equal elements in the subsets.
Help the representatives select the sets in such a way that no element is presented in both sets and the total income is the maximum possible.
The first line contains a single integer $$$n$$$ ($$$1 \leq n \leq 10^5$$$)  — the number of elements discovered by ChemForces.
The $$$i$$$-th of the next $$$n$$$ lines contains two integers $$$a_i$$$ and $$$x_i$$$ ($$$1 \leq a_i \leq 10^9$$$, $$$1 \leq x_i \leq 10^9$$$)  — the index of the $$$i$$$-th element and the income of its usage on the exhibition. It is guaranteed that all $$$a_i$$$ are distinct.
The next line contains a single integer $$$m$$$ ($$$1 \leq m \leq 10^5$$$)  — the number of chemicals invented by TopChemist.
The $$$j$$$-th of the next $$$m$$$ lines contains two integers $$$b_j$$$ and $$$y_j$$$, ($$$1 \leq b_j \leq 10^9$$$, $$$1 \leq y_j \leq 10^9$$$)  — the index of the $$$j$$$-th element and the income of its usage on the exhibition. It is guaranteed that all $$$b_j$$$ are distinct.
Print the maximum total income you can obtain by choosing the sets for both companies in such a way that no element is presented in both sets.
","input
In the first example ChemForces can choose the set ($$$3, 7$$$), while TopChemist can choose ($$$1, 2, 4$$$). This way the total income is $$$(10 + 2) + (4 + 4 + 4) = 24$$$.
output
In the second example ChemForces can choose the only element $$$10^9$$$, while TopChemist can choose ($$$14, 92, 35$$$). This way the total income is $$$(239) + (15 + 65 + 89) = 408$$$.
",sortings,4
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
    print(""?"", xr + cb, cb)
    ans11 = input()
    print(""?"", xr, cb)
    if ans11 == ans00:
        ans01 = input()
        if ans01 == '1':
            a += cb
            b += cb
    else:
        ans00 = input()
        if ans11 == '1':
            b += cb
        else:
            a += cb
        xr += cb
    cb //= 2
print(""!"", a, b)",1088_D,CODEFORCES,655,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",1
"# ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------- fast io --------------------
from math import gcd, ceil

def prod(a, mod=10**9+7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    n = int(input())
    a = list(map(int, input().split()))
    dp = [[False]*(n+2) for i in range(n+2)]
    # dp[i][j] -> Can a[i-j] be reduced to a single element.
    # If yes, then dp[i][j] contains value of that element. Else, false.
    dp2 = [[600]*(n+2) for i in range(n+2)]
    for i in range(n):
        dp[i][i] = a[i]
        dp2[i][i] = 1
    for diff in range(1, n):
        for i in range(n-diff):
            # i -> i+diff
            for j in range(i, i+diff):
                if dp[i][j] == dp[j+1][i+diff] and dp[i][j]:
                    dp[i][i+diff] = dp[i][j] + 1
                    dp2[i][i+diff] = 1
                dp2[i][i+diff] = min(dp2[i][i+diff], dp2[i][j]+dp2[j+1][i+diff])
            if not dp2[i][i+diff]:
                dp2[i][i+diff] = min(dp2[i+1][i+diff]+1, dp2[i][i+diff-1] + 1)
    print(dp2[0][n-1])",1312_E,CODEFORCES,3819,Array Shrinking,"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation any number of times:
After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array $$$a$$$ you can get?
The first line contains the single integer $$$n$$$ ($$$1 \le n \le 500$$$) — the initial length of the array $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$) — the initial array $$$a$$$.
Print the only integer — the minimum possible length you can get after performing the operation described above any number of times.
In the first test, this is one of the optimal sequences of operations: $$$4$$$ $$$3$$$ $$$2$$$ $$$2$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$\rightarrow$$$ $$$5$$$ $$$3$$$.
","input
In the second test, this is one of the optimal sequences of operations: $$$3$$$ $$$3$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$5$$$ $$$4$$$ $$$\rightarrow$$$ $$$6$$$ $$$4$$$.
output
In the third and fourth tests, you can't perform the operation at all.
","dp, greedy",6
"n = int(input())
m = int(n**.5)
a = []

for i in range(0, n, m):
    for j in range(i, min(i+m, n)):
        a.append(min(i+m, n)-j + i)

print(' '.join(str(_) for _ in a))
",1017_C,CODEFORCES,1847,The Phone Number,"Mrs. Smith is trying to contact her husband, John Smith, but she forgot the secret phone number!
The only thing Mrs. Smith remembered was that any permutation of $$$n$$$ can be a secret phone number. Only those permutations that minimize secret value might be the phone of her husband.
The sequence of $$$n$$$ integers is called a permutation if it contains all integers from $$$1$$$ to $$$n$$$ exactly once.
The secret value of a phone number is defined as the sum of the length of the longest increasing subsequence (LIS) and length of the longest decreasing subsequence (LDS). 
A subsequence $$$a_{i_1}, a_{i_2}, \ldots, a_{i_k}$$$ where $$$1\leq i_1 < i_2 < \ldots < i_k\leq n$$$ is called increasing if $$$a_{i_1} < a_{i_2} < a_{i_3} < \ldots < a_{i_k}$$$. If $$$a_{i_1} > a_{i_2} > a_{i_3} > \ldots > a_{i_k}$$$, a subsequence is called decreasing. An increasing/decreasing subsequence is called longest if it has maximum length among all increasing/decreasing subsequences.
For example, if there is a permutation $$$[6, 4, 1, 7, 2, 3, 5]$$$, LIS of this permutation will be $$$[1, 2, 3, 5]$$$, so the length of LIS is equal to $$$4$$$. LDS can be $$$[6, 4, 1]$$$, $$$[6, 4, 2]$$$, or $$$[6, 4, 3]$$$, so the length of LDS is $$$3$$$.
Note, the lengths of LIS and LDS can be different.
So please help Mrs. Smith to find a permutation that gives a minimum sum of lengths of LIS and LDS.
The only line contains one integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the length of permutation that you need to build.
Print a permutation that gives a minimum sum of lengths of LIS and LDS. 
If there are multiple answers, print any.
","input
In the first sample, you can build a permutation $$$[3, 4, 1, 2]$$$. LIS is $$$[3, 4]$$$ (or $$$[1, 2]$$$), so the length of LIS is equal to $$$2$$$. LDS can be ony of $$$[3, 1]$$$, $$$[4, 2]$$$, $$$[3, 2]$$$, or $$$[4, 1]$$$. The length of LDS is also equal to $$$2$$$. The sum is equal to $$$4$$$. Note that $$$[3, 4, 1, 2]$$$ is not the only permutation that is valid.
output
In the second sample, you can build a permutation $$$[2, 1]$$$. LIS is $$$[1]$$$ (or $$$[2]$$$), so the length of LIS is equal to $$$1$$$. LDS is $$$[2, 1]$$$, so the length of LDS is equal to $$$2$$$. The sum is equal to $$$3$$$. Note that permutation $$$[1, 2]$$$ is also valid.
","constructivealgorithms, greedy",3
"import atexit
import io
import sys

# Buffering IO
_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
    

def main():
    n = int(input())
    s = []
    for i in range(4):
        df = 0
        for k in range(n):
            l = input()
            for j in range(n):
                if int(l[j]) == (k + j) % 2:
                    df += 1
        if i <3 :
            input()
        s.append(df)
    
    print( min(s[0] + s[1] + n*n-s[2] + n*n-s[3],
        s[0] + s[2] + n*n-s[1] + n*n-s[3],
        s[0] + s[3] + n*n-s[1] + n*n-s[2],
        s[1] + s[2] + n*n-s[0] + n*n-s[3],
        s[1] + s[3] + n*n-s[0] + n*n-s[2],
        s[2] + s[3] + n*n-s[0] + n*n-s[1]))
        
        
    
    
    

    
if __name__ == '__main__':
    main()
        ",0961_C,CODEFORCES,3189,Chessboard,"Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into 4 pieces, each of size n by n, n is always odd. And what's even worse, some squares were of wrong color. j-th square of the i-th row of k-th piece of the board has color ak, i, j; 1 being black and 0 being white. 
Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be 2n by 2n. You are allowed to move pieces but not allowed to rotate or flip them.
The first line contains odd integer n (1 ≤ n ≤ 100) — the size of all pieces of the board. 
","input
Then 4 segments follow, each describes one piece of the board. Each consists of n lines of n characters; j-th one of i-th line is equal to 1 if the square is black initially and 0 otherwise. Segments are separated by an empty line.
output
Print one number — minimum number of squares Magnus should recolor to be able to obtain a valid chessboard.
","bitmasks, bruteforce, implementation",5
"x, y, z, t1, t2, t3 = map(int, input().split())
dp = abs(x - y) * t1;
dl = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3;
if dp < dl:
    print(""NO"")
else:
    print(""YES"")
",1054_A,CODEFORCES,502,Elevator or Stairs?,"Masha lives in a multi-storey building, where floors are numbered with positive integers. Two floors are called adjacent if their numbers differ by one. Masha decided to visit Egor. Masha lives on the floor $$$x$$$, Egor on the floor $$$y$$$ (not on the same floor with Masha).
The house has a staircase and an elevator. If Masha uses the stairs, it takes $$$t_1$$$ seconds for her to walk between adjacent floors (in each direction). The elevator passes between adjacent floors (in each way) in $$$t_2$$$ seconds. The elevator moves with doors closed. The elevator spends $$$t_3$$$ seconds to open or close the doors. We can assume that time is not spent on any action except moving between adjacent floors and waiting for the doors to open or close. If Masha uses the elevator, it immediately goes directly to the desired floor.
Coming out of the apartment on her floor, Masha noticed that the elevator is now on the floor $$$z$$$ and has closed doors. Now she has to choose whether to use the stairs or use the elevator. 
If the time that Masha needs to get to the Egor's floor by the stairs is strictly less than the time it will take her using the elevator, then she will use the stairs, otherwise she will choose the elevator.
Help Mary to understand whether to use the elevator or the stairs.
The only line contains six integers $$$x$$$, $$$y$$$, $$$z$$$, $$$t_1$$$, $$$t_2$$$, $$$t_3$$$ ($$$1 \leq x, y, z, t_1, t_2, t_3 \leq 1000$$$) — the floor Masha is at, the floor Masha wants to get to, the floor the elevator is located on, the time it takes Masha to pass between two floors by stairs, the time it takes the elevator to pass between two floors and the time it takes for the elevator to close or open the doors.
It is guaranteed that $$$x \ne y$$$.
If the time it will take to use the elevator is not greater than the time it will take to use the stairs, print «YES» (without quotes), otherwise print «NO> (without quotes).
You can print each letter in any case (upper or lower).
In the first example:
If Masha goes by the stairs, the time she spends is $$$4 \cdot 4 = 16$$$, because she has to go $$$4$$$ times between adjacent floors and each time she spends $$$4$$$ seconds. 
If she chooses the elevator, she will have to wait $$$2$$$ seconds while the elevator leaves the $$$4$$$-th floor and goes to the $$$5$$$-th. After that the doors will be opening for another $$$1$$$ second. Then Masha will enter the elevator, and she will have to wait for $$$1$$$ second for the doors closing. Next, the elevator will spend $$$4 \cdot 2 = 8$$$ seconds going from the $$$5$$$-th floor to the $$$1$$$-st, because the elevator has to pass $$$4$$$ times between adjacent floors and spends $$$2$$$ seconds each time. And finally, it will take another $$$1$$$ second before the doors are open and Masha can come out. 
Thus, all the way by elevator will take $$$2 + 1 + 1 + 8 + 1 = 13$$$ seconds, which is less than $$$16$$$ seconds, so Masha has to choose the elevator.
","input
In the second example, it is more profitable for Masha to use the stairs, because it will take $$$13$$$ seconds to use the elevator, that is more than the $$$10$$$ seconds it will takes to go by foot.
output
In the third example, the time it takes to use the elevator is equal to the time it takes to walk up by the stairs, and is equal to $$$12$$$ seconds. That means Masha will take the elevator.
",implementation,1
"s=input()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)
        
",0023_A,CODEFORCES,3737,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
def pos(n):
    t=0
    for k,v in d.items():
        if v>=n:t+=v//n
    return t>=p
for _ in range(1):#nmbr())
    p,n=lst()
    d=Counter(lst())
    ans=0
    for sel in range(1,n+1):
         if pos(sel):ans=max(ans,sel)
    print(ans)",1011_B,CODEFORCES,2726,Planning The Expedition,"Natasha is planning an expedition to Mars for $$$n$$$ people. One of the important tasks is to provide food for each participant.
The warehouse has $$$m$$$ daily food packages. Each package has some food type $$$a_i$$$.
Each participant must eat exactly one food package each day. Due to extreme loads, each participant must eat the same food type throughout the expedition. Different participants may eat different (or the same) types of food.
Formally, for each participant $$$j$$$ Natasha should select his food type $$$b_j$$$ and each day $$$j$$$-th participant will eat one food package of type $$$b_j$$$. The values $$$b_j$$$ for different participants may be different.
What is the maximum possible number of days the expedition can last, following the requirements above?
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 100$$$, $$$1 \le m \le 100$$$) — the number of the expedition participants and the number of the daily food packages available.
The second line contains sequence of integers $$$a_1, a_2, \dots, a_m$$$ ($$$1 \le a_i \le 100$$$), where $$$a_i$$$ is the type of $$$i$$$-th food package.
Print the single integer — the number of days the expedition can last. If it is not possible to plan the expedition for even one day, print 0.
","input
In the first example, Natasha can assign type $$$1$$$ food to the first participant, the same type $$$1$$$ to the second, type $$$5$$$ to the third and type $$$2$$$ to the fourth. In this case, the expedition can last for $$$2$$$ days, since each participant can get two food packages of his food type (there will be used $$$4$$$ packages of type $$$1$$$, two packages of type $$$2$$$ and two packages of type $$$5$$$).
output
In the second example, there are $$$100$$$ participants and only $$$1$$$ food package. In this case, the expedition can't last even $$$1$$$ day.
","binarysearch, bruteforce, implementation",4
"def chnge(last,cap,ini=(0,0)):
    for i in range(ini[1],last[1]):
        fin[i][ini[0]:last[0]] = [cap]*(last[0]-ini[0])

x1,y1,x2,y2,x3,y3 = map(int,input().split())
a = (max(x1,y1),[x1,y1],""A"")
b = (max(x2,y2),[x2,y2],""B"")
c = (max(x3,y3),[x3,y3],""C"")
m = max(a[0],b[0],c[0])
fin = [[""*"" for i in range(m)] for j in range(m)]

if (x1*y1 + x2*y2 + x3*y3)!=m**2:
    print(-1)
else:
    l = sorted([a]+[b]+[c],reverse = True)
    l[0][1].sort(reverse=True)
    chnge(l[0][1],l[0][2])
    ini=[0,l[0][1][1]]
    last = l[1][1]
    if m in [ini[0]+last[0],ini[1]+last[1]] and (ini[0]+last[0]+ini[1]+last[1])<=2*m:
        last = [ini[0]+last[0],ini[1]+last[1]]
    else:
        last = [ini[0] + last[1], ini[1] + last[0]]
    chnge(last,l[1][2],ini)
    chr = l[2][2]
    print(m)
    for i in fin:
        print("""".join(i).replace(""*"",chr))",0581_D,CODEFORCES,4517,Three Logos,"Three companies decided to order a billboard with pictures of their logos. A billboard is a big square board. A logo of each company is a rectangle of a non-zero area. 
Advertisers will put up the ad only if it is possible to place all three logos on the billboard so that they do not overlap and the billboard has no empty space left. When you put a logo on the billboard, you should rotate it so that the sides were parallel to the sides of the billboard.
Your task is to determine if it is possible to put the logos of all the three companies on some square billboard without breaking any of the described rules.
The first line of the input contains six positive integers x1, y1, x2, y2, x3, y3 (1 ≤ x1, y1, x2, y2, x3, y3 ≤ 100), where xi and yi determine the length and width of the logo of the i-th company respectively.
If it is impossible to place all the three logos on a square shield, print a single integer ""-1"" (without the quotes).
If it is possible, print in the first line the length of a side of square n, where you can place all the three logos. Each of the next n lines should contain n uppercase English letters ""A"", ""B"" or ""C"". The sets of the same letters should form solid rectangles, provided that:
","input
Note that the logos of the companies can be rotated for printing on the billboard. The billboard mustn't have any empty space. If a square billboard can be filled with the logos in multiple ways, you are allowed to print any of them.
output
See the samples to better understand the statement.
","bitmasks, bruteforce, constructivealgorithms, geometry, implementation, math",7
"n=int(input())

if n<=2:
    print(n)
else:
    if n%2!=0:
        print(n*(n-1)*(n-2))
    elif n%3==0:
        print((n-1)*(n-2)*(n-3))
    else:
        print(n*(n-1)*(n-3))",0235_A,CODEFORCES,71,LCM Challenge,"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.
But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than n. Can you help me to find the maximum possible least common multiple of these three integers?
The first line contains an integer n (1 ≤ n ≤ 106) — the n mentioned in the statement.
Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than n.
The least common multiple of some positive integers is the least positive integer which is multiple for each of them.
","input
The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.
output
For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.
",numbertheory,1
"def solve():
    n = int(input())
    for d in [2,4]:
        if n % d != 0:
            continue
        temp = int((n//d) ** (0.5))
        temp -= 1
        while temp*temp < n//d:
            temp += 1
        if temp*temp == n//d:
            print(""YES"")
            return
    print(""NO"")
for _ in range(int(input())):
    solve()
",1515_B,CODEFORCES,752,Phoenix and Puzzle,"Phoenix is playing with a new puzzle, which consists of $$$n$$$ identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.
The goal of the puzzle is to create a square using the $$$n$$$ pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all $$$n$$$ pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^9$$$) — the number of puzzle pieces.
For each test case, if Phoenix can create a square with the $$$n$$$ puzzle pieces, print YES. Otherwise, print NO.
For $$$n=2$$$, Phoenix can create a square like this:
","input
For $$$n=4$$$, Phoenix can create a square like this:
output
For $$$n=6$$$, it is impossible for Phoenix to create a square.
","bruteforce, geometry, math, numbertheory",1
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import Counter,deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)
def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item
from math import gcd as GCD
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N=int(readline())
A=list(map(int,readline().split()))
mod=10**9+7
m=max(A)
cnt=[0]*(m+1)
P=Prime(m)
for a,c in Counter(A).items():
    cnt[a]=c
for p in P.primes:
    for i in range(m//p,0,-1):
        cnt[i]+=cnt[i*p]
for i in range(1,m+1):
    cnt[i]=pow(2,cnt[i],mod)-1
    cnt[i]%=mod
for p in P.primes:
    for i in range(p,m+1,p):
        cnt[i//p]-=cnt[i]
        cnt[i//p]%=mod
ans=cnt[1]
print(ans)",0803_F,CODEFORCES,4548,Coprime Subsequences,"Let's call a non-empty sequence of positive integers a1, a2... ak coprime if the greatest common divisor of all elements of this sequence is equal to 1.
Given an array a consisting of n positive integers, find the number of its coprime subsequences. Since the answer may be very large, print it modulo 109 + 7.
Note that two subsequences are considered different if chosen indices are different. For example, in the array [1, 1] there are 3 different subsequences: [1], [1] and [1, 1].
The first line contains one integer number n (1 ≤ n ≤ 100000).
The second line contains n integer numbers a1, a2... an (1 ≤ ai ≤ 100000).
Print the number of coprime subsequences of a modulo 109 + 7.
","input
In the first example coprime subsequences are: 
output
In the second example all subsequences are coprime.
","bitmasks, combinatorics, numbertheory",7
"D = False

def hash(r,c):
    return str(r) + ""-"" + str(c)

def sol():
    R, C = [int(x) for x in input().split("" "")]
    m = []
    count = 0
    for _ in range(R):
        line = input()
        m.append(line)
        count += line.count(""#"")

    if D: print(""Count:"", count)

    lookup = {}
    for r in range(1, R-1):
        for c in range(1, C-1):

            if D: print(""  row,col:"", r, c)

            offset = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
            lst = []
            fail = False

            # ensure all 8 adj cells are '#'
            # if so add to
            for o in offset:

                cell = (r + o[0], c + o[1])
                if D: print(""  cell:"", cell, m[cell[0]][cell[1]])
                h = hash(cell[0], cell[1])

                if m[cell[0]][cell[1]] == ""#"":
                    if (not h in lookup):
                        lst.append(h)

                else: # . found
                    fail = True
                    break

            if not fail:
                for item in lst:
                    lookup[item] = True
                count -= len(lst)

    return ""YES"" if count == 0 else ""NO""

#for t in range(int(input())):
ans = sol()
print(ans)
",1059_B,CODEFORCES,3560,Forgery,"Student Andrey has been skipping physical education lessons for the whole term, and now he must somehow get a passing grade on this subject. Obviously, it is impossible to do this by legal means, but Andrey doesn't give up. Having obtained an empty certificate from a local hospital, he is going to use his knowledge of local doctor's handwriting to make a counterfeit certificate of illness. However, after writing most of the certificate, Andrey suddenly discovered that doctor's signature is impossible to forge. Or is it?
For simplicity, the signature is represented as an $$$n\times m$$$ grid, where every cell is either filled with ink or empty. Andrey's pen can fill a $$$3\times3$$$ square without its central cell if it is completely contained inside the grid, as shown below.
Determine whether is it possible to forge the signature on an empty $$$n\times m$$$ grid.
The first line of input contains two integers $$$n$$$ and $$$m$$$ ($$$3 \le n, m \le 1000$$$).
Then $$$n$$$ lines follow, each contains $$$m$$$ characters. Each of the characters is either '.', representing an empty cell, or '#', representing an ink filled cell.
If Andrey can forge the signature, output ""YES"". Otherwise output ""NO"".
You can print each letter in any case (upper or lower).
In the first sample Andrey can paint the border of the square with the center in $$$(2, 2)$$$.
In the second sample the signature is impossible to forge.
","input
In the third sample Andrey can paint the borders of the squares with the centers in $$$(2, 2)$$$ and $$$(3, 2)$$$: 
output
In the fourth sample Andrey can paint the borders of the squares with the centers in $$$(3, 3)$$$ and $$$(3, 5)$$$.
",implementation,5
"from heapq import heappush, heappop
n,k = map(int, input().split())
powers = list(map(int, input().split()))
coins = list(map(int, input().split()))

A = []
ans = [0] * n
for i in range(n):
    A.append((powers[i], coins[i], i))
A.sort()
h = []
total = 0
for i in range(n):
    _,c,idx = A[i]
    ans[idx] = total + c
    if len(h) < k:
        heappush(h, c)
        total += c
    elif h and h[0] < c:
        total -= heappop(h)
        heappush(h, c)
        total += c

for x in ans:
    print(x, end="" "")
print()
",0994_B,CODEFORCES,2639,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings",4
"import sys
from collections import defaultdict

readline=sys.stdin.readline

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N,Q=map(int,readline().split())
P=Prime(5*10**5)
mebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]
cnt=[0]*(5*10**5+1)
ans=0
A=list(map(int,readline().split()))
used=[False]*(N)
for _ in range(Q):
    q=int(readline())-1
    prime=list(P.Factorize(A[q]).keys())
    l=len(prime)
    for bit in range(1<<l):
        s=1
        for i in range(l):
            if bit>>i&1:
                s*=prime[i]
        if used[q]:
            cnt[s]-=1
            ans-=cnt[s]*mebius[s]
        else:
            ans+=cnt[s]*mebius[s]
            cnt[s]+=1
    if used[q]:
        used[q]=False
    else:
        used[q]=True
    print(ans)",0547_C,CODEFORCES,4414,Mike and Foam,"Mike is a bartender at Rico's bar. At Rico's, they put beer glasses in a special shelf. There are n kinds of beer at Rico's numbered from 1 to n. i-th kind of beer has ai milliliters of foam on it.
Maxim is Mike's boss. Today he told Mike to perform q queries. Initially the shelf is empty. In each request, Maxim gives him a number x. If beer number x is already in the shelf, then Mike should remove it from the shelf, otherwise he should put it in the shelf.
After each query, Mike should tell him the score of the shelf. Bears are geeks. So they think that the score of a shelf is the number of pairs (i, j) of glasses in the shelf such that i < j and  where  is the greatest common divisor of numbers a and b.
Mike is tired. So he asked you to help him in performing these requests.
The first line of input contains numbers n and q (1 ≤ n, q ≤ 2 × 105), the number of different kinds of beer and number of queries.
The next line contains n space separated integers, a1, a2, ... , an (1 ≤ ai ≤ 5 × 105), the height of foam in top of each kind of beer.
","input
The next q lines contain the queries. Each query consists of a single integer integer x (1 ≤ x ≤ n), the index of a beer that should be added or removed from the shelf.
output
For each query, print the answer for that query in one line.
","bitmasks, combinatorics, dp, math, numbertheory",7
"n,k = map(int, input().strip().split(' '))
lst = list(map(int, input().strip().split(' ')))
s=sum(lst)
s2=0
m=0
for i in range(n-1):
    s2+=lst[i]
    s-=lst[i]
    if (s2%k)+(s%k)>m:
        m=(s2%k)+(s%k)
print(m)
    
    
        
",0958_C1,CODEFORCES,1566,Encryption (easy),"Rebel spy Heidi has just obtained the plans for the Death Star from the Empire and, now on her way to safety, she is trying to break the encryption of the plans (of course they are encrypted – the Empire may be evil, but it is not stupid!). The encryption has several levels of security, and here is how the first one looks.
Heidi is presented with a screen that shows her a sequence of integers A and a positive integer p. She knows that the encryption code is a single number S, which is defined as follows:
Define the score of X to be the sum of the elements of X modulo p.
Heidi is given a sequence A that consists of N integers, and also given an integer p. She needs to split A into 2 parts such that: 
Output the sum S, which is the encryption code.
The first line of the input contains two space-separated integer N and p (2 ≤ N ≤ 100 000, 2 ≤ p ≤ 10 000) – the number of elements in A, and the modulo for computing scores, respectively.
The second line contains N space-separated integers which are the elements of A. Each integer is from the interval [1, 1 000 000].
Output the number S as described in the problem statement.
","input
In the first example, the score is maximized if the input sequence is split into two parts as (3, 4), (7, 2). It gives the total score of .
output
In the second example, the score is maximized if the first part consists of the first three elements, and the second part consists of the rest. Then, the score is .
",bruteforce,3
"n=int(input())
A=list(map(int,input().split()))

if n==1:
    print(A[0])

elif n==2:
    print(abs(A[0]-A[1]))

else:
    SUM=0
    for i in range(n):
        SUM+=abs(A[i])
    ANS=0

    for i in range(n-1):
        if ANS<SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1]):
            ANS=SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1])

    print(ANS)
",1038_D,CODEFORCES,1947,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation",3
"n = int(input())
mod = 10**9+7
dp = [0]*(n+1)
dp[0] = 1
for i in range(n):
    nx = [0]*(n+1)
    s = str(input())
    if s == 'f':
        nx[0] = 0
        for j in range(1, n+1):
            nx[j] = dp[j-1]
            nx[j] %= mod
    else:
        nx[n] = dp[n]
        for j in reversed(range(n)):
            nx[j] = nx[j+1]
            nx[j] += dp[j]
            nx[j] %= mod
    if i != n-1:
        dp = nx
print(sum(dp)%mod)
",0909_C,CODEFORCES,3070,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"R, G, B = list(map(lambda x: int(x), input().split()))
r = list(map(lambda x: int(x), input().split()))
g = list(map(lambda x: int(x), input().split()))
b = list(map(lambda x: int(x), input().split()))

def f(t):
    i, j, k = t
    return (i+1)*(G+1)*(B+1) + (j+1)*(B+1) + (k+1)

max_area = [None]*((R+1)*(G+1)*(B+1)+1)

def get_max_area(i, j, k):
    temp = f((i,j,k))
    if max_area[temp] != None:
        return max_area[temp]
    x1=x2=x3=0
    if i >= 0 and j>=0:
        x1 = get_max_area(i-1, j-1, k) + r[i]*g[j]
    if i >= 0 and k >= 0:
        x2 = get_max_area(i-1, j, k-1) + r[i]*b[k]
    if j >= 0 and k >= 0:
        x3 = get_max_area(i, j-1, k-1) + g[j]*b[k]

    max_area[temp] = max(x1, x2, x3)
    return max_area[temp]

r.sort()
g.sort()
b.sort()
print(get_max_area(R-1, G-1, B-1))
#print(max_area)    ",1398_D,CODEFORCES,3919,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"n=int(input())
a=list(map(int,input().split()))
a.sort()
lose=False
pair=False
for i in range(n-1):
    if a[i]==a[i+1]==0:
        lose=True
    if a[i]==a[i+1]:
        if pair:
            lose=True
        pair=True
        if i>=1:
            if a[i]==a[i-1]+1:
                lose=True
if lose:
    print(""cslnb"")
else:
    eventual=n*(n-1)//2
    curr=sum(a)
    if (curr-eventual)%2==0:
        print(""cslnb"")
    else:
        print(""sjfnb"")",1190_B,CODEFORCES,2952,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
",games,4
"s1=input()
s2=input()
arr=list(s1)
arr.sort(reverse=True)
if(len(s2)>len(s1)):
  t=""""
  for i in arr:
    t+=i
  print(t)
else:
  t=""""
  l =len(s1)
  for i in range(l):
    index=-1
    ma = -1
    for j in range(len(arr)):
      temp = arr[j]
      tt=[]
      for k in range(len(arr)):
        if(k!=j):
          tt.append(arr[k])
      tt.sort()
      for k in tt:
        temp+=k
      temp = t+temp
      # print(temp,""fhhh"")
      if(int(s2)>=int(temp)):
        # print(temp,""f"")
        if(int(arr[j])>ma):
          ma = int(arr[j])
          index = j
    t+=arr[index]
    del arr[index]
    # print(t,arr)
  print(t)



",915C_,CODEFORCES,4209,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"import sys
def getSum(a):
    sum1 = a * (a + 1) // 2
    return sum1
def getSumOfTwo(a, b):
    if a <= 1:
        return getSum(b)
    return getSum(b) - getSum(a - 1)

n, k = [int(elem) for elem in input().split()]
if n == 1:
    print(0)
    sys.exit(0)
if n <= k:
    print(1)
    sys.exit(0)
if getSum(k - 1) < n - 1:
    print(-1)
    sys.exit(0)

n -= 1
k -= 1
left, right = 1, k
while left < right:
    mid = (left + right) // 2
    sum1 = getSumOfTwo(mid, k)
    if sum1 == n:
        print(k - mid + 1)
        sys.exit(0)
    if sum1 > n :
        left = mid + 1
    else:
        right = mid
print(k - left + 2)
		 			  			  			 	  				    		",0287_B,CODEFORCES,918,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"n = int(input())
t = list(map(int, input().split()))

sw = 0

while t != []:
	pr = 1 + t[1:].index(t[0])
	#print(pr)
	sw += pr-1
	#print(t[1:pr], t[pr+1:])
	t = t[1:pr] + t[pr+1:]
	#print(t)

print(sw)
",0995_B,CODEFORCES,3336,Suit and Tie,"Allen is hosting a formal dinner party. $$$2n$$$ people come to the event in $$$n$$$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $$$2n$$$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.
Help Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 100$$$), the number of pairs of people.
The second line contains $$$2n$$$ integers $$$a_1, a_2, \dots, a_{2n}$$$. For each $$$i$$$ with $$$1 \le i \le n$$$, $$$i$$$ appears exactly twice. If $$$a_j = a_k = i$$$, that means that the $$$j$$$-th and $$$k$$$-th people in the line form a couple.
Output a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.
","input
In the first sample case, we can transform $$$1 1 2 3 3 2 4 4 \rightarrow 1 1 2 3 2 3 4 4 \rightarrow 1 1 2 2 3 3 4 4$$$ in two steps. Note that the sequence $$$1 1 2 3 3 2 4 4 \rightarrow 1 1 3 2 3 2 4 4 \rightarrow 1 1 3 3 2 2 4 4$$$ also works in the same number of steps.
output
The second sample case already satisfies the constraints; therefore we need $$$0$$$ swaps.
","greedy, implementation, math",5
"a,b=map(int,input().split(' '))
print((b+a-1)//a)",1036_A,CODEFORCES,459,Function Height,"You are given a set of $$$2n+1$$$ integer points on a Cartesian plane. Points are numbered from $$$0$$$ to $$$2n$$$ inclusive. Let $$$P_i$$$ be the $$$i$$$-th point. The $$$x$$$-coordinate of the point $$$P_i$$$ equals $$$i$$$. The $$$y$$$-coordinate of the point $$$P_i$$$ equals zero (initially). Thus, initially $$$P_i=(i,0)$$$.
The given points are vertices of a plot of a piecewise function. The $$$j$$$-th piece of the function is the segment $$$P_{j}P_{j + 1}$$$.
In one move you can increase the $$$y$$$-coordinate of any point with odd $$$x$$$-coordinate (i.e. such points are $$$P_1, P_3, \dots, P_{2n-1}$$$) by $$$1$$$. Note that the corresponding segments also change.
For example, the following plot shows a function for $$$n=3$$$ (i.e. number of points is $$$2\cdot3+1=7$$$) in which we increased the $$$y$$$-coordinate of the point $$$P_1$$$ three times and $$$y$$$-coordinate of the point $$$P_5$$$ one time:
Let the area of the plot be the area below this plot and above the coordinate axis OX. For example, the area of the plot on the picture above is 4 (the light blue area on the picture above is the area of the plot drawn on it).
Let the height of the plot be the maximum $$$y$$$-coordinate among all initial points in the plot (i.e. points $$$P_0, P_1, \dots, P_{2n}$$$). The height of the plot on the picture above is 3.
Your problem is to say which minimum possible height can have the plot consisting of $$$2n+1$$$ vertices and having an area equal to $$$k$$$. Note that it is unnecessary to minimize the number of moves.
It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 10^{18}$$$) — the number of vertices in a plot of a piecewise function and the area we need to obtain.
Print one integer — the minimum possible height of a plot consisting of $$$2n+1$$$ vertices and with an area equals $$$k$$$. It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
One of the possible answers to the first example:
The area of this plot is 3, the height of this plot is 1.
","input
There is only one possible answer to the second example:
output
The area of this plot is 12, the height of this plot is 3.
",math,1
"def merge(a,b):
    inda=0
    indb=0
    lena=len(a)
    lenb=len(b)
    d=[a[-1]+b[-1]+1000]
    a+=d
    b+=d
    c=[]
    inversions=0
    for i in range(lena+lenb):
        if a[inda]<b[indb]:
            c.append(a[inda])
            inda+=1
        else:
            c.append(b[indb])
            indb+=1
            inversions+=lena-inda
    return((c,inversions))
def mergesort(a):
    if len(a)<=1:
        return((a,0))
    split=len(a)//2
    b=a[:split]
    c=a[split:]
    d=mergesort(b)
    e=mergesort(c)
    f=merge(d[0],e[0])
    return((f[0],f[1]+d[1]+e[1]))
n=int(input())
a=list(map(int,input().split()))
b=[]
for guy in a:
    if guy!=-1:
        b.append(guy)
invs=mergesort(b)[1]
negs=len(a)-len(b)
pairs=(negs*(negs-1))//2
used=[0]*n
for guy in a:
    if guy!=-1:
        used[guy-1]+=1
unused=[0]
for i in range(n-1):
    unused.append(unused[-1]+1-used[i])
negsseen=0
mix=0
for i in range(n):
    if a[i]==-1:
        negsseen+=1
    else:
        mix+=unused[a[i]-1]*(negs-negsseen)+negsseen*(negs-unused[a[i]-1])
num=invs*2*negs+pairs*negs+mix*2
denom=2*negs
if negs==0:
    print(invs%998244353)
else:
    for i in range(denom):
        if (998244353*i+1)%denom==0:
            inv=(998244353*i+1)//denom
            break
    print((num*inv)%998244353)",1096_F,CODEFORCES,2909,Inversion Expectation,"A permutation of size $$$n$$$ is an array of size $$$n$$$ such that each integer from $$$1$$$ to $$$n$$$ occurs exactly once in this array. An inversion in a permutation $$$p$$$ is a pair of indices $$$(i, j)$$$ such that $$$i > j$$$ and $$$a_i < a_j$$$. For example, a permutation $$$[4, 1, 3, 2]$$$ contains $$$4$$$ inversions: $$$(2, 1)$$$, $$$(3, 1)$$$, $$$(4, 1)$$$, $$$(4, 3)$$$.
You are given a permutation $$$p$$$ of size $$$n$$$. However, the numbers on some positions are replaced by $$$-1$$$. Let the valid permutation be such a replacement of $$$-1$$$ in this sequence back to numbers from $$$1$$$ to $$$n$$$ in such a way that the resulting sequence is a permutation of size $$$n$$$.
The given sequence was turned into a valid permutation randomly with the equal probability of getting each valid permutation.
Calculate the expected total number of inversions in the resulting valid permutation.
It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the length of the sequence.
The second line contains $$$n$$$ integers $$$p_1, p_2, \dots, p_n$$$ ($$$-1 \le p_i \le n$$$, $$$p_i \ne 0$$$) — the initial sequence.
It is guaranteed that all elements not equal to $$$-1$$$ are pairwise distinct.
Print a single integer — the expected total number of inversions in the resulting valid permutation.
It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.
In the first example two resulting valid permutations are possible:
The expected value is $$$\frac{2 \cdot 1 + 3 \cdot 1}{2} = 2.5$$$.
","input
In the second example no $$$-1$$$ are present, thus the only valid permutation is possible — the given one. It has $$$0$$$ inversions.
output
In the third example there are two resulting valid permutations — one with $$$0$$$ inversions and one with $$$1$$$ inversion.
","dp, math, probabilities",4
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
########################################################################

s=rl()
n=len(s)
ans=0
for i in range(n-1):
  for j in range(i+1,n):
    for k in range(n-j):
      if s[i+k]!=s[j+k]:
        break
      ans=max(ans,1+k)

print(ans)
",0023_A,CODEFORCES,3701,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"import sys
input = sys.stdin.readline

rr, gg, bb = map(int, input().split())
inf = 114514
r = list(map(int, input().split())) + [inf]
g = list(map(int, input().split())) + [inf]
b = list(map(int, input().split())) + [inf]
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = []
for _ in range(rr + 1):
    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])
ans = 0
for i in range(rr + 1):
    ri = r[i]
    for j in range(gg + 1):
        gj = g[j]
        for k in range(bb + 1):
            bk = b[k]
            if (i + j + k) % 2:
                continue
            dpijk = 0
            if i > 0 and j > 0:
                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)
            if j > 0 and k > 0:
                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)
            if k > 0 and i > 0:
                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)
            dp[i][j][k] = dpijk
            if ans < dpijk:
                ans = dpijk
print(ans)",1398_D,CODEFORCES,3888,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"# qumeric
n, m = map(int, input().split())
a = [int(input(), 2) for _ in range(n)]

s = t = 0
for x in a:
    t |= s & x
    s |= x
print((""YES"", ""NO"")[all(x & s & ~t for x in a)])
",0985_B,CODEFORCES,3247,Switches and Lamps,"You are given n switches and m lamps. The i-th switch turns on some subset of the lamps. This information is given as the matrix a consisting of n rows and m columns where ai, j = 1 if the i-th switch turns on the j-th lamp and ai, j = 0 if the i-th switch is not connected to the j-th lamp.
Initially all m lamps are turned off.
Switches change state only from ""off"" to ""on"". It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards.
It is guaranteed that if you push all n switches then all m lamps will be turned on.
Your think that you have too many switches and you would like to ignore one of them. 
Your task is to say if there exists such a switch that if you will ignore (not use) it but press all the other n - 1 switches then all the m lamps will be turned on.
The first line of the input contains two integers n and m (1 ≤ n, m ≤ 2000) — the number of the switches and the number of the lamps.
The following n lines contain m characters each. The character ai, j is equal to '1' if the i-th switch turns on the j-th lamp and '0' otherwise.
","input
It is guaranteed that if you press all n switches all m lamps will be turned on.
output
Print ""YES"" if there is a switch that if you will ignore it and press all the other n - 1 switches then all m lamps will be turned on. Print ""NO"" if there is no such switch.
",implementation,5
"import bisect
import math
import itertools
import sys

# import sys.stdout.flush() use for interactive problems
alpha = 'abcdefghijklmnopqrstuvwxyz'
inf = 1e17


# Max = 10**6
# primes = []
# prime = [True for i in range(10**6+1)]
# p = 2
# while (p * p <= Max+1):
#
#     # If prime[p] is not
#     # changed, then it is a prime
#     if (prime[p] == True):
#
#         # Update all multiples of p
#         for i in range(p * p, Max+1, p):
#             prime[i] = False
#     p += 1
#
# for p in range(2, Max+1):
#     if prime[p]:
#         primes.append(p)
def calc1(grid):
    l = len(grid)
    cnt = 0
    for i in range(l):
        for j in range(l):
            if (i+j) % 2 and grid[i][j]:
                cnt += 1
            if (i+j) % 2 == 0 and grid[i][j] == 0:
                cnt += 1
    return cnt

def calc2(grid):
    l = len(grid)
    cnt = 0
    for i in range(l):
        for j in range(l):
            if (i+j) % 2 and grid[i][j] == 0:
                cnt += 1
            if (i+j) % 2 == 0 and grid[i][j]:
                cnt += 1
    return cnt
def solve(n,grids):
    one = []
    zero = []
    for grid in grids:
        one.append(calc1(grid))
        zero.append(calc2(grid))
    take = [3,5,6,9,10,12]
    answer = inf
    for mask in range(16):
        cnt = 0
        if mask not in take:
            continue
        if mask in take:
            if mask & 1:
                cnt += one[3]
                pass
            else:
                cnt += zero[3]
                pass
            if mask & 2:
                cnt += one[2]
                pass
            else:
                cnt += zero[2]
                pass
            if mask & 4:
                cnt += one[1]
                pass
            else:
                cnt += zero[1]
                pass
            if mask & 8:
                cnt += one[0]
                pass
            else:
                cnt += zero[0]
                pass
        answer = min(answer,cnt)
    return answer

t = 1#int(input())
ans = []
for _ in range(t):
    n = int(input())
    #n, u, r, d, l = map(int, input().split())
    #a,b = map(int, input().split())
    # s = input()
    # arr = list(input())
    # arr = [int(x) for x in input().split()]
    # c = [int(x) for x in input().split()]

    # b = [int(x) for x in input().split()]
    # s = input()
    # t = input()
    grids = []
    for i in range(4):
        grid = []
        for j in range(n):
            arr = list(map(int,list(input())))
            grid.append(arr)
        if i != 3:
            s = input()
        grids.append(grid)
    # options = [int(x) for x in input().split()]
    """"""ladders = []
    for j in range(l):
        ladders.append([int(x) for x in input().split()])""""""
    """"""queries = []
    for j in range(q):
        queries.append(list(map(int, input().split())))""""""
    # s = list(input())
    # start,end = map(int,input().split())

    ans.append(solve(n,grids))

for test in ans:
    print(test)",0961_C,CODEFORCES,3169,Chessboard,"Magnus decided to play a classic chess game. Though what he saw in his locker shocked him! His favourite chessboard got broken into 4 pieces, each of size n by n, n is always odd. And what's even worse, some squares were of wrong color. j-th square of the i-th row of k-th piece of the board has color ak, i, j; 1 being black and 0 being white. 
Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard. Every square has its color different to each of the neightbouring by side squares in a valid board. Its size should be 2n by 2n. You are allowed to move pieces but not allowed to rotate or flip them.
The first line contains odd integer n (1 ≤ n ≤ 100) — the size of all pieces of the board. 
","input
Then 4 segments follow, each describes one piece of the board. Each consists of n lines of n characters; j-th one of i-th line is equal to 1 if the square is black initially and 0 otherwise. Segments are separated by an empty line.
output
Print one number — minimum number of squares Magnus should recolor to be able to obtain a valid chessboard.
","bitmasks, bruteforce, implementation",5
"MAX = 1000
f = [0]
for i in range(1, MAX):
    f.append(f[i - 1] + (1 << (2 * i - 2)))

g = [0]
for i in range(1, MAX):
    g.append(g[i - 1] + (1 << i) - 1)

t = int(input())
for _ in range(t):
    n, k = map(int, input().split(' '))
    ans = False
    for i in range(1, n + 1):
        if k >= g[i]:
            if n >= MAX:
                print(""YES %d"" % (n - i))
                ans = True
            elif k <= f[n] - ((1 << (i + 1)) - 1) * f[n - i]:
                print(""YES %d"" % (n - i))
                ans = True
        if ans == True:
            break
    if ans == False:
        print(""NO"")
        
    ",1080_D,CODEFORCES,2036,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",3
"from collections import defaultdict, deque
from heapq import heappush, heappop
from math import inf


def solve():
    n, m = map(int, input().split())
    cnt = defaultdict(int)
    res = []
    for i in range(n):
        A = list(map(int, list(input())))
        res.append(A)
        for j in range(m):
            if A[j]:
                cnt[j] += 1
    valid = False
    for r in res:
        j = [i for i in range(m) if r[i]]
        if all(cnt[i] > 1 for i in j):
            valid = True
            break
    if valid:
        print(""YES"")
    else:
        print(""NO"")

t = 1
# t = int(input())
while t:
    t -= 1
    solve()

",0985_B,CODEFORCES,3245,Switches and Lamps,"You are given n switches and m lamps. The i-th switch turns on some subset of the lamps. This information is given as the matrix a consisting of n rows and m columns where ai, j = 1 if the i-th switch turns on the j-th lamp and ai, j = 0 if the i-th switch is not connected to the j-th lamp.
Initially all m lamps are turned off.
Switches change state only from ""off"" to ""on"". It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards.
It is guaranteed that if you push all n switches then all m lamps will be turned on.
Your think that you have too many switches and you would like to ignore one of them. 
Your task is to say if there exists such a switch that if you will ignore (not use) it but press all the other n - 1 switches then all the m lamps will be turned on.
The first line of the input contains two integers n and m (1 ≤ n, m ≤ 2000) — the number of the switches and the number of the lamps.
The following n lines contain m characters each. The character ai, j is equal to '1' if the i-th switch turns on the j-th lamp and '0' otherwise.
","input
It is guaranteed that if you press all n switches all m lamps will be turned on.
output
Print ""YES"" if there is a switch that if you will ignore it and press all the other n - 1 switches then all m lamps will be turned on. Print ""NO"" if there is no such switch.
",implementation,5
"n,k=list(map(int,input().split()))

if k%2==0:
    s="".""
    s=s+""#""*(k//2)
    s=s+"".""*(n-len(s))
    print(""YES"")
    print("".""*n)
    print(s)
    print(s)
    print("".""*n)

else:
    if k<=n-2:
        a=""#""*k
        s="".""*((n-k)//2)+a+"".""*((n-k)//2)
        print(""YES"")
        print("".""*n)
        print(s)
        print("".""*n)
        print("".""*n)
    else:
        k=k-n+3
        a=""#""*k
        s="".""*((n-k)//2)+a+"".""*((n-k)//2)
        print(""YES"")
        print("".""*n)
        print("".""+""#""*(n-2)+""."")
        s=list(s)
        s[n//2]="".""
        s="""".join(s)
        print(s)
        print("".""*n)",0980_B,CODEFORCES,1660,Marlin,"The city of Fishtopia can be imagined as a grid of $$$4$$$ rows and an odd number of columns. It has two main villages; the first is located at the top-left cell $$$(1,1)$$$, people who stay there love fishing at the Tuna pond at the bottom-right cell $$$(4, n)$$$. The second village is located at $$$(4, 1)$$$ and its people love the Salmon pond at $$$(1, n)$$$.
The mayor of Fishtopia wants to place $$$k$$$ hotels in the city, each one occupying one cell. To allow people to enter the city from anywhere, hotels should not be placed on the border cells.
A person can move from one cell to another if those cells are not occupied by hotels and share a side.
Can you help the mayor place the hotels in a way such that there are equal number of shortest paths from each village to its preferred pond?
The first line of input contain two integers, $$$n$$$ and $$$k$$$ ($$$3 \leq n \leq 99$$$, $$$0 \leq k \leq 2\times(n-2)$$$), $$$n$$$ is odd, the width of the city, and the number of hotels to be placed, respectively.
","input
Print ""YES"", if it is possible to place all the hotels in a way that satisfies the problem statement, otherwise print ""NO"".
output
If it is possible, print an extra $$$4$$$ lines that describe the city, each line should have $$$n$$$ characters, each of which is ""#"" if that cell has a hotel on it, or ""."" if not.
",constructivealgorithms,3
"import sys

n = int(sys.stdin.buffer.readline().decode('utf-8'))
cost = [0] + \
    list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))
a = [line.decode('utf-8').rstrip() for line in sys.stdin.buffer]

mask = [0, 1, 51, 1911]
inf, bs_size, full_bit = 10**9, 1 << 12, (1 << 12) - 1
dp = [[inf]*bs_size for _ in range(4*n+1)]
dp[0][0] = 0

for i in range(4*n):
    y, x = i & 3, i >> 2
    is_dot = 1 if a[y][x] == '.' else 0

    for bitset in range(bs_size):
        if y == 0:
            '''
              01234    01234
            0 s****    .t..*
            1 ***** -> ....*
            2 ***** -> ....*
            3 *****    ....*
            '''
            if dp[i+4][full_bit] > dp[i][bitset] + cost[4]:
                dp[i+4][full_bit] = dp[i][bitset] + cost[4]

        if (is_dot | bitset & 1) and\
                dp[i+1][bitset >> 1] > dp[i][bitset]:
            dp[i+1][bitset >> 1] = dp[i][bitset]

        for k in range(1, min(4-y, 3)+1):
            if dp[i][bitset | mask[k]] > dp[i][bitset] + cost[k]:
                dp[i][bitset | mask[k]] = dp[i][bitset] + cost[k]

print(min(dp[4*n]))
",0903_F,CODEFORCES,1520,Clear The Matrix,"You are given a matrix f with 4 rows and n columns. Each element of the matrix is either an asterisk (*) or a dot (.).
You may perform the following operation arbitrary number of times: choose a square submatrix of f with size k × k (where 1 ≤ k ≤ 4) and replace each element of the chosen submatrix with a dot. Choosing a submatrix of size k × k costs ak coins.
What is the minimum number of coins you have to pay to replace all asterisks with dots?
The first line contains one integer n (4 ≤ n ≤ 1000) — the number of columns in f.
The second line contains 4 integers a1, a2, a3, a4 (1 ≤ ai ≤ 1000) — the cost to replace the square submatrix of size 1 × 1, 2 × 2, 3 × 3 or 4 × 4, respectively.
Then four lines follow, each containing n characters and denoting a row of matrix f. Each character is either a dot or an asterisk.
Print one integer — the minimum number of coins to replace all asterisks with dots.
In the first example you can spend 8 coins to replace the submatrix 3 × 3 in the top-left corner, and 1 coin to replace the 1 × 1 submatrix in the bottom-right corner.
","input
In the second example the best option is to replace the 4 × 4 submatrix containing columns 2 – 5, and the 2 × 2 submatrix consisting of rows 2 – 3 and columns 6 – 7.
output
In the third example you can select submatrix 3 × 3 in the top-left corner and then submatrix 3 × 3 consisting of rows 2 – 4 and columns 2 – 4.
","bitmasks, dp",3
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []


def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False


le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])
",1288_D,CODEFORCES,4685,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"n = int(input())
l = list(map(int,input().split()))
l=sorted(l)
if l[-1]==1:
    l[-1]=2
else:
    l[-1]=1
l=sorted(l)
print(*l)",0135_A,CODEFORCES,2305,Replacement,"Little Petya very much likes arrays consisting of n integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 
After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.
","input
The first line contains a single integer n (1 ≤ n ≤ 105), which represents how many numbers the array has. The next line contains n space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.
output
Print n space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.
","greedy, implementation, sortings",4
"import math
n,k=map(int,input().split())
edges=[]
for i in range(n-1):
    edges.append(tuple(map(int,input().split())))
degreelist=[]
for i in range(min(k+1,math.floor(math.log2(n))+10)):
    degreelist.append({})
degrees=degreelist[0]
for i in range(1,n+1):
    degrees[i]=0
for guy in edges:
    degrees[guy[0]]+=1
    degrees[guy[1]]+=1
small=[]
center=None
done=False
for i in range(k):
    if not done:
        small=[]
        for guy in degrees:
            if degrees[guy]==2:
                print(""No"")
                done=True
                break
            if degrees[guy]==3:
                small.append(guy)
                if center==None: 
                    center=guy
                elif center!=guy:
                    print(""No"")
                    done=True
                    break
            elif degrees[guy]>1:
                small.append(guy)
        degrees=degreelist[i+1]
        if center!=None and center not in small:
            if not done:
                print(""No"")
            done=True
            break
        elif len(small)==0:
            if not done:
                print(""No"")
            done=True
            break
        for guy in small:
            degrees[guy]=0
        for guy in edges:
            if guy[0] in degrees and guy[1] in degrees:
                degrees[guy[0]]+=1
                degrees[guy[1]]+=1
        for guy in degrees:
            if degrees[guy]>1 and degreelist[i][guy]!=degrees[guy]:
                if not done:
                    print(""No"")
                done=True
                break
    else:
        break
if not done:
    if len(degreelist[-1])==1:
        print(""Yes"")
    else:
        print(""No"")",1067_B,CODEFORCES,2006,Multihedgehog,"Someone give a strange birthday present to Ivan. It is hedgehog — connected undirected graph in which one vertex has degree at least $$$3$$$ (we will call it center) and all other vertices has degree 1. Ivan thought that hedgehog is too boring and decided to make himself $$$k$$$-multihedgehog.
Let us define $$$k$$$-multihedgehog as follows:
Thereby $$$k$$$-multihedgehog is a tree. Ivan made $$$k$$$-multihedgehog but he is not sure that he did not make any mistakes. That is why he asked you to check if his tree is indeed $$$k$$$-multihedgehog.
First line of input contains $$$2$$$ integers $$$n$$$, $$$k$$$ ($$$1 \le n \le 10^{5}$$$, $$$1 \le k \le 10^{9}$$$) — number of vertices and hedgehog parameter.
Next $$$n-1$$$ lines contains two integers $$$u$$$ $$$v$$$ ($$$1 \le u, \,\, v \le n; \,\, u \ne v$$$) — indices of vertices connected by edge.
It is guaranteed that given graph is a tree.
Print ""Yes"" (without quotes), if given graph is $$$k$$$-multihedgehog, and ""No"" (without quotes) otherwise.
2-multihedgehog from the first example looks like this:

","input
Its center is vertex $$$13$$$. Hedgehogs created on last step are: [4 (center), 1, 2, 3], [6 (center), 7, 8, 9], [5 (center), 10, 11, 12, 13].
output
Tree from second example is not a hedgehog because degree of center should be at least $$$3$$$.
","dfsandsimilar, graphs, shortestpaths",3
"xs, ys = map(int, input().split())
things = [[xs, ys, 0]]
n = int(input())
for i in range(n):
    things.append(list(map(int, input().split())) + [i + 1])


distance = [[0 for i in range(n + 1)] for j in range(n + 1)]
for i in range(n + 1):
    for j in range(i, n + 1):
        distance[i][j] = distance[j][i] = (things[i][0] - things[j][0]) ** 2 + (things[i][1] - things[j][1]) ** 2

INF = float('inf')
DP = [INF for _ in range((1 << n) + 10)]
Path = [None for _ in range((1 << n) + 10)]
DP[0] = 0

for cur in range(1 << n):
    if DP[cur] == INF:
        continue
    for nxt1 in range(n):
        if cur & (1 << nxt1) != 0:
            continue
        
        if DP[cur | (1 << nxt1)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]:
            DP[cur | (1 << nxt1)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]
            Path[cur | (1 << nxt1)] = cur
        
        for nxt2 in range(n):
            if (cur | (1 << nxt1)) & (1 << nxt2) != 0:
                continue
            if DP[cur | (1 << nxt1) | (1 << nxt2)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]:
                DP[cur | (1 << nxt1) | (1 << nxt2)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]
                Path[cur | (1 << nxt1) | (1 << nxt2)] = cur
        break

print(DP[(1 << n) - 1])

path = []
cur = (1 << n) - 1
while cur != 0:
    path.append(0)
    father = Path[cur]
    diff = cur ^ father
    d1 = len(bin(diff)[2:])
    path.append(d1)
    diff ^= (1 << (d1 - 1))
    if diff != 0:
        d2 = len(bin(diff)[2:])
        path.append(d2)
    cur = father
path.append(0)
path = list(reversed(path))
print(' '.join(map(str, path)))",0008_C,CODEFORCES,4268,Looking for Order,"Girl Lena likes it when everything is in order, and looks for order everywhere. Once she was getting ready for the University and noticed that the room was in a mess — all the objects from her handbag were thrown about the room. Of course, she wanted to put them back into her handbag. The problem is that the girl cannot carry more than two objects at a time, and cannot move the handbag. Also, if he has taken an object, she cannot put it anywhere except her handbag — her inherent sense of order does not let her do so.
You are given the coordinates of the handbag and the coordinates of the objects in some Сartesian coordinate system. It is known that the girl covers the distance between any two objects in the time equal to the squared length of the segment between the points of the objects. It is also known that initially the coordinates of the girl and the handbag are the same. You are asked to find such an order of actions, that the girl can put all the objects back into her handbag in a minimum time period.
The first line of the input file contains the handbag's coordinates xs, ys. The second line contains number n (1 ≤ n ≤ 24) — the amount of objects the girl has. The following n lines contain the objects' coordinates. All the coordinates do not exceed 100 in absolute value. All the given positions are different. All the numbers are integer.
","input
In the first line output the only number — the minimum time the girl needs to put the objects into her handbag. 
output
In the second line output the possible optimum way for Lena. Each object in the input is described by its index number (from 1 to n), the handbag's point is described by number 0. The path should start and end in the handbag's point. If there are several optimal paths, print any of them. 
","bitmasks, dp",7
"from itertools import combinations
 
n, l, r, x = map(int, input().split())
(*a,) = map(int, input().split())
sumu = 0
for i in range(2, n + 2):
    for j in combinations(a, i):
        if (r >= sum(j) >= l) and (max(j) - min(j) >= x):
            sumu += 1
print(sumu)
	 		      	 	  		   	  		 	 	",0550_B,CODEFORCES,4487,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"import math

def getdt():
    return map(int,input().split())
def calc(v0,v,a,x):
    t = (v - v0)/a
    x0 = v0 * t + 0.5*a*t*t
    if x0>=x:
        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)
    return (x0,t)
def go(v0,v,a,x):
    x0,t = calc(v0,v,a,x)
    return t + (x-x0)/v

a,v = getdt()
l,d,w = getdt()
if w>v:
    w = v
x,t = calc(0,w,a,d)
if x==d:
    print(go(0,v,a,l))
else:
    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))",0005_D,CODEFORCES,13,Follow Traffic Rules,"Everybody knows that the capital of Berland is connected to Bercouver (the Olympic capital) by a direct road. To improve the road's traffic capacity, there was placed just one traffic sign, limiting the maximum speed. Traffic signs in Berland are a bit peculiar, because they limit the speed only at that point on the road where they are placed. Right after passing the sign it is allowed to drive at any speed.
It is known that the car of an average Berland citizen has the acceleration (deceleration) speed of a km/h2, and has maximum speed of v km/h. The road has the length of l km, and the speed sign, limiting the speed to w km/h, is placed d km (1 ≤ d < l) away from the capital of Berland. The car has a zero speed at the beginning of the journey. Find the minimum time that an average Berland citizen will need to get from the capital to Bercouver, if he drives at the optimal speed.
The car can enter Bercouver at any speed.
","input
The first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).
output
Print the answer with at least five digits after the decimal point.
","implementation, math",1
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
from io import BytesIO, IOBase
import sys
from collections import defaultdict, deque, Counter
from math import sqrt, pi, ceil, log, inf, gcd, floor
from itertools import combinations, permutations
from bisect import *
from fractions import Fraction
from heapq import *
from random import randint

def main():
    n=int(input())
    a=list(map(int,input().split()))
    dp=[[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        dp[i][i]=a[i]
    for i in range(n-2,-1,-1):
        for j in range(i+1,n,1):
            for k in range(i,j,1):
                if dp[i][k] and dp[i][k]==dp[k+1][j]:
                    dp[i][j]=dp[i][k]+1
    b=[10**10]*(n+1)
    b[0]=0
    for i in range(1,n+1):
        for j in range(i):
            if dp[j][i-1]:
                b[i]=min(b[i],b[j]+1)
    print(b[n])
    
# region fastio
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",1312_E,CODEFORCES,3824,Array Shrinking,"You are given an array $$$a_1, a_2, \dots, a_n$$$. You can perform the following operation any number of times:
After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array $$$a$$$ you can get?
The first line contains the single integer $$$n$$$ ($$$1 \le n \le 500$$$) — the initial length of the array $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$) — the initial array $$$a$$$.
Print the only integer — the minimum possible length you can get after performing the operation described above any number of times.
In the first test, this is one of the optimal sequences of operations: $$$4$$$ $$$3$$$ $$$2$$$ $$$2$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$\rightarrow$$$ $$$5$$$ $$$3$$$.
","input
In the second test, this is one of the optimal sequences of operations: $$$3$$$ $$$3$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$3$$$ $$$3$$$ $$$\rightarrow$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$4$$$ $$$4$$$ $$$4$$$ $$$\rightarrow$$$ $$$5$$$ $$$5$$$ $$$4$$$ $$$\rightarrow$$$ $$$6$$$ $$$4$$$.
output
In the third and fourth tests, you can't perform the operation at all.
","dp, greedy",6
"n = int(input())
print(int(3 * n / 2))",0084_A,CODEFORCES,27,Toy Army,"The hero of our story, Valera, and his best friend Arcady are still in school, and therefore they spend all the free time playing turn-based strategy ""GAGA: Go And Go Again"". The gameplay is as follows. 
There are two armies on the playing field each of which consists of n men (n is always even). The current player specifies for each of her soldiers an enemy's soldier he will shoot (a target) and then all the player's soldiers shot simultaneously. This is a game world, and so each soldier shoots perfectly, that is he absolutely always hits the specified target. If an enemy soldier is hit, he will surely die. It may happen that several soldiers had been indicated the same target. Killed soldiers do not participate in the game anymore. 
The game ""GAGA"" consists of three steps: first Valera makes a move, then Arcady, then Valera again and the game ends. 
You are asked to calculate the maximum total number of soldiers that may be killed during the game. 
The input data consist of a single integer n (2 ≤ n ≤ 108, n is even). Please note that before the game starts there are 2n soldiers on the fields. 
Print a single number — a maximum total number of soldiers that could be killed in the course of the game in three turns.
The first sample test:
1) Valera's soldiers 1 and 2 shoot at Arcady's soldier 1.
2) Arcady's soldier 2 shoots at Valera's soldier 1.
","input
3) Valera's soldier 1 shoots at Arcady's soldier 2.
output
There are 3 soldiers killed in total: Valera's soldier 1 and Arcady's soldiers 1 and 2.
","math, numbertheory",1
"import math
from collections import defaultdict

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,input().split())
S=[input() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",0908_E,CODEFORCES,3063,New Year and Entity Enumeration,"You are given an integer m.
Let M = 2m - 1.
You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m.
A set of integers S is called ""good"" if the following hold. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.
Count the number of good sets S, modulo 109 + 7.
The first line will contain two integers m and n (1 ≤ m ≤ 1 000, 1 ≤ n ≤ min(2m, 50)).
The next n lines will contain the elements of T. Each line will contain exactly m zeros and ones. Elements of T will be distinct.
","input
Print a single integer, the number of good sets modulo 109 + 7. 
output
An example of a valid set S is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.
","bitmasks, combinatorics, dp, math",5
"def decimal_to_26(num):
    num = int(num)
    res = ''
    while num:
        mod = num % 26
        if mod == 0:
            res = 'Z' + res
            num = num // 26 - 1
        else:
            num //= 26
            res = chr(mod+64) + res
    return res

def RXCY_to_Excel(c,r):
    new_row = decimal_to_26(r)
    return new_row + str(c)
# print(RXCY_to_Excel(55,23))

n = int(input())
li = []
for i in range(n):
    li.append(input())
for i in li:
    di_index = []
    al_index = []
    temp = i
    for j in range(len(i)):
        if i[j].isalpha():
            al_index.append(j)
            i = i.replace(i[j],' ')
            # print(i)
        elif i[j].isdigit():
            di_index.append(j)
            i = i.replace(i[j],' ')
            # print(i)
    i = temp
    if min(di_index) < max(al_index): # RxxCxx
        # print(i)
        row = int(i[1:i.index('C')])
        col = int(i[i.index('C')+1:])
        # print(row,col,sep=' ')
        print(RXCY_to_Excel(row,col))
    else: # COL + ROW
        row_num = 0
        for k in range(len(i)):
            if i[k].isdigit():
                num_start = k
                break
        # print(i)
        # print(k)
        length = len(i[0:k])
        # print(length)
        for m in range(num_start):
            row_num += 26 ** (length-1) * (ord(i[m])-64) or (ord(i[m])-64)
            # print(row_num)
            length -= 1
        print('R'+i[num_start:]+'C'+str(row_num))








",0001_B,CODEFORCES,1424,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math",3
"n = int(input())
ans = 1+n//2
print(ans)
",0964_A,CODEFORCES,270,Splits,"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. 
For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.
The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.
The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.
For a given $$$n$$$, find out the number of different weights of its splits.
The first line contains one integer $$$n$$$ ($$$1 \leq n \leq 10^9$$$).
Output one integer — the answer to the problem.
In the first sample, there are following possible weights of splits of $$$7$$$:
Weight 1: [$$$\textbf 7$$$] 
Weight 2: [$$$\textbf 3$$$, $$$\textbf 3$$$, 1] 
","input
Weight 3: [$$$\textbf 2$$$, $$$\textbf 2$$$, $$$\textbf 2$$$, 1] 
output
Weight 7: [$$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$]
",math,1
"n=int(input())
print(n//2+1)",0964_A,CODEFORCES,269,Splits,"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. 
For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.
The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.
The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.
For a given $$$n$$$, find out the number of different weights of its splits.
The first line contains one integer $$$n$$$ ($$$1 \leq n \leq 10^9$$$).
Output one integer — the answer to the problem.
In the first sample, there are following possible weights of splits of $$$7$$$:
Weight 1: [$$$\textbf 7$$$] 
Weight 2: [$$$\textbf 3$$$, $$$\textbf 3$$$, 1] 
","input
Weight 3: [$$$\textbf 2$$$, $$$\textbf 2$$$, $$$\textbf 2$$$, 1] 
output
Weight 7: [$$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$, $$$\textbf 1$$$]
",math,1
"z,x=map(int,input().split())
z-=1;x-=1
if x*(x+1)/2 < z :
  print(-1)  
elif z==0:
    print(0)
elif z==x:
    print(1)    
else:
    import sys           
    start = 1 ; end = x  
    while end > start:    
        mid = (end +start)//2
        ans =(x*(x+1)//2)-((mid-1)*(mid)//2 )
        if ans == z:
            print(x-mid+1)
            sys.exit(0)  
        elif ans > z:
            start = mid+1   
        elif ans < z:
            end = mid      
    print(x-end+2)
   
",0287_B,CODEFORCES,927,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"import sys
def ask(x,y,rev):
	if (rev==0):
		print(""? %d %d""%(x,y))
	else:
		print(""? %d %d""%(y,x))
	sys.stdout.flush()
	if (rev==1):
		return -int(input())
	else:
		return int(input())

comp=ask(0,0,0)
nowa=0
nowb=0
rev=0
for i in range(29,-1,-1):
	if (comp<0):
		rev^=1
		nowa,nowb=nowb,nowa
		comp=-comp
	if comp>=0:
		comp=ask(nowa|(1<<i),nowb|(1<<i),rev)
		if (comp<0):
			nowa|=1<<i
			comp=ask(nowa,nowb,rev)
		else:
			tmp=ask(nowa|(1<<i),nowb,rev)
			if (tmp<0):
				nowa|=1<<i
				nowb|=1<<i
if (rev==1):
	nowa,nowb=nowb,nowa
print(""! %d %d""%(nowa,nowb))
			
		",1088_D,CODEFORCES,653,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",1
"x, k = [int(x) for x in input().split()]

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

res = x * pow(2, k + 1, mod) % mod
res = ((res - (pow(2, k, mod) - 1)) % mod + mod) % mod

print(res)
",0992_C,CODEFORCES,1035,Nastya and a Wardrobe,"Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).
Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 
Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.
Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 109 + 7, because it is easy to see that it is always integer.
The only line contains two integers x and k (0 ≤ x, k ≤ 1018), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.
In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 109 + 7.
","input
In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.
output
In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
",math,2
"import math
import sys
from collections import deque


def scan() -> list:
    return list(map(int, sys.stdin.readline().strip().split()))


def solution() -> None:
    # for _ in range(int(input())):
    n, k = scan()
    print(round(n+1.5-math.sqrt(2*(n+k)+2.75)))


if __name__ == '__main__':
    solution()
",1195_B,CODEFORCES,1347,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"import os, sys
from io import BytesIO, IOBase
from math import log2, ceil, sqrt, gcd
from _collections import deque
import heapq as hp
from bisect import bisect_left, bisect_right
from math import cos, sin

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

mod = 10 ** 9 + 7


def ask(x, y):
    print('?', x, y, flush=True)
    return int(input())


a = b = 0
cond = ask(a, b)
for i in range(29, -1, -1):
    if cond:
        x = a + (1 << i)
        y = b + (1 << i)
        n_cond = ask(x, y)
        if cond == n_cond:
            if cond == 1:
                n_cond1 = ask(x, b)
            else:
                n_cond1 = ask(a, y)

            if cond != n_cond1:
                a = x
                b = y

        else:
            if cond == 1:
                a = x
            else:
                b = y
            cond = ask(a, b)
    else:
        x = a + (1 << i)
        y = b + (1 << i)
        n_cond = ask(x, b)
        if n_cond == -1:
            a = x
            b = y
print('!', a, b, flush=True)
",1088_D,CODEFORCES,1216,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",2
"import sys
import os

def solve(slimes):
    if len(slimes) == 1:
        return slimes[0]

    havePos = False
    haveNeg = False

    for s in slimes:
        if s > 0:
            havePos = True
        elif s < 0:
            haveNeg = True

    if havePos and haveNeg:
        return sum(map(abs, slimes))
    elif not havePos:
        m = max(slimes)
        return sum(list(map(abs, slimes))) + 2 * m
    elif not haveNeg:
        m = min(slimes)
        return sum(list(map(abs, slimes))) - 2 * m
    else:
        return 0

def main():
    n = int(input())
    slimes = list(map(int, input().split()))
    print(solve(slimes))


if __name__ == '__main__':
    main()",1038_D,CODEFORCES,1945,Slime,"There are $$$n$$$ slimes in a row. Each slime has an integer value (possibly negative or zero) associated with it.
Any slime can eat its adjacent slime (the closest slime to its left or to its right, assuming that this slime exists). 
When a slime with a value $$$x$$$ eats a slime with a value $$$y$$$, the eaten slime disappears, and the value of the remaining slime changes to $$$x - y$$$.
The slimes will eat each other until there is only one slime left. 
Find the maximum possible value of the last slime.
The first line of the input contains an integer $$$n$$$ ($$$1 \le n \le 500\,000$$$) denoting the number of slimes.
The next line contains $$$n$$$ integers $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ is the value of $$$i$$$-th slime.
Print an only integer — the maximum possible value of the last slime.
","input
In the first example, a possible way of getting the last slime with value $$$4$$$ is:
output
In the second example, the first slime can keep eating slimes to its right to end up with a value of $$$4$$$.
","dp, greedy, implementation",3
"n = int(input())
if n <= 4:
    print(""YES"")
    exit()

A = [None]*n

for i in range(n):
    A[i] = list(map(int,input().split()))

def is_colinear(a1,a2,a3):
    if a1 == a2 or a2 == a3 or a1 == a3:
        return True

    x1,y1 = a1
    x2,y2 = a2
    x3,y3 = a3

    if x1 == x2 or x1 == x3 or x2 == x3:
        return x1 == x2 == x3
    if y1 == y2 or y1 == y3 or y2 == y3:
        return y1 == y2 == y3
    return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)

X,Y,Z = A[0],A[1],A[2]

def good(X,Y):
    # are X,Y on the same line?
    bad = []
    for i in range(n):
        if not is_colinear(X,Y,A[i]):
            bad.append(A[i])

    if len(bad) <= 2:
        return True

    U,V = bad[0],bad[1]
    for i in range(len(bad)):
        if not is_colinear(U,V,bad[i]):
            return False
    return True

if good(X,Y) or good(Y,Z) or good(X,Z):
    print(""YES"")
    exit()

print(""NO"")
exit()



    
",0961_D,CODEFORCES,2485,Pair Of Lines,"You are given n points on Cartesian plane. Every point is a lattice point (i. e. both of its coordinates are integers), and all points are distinct.
You may draw two straight lines (not necessarily distinct). Is it possible to do this in such a way that every point lies on at least one of these lines?
The first line contains one integer n (1 ≤ n ≤ 105) — the number of points you are given.
Then n lines follow, each line containing two integers xi and yi (|xi|, |yi| ≤ 109)— coordinates of i-th point. All n points are distinct.
","input
If it is possible to draw two straight lines in such a way that each of given points belongs to at least one of these lines, print YES. Otherwise, print NO.
output
In the first example it is possible to draw two lines, the one containing the points 1, 3 and 5, and another one containing two remaining points.
",geometry,4
"import io,os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from collections import defaultdict as dd
I = lambda : list(map(int,input().split()))

n,m=I()
l=[]
an=-1;a=b=0
for _ in range(n):
	k=I()
	l.append(k+[_+1])
	if an<min(k):
		a=b=_+1
		an=min(k)
le=an;r=10**9+1
while le<r:
	md = (le+r)//2
	f=0;a1=a2=-1
	s=[0]*n
	for i in range(n):
		for j in range(m):
			if l[i][j]>=md:
				s[i]|=1<<j

	po=1<<m
	d=[0]*po
	for i in range(n):
		d[s[i]]=i+1
	for i in range(1,po):
		if d[i]:
			pp=i
			while pp:
				d[pp]=d[i]
				pp=(pp-1)&i
	if d[po-1]:
		f=1
		a1=a2=d[po-1]
	for i in range(1,po):
		if d[i] and d[(po-1)^i]:
			f=1
			a1 = d[i]
			a2 = d[(po-1)^i]
			break
	if f:
		le=md+1
		if md>an:
			a,b=a1,a2
			an=md
	else:
		r=md
print(a,b)",1288_D,CODEFORCES,4693,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"
def  getc():
    f = [[0]*500 for i in range(500)]
    for i in range(500):
        f[i][0] = 1
    f[1][0] = 1
    f[1][1] = 1
    for i in range(2,411):
        for j in range(1, i+1):
            f[i][j] = (f[i-1][j-1] + f[i-1][j])%mod
    return f
n, mod = map(int, input().split())
f = [[0]*500 for i in range(500)]
c = getc()
mi_2 = [0]*500
mi_2[0] = 1
for i in range(1, 500):
    mi_2[i] = mi_2[i-1]*2%mod
for i in range(1, n+1):
    for j in range(0, i//2+1):
        if j == 0:
            f[i][j] = mi_2[i-1]
        else:
            for k in range(2, i):
                f[i][j] = (f[i][j] + ((mi_2[k-2]*f[i-k][j-1])%mod)*c[i-j][k-1]%mod)%mod 
ans = 0
for i in range(0,n+1):
    ans = (ans + f[n][i])%mod
print(ans)
",1515_E,CODEFORCES,4036,Phoenix and Computers,"There are $$$n$$$ computers in a row, all originally off, and Phoenix wants to turn all of them on. He will manually turn on computers one at a time. At any point, if computer $$$i-1$$$ and computer $$$i+1$$$ are both on, computer $$$i$$$ $$$(2 \le i \le n-1)$$$ will turn on automatically if it is not already on. Note that Phoenix cannot manually turn on a computer that already turned on automatically.
If we only consider the sequence of computers that Phoenix turns on manually, how many ways can he turn on all the computers? Two sequences are distinct if either the set of computers turned on manually is distinct, or the order of computers turned on manually is distinct. Since this number may be large, please print it modulo $$$M$$$.
The first line contains two integers $$$n$$$ and $$$M$$$ ($$$3 \le n \le 400$$$; $$$10^8 \le M \le 10^9$$$) — the number of computers and the modulo. It is guaranteed that $$$M$$$ is prime.
","input
Print one integer — the number of ways to turn on the computers modulo $$$M$$$.
output
In the first example, these are the $$$6$$$ orders in which Phoenix can turn on all computers: 
","combinatorics, dp, math",6
"n = int(input())
i = 1
while n:
    if i > 1:
        print(' ', end='')
    if n == 3:
        print(*[i, i, i * 3], end='')
        break
    print(' '.join([str(i)] * ((n + 1) // 2)), end='')
    i <<= 1
    n >>= 1

print()
",1059_C,CODEFORCES,2825,Sequence Transformation,"Let's call the following process a transformation of a sequence of length $$$n$$$.
If the sequence is empty, the process ends. Otherwise, append the greatest common divisor (GCD) of all the elements of the sequence to the result and remove one arbitrary element from the sequence. Thus, when the process ends, we have a sequence of $$$n$$$ integers: the greatest common divisors of all the elements in the sequence before each deletion.
You are given an integer sequence $$$1, 2, \dots, n$$$. Find the lexicographically maximum result of its transformation.
A sequence $$$a_1, a_2, \ldots, a_n$$$ is lexicographically larger than a sequence $$$b_1, b_2, \ldots, b_n$$$, if there is an index $$$i$$$ such that $$$a_j = b_j$$$ for all $$$j < i$$$, and $$$a_i > b_i$$$.
The first and only line of input contains one integer $$$n$$$ ($$$1\le n\le 10^6$$$).
Output $$$n$$$ integers  — the lexicographically maximum result of the transformation.
","input
In the first sample the answer may be achieved this way:
output
We get the sequence $$$[1, 1, 3]$$$ as the result.
","constructivealgorithms, math",4
"
from bisect import *
from collections import *
from math import gcd,ceil,sqrt,floor,inf
from heapq import *
from itertools import *
from operator import add,mul,sub,xor,truediv,floordiv
from functools import *

#------------------------------------------------------------------------
import os
import sys

from io import BytesIO, IOBase
# region fastio
 
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 

#------------------------------------------------------------------------
def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
#------------------------------------------------------------------------


from types import GeneratorType
 
 
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
 
    return wrappedfunc

mod=10**9+7
farr=[1]
ifa=[]
 
def fact(x,mod=0):
    if mod:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr)%mod)
    else:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr))
    return farr[x]
 
def ifact(x,mod):
    global ifa
    fact(x,mod)
    ifa.append(pow(farr[-1],mod-2,mod))
    for i in range(x,0,-1):
        ifa.append(ifa[-1]*i%mod)
    ifa.reverse()
 
def per(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return fact(i)//fact(i-j)
    return farr[i]*ifa[i-j]%mod
    
def com(i,j,mod=0):
    if i<j: return 0
    if not mod:        
        return per(i,j)//fact(j)
    return per(i,j,mod)*ifa[j]%mod
 
def catalan(n):
    return com(2*n,n)//(n+1)
 
def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True

def floorsum(a,b,c,n):#sum((a*i+b)//c for i in range(n+1))
    if a==0:return b//c*(n+1)
    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2
    m=(a*n+b)//c
    return n*m-floorsum(c,c-b-1,a,m-1)

def inverse(a,m):
    a%=m
    if a<=1: return a
    return ((1-inverse(m,a)*m)//a)%m
 
def lowbit(n):
    return n&-n
 
class BIT:
    def __init__(self,arr):
        self.arr=arr
        self.n=len(arr)-1
        
    def update(self,x,v):
        while x<=self.n:
            self.arr[x]+=v
            x+=x&-x
 
    def query(self,x):
        ans=0
        while x:
            ans+=self.arr[x]
            x&=x-1
        return ans
'''
class SMT:
    def __init__(self,arr):
        self.n=len(arr)-1#arr包含一个前导0
        self.arr=[0]*(self.n<<2)
        self.lazy=[0]*(self.n<<2)
        def Build(l,r,rt):
            if l==r:
                self.arr[rt]=arr[l]
                return
            m=(l+r)>>1
            Build(l,m,rt<<1)
            Build(m+1,r,rt<<1|1)
            self.pushup(rt)
        Build(1,self.n,1)
 
    def pushup(self,rt):
        self.arr[rt]=self.arr[rt<<1]+self.arr[rt<<1|1]
 
    def pushdown(self,rt,ln,rn):#lr,rn表区间数字数
        if self.lazy[rt]:
            self.lazy[rt<<1]+=self.lazy[rt]
            self.lazy[rt<<1|1]+=self.lazy[rt]
            self.arr[rt<<1]+=self.lazy[rt]*ln
            self.arr[rt<<1|1]+=self.lazy[rt]*rn
            self.lazy[rt]=0
            
    def update(self,L,R,c,l=1,r=None,rt=1):#L,R表示操作区间
        if r==None: r=self.n
        if L<=l and r<=R:
            self.arr[rt]+=c*(r-l+1)
            self.lazy[rt]+=c
            return
        m=(l+r)>>1
        self.pushdown(rt,m-l+1,r-m)
        if L<=m: self.update(L,R,c,l,m,rt<<1)
        if R>m: self.update(L,R,c,m+1,r,rt<<1|1)
        self.pushup(rt)
 
    def query(self,L,R,l=1,r=None,rt=1):
        if r==None: r=self.n
        #print(L,R,l,r,rt)
        if L<=l and R>=r:
            return self.arr[rt]
        m=(l+r)>>1
        self.pushdown(rt,m-l+1,r-m)
        ans=0
        if L<=m: ans+=self.query(L,R,l,m,rt<<1)
        if R>m: ans+=self.query(L,R,m+1,r,rt<<1|1)
        return ans
'''       
class DSU:#容量+路径压缩
    def __init__(self,n):
        self.c=[-1]*n
 
    def same(self,x,y):
        return self.find(x)==self.find(y)
 
    def find(self,x):
        if self.c[x]<0:
            return x
        self.c[x]=self.find(self.c[x])
        return self.c[x]
 
    def union(self,u,v):
        u,v=self.find(u),self.find(v)
        if u==v:
            return False
        if self.c[u]>self.c[v]:
            u,v=v,u
        self.c[u]+=self.c[v]
        self.c[v]=u
        return True
 
    def size(self,x): return -self.c[self.find(x)]
    
class UFS:#秩+路径
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n
 
    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]
 
    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv
 
def Prime(n):
    c=0
    prime=[]
    flag=[0]*(n+1)
    
    for i in range(2,n+1):
        if not flag[i]:
            prime.append(i)
            c+=1
        for j in range(c):
            if i*prime[j]>n: break
            flag[i*prime[j]]=prime[j]
            if i%prime[j]==0: break
    return prime
 
def dij(s,graph):
    d={}
    d[s]=0
    heap=[(0,s)]
    seen=set()
    while heap:
        dis,u=heappop(heap)
        if u in seen:
            continue
        seen.add(u)
        for v,w in graph[u]:
            if v not in d or d[v]>d[u]+w:
                d[v]=d[u]+w
                heappush(heap,(d[v],v))
    return d
 
def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]
def lcm(a,b): return a*b//gcd(a,b)
def lis(nums):
    res=[]
    for k in nums:
        i=bisect.bisect_left(res,k)
        if i==len(res):
            res.append(k)
        else:
            res[i]=k
    return len(res)
 
class DLN:
    def __init__(self,val):
        self.val=val
        self.pre=None
        self.next=None

def nb(i,j):
    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:
        if 0<=ni<n and 0<=nj<m:
            yield ni,nj

def topo(n):
    q=deque()
    res=[]
    for i in range(n):
        if ind[i]==0:
            q.append(i)
            res.append(i+1)
    while q:
        u=q.popleft()
        for v in g[u]:
            ind[v]-=1
            if ind[v]==0:
                q.append(v)
                res.append(v+1)
    return res

@bootstrap
def gdfs(r,p):
    if len(g[r])==1 and p!=-1:
        yield None
    for ch in g[r]:
        if ch!=p:
            yield gdfs(ch,r)
    yield None


def match(pat,cur):
    for i in range(k):
        if pat[i]!='_' and pat[i]!=cur[i]:
            #print(pat[i],cur[i])
            return False
    return True

def pos(cur):
    res=list(cur)
    #print(cur,res)
    pa=[]
    dfs(0,pa,res)
    return pa

def dfs(i,pa,res):
    #print(i,pa,res)
    global k
    if i==k:
        #print(res)
        pa.append(''.join(res))
        return 
    dfs(i+1,pa,res)
    #print(i,res,pa)
    tmp=res[i]
    res[i]='_'
    dfs(i+1,pa,res)
    res[i]=tmp
    


t=1
for i in range(t):
    n,m,k=RLL()
    p=[]
    d={}
    for i in range(n):
        cur=input()
        p.append(cur)
        d[cur]=i
    res=[]
    ans=True
    ind=[0]*n
    #print(d)
    g=[[] for i in range(n)]
    for i in range(m):
        cur,x=input().split()
        x=int(x)
        if ans:
            #print(cur,x,p[x-1])
            if not match(p[x-1],cur):
                ans=False
            else:
                #print(cur)
                for al in pos(cur):
                    if al in d and d[al]!=x-1:
                        g[x-1].append(d[al])
                        ind[d[al]]+=1
    if not ans:
        print(""NO"")
    else:
        #print(g,ind)
        ans=topo(n)
        if len(ans)!=n:
            print(""NO"")
        else:
            print(""YES"")
            print(*ans)
    #print(*ans)
            
    
                    
                    
        

''' 
sys.setrecursionlimit(200000)
import threading
threading.stack_size(10**8)
t=threading.Thr
ead(target=main)
t.start()
t.join()
'''

''' 
sys.setrecursionlimit(200000)
import threading
threading.stack_size(10**8)
t=threading.Thread(target=main)
t.start()
t.join()
'''
",1476_E,CODEFORCES,4724,Pattern Matching,"You are given $$$n$$$ patterns $$$p_1, p_2, \dots, p_n$$$ and $$$m$$$ strings $$$s_1, s_2, \dots, s_m$$$. Each pattern $$$p_i$$$ consists of $$$k$$$ characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string $$$s_j$$$ consists of $$$k$$$ lowercase Latin letters.
A string $$$a$$$ matches a pattern $$$b$$$ if for each $$$i$$$ from $$$1$$$ to $$$k$$$ either $$$b_i$$$ is a wildcard character or $$$b_i=a_i$$$.
You are asked to rearrange the patterns in such a way that the first pattern the $$$j$$$-th string matches is $$$p[mt_j]$$$. You are allowed to leave the order of the patterns unchanged.
Can you perform such a rearrangement? If you can, then print any valid order.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \le n, m \le 10^5$$$, $$$1 \le k \le 4$$$) — the number of patterns, the number of strings and the length of each pattern and string.
Each of the next $$$n$$$ lines contains a pattern — $$$k$$$ characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct.
Each of the next $$$m$$$ lines contains a string — $$$k$$$ lowercase Latin letters, and an integer $$$mt$$$ ($$$1 \le mt \le n$$$) — the index of the first pattern the corresponding string should match.
Print ""NO"" if there is no way to rearrange the patterns in such a way that the first pattern that the $$$j$$$-th string matches is $$$p[mt_j]$$$.
Otherwise, print ""YES"" in the first line. The second line should contain $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ — the order of the patterns. If there are multiple answers, print any of them.
The order of patterns after the rearrangement in the first example is the following: 
Thus, the first string matches patterns ab__, _bcd, _b_d in that order, the first of them is ab__, that is indeed $$$p[4]$$$. The second string matches __b_ and ab__, the first of them is __b_, that is $$$p[2]$$$. The last string matches _bcd and _b_d, the first of them is _bcd, that is $$$p[5]$$$.
The answer to that test is not unique, other valid orders also exist.
","input
In the second example cba doesn't match __c, thus, no valid order exists.
output
In the third example the order (a_, _b) makes both strings match pattern $$$1$$$ first and the order (_b, a_) makes both strings match pattern $$$2$$$ first. Thus, there is no order that produces the result $$$1$$$ and $$$2$$$.
","bitmasks, datastructures, dfsandsimilar, graphs, hashing, sortings, strings",7
"n,k=map(int,input().split())
low=1
high=n
import sys
while low<=high:
    mid=(low+high)//2
    if mid*(mid+1)//2 -(n-mid)>k:
        high=mid-1
    elif mid*(mid+1)//2-(n-mid)==k:
        print(n-mid)
        sys.exit()
    else :
        low=mid+1",1195_B,CODEFORCES,1349,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"from itertools import combinations
num,min_dif,max_dif,easy_hard_dif=map(int, input().split("" ""))
arr=[int(m) for m in input().split("" "")]
all_combinations=[]
for x in range(2, num+1):
    combs=combinations(arr, x)
    for abc in combs:
        all_combinations.append(list(abc))
possible_answers=0
for a in all_combinations:
    if sum(a)>=min_dif and sum(a)<=max_dif and max(a)-min(a)>=easy_hard_dif:
        possible_answers+=1
print(possible_answers)",0550_B,CODEFORCES,4431,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"n, q = map(int, input().split(' '))
a = list(map(int, input().split(' ')))


def p(c_k, r):
    l = 0
    while r - l > 1:
        z = (r + l) // 2
        if pr_a[z] > c_k:
            r = z
        else:
            l = z
    return l


pr_a = []
for i in range(n):
    pr_a.append(a[i])
    if i > 0:
        pr_a[i] += pr_a[i - 1]
k = list(map(int, input().split(' ')))
c_k = 0
ans = []
for qq in range(q):
    c_k += k[qq]
    l = p(c_k, n - 1)
    if pr_a[l] <= c_k:
        l += 1
    if c_k >= pr_a[n - 1]:
        c_k = 0
        l = 0
    ans.append(str(n - l))
print('\n'.join(ans))
",0975_C,CODEFORCES,2505,Valhalla Siege,"Ivar the Boneless is a great leader. He is trying to capture Kattegat from Lagertha. The war has begun and wave after wave Ivar's warriors are falling in battle.
Ivar has $$$n$$$ warriors, he places them on a straight line in front of the main gate, in a way that the $$$i$$$-th warrior stands right after $$$(i-1)$$$-th warrior. The first warrior leads the attack.
Each attacker can take up to $$$a_i$$$ arrows before he falls to the ground, where $$$a_i$$$ is the $$$i$$$-th warrior's strength.
Lagertha orders her warriors to shoot $$$k_i$$$ arrows during the $$$i$$$-th minute, the arrows one by one hit the first still standing warrior. After all Ivar's warriors fall and all the currently flying arrows fly by, Thor smashes his hammer and all Ivar's warriors get their previous strengths back and stand up to fight again. In other words, if all warriors die in minute $$$t$$$, they will all be standing to fight at the end of minute $$$t$$$.
The battle will last for $$$q$$$ minutes, after each minute you should tell Ivar what is the number of his standing warriors.
The first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \le n, q \leq 200\,000$$$) — the number of warriors and the number of minutes in the battle.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \leq a_i \leq 10^9$$$) that represent the warriors' strengths.
The third line contains $$$q$$$ integers $$$k_1, k_2, \ldots, k_q$$$ ($$$1 \leq k_i \leq 10^{14}$$$), the $$$i$$$-th of them represents Lagertha's order at the $$$i$$$-th minute: $$$k_i$$$ arrows will attack the warriors.
","input
Output $$$q$$$ lines, the $$$i$$$-th of them is the number of standing warriors after the $$$i$$$-th minute.
output
In the first example: 
",binarysearch,4
"x, y, z, t1, t2, t3, = map(int, input().split())
if abs(x-z)*t2 + abs((x-y))*t2 + t3*3 <= t1*abs((x-y)):
    print(""YES"")
else:
    print(""NO"")",1054_A,CODEFORCES,510,Elevator or Stairs?,"Masha lives in a multi-storey building, where floors are numbered with positive integers. Two floors are called adjacent if their numbers differ by one. Masha decided to visit Egor. Masha lives on the floor $$$x$$$, Egor on the floor $$$y$$$ (not on the same floor with Masha).
The house has a staircase and an elevator. If Masha uses the stairs, it takes $$$t_1$$$ seconds for her to walk between adjacent floors (in each direction). The elevator passes between adjacent floors (in each way) in $$$t_2$$$ seconds. The elevator moves with doors closed. The elevator spends $$$t_3$$$ seconds to open or close the doors. We can assume that time is not spent on any action except moving between adjacent floors and waiting for the doors to open or close. If Masha uses the elevator, it immediately goes directly to the desired floor.
Coming out of the apartment on her floor, Masha noticed that the elevator is now on the floor $$$z$$$ and has closed doors. Now she has to choose whether to use the stairs or use the elevator. 
If the time that Masha needs to get to the Egor's floor by the stairs is strictly less than the time it will take her using the elevator, then she will use the stairs, otherwise she will choose the elevator.
Help Mary to understand whether to use the elevator or the stairs.
The only line contains six integers $$$x$$$, $$$y$$$, $$$z$$$, $$$t_1$$$, $$$t_2$$$, $$$t_3$$$ ($$$1 \leq x, y, z, t_1, t_2, t_3 \leq 1000$$$) — the floor Masha is at, the floor Masha wants to get to, the floor the elevator is located on, the time it takes Masha to pass between two floors by stairs, the time it takes the elevator to pass between two floors and the time it takes for the elevator to close or open the doors.
It is guaranteed that $$$x \ne y$$$.
If the time it will take to use the elevator is not greater than the time it will take to use the stairs, print «YES» (without quotes), otherwise print «NO> (without quotes).
You can print each letter in any case (upper or lower).
In the first example:
If Masha goes by the stairs, the time she spends is $$$4 \cdot 4 = 16$$$, because she has to go $$$4$$$ times between adjacent floors and each time she spends $$$4$$$ seconds. 
If she chooses the elevator, she will have to wait $$$2$$$ seconds while the elevator leaves the $$$4$$$-th floor and goes to the $$$5$$$-th. After that the doors will be opening for another $$$1$$$ second. Then Masha will enter the elevator, and she will have to wait for $$$1$$$ second for the doors closing. Next, the elevator will spend $$$4 \cdot 2 = 8$$$ seconds going from the $$$5$$$-th floor to the $$$1$$$-st, because the elevator has to pass $$$4$$$ times between adjacent floors and spends $$$2$$$ seconds each time. And finally, it will take another $$$1$$$ second before the doors are open and Masha can come out. 
Thus, all the way by elevator will take $$$2 + 1 + 1 + 8 + 1 = 13$$$ seconds, which is less than $$$16$$$ seconds, so Masha has to choose the elevator.
","input
In the second example, it is more profitable for Masha to use the stairs, because it will take $$$13$$$ seconds to use the elevator, that is more than the $$$10$$$ seconds it will takes to go by foot.
output
In the third example, the time it takes to use the elevator is equal to the time it takes to walk up by the stairs, and is equal to $$$12$$$ seconds. That means Masha will take the elevator.
",implementation,1
"# ---------------------------iye ha aam zindegi---------------------------------------------
import math
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
mod = 10 ** 9 + 7
mod1 = 998244353
#sys.setrecursionlimit(300000)
# ------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192
#sys.setrecursionlimit(300000)
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# -------------------game starts now----------------------------------------------------import math
# -----------------------------------------------binary seacrh tree---------------------------------------
# -------------------game starts now----------------------------------------------------import math
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------------------iye ha chutiya zindegi-------------------------------------
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD


# --------------------------------------iye ha combinations ka zindegi---------------------------------
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m


# --------------------------------------iye ha power ka zindegi---------------------------------
def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z


# --------------------------------------------------product----------------------------------------
def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por


# --------------------------------------------------binary----------------------------------------
def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        # Check if middle element is
        # less than or equal to key
        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        # If key is smaller, ignore right half
        else:
            right = mid - 1

    return count


# --------------------------------------------------binary----------------------------------------
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    # Stores the index of the left most element
    # from the array which is greater than k
    leftGreater = n

    # Finds number of elements greater than k
    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        # If mid element is less than
        # or equal to k update l
        else:
            l = m + 1

    # Return the count of elements
    # greater than k
    return (n - leftGreater)
# --------------------------------------------------binary------------------------------------
n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]
#print(h)
#print(v)
for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)

",1015_E2,CODEFORCES,3402,Stars Drawing (Hard Edition),"A star is a figure of the following type: an asterisk character '*' in the center of the figure and four rays (to the left, right, top, bottom) of the same positive length. The size of a star is the length of its rays. The size of a star must be a positive number (i.e. rays of length $$$0$$$ are not allowed).
Let's consider empty cells are denoted by '.', then the following figures are stars:
You are given a rectangular grid of size $$$n \times m$$$ consisting only of asterisks '*' and periods (dots) '.'. Rows are numbered from $$$1$$$ to $$$n$$$, columns are numbered from $$$1$$$ to $$$m$$$. Your task is to draw this grid using any number of stars or find out that it is impossible. Stars can intersect, overlap or even coincide with each other. The number of stars in the output can't exceed $$$n \cdot m$$$. Each star should be completely inside the grid. You can use stars of same and arbitrary sizes.
In this problem, you do not need to minimize the number of stars. Just find any way to draw the given grid with at most $$$n \cdot m$$$ stars.
The first line of the input contains two integers $$$n$$$ and $$$m$$$ ($$$3 \le n, m \le 1000$$$) — the sizes of the given grid.
The next $$$n$$$ lines contains $$$m$$$ characters each, the $$$i$$$-th line describes the $$$i$$$-th row of the grid. It is guaranteed that grid consists of characters '*' and '.' only.
If it is impossible to draw the given grid using stars only, print ""-1"".
Otherwise in the first line print one integer $$$k$$$ ($$$0 \le k \le n \cdot m$$$) — the number of stars needed to draw the given grid. The next $$$k$$$ lines should contain three integers each — $$$x_j$$$, $$$y_j$$$ and $$$s_j$$$, where $$$x_j$$$ is the row index of the central star character, $$$y_j$$$ is the column index of the central star character and $$$s_j$$$ is the size of the star. Each star should be completely inside the grid.
","input
In the first example the output 
output
is also correct.
","binarysearch, dp, greedy",5
"n, k = [int(i) for i in input().split()]
for i in range(100*k+100*n):
    if i*(i+1) == (n+k-i)*2:
        print(n-i)
        break",1195_B,CODEFORCES,2225,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",3
"#Mamma don't raises quitter.................................................
from collections import deque as de
import math
from sys import stdin, stdout
import re
from collections import Counter as cnt
from functools import  reduce

from itertools import groupby as gb
#from fractions import Fraction as fr
from bisect import bisect_left as bl, bisect_right as br

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
    
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack() 

#decimal to binary   
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")
#binary to decimal
def binarytodecimal(n):
    return int(n,2)

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

 
# Function to get product of digits
def getProduct(n):
 
    product = 1
 
    while (n != 0):
        product = product * (n % 10)
        n = n // 10
 
    return product


#function to find LCM of two numbers
def lcm(x,y):
   lcm = (x*y)//math.gcd(x,y)
   return lcm

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 
#to check whether the given sorted sequnce is forming an AP or not....
def checkisap(list):
    d=list[1]-list[0]
    for i in range(2,len(list)):
        temp=list[i]-list[i-1]
        if temp !=d:
            return False
    return True
        
    

#ceil  function gives wrong answer after 10^17 so i have to create my own :)
# because i don't want to doubt on my solution of 900-1000 problem set.
def ceildiv(x,y): 
    return (x+y-1)//y 
  
def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(int, input()))
def indict():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(index)+1] = int(value)
    return dic
def frqdict():
    # by default it is for integer input. :)
    dic={}
    for index, value in enumerate(input().split()):
        if int(value) not in dic:
            dic[int(value)] =1
        else:
            dic[int(value)] +=1
    return dic

#inp = open(""input.txt"",""r"")
#out = open(""output.txt"",""w"")
#Here we go......................
#practice like your never won
#perform like you never lost
n,pos, l, r=di()
if l==1 and r==n:
    print(0)
else:
    if pos < l:
        ans=l-pos+1
        if r <n:
            ans+=(r-l)
            ans+=1
        print(ans)
    elif l<=pos<=r:
        if l >1 and r<n:
            ans=(r-l)
            ans+=min(pos-l,r-pos)
            ans+=2
        elif l>1 and r==n:
            ans=pos-l
            ans+=1
        else:
            ans=r-pos
            ans+=1
        print(ans)
            
            
    else:
        ans=pos-r+1
        if l>1:
            ans+=(r-l)
            ans+=1
        print(ans)


        
        
        

        

    
            
        
        
    
        
        
        


                
                

    


        
        
    
    
    
        
    
        
    




    

                
    
        


        
    

            
        
    

                
                
                
        
        
        

            

        





                    
                
            
        

            
    
        
    
    

    
        
    
 

    
        


    
        

",0915_B,CODEFORCES,251,Browser,"Luba is surfing the Internet. She currently has n opened tabs in her browser, indexed from 1 to n from left to right. The mouse cursor is currently located at the pos-th tab. Luba needs to use the tabs with indices from l to r (inclusive) for her studies, and she wants to close all the tabs that don't belong to this segment as fast as possible.
Each second Luba can either try moving the cursor to the left or to the right (if the cursor is currently at the tab i, then she can move it to the tab max(i - 1, a) or to the tab min(i + 1, b)) or try closing all the tabs to the left or to the right of the cursor (if the cursor is currently at the tab i, she can close all the tabs with indices from segment [a, i - 1] or from segment [i + 1, b]). In the aforementioned expressions a and b denote the minimum and maximum index of an unclosed tab, respectively. For example, if there were 7 tabs initially and tabs 1, 2 and 7 are closed, then a = 3, b = 6.
What is the minimum number of seconds Luba has to spend in order to leave only the tabs with initial indices from l to r inclusive opened?
The only line of input contains four integer numbers n, pos, l, r (1 ≤ n ≤ 100, 1 ≤ pos ≤ n, 1 ≤ l ≤ r ≤ n) — the number of the tabs, the cursor position and the segment which Luba needs to leave opened.
Print one integer equal to the minimum number of seconds required to close all the tabs outside the segment [l, r].
In the first test Luba can do the following operations: shift the mouse cursor to the tab 2, close all the tabs to the left of it, shift the mouse cursor to the tab 3, then to the tab 4, and then close all the tabs to the right of it.
","input
In the second test she only needs to close all the tabs to the right of the current position of the cursor.
output
In the third test Luba doesn't need to do anything.
",implementation,1
"k=int(input())
a=[]
for i in range(0,12):
    s=9*pow(10,i)*(i+1)
    if k<=s:
        break
    else:
        k-=s
pos=i+1
num=(pow(10,pos-1)+(k//pos)-1)
if k%pos==0:
    print(str(num)[-1])
else:
    print(str(num+(0 if pos==1 else 1))[(k%pos)-1])
 
",1177_B,CODEFORCES,712,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",1
"n = int(input())
i = 0
s = 0
while True:
	temp = (i+1)*9*(10**i)
	if s + temp <= n:
		s += temp
		i += 1
	else:
		break
tc = n - s

nd = tc//(i+1) - 1
tc -= (nd+1)*(i+1)
f = 10**i + nd
if tc != 0:
	print(str(10**i+nd+1)[tc-1])
else:
	print(str(10**i+nd)[-1])
",1177_B,CODEFORCES,1331,Digits Sequence (Hard Edition),"Let's write all the positive integer numbers one after another from $$$1$$$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...
Your task is to print the $$$k$$$-th digit of this sequence.
","input
The first and only line contains integer $$$k$$$ ($$$1 \le k \le 10^{12}$$$) — the position to process ($$$1$$$-based index).
output
Print the $$$k$$$-th digit of the resulting infinite sequence.
","binarysearch, divideandconquer, implementation",2
"import itertools
import bisect
import math
from collections import *
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())


def main():
    a = li()
    b = li()
    n = len(a)
    ans = 0
    for i in range(n):
        if a[i] == ""0"":
            ans += 1
            if i - 1 >= 0 and a[i] == b[i] == b[i - 1]:
                a[i] = b[i] = b[i - 1] = ""X""
            elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]:
                a[i] = b[i] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == b[i + 1]:
                a[i] = b[i] = b[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]:
                a[i] = b[i + 1] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == a[i + 1]:
                a[i] = b[i] = a[i + 1] = ""X""
            else:
                ans -= 1
    print(ans)
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

# a03e7a21f6788bc81f27641a9c1f55f66ef836ddc748e5f5a882374bb22a897d


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",0991_D,CODEFORCES,378,Bishwock,"Bishwock is a chess figure that consists of three squares resembling an ""L-bar"". This figure can be rotated by 90, 180 and 270 degrees so it can have four possible states:
Bishwocks don't attack any squares and can even occupy on the adjacent squares as long as they don't occupy the same square. 
Vasya has a board with $$$2\times n$$$ squares onto which he wants to put some bishwocks. To his dismay, several squares on this board are already occupied by pawns and Vasya can't put bishwocks there. However, pawns also don't attack bishwocks and they can occupy adjacent squares peacefully.
Knowing the positions of pawns on the board, help Vasya to determine the maximum amount of bishwocks he can put onto the board so that they wouldn't occupy the same squares and wouldn't occupy squares with pawns.
","input
The input contains two nonempty strings that describe Vasya's board. Those strings contain only symbols ""0"" (zero) that denote the empty squares and symbols ""X"" (uppercase English letter) that denote the squares occupied by pawns. Strings are nonempty and are of the same length that does not exceed $$$100$$$.
output
Output a single integer — the maximum amount of bishwocks that can be placed onto the given board.
","dp, greedy",1
"n,m,a,b=map(int,input().split())
z=(n%m)*b
x=((n//m+1)*m-n)*a
y=min(z,x)
print(y if y>0 else 0)",0990_A,CODEFORCES,1689,Commentary Boxes,"Berland Football Cup starts really soon! Commentators from all over the world come to the event.
Organizers have already built $$$n$$$ commentary boxes. $$$m$$$ regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.
If $$$n$$$ is not divisible by $$$m$$$, it is impossible to distribute the boxes to the delegations at the moment.
Organizers can build a new commentary box paying $$$a$$$ burles and demolish a commentary box paying $$$b$$$ burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.
What is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$)?
The only line contains four integer numbers $$$n$$$, $$$m$$$, $$$a$$$ and $$$b$$$ ($$$1 \le n, m \le 10^{12}$$$, $$$1 \le a, b \le 100$$$), where $$$n$$$ is the initial number of the commentary boxes, $$$m$$$ is the number of delegations to come, $$$a$$$ is the fee to build a box and $$$b$$$ is the fee to demolish a box.
Output the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$). It is allowed that the final number of the boxes is equal to $$$0$$$.
In the first example organizers can build $$$5$$$ boxes to make the total of $$$14$$$ paying $$$3$$$ burles for the each of them.
","input
In the second example organizers can demolish $$$2$$$ boxes to make the total of $$$0$$$ paying $$$7$$$ burles for the each of them.
output
In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get $$$5$$$ boxes.
","implementation, math",3
"n = int(input())
ans = [1, 3, 5, 7, 9, 11, 13, 15]
dct = \
{
    1 : 1,
    3 : 18,
    5 : 1800,
    7 : 670320,
    9 : 734832000,
    11 : 890786230,
    13 : 695720788,
    15 : 150347555
}
if n in ans:
    print(dct[n])
else:
    print(0)",0285_D,CODEFORCES,4293,Permutation Sum,"Permutation p is an ordered set of integers p1,  p2,  ...,  pn, consisting of n distinct positive integers, each of them doesn't exceed n. We'll denote the i-th element of permutation p as pi. We'll call number n the size or the length of permutation p1,  p2,  ...,  pn.
Petya decided to introduce the sum operation on the set of permutations of length n. Let's assume that we are given two permutations of length n: a1, a2, ..., an and b1, b2, ..., bn. Petya calls the sum of permutations a and b such permutation c of length n, where ci = ((ai - 1 + bi - 1) mod n) + 1 (1 ≤ i ≤ n).
Operation  means taking the remainder after dividing number x by number y.
Obviously, not for all permutations a and b exists permutation c that is sum of a and b. That's why Petya got sad and asked you to do the following: given n, count the number of such pairs of permutations a and b of length n, that exists permutation c that is sum of a and b. The pair of permutations x, y (x ≠ y) and the pair of permutations y, x are considered distinct pairs.
As the answer can be rather large, print the remainder after dividing it by 1000000007 (109 + 7).
","input
The single line contains integer n (1 ≤ n ≤ 16).
output
In the single line print a single non-negative integer — the number of such pairs of permutations a and b, that exists permutation c that is sum of a and b, modulo 1000000007 (109 + 7).
","bitmasks, combinatorics, dp, implementation, meet-in-the-middle",7
"#!/usr/bin/env python
import os
import re
import sys
from bisect import bisect, bisect_left, insort, insort_left
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from fractions import gcd
from io import BytesIO, IOBase
from itertools import (
    accumulate, combinations, combinations_with_replacement, groupby,
    permutations, product)
from math import (
    acos, asin, atan, ceil, cos, degrees, factorial, hypot, log2, pi, radians,
    sin, sqrt, tan)
from operator import itemgetter, mul
from string import ascii_lowercase, ascii_uppercase, digits


def inp():
    return(int(input()))


def inlist():
    return(list(map(int, input().split())))


def instr():
    s = input()
    return(list(s[:len(s)]))


def invr():
    return(map(int, input().split()))


def getSum(p, q):
    n = q - p + 1

    temp = (n * (p + q)//2) - n + 1
    #print(temp, p, q, n)
    return temp, n


def main():
    # sys.stdin = open('input.txt', 'r')
    # sys.stdout = open('output.txt', 'w')

    n, k = invr()

    l = 2
    r = k
    ans = -1

    while l <= r:
        mid = l + (r - l) // 2
        tot, count = getSum(mid, k)
        if tot >= n:
            ans = count
        if tot < n:
            r = mid - 1
        else:
            l = mid + 1
    if n == 1:
        ans = 0
    print(ans)

    # region fastio
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")

# endregion


if __name__ == ""__main__"":
    main()
",0287_B,CODEFORCES,930,Pipeline,"Vova, the Ultimate Thule new shaman, wants to build a pipeline. As there are exactly n houses in Ultimate Thule, Vova wants the city to have exactly n pipes, each such pipe should be connected to the water supply. A pipe can be connected to the water supply if there's water flowing out of it. Initially Vova has only one pipe with flowing water. Besides, Vova has several splitters.
A splitter is a construction that consists of one input (it can be connected to a water pipe) and x output pipes. When a splitter is connected to a water pipe, water flows from each output pipe. You can assume that the output pipes are ordinary pipes. For example, you can connect water supply to such pipe if there's water flowing out from it. At most one splitter can be connected to any water pipe.
Vova has one splitter of each kind: with 2, 3, 4, ..., k outputs. Help Vova use the minimum number of splitters to build the required pipeline or otherwise state that it's impossible.
Vova needs the pipeline to have exactly n pipes with flowing out water. Note that some of those pipes can be the output pipes of the splitters.
The first line contains two space-separated integers n and k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 109).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
Print a single integer — the minimum number of splitters needed to build the pipeline. If it is impossible to build a pipeline with the given splitters, print -1.
","binarysearch, math",2
"def main():
    n = int(input())
    arr = []
    
    for i in range(n):
        arr.append(input())
        
    arr = sorted(arr, key=lambda x : len(x))
    
    for i in range(n-1):
        if arr[i] not in arr[i+1]:
            print('NO')
            return;
    
    print('YES')
    for pal in arr:
        print(pal)

main()
	 		 			    	   							 		 		 	",0988_B,CODEFORCES,2596,Substrings Sort,"You are given $$$n$$$ strings. Each string consists of lowercase English letters. Rearrange (reorder) the given strings in such a way that for every string, all strings that are placed before it are its substrings.
String $$$a$$$ is a substring of string $$$b$$$ if it is possible to choose several consecutive letters in $$$b$$$ in such a way that they form $$$a$$$. For example, string ""for"" is contained as a substring in strings ""codeforces"", ""for"" and ""therefore"", but is not contained as a substring in strings ""four"", ""fofo"" and ""rof"".
The first line contains an integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of strings.
The next $$$n$$$ lines contain the given strings. The number of letters in each string is from $$$1$$$ to $$$100$$$, inclusive. Each string consists of lowercase English letters.
Some strings might be equal.
If it is impossible to reorder $$$n$$$ given strings in required order, print ""NO"" (without quotes).
","input
Otherwise print ""YES"" (without quotes) and $$$n$$$ given strings in required order.
output
In the second example you cannot reorder the strings because the string ""abab"" is not a substring of the string ""abacaba"".
","sortings, strings",4
"k1,k2,k3 = map(int, input().strip().split(' '))
l=[k1,k2,k3]
if min(k1,k2,k3)==1:
    print('yes')
elif l.count(2)>=2:
    print('yes')
elif l.count(3)==3:
    print('yes')
elif l.count(4)==2 and l.count(2)==1:
    print('yes')
else:
    print('no')",0911_C,CODEFORCES,201,Three Garlands,"Mishka is decorating the Christmas tree. He has got three garlands, and all of them will be put on the tree. After that Mishka will switch these garlands on.
When a garland is switched on, it periodically changes its state — sometimes it is lit, sometimes not. Formally, if i-th garland is switched on during x-th second, then it is lit only during seconds x, x + ki, x + 2ki, x + 3ki and so on.
Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland. Formally, Mishka wants to choose three integers x1, x2 and x3 (not necessarily distinct) so that he will switch on the first garland during x1-th second, the second one — during x2-th second, and the third one — during x3-th second, respectively, and during each second starting from max(x1, x2, x3) at least one garland will be lit.
Help Mishka by telling him if it is possible to do this!
The first line contains three integers k1, k2 and k3 (1 ≤ ki ≤ 1500) — time intervals of the garlands.
If Mishka can choose moments of time to switch on the garlands in such a way that each second after switching the garlands on at least one garland will be lit, print YES.
Otherwise, print NO.
","input
In the first example Mishka can choose x1 = 1, x2 = 2, x3 = 1. The first garland will be lit during seconds 1, 3, 5, 7, ..., the second — 2, 4, 6, 8, ..., which already cover all the seconds after the 2-nd one. It doesn't even matter what x3 is chosen. Our choice will lead third to be lit during seconds 1, 4, 7, 10, ..., though.
output
In the second example there is no way to choose such moments of time, there always be some seconds when no garland is lit.
","bruteforce, constructivealgorithms",1
"import sys


def ask(c, d):
    print(""? {} {}"".format(c, d))
    return int(input())


c = d = 0


def solve(mi, base):
    def solve_same():
        global c, d
        print(""# solve_same"", file=sys.stderr)
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d)
            res2 = ask(c, d ^ bit)
            if res1 == -1 and res2 == 1:
                c |= bit
                d |= bit

    def solve1():
        global c, d
        print(""# solve1"", file=sys.stderr)
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == -1:
                # a[i] == 1, b[i] == 0
                c |= bit
                return solve(i - 1, ask(c, d))
            else:
                # a[i] == b[i]
                res2 = ask(c ^ bit, d)
                if res2 == -1:
                    # a[i] == b[i] == 1
                    c |= bit
                    d |= bit

    def solve2():
        global c, d
        print(""# solve2"", file=sys.stderr)
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == 1:
                # a[i] == 0, b[i] == 1
                d |= bit
                return solve(i - 1, ask(c, d))
            else:
                # a[i] == b[i]
                res2 = ask(c, d ^ bit)
                if res2 == 1:
                    # a[i] == b[i] == 1
                    c |= bit
                    d |= bit

    if base == 0:
        solve_same()
    elif base == 1:
        solve1()
    else:
        solve2()


solve(29, ask(0, 0))
print(""! {} {}"".format(c, d))
",1088_D,CODEFORCES,642,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",1
"import os, sys
from io import BytesIO, IOBase


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
get_bit = lambda x, i: (x >> i) & 1

n = int(input())
a, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1

if n == 1:
    exit(print(1))

for i in range(n):
    for j in range(i + 1, n):
        masks[big ^ (1 << j)] += a[i][j]
        masks[big ^ (1 << i)] += a[j][i]

for _ in range(2, n):
    tem = dict()
    for msk in masks:
        for bit in range(18):
            if get_bit(msk, bit):
                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]
    masks = tem

su = sum(masks.values())
print(*[masks[2 ** i] / su for i in range(n)])
",0016_E,CODEFORCES,4281,Fish,"n fish, numbered from 1 to n, live in a lake. Every day right one pair of fish meet, and the probability of each other pair meeting is the same. If two fish with indexes i and j meet, the first will eat up the second with the probability aij, and the second will eat up the first with the probability aji = 1 - aij. The described process goes on until there are at least two fish in the lake. For each fish find out the probability that it will survive to be the last in the lake.
","input
The first line contains integer n (1 ≤ n ≤ 18) — the amount of fish in the lake. Then there follow n lines with n real numbers each — matrix a. aij (0 ≤ aij ≤ 1) — the probability that fish with index i eats up fish with index j. It's guaranteed that the main diagonal contains zeros only, and for other elements the following is true: aij = 1 - aji. All real numbers are given with not more than 6 characters after the decimal point.
output
Output n space-separated real numbers accurate to not less than 6 decimal places. Number with index i should be equal to the probability that fish with index i will survive to be the last in the lake.
","bitmasks, dp, probabilities",7
"def main():
    n, d, k = map(int, input().split())
    r, odd = divmod(d, 2)
    k -= 1
    cap = d + 1 if k == 1 else 1
    if k > 1:
        cap = 2 * (k ** (r + 1) - 1) // (k - 1) if odd else 1 + (k + 1) * (k ** r - 1) // (k - 1)
    if n == 1 or k < 1 < n - 1 or k == 1 and d != n - 1 or d >= n or k > 1 and not d < n <= cap:
        print('NO')
        return

    def dfs(parent, depth):
        stack = []
        for _ in range(k - 1):
            child = rest.pop()
            res.append('%s %s' % (parent, child))
            if depth:
                stack.append((child, depth))
        while stack:
            parent, depth = stack.pop()
            depth -= 1
            for _ in range(k):
                child = rest.pop()
                res.append('%s %s' % (parent, child))
                if depth:
                    stack.append((child, depth))

    res = ['YES']
    for pc in enumerate(range(2, d + 2), 1):
        res.append('%d %d' % pc)
    rest = list(range(n, d + 1, -1))
    try:
        for p in range(r + 1, r + odd + 2):
            dfs(p, r - 1)
        for de, p, q in zip(range(r - 2, -1, -1), range(r, 1, -1), range(r + odd + 2, d + 1)):
            dfs(p, de)
            dfs(q, de)
    except IndexError:
        pass
    print('\n'.join(res))


if __name__ == '__main__':
    main()
",1003_E,CODEFORCES,3366,Tree Constructing,"You are given three integers $$$n$$$, $$$d$$$ and $$$k$$$.
Your task is to construct an undirected tree on $$$n$$$ vertices with diameter $$$d$$$ and degree of each vertex at most $$$k$$$, or say that it is impossible.
An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Diameter of a tree is the maximum length of a simple path (a path in which each vertex appears at most once) between all pairs of vertices of this tree.
Degree of a vertex is the number of edges incident to this vertex (i.e. for a vertex $$$u$$$ it is the number of edges $$$(u, v)$$$ that belong to the tree, where $$$v$$$ is any other vertex of a tree).
The first line of the input contains three integers $$$n$$$, $$$d$$$ and $$$k$$$ ($$$1 \le n, d, k \le 4 \cdot 10^5$$$).
","input
If there is no tree satisfying the conditions above, print only one word ""NO"" (without quotes).
output
Otherwise in the first line print ""YES"" (without quotes), and then print $$$n - 1$$$ lines describing edges of a tree satisfying the conditions above. Vertices of the tree must be numbered from $$$1$$$ to $$$n$$$. You can print edges and vertices connected by an edge in any order. If there are multiple answers, print any of them.1
","constructivealgorithms, graphs",5
"import sys
input = sys.stdin.readline

n=int(input())
P=list(map(int,input().split()))
mod=998244353

INV=[None]*(n+1)#1/aのリストを予め作っておく.
for i in range(1,n+1):
    INV[i]=pow(i,mod-2,mod)

BLA=P.count(-1)

if BLA==0 or BLA==1:
    ANS=0
else:
    LEFT=BLA*(BLA-1)//2*INV[BLA]%mod#左側の個数の平均
    AVEP=BLA*(BLA-1)//2*pow(BLA-1,mod-2,mod)#左側にあるものが自分より大きい確率の和

    ANS=LEFT*AVEP%mod


#print(ANS,LEFT,AVEP)
y=1
for i in range(BLA):
    y=y*(BLA-i)%mod

KOSUU=pow(y,mod-2,mod)
BLALIST=[1]*(n+1)
NONBLA=[]
BLANUM=[0]*n
for i in range(n):
    if P[i]!=-1:
        BLALIST[P[i]]=0
        BLANUM[i]=BLANUM[i-1]
        NONBLA.append(P[i])
        
    else:
        BLANUM[i]=BLANUM[i-1]+1

#print(BLALIST)
BLALIST[0]=0
for i in range(1,n+1):
    BLALIST[i]=BLALIST[i-1]+BLALIST[i]
    
if BLA!=0:
    for i in range(n):
        if P[i]!=-1:
            ANS=(ANS+(BLANUM[i]*(BLA-BLALIST[P[i]])+(BLA-BLANUM[i])*BLALIST[P[i]])*INV[BLA])%mod

#print(ANS)

A=NONBLA

if A==[]:
    print(ANS)
    sys.exit()


n=len(A)
MAXA=max(A)
MINA=min(A)


BIT=[0]*(MAXA-MINA+2)#出現回数をbit indexed treeの形でもっておく.

for i in range(n):#A[0],A[1],...とBITを更新
    bitobje=A[i]-MINA+1

    x=bitobje
    while x!=0:
        ANS=(ANS-BIT[x])%mod
        x-=(x&(-x))

    #print(ANS)

    x2=MAXA-MINA+1
    #print(x2)
    while x2!=0:
        #print(x2,BIT)
        ANS=(ANS+BIT[x2])%mod
        x2-=(x2&(-x2))

    #print(ANS)

    y=bitobje
    while y<=MAXA-MINA+1:
        BIT[y]+=1
        y+=(y&(-y))

    #print(ANS,BIT)

print(ANS)

",1096_F,CODEFORCES,2907,Inversion Expectation,"A permutation of size $$$n$$$ is an array of size $$$n$$$ such that each integer from $$$1$$$ to $$$n$$$ occurs exactly once in this array. An inversion in a permutation $$$p$$$ is a pair of indices $$$(i, j)$$$ such that $$$i > j$$$ and $$$a_i < a_j$$$. For example, a permutation $$$[4, 1, 3, 2]$$$ contains $$$4$$$ inversions: $$$(2, 1)$$$, $$$(3, 1)$$$, $$$(4, 1)$$$, $$$(4, 3)$$$.
You are given a permutation $$$p$$$ of size $$$n$$$. However, the numbers on some positions are replaced by $$$-1$$$. Let the valid permutation be such a replacement of $$$-1$$$ in this sequence back to numbers from $$$1$$$ to $$$n$$$ in such a way that the resulting sequence is a permutation of size $$$n$$$.
The given sequence was turned into a valid permutation randomly with the equal probability of getting each valid permutation.
Calculate the expected total number of inversions in the resulting valid permutation.
It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the length of the sequence.
The second line contains $$$n$$$ integers $$$p_1, p_2, \dots, p_n$$$ ($$$-1 \le p_i \le n$$$, $$$p_i \ne 0$$$) — the initial sequence.
It is guaranteed that all elements not equal to $$$-1$$$ are pairwise distinct.
Print a single integer — the expected total number of inversions in the resulting valid permutation.
It can be shown that it is in the form of $$$\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \ne 0$$$. Report the value of $$$P \cdot Q^{-1} \pmod {998244353}$$$.
In the first example two resulting valid permutations are possible:
The expected value is $$$\frac{2 \cdot 1 + 3 \cdot 1}{2} = 2.5$$$.
","input
In the second example no $$$-1$$$ are present, thus the only valid permutation is possible — the given one. It has $$$0$$$ inversions.
output
In the third example there are two resulting valid permutations — one with $$$0$$$ inversions and one with $$$1$$$ inversion.
","dp, math, probabilities",4
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
lf = [(a[i], i) for i in range(n) if a[i] == 1]
it = [(a[i], i) for i in range(n) if a[i] > 1]
it.sort(reverse=True)
while len(lf) < 2:
    lf.append(it.pop())

ed = []
_, last = lf.pop()

for i in range(len(it)):
    cap, u = it[i]
    if i != 0:
        ed.append((it[i - 1][1], u))
        cap -= 1
    while lf and cap > 1:
        _, l = lf.pop()
        ed.append((u, l))
        cap -= 1

if lf:
    ans = 'NO'
else:
    ans = 'YES %d' % (len(it) + 1,)
    ed.append((it[-1][1], last))
    ans1 = str(len(ed))
    ans2 = '\n'.join('%d %d' % (u + 1, v + 1) for u, v in ed)
    ans = '\n'.join([ans, ans1, ans2])
print(ans)
",1082_D,CODEFORCES,2898,Maximum Diameter Graph,"Graph constructive problems are back! This time the graph you are asked to build should match the following properties.
The graph is connected if and only if there exists a path between every pair of vertices.
The diameter (aka ""longest shortest path"") of a connected undirected graph is the maximum number of edges in the shortest path between any pair of its vertices.
The degree of a vertex is the number of edges incident to it.
Given a sequence of $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ construct a connected undirected graph of $$$n$$$ vertices such that:
Output the resulting graph or report that no solution exists.
The first line contains a single integer $$$n$$$ ($$$3 \le n \le 500$$$) — the number of vertices in the graph.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le n - 1$$$) — the upper limits to vertex degrees.
Print ""NO"" if no graph can be constructed under the given conditions.
Otherwise print ""YES"" and the diameter of the resulting graph in the first line.
The second line should contain a single integer $$$m$$$ — the number of edges in the resulting graph.
The $$$i$$$-th of the next $$$m$$$ lines should contain two integers $$$v_i, u_i$$$ ($$$1 \le v_i, u_i \le n$$$, $$$v_i \neq u_i$$$) — the description of the $$$i$$$-th edge. The graph should contain no multiple edges — for each pair $$$(x, y)$$$ you output, you should output no more pairs $$$(x, y)$$$ or $$$(y, x)$$$.
Here are the graphs for the first two example cases. Both have diameter of $$$2$$$.
$$$d_2 = 2 \le a_2 = 2$$$
$$$d_3 = 1 \le a_3 = 2$$$ 
$$$d_2 = 4 \le a_2 = 4$$$
","input
$$$d_3 = 1 \le a_3 = 1$$$
output
$$$d_4 = 1 \le a_4 = 1$$$ 
","constructivealgorithms, graphs, implementation",4
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

n = int(input())
above = n // 3
below = n - above
for i in range(above):
    print(2 * i + 1, 3)
for i in range(below):
    print(i, 0)
",1067_C,CODEFORCES,2013,Knights,"Ivan places knights on infinite chessboard. Initially there are $$$n$$$ knights. If there is free cell which is under attack of at least $$$4$$$ knights then he places new knight in this cell. Ivan repeats this until there are no such free cells. One can prove that this process is finite. One can also prove that position in the end does not depend on the order in which new knights are placed.
Ivan asked you to find initial placement of exactly $$$n$$$ knights such that in the end there will be at least $$$\lfloor \frac{n^{2}}{10} \rfloor$$$ knights.
The only line of input contains one integer $$$n$$$ ($$$1 \le n \le 10^{3}$$$) — number of knights in the initial placement.
Print $$$n$$$ lines. Each line should contain $$$2$$$ numbers $$$x_{i}$$$ and $$$y_{i}$$$ ($$$-10^{9} \le x_{i}, \,\, y_{i} \le 10^{9}$$$) — coordinates of $$$i$$$-th knight. For all $$$i \ne j$$$, $$$(x_{i}, \,\, y_{i}) \ne (x_{j}, \,\, y_{j})$$$ should hold. In other words, all knights should be in different cells.
It is guaranteed that the solution exists.
Let's look at second example:
","input

output
Green zeroes are initial knights. Cell $$$(3, \,\, 3)$$$ is under attack of $$$4$$$ knights in cells $$$(1, \,\, 2)$$$, $$$(2, \,\, 1)$$$, $$$(4, \,\, 1)$$$ and $$$(5, \,\, 2)$$$, therefore Ivan will place a knight in this cell. Cell $$$(4, \,\, 5)$$$ is initially attacked by only $$$3$$$ knights in cells $$$(2, \,\, 6)$$$, $$$(5, \,\, 7)$$$ and $$$(6, \,\, 6)$$$. But new knight in cell $$$(3, \,\, 3)$$$ also attacks cell $$$(4, \,\, 5)$$$, now it is attacked by $$$4$$$ knights and Ivan will place another knight in this cell. There are no more free cells which are attacked by $$$4$$$ or more knights, so the process stops. There are $$$9$$$ knights in the end, which is not less than $$$\lfloor \frac{7^{2}}{10} \rfloor = 4$$$.
",constructivealgorithms,3
"import sys
import copy

input = sys.stdin.readline

n,m=map(int,input().split())
MAT=[list(map(int,input().split())) for i in range(n)]

#n=15
#m=10000
#MAT=[list(range(j*j,j*j*(m+1),j*j)) for j in range(1,n+1)]


if n==1:
    ANS=10**10
    for i in range(1,m):
        if ANS>abs(MAT[0][i]-MAT[0][i-1]):
            ANS=abs(MAT[0][i]-MAT[0][i-1])
    print(ANS)
    sys.exit()



EDGE0=[[10**10]*n for i in range(n)]#iが0行目,jが最終行
EDGE1=[[10**10]*n for i in range(n)]
MAX=0
MIN=0

if m!=1:    
    for i in range(n):
        for j in range(n):

            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])
            
            if EDGE1[i][j]>MAX:
                MAX=EDGE1[i][j]

            EDGE0[i][j]=min([abs(MAT[i][k]-MAT[j][k-1]) for k in range(1,m)])
else:
    for i in range(n):
        for j in range(n):

            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])
            
            if EDGE1[i][j]>MAX:
                MAX=EDGE1[i][j]
    

def Hamilton(start,USED,rest,last,weight):
    #print(start,USED,rest,last,weight,last*(1<<n)+USED)
    if MEMO[last*(1<<n)+USED]!=2:
        return MEMO[last*(1<<n)+USED]
    if rest==1:
        for i in range(n):
            if USED & (1<<i)==0:
                final=i
                break

        if EDGE0[start][final]>=weight and EDGE1[last][final]>=weight:
            #print(start,USED,rest,last,weight)

            MEMO[last*(1<<n)+USED]=1
            return 1
        else:
            #print(start,USED,weight,""!"")
            MEMO[last*(1<<n)+USED]=0
            return 0

    for j in range(n):
        if USED & (1<<j)==0 and EDGE1[last][j]>=weight:
            
            NEXT=USED+(1<<j)
            if Hamilton(start,NEXT,rest-1,j,weight)==1:
                #print(start,USED,rest,last,weight)
                MEMO[last*(1<<n)+USED]=1
                return 1
    else:
        #print(start,USED,weight,""?"")
        MEMO[last*(1<<n)+USED]=0
        return 0
        
    
while MAX!=MIN:
    #print(MAX,MIN)
    aveweight=(MAX+MIN+1)//2

    for start in range(n):
        MEMO=[2]*(n*1<<(n+1))
        START=1<<start
        if Hamilton(start,START,n-1,start,aveweight)==1:
            MIN=aveweight
            break
    else:
        MAX=aveweight-1

print(MAX)
",1102_F,CODEFORCES,4591,Elongated Matrix,"You are given a matrix $$$a$$$, consisting of $$$n$$$ rows and $$$m$$$ columns. Each cell contains an integer in it.
You can change the order of rows arbitrarily (including leaving the initial order), but you can't change the order of cells in a row. After you pick some order of rows, you traverse the whole matrix the following way: firstly visit all cells of the first column from the top row to the bottom one, then the same for the second column and so on. During the traversal you write down the sequence of the numbers on the cells in the same order you visited them. Let that sequence be $$$s_1, s_2, \dots, s_{nm}$$$. 
The traversal is $$$k$$$-acceptable if for all $$$i$$$ ($$$1 \le i \le nm - 1$$$) $$$|s_i - s_{i + 1}| \ge k$$$.
Find the maximum integer $$$k$$$ such that there exists some order of rows of matrix $$$a$$$ that it produces a $$$k$$$-acceptable traversal.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 16$$$, $$$1 \le m \le 10^4$$$, $$$2 \le nm$$$) — the number of rows and the number of columns, respectively.
Each of the next $$$n$$$ lines contains $$$m$$$ integers ($$$1 \le a_{i, j} \le 10^9$$$) — the description of the matrix.
Print a single integer $$$k$$$ — the maximum number such that there exists some order of rows of matrix $$$a$$$ that it produces an $$$k$$$-acceptable traversal.
In the first example you can rearrange rows as following to get the $$$5$$$-acceptable traversal:
Then the sequence $$$s$$$ will be $$$[5, 10, 4, 9, 3, 8, 3, 9]$$$. Each pair of neighbouring elements have at least $$$k = 5$$$ difference between them.
","input
In the second example the maximum $$$k = 0$$$, any order is $$$0$$$-acceptable.
output
In the third example the given order is already $$$3$$$-acceptable, you can leave it as it is.
","binarysearch, bitmasks, bruteforce, dp, graphs",7
"l,r=input().split("" "")
l,r=int(l),int(r)

a,b,c=l,l+1,l+2

if (l % 2 != 0):
    a,b,c=a+1,b+1,c+1
    
if (c > r):
    print(-1)
    
else:
    print(a,b,c)",0483_A,CODEFORCES,170,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"import math
import sys
from bisect import bisect_right, bisect_left, insort_right
from collections import Counter, defaultdict
from heapq import heappop, heappush
from itertools import accumulate
from sys import stdout

R = lambda: map(int, input().split())
t = input()
s = input()
k = t.count('+') - s.count('+')
n = s.count('?')
if k > n or k < 0:
    print('0.0')
else:
    print(math.factorial(n) / (math.factorial(k) * math.factorial(n - k)) / 2**n)",0476_B,CODEFORCES,4320,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"cards=list(input().split())
lm=[0]*9
lp=[0]*9
ls=[0]*9
for item in cards:
    if item[1]=='m':
        lm[int(item[0])-1]+=1
    elif item[1]=='p':
        lp[int(item[0])-1]+=1
    else :
        ls[int(item[0])-1]+=1
if max(lm)==3 or max(lp)==3 or max(ls)==3:
    print(0)
else :
    flag=0
    def seq_checker(li):
        flag=0
        for i in range(9):
            if flag==0:
                if lm[i]==1:
                    flag=1
            else :
                if lm[i]==1:
                    flag+=1
                else :
                    break
        return flag
    if seq_checker(lm)==3 or seq_checker(lp)==3 or seq_checker(ls)==3:
        print(0)
    elif max(lm)==2 or max(lp)==2 or max(ls)==2:
        print(1)
    else :
        m=0
        for i in range(0,7):
            m=max(sum(lm[i:i+3]),sum(lp[i:i+3]),sum(ls[i:i+3]),m)
        print(3-m)",1191_B,CODEFORCES,2197,Tokitsukaze and Mahjong,"Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $$$1$$$ to $$$9$$$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $$$\ldots$$$, 9m, 1p, 2p, $$$\ldots$$$, 9p, 1s, 2s, $$$\ldots$$$, 9s.
In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.
Do you know the minimum number of extra suited tiles she needs to draw so that she can win?
Here are some useful definitions in this game:
Some examples: 
Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.
The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $$$1$$$ to $$$9$$$ and the second character is m, p or s.
Print a single integer — the minimum number of extra suited tiles she needs to draw.
In the first example, Tokitsukaze already has a shuntsu.
","input
In the second example, Tokitsukaze already has a koutsu.
output
In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
","bruteforce, implementation",3
"n, k = map(int, input().split())
a = list(map(int, input().split()))
t = list(map(int, input().split()))
p = [0] * (n + 1)
now = 0
for i in range(0, n):
    if (t[i] == 1):
        now += a[i]
    p[i + 1] = p[i]
    if (t[i] == 0):
        p[i + 1] += a[i]
s = 0
for i in range(n - k + 1):
    s = max(s, p[i + k] - p[i])
print(now + s)
    ",0961_B,CODEFORCES,1591,Lecture Sleep,"Your friend Mishka and you attend a calculus lecture. Lecture lasts n minutes. Lecturer tells ai theorems during the i-th minute.
Mishka is really interested in calculus, though it is so hard to stay awake for all the time of lecture. You are given an array t of Mishka's behavior. If Mishka is asleep during the i-th minute of the lecture then ti will be equal to 0, otherwise it will be equal to 1. When Mishka is awake he writes down all the theorems he is being told — ai during the i-th minute. Otherwise he writes nothing.
You know some secret technique to keep Mishka awake for k minutes straight. However you can use it only once. You can start using it at the beginning of any minute between 1 and n - k + 1. If you use it on some minute i then Mishka will be awake during minutes j such that  and will write down all the theorems lecturer tells.
You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
The first line of the input contains two integer numbers n and k (1 ≤ k ≤ n ≤ 105) — the duration of the lecture in minutes and the number of minutes you can keep Mishka awake.
The second line of the input contains n integer numbers a1, a2, ... an (1 ≤ ai ≤ 104) — the number of theorems lecturer tells during the i-th minute.
The third line of the input contains n integer numbers t1, t2, ... tn (0 ≤ ti ≤ 1) — type of Mishka's behavior at the i-th minute of the lecture.
","input
Print only one integer — the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.
output
In the sample case the better way is to use the secret technique at the beginning of the third minute. Then the number of theorems Mishka will be able to write down will be equal to 16.
","datastructures, dp, implementation, twopointers",3
"T = input().split(' ')
n = int(T[0])
m = int(T[1])
S = input().split(' ')
for i in range(n):
    S[i] = int(S[i])
ind = 0
for k in range(n):
    if S[k] == m:
        ind = k
k = ind
P = [0]*(n+1)
N = [0]*(n+1)
R = [0]*(n-k)
L = [0]*(k+1)
for i in range(k):
    if S[k-1-i] < m:
        L[k-1-i] = L[k-i] - 1
    else:
        L[k-1-i] = L[k-i] + 1
for i in range(n-k-1):
    if S[k+1+i] > m:
        R[1+i] = R[i] + 1
    else:
        R[1+i] = R[i] - 1
c = 0
for el in R:
    if el >= 0:
        P[el]+=1
        if el == 0:
            N[el]+=1
    else:
        N[-el]+=1
for el in L:
    if el >= 1:
        c = c + N[el] + N[el-1]
    else:
        c = c + P[-el] + P[-el+1]
print(c)
",1005_E1,CODEFORCES,2700,Median on Segments (Permutations Edition),"You are given a permutation $$$p_1, p_2, \dots, p_n$$$. A permutation of length $$$n$$$ is a sequence such that each integer between $$$1$$$ and $$$n$$$ occurs exactly once in the sequence.
Find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of the median of $$$p_l, p_{l+1}, \dots, p_r$$$ is exactly the given number $$$m$$$.
The median of a sequence is the value of the element which is in the middle of the sequence after sorting it in non-decreasing order. If the length of the sequence is even, the left of two middle elements is used.
For example, if $$$a=[4, 2, 7, 5]$$$ then its median is $$$4$$$ since after sorting the sequence, it will look like $$$[2, 4, 5, 7]$$$ and the left of two middle elements is equal to $$$4$$$. The median of $$$[7, 1, 2, 9, 6]$$$ equals $$$6$$$ since after sorting, the value $$$6$$$ will be in the middle of the sequence.
Write a program to find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of the median of $$$p_l, p_{l+1}, \dots, p_r$$$ is exactly the given number $$$m$$$.
The first line contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 2\cdot10^5$$$, $$$1 \le m \le n$$$) — the length of the given sequence and the required value of the median.
The second line contains a permutation $$$p_1, p_2, \dots, p_n$$$ ($$$1 \le p_i \le n$$$). Each integer between $$$1$$$ and $$$n$$$ occurs in $$$p$$$ exactly once.
","input
Print the required number.
output
In the first example, the suitable pairs of indices are: $$$(1, 3)$$$, $$$(2, 2)$$$, $$$(2, 3)$$$ and $$$(2, 4)$$$.
",sortings,4
"n,k = map(int,input().split())
s= input()
s1=s
c=0
for i in range(len(s)-1):
    if(s[:i+1]==s[n-i-1:]):
        c=i+1
for i in range(k-1):
    s1+=s[c:]
print(s1)",1029_A,CODEFORCES,3432,Many Equal Substrings,"You are given a string $$$t$$$ consisting of $$$n$$$ lowercase Latin letters and an integer number $$$k$$$.
Let's define a substring of some string $$$s$$$ with indices from $$$l$$$ to $$$r$$$ as $$$s[l \dots r]$$$.
Your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ positions $$$i$$$ such that $$$s[i \dots i + n - 1] = t$$$. In other words, your task is to construct such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
It is guaranteed that the answer is always unique.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 50$$$) — the length of the string $$$t$$$ and the number of substrings.
The second line of the input contains the string $$$t$$$ consisting of exactly $$$n$$$ lowercase Latin letters.
","input
Print such string $$$s$$$ of minimum possible length that there are exactly $$$k$$$ substrings of $$$s$$$ equal to $$$t$$$.
output
It is guaranteed that the answer is always unique.
","implementation, strings",5
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################

import sys,os,io
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from sys import stdin

import math 



def ncr(n, r, p):  #using fermat's little theorem
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

  
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
          
    for i in range(3,int(math.sqrt(n))+1,2): 
          

        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
    
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 


def si():
    return input()

# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")


input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

t = int(input())
for _ in range(t):
    n = ii()
    l = li()
    l1 = l[:]
    arr = defaultdict(lambda:0)
    for i in l:
        arr[i]+=1
    l = []
    graterthan4 = 0
    isgraterthan4 = False
    for i in list(arr.keys()):
        if (arr[i]>=4):
            isgraterthan4 = True
            graterthan4 = i
        if (arr[i]>=2):
            l.append(i)
    n = len(l)
    l.sort()
    m = 1000000000000
    mi = []
    # print(l)
    for i in range(n-1):
        a = l[i]
        b = l[i+1]
        # print(a/b+b/a)
        if (a/b+b/a<m):
            m = a/b+b/a
            # print(""m"",m)
            mi = [a,b]
    if (isgraterthan4==True):
        print(graterthan4,graterthan4,graterthan4,graterthan4)
    else:
        a,b = mi
        print(a,a,b,b)
    

    ",1027_C,CODEFORCES,2762,Minimum Value Rectangle,"You have $$$n$$$ sticks of the given lengths.
Your task is to choose exactly four of them in such a way that they can form a rectangle. No sticks can be cut to pieces, each side of the rectangle must be formed by a single stick. No stick can be chosen multiple times. It is guaranteed that it is always possible to choose such sticks.
Let $$$S$$$ be the area of the rectangle and $$$P$$$ be the perimeter of the rectangle. 
The chosen rectangle should have the value $$$\frac{P^2}{S}$$$ minimal possible. The value is taken without any rounding.
If there are multiple answers, print any of them.
Each testcase contains several lists of sticks, for each of them you are required to solve the problem separately.
The first line contains a single integer $$$T$$$ ($$$T \ge 1$$$) — the number of lists of sticks in the testcase.
Then $$$2T$$$ lines follow — lines $$$(2i - 1)$$$ and $$$2i$$$ of them describe the $$$i$$$-th list. The first line of the pair contains a single integer $$$n$$$ ($$$4 \le n \le 10^6$$$) — the number of sticks in the $$$i$$$-th list. The second line of the pair contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_j \le 10^4$$$) — lengths of the sticks in the $$$i$$$-th list.
It is guaranteed that for each list there exists a way to choose four sticks so that they form a rectangle.
The total number of sticks in all $$$T$$$ lists doesn't exceed $$$10^6$$$ in each testcase.
Print $$$T$$$ lines. The $$$i$$$-th line should contain the answer to the $$$i$$$-th list of the input. That is the lengths of the four sticks you choose from the $$$i$$$-th list, so that they form a rectangle and the value $$$\frac{P^2}{S}$$$ of this rectangle is minimal possible. You can print these four lengths in arbitrary order.
If there are multiple answers, print any of them.
There is only one way to choose four sticks in the first list, they form a rectangle with sides $$$2$$$ and $$$7$$$, its area is $$$2 \cdot 7 = 14$$$, perimeter is $$$2(2 + 7) = 18$$$. $$$\frac{18^2}{14} \approx 23.143$$$.
","input
The second list contains subsets of four sticks that can form rectangles with sides $$$(1, 2)$$$, $$$(2, 8)$$$ and $$$(1, 8)$$$. Their values are $$$\frac{6^2}{2} = 18$$$, $$$\frac{20^2}{16} = 25$$$ and $$$\frac{18^2}{8} = 40.5$$$, respectively. The minimal one of them is the rectangle $$$(1, 2)$$$.
output
You can choose any four of the $$$5$$$ given sticks from the third list, they will form a square with side $$$5$$$, which is still a rectangle with sides $$$(5, 5)$$$.
",greedy,4
"rnd_mod = 1234567890133
rnd_x = 987654321098
def rnd():
    global rnd_x
    rnd_x = rnd_x**2 % rnd_mod
    return (rnd_x>>5) % (1<<20)
def randrange(a):
    return rnd() % a

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    X = []
    for __ in range(N):
        X.append([int(a) for a in input().split()])
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    for t in range(577):
        for i in range(M):
            a = randrange(N)
            Y[i] = [Y[i][j-a] for j in range(N)]
        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))
    print(ma)
",1209_E1,CODEFORCES,4611,Rotate Columns (easy version),"This is an easier version of the next problem. The difference is only in constraints.
You are given a rectangular $$$n \times m$$$ matrix $$$a$$$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want (possibly zero). You can perform this operation to a column multiple times.
After you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $$$i$$$-th row it is equal $$$r_i$$$. What is the maximal possible value of $$$r_1+r_2+\ldots+r_n$$$?
The first line contains an integer $$$t$$$ ($$$1 \le t \le 40$$$), the number of test cases in the input.
The first line of each test case contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 4$$$, $$$1 \le m \le 100$$$) — the number of rows and the number of columns in the given matrix $$$a$$$. 
Each of the following $$$n$$$ lines contains $$$m$$$ integers, the elements of $$$a$$$ ($$$1 \le a_{i, j} \le 10^5$$$).
Print $$$t$$$ integers: answers for all test cases in the order they are given in the input.
","input
In the first test case, you can shift the third column down by one, this way there will be $$$r_1 = 5$$$ and $$$r_2 = 7$$$.
output
In the second case you can don't rotate anything at all, this way there will be $$$r_1 = r_2 = 10$$$ and $$$r_3 = 9$$$.
","bitmasks, bruteforce, dp, greedy, sortings",7
"b = [list(input()) for _ in range(2)]

n = len(b[0])
ans = 0
a = []
for i in range(n):
    ai = 0
    if b[0][i] == '0':
        ai += 1
    if b[1][i] == '0':
        ai += 1
    a.append(ai)
prv = 0
for i in range(n):
    if a[i] == 0:
        prv = 0
    elif a[i] == 1:
        if prv == 2:
            ans += 1
            prv = 0
        else:
            prv = 1
    elif a[i] == 2:
        if prv == 2:
            ans += 1
            prv = 1
        elif prv == 1:
            ans += 1
            prv = 0
        else:
            prv = 2
print(ans)",0991_D,CODEFORCES,379,Bishwock,"Bishwock is a chess figure that consists of three squares resembling an ""L-bar"". This figure can be rotated by 90, 180 and 270 degrees so it can have four possible states:
Bishwocks don't attack any squares and can even occupy on the adjacent squares as long as they don't occupy the same square. 
Vasya has a board with $$$2\times n$$$ squares onto which he wants to put some bishwocks. To his dismay, several squares on this board are already occupied by pawns and Vasya can't put bishwocks there. However, pawns also don't attack bishwocks and they can occupy adjacent squares peacefully.
Knowing the positions of pawns on the board, help Vasya to determine the maximum amount of bishwocks he can put onto the board so that they wouldn't occupy the same squares and wouldn't occupy squares with pawns.
","input
The input contains two nonempty strings that describe Vasya's board. Those strings contain only symbols ""0"" (zero) that denote the empty squares and symbols ""X"" (uppercase English letter) that denote the squares occupied by pawns. Strings are nonempty and are of the same length that does not exceed $$$100$$$.
output
Output a single integer — the maximum amount of bishwocks that can be placed onto the given board.
","dp, greedy",1
"def main():
    n = int(input())
    arr = list(map(int, input().split()))
    ans = 10 ** 10
    for i in range(n):
        x = i if i > n - i - 1 else n - i - 1
        ans = min(ans, arr[i] // x)
    print(ans)
main()",1159_B,CODEFORCES,2118,Expansion coefficient of the array,"Let's call an array of non-negative integers $$$a_1, a_2, \ldots, a_n$$$ a $$$k$$$-extension for some non-negative integer $$$k$$$ if for all possible pairs of indices $$$1 \leq i, j \leq n$$$ the inequality $$$k \cdot |i - j| \leq min(a_i, a_j)$$$ is satisfied. The expansion coefficient of the array $$$a$$$ is the maximal integer $$$k$$$ such that the array $$$a$$$ is a $$$k$$$-extension. Any array is a 0-expansion, so the expansion coefficient always exists.
You are given an array of non-negative integers $$$a_1, a_2, \ldots, a_n$$$. Find its expansion coefficient.
The first line contains one positive integer $$$n$$$ — the number of elements in the array $$$a$$$ ($$$2 \leq n \leq 300\,000$$$). The next line contains $$$n$$$ non-negative integers $$$a_1, a_2, \ldots, a_n$$$, separated by spaces ($$$0 \leq a_i \leq 10^9$$$).
Print one non-negative integer — expansion coefficient of the array $$$a_1, a_2, \ldots, a_n$$$.
","input
In the first test, the expansion coefficient of the array $$$[6, 4, 5, 5]$$$ is equal to $$$1$$$ because $$$|i-j| \leq min(a_i, a_j)$$$, because all elements of the array satisfy $$$a_i \geq 3$$$. On the other hand, this array isn't a $$$2$$$-extension, because $$$6 = 2 \cdot |1 - 4| \leq min(a_1, a_4) = 5$$$ is false.
output
In the second test, the expansion coefficient of the array $$$[0, 1, 2]$$$ is equal to $$$0$$$ because this array is not a $$$1$$$-extension, but it is $$$0$$$-extension.
","implementation, math",3
"a = input().split()
st = set([])
cnt = [[0 for i in range(9)] for i in range(3)]
for e in a:
    cnt['mps'.index(e[1])][int(e[0]) - 1] = 1
    st.add(e)
answ = len(st) - 1
for i in range(3):
    for j in range(7):
        answ = min(answ, 3 - sum(cnt[i][j:j + 3]))
print(answ)",1191_B,CODEFORCES,2199,Tokitsukaze and Mahjong,"Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $$$1$$$ to $$$9$$$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $$$\ldots$$$, 9m, 1p, 2p, $$$\ldots$$$, 9p, 1s, 2s, $$$\ldots$$$, 9s.
In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.
Do you know the minimum number of extra suited tiles she needs to draw so that she can win?
Here are some useful definitions in this game:
Some examples: 
Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.
The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $$$1$$$ to $$$9$$$ and the second character is m, p or s.
Print a single integer — the minimum number of extra suited tiles she needs to draw.
In the first example, Tokitsukaze already has a shuntsu.
","input
In the second example, Tokitsukaze already has a koutsu.
output
In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
","bruteforce, implementation",3
"#Problem Set E: Collaborated with no one
from collections import defaultdict

mod_v = 1000000007

temp_arr = [[1]]
for i in range(1,1010):
    a = [1]
    for k in range(1,i):
        a.append((temp_arr[i-1][k-1]+temp_arr[i-1][k]) % mod_v)
    a.append(1)
    temp_arr.append(a)


ans_arr = [1]
for i in range(1,1010):
    res = 0
    for j in range(i):
        res += ans_arr[j] * temp_arr[i-1][j]
        res %= mod_v
    ans_arr.append(res)


n_list=list(map(int, input().split()))

n = n_list[0]
lines = n_list[1]

new_list = [0 for __ in range(n)]

for i in range(lines):
    input1 = list(map(int, input()))
    for k in range(n):
        new_list[k] |= input1[k] << i

default_d = defaultdict(int)
for k in new_list:
    default_d[k] += 1

answer = 1
for n in default_d.values():
    answer = answer * ans_arr[n] % mod_v

print(answer)
  		 	 	  	    	 	 		   		 	  	",0908_E,CODEFORCES,3060,New Year and Entity Enumeration,"You are given an integer m.
Let M = 2m - 1.
You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m.
A set of integers S is called ""good"" if the following hold. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.
Count the number of good sets S, modulo 109 + 7.
The first line will contain two integers m and n (1 ≤ m ≤ 1 000, 1 ≤ n ≤ min(2m, 50)).
The next n lines will contain the elements of T. Each line will contain exactly m zeros and ones. Elements of T will be distinct.
","input
Print a single integer, the number of good sets modulo 109 + 7. 
output
An example of a valid set S is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.
","bitmasks, combinatorics, dp, math",5
"from sys import stdin
from bisect import *

rints = lambda: [int(x) for x in stdin.readline().split()]
rints_2d = lambda n: [rints() for _ in range(n)]
n, mem, pos, power = int(input()), [1], [], []
a = sorted(rints_2d(n))

for x, y in a:
    pos.append(x)
    power.append(y)

for i in range(1, n):
    ix = bisect_left(pos, pos[i] - power[i]) - 1
    if ix == -1:
        mem.append(1)
    else:
        mem.append(mem[ix] + 1)

print(n - max(mem))
",0608_C,CODEFORCES,1502,Chain Reaction,"There are n beacons located at distinct positions on a number line. The i-th beacon has position ai and power level bi. When the i-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance bi inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.
Saitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.
The first line of input contains a single integer n (1 ≤ n ≤ 100 000) — the initial number of beacons.
The i-th of next n lines contains two integers ai and bi (0 ≤ ai ≤ 1 000 000, 1 ≤ bi ≤ 1 000 000) — the position and power level of the i-th beacon respectively. No two beacons will have the same position, so ai ≠ aj if i ≠ j.
Print a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.
","input
For the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.
output
For the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.
",dp,3
"from heapq import heappush, heappop
n = int(input())
L = list(map(int, input().split()))
T = input()

# fly -> walk, time cost: +4s, stamina: +2
# walk in place, time cost: +5s, stamina: +1

#fly -> swim, time cost: +2s, stamina: +2
#swim in place, time cost: +3s, stamina:+1

ans = sum(L)

Q = []

for l, t in zip(L, T):
    if t == 'G':
        heappush(Q, (2, 2 * l))
        heappush(Q, (5, float('inf')))
    elif t == 'W':
        heappush(Q, (1, 2 * l))
        heappush(Q, (3, float('inf')))

    need_stamina = l
    while need_stamina > 0:
        cost, quantity = heappop(Q)
        if need_stamina > quantity:
            ans += quantity * cost
            need_stamina -= quantity
        else:
            ans += need_stamina * cost
            heappush(Q, (cost, quantity - need_stamina))
            need_stamina = 0

print(ans)
",1091_F,CODEFORCES,2904,New Year and the Mallard Expedition,"Bob is a duck. He wants to get to Alice's nest, so that those two can duck!
The journey can be represented as a straight line, consisting of $$$n$$$ segments. Bob is located to the left of the first segment, while Alice's nest is on the right of the last segment. Each segment has a length in meters, and also terrain type: grass, water or lava. 
Bob has three movement types: swimming, walking and flying. He can switch between them or change his direction at any point in time (even when he is located at a non-integer coordinate), and doing so doesn't require any extra time. Bob can swim only on the water, walk only on the grass and fly over any terrain. Flying one meter takes $$$1$$$ second, swimming one meter takes $$$3$$$ seconds, and finally walking one meter takes $$$5$$$ seconds.
Bob has a finite amount of energy, called stamina. Swimming and walking is relaxing for him, so he gains $$$1$$$ stamina for every meter he walks or swims. On the other hand, flying is quite tiring, and he spends $$$1$$$ stamina for every meter flown. Staying in place does not influence his stamina at all. Of course, his stamina can never become negative. Initially, his stamina is zero.
What is the shortest possible time in which he can reach Alice's nest? 
The first line contains a single integer $$$n$$$ ($$$1 \leq n \leq 10^5$$$) — the number of segments of terrain. 
The second line contains $$$n$$$ integers $$$l_1, l_2, \dots, l_n$$$ ($$$1 \leq l_i \leq 10^{12}$$$). The $$$l_i$$$ represents the length of the $$$i$$$-th terrain segment in meters.
The third line contains a string $$$s$$$ consisting of $$$n$$$ characters ""G"", ""W"", ""L"", representing Grass, Water and Lava, respectively. 
It is guaranteed that the first segment is not Lava.
Output a single integer $$$t$$$ — the minimum time Bob needs to reach Alice. 
In the first sample, Bob first walks $$$5$$$ meters in $$$25$$$ seconds. Then he flies the remaining $$$5$$$ meters in $$$5$$$ seconds.
In the second sample, Bob first swims $$$10$$$ meters in $$$30$$$ seconds. Then he flies over the patch of lava for $$$10$$$ seconds.
","input
In the third sample, the water pond is much smaller. Bob first swims over the water pond, taking him $$$3$$$ seconds. However, he cannot fly over the lava just yet, as he only has one stamina while he needs two. So he swims back for half a meter, and then half a meter forward, taking him $$$3$$$ seconds in total. Now he has $$$2$$$ stamina, so he can spend $$$2$$$ seconds flying over the lava.
output
In the fourth sample, he walks for $$$50$$$ seconds, flies for $$$10$$$ seconds, swims for $$$15$$$ seconds, and finally flies for $$$5$$$ seconds.
","constructivealgorithms, greedy",4
"try:
    n,k=list(map(int,input().split("" "")))
    s=input()
    s=list(s)
    if len(s)>k:
        p='('*(k//2)
        p=list(p)
        c=0
        for i in range(0,len(s)):
            if s[i]==')':
                p.insert(i,')')
                c+=1
                if c==k//2:
                    break
        print("""".join(p))
                
            
                
    
    else:
        print("""".join(s))
    
except:
    pass",1023_C,CODEFORCES,1871,Bracket Subsequence,"A bracket sequence is a string containing only characters ""("" and "")"". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()()"" and ""(())"" are regular (the resulting expressions are: ""(1)+(1)"" and ""((1+1)+1)""), and "")("", ""("" and "")"" are not.
Subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.
You are given a regular bracket sequence $$$s$$$ and an integer number $$$k$$$. Your task is to find a regular bracket sequence of length exactly $$$k$$$ such that it is also a subsequence of $$$s$$$.
It is guaranteed that such sequence always exists.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \le k \le n \le 2 \cdot 10^5$$$, both $$$n$$$ and $$$k$$$ are even) — the length of $$$s$$$ and the length of the sequence you are asked to find.
The second line is a string $$$s$$$ — regular bracket sequence of length $$$n$$$.
","input
Print a single string — a regular bracket sequence of length exactly $$$k$$$ such that it is also a subsequence of $$$s$$$.
output
It is guaranteed that such sequence always exists.
",greedy,3
"n,m=map(int,input().split())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
l=list()
for i in range(m):
    for j in range(n):
        if(y[i]==x[j]):
            l.append(j)
print(' '.join(map(str,[x[i] for i in sorted(l)])))",0994_A,CODEFORCES,3303,Fingerprints,"You are locked in a room with a door that has a keypad with 10 keys corresponding to digits from 0 to 9. To escape from the room, you need to enter a correct code. You also have a sequence of digits.
Some keys on the keypad have fingerprints. You believe the correct code is the longest not necessarily contiguous subsequence of the sequence you have that only contains digits with fingerprints on the corresponding keys. Find such code.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n, m \le 10$$$) representing the number of digits in the sequence you have and the number of keys on the keypad that have fingerprints.
The next line contains $$$n$$$ distinct space-separated integers $$$x_1, x_2, \ldots, x_n$$$ ($$$0 \le x_i \le 9$$$) representing the sequence.
The next line contains $$$m$$$ distinct space-separated integers $$$y_1, y_2, \ldots, y_m$$$ ($$$0 \le y_i \le 9$$$) — the keys with fingerprints.
In a single line print a space-separated sequence of integers representing the code. If the resulting sequence is empty, both printing nothing and printing a single line break is acceptable.
","input
In the first example, the only digits with fingerprints are $$$1$$$, $$$2$$$ and $$$7$$$. All three of them appear in the sequence you know, $$$7$$$ first, then $$$1$$$ and then $$$2$$$. Therefore the output is 7 1 2. Note that the order is important, and shall be the same as the order in the original sequence.
output
In the second example digits $$$0$$$, $$$1$$$, $$$7$$$ and $$$9$$$ have fingerprints, however only $$$0$$$ and $$$1$$$ appear in the original sequence. $$$1$$$ appears earlier, so the output is 1 0. Again, the order is important.
",implementation,5
"from sys import stdin
n, m, a, b = map(int, stdin.readline().split())
x = n%m
print(min(a *(m-x), b*x))",0990_A,CODEFORCES,1695,Commentary Boxes,"Berland Football Cup starts really soon! Commentators from all over the world come to the event.
Organizers have already built $$$n$$$ commentary boxes. $$$m$$$ regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.
If $$$n$$$ is not divisible by $$$m$$$, it is impossible to distribute the boxes to the delegations at the moment.
Organizers can build a new commentary box paying $$$a$$$ burles and demolish a commentary box paying $$$b$$$ burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.
What is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$)?
The only line contains four integer numbers $$$n$$$, $$$m$$$, $$$a$$$ and $$$b$$$ ($$$1 \le n, m \le 10^{12}$$$, $$$1 \le a, b \le 100$$$), where $$$n$$$ is the initial number of the commentary boxes, $$$m$$$ is the number of delegations to come, $$$a$$$ is the fee to build a box and $$$b$$$ is the fee to demolish a box.
Output the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$). It is allowed that the final number of the boxes is equal to $$$0$$$.
In the first example organizers can build $$$5$$$ boxes to make the total of $$$14$$$ paying $$$3$$$ burles for the each of them.
","input
In the second example organizers can demolish $$$2$$$ boxes to make the total of $$$0$$$ paying $$$7$$$ burles for the each of them.
output
In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get $$$5$$$ boxes.
","implementation, math",3
"a = list(map(int, input().split()))
b = list(map(int, input().split()))
a1 = min(a[::2])
b1 = max(a[::2])
c1 = min(a[1::2])
d1 = max(a[1::2])
g  = sum(b[::2]) / 4
h  = sum(b[1::2]) / 4
r  = abs(b[0] - g) + abs(b[1] - h)
for i in range(a1, b1+1) :
    for j in range(c1, d1+1) :
        if abs(i-g) + abs(j-h) <= r:
            print(""YES"")
            exit()
print(""NO"")
",0994_C,CODEFORCES,389,Two Squares,"You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.
The interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.
The input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order.
The first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees.
All the values are integer and between $$$-100$$$ and $$$100$$$.
Print ""Yes"" if squares intersect, otherwise print ""No"".
You can print each letter in any case (upper or lower).
In the first example the second square lies entirely within the first square, so they do intersect.
","input
In the second sample squares do not have any points in common.
output
Here are images corresponding to the samples:
",bruteforce,1
"n, p = map(int, input().split())
a = list(map(int, input().split()))
t = 0
k = 0
for i in range(n):
    k += a[i]
s = 0
for i in range(0, n-1):
    s += a[i]
    t = max(t, s%p + (k - s)%p)
print(t)
",0958_C1,CODEFORCES,1567,Encryption (easy),"Rebel spy Heidi has just obtained the plans for the Death Star from the Empire and, now on her way to safety, she is trying to break the encryption of the plans (of course they are encrypted – the Empire may be evil, but it is not stupid!). The encryption has several levels of security, and here is how the first one looks.
Heidi is presented with a screen that shows her a sequence of integers A and a positive integer p. She knows that the encryption code is a single number S, which is defined as follows:
Define the score of X to be the sum of the elements of X modulo p.
Heidi is given a sequence A that consists of N integers, and also given an integer p. She needs to split A into 2 parts such that: 
Output the sum S, which is the encryption code.
The first line of the input contains two space-separated integer N and p (2 ≤ N ≤ 100 000, 2 ≤ p ≤ 10 000) – the number of elements in A, and the modulo for computing scores, respectively.
The second line contains N space-separated integers which are the elements of A. Each integer is from the interval [1, 1 000 000].
Output the number S as described in the problem statement.
","input
In the first example, the score is maximized if the input sequence is split into two parts as (3, 4), (7, 2). It gives the total score of .
output
In the second example, the score is maximized if the first part consists of the first three elements, and the second part consists of the rest. Then, the score is .
",bruteforce,3
"n, k = map(int, input().split())
h = k // n
if h * n < k:
    h += 1
print(h)
",1036_A,CODEFORCES,458,Function Height,"You are given a set of $$$2n+1$$$ integer points on a Cartesian plane. Points are numbered from $$$0$$$ to $$$2n$$$ inclusive. Let $$$P_i$$$ be the $$$i$$$-th point. The $$$x$$$-coordinate of the point $$$P_i$$$ equals $$$i$$$. The $$$y$$$-coordinate of the point $$$P_i$$$ equals zero (initially). Thus, initially $$$P_i=(i,0)$$$.
The given points are vertices of a plot of a piecewise function. The $$$j$$$-th piece of the function is the segment $$$P_{j}P_{j + 1}$$$.
In one move you can increase the $$$y$$$-coordinate of any point with odd $$$x$$$-coordinate (i.e. such points are $$$P_1, P_3, \dots, P_{2n-1}$$$) by $$$1$$$. Note that the corresponding segments also change.
For example, the following plot shows a function for $$$n=3$$$ (i.e. number of points is $$$2\cdot3+1=7$$$) in which we increased the $$$y$$$-coordinate of the point $$$P_1$$$ three times and $$$y$$$-coordinate of the point $$$P_5$$$ one time:
Let the area of the plot be the area below this plot and above the coordinate axis OX. For example, the area of the plot on the picture above is 4 (the light blue area on the picture above is the area of the plot drawn on it).
Let the height of the plot be the maximum $$$y$$$-coordinate among all initial points in the plot (i.e. points $$$P_0, P_1, \dots, P_{2n}$$$). The height of the plot on the picture above is 3.
Your problem is to say which minimum possible height can have the plot consisting of $$$2n+1$$$ vertices and having an area equal to $$$k$$$. Note that it is unnecessary to minimize the number of moves.
It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n, k \le 10^{18}$$$) — the number of vertices in a plot of a piecewise function and the area we need to obtain.
Print one integer — the minimum possible height of a plot consisting of $$$2n+1$$$ vertices and with an area equals $$$k$$$. It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.
One of the possible answers to the first example:
The area of this plot is 3, the height of this plot is 1.
","input
There is only one possible answer to the second example:
output
The area of this plot is 12, the height of this plot is 3.
",math,1
"import math

inp = input().strip()
dec = input().strip()
inp_dict = {""+"":0,""-"":0}
dec_dict = {""+"":0,""-"":0,""?"":0}

for i in range(len(inp)):
	if inp[i]==""+"":
		inp_dict[""+""] += 1
	elif inp[i]==""-"":
		inp_dict[""-""] += 1

for i in range(len(dec)):
	if dec[i]==""+"":
		dec_dict[""+""] += 1
	elif dec[i]==""-"":
		dec_dict[""-""] += 1
	elif dec[i] == ""?"":
		dec_dict[""?""] += 1

if(dec_dict[""+""] == inp_dict[""+""] and dec_dict[""-""] == inp_dict[""-""]):
	print(1.0000000000)
else:
	temp = inp_dict[""+""] - dec_dict[""+""]
	temp1 = inp_dict[""-""] - dec_dict[""-""]
	#print(temp,temp1)
	if temp + temp1 == dec_dict[""?""] and temp>=0 and temp1 >= 0:
		temp2 = math.factorial(temp+temp1)/(math.factorial(temp)*math.factorial(temp1))
		for i in range(temp1+temp):
			temp2 = temp2 * 0.5
		print(temp2)
	else:
		print(0.000000000)



",0476_B,CODEFORCES,4311,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"import sys
input = sys.stdin.readline
from collections import *

def judge(x):
    ins = [0]*n
    outs = defaultdict(list)
    
    for u, v, c in edges:
        if c>x:
            ins[v] += 1
            outs[u].append(v)
    
    q = deque([v for v in range(n) if ins[v]==0])
    cnt = 0
    
    while q:
        v = q.popleft()
        cnt += 1
        
        for nv in outs[v]:
            ins[nv] -= 1
            
            if ins[nv]==0:
                q.append(nv)
        
    return cnt==n

def binary_search():
    l, r = 0, 10**9+10
    
    while l<=r:
        m = (l+r)//2
        
        if judge(m):
            r = m-1
        else:
            l = m+1
    
    return l

n, m = map(int, input().split())
edges = []
idx = defaultdict(lambda : deque([]))

for i in range(m):
    u, v, c = map(int, input().split())
    u -= 1
    v -= 1
    edges.append((u, v, c))
    idx[10**6*u+v].append(i+1)

k = binary_search()
ins = [0]*n
outs = defaultdict(list)
removed = []

for u, v, c in edges:
    if c>k:
        ins[v] += 1
        outs[u].append(v)
    else:
        removed.append((u, v))
    
q = deque([v for v in range(n) if ins[v]==0])
order = [-1]*n
cnt = 0

while q:
    v = q.popleft()
    order[v] = cnt
    cnt += 1
    
    for nv in outs[v]:
        ins[nv] -= 1
        
        if ins[nv]==0:
            q.append(nv)

change = []

for u, v in removed:
    if order[v]<order[u]:
        change.append(idx[10**6*u+v].popleft())

print(k, len(change))
print(*change)",1100_E,CODEFORCES,2920,Andrew and Taxi,"Andrew prefers taxi to other means of transport, but recently most taxi drivers have been acting inappropriately. In order to earn more money, taxi drivers started to drive in circles. Roads in Andrew's city are one-way, and people are not necessary able to travel from one part to another, but it pales in comparison to insidious taxi drivers.
The mayor of the city decided to change the direction of certain roads so that the taxi drivers wouldn't be able to increase the cost of the trip endlessly. More formally, if the taxi driver is on a certain crossroads, they wouldn't be able to reach it again if he performs a nonzero trip. 
Traffic controllers are needed in order to change the direction the road goes. For every road it is known how many traffic controllers are needed to change the direction of the road to the opposite one. It is allowed to change the directions of roads one by one, meaning that each traffic controller can participate in reversing two or more roads.
You need to calculate the minimum number of traffic controllers that you need to hire to perform the task and the list of the roads that need to be reversed.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \leq n \leq 100\,000$$$, $$$1 \leq m \leq 100\,000$$$) — the number of crossroads and the number of roads in the city, respectively.
Each of the following $$$m$$$ lines contain three integers $$$u_{i}$$$, $$$v_{i}$$$ and $$$c_{i}$$$ ($$$1 \leq u_{i}, v_{i} \leq n$$$, $$$1 \leq c_{i} \leq 10^9$$$, $$$u_{i} \ne v_{i}$$$) — the crossroads the road starts at, the crossroads the road ends at and the number of traffic controllers required to reverse this road.
In the first line output two integers the minimal amount of traffic controllers required to complete the task and amount of roads $$$k$$$ which should be reversed. $$$k$$$ should not be minimized.
In the next line output $$$k$$$ integers separated by spaces — numbers of roads, the directions of which should be reversed. The roads are numerated from $$$1$$$ in the order they are written in the input. If there are many solutions, print any of them.
","input
There are two simple cycles in the first example: $$$1 \rightarrow 5 \rightarrow 2 \rightarrow 1$$$ and $$$2 \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow 2$$$. One traffic controller can only reverse the road $$$2 \rightarrow 1$$$ and he can't destroy the second cycle by himself. Two traffic controllers can reverse roads $$$2 \rightarrow 1$$$ and $$$2 \rightarrow 3$$$ which would satisfy the condition.
output
In the second example one traffic controller can't destroy the cycle $$$ 1 \rightarrow 3 \rightarrow 2 \rightarrow 1 $$$. With the help of three controllers we can, for example, reverse roads $$$1 \rightarrow 3$$$ ,$$$ 2 \rightarrow 4$$$, $$$1 \rightarrow 5$$$.
","binarysearch, dfsandsimilar, graphs",4
"n, k = map(int, input().split())
v = list(map(int, input().split()))
 
d = {}
ans = 0
 
for x in v:
  num_d, mod_k = len(str(x)), x % k
  d.setdefault(num_d, {}).setdefault(mod_k, []).append(x)
 
for x in v:
  num_d, mod_k = len(str(x)), x % k
  for add, mods in d.items():
    val_mod = (mod_k * 10 ** add) % k
    need_mod = (k - val_mod) % k
    ans += len(mods.get(need_mod, []))
    if need_mod == mod_k and add == num_d:
      ans -= 1
 
print(ans)
",1029_D,CODEFORCES,2782,Concatenated Multiples,"You are given an array $$$a$$$, consisting of $$$n$$$ positive integers.
Let's call a concatenation of numbers $$$x$$$ and $$$y$$$ the number that is obtained by writing down numbers $$$x$$$ and $$$y$$$ one right after another without changing the order. For example, a concatenation of numbers $$$12$$$ and $$$3456$$$ is a number $$$123456$$$.
Count the number of ordered pairs of positions $$$(i, j)$$$ ($$$i \neq j$$$) in array $$$a$$$ such that the concatenation of $$$a_i$$$ and $$$a_j$$$ is divisible by $$$k$$$.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$2 \le k \le 10^9$$$).
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$).
Print a single integer — the number of ordered pairs of positions $$$(i, j)$$$ ($$$i \neq j$$$) in array $$$a$$$ such that the concatenation of $$$a_i$$$ and $$$a_j$$$ is divisible by $$$k$$$.
In the first example pairs $$$(1, 2)$$$, $$$(1, 3)$$$, $$$(2, 3)$$$, $$$(3, 1)$$$, $$$(3, 4)$$$, $$$(4, 2)$$$, $$$(4, 3)$$$ suffice. They produce numbers $$$451$$$, $$$4510$$$, $$$110$$$, $$$1045$$$, $$$1012$$$, $$$121$$$, $$$1210$$$, respectively, each of them is divisible by $$$11$$$.
","input
In the second example all $$$n(n - 1)$$$ pairs suffice.
output
In the third example no pair is sufficient.
","implementation, math",4
"n = int(input())
s = [input() for i in range(n)]
MOD = 10**9 + 7

dps = [[0]*(n + 3) for i in range(n + 1)]
dpf = [[0]*(n + 3) for i in range(n + 1)]

for k in range(n + 1):
    dps[0][k] = 1

for pos, char in enumerate(s):
    if char == ""s"":
        #dps[pos + 1][depth] = dps[pos][depth]  + .... + dps[pos][pos] + dpf[pos][depth]
        for depth in range(pos + 2):
            dps[pos + 1][depth] = dpf[pos][depth] - \
                dpf[pos][depth - 1] + dps[pos][pos] - dps[pos][depth - 1]
            #sum(dps[pos][k] for k in range(depth, pos + 1))

            dps[pos + 1][depth] += dps[pos + 1][depth - 1]
            dps[pos + 1][depth] %= MOD

        for p in range(pos + 2, n+1):
            dpf[pos + 1][p] += dpf[pos + 1][p - 1]
            dpf[pos + 1][p] %= MOD
        continue

    else:
        #dpf[pos + 1][depth] =  dpf[pos][depth - 1] + dps[pos][depth - 1] + .......... + depth[pos][pos]
        #dps[pos + 1][depth] = impossible
        for depth in range(1, pos + 2):
            dpf[pos + 1][depth] = dpf[pos][depth - 1] - \
                dpf[pos][depth - 2] + dps[pos][pos] - dps[pos][depth - 2]
            #sum(dps[pos][k] for k in range(depth - 1, pos + 1))
            dpf[pos + 1][depth] += dpf[pos + 1][depth - 1]
            dpf[pos + 1][depth] %= MOD
        for p in range(pos + 2, n+1):
            dpf[pos + 1][p] += dpf[pos + 1][p - 1]
            dpf[pos + 1][p] %= MOD


ans = dps[n][n] % MOD
print(ans)
",0909_C,CODEFORCES,3066,Python Indentation,"In Python, code blocks don't have explicit begin/end or curly braces to mark beginning and end of the block. Instead, code blocks are defined by indentation.
We will consider an extremely simplified subset of Python with only two types of statements.
Simple statements are written in a single line, one per line. An example of a simple statement is assignment.
For statements are compound statements: they contain one or several other statements. For statement consists of a header written in a separate line which starts with ""for"" prefix, and loop body. Loop body is a block of statements indented one level further than the header of the loop. Loop body can contain both types of statements. Loop body can't be empty.
You are given a sequence of statements without indentation. Find the number of ways in which the statements can be indented to form a valid Python program.
The first line contains a single integer N (1 ≤ N ≤ 5000) — the number of commands in the program. N lines of the program follow, each line describing a single command. Each command is either ""f"" (denoting ""for statement"") or ""s"" (""simple statement""). It is guaranteed that the last line is a simple statement.
Output one line containing an integer - the number of ways the given sequence of statements can be indented modulo 109 + 7. 
In the first test case, there is only one way to indent the program: the second for statement must be part of the body of the first one.
","input
In the second test case, there are two ways to indent the program: the second for statement can either be part of the first one's body or a separate statement following the first one.
output
or
",dp,5
"def main():
    n, d, k = map(int, input().split())
    _min = d+1

    if n < _min:
        print('NO')
    else:
        res = []
        deg = [0] * (n+1)
        dist = [0] * (n+1)

        stack = []
        deg[1] = 1
        for i in range(1, d+1):
            res.append((i, i+1))
            if i > 1:
                deg[i] += 2
            dist[i] = max(i-1, d+1-i)
        dist[d+1] = d
        deg[d+1] = 1

        for i in range(2, d+1):
            stack.append(i)

        next = d+2
        while stack:
            if next > n:
                break
            v = stack.pop()
            if dist[v] < d:
                while next <= n and deg[v] < k:
                    res.append((v, next))
                    deg[v] += 1
                    deg[next] += 1
                    dist[next] = dist[v] + 1
                    if dist[next] < d:
                        stack.append(next)
                    next += 1

        ok = next > n
        ok &= all(deg[i] <= k for i in range(1, n+1))
        ok &= all(dist[i] <= d for i in range(1, n+1))

        if not ok:
            print('NO')
        else:
            print('YES')
            for e in res:
                print(*e)


if __name__ == '__main__':
    main()
",1003_E,CODEFORCES,3367,Tree Constructing,"You are given three integers $$$n$$$, $$$d$$$ and $$$k$$$.
Your task is to construct an undirected tree on $$$n$$$ vertices with diameter $$$d$$$ and degree of each vertex at most $$$k$$$, or say that it is impossible.
An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Diameter of a tree is the maximum length of a simple path (a path in which each vertex appears at most once) between all pairs of vertices of this tree.
Degree of a vertex is the number of edges incident to this vertex (i.e. for a vertex $$$u$$$ it is the number of edges $$$(u, v)$$$ that belong to the tree, where $$$v$$$ is any other vertex of a tree).
The first line of the input contains three integers $$$n$$$, $$$d$$$ and $$$k$$$ ($$$1 \le n, d, k \le 4 \cdot 10^5$$$).
","input
If there is no tree satisfying the conditions above, print only one word ""NO"" (without quotes).
output
Otherwise in the first line print ""YES"" (without quotes), and then print $$$n - 1$$$ lines describing edges of a tree satisfying the conditions above. Vertices of the tree must be numbered from $$$1$$$ to $$$n$$$. You can print edges and vertices connected by an edge in any order. If there are multiple answers, print any of them.1
","constructivealgorithms, graphs",5
"movimentos, doces_final = map(int, input().split())
left, right = 0, movimentos + 1

while left < right -1 :
    media = (left + right)//2
    cedidos = (media * (media + 1)) // 2
    comidos = movimentos - media
    if cedidos - comidos > doces_final:
        right = media
    else:
        left = media
print(movimentos - left)",1195_B,CODEFORCES,1386,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"#  author: ThePonyCoder
#  created: 23.06.2019, 21:58
#  filename: f.py
#  path: C:/Users/User/Desktop/python/Prog/CodeForces/rounds/cf_568/f.py

import os

# import random

# sys.setrecursionlimit(999999999)
import string

from math import inf
from functools import lru_cache

if os.getcwd() == 'C:\\Users\\User\\Desktop\\python\\Prog\\CodeForces' \
        or os.environ['COMPUTERNAME'] == 'USER145':
    import pdb
    
    import sys
    
    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    from pprint import pprint
    from hypothesis import given, settings
    from hypothesis import strategies as st


def ri():
    return [int(i) for i in input().split()]


def to_bits(l):
    ans = 0
    for i in l:
        ans |= (1 << i - 1)
    return ans


user_masks = [0 for i in range(1 << 10)]
pizzas = [[] for i in range(1 << 10)]


@lru_cache()
def count_sat_users(mask):
    ans = 0
    cmask = mask
    while cmask:
        ans += user_masks[cmask]
        cmask = (cmask - 1) & mask
    return ans


def main():
    n, m = ri()
    for _ in range(n):
        k, *a = ri()
        bits = to_bits(a)
        user_masks[bits] += 1
    
    ans = (float(-inf), float(inf), -1, -1)
    
    for i in range(m):
        c, k, *a = ri()
        bits = to_bits(a)
        pizzas[bits].append((c, i + 1, bits))  # цена, номер, маска
        pizzas[bits].sort()
        while len(pizzas[bits]) > 2:
            pizzas[bits].pop()
    # pprint(pizzas)
    
    for mask_F in range(1 << 9):
        for mask_S in range(1 << 9):
            if len(pizzas[mask_F]) and len(pizzas[mask_S]) \
                    and mask_F != mask_S:
                
                mask = mask_F | mask_S
                
                satisfied_users = count_sat_users(mask)
                
                f_pizza = next(iter(pizzas[mask_F]))
                s_pizza = next(iter(pizzas[mask_S]))
                
                summary_cost = 0
                summary_cost += f_pizza[0]
                summary_cost += s_pizza[0]
                
                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))
                
                # bruting all masks
                bmask = mask
                while bmask:
                    satisfied_users += user_masks[bmask]
                    bmask = (bmask - 1) & mask
            
            if len(pizzas[mask_F]) == 2:
                satisfied_users = count_sat_users(mask_F)
                
                it = iter(pizzas[mask_F])
                
                f_pizza = next(it)
                s_pizza = next(it)
                summary_cost = 0
                summary_cost += f_pizza[0] + s_pizza[0]
                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))
            
            if len(pizzas[mask_S]) == 2:
                satisfied_users = count_sat_users(mask_S)
                
                it = iter(pizzas[mask_S])
                
                f_pizza = next(it)
                s_pizza = next(it)
                summary_cost = 0
                summary_cost += f_pizza[0] + s_pizza[0]
                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))
    
    aans = [ans[2],ans[3]]
    aans.sort()
    print(*aans, sep=' ')


main()
",1185_F,CODEFORCES,4594,Two Pizzas,"A company of $$$n$$$ friends wants to order exactly two pizzas. It is known that in total there are $$$9$$$ pizza ingredients in nature, which are denoted by integers from $$$1$$$ to $$$9$$$.
Each of the $$$n$$$ friends has one or more favorite ingredients: the $$$i$$$-th of friends has the number of favorite ingredients equal to $$$f_i$$$ ($$$1 \le f_i \le 9$$$) and your favorite ingredients form the sequence $$$b_{i1}, b_{i2}, \dots, b_{if_i}$$$ ($$$1 \le b_{it} \le 9$$$).
The website of CodePizza restaurant has exactly $$$m$$$ ($$$m \ge 2$$$) pizzas. Each pizza is characterized by a set of $$$r_j$$$ ingredients $$$a_{j1}, a_{j2}, \dots, a_{jr_j}$$$ ($$$1 \le r_j \le 9$$$, $$$1 \le a_{jt} \le 9$$$) , which are included in it, and its price is $$$c_j$$$.
Help your friends choose exactly two pizzas in such a way as to please the maximum number of people in the company. It is known that a person is pleased with the choice if each of his/her favorite ingredients is in at least one ordered pizza. If there are several ways to choose two pizzas so as to please the maximum number of friends, then choose the one that minimizes the total price of two pizzas.
The first line of the input contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^5, 2 \le m \le 10^5$$$) — the number of friends in the company and the number of pizzas, respectively.
Next, the $$$n$$$ lines contain descriptions of favorite ingredients of the friends: the $$$i$$$-th of them contains the number of favorite ingredients $$$f_i$$$ ($$$1 \le f_i \le 9$$$) and a sequence of distinct integers $$$b_{i1}, b_{i2}, \dots, b_{if_i}$$$ ($$$1 \le b_{it} \le 9$$$).
","input
Next, the $$$m$$$ lines contain pizza descriptions: the $$$j$$$-th of them contains the integer price of the pizza $$$c_j$$$ ($$$1 \le c_j \le 10^9$$$), the number of ingredients $$$r_j$$$ ($$$1 \le r_j \le 9$$$) and the ingredients themselves as a sequence of distinct integers $$$a_{j1}, a_{j2}, \dots, a_{jr_j}$$$ ($$$1 \le a_{jt} \le 9$$$).
output
Output two integers $$$j_1$$$ and $$$j_2$$$ ($$$1 \le j_1,j_2 \le m$$$, $$$j_1 \ne j_2$$$) denoting the indices of two pizzas in the required set. If there are several solutions, output any of them. Pizza indices can be printed in any order.
","bitmasks, bruteforce",7
"
def d(n):
    ret = 0
    n = list(str(n))
    for i in range(len(n)):
        ret += int(n[i])
    return ret


def main():
    n, s = map(int, input().split())

    l, h = 0, n
    for i in range(2000):
        #print(l, h)
        m = (l + h) // 2
        if m - d(m) >= s:
            h = m
        else:
            l = m
    # print(m)
    for i in range(-100, 100):
        t = m + i
        # print(t)
        if t < 0 or t > n:
            continue
        if abs(t - d(t)) >= s:
            print(n - t + 1)
            exit()
    print(0)


if __name__ == '__main__':
    main()
",0817_C,CODEFORCES,985,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"#WARNING This code is just for fun. Reading it might give u a brainfreeze

n,d,k = [int(x) for x in input().strip().split(' ')]
l = []
i = 1
if n<=d:
	print(""NO"")
elif k==1:
	if n>2:
		print(""NO"")
	elif n==2:
		print(""YES"")
		print(1,2)
else:
	n+=1
	flag = False
	while i<min(d+1,n):
		l.append(str(i)+"" ""+str(i+1))
		i+=1
	i+=1
	cnt1=0
	cnt2=1
	se=[[2,d+1,1]]
	while cnt1<cnt2:
		start = se[cnt1][0]
		end = se[cnt1][1]
		mode = se[cnt1][2]
		#print(se)
		kk = 3
		while (i<n) and (kk<=k):
			if i<n and not flag:
				j = start
				#print(j,""kk"")
				while i<n and j<end:
					if mode==1:
						c = min(j-start+1,end-j)
					else:
						c = min(end-j,d-end+j)
					if c>1:
						se.append([i,i+c-1,2])
						cnt2+=1
					ki=j
					while i<n and c>0:
						l.append(str(ki)+"" ""+str(i))
						#print(j,i,c)
						c-=1
						ki=i
						i+=1
					j+=1
					
			else:
				flag = True
				break
			kk+=1
		cnt1+=1
	if i<n or flag:
		#print(l)
		print(""NO"")
	else:
		print(""YES"")
		print('\n'.join(l))",1003_E,CODEFORCES,3363,Tree Constructing,"You are given three integers $$$n$$$, $$$d$$$ and $$$k$$$.
Your task is to construct an undirected tree on $$$n$$$ vertices with diameter $$$d$$$ and degree of each vertex at most $$$k$$$, or say that it is impossible.
An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.
Diameter of a tree is the maximum length of a simple path (a path in which each vertex appears at most once) between all pairs of vertices of this tree.
Degree of a vertex is the number of edges incident to this vertex (i.e. for a vertex $$$u$$$ it is the number of edges $$$(u, v)$$$ that belong to the tree, where $$$v$$$ is any other vertex of a tree).
The first line of the input contains three integers $$$n$$$, $$$d$$$ and $$$k$$$ ($$$1 \le n, d, k \le 4 \cdot 10^5$$$).
","input
If there is no tree satisfying the conditions above, print only one word ""NO"" (without quotes).
output
Otherwise in the first line print ""YES"" (without quotes), and then print $$$n - 1$$$ lines describing edges of a tree satisfying the conditions above. Vertices of the tree must be numbered from $$$1$$$ to $$$n$$$. You can print edges and vertices connected by an edge in any order. If there are multiple answers, print any of them.1
","constructivealgorithms, graphs",5
"import math

def gaosi(x):
    if (x==1):
        return 1
    else:
        return ((1+x)*x)/2

def calc(mid, total, left):
    return gaosi(mid) - (total - mid) - left

def main(): 
    x, left = map(int, input().split())
    if (x == 1 and left == 1):
        print(0)
    else:
        l = 1
        r = x
        while (True):
            mid = math.floor((l + r) / 2)
            result = calc(mid, x, left)
            if (result == 0):
                print(x - mid)
                break
            elif (result > 0):
                r = mid
            elif (result  < left):
                l = mid

    
if __name__ == ""__main__"":
    main()",1195_B,CODEFORCES,1383,Sport Mafia,"Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. 
For the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs $$$n$$$ actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:
Thus, if the box is empty, then it can only use the second option.
For example, one possible sequence of Alya's actions look as follows:
This way she will perform $$$9$$$ actions, the number of candies at the end will be $$$11$$$, while Alya will eat $$$4$$$ candies in total.
You know the total number of actions $$$n$$$ and the number of candies at the end $$$k$$$. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer always exists.
Please note, that during an action of the first option, Alya takes out and eats exactly one candy.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 10^9$$$; $$$0 \le k \le 10^9$$$) — the total number of moves and the number of candies in the box at the end. 
It's guaranteed, that for the given $$$n$$$ and $$$k$$$ the answer exists.
Print a single integer — the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers — the answer is unique for any input data. 
In the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate $$$0$$$ candies.
","input
In the second example the possible sequence of Alya's actions looks as follows: 
output
This way, she will make exactly $$$n=9$$$ actions and in the end the box will contain $$$1+2-1-1+3-1+4-1+5=11$$$ candies. The answer is $$$4$$$, since she ate $$$4$$$ candies in total.
","binarysearch, bruteforce, math",2
"def f():
    b = [a[0]]
    for e in a[1:]:
        if b != []:
            if e == b[-1] or abs(e-b[-1])%2==0:
                b.pop()

            else:
                b.append(e)
        else:
            b.append(e)

    for i in range(1,len(b)):
        if abs(b[i]-b[i-1])%2:
            print('NO')
            return

    print('YES')

n=int(input())
a=[int(i) for i in input().split()]


f()",1092_D1,CODEFORCES,2082,Great Vova Wall (Version 1),"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.
The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.
Vova can only use $$$2 \times 1$$$ bricks to put in the wall (he has infinite supply of them, however).
Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).
The next paragraph is specific to the version 1 of the problem.
Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.
Vova is a perfectionist, so he considers the wall completed when:
Can Vova complete the wall using any amount of bricks (possibly zero)?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of parts in the wall.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial heights of the parts of the wall.
Print ""YES"" if Vova can complete the wall using any amount of bricks (possibly zero).
Print ""NO"" otherwise.
In the first example Vova can put a brick on parts 2 and 3 to make the wall $$$[2, 2, 2, 2, 5]$$$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $$$[5, 5, 5, 5, 5]$$$.
","input
In the second example Vova can put a brick vertically on part 3 to make the wall $$$[4, 5, 5]$$$, then horizontally on parts 2 and 3 to make it $$$[4, 6, 6]$$$ and then vertically on part 1 to make it $$$[6, 6, 6]$$$.
output
In the third example the wall is already complete.
","greedy, implementation, math",3
"import sys

n, s = map(int, input().split())

ok, ng = 10**18+100, -1
while abs(ok - ng) > 1:
    mid = (ok + ng) >> 1
    if mid - sum(map(int, str(mid))) >= s:
        ok = mid
    else:
        ng = mid

print(max(0, n - ok + 1))
",0817_C,CODEFORCES,1006,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"print(""? 0 0"", flush=True)
res = input()
i = 1
a = 0
b = 0
for i in range(29,-1,-1):
	print(""?"",(a^(1<<i)), b, flush=True)
	res1 = input()
	print(""?"",a, (b^(1<<i)), flush=True)
	res2 = input()
	if res1 == res2:
		if res == '1':
			a ^= (1<<i)
		else:
			b ^= (1<<i)
		res = res1
	elif res1 == '-1':
		a ^= (1<<i)
		b ^= (1<<i)
print(""!"", a, b, flush=True)",1088_D,CODEFORCES,1231,Ehab and another another xor problem,"This is an interactive problem!
Ehab plays a game with Laggy. Ehab has 2 hidden integers $$$(a,b)$$$. Laggy can ask a pair of integers $$$(c,d)$$$ and Ehab will reply with:
Operation $$$a \oplus b$$$ is the bitwise-xor operation of two numbers $$$a$$$ and $$$b$$$.
Laggy should guess $$$(a,b)$$$ with at most 62 questions. You'll play this game. You're Laggy and the interactor is Ehab.
It's guaranteed that $$$0 \le a,b<2^{30}$$$.
See the interaction section.
To print the answer, print ""! a b"" (without quotes). Don't forget to flush the output after printing the answer.
To ask a question, print ""? c d"" (without quotes). Both $$$c$$$ and $$$d$$$ must be non-negative integers less than $$$2^{30}$$$. Don't forget to flush the output after printing any question.
After each question, you should read the answer as mentioned in the legend. If the interactor replies with -2, that means you asked more than 62 queries and your program should terminate.
To flush the output, you can use:-
Hacking:
To hack someone, print the 2 space-separated integers $$$a$$$ and $$$b$$$ $$$(0 \le a,b<2^{30})$$$.
In the sample:
The hidden numbers are $$$a=3$$$ and $$$b=1$$$.
In the first query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 1 = 0$$$, so the answer is 1.
In the second query: $$$3 \oplus 1 = 2$$$ and $$$1 \oplus 2 = 3$$$, so the answer is -1.
","input
In the third query: $$$3 \oplus 2 = 1$$$ and $$$1 \oplus 0 = 1$$$, so the answer is 0.
output
Then, we printed the answer.
","bitmasks, constructivealgorithms, implementation, interactive",2
"from math import *
import sys
input = lambda: sys.stdin.readline().strip()

d = {'m': [], 's': [], 'p': []}

ls = list(input().split())
for i in ls:
    d[i[1]].append(int(i[0]))
for k, v in d.items():
    v.sort()
    if len(v)==3 and len(set(v))==1: print(0); break
    if len(v)==3 and v[0]+1==v[1] and v[1]+1==v[2]: print(0); break
else:
    for k, v in d.items():
        if len(v)==2 and len(set(v))==1: print(1); break
        if len(v)==2 and v[1]-v[0]<=2: print(1); break
        if len(v)==3 and (v[0]==v[1] or v[1]==v[2]): print(1); break
        if len(v)==3 and (v[1]-v[0]<=2 or v[2]-v[1]<=2): print(1); break
    else:
        print(2)
",1191_B,CODEFORCES,2969,Tokitsukaze and Mahjong,"Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $$$1$$$ to $$$9$$$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $$$\ldots$$$, 9m, 1p, 2p, $$$\ldots$$$, 9p, 1s, 2s, $$$\ldots$$$, 9s.
In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.
Do you know the minimum number of extra suited tiles she needs to draw so that she can win?
Here are some useful definitions in this game:
Some examples: 
Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.
The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $$$1$$$ to $$$9$$$ and the second character is m, p or s.
Print a single integer — the minimum number of extra suited tiles she needs to draw.
In the first example, Tokitsukaze already has a shuntsu.
","input
In the second example, Tokitsukaze already has a koutsu.
output
In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
","bruteforce, implementation",4
"n=int(input())
li=[]
for i in range(1,n+1):
    if n%i==0:
        li.append(i)
p=0
for t in li:
    l=[m for m in str(t)]
    if set(l)=={'4'} or set(l)=={'7'} or set(l)=={'4','7'}:
        p+=1
if p>0:
    print('YES')
else:
    print('NO')",0122_A,CODEFORCES,52,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory",1
"n = int(input())
fst, nxt, lst, des = [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)], [0 for i in range(2 * n + 1)]
cnt = 0

def add(u, v) :
	global cnt
	cnt += 1
	if fst[u] == 0 :
		fst[u] = cnt
	else :
		nxt[lst[u]] = cnt
	lst[u], des[cnt] = cnt, v

for i in range(1, n) : 
	u, v = map(int, input().split())
#	print(u, v)
	add(u, v)
	add(v, u)

a = list(map(int, input().split()))
deep = [0 for i in range(n + 1)]
deep[1] = 1
now, res = 1, 1
Ans = 0

for i in range(0, n) :
	if deep[a[i]] == 0 : 
		Ans = 1
		break
	elif deep[a[i]] < now :
		Ans = 1
		break
	else : 
		b = fst[a[i]]
		res += 1
		while b > 0 :
			if deep[des[b]] == 0 : 
				deep[des[b]] = res
			b = nxt[b]
		now = deep[a[i]]

if Ans == 0 :
	print(""Yes"")
else :
	print(""No"")
",1037_D,CODEFORCES,2804,Valid BFS?,"The BFS algorithm is defined as follows.
Since the order of choosing neighbors of each vertex can vary, it turns out that there may be multiple sequences which BFS can print.
In this problem you need to check whether a given sequence corresponds to some valid BFS traversal of the given tree starting from vertex $$$1$$$. The tree is an undirected graph, such that there is exactly one simple path between any two vertices.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) which denotes the number of nodes in the tree. 
The following $$$n - 1$$$ lines describe the edges of the tree. Each of them contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x, y \le n$$$) — the endpoints of the corresponding edge of the tree. It is guaranteed that the given graph is a tree.
The last line contains $$$n$$$ distinct integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$) — the sequence to check.
Print ""Yes"" (quotes for clarity) if the sequence corresponds to some valid BFS traversal of the given tree and ""No"" (quotes for clarity) otherwise.
You can print each letter in any case (upper or lower).
Both sample tests have the same tree in them.
","input
In this tree, there are two valid BFS orderings: 
output
The ordering $$$1, 2, 4, 3$$$ doesn't correspond to any valid BFS order.
","dfsandsimilar, graphs, shortestpaths, trees",4
"n = int(input())
l = list(map(int, input().split("" "")))
r = list(map(int, input().split("" "")))

slr = [l[i]+r[i] for i in range(n)]
ans = [n-slr[i] for i in range(n)]

flag = True
if l[0]!=0 or r[n-1]!=0:
	flag= False

for i in range(n):
	great = 0
	for j in range(i+1, n):
		if ans[i]<ans[j]:
			great = great + 1
	if r[i]!=great:
		flag = False
		break
for i in range(n-1, -1, -1):
	great = 0
	for j in range(i-1, -1, -1):
		if ans[i]<ans[j]:
			great = great + 1
	if l[i]!=great:
		flag = False
		break

if flag:
	print(""YES"")
	for i in range(0, n-1):
		print(ans[i], end="" "")
	print(ans[n-1])
else:
	print(""NO"")
",1054_C,CODEFORCES,3518,Candies Distribution,"There are $$$n$$$ children numbered from $$$1$$$ to $$$n$$$ in a kindergarten. Kindergarten teacher gave $$$a_i$$$ ($$$1 \leq a_i \leq n$$$) candies to the $$$i$$$-th child. Children were seated in a row in order from $$$1$$$ to $$$n$$$ from left to right and started eating candies. 
While the $$$i$$$-th child was eating candies, he calculated two numbers $$$l_i$$$ and $$$r_i$$$ — the number of children seating to the left of him that got more candies than he and the number of children seating to the right of him that got more candies than he, respectively.
Formally, $$$l_i$$$ is the number of indices $$$j$$$ ($$$1 \leq j < i$$$), such that $$$a_i < a_j$$$ and $$$r_i$$$ is the number of indices $$$j$$$ ($$$i < j \leq n$$$), such that $$$a_i < a_j$$$.
Each child told to the kindergarten teacher the numbers $$$l_i$$$ and $$$r_i$$$ that he calculated. Unfortunately, she forgot how many candies she has given to each child. So, she asks you for help: given the arrays $$$l$$$ and $$$r$$$ determine whether she could have given the candies to the children such that all children correctly calculated their values $$$l_i$$$ and $$$r_i$$$, or some of them have definitely made a mistake. If it was possible, find any way how she could have done it.
On the first line there is a single integer $$$n$$$ ($$$1 \leq n \leq 1000$$$) — the number of children in the kindergarten.
On the next line there are $$$n$$$ integers $$$l_1, l_2, \ldots, l_n$$$ ($$$0 \leq l_i \leq n$$$), separated by spaces.
On the next line, there are $$$n$$$ integer numbers $$$r_1, r_2, \ldots, r_n$$$ ($$$0 \leq r_i \leq n$$$), separated by spaces.
If there is no way to distribute the candies to the children so that all of them calculated their numbers correctly, print «NO» (without quotes).
Otherwise, print «YES» (without quotes) on the first line. On the next line, print $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$, separated by spaces — the numbers of candies the children $$$1, 2, \ldots, n$$$ received, respectively. Note that some of these numbers can be equal, but all numbers should satisfy the condition $$$1 \leq a_i \leq n$$$. The number of children seating to the left of the $$$i$$$-th child that got more candies than he should be equal to $$$l_i$$$ and the number of children seating to the right of the $$$i$$$-th child that got more candies than he should be equal to $$$r_i$$$. If there is more than one solution, find any of them.
In the first example, if the teacher distributed $$$1$$$, $$$3$$$, $$$1$$$, $$$2$$$, $$$1$$$ candies to $$$1$$$-st, $$$2$$$-nd, $$$3$$$-rd, $$$4$$$-th, $$$5$$$-th child, respectively, then all the values calculated by the children are correct. For example, the $$$5$$$-th child was given $$$1$$$ candy, to the left of him $$$2$$$ children were given $$$1$$$ candy, $$$1$$$ child was given $$$2$$$ candies and $$$1$$$ child — $$$3$$$ candies, so there are $$$2$$$ children to the left of him that were given more candies than him.
","input
In the second example it is impossible to distribute the candies, because the $$$4$$$-th child made a mistake in calculating the value of $$$r_4$$$, because there are no children to the right of him, so $$$r_4$$$ should be equal to $$$0$$$.
output
In the last example all children may have got the same number of candies, that's why all the numbers are $$$0$$$. Note that each child should receive at least one candy.
","constructivealgorithms, implementation",5
"def isPoss(n, arrs, nvals):
    masks = set()
    midx = {}
    for pos,arr in enumerate(arrs):
        mask = 0
        for i in range(nvals):
            if arr[i]>=n:
                mask += 1<<i
        midx[mask] = pos+1
        masks.add(mask)

    for m1 in masks:
        for m2 in masks:
            if m1|m2 == (1<<nvals)-1:
                return midx[m1], midx[m2]

    return -1, -1
                

narr, nvals = map(int, input().split())

arrs = []
for i in range(narr):
    arrs.append(list(map(int, input().split())))

mn = -1
mx = 10**9+1
while mn < mx-1:
    mid = (mn + mx) // 2
    a,b = isPoss(mid, arrs, nvals)
    if a != -1:
        mn = mid
    else:
        mx = mid - 1

for i in range(1,-1,-1):      
    a,b = isPoss(mn+i, arrs, nvals)
    if a != -1:
        print(a,b)
        break

",1288_D,CODEFORCES,4652,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"n, a, b = map(int, input().split())
z, o = ('01', '10')[a < b]
n *= not (a > 1 < b or 1 < n * a * b < 4)
l = [[z] * n for _ in range(n)]
for i in range(n):
    l[i][i] = '0'
for i in range(n - a * b):
    l[i][i + 1] = l[i + 1][i] = o
print(('YES', 'NO')[not n])
print('\n'.join(map(''.join, l)))",0990_D,CODEFORCES,3289,Graph And Its Complement,"Given three numbers $$$n, a, b$$$. You need to find an adjacency matrix of such an undirected graph that the number of components in it is equal to $$$a$$$, and the number of components in its complement is $$$b$$$. The matrix must be symmetric, and all digits on the main diagonal must be zeroes.
In an undirected graph loops (edges from a vertex to itself) are not allowed. It can be at most one edge between a pair of vertices.
The adjacency matrix of an undirected graph is a square matrix of size $$$n$$$ consisting only of ""0"" and ""1"", where $$$n$$$ is the number of vertices of the graph and the $$$i$$$-th row and the $$$i$$$-th column correspond to the $$$i$$$-th vertex of the graph. The cell $$$(i,j)$$$ of the adjacency matrix contains $$$1$$$ if and only if the $$$i$$$-th and $$$j$$$-th vertices in the graph are connected by an edge.
A connected component is a set of vertices $$$X$$$ such that for every two vertices from this set there exists at least one path in the graph connecting this pair of vertices, but adding any other vertex to $$$X$$$ violates this rule.
The complement or inverse of a graph $$$G$$$ is a graph $$$H$$$ on the same vertices such that two distinct vertices of $$$H$$$ are adjacent if and only if they are not adjacent in $$$G$$$.
In a single line, three numbers are given $$$n, a, b \,(1 \le n \le 1000, 1 \le a, b \le n)$$$: is the number of vertexes of the graph, the required number of connectivity components in it, and the required amount of the connectivity component in it's complement. 
If there is no graph that satisfies these constraints on a single line, print ""NO"" (without quotes).
","input
Otherwise, on the first line, print ""YES""(without quotes). In each of the next $$$n$$$ lines, output $$$n$$$ digits such that $$$j$$$-th digit of $$$i$$$-th line must be $$$1$$$ if and only if there is an edge between vertices $$$i$$$ and $$$j$$$ in $$$G$$$ (and $$$0$$$ otherwise). Note that the matrix must be symmetric, and all digits on the main diagonal must be zeroes. 
output
If there are several matrices that satisfy the conditions — output any of them.
","constructivealgorithms, graphs, implementation",5
"a=input()
b=input()
na=len(a)
nb=len(b)
def fs(a,b):
	try:
		for i in range(a+1,len(b)):
			if b[a]>b[i]:
				ans=b[i]
				k=b.copy()
				k.pop(i)
				ans+="""".join(k)
				return ans
		return False
	except:
		return False
if(na<nb):
	print("""".join(sorted(list(a),reverse=True)))
else:
	if(a==b):
		print(a)
		
	else:
		l=sorted(list(a),reverse=True)
		l2=l.copy()
		ans1=""""
		flag=0
		ans=[]
		for i in b:
			for j in range(len(l)):
				if i==l[j]:
					k=fs(j,l)
					if(k!=False):
						ans.append(ans1+fs(j,l))
					ans1+=l[j]
					l.pop(j)
					break
				if i>l[j]:
					ans1+=l[j]
					l.pop(j)
					flag=1
					break
			if(flag==1):
				break
		ans1+="""".join(l)
		if(int(ans1)<=int(b)):
			print(ans1)
		else:
			for i in sorted([int(i) for i in ans],reverse=True):
				if(i<=int(b)):
					print(i)
					break
  		  	 	    				   	 		   	",915C_,CODEFORCES,4199,Permute Digits,"You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.
It is allowed to leave a as it is.
The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.
","input
Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.
output
The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.
","dp, greedy",6
"n=2*int(input())
a=list(map(int,input().split()))
z=0
for i in range(0,n-1,2):
    if a[i]!=a[i+1]:
        for j in range(i+1,n):
            if a[j]==a[i]:
                z+=j-i-1
                a.pop(j)
                a.insert(i+1,a[i])
print(z)",0995_B,CODEFORCES,3330,Suit and Tie,"Allen is hosting a formal dinner party. $$$2n$$$ people come to the event in $$$n$$$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $$$2n$$$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.
Help Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 100$$$), the number of pairs of people.
The second line contains $$$2n$$$ integers $$$a_1, a_2, \dots, a_{2n}$$$. For each $$$i$$$ with $$$1 \le i \le n$$$, $$$i$$$ appears exactly twice. If $$$a_j = a_k = i$$$, that means that the $$$j$$$-th and $$$k$$$-th people in the line form a couple.
Output a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.
","input
In the first sample case, we can transform $$$1 1 2 3 3 2 4 4 \rightarrow 1 1 2 3 2 3 4 4 \rightarrow 1 1 2 2 3 3 4 4$$$ in two steps. Note that the sequence $$$1 1 2 3 3 2 4 4 \rightarrow 1 1 3 2 3 2 4 4 \rightarrow 1 1 3 3 2 2 4 4$$$ also works in the same number of steps.
output
The second sample case already satisfies the constraints; therefore we need $$$0$$$ swaps.
","greedy, implementation, math",5
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

from math import log
l,r=kk()
i=msb = int(max(log(l,2),log(r,2)))
while ((2**i)&l) == ((2**i)&r):
	i-=1
	if i == -1:
		break
i+=1
print(2**i-1)",0276_D,CODEFORCES,824,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"from collections import deque
from sys import stdin
lines = deque(line.strip() for line in stdin.readlines())

def nextline():
    return lines.popleft()

def types(cast, sep=None):
    return tuple(cast(x) for x in strs(sep=sep))

def ints(sep=None):
    return types(int, sep=sep)

def strs(sep=None):
    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))

def main():
    # lines will now contain all of the input's lines in a list
    n = int(nextline())
    a = ints()
    bs = set()
    moves = {}
    for i in range(n):
        moves[a[i]] = list(a[j] for j in range(i % a[i], n, a[i]) if a[j] > a[i])
    winners = {}
    for i in range(n, 0, -1):
        winner = 'A' if any(winners[j] == 'B' for j in moves[i]) else 'B'
        if winner == 'B':
            bs.add(i)
        winners[i] = winner
    print(''.join(winners[ai] for ai in a))


if __name__ == '__main__':
    main()
",1033_C,CODEFORCES,1914,Permutation Game,"After a long day, Alice and Bob decided to play a little game. The game board consists of $$$n$$$ cells in a straight line, numbered from $$$1$$$ to $$$n$$$, where each cell contains a number $$$a_i$$$ between $$$1$$$ and $$$n$$$. Furthermore, no two cells contain the same number. 
A token is placed in one of the cells. They take alternating turns of moving the token around the board, with Alice moving first. The current player can move from cell $$$i$$$ to cell $$$j$$$ only if the following two conditions are satisfied: 
Whoever is unable to make a move, loses. For each possible starting position, determine who wins if they both play optimally. It can be shown that the game is always finite, i.e. there always is a winning strategy for one of the players.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of numbers.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le n$$$). Furthermore, there are no pair of indices $$$i \neq j$$$ such that $$$a_i = a_j$$$.
","input
Print $$$s$$$ — a string of $$$n$$$ characters, where the $$$i$$$-th character represents the outcome of the game if the token is initially placed in the cell $$$i$$$. If Alice wins, then $$$s_i$$$ has to be equal to ""A""; otherwise, $$$s_i$$$ has to be equal to ""B"". 
output
In the first sample, if Bob puts the token on the number (not position): 
","bruteforce, dp, games",3
"def BIG(NUM):
    X=NUM
    SM=0
    while X!=0:
        M=X%10
        SM+=M
        X//=10
    if NUM-SM>=S:
        return True

import sys
sys.setrecursionlimit(int(1e5))
input=sys.stdin.readline
N,S=map(int,input().split())
F=0;L=N+1;MN=1<<64
while L>=F:
    M=(L+F)>>1
    if BIG(M):L=M-1;MN=min(MN,M)
    else:F=M+1
if MN==1<<64:
    print(0)
else:
    print(N-MN+1)",0817_C,CODEFORCES,965,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"n, s = map(int,input().split())

def digs(k):
	r = k
	while k:
		r -= k % 10
		k //= 10
	return r
x = s + 19*9
while digs(x-1) >= s:
	x -= 1
print(max(n - x + 1, 0))",0817_C,CODEFORCES,975,Really Big Numbers,"Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.
Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.
The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 1018).
Print one integer — the quantity of really big numbers that are not greater than n.
In the first example numbers 10, 11 and 12 are really big.
","input
In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).
output
In the third example 10 is the only really big number (10 - 1 ≥ 9).
","binarysearch, bruteforce, dp, math",2
"lst = list()

lst.append(0)
lst.append(1)

now = 1
while now <= 1e25 :
	now = now * 4 + 1
	# print(now)
	lst.append(now)

t = int(input())

for i in range(t):
	s = input().split()
	n = int(s[0])
	k = int(s[1])
	if(n >= 34):
		print(""YES "" + str(n - 1))
		continue

	sek = 0
	ambil = 1
	nyak = 0
	cnt = 0

	sudah = False
	while (sek < n):
		cnt = cnt + (1 << (sek + 1)) - 1
		# print(str(cnt) + "" here"")
		if cnt > k:
			print(""NO"")
			sudah = True
			break

		next_ambil = (ambil + 1) * 2 - 1
		sisa = 4 * ambil - next_ambil
		ambil = next_ambil

		sek += 1
		nyak = nyak + sisa * lst[n - sek]
		if (nyak + cnt) >= k :
			print(""YES "" + str(n - sek))
			sudah = True
			break

	if sudah == False:
		print(""NO"")
",1080_D,CODEFORCES,1175,Olya and magical square,"Recently, Olya received a magical square with the size of $$$2^n\times 2^n$$$.
It seems to her sister that one square is boring. Therefore, she asked Olya to perform exactly $$$k$$$ splitting operations.
A Splitting operation is an operation during which Olya takes a square with side $$$a$$$ and cuts it into 4 equal squares with side $$$\dfrac{a}{2}$$$. If the side of the square is equal to $$$1$$$, then it is impossible to apply a splitting operation to it (see examples for better understanding).
Olya is happy to fulfill her sister's request, but she also wants the condition of Olya's happiness to be satisfied after all operations.
The condition of Olya's happiness will be satisfied if the following statement is fulfilled:
Let the length of the side of the lower left square be equal to $$$a$$$, then the length of the side of the right upper square should also be equal to $$$a$$$. There should also be a path between them that consists only of squares with the side of length $$$a$$$. All consecutive squares on a path should have a common side.
Obviously, as long as we have one square, these conditions are met. So Olya is ready to fulfill her sister's request only under the condition that she is satisfied too. Tell her: is it possible to perform exactly $$$k$$$ splitting operations in a certain order so that the condition of Olya's happiness is satisfied? If it is possible, tell also the size of the side of squares of which the path from the lower left square to the upper right one will consist.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^3$$$) — the number of tests.
Each of the following $$$t$$$ lines contains two integers $$$n_i$$$ and $$$k_i$$$ ($$$1 \le n_i \le 10^9, 1 \le k_i \le 10^{18}$$$) — the description of the $$$i$$$-th test, which means that initially Olya's square has size of $$$2^{n_i}\times 2^{n_i}$$$ and Olya's sister asks her to do exactly $$$k_i$$$ splitting operations.
Print $$$t$$$ lines, where in the $$$i$$$-th line you should output ""YES"" if it is possible to perform $$$k_i$$$ splitting operations in the $$$i$$$-th test in such a way that the condition of Olya's happiness is satisfied or print ""NO"" otherwise. If you printed ""YES"", then also print the $$$log_2$$$ of the length of the side of the squares through space, along which you can build a path from the lower left square to the upper right one.
You can output each letter in any case (lower or upper).
If there are multiple answers, print any.
In each of the illustrations, the pictures are shown in order in which Olya applied the operations. The recently-created squares are highlighted with red.
In the first test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$1$$$. $$$log_2(1) = 0$$$.
In the second test, Olya can apply splitting operations in the following order:
The condition of Olya's happiness will be met, since there is a path of squares of the same size from the lower left square to the upper right one:
The length of the sides of the squares on the path is $$$2$$$. $$$log_2(2) = 1$$$.
","input
In the third test, it takes $$$5$$$ operations for Olya to make the square look like this:
output
Since it requires her to perform $$$7$$$ splitting operations, and it is impossible to perform them on squares with side equal to $$$1$$$, then Olya cannot do anything more and the answer is ""NO"".
","constructivealgorithms, implementation, math",2
"n, m = map(int, input().split())

np1 = n + 1
mp1 = m + 1

for i in range(1, 1 + n // 2):
  for j in range(1, mp1):
    # print(i, j)
    # print(np1 - i, mp1 - j)
    print('%d %d\n%d %d' % (i,j,np1-i,mp1-j))

if n & 1:
  i = 1 + n // 2
  for j in range(1, 1 + m // 2):
    # print(i, j)
    # print(i, mp1 - j)
    print('%d %d\n%d %d' % (i,j,i,mp1-j))

  if m & 1:
    print(i, 1 + m // 2)
",1179_B,CODEFORCES,3598,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms,5
"
import sys
#sys.stdin=open(""data.txt"")
input=sys.stdin.readline

for _ in range(int(input())):
    n,m,k=map(int,input().split())
    n=abs(n)
    m=abs(m)
    if max(n,m)>k:
        print(""-1"")
    else:
        # you can't 0 0 1 me :D
        bad1=((n+k)%2==1)
        bad2=((m+k)%2==1)
        print(k-bad1-bad2)
",1036_B,CODEFORCES,484,Diagonal Walking v,"Mikhail walks on a Cartesian plane. He starts at the point $$$(0, 0)$$$, and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $$$(0, 0)$$$, he can go to any of the following points in one move: 
If Mikhail goes from the point $$$(x1, y1)$$$ to the point $$$(x2, y2)$$$ in one move, and $$$x1 \ne x2$$$ and $$$y1 \ne y2$$$, then such a move is called a diagonal move.
Mikhail has $$$q$$$ queries. For the $$$i$$$-th query Mikhail's target is to go to the point $$$(n_i, m_i)$$$ from the point $$$(0, 0)$$$ in exactly $$$k_i$$$ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in $$$k_i$$$ moves.
Note that Mikhail can visit any point any number of times (even the destination point!).
The first line of the input contains one integer $$$q$$$ ($$$1 \le q \le 10^4$$$) — the number of queries.
Then $$$q$$$ lines follow. The $$$i$$$-th of these $$$q$$$ lines contains three integers $$$n_i$$$, $$$m_i$$$ and $$$k_i$$$ ($$$1 \le n_i, m_i, k_i \le 10^{18}$$$) — $$$x$$$-coordinate of the destination point of the query, $$$y$$$-coordinate of the destination point of the query and the number of moves in the query, correspondingly.
Print $$$q$$$ integers. The $$$i$$$-th integer should be equal to -1 if Mikhail cannot go from the point $$$(0, 0)$$$ to the point $$$(n_i, m_i)$$$ in exactly $$$k_i$$$ moves described above. Otherwise the $$$i$$$-th integer should be equal to the the maximum number of diagonal moves among all possible movements.
One of the possible answers to the first test case: $$$(0, 0) \to (1, 0) \to (1, 1) \to (2, 2)$$$.
","input
One of the possible answers to the second test case: $$$(0, 0) \to (0, 1) \to (1, 2) \to (0, 3) \to (1, 4) \to (2, 3) \to (3, 2) \to (4, 3)$$$.
output
In the third test case Mikhail cannot reach the point $$$(10, 1)$$$ in 9 moves.
",math,1
"a, b = map(int, input().split())
c = input()
sorted(c)
summa = 0
count = 0
j = -2
i = 0
abc = ""abcdefghijklmnopqrstuvwxyz""
while i < 26 and count < b:
    if abc[i] in c and i-2 >= j:
        summa += i+1
        count += 1
        j = i
    i += 1
if count < b:
    print(-1)
else:
    print(summa)",1011_A,CODEFORCES,1823,Stages,"Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string — concatenation of letters, which correspond to the stages.
There are $$$n$$$ stages available. The rocket must contain exactly $$$k$$$ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.
For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z' — $$$26$$$ tons.
Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.
The first line of input contains two integers — $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 50$$$) – the number of available stages and the number of stages to use in the rocket.
The second line contains string $$$s$$$, which consists of exactly $$$n$$$ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.
Print a single integer — the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.
In the first example, the following rockets satisfy the condition:
Rocket ""adx"" has the minimal weight, so the answer is $$$29$$$.
","input
In the second example, target rocket is ""belo"". Its weight is $$$2+5+12+15=34$$$.
output
In the third example, $$$n=k=2$$$, so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.
","greedy, implementation, sortings",3
"l,r = map(int,input().split())

a = ""{0:062b}"".format(l)
b = ""{0:062b}"".format(r)

n = len(a)
i = 0

if (l == r):
    print(0)
else:
    while (i<n and a[i] == b[i]):
        i += 1
    print(2**(62-i) - 1)",0276_D,CODEFORCES,829,Little Girl and Maximum XOR,"A little girl loves problems on bitwise operations very much. Here's one of them.
You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l ≤ a ≤ b ≤ r). Your task is to find the maximum value among all considered ones.
Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as ""^"", in Pascal — as ""xor"".
The single line contains space-separated integers l and r (1 ≤ l ≤ r ≤ 1018).
","input
Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.
output
In a single line print a single integer — the maximum value of  for all pairs of integers a, b (l ≤ a ≤ b ≤ r).
","bitmasks, dp, greedy, implementation, math",2
"

n, m = map(int, input().split())
a = list(map(int, input().split()))


class BIT:
    def __init__(self, n):
        self.n = n
        self.data = [0]*(n+1)

    def to_sum(self, i):
        s = 0
        while i > 0:
            s += self.data[i]
            i -= (i & -i)
        return s

    def add(self, i, x):
        while i <= self.n:
            self.data[i] += x
            i += (i & -i)

    def get(self, i, j):
        #[i,j](1<=i<=j<=N)
        return self.to_sum(j) - self.to_sum(i - 1)


def f(x, V):
    if x < V:
        return -1
    return 1


def calc_median(M):
    b = [f(v, M) for v in a]
    res = 0
    c = [0]
    for x in b:
        c.append(c[-1] + x)
    d = [(c[i], i) for i in range(n + 1)]
    bit = BIT(2*n + 10)
    for value, index in d:
        if index == 0:
            bit.add(value + n + 1, 1)
            continue
        res += bit.get(1, value + n)
        bit.add(value + n + 1, 1)

    return res


print(calc_median(m) - calc_median(m + 1))

",1005_E1,CODEFORCES,2692,Median on Segments (Permutations Edition),"You are given a permutation $$$p_1, p_2, \dots, p_n$$$. A permutation of length $$$n$$$ is a sequence such that each integer between $$$1$$$ and $$$n$$$ occurs exactly once in the sequence.
Find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of the median of $$$p_l, p_{l+1}, \dots, p_r$$$ is exactly the given number $$$m$$$.
The median of a sequence is the value of the element which is in the middle of the sequence after sorting it in non-decreasing order. If the length of the sequence is even, the left of two middle elements is used.
For example, if $$$a=[4, 2, 7, 5]$$$ then its median is $$$4$$$ since after sorting the sequence, it will look like $$$[2, 4, 5, 7]$$$ and the left of two middle elements is equal to $$$4$$$. The median of $$$[7, 1, 2, 9, 6]$$$ equals $$$6$$$ since after sorting, the value $$$6$$$ will be in the middle of the sequence.
Write a program to find the number of pairs of indices $$$(l, r)$$$ ($$$1 \le l \le r \le n$$$) such that the value of the median of $$$p_l, p_{l+1}, \dots, p_r$$$ is exactly the given number $$$m$$$.
The first line contains integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 2\cdot10^5$$$, $$$1 \le m \le n$$$) — the length of the given sequence and the required value of the median.
The second line contains a permutation $$$p_1, p_2, \dots, p_n$$$ ($$$1 \le p_i \le n$$$). Each integer between $$$1$$$ and $$$n$$$ occurs in $$$p$$$ exactly once.
","input
Print the required number.
output
In the first example, the suitable pairs of indices are: $$$(1, 3)$$$, $$$(2, 2)$$$, $$$(2, 3)$$$ and $$$(2, 4)$$$.
",sortings,4
"import sys
import threading
inp = sys.stdin.buffer.readline      
input = lambda: sys.stdin.readline().rstrip()
def I(): return list(map(int,inp().split()))
def main():
    n,=I() ; vis=[0]*n ; st=[0]*n
    if n==1:
        print(1)
        exit(0)
    def dfs(g,e):
        if vis[e]==1: return
        else: 
            vis[e]=1
            for i in g[e]:
                dfs(g,i)
            if len(g[e])==1 and e!=0: st[e]+=1
            for i in g[e]:
                st[e]+=st[i]
    a=[int(i)-1 for i in input().split()]
    g=[[] for i in range(n)]
    for i in range(n-1):
        g[i+1].append(a[i])
        g[a[i]].append(i+1)
    dfs(g,0)
    st.sort()
    print(*st)
sys.setrecursionlimit(2097152)
threading.stack_size(134217728)
main_thread = threading.Thread(target=main)
main_thread.start()
main_thread.join()",1056_D,CODEFORCES,3530,Decorate Apple Tree,"There is one apple tree in Arkady's garden. It can be represented as a set of junctions connected with branches so that there is only one way to reach any junctions from any other one using branches. The junctions are enumerated from $$$1$$$ to $$$n$$$, the junction $$$1$$$ is called the root.
A subtree of a junction $$$v$$$ is a set of junctions $$$u$$$ such that the path from $$$u$$$ to the root must pass through $$$v$$$. Note that $$$v$$$ itself is included in a subtree of $$$v$$$.
A leaf is such a junction that its subtree contains exactly one junction.
The New Year is coming, so Arkady wants to decorate the tree. He will put a light bulb of some color on each leaf junction and then count the number happy junctions. A happy junction is such a junction $$$t$$$ that all light bulbs in the subtree of $$$t$$$ have different colors.
Arkady is interested in the following question: for each $$$k$$$ from $$$1$$$ to $$$n$$$, what is the minimum number of different colors needed to make the number of happy junctions be greater than or equal to $$$k$$$?
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of junctions in the tree.
The second line contains $$$n - 1$$$ integers $$$p_2$$$, $$$p_3$$$, ..., $$$p_n$$$ ($$$1 \le p_i < i$$$), where $$$p_i$$$ means there is a branch between junctions $$$i$$$ and $$$p_i$$$. It is guaranteed that this set of branches forms a tree.
Output $$$n$$$ integers. The $$$i$$$-th of them should be the minimum number of colors needed to make the number of happy junctions be at least $$$i$$$.
","input
In the first example for $$$k = 1$$$ and $$$k = 2$$$ we can use only one color: the junctions $$$2$$$ and $$$3$$$ will be happy. For $$$k = 3$$$ you have to put the bulbs of different colors to make all the junctions happy.
output
In the second example for $$$k = 4$$$ you can, for example, put the bulbs of color $$$1$$$ in junctions $$$2$$$ and $$$4$$$, and a bulb of color $$$2$$$ into junction $$$5$$$. The happy junctions are the ones with indices $$$2$$$, $$$3$$$, $$$4$$$ and $$$5$$$ then.
","constructivealgorithms, dfsandsimilar, dp, graphs, greedy, sortings, trees",5
"""""""
Brandt Smith, Lemuel Gorion and Peter Haddad

codeforces.com

Problem 12455
""""""
import sys

def set(mask, pos):
    return mask | (1 << pos)

def isOn(mask, pos):
    return mask & ( 1 << pos) > 0

n, l, r, x = map(int, input().split(' '))
dif = list(map(int, input().split(' ')))

count, mask = 0, 0

while mask <= 2**n:
    summ, bit = [], 0

    while bit < n:
                
        if isOn(mask, bit):
            summ.append(dif[bit])
                    
        bit += 1
        
    if sum(summ) <= r and sum(summ) >= l and max(summ) - min(summ) >= x:
        count += 1
                
    mask += 1
                
                
print(count)

    
    

",0550_B,CODEFORCES,4438,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"n, k = map(int, input().split())
ps = list(map(int, input().split()))


g = [None for i in range(256)]
f = [None for i in range(256)]
ans = []
for i in range(n):
    p = ps[i]
    if g[p] is not None:
        ans.append(g[p])
        f[p] = 1
    else:
        gb= 0
        for j in range(k):
            ind = p - j
            if f[ind] is not None:
                gb = ind +1
                break
            if ind <= 0:
                break
            if j == k-1:
                gb = ind
        ans.append(gb)
        for j in range(k):
            if gb+j >= 256:
                break
            if f[gb + j] is None:
                g[gb+j] = gb
            else:
                break
        f[gb] = 1
        f[p] = 1
print(' '.join([str(i) for i in ans]))",0980_C,CODEFORCES,3205,Posterized,"Professor Ibrahim has prepared the final homework for his algorithm’s class. He asked his students to implement the Posterization Image Filter.
Their algorithm will be tested on an array of integers, where the $$$i$$$-th integer represents the color of the $$$i$$$-th pixel in the image. The image is in black and white, therefore the color of each pixel will be an integer between 0 and 255 (inclusive).
To implement the filter, students are required to divide the black and white color range [0, 255] into groups of consecutive colors, and select one color in each group to be the group’s key. In order to preserve image details, the size of a group must not be greater than $$$k$$$, and each color should belong to exactly one group.
Finally, the students will replace the color of each pixel in the array with that color’s assigned group key.
To better understand the effect, here is an image of a basking turtle where the Posterization Filter was applied with increasing $$$k$$$ to the right. 
To make the process of checking the final answer easier, Professor Ibrahim wants students to divide the groups and assign the keys in a way that produces the lexicographically smallest possible array.
The first line of input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq n \leq 10^5$$$, $$$1 \leq k \leq 256$$$), the number of pixels in the image, and the maximum size of a group, respectively.
The second line contains $$$n$$$ integers $$$p_1, p_2, \dots, p_n$$$ ($$$0 \leq p_i \leq 255$$$), where $$$p_i$$$ is the color of the $$$i$$$-th pixel.
Print $$$n$$$ space-separated integers; the lexicographically smallest possible array that represents the image after applying the Posterization filter.
One possible way to group colors and assign keys for the first sample:
Color $$$2$$$ belongs to the group $$$[0,2]$$$, with group key $$$0$$$.
Color $$$14$$$ belongs to the group $$$[12,14]$$$, with group key $$$12$$$.
","input
Colors $$$3$$$ and $$$4$$$ belong to group $$$[3, 5]$$$, with group key $$$3$$$.
output
Other groups won't affect the result so they are not listed here.
","games, greedy",5
"import sys
input = sys.stdin.buffer.readline

n = int(input())
a = list(map(int,input().split()))

parity = 0
for i in range(n):
    for j in range(i+1,n):
        if a[j] < a[i]:
            parity ^= 1

m = int(input())
for i in range(m):
    l,r = map(int,input().split())

    dist = (r-l+1)
    pairs = (dist-1)*(dist)//2

    if pairs & 1:
        parity ^= 1

    if parity:
        print(""odd"")
    else:
        print(""even"")",0911_D,CODEFORCES,3095,Inversion Counting,"A permutation of size n is an array of size n such that each integer from 1 to n occurs exactly once in this array. An inversion in a permutation p is a pair of indices (i, j) such that i > j and ai < aj. For example, a permutation [4, 1, 3, 2] contains 4 inversions: (2, 1), (3, 1), (4, 1), (4, 3).
You are given a permutation a of size n and m queries to it. Each query is represented by two indices l and r denoting that you have to reverse the segment [l, r] of the permutation. For example, if a = [1, 2, 3, 4] and a query l = 2, r = 4 is applied, then the resulting permutation is [1, 4, 3, 2].
After each query you have to determine whether the number of inversions is odd or even.
The first line contains one integer n (1 ≤ n ≤ 1500) — the size of the permutation. 
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of the permutation. These integers are pairwise distinct.
The third line contains one integer m (1 ≤ m ≤ 2·105) — the number of queries to process.
Then m lines follow, i-th line containing two integers li, ri (1 ≤ li ≤ ri ≤ n) denoting that i-th query is to reverse a segment [li, ri] of the permutation. All queries are performed one after another.
Print m lines. i-th of them must be equal to odd if the number of inversions in the permutation after i-th query is odd, and even otherwise.
","input
The first example:
output
The second example:
","bruteforce, math",5
"import sys
input = sys.stdin.readline
x,y = map(int, input().split())
if y-x<2:
	print(-1)
elif x%2 != 0 and y-x==2:
	print(-1)
elif x%2==0:
	print(x, x+1, x+2)
else:
	print(x+1, x+2, x+3)",0483_A,CODEFORCES,161,Counterexample,"Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. 
Your friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. 
You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l ≤ a < b < c ≤ r. 
More specifically, you need to find three numbers (a, b, c), such that l ≤ a < b < c ≤ r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.
The single line contains two positive space-separated integers l, r (1 ≤ l ≤ r ≤ 1018; r - l ≤ 50).
Print three positive space-separated integers a, b, c — three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 
If the counterexample does not exist, print the single number -1.
In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 
","input
In the second sample you cannot form a group of three distinct integers, so the answer is -1. 
output
In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three. 
","bruteforce, implementation, math, numbertheory",1
"from sys import stdin,stdout
n,q=map(int,input().split())
mod=1000000007
o=[]
s=[]
r=m=0
a=input()
for i in a:
    if i=='0':
        r+=1
    else:
        m+=1
    o.append(r)
    s.append(m)
z=[1]
#print(o)
for i in range(100000):
    z.append((z[-1]*2)%mod)
for j in range(q):
    l,r=(int(j) for j in stdin.readline().split())
    m=r-l+1
    zs=o[r-1]-o[l-1]+(a[l-1]=='0')
    os=m-zs
    #print(zs,os)
    if zs!=0:
        print((((z[os]-1)%mod)*((z[zs])%mod))%mod)
    else:
        print(((z[os]-1)%mod))
    
    
    
",1062_C,CODEFORCES,1992,Banh-mi,"JATC loves Banh-mi (a Vietnamese food). His affection for Banh-mi is so much that he always has it for breakfast. This morning, as usual, he buys a Banh-mi and decides to enjoy it in a special way.
First, he splits the Banh-mi into $$$n$$$ parts, places them on a row and numbers them from $$$1$$$ through $$$n$$$. For each part $$$i$$$, he defines the deliciousness of the part as $$$x_i \in \{0, 1\}$$$. JATC's going to eat those parts one by one. At each step, he chooses arbitrary remaining part and eats it. Suppose that part is the $$$i$$$-th part then his enjoyment of the Banh-mi will increase by $$$x_i$$$ and the deliciousness of all the remaining parts will also increase by $$$x_i$$$. The initial enjoyment of JATC is equal to $$$0$$$.
For example, suppose the deliciousness of $$$3$$$ parts are $$$[0, 1, 0]$$$. If JATC eats the second part then his enjoyment will become $$$1$$$ and the deliciousness of remaining parts will become $$$[1, \_, 1]$$$. Next, if he eats the first part then his enjoyment will become $$$2$$$ and the remaining parts will become $$$[\_, \_, 2]$$$. After eating the last part, JATC's enjoyment will become $$$4$$$.
However, JATC doesn't want to eat all the parts but to save some for later. He gives you $$$q$$$ queries, each of them consisting of two integers $$$l_i$$$ and $$$r_i$$$. For each query, you have to let him know what is the maximum enjoyment he can get if he eats all the parts with indices in the range $$$[l_i, r_i]$$$ in some order.
All the queries are independent of each other. Since the answer to the query could be very large, print it modulo $$$10^9+7$$$.
The first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \le n, q \le 100\,000$$$).
The second line contains a string of $$$n$$$ characters, each character is either '0' or '1'. The $$$i$$$-th character defines the deliciousness of the $$$i$$$-th part.
Each of the following $$$q$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \le l_i \le r_i \le n$$$) — the segment of the corresponding query.
Print $$$q$$$ lines, where $$$i$$$-th of them contains a single integer — the answer to the $$$i$$$-th query modulo $$$10^9 + 7$$$.
","input
In the first example: 
output
In the second example, any order of eating parts leads to the same answer.
","greedy, implementation, math",3
"import sys
sys.setrecursionlimit(2000)
from collections import Counter

if __name__ == ""__main__"":

    # single variables
    n = [int(val) for val in input().split()][0]
    b = [int(val) for val in input().split()]

    l = 0
    r = b[0]
    a = [0] * n
    for i in range(n//2):
        a[i] = l
        a[n-1-i] = r
        if(i != n//2-1):
            val = b[i+1]
            summ = l + r
            if(summ == val):
                continue
            elif(summ > val):
                diff = summ - val
                r -= diff
            elif(summ < val):
                diff = val - summ
                l += diff

    for i in a:
        print(i, end=' ')
    print('')
       


",1093_C,CODEFORCES,2091,Mishka and the Last Exam,"Mishka is trying really hard to avoid being kicked out of the university. In particular, he was doing absolutely nothing for the whole semester, miraculously passed some exams so that just one is left.
There were $$$n$$$ classes of that subject during the semester and on $$$i$$$-th class professor mentioned some non-negative integer $$$a_i$$$ to the students. It turned out, the exam was to tell the whole sequence back to the professor. 
Sounds easy enough for those who attended every class, doesn't it?
Obviously Mishka didn't attend any classes. However, professor left some clues on the values of $$$a$$$ to help out students like Mishka: 
Professor also mentioned that any sequence $$$a$$$, which produces sequence $$$b$$$ with the presented technique, will be acceptable.
Help Mishka to pass that last exam. Restore any sorted sequence $$$a$$$ of non-negative integers, which produces sequence $$$b$$$ with the presented technique. It is guaranteed that there exists at least one correct sequence $$$a$$$, which produces the given sequence $$$b$$$.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — the length of sequence $$$a$$$. $$$n$$$ is always even.
The second line contains $$$\frac n 2$$$ integers $$$b_1, b_2, \dots, b_{\frac n 2}$$$ ($$$0 \le b_i \le 10^{18}$$$) — sequence $$$b$$$, where $$$b_i = a_i + a_{n - i + 1}$$$.
It is guaranteed that there exists at least one correct sequence $$$a$$$, which produces the given sequence $$$b$$$.
Print $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$0 \le a_i \le 10^{18}$$$) in a single line.
","input
$$$a_1 \le a_2 \le \dots \le a_n$$$ should be satisfied.
output
$$$b_i = a_i + a_{n - i + 1}$$$ should be satisfied for all valid $$$i$$$.
",greedy,3
"import math
s1=list(input())
s2=list(input())
p1,m1,p2,m2,c=0,0,0,0,0
for i in range(len(s1)):
	if(s1[i]=='+'):
		p1+=1
	if(s1[i]=='-'):
		m1+=1
	if(s2[i]=='+'):
		p2+=1
	if(s2[i]=='-'):
		m2+=1
	if(s2[i]=='?'):
		c+=1
p=abs(p1-p2)
m=abs(m1-m2)
if((p+m)==c):
	print(math.factorial(c)/(math.factorial(p)*math.factorial(m)*pow(2,c)))
else:
	print(0/1)",0476_B,CODEFORCES,4318,Dreamoon and WiFi,"Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.
Each command is one of the following two types: 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 
You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?
The first line contains a string s1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 
The second line contains a string s2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.
Lengths of two strings are equal and do not exceed 10.
Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9.
For the first sample, both s1 and s2 will lead Dreamoon to finish at the same position  + 1. 
","input
For the second sample, s1 will lead Dreamoon to finish at position 0, while there are four possibilites for s2: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 
output
For the third sample, s2 could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.
","bitmasks, bruteforce, combinatorics, dp, math, probabilities",7
"#_______________________________________________________________#
def fact(x):
	if x == 0:
		return 1
	else:
		return x * fact(x-1)
def lower_bound(li, num): 
	answer = -1
	start = 0
	end = len(li)-1

	while(start <= end):
		middle = (end+start)//2
		if li[middle] >= num:
			answer = middle
			end = middle - 1
		else:
			start = middle + 1
	return answer #index where x is not less than num
def upper_bound(li, num): 
	answer = -1
	start = 0
	end = len(li)-1

	while(start <= end):
		middle = (end+start)//2

		if li[middle] <= num:
			answer = middle
			start = middle + 1
		
		else:
			end = middle - 1
	return answer #index where x is not greater than num

def abs(x):
	return x if x >=0 else -x
def binary_search(li, val, lb, ub): 
	ans = 0
	while(lb <= ub):
		mid = (lb+ub)//2
		#print(mid, li[mid])
		if li[mid] > val:
			ub = mid-1
		elif val > li[mid]:
			lb = mid + 1
		else:
			ans = 1
			break
	return ans
def kadane(x): #maximum sum contiguous subarray
	sum_so_far = 0
	current_sum = 0
	for i in x:
		current_sum += i
		if current_sum < 0:
			current_sum = 0
		else:
			sum_so_far = mpos(sum_so_far,current_sum)
	return sum_so_far
def pref(li):
	pref_sum = [0]
	for i in li:
		pref_sum.append(pref_sum[-1] + i)
	return pref_sum
def graph(n,m):
	adj = dict()
	for i in range(1,n+1):
		adj.setdefault(i,0)
	for i in range(m):
		a,b = map(int,input().split())
		adj[a] += 1
		adj[b] += 1
	return adj

#_______________________________________________________________#
'''
      ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
   ▄███████▀▀▀▀▀▀███████▄
░▐████▀▒▒Aestroix▒▒▀██████
░███▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▀████
░▐██▒▒▒▒▒KARMANYA▒▒▒▒▒▒████▌         ________________
░▐█▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▌  ? ?   |▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒|
░░█▒▒▄▀▀▀▀▀▄▒▒▄▀▀▀▀▀▄▒▒▐███▌   ?    |___CM ONE DAY___|
░░░▐░░░▄▄░░▌▐░░░▄▄░░▌▒▐███▌     ? ? |▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒|
░▄▀▌░░░▀▀░░▌▐░░░▀▀░░▌▒▀▒█▌    ? ?    
░▌▒▀▄░░░░▄▀▒▒▀▄░░░▄▀▒▒▄▀▒▌      ? 
░▀▄▐▒▀▀▀▀▒▒▒▒▒▒▀▀▀▒▒▒▒▒▒█     ? ? 
░░░▀▌▒▄██▄▄▄▄████▄▒▒▒▒█▀       ? 
░░░░▄█████████ ████=========█▒▒▐▌
░░░▀███▀▀████▀█████▀▒▌
░░░░░▌▒▒▒▄▒▒▒▄▒▒▒▒▒▒▐
░░░░░▌▒▒▒▒▀▀▀▒▒▒▒▒▒▒▐
░░░░░████████████████
'''
import sys
import threading
from math import *
#sys.setrecursionlimit(900000)
#threading.stack_size(10**5)  # remember it cause mle
#def main():
#for _ in range(int(input())):
for _ in range(1):
	#n = int(input())
	n,l,r,x = map(int,input().split())
	#n, s = input().split()
	#s = list(input())
	#a = [int(x) for x in s]
	#s = list(input())
	a = list(map(int,input().split()))
	#b = list(map(int,input().split()))
	#adj = graph(n,m)
	
	cnt = 0
	for mask in range(1,(1<<n)+1):
		mini = 10**9 + 10
		maxi = 0
		elem = 0
		sumi = 0
		for j in range(n):
			if mask & (1<<j): #if the bitmask array element is 1
				elem += 1
				sumi += a[j]
				mini = min(mini, a[j])
				maxi = max(maxi, a[j])
		#print(elem,sumi,maxi,mini,bin(mask))
		if elem >= 2:
			if (l <= sumi <= r) and (maxi-mini >= x):
				cnt += 1
	print(cnt)



















































'''		
t = threading.Thread(target=main)
t.start()
t.join()
'''









	




",0550_B,CODEFORCES,4500,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"def solution():
    
    n = int(input())
    segments = []
    for i,_ in enumerate(range(n)):
        x,y = input().split("" "")
        segments.append((int(x), int(y), i+1))

    segments = sorted(segments, key=lambda x: (x[0], -x[1]))

    for i,seg in enumerate(segments):
        j = i+1
        if j >= n:
            print(""-1 -1"")
            return

        while segments[j][1] <= seg[1]:
            print(""{} {}"".format(segments[j][2], seg[2]))
            return

    print(""-1 -1"")
    return

solution()
",0976_C,CODEFORCES,2526,Nested Segments,"You are given a sequence a1, a2, ..., an of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment ai lies within segment aj.
Segment [l1, r1] lies within segment [l2, r2] iff l1 ≥ l2 and r1 ≤ r2.
Print indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
The first line contains one integer n (1 ≤ n ≤ 3·105) — the number of segments.
Each of the next n lines contains two integers li and ri (1 ≤ li ≤ ri ≤ 109) — the i-th segment.
","input
Print two distinct indices i and j such that segment ai lies within segment aj. If there are multiple answers, print any of them. If no answer exists, print -1 -1.
output
In the first example the following pairs are considered correct:
","greedy, implementation, sortings",4
"a,b = map(int, input().split())
x, y, z = map(int, input().split())

ans = max(0, 2*x+y-a)+max(0, 3*z+y-b)
print(ans)
",0912_A,CODEFORCES,216,Tricky Alchemy,"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.
Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.
Right now there are A yellow and B blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.
The first line features two integers A and B (0 ≤ A, B ≤ 109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.
The next line contains three integers x, y and z (0 ≤ x, y, z ≤ 109) — the respective amounts of yellow, green and blue balls to be obtained.
","input
Print a single integer — the minimum number of crystals that Grisha should acquire in addition.
output
In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.
",implementation,1
"
import itertools

n , l , r , x = map(int,input().split())

problems = list(map(int,input().split()))

ans = 0

for i in range(2 , n + 1 ):
    for j in itertools.combinations(problems ,i):
        if (l <= sum(j) <= r and max(j) - min(j) >= x):
            ans +=1

print(ans)


",0550_B,CODEFORCES,4502,Preparing Olympiad,"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.
A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.
Find the number of ways to choose a problemset for the contest.
The first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.
The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.
Print the number of ways to choose a suitable problemset for the contest. 
In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.
","input
In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.
output
In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.
","bitmasks, bruteforce",7
"n = int(input())
print([""YES"", ""NO""][all(n % i for i in [4, 7, 47, 744, 477])])",0122_A,CODEFORCES,40,Lucky Division,"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.
Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.
The single line contains an integer n (1 ≤ n ≤ 1000) — the number that needs to be checked.
In the only line print ""YES"" (without the quotes), if number n is almost lucky. Otherwise, print ""NO"" (without the quotes).
","input
Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.
output
In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.
","bruteforce, numbertheory",1
"n = int(input())
x, y = map(int, input().split())

def d(a, b):
    return a + b

if d(x-1, y-1) <= d(n-x, n-y):
    print(""White"")
else:
    print(""Black"")",1075_A,CODEFORCES,565,The King's Race,"On a chessboard with a width of $$$n$$$ and a height of $$$n$$$, rows are numbered from bottom to top from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. Therefore, for each cell of the chessboard, you can assign the coordinates $$$(r,c)$$$, where $$$r$$$ is the number of the row, and $$$c$$$ is the number of the column.
The white king has been sitting in a cell with $$$(1,1)$$$ coordinates for a thousand years, while the black king has been sitting in a cell with $$$(n,n)$$$ coordinates. They would have sat like that further, but suddenly a beautiful coin fell on the cell with coordinates $$$(x,y)$$$...
Each of the monarchs wanted to get it, so they decided to arrange a race according to slightly changed chess rules:
As in chess, the white king makes the first move, the black king makes the second one, the white king makes the third one, and so on. However, in this problem, kings can stand in adjacent cells or even in the same cell at the same time.
The player who reaches the coin first will win, that is to say, the player who reaches the cell with the coordinates $$$(x,y)$$$ first will win.
Let's recall that the king is such a chess piece that can move one cell in all directions, that is, if the king is in the $$$(a,b)$$$ cell, then in one move he can move from $$$(a,b)$$$ to the cells $$$(a + 1,b)$$$, $$$(a - 1,b)$$$, $$$(a,b + 1)$$$, $$$(a,b - 1)$$$, $$$(a + 1,b - 1)$$$, $$$(a + 1,b + 1)$$$, $$$(a - 1,b - 1)$$$, or $$$(a - 1,b + 1)$$$. Going outside of the field is prohibited.
Determine the color of the king, who will reach the cell with the coordinates $$$(x,y)$$$ first, if the white king moves first.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 10^{18}$$$) — the length of the side of the chess field.
The second line contains two integers $$$x$$$ and $$$y$$$ ($$$1 \le x,y \le n$$$) — coordinates of the cell, where the coin fell.
In a single line print the answer ""White"" (without quotes), if the white king will win, or ""Black"" (without quotes), if the black king will win.
You can print each letter in any case (upper or lower).
An example of the race from the first sample where both the white king and the black king move optimally:
","input
An example of the race from the second sample where both the white king and the black king move optimally:
output
In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.
","implementation, math",1
"from collections import defaultdict
from sys import stdin
input = stdin.readline
def check(mid, m):
    d = defaultdict(int)
    for idx, i in enumerate(a):
        string = ''
        for j in i:
            if j >= mid:
                string+='1'
            else:
                string+='0'
        d[int(string, 2)] = idx
    for i in d.keys():
        for j in d.keys():
            if i|j == 2**m - 1:
                 return [d[i], d[j]]
    return []
def binarySearch(lo, hi, m):
    ans = []
    while lo < hi:
        mid = lo + (hi-lo+1)//2
        x = check(mid, m)
        if x:
            lo = mid
            ans = [x[0]+1, x[1]+1]
        else:
            hi = mid-1
    return ans
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
print(*binarySearch(-1, 10**9+1, m))",1288_D,CODEFORCES,4663,Minimax Problem,"You are given $$$n$$$ arrays $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$; each array consists of exactly $$$m$$$ integers. We denote the $$$y$$$-th element of the $$$x$$$-th array as $$$a_{x, y}$$$.
You have to choose two arrays $$$a_i$$$ and $$$a_j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$). After that, you will obtain a new array $$$b$$$ consisting of $$$m$$$ integers, such that for every $$$k \in [1, m]$$$ $$$b_k = \max(a_{i, k}, a_{j, k})$$$.
Your goal is to choose $$$i$$$ and $$$j$$$ so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 3 \cdot 10^5$$$, $$$1 \le m \le 8$$$) — the number of arrays and the number of elements in each array, respectively.
","input
Then $$$n$$$ lines follow, the $$$x$$$-th line contains the array $$$a_x$$$ represented by $$$m$$$ integers $$$a_{x, 1}$$$, $$$a_{x, 2}$$$, ..., $$$a_{x, m}$$$ ($$$0 \le a_{x, y} \le 10^9$$$).
output
Print two integers $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$, it is possible that $$$i = j$$$) — the indices of the two arrays you have to choose so that the value of $$$\min \limits_{k = 1}^{m} b_k$$$ is maximum possible. If there are multiple answers, print any of them.
","binarysearch, bitmasks, dp",7
"n = int(input())
wyn = 1
x = 4
for i in range(n - 1):
	wyn += x
	x += 4
print(wyn)",1180_A,CODEFORCES,2154,Alex and a Rhombus,"While playing with geometric figures Alex has accidentally invented a concept of a $$$n$$$-th order rhombus in a cell grid.
A $$$1$$$-st order rhombus is just a square $$$1 \times 1$$$ (i.e just a cell).
A $$$n$$$-th order rhombus for all $$$n \geq 2$$$ one obtains from a $$$n-1$$$-th order rhombus adding all cells which have a common side with it to it (look at the picture to understand it better).
Alex asks you to compute the number of cells in a $$$n$$$-th order rhombus.
The first and only input line contains integer $$$n$$$ ($$$1 \leq n \leq 100$$$) — order of a rhombus whose numbers of cells should be computed.
","input
Print exactly one integer — the number of cells in a $$$n$$$-th order rhombus.
output
Images of rhombus corresponding to the examples are given in the statement.
","dp, implementation, math",3
"def main():
    n = int(input())
    a = list(map(int, input().split(' ')))
    array = []
    array.append(a)
    
    for i in range(n - 1):
        aux = []
        for j in range(1, len(array[-1])):
            xor = array[-1][j-1] ^ array[-1][j]
            aux.append(xor)
        array.append(aux)
    
    for j in range(1, len(array)):
        for k in range(len(array[j])):
            maximo = max(array[j][k], array[j-1][k], array[j - 1][k + 1])
            array[j][k] = maximo
    
    q = int(input())
    aux2 = []
    for i in range(q):
        l, r = map(int, input().split(' '))
        aux2.append((l,r))

    for i in aux2:
        l, r = i[0], i[1]
        print(str(array[r - l][l - 1]))

main()
 	 			 	 			 			     	 		 	  		",0983_B,CODEFORCES,3220,XOR-pyramid,"For an array $$$b$$$ of length $$$m$$$ we define the function $$$f$$$ as 
where $$$\oplus$$$ is bitwise exclusive OR.
For example, $$$f(1,2,4,8)=f(1\oplus2,2\oplus4,4\oplus8)=f(3,6,12)=f(3\oplus6,6\oplus12)=f(5,10)=f(5\oplus10)=f(15)=15$$$
You are given an array $$$a$$$ and a few queries. Each query is represented as two integers $$$l$$$ and $$$r$$$. The answer is the maximum value of $$$f$$$ on all continuous subsegments of the array $$$a_l, a_{l+1}, \ldots, a_r$$$.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 5000$$$) — the length of $$$a$$$.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$0 \le a_i \le 2^{30}-1$$$) — the elements of the array.
The third line contains a single integer $$$q$$$ ($$$1 \le q \le 100\,000$$$) — the number of queries.
Each of the next $$$q$$$ lines contains a query represented as two integers $$$l$$$, $$$r$$$ ($$$1 \le l \le r \le n$$$).
Print $$$q$$$ lines — the answers for the queries.
","input
In first sample in both queries the maximum value of the function is reached on the subsegment that is equal to the whole segment.
output
In second sample, optimal segment for first query are $$$[3,6]$$$, for second query — $$$[2,5]$$$, for third — $$$[3,4]$$$, for fourth — $$$[1,2]$$$.
",dp,5
"n, a, b, c, t = map(int, input().split())
l = list(map(int, input().split()))
f = [0] * 1001
for i in l: f[i] -= -1
tmp = 0
tmp2 = 0
for i in range(1, t):
    tmp += (t - i) * f[i]
tmp = n * a + tmp * c - tmp * b
print(max(n * a, tmp))",0964_B,CODEFORCES,1609,Messages,"There are n incoming messages for Vasya. The i-th message is going to be received after ti minutes. Each message has a cost, which equals to A initially. After being received, the cost of a message decreases by B each minute (it can become negative). Vasya can read any message after receiving it at any moment of time. After reading the message, Vasya's bank account receives the current cost of this message. Initially, Vasya's bank account is at 0.
Also, each minute Vasya's bank account receives C·k, where k is the amount of received but unread messages.
Vasya's messages are very important to him, and because of that he wants to have all messages read after T minutes.
Determine the maximum amount of money Vasya's bank account can hold after T minutes.
The first line contains five integers n, A, B, C and T (1 ≤ n, A, B, C, T ≤ 1000).
The second string contains n integers ti (1 ≤ ti ≤ T).
Output one integer  — the answer to the problem.
In the first sample the messages must be read immediately after receiving, Vasya receives A points for each message, n·A = 20 in total.
","input
In the second sample the messages can be read at any integer moment.
output
In the third sample messages must be read at the moment T. This way Vasya has 1, 2, 3, 4 and 0 unread messages at the corresponding minutes, he gets 40 points for them. When reading messages, he receives (5 - 4·3) + (5 - 3·3) + (5 - 2·3) + (5 - 1·3) + 5 =  - 5 points. This is 35 in total.
",math,3
"def search(arr,power):
    lo=0
    hi=len(arr)-1
    ans=-1
    while lo<=hi:
        mid=(lo+hi)//2
        if arr[mid]<=power:
            ans=mid
            lo=mid+1
        else:
            hi=mid-1
    return ans

n,q = list(map(int, input().split()))
a = list(map(int, input().split()))
k = list(map(int, input().split()))
for i in range(1,n):
    a[i]+=a[i-1]
power = 0
for i in range(q):
    power+=k[i]
    pos = search(a,power)
    if pos==n-1:
        print(n)
        power=0
    elif pos==-1:
        print(n)
    else:
        print(n-pos-1)",0975_C,CODEFORCES,2509,Valhalla Siege,"Ivar the Boneless is a great leader. He is trying to capture Kattegat from Lagertha. The war has begun and wave after wave Ivar's warriors are falling in battle.
Ivar has $$$n$$$ warriors, he places them on a straight line in front of the main gate, in a way that the $$$i$$$-th warrior stands right after $$$(i-1)$$$-th warrior. The first warrior leads the attack.
Each attacker can take up to $$$a_i$$$ arrows before he falls to the ground, where $$$a_i$$$ is the $$$i$$$-th warrior's strength.
Lagertha orders her warriors to shoot $$$k_i$$$ arrows during the $$$i$$$-th minute, the arrows one by one hit the first still standing warrior. After all Ivar's warriors fall and all the currently flying arrows fly by, Thor smashes his hammer and all Ivar's warriors get their previous strengths back and stand up to fight again. In other words, if all warriors die in minute $$$t$$$, they will all be standing to fight at the end of minute $$$t$$$.
The battle will last for $$$q$$$ minutes, after each minute you should tell Ivar what is the number of his standing warriors.
The first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \le n, q \leq 200\,000$$$) — the number of warriors and the number of minutes in the battle.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \leq a_i \leq 10^9$$$) that represent the warriors' strengths.
The third line contains $$$q$$$ integers $$$k_1, k_2, \ldots, k_q$$$ ($$$1 \leq k_i \leq 10^{14}$$$), the $$$i$$$-th of them represents Lagertha's order at the $$$i$$$-th minute: $$$k_i$$$ arrows will attack the warriors.
","input
Output $$$q$$$ lines, the $$$i$$$-th of them is the number of standing warriors after the $$$i$$$-th minute.
output
In the first example: 
",binarysearch,4
"str=input()
n=len(str)
ans=0
amap={}
def fun():
    global ans
    for strLen in range(n,0,-1):
        mark=0
        for t in range(0,n):
            if t+strLen>n:
                break
            s=str[t:t+strLen]
            if s in amap:
                amap[s]+=1
            else:
                amap[s]=1
            if amap[s]>=2:
                mark=1
                ans=len(s)
                print(ans)
                break
        if mark==1:
            break
fun()
if ans==0:
    print(ans)",0023_A,CODEFORCES,3728,You're Given a String,"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).
","input
The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.
output
Output one number — length of the longest substring that can be met in the string at least twice.
","bruteforce, greedy",6
"from sys import stdin,stdout
from math import gcd,sqrt,factorial,pi,inf
from collections import deque,defaultdict
from bisect import bisect,bisect_left
from time import time
from itertools import permutations as per
input=stdin.readline
R=lambda:map(int,input().split())
I=lambda:int(input())
S=lambda:input().rstrip('\r\n')
L=lambda:list(R())
P=lambda x:stdout.write(str(x)+'\n')
lcm=lambda x,y:(x*y)//gcd(x,y)
nCr=lambda x,y:(f[x]*inv((f[y]*f[x-y])%N))%N
inv=lambda x:pow(x,N-2,N)
sm=lambda x:(x**2+x)//2
N=10**9+7

n,m,k=R()
A=[L() for i in range(n)]
B=[L() for i in range(n-1)]
if k&1:
	for i in range(n):
		print('-1 '*m)
	exit()
X=[[0]*m for i in range(n)]
for _ in range(k//2):
	Y=[[inf]*m for i in range(n)]
	for i in range(n):
		for j in range(m):
			if i:
				Y[i][j]=X[i-1][j]+2*B[i-1][j]
			if i<n-1:
				Y[i][j]=min(Y[i][j],X[i+1][j]+2*B[i][j])
			if j:
				Y[i][j]=min(Y[i][j],X[i][j-1]+2*A[i][j-1])
			if j<m-1:
				Y[i][j]=min(Y[i][j],X[i][j+1]+2*A[i][j])
	X=Y
for i in X:
	print(*i)",1517_D,CODEFORCES,4156,Explorer Space,"You are wandering in the explorer space of the 2050 Conference.
The explorer space can be viewed as an undirected weighted grid graph with size $$$n\times m$$$. The set of vertices is $$$\{(i, j)|1\le i\le n, 1\le j\le m\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.
At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.
For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?
You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$2\leq n, m\leq 500, 1\leq k\leq 20$$$).
The $$$j$$$-th number ($$$1\le j \le m - 1$$$) in the $$$i$$$-th line of the following $$$n$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i, j+1)$$$. 
The $$$j$$$-th number ($$$1\le j\le m$$$) in the $$$i$$$-th line of the following $$$n-1$$$ lines is the number of exibits on the edge between vertex $$$(i, j)$$$ and vertex $$$(i+1, j)$$$. 
The number of exhibits on each edge is an integer between $$$1$$$ and $$$10^6$$$.
Output $$$n$$$ lines with $$$m$$$ numbers each. The $$$j$$$-th number in the $$$i$$$-th line, $$$answer_{ij}$$$, should be the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps.
If you cannot go back to vertex $$$(i, j)$$$ after exactly $$$k$$$ steps, $$$answer_{ij}$$$ should be $$$-1$$$. 
","input
In the first example, the answer is always $$$10$$$ no matter how you walk.
output
In the second example, $$$answer_{21} = 10$$$, the path is $$$(2,1) \to (1,1) \to (1,2) \to (2,2) \to (2,1)$$$, the boredness is $$$4 + 1 + 2 + 3 = 10$$$.
","dp, graphs, shortestpaths",6
"n, k = map(int, input().split())
a = list(map(int, input().split()))
j = 0
a.sort()
n1 = n
for i in range(n):
    while a[j] < a[i]:
        if a[i] <= a[j] + k:
            n1 -= 1
        j += 1
print(n1)
",0990_B,CODEFORCES,2622,Micro-World,"You have a Petri dish with bacteria and you are preparing to dive into the harsh micro-world. But, unfortunately, you don't have any microscope nearby, so you can't watch them.
You know that you have $$$n$$$ bacteria in the Petri dish and size of the $$$i$$$-th bacteria is $$$a_i$$$. Also you know intergalactic positive integer constant $$$K$$$.
The $$$i$$$-th bacteria can swallow the $$$j$$$-th bacteria if and only if $$$a_i > a_j$$$ and $$$a_i \le a_j + K$$$. The $$$j$$$-th bacteria disappear, but the $$$i$$$-th bacteria doesn't change its size. The bacteria can perform multiple swallows. On each swallow operation any bacteria $$$i$$$ can swallow any bacteria $$$j$$$ if $$$a_i > a_j$$$ and $$$a_i \le a_j + K$$$. The swallow operations go one after another.
For example, the sequence of bacteria sizes $$$a=[101, 53, 42, 102, 101, 55, 54]$$$ and $$$K=1$$$. The one of possible sequences of swallows is: $$$[101, 53, 42, 102, \underline{101}, 55, 54]$$$ $$$\to$$$ $$$[101, \underline{53}, 42, 102, 55, 54]$$$ $$$\to$$$ $$$[\underline{101}, 42, 102, 55, 54]$$$ $$$\to$$$ $$$[42, 102, 55, \underline{54}]$$$ $$$\to$$$ $$$[42, 102, 55]$$$. In total there are $$$3$$$ bacteria remained in the Petri dish.
Since you don't have a microscope, you can only guess, what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope.
The first line contains two space separated positive integers $$$n$$$ and $$$K$$$ ($$$1 \le n \le 2 \cdot 10^5$$$, $$$1 \le K \le 10^6$$$) — number of bacteria and intergalactic constant $$$K$$$.
The second line contains $$$n$$$ space separated integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^6$$$) — sizes of bacteria you have.
Print the only integer — minimal possible number of bacteria can remain.
The first example is clarified in the problem statement.
","input
In the second example an optimal possible sequence of swallows is: $$$[20, 15, 10, 15, \underline{20}, 25]$$$ $$$\to$$$ $$$[20, 15, 10, \underline{15}, 25]$$$ $$$\to$$$ $$$[20, 15, \underline{10}, 25]$$$ $$$\to$$$ $$$[20, \underline{15}, 25]$$$ $$$\to$$$ $$$[\underline{20}, 25]$$$ $$$\to$$$ $$$[25]$$$.
output
In the third example no bacteria can swallow any other bacteria.
","greedy, sortings",4
"n = int(input())
ans = 0
mod = 998244353
a = list(map(int, input().split()))
p = 1 / 2

for i in range(n):
    ans = (ans + (i + 2) * (p * a[n - i - 1] % mod) % mod) % mod
    p = (2 * p) % mod

print(int(ans) % mod)",1009_E,CODEFORCES,1810,Intercity Travelling,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.
The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.
Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.
Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.
For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.
Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.
Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$.
The first line contains one number $$$n$$$ ($$$1 \le n \le 10^6$$$) — the distance from Moscow to Saratov.
","input
The second line contains $$$n$$$ integer numbers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$$$), where $$$a_i$$$ is the difficulty of $$$i$$$-th kilometer after Leha has rested.
output
Print one number — $$$p \cdot 2^{n - 1}$$$, taken modulo $$$998244353$$$.
","combinatorics, math, probabilities",3
"from random import randint

mod = 10**9 + 7
d = {}
n, m, l = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
def go(i, j, k):
    val = i * 40401 + j * 201 + k
    ret = 0
    if val in d:
        return d[val]
    elif i < n and j < m and k < l:
        ret = max(a[i] * b[j] + go(i + 1, j + 1, k), b[j] * c[k] + go(i, j + 1, k + 1), c[k] * a[i] + go(i + 1, j, k + 1))
    elif i < n and j < m:
        ret = a[i] * b[j] + go(i + 1, j + 1, k)
    elif j < m and k < l:
        ret = b[j] * c[k] + go(i, j + 1, k + 1)
    elif k < l and i < n:
        ret = c[k] * a[i] + go(i + 1, j, k + 1)
    d[val] = ret
    return ret

a.sort(reverse = True)
b.sort(reverse = True)
c.sort(reverse = True)
print(go(0, 0, 0))
",1398_D,CODEFORCES,3914,Colored Rectangles,"You are given three multisets of pairs of colored sticks: 
You are constructing rectangles from these pairs of sticks with the following process: 
Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color.
Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks.
What is the maximum area you can achieve?
The first line contains three integers $$$R$$$, $$$G$$$, $$$B$$$ ($$$1 \le R, G, B \le 200$$$) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks.
The second line contains $$$R$$$ integers $$$r_1, r_2, \dots, r_R$$$ ($$$1 \le r_i \le 2000$$$) — the lengths of sticks in each pair of red sticks.
The third line contains $$$G$$$ integers $$$g_1, g_2, \dots, g_G$$$ ($$$1 \le g_i \le 2000$$$) — the lengths of sticks in each pair of green sticks.
The fourth line contains $$$B$$$ integers $$$b_1, b_2, \dots, b_B$$$ ($$$1 \le b_i \le 2000$$$) — the lengths of sticks in each pair of blue sticks.
Print the maximum possible total area of the constructed rectangles.
In the first example you can construct one of these rectangles: red and green with sides $$$3$$$ and $$$5$$$, red and blue with sides $$$3$$$ and $$$4$$$ and green and blue with sides $$$5$$$ and $$$4$$$. The best area of them is $$$4 \times 5 = 20$$$.
","input
In the second example the best rectangles are: red/blue $$$9 \times 8$$$, red/blue $$$5 \times 5$$$, green/blue $$$2 \times 1$$$. So the total area is $$$72 + 25 + 2 = 99$$$.
output
In the third example the best rectangles are: red/green $$$19 \times 8$$$ and red/blue $$$20 \times 11$$$. The total area is $$$152 + 220 = 372$$$. Note that you can't construct more rectangles because you are not allowed to have both pairs taken to be the same color.
","dp, greedy, sortings",6
"import sys
readline = sys.stdin.readline

N = int(readline())
M = float(readline())
A = list(map(int, readline().split()))
B = list(map(int, readline().split()))
B = B[1:] + [B[0]]
C = []
for a, b in zip(A[::-1], B[::-1]):
    C.append(b)
    C.append(a)

if 1 in C:
    print(-1)
else:
    M0 = M
    for c in C:
        M += M/(c-1)
    
    print(M-M0)",1010_A,CODEFORCES,1820,Fly,"Natasha is going to fly on a rocket to Mars and return to Earth. Also, on the way to Mars, she will land on $$$n - 2$$$ intermediate planets. Formally: we number all the planets from $$$1$$$ to $$$n$$$. $$$1$$$ is Earth, $$$n$$$ is Mars. Natasha will make exactly $$$n$$$ flights: $$$1 \to 2 \to \ldots n \to 1$$$.
Flight from $$$x$$$ to $$$y$$$ consists of two phases: take-off from planet $$$x$$$ and landing to planet $$$y$$$. This way, the overall itinerary of the trip will be: the $$$1$$$-st planet $$$\to$$$ take-off from the $$$1$$$-st planet $$$\to$$$ landing to the $$$2$$$-nd planet $$$\to$$$ $$$2$$$-nd planet $$$\to$$$ take-off from the $$$2$$$-nd planet $$$\to$$$ $$$\ldots$$$ $$$\to$$$ landing to the $$$n$$$-th planet $$$\to$$$ the $$$n$$$-th planet $$$\to$$$ take-off from the $$$n$$$-th planet $$$\to$$$ landing to the $$$1$$$-st planet $$$\to$$$ the $$$1$$$-st planet.
The mass of the rocket together with all the useful cargo (but without fuel) is $$$m$$$ tons. However, Natasha does not know how much fuel to load into the rocket. Unfortunately, fuel can only be loaded on Earth, so if the rocket runs out of fuel on some other planet, Natasha will not be able to return home. Fuel is needed to take-off from each planet and to land to each planet. It is known that $$$1$$$ ton of fuel can lift off $$$a_i$$$ tons of rocket from the $$$i$$$-th planet or to land $$$b_i$$$ tons of rocket onto the $$$i$$$-th planet. 
For example, if the weight of rocket is $$$9$$$ tons, weight of fuel is $$$3$$$ tons and take-off coefficient is $$$8$$$ ($$$a_i = 8$$$), then $$$1.5$$$ tons of fuel will be burnt (since $$$1.5 \cdot 8 = 9 + 3$$$). The new weight of fuel after take-off will be $$$1.5$$$ tons. 
Please note, that it is allowed to burn non-integral amount of fuel during take-off or landing, and the amount of initial fuel can be non-integral as well.
Help Natasha to calculate the minimum mass of fuel to load into the rocket. Note, that the rocket must spend fuel to carry both useful cargo and the fuel itself. However, it doesn't need to carry the fuel which has already been burnt. Assume, that the rocket takes off and lands instantly.
The first line contains a single integer $$$n$$$ ($$$2 \le n \le 1000$$$) — number of planets.
The second line contains the only integer $$$m$$$ ($$$1 \le m \le 1000$$$) — weight of the payload.
The third line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 1000$$$), where $$$a_i$$$ is the number of tons, which can be lifted off by one ton of fuel.
The fourth line contains $$$n$$$ integers $$$b_1, b_2, \ldots, b_n$$$ ($$$1 \le b_i \le 1000$$$), where $$$b_i$$$ is the number of tons, which can be landed by one ton of fuel. 
It is guaranteed, that if Natasha can make a flight, then it takes no more than $$$10^9$$$ tons of fuel.
If Natasha can fly to Mars through $$$(n - 2)$$$ planets and return to Earth, print the minimum mass of fuel (in tons) that Natasha should take. Otherwise, print a single number $$$-1$$$.
It is guaranteed, that if Natasha can make a flight, then it takes no more than $$$10^9$$$ tons of fuel.
The answer will be considered correct if its absolute or relative error doesn't exceed $$$10^{-6}$$$. Formally, let your answer be $$$p$$$, and the jury's answer be $$$q$$$. Your answer is considered correct if $$$\frac{|p - q|}{\max{(1, |q|)}} \le 10^{-6}$$$.
Let's consider the first example.
","input
Initially, the mass of a rocket with fuel is $$$22$$$ tons.
output
In the second case, the rocket will not be able even to take off from Earth.
","binarysearch, math",3
"n=int(input())
a=list(map(int,input().split()))
b=[]
maxi=0
for i in range(n):
    maxi=max(maxi,a[i]+1)
    b.append(maxi)
c=[]
count=b[-1]
for i in range(n-1,-1,-1):
    if count-1>=b[i]:
        count-=1
        c.append(count)
    else:
        c.append(count)
c=c[::-1]
ans=0
for i in range(n):
    ans+=(c[i]-a[i]-1)
print(ans)",0924_C,CODEFORCES,1558,Riverside Curio,"Arkady decides to observe a river for n consecutive days. The river's water level on each day is equal to some real value.
Arkady goes to the riverside each day and makes a mark on the side of the channel at the height of the water level, but if it coincides with a mark made before, no new mark is created. The water does not wash the marks away. Arkady writes down the number of marks strictly above the water level each day, on the i-th day this value is equal to mi.
Define di as the number of marks strictly under the water level on the i-th day. You are to find out the minimum possible sum of di over all days. There are no marks on the channel before the first day.
The first line contains a single positive integer n (1 ≤ n ≤ 105) — the number of days.
The second line contains n space-separated integers m1, m2, ..., mn (0 ≤ mi < i) — the number of marks strictly above the water on each day.
Output one single integer — the minimum possible sum of the number of marks strictly below the water level among all days.
In the first example, the following figure shows an optimal case.
","input
Note that on day 3, a new mark should be created because if not, there cannot be 3 marks above water on day 4. The total number of marks underwater is 0 + 0 + 2 + 0 + 3 + 1 = 6.
output
In the second example, the following figure shows an optimal case.
","datastructures, dp, greedy",3
