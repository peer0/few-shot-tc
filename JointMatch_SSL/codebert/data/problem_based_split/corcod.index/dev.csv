content,label,from,problem,index
"import java.util.HashSet;
import java.util.Scanner;


public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0; i<n; i++){
            int a = sc.nextInt();
            if(a!=0){
                set.add(a);
            }
        }
        System.out.println(set.size());
    }
}",3,CorCod,1,1
"
class
Main 
{ 

/* Function to get index of ceiling 

of x in arr[low..high] */

static
int
ceilSearch(
int
arr[], 
int
low, 
int
high, 
int
x) 

{ 

int
i; 


/* If x is smaller than or equal to first 

element,then return the first element */

if
(x <= arr[low]) 

return
low; 


/* Otherwise, linearly search for ceil value */

for
(i = low; i < high; i++) 

{ 

if
(arr[i] == x) 

return
i; 


/* if x lies between arr[i] and arr[i+1] 

including arr[i+1], then return arr[i+1] */

if
(arr[i] < x && arr[i+
1
] >= x) 

return
i+
1
; 

} 


/* If we reach here then x is greater than the 

last element of the array, return -1 in this case */

return
-
1
; 

} 



/* Driver program to check above functions */

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
2
, 
8
, 
10
, 
10
, 
12
, 
19
}; 

int
n = arr.length; 

int
x = 
3
; 

int
index = ceilSearch(arr, 
0
, n-
1
, x); 

if
(index == -
1
) 

System.out.println(
""Ceiling of ""
+x+
"" doesn't exist in array""
); 

else

System.out.println(
""ceiling of ""
+x+
"" is ""
+arr[index]); 

} 
} ",3,CorCod,18,18
"
// Java code to find maximum triplet sum 
import
java.io.*; 
import
java.util.*; 


class
GFG { 


// This function assumes that there 

// are at least three elements in arr[]. 

static
int
maxTripletSum(
int
arr[], 
int
n) 

{ 

// Initialize Maximum, second maximum and third 

// maximum element 

int
maxA = -
100000000
, maxB = -
100000000
; 

int
maxC = -
100000000
; 


for
(
int
i = 
0
; i < n; i++) { 


// Update Maximum, second maximum 

// and third maximum element 

if
(arr[i] > maxA) 

{ 

maxC = maxB; 

maxB = maxA; 

maxA = arr[i]; 

} 


// Update second maximum and third maximum 

// element 

else
if
(arr[i] > maxB) 

{ 

maxC = maxB; 

maxB = arr[i]; 

} 


// Update third maximum element 

else
if
(arr[i] > maxC) 

maxC = arr[i]; 

} 


return
(maxA + maxB + maxC); 

} 


// Driven code 

public
static
void
main(String args[]) 

{ 

int
arr[] = { 
1
, 
0
, 
8
, 
6
, 
4
, 
2
}; 

int
n = arr.length; 

System.out.println(maxTripletSum(arr, n)); 

} 
} 


// This code is contributed by Nikita Tiwari. ",3,CorCod,24,24
"
// Java program to find number of operations 
// to make an array palindrome 

class
GFG 
{ 

// Returns minimum number of count operations 

// required to make arr[] palindrome 

static
int
findMinOps(
int
[] arr, 
int
n) 

{ 

int
ans = 
0
; 
// Initialize result 


// Start from two corners 

for
(
int
i=
0
,j=n-
1
; i<=j;) 

{ 

// If corner elements are same, 

// problem reduces arr[i+1..j-1] 

if
(arr[i] == arr[j]) 

{ 

i++; 

j--; 

} 


// If left element is greater, then 

// we merge right two elements 

else
if
(arr[i] > arr[j]) 

{ 

// need to merge from tail. 

j--; 

arr[j] += arr[j+
1
] ; 

ans++; 

} 


// Else we merge left two elements 

else

{ 

i++; 

arr[i] += arr[i-
1
]; 

ans++; 

} 

} 


return
ans; 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

int
arr[] = 
new
int
[]{
1
, 
4
, 
5
, 
9
, 
1
} ; 

System.out.println(
""Count of minimum operations is ""
+ 

findMinOps(arr, arr.length)); 


} 
} ",3,CorCod,27,27
"import java.util.*;

//201920181

public class Polycarp{

	public static void main(String args[]){
		Scanner s = new Scanner(System.in);
        int rem[] = new int[3];
		
		Arrays.fill(rem,-1);
		rem[0] = 0;
        char ch[] = s.next().toCharArray();
		int n = ch.length;
 		long dp[] = new long[n];

        int sum = 0;
		
        for(int i=0;i<ch.length;i++){
		   sum = sum + (ch[i]-48);
		   if(rem[sum%3] != -1)
			    if(i>0){
					dp[i] = Math.max(dp[i-1],dp[rem[sum%3]]+1);}
				else
					dp[i] = 1;
	       else
			   if(i>0)
				   dp[i] = dp[i-1];
			   
		   
		   rem[sum%3] = i;
		   sum = sum%3;
		   
		}		
		 

            System.out.println(dp[n-1]);			
		
		
	}
}
",3,CorCod,37,37
"
// Java program to check if two binary tree are cousins 
class
Node 
{ 

int
data; 

Node left, right; 


Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root; 


// Recursive function to check if two Nodes are 

// siblings 

boolean
isSibling(Node node, Node a, Node b) 

{ 

// Base case 

if
(node == 
null
) 

return
false
; 


return
((node.left == a && node.right == b) || 

(node.left == b && node.right == a) || 

isSibling(node.left, a, b) || 

isSibling(node.right, a, b)); 

} 


// Recursive function to find level of Node 'ptr' in 

// a binary tree 

int
level(Node node, Node ptr, 
int
lev) 

{ 

// base cases 

if
(node == 
null
) 

return
0
; 


if
(node == ptr) 

return
lev; 


// Return level if Node is present in left subtree 

int
l = level(node.left, ptr, lev + 
1
); 

if
(l != 
0
) 

return
l; 


// Else search in right subtree 

return
level(node.right, ptr, lev + 
1
); 

} 


// Returns 1 if a and b are cousins, otherwise 0 

boolean
isCousin(Node node, Node a, Node b) 

{ 

// 1. The two Nodes should be on the same level 

// in the binary tree. 

// 2. The two Nodes should not be siblings (means 

// that they should not have the same parent 

// Node). 

return
((level(node, a, 
1
) == level(node, b, 
1
)) && 

(!isSibling(node, a, b))); 

} 


//Driver program to test above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
1
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
3
); 

tree.root.left.left = 
new
Node(
4
); 

tree.root.left.right = 
new
Node(
5
); 

tree.root.left.right.right = 
new
Node(
15
); 

tree.root.right.left = 
new
Node(
6
); 

tree.root.right.right = 
new
Node(
7
); 

tree.root.right.left.right = 
new
Node(
8
); 


Node Node1, Node2; 

Node1 = tree.root.left.left; 

Node2 = tree.root.right.right; 

if
(tree.isCousin(tree.root, Node1, Node2)) 

System.out.println(
""Yes""
); 

else

System.out.println(
""No""
); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",3,CorCod,43,43
"import java.io.*;
import java.lang.*;
import java.util.*;
import static java.lang.Integer.*;
import static java.lang.Long.*;
import static java.lang.Math.*;
import static java.lang.System.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main {

    Main() throws IOException {
        String a = nextLine();
        String b = nextLine();
        long ans = 0;
        int s = 0;
        for (int i = 0; i < b.length() - a.length(); ++i) {
            s += b.charAt(i) == '1' ? 1 : 0;
        }

        for (int i = 0; i < a.length(); ++i) {
            s += b.charAt(i + b.length() - a.length()) == '1' ? 1 : 0;
            ans += a.charAt(i) == '1' ? b.length() - a.length() + 1 - s : s;
            s -= b.charAt(i) == '1' ? 1 : 0;
        }
        out.println(ans);
    }


    //////////////////////////////
    PrintWriter out = new PrintWriter(System.out, false);
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer stok = null;
    String nextLine() throws IOException {
        while (stok == null || !stok.hasMoreTokens()) {
            stok = new StringTokenizer(in.readLine());
        }
        return stok.nextToken();
    }


    public static void main(String args[]) throws IOException {
        if (args.length > 0) {
            setIn(new FileInputStream(args[0] + "".inp""));
            setOut(new PrintStream(args[0] + "".out""));
        }
        Main solver = new Main();
        solver.out.flush();  //  could be replace with a method, but nah, this is just competitive programming :p
    }
}
",3,CorCod,45,45
"
// Java program to find maximum average 
// subarray of given length. 
import
java .io.*; 

class
GFG { 


// Returns beginning index 

// of maximum average 

// subarray of length 'k' 

static
int
findMaxAverage(
int
[]arr, 

int
n, 
int
k) 

{ 


// Check if 'k' is valid 

if
(k > n) 

return
-
1
; 


// Create and fill array 

// to store cumulative 

// sum. csum[i] stores 

// sum of arr[0] to arr[i] 

int
[]csum = 
new
int
[n]; 


csum[
0
] = arr[
0
]; 

for
(
int
i = 
1
; i < n; i++) 

csum[i] = csum[i - 
1
] + arr[i]; 


// Initialize max_sm as 

// sum of first subarray 

int
max_sum = csum[k - 
1
], 

max_end = k - 
1
; 


// Find sum of other 

// subarrays and update 

// max_sum if required. 

for
(
int
i = k; i < n; i++) 

{ 

int
curr_sum = csum[i] - 

csum[i - k]; 

if
(curr_sum > max_sum) 

{ 

max_sum = curr_sum; 

max_end = i; 

} 

} 


// To avoid memory leak 

//delete [] csum; 


// Return starting index 

return
max_end - k + 
1
; 

} 


// Driver Code 

static
public
void
main (String[] args) 

{ 

int
[]arr = {
1
, 
12
, -
5
, -
6
, 
50
, 
3
}; 

int
k = 
4
; 

int
n = arr.length; 


System.out.println(
""The maximum ""

+ 
""average subarray of length ""

+ k + 
"" begins at index ""

+ findMaxAverage(arr, n, k)); 

} 
} 

// This code is contributed by anuj_67. ",3,CorCod,49,49
"
// Java program to check if all leaves are at same level 

// A binary tree node 
class
Node 
{ 

int
data; 

Node left, right; 


Node(
int
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
Leaf 
{ 

int
leaflevel=
0
; 
} 

class
BinaryTree 
{ 

Node root; 

Leaf mylevel = 
new
Leaf(); 


/* Recursive function which checks whether all leaves are at same 

level */

boolean
checkUtil(Node node, 
int
level, Leaf leafLevel) 

{ 

// Base case 

if
(node == 
null
) 

return
true
; 


// If a leaf node is encountered 

if
(node.left == 
null
&& node.right == 
null
) 

{ 

// When a leaf node is found first time 

if
(leafLevel.leaflevel == 
0
) 

{ 

// Set first found leaf's level 

leafLevel.leaflevel = level; 

return
true
; 

} 


// If this is not first leaf node, compare its level with 

// first leaf's level 

return
(level == leafLevel.leaflevel); 

} 


// If this node is not leaf, recursively check left and right 

// subtrees 

return
checkUtil(node.left, level + 
1
, leafLevel) 

&& checkUtil(node.right, level + 
1
, leafLevel); 

} 


/* The main function to check if all leafs are at same level. 

It mainly uses checkUtil() */

boolean
check(Node node) 

{ 

int
level = 
0
; 

return
checkUtil(node, level, mylevel); 

} 


public
static
void
main(String args[]) 

{ 

// Let us create the tree as shown in the example 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
12
); 

tree.root.left = 
new
Node(
5
); 

tree.root.left.left = 
new
Node(
3
); 

tree.root.left.right = 
new
Node(
9
); 

tree.root.left.left.left = 
new
Node(
1
); 

tree.root.left.right.left = 
new
Node(
1
); 

if
(tree.check(tree.root)) 

System.out.println(
""Leaves are at same level""
); 

else

System.out.println(
""Leaves are not at same level""
); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",3,CorCod,57,57
"
// Java program to Find the repeating 
// and missing elements 

import
java.io.*; 

class
GFG { 


static
void
printTwoElements(
int
arr[], 
int
size) 

{ 

int
i; 

System.out.print(
""The repeating element is ""
); 


for
(i = 
0
; i < size; i++) { 

int
abs_val = Math.abs(arr[i]); 

if
(arr[abs_val - 
1
] > 
0
) 

arr[abs_val - 
1
] = -arr[abs_val - 
1
]; 

else

System.out.println(abs_val); 

} 


System.out.print(
""And the missing element is ""
); 

for
(i = 
0
; i < size; i++) { 

if
(arr[i] > 
0
) 

System.out.println(i + 
1
); 

} 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
arr[] = { 
7
, 
3
, 
4
, 
5
, 
5
, 
6
, 
2
}; 

int
n = arr.length; 

printTwoElements(arr, n); 

} 
} 

// This code is contributed by Gitanjali ",3,CorCod,71,71
"
// Java program to find n-th node of 
// Postorder Traversal of Binary Tree 
public
class
NthNodePostOrder { 


static
int
flag = 
0
; 


// function to find the N-th node in the postorder 

// traversal of a given binary tree 

public
static
void
NthPostordernode(Node root, 
int
N) 

{ 


if
(root == 
null
) 

return
; 


if
(flag <= N) 

{ 

// left recursion 

NthPostordernode(root.left, N); 

// right recursion 

NthPostordernode(root.right, N); 

flag++; 

// prints the n-th node of preorder traversal 

if
(flag == N) 

System.out.print(root.data); 

} 

} 



public
static
void
main(String args[]) { 

Node root = 
new
Node(
25
); 

root.left = 
new
Node(
20
); 

root.right = 
new
Node(
30
); 

root.left.left = 
new
Node(
18
); 

root.left.right = 
new
Node(
22
); 

root.right.left = 
new
Node(
24
); 

root.right.right = 
new
Node(
32
); 


int
N = 
6
; 


// prints n-th node found 

NthPostordernode(root, N); 

} 
} 

/* A binary tree node structure */
class
Node 
{ 

int
data; 

Node left, right; 

Node(
int
data) 

{ 

this
.data=data; 

} 
}; 
// This code is contributed by Gaurav Tiwari ",3,CorCod,84,84
"import java.util.*;
import java.io.*;
import java.math.*;
public class Solution{
    public static void main(String[] args)throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] a = new int[n];
        for(int i=0;i<n;i++) a[i] = Integer.parseInt(st.nextToken());
        int ind = 0;
        for(int i=0;i<n;i++){
            if(a[i]==n){
                ind = i;
                break;
            }
        }
        boolean ok = true;
        for(int i=ind+1;i<n;i++) if(a[i]>a[i-1]) ok = false;
        for(int i=ind-1;i>=0;i--) if(a[i]>a[i+1]) ok = false;
        if(ok) System.out.println(""YES"");
        else System.out.println(""NO"");
        
    }
}

",3,CorCod,88,88
"/**
 * Created by Baelish on 7/30/2018.
 */

import java.io.*;
import java.util.*;
import static java.lang.Math.*;

public class B {
    public static void main(String[] args)throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int ans = -1;
        int f[] = new int[(int)2e5+50];
        int g[] = new int[(int)2e5+50];

        int n = in.nextInt(), x = in.nextInt();

        int arr[] = new int[n+1];
        for (int i = 1; i <= n && ans == -1; i++) {
            int a = in.nextInt();
            if(f[a] > 0){
                ans = 0; break;
            }
            f[a]++;
            arr[i] = a;
        }

        for (int i = 1; i <= n && ans == -1; i++) {
            int a = arr[i] & x;
            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){
                ans = 1; break;
            }
            
            g[a]++;
        }

        for (int i = 1; i <= n && ans == -1; i++) {
            int a = arr[i] & x;
            if(g[a] > 1){
                ans = 2; break;
            }
            //g[a]++;
        }

        pw.println(ans);



        pw.close();
    }

    static void debug(Object...obj) {
        System.err.println(Arrays.deepToString(obj));
    }

    static class FastReader {
        InputStream is;
        private byte[] inbuf = new byte[1024];
        private int lenbuf = 0, ptrbuf = 0;
        static final int ints[] = new int[128];

        public FastReader(InputStream is){
            for(int i='0';i<='9';i++) ints[i]=i-'0';
            this.is = is;
        }

        public int readByte(){
            if(lenbuf == -1)throw new InputMismatchException();
            if(ptrbuf >= lenbuf){
                ptrbuf = 0;
                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
                if(lenbuf <= 0)return -1;
            }
            return inbuf[ptrbuf++];
        }

        public boolean isSpaceChar(int c) {
            return !(c >= 33 && c <= 126);
        }
        public int skip() {
            int b;
            while((b = readByte()) != -1 && isSpaceChar(b));
            return b;
        }

        public String next(){
            int b = skip();
            StringBuilder sb = new StringBuilder();
            while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public int nextInt(){
            int num = 0, b;
            boolean minus = false;
            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
            if(b == '-'){
                minus = true;
                b = readByte();
            }

            while(true){
                if(b >= '0' && b <= '9'){
                    num = (num<<3) + (num<<1) + ints[b];
                }else{
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }

        public long nextLong() {
            long num = 0;
            int b;
            boolean minus = false;
            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
            if(b == '-'){
                minus = true;
                b = readByte();
            }

            while(true){
                if(b >= '0' && b <= '9'){
                    num = (num<<3) + (num<<1) + ints[b];
                }else{
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
       /* public char nextChar() {
            return (char)skip();
        }*/

        public char[] next(int n){
            char[] buf = new char[n];
            int b = skip(), p = 0;
            while(p < n && !(isSpaceChar(b))){
                buf[p++] = (char)b;
                b = readByte();
            }
            return n == p ? buf : Arrays.copyOf(buf, p);
        }

        /*private char buff[] = new char[1005];
        public char[] nextCharArray(){
            int b = skip(), p = 0;
            while(!(isSpaceChar(b))){
                buff[p++] = (char)b;
                b = readByte();
            }
            return Arrays.copyOf(buff, p);
        }*/
    }
}",3,CorCod,116,116
"import static java.lang.Integer.parseInt;
import static java.lang.Long.parseLong;
import static java.lang.Math.min;
import static java.lang.System.exit;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class F {

	static void solve() throws Exception {
		int n = scanInt();
		long l[] = new long[n];
		for (int i = 0; i < n; i++) {
			l[i] = scanLong();
		}
		long e1 = 0, e2 = 0, ans = 0;
		boolean water = false;
		String types = scanString();
		for (int i = 0; i < n; i++) {
			long li = l[i], cur;
			switch (types.charAt(i)) {
			case 'G':
				cur = min(e1, li);
				e1 -= cur;
				li -= cur;
				e2 += 2 * cur;
				ans += 2 * cur;
				e2 += li;
				ans += 3 * li;
				break;
			case 'W':
				water = true;
				e1 += li;
				ans += 2 * li;
				break;
			case 'L':
				cur = min(e1, li);
				e1 -= cur;
				li -= cur;
				ans += 2 * cur;
				cur = min(e2, li);
				e2 -= cur;
				li -= cur;
				ans += 3 * cur;
				ans += (water ? 4 : 6) * li;
				break;
			default:
				throw new AssertionError();
			}
		}
		out.print(ans);
	}

	static int scanInt() throws IOException {
		return parseInt(scanString());
	}

	static long scanLong() throws IOException {
		return parseLong(scanString());
	}

	static String scanString() throws IOException {
		while (tok == null || !tok.hasMoreTokens()) {
			tok = new StringTokenizer(in.readLine());
		}
		return tok.nextToken();
	}

	static BufferedReader in;
	static PrintWriter out;
	static StringTokenizer tok;

	public static void main(String[] args) {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			solve();
			in.close();
			out.close();
		} catch (Throwable e) {
			e.printStackTrace();
			exit(1);
		}
	}
}",3,CorCod,123,123
"
// Java program to see if two trees 
// are mirror of each other 

// A binary tree node 
class
Node 
{ 

int
data; 

Node left, right; 


public
Node(
int
data) 

{ 

this
.data = data; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node a, b; 


/* Given two trees, return true if they are 

mirror of each other */

boolean
areMirror(Node a, Node b) 

{ 

/* Base case : Both empty */

if
(a == 
null
&& b == 
null
) 

return
true
; 


// If only one is empty 

if
(a == 
null
|| b == 
null
) 

return
false
; 


/* Both non-empty, compare them recursively 

Note that in recursive calls, we pass left 

of one tree and right of other tree */

return
a.data == b.data 

&& areMirror(a.left, b.right) 

&& areMirror(a.right, b.left); 

} 


// Driver code to test above methods 

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

Node a = 
new
Node(
1
); 

Node b = 
new
Node(
1
); 

a.left = 
new
Node(
2
); 

a.right = 
new
Node(
3
); 

a.left.left = 
new
Node(
4
); 

a.left.right = 
new
Node(
5
); 


b.left = 
new
Node(
3
); 

b.right = 
new
Node(
2
); 

b.right.left = 
new
Node(
5
); 

b.right.right = 
new
Node(
4
); 


if
(tree.areMirror(a, b) == 
true
) 

System.out.println(
""Yes""
); 

else

System.out.println(
""No""
); 


} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",3,CorCod,133,133
"
import
java.io.*; 

class
PairSum { 


// Fills element in arr[] from its pair sum array pair[]. 

// n is size of arr[] 

static
void
constructArr(
int
arr[], 
int
pair[], 
int
n) 

{ 

arr[
0
] = (pair[
0
]+pair[
1
]-pair[n-
1
]) / 
2
; 

for
(
int
i=
1
; i<n; i++) 

arr[i] = pair[i-
1
]-arr[
0
]; 

} 


// Driver program to test above function 

public
static
void
main(String[] args) 

{ 

int
pair[] = {
15
, 
13
, 
11
, 
10
, 
12
, 
10
, 
9
, 
8
, 
7
, 
5
}; 

int
n = 
5
; 

int
[] arr = 
new
int
[n]; 

constructArr(arr, pair, n); 

for
(
int
i = 
0
; i < n; i++) 

System.out.print(arr[i]+
"" ""
); 

} 
} 
/* This code is contributed by Devesh Agrawal */",3,CorCod,140,140
" import java.io.*;
import java.util.*;
import java.lang.*;
import java.awt.*;
import java.awt.geom.*;
import java.math.*;
import java.text.*;
import java.math.BigInteger.*;
import java.util.Arrays; 

public class   CF111111
{
  BufferedReader in;
  StringTokenizer as;
  int nums[],nums2[];
  int[] nums1[];
  boolean con = true;
 
  ArrayList < Integer >  ar = new ArrayList < Integer >();
  ArrayList < Integer >  fi = new ArrayList < Integer >();
  Map<Integer,Integer > map = new HashMap<Integer, Integer>();
  public static void main (String[] args)
  {
    new CF111111  ();
  }
  
  public int GCD(int a, int b) {
    if (b==0) return a;
    return GCD(b,a%b);
  }
  
  public int LIS(int arr[])
  {
    int n = arr.length;
    int sun[] = new int [n];
    int cur = 0;
    for(int x = 0;x<n;x++)
    {
      int temp = Arrays.binarySearch(sun,0,cur,arr[x]);
      if(temp < 0)
        temp = -temp -1;
      sun[temp] = arr[x];
      if(temp == cur)
        cur++;
    }
    return cur;
    
  }
  
  
  
  
  public CF111111  ()
  {
    try
    {
      
      in = new BufferedReader (new InputStreamReader (System.in));
      int a = nextInt();
      for(int xx1 = 0;xx1<a;xx1++)
      {
        int b = nextInt();
        nums = new int [b];
        for(int x = 0;x<b;x++)
        {
          nums[x] = nextInt();
        }
         int max = 0;
         int max2 = -1;
         for(int x = 0;x<b;x++)
         {
           if(nums[x] >= max)
           {
             max2 = max;
             max = nums[x];
           }
           else if(nums[x] >= max2)
             max2 = nums[x];
         }
        System.out.println(Math.min(max2, b-1)-1);
      }
    }
    catch(IOException e)
    {

    }
  }
  
  
  
  
  
  
  
  String next () throws IOException
  {
    while (as == null || !as.hasMoreTokens ())
    {
      as = new StringTokenizer (in.readLine ().trim ());
    }
    
    
    return as.nextToken ();
  }
  
  
  
  long nextLong () throws IOException
  {
    return Long.parseLong (next ());
  }
  
  
  int nextInt () throws IOException
  {
    return Integer.parseInt (next ());
  }
  
  
  double nextDouble () throws IOException
  {
    return Double.parseDouble (next ());
  }
  
  
  String nextLine () throws IOException
  {
    return in.readLine ().trim ();
  }
}",3,CorCod,143,143
"
/* Java program to find first repeating element in arr[] */
import
java.util.*; 

class
Main 
{ 

// This function prints the first repeating element in arr[] 

static
void
printFirstRepeating(
int
arr[]) 

{ 

// Initialize index of first repeating element 

int
min = -
1
; 


// Creates an empty hashset 

HashSet<Integer> set = 
new
HashSet<>(); 


// Traverse the input array from right to left 

for
(
int
i=arr.length-
1
; i>=
0
; i--) 

{ 

// If element is already in hash set, update min 

if
(set.contains(arr[i])) 

min = i; 


else
// Else add element to hash set 

set.add(arr[i]); 

} 


// Print the result 

if
(min != -
1
) 

System.out.println(
""The first repeating element is ""
+ arr[min]); 

else

System.out.println(
""There are no repeating elements""
); 

} 


// Driver method to test above method 

public
static
void
main (String[] args) 
throws
java.lang.Exception 

{ 

int
arr[] = {
10
, 
5
, 
3
, 
4
, 
3
, 
5
, 
6
}; 

printFirstRepeating(arr); 

} 
} ",3,CorCod,154,154
"/*
Roses are red
Memes are neat
All my test cases time out
Lmao yeet
*/
import java.util.*;
import java.io.*;

   public class A
   {
      public static void main(String args[]) throws Exception
      {
         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in)); 
         StringTokenizer st = new StringTokenizer(infile.readLine());
         int N = Integer.parseInt(st.nextToken());
         int L = Integer.parseInt(st.nextToken());
         int A = Integer.parseInt(st.nextToken());
         int[] arr1 = new int[N];
         int[] arr2 = new int[N];
         for(int i=0; i < N; i++)
         {
            st = new StringTokenizer(infile.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken())+x;
            arr1[i] = x;
            arr2[i] = y;
         }
         int res = 0;
         for(int i=1; i < N; i++)
            res += (arr1[i]-arr2[i-1])/A;
         if(N > 0)
            res += (L-arr2[N-1])/A+arr1[0]/A;
         else
            res += L/A;
         System.out.println(res);
      }
   }",3,CorCod,204,204
"
// Java program to remove duplicates, the order of 
// characters is not maintained in this program 

public
class
GFG 
{ 

static
final
int
NO_OF_CHARS = 
256
; 


/* Returns an array of size 256 containg count 

of characters in the passed char array */

static
int
[] getCharCountArray(String str) 

{ 

int
count[] = 
new
int
[NO_OF_CHARS]; 

for
(
int
i = 
0
; i<str.length(); i++) 

count[str.charAt(i)]++; 


return
count; 

} 


/* removeDirtyChars takes two string as arguments: First 

string (str) is the one from where function removes dirty 

characters. Second string is the string which contain all 

dirty characters which need to be removed from first string */

static
String removeDirtyChars(String str, String mask_str) 

{ 

int
count[] = getCharCountArray(mask_str); 

int
ip_ind = 
0
, res_ind = 
0
; 


char
arr[] = str.toCharArray(); 


while
(ip_ind != arr.length) 

{ 

char
temp = arr[ip_ind]; 

if
(count[temp] == 
0
) 

{ 

arr[res_ind] = arr[ip_ind]; 

res_ind ++; 

} 

ip_ind++; 


} 


str = 
new
String(arr); 


/* After above step string is ngring. 

Removing extra ""iittg"" after string*/


return
str.substring(
0
, res_ind); 


} 


// Driver Method 

public
static
void
main(String[] args) 

{ 

String str = 
""geeksforgeeks""
; 

String mask_str = 
""mask""
; 

System.out.println(removeDirtyChars(str, mask_str)); 

} 
} ",3,CorCod,206,206
"
// Java program to find maximum product of 
// a subset. 

class
GFG { 


static
int
maxProductSubset(
int
a[], 
int
n) { 

if
(n == 
1
) { 

return
a[
0
]; 

} 


// Find count of negative numbers, count 

// of zeros, maximum valued negative number 

// and product of non-zero numbers 

int
max_neg = Integer.MIN_VALUE; 

int
count_neg = 
0
, count_zero = 
0
; 

int
prod = 
1
; 

for
(
int
i = 
0
; i < n; i++) { 


// If number is 0, we don't 

// multiply it with product. 

if
(a[i] == 
0
) { 

count_zero++; 

continue
; 

} 


// Count negatives and keep 

// track of maximum valued negative. 

if
(a[i] < 
0
) { 

count_neg++; 

max_neg = Math.max(max_neg, a[i]); 

} 


prod = prod * a[i]; 

} 


// If there are all zeros 

if
(count_zero == n) { 

return
0
; 

} 


// If there are odd number of 

// negative numbers 

if
(count_neg % 
2
== 
1
) { 


// Exceptional case: There is only 

// negative and all other are zeros 

if
(count_neg == 
1

&& count_zero > 
0

&& count_zero + count_neg == n) { 

return
0
; 

} 


// Otherwise result is product of 

// all non-zeros divided by maximum 

// valued negative. 

prod = prod / max_neg; 

} 


return
prod; 

} 

// Driver code 

public
static
void
main(String[] args) { 

int
a[] = {-
1
, -
1
, -
2
, 
4
, 
3
}; 

int
n = a.length; 

System.out.println(maxProductSubset(a, n)); 


} 
} 
/* This JAVA code is contributed by Rajput-Ji*/",3,CorCod,216,216
"
// java program to find maximum 
// element 

class
Main 
{ 

// function to find the 

// maximum element 

static
int
findMaximum(
int
arr[], 
int
low, 
int
high) 

{ 

int
max = arr[low]; 

int
i; 

for
(i = low; i <= high; i++) 

{ 

if
(arr[i] > max) 

max = arr[i]; 

} 

return
max; 

} 


// main function 

public
static
void
main (String[] args) 

{ 

int
arr[] = {
1
, 
30
, 
40
, 
50
, 
60
, 
70
, 
23
, 
20
}; 

int
n = arr.length; 

System.out.println(
""The maximum element is ""
+ 

findMaximum(arr, 
0
, n-
1
)); 

} 
} ",3,CorCod,217,217
"import java.util.Scanner;

public class codef8 {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int num = sc.nextInt();
		int beacon[] = new int[1000001];
		int pos[] = new int[num];
		for (int i = 0; i < num; i++) {
			int position = sc.nextInt();
			beacon[position] = sc.nextInt();
			pos[i] = position;
		}
		int dp[] = new int[1000001];
		int max = 1;
		if (beacon[0] != 0)
			dp[0] = 1;
		
		for (int i = 1; i <= 1000000; i++) {
			if (beacon[i] == 0) {
				dp[i] = dp[i-1];
			} 
			else {
				int j = i - beacon[i] - 1;
				if (j < 0) {
					dp[i] = 1;
				}
				else {
					dp[i] = dp[j] + 1;
				}
			}
			max = Math.max(max, dp[i]);
		}		
		System.out.println(num-max);
	}

}
",3,CorCod,238,238
"import java.util.Arrays;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		int[] a = new int[n];
		for (int i = 0; i < a.length; i++) {
			a[i] = sc.nextInt();
		}
		System.out.println(solve(a));

		sc.close();
	}

	static String solve(int[] a) {
		if (a.length == 1 || (a.length == 2 && a[0] == a[1])) {
			return ""-1"";
		}

		int sum = Arrays.stream(a).sum();
		for (int i = 0;; i++) {
			if (a[i] * 2 != sum) {
				return String.format(""1\n%d"", i + 1);
			}
		}
	}
}
",3,CorCod,249,249
"import java.io.*;


public class First {
    StreamTokenizer in;
    PrintWriter out;

    int nextInt() throws IOException {
        in.nextToken();
        return (int)in.nval;
    }

    long nextLong() throws IOException {
        in.nextToken();
        return (long) in.nval;
    }

    String nextString() throws IOException {
        in.nextToken();
        return in.sval;
    }



    void run() throws IOException {
        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(System.out);
        solve();
        out.flush();
    }

    void solve() throws IOException {
        int n = nextInt(), k = nextInt(), sum = 0, count = 0;
        String str = nextString();
        char[] arr = str.toCharArray();
        boolean[] bool = new boolean[26];
        for(char ch: arr){
            bool[((int)ch)-97] = true;
        }
        for(int i = 0; i < 26; i++){
            if(bool[i]){
                sum += i+1;
                count++;
                i += 1;
            }
            if(count == k) break;
        }
        if(count == k) out.println(sum);
        else out.println(-1);
    }

    public static void main(String[] args) throws IOException {
        new First().run();
    }
}",3,CorCod,265,265
"
// Java program to find nth 
// element of Newman-Conway Sequence 
import
java.io.*; 

class
GFG { 


// Recursion to find 

// n-th element 

static
int
sequence(
int
n) 

{ 

if
(n == 
1
|| n == 
2
) 

return
1
; 

else

return
sequence(sequence(n - 
1
)) 

+ sequence(n - sequence(n - 
1
)); 

} 


// Driver Program 

public
static
void
main(String args[]) 

{ 

int
n = 
10
; 

System.out.println(sequence(n)); 

} 
} 

/*This code is contributed by Nikita Tiwari.*/",3,CorCod,268,268
"
// Java implementation to check whether the two 
// binary tress are mirrors of each other or not 
import
java.util.*; 
class
GfG { 

// structure of a node in binary tree 
static
class
Node 
{ 

int
data; 

Node left, right; 
} 

// Utility function to create and return 
// a new node for a binary tree 
static
Node newNode(
int
data) 
{ 

Node temp = 
new
Node(); 

temp.data = data; 

temp.left = 
null
; 

temp.right = 
null
; 

return
temp; 
} 

// function to check whether the two binary trees 
// are mirrors of each other or not 
static
String areMirrors(Node root1, Node root2) 
{ 

Stack<Node> st1 = 
new
Stack<Node> (); 

Stack<Node> st2 = 
new
Stack<Node> (); 

while
(
true
) 

{ 

// iterative inorder traversal of 1st tree and 

// reverse inoder traversal of 2nd tree 

while
(root1 != 
null
&& root2 != 
null
) 

{ 

// if the corresponding nodes in the two traversal 

// have different data values, then they are not 

// mirrors of each other. 

if
(root1.data != root2.data) 

return
""No""
; 


st1.push(root1); 

st2.push(root2); 

root1 = root1.left; 

root2 = root2.right; 

} 


// if at any point one root becomes null and 

// the other root is not null, then they are 

// not mirrors. This condition verifies that 

// structures of tree are mirrors of each other. 

if
(!(root1 == 
null
&& root2 == 
null
)) 

return
""No""
; 


if
(!st1.isEmpty() && !st2.isEmpty()) 

{ 

root1 = st1.peek(); 

root2 = st2.peek(); 

st1.pop(); 

st2.pop(); 


/* we have visited the node and its left subtree. 

Now, it's right subtree's turn */

root1 = root1.right; 


/* we have visited the node and its right subtree. 

Now, it's left subtree's turn */

root2 = root2.left; 

} 


// both the trees have been completely traversed 

else

break
; 

} 


// tress are mirrors of each other 

return
""Yes""
; 
} 

// Driver program to test above 
public
static
void
main(String[] args) 
{ 

// 1st binary tree formation 

Node root1 = newNode(
1
); 
/* 1 */

root1.left = newNode(
3
); 
/* / \ */

root1.right = newNode(
2
); 
/* 3 2 */

root1.right.left = newNode(
5
); 
/* / \ */

root1.right.right = newNode(
4
); 
/* 5 4 */


// 2nd binary tree formation 

Node root2 = newNode(
1
); 
/* 1 */

root2.left = newNode(
2
); 
/* / \ */

root2.right = newNode(
3
); 
/* 2 3 */

root2.left.left = newNode(
4
); 
/* / \ */

root2.left.right = newNode(
5
); 
/* 4 5 */


System.out.println(areMirrors(root1, root2)); 
} 
} ",3,CorCod,275,275
"
// Java implementation to replace each node 
// in binary tree with the sum of its inorder 
// predecessor and successor 
import
java.util.*; 
class
Solution 
{ 

// node of a binary tree 
static
class
Node { 

int
data; 

Node left, right; 
} 

//INT class 
static
class
INT 
{ 

int
data; 
} 

// function to get a new node of a binary tree 
static
Node getNode(
int
data) 
{ 

// allocate node 

Node new_node =
new
Node(); 


// put in the data; 

new_node.data = data; 

new_node.left = new_node.right = 
null
; 


return
new_node; 
} 

// function to store the inorder traversal 
// of the binary tree in 'arr' 
static
void
storeInorderTraversal( Node root, 

Vector<Integer> arr) 
{ 

// if root is null 

if
(root==
null
) 

return
; 


// first recur on left child 

storeInorderTraversal(root.left, arr); 


// then store the root's data in 'arr' 

arr.add(root.data); 


// now recur on right child 

storeInorderTraversal(root.right, arr); 
} 

// function to replace each node with the sum of its 
// inorder predecessor and successor 
static
void
replaceNodeWithSum( Node root, 

Vector<Integer> arr, INT i) 
{ 

// if root is null 

if
(root==
null
) 

return
; 


// first recur on left child 

replaceNodeWithSum(root.left, arr, i); 


// replace node's data with the sum of its 

// inorder predecessor and successor 

root.data = arr.get(i.data - 
1
) + arr.get(i.data + 
1
); 


// move 'i' to point to the next 'arr' element 

i.data++; 


// now recur on right child 

replaceNodeWithSum(root.right, arr, i); 
} 

// Utility function to replace each node in binary 
// tree with the sum of its inorder predecessor 
// and successor 
static
void
replaceNodeWithSumUtil( Node root) 
{ 

// if tree is empty 

if
(root==
null
) 

return
; 


Vector<Integer> arr= 
new
Vector<Integer>(); 


// store the value of inorder predecessor 

// for the leftmost leaf 

arr.add(
0
); 


// store the inoder traversal of the tree in 'arr' 

storeInorderTraversal(root, arr); 


// store the value of inorder successor 

// for the rightmost leaf 

arr.add(
0
); 


// replace each node with the required sum 

INT i = 
new
INT(); 


i.data=
1
; 


replaceNodeWithSum(root, arr, i); 
} 

// function to print the preorder traversal 
// of a binary tree 
static
void
preorderTraversal( Node root) 
{ 

// if root is null 

if
(root==
null
) 

return
; 


// first print the data of node 

System.out.print( root.data + 
"" ""
); 


// then recur on left subtree 

preorderTraversal(root.left); 


// now recur on right subtree 

preorderTraversal(root.right); 
} 

// Driver program to test above 
public
static
void
main(String args[]) 
{ 

// binary tree formation 

Node root = getNode(
1
); 
// 1 

root.left = getNode(
2
); 
// / \ 

root.right = getNode(
3
); 
// 2 3 

root.left.left = getNode(
4
); 
// / \ / \ 

root.left.right = getNode(
5
); 
// 4 5 6 7 

root.right.left = getNode(
6
); 

root.right.right = getNode(
7
); 


System.out.println( 
""Preorder Traversal before tree modification:""
); 

preorderTraversal(root); 


replaceNodeWithSumUtil(root); 


System.out.println(
""\nPreorder Traversal after tree modification:""
); 

preorderTraversal(root); 

} 
} 
//contributed by Arnab Kundu ",3,CorCod,285,285
"import java.util.*;
import java.io.*;
import java.math.*;
import java.util.HashMap;

public class Main
{
    static class Reader 
    { 
        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} 
        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} 
        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} 
        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} 
        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} 
        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} 
        public double d() throws IOException {return Double.parseDouble(s()) ;}
        public boolean isSpaceChar(int c) { return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; } 
        public boolean isEndOfLine(int c) { return c == '\n' || c == '\r' || c == -1; } 
    } 
    
    
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    public static void main(String args[])
    {
        Reader sc=new Reader();
        PrintWriter out=new PrintWriter(System.out);
        int n=sc.i();
        String s1=sc.s();
        String s2=sc.s();
        int pos1=-1;
        int pos2=-1;
        int arr[][][]=new int[100][100][2];
        for(int i=0;i<n;i++)
        {
            if(s1.charAt(i)!=s2.charAt(i))
            {
                if(arr[s2.charAt(i)-97][s1.charAt(i)-97][0]==1)
                {
                    pos2=i;
                    pos1=arr[s2.charAt(i)-97][s1.charAt(i)-97][1];
                    break;
                }
                arr[s1.charAt(i)-97][s2.charAt(i)-97][0]=1;
                arr[s1.charAt(i)-97][s2.charAt(i)-97][1]=i;
            }
        }
        int ham=0;
        for(int i=0;i<n;i++)
        {
            if(s1.charAt(i)!=s2.charAt(i))
            ham++;
        }
        if(pos1!=-1&&pos2!=-1)
        {
            System.out.println(ham-2);
            System.out.println(pos1+1+"" ""+(pos2+1));
            System.exit(0);
        }
        
        int arr1[][]=new int[100][2];
        int arr2[][]=new int[100][2];
        for(int i=0;i<n;i++)
        {
            if(s1.charAt(i)!=s2.charAt(i))
            {
                if(arr1[s1.charAt(i)-97][0]==1)
                {
                    pos2=i;
                    pos1=arr1[s1.charAt(i)-97][1];
                    break;
                }
                if(arr2[s2.charAt(i)-97][0]==1)
                {
                    pos2=i;
                    pos1=arr2[s2.charAt(i)-97][1];
                    break;
                }
                arr1[s2.charAt(i)-97][0]=1;
                arr1[s2.charAt(i)-97][1]=i;
                arr2[s1.charAt(i)-97][0]=1;
                arr2[s1.charAt(i)-97][1]=i;
            }
        }
        if(pos1!=-1&&pos2!=-1)
        {
            System.out.println(ham-1);
            System.out.println(pos1+1+"" ""+(pos2+1));
            System.exit(0);
        }
        System.out.println(ham);
        System.out.println(pos1+"" ""+pos2);
    }
}",3,CorCod,289,289
" import java.io.*;
import java.util.*;
import java.lang.*;
import java.awt.*;
import java.awt.geom.*;
import java.math.*;
import java.text.*;
import java.math.BigInteger.*;
import java.util.Arrays; 

public class   CF111111
{
  BufferedReader in;
  StringTokenizer as;
  int nums[],nums2[];
  int[] nums1[];
  boolean con = true;
 
  ArrayList < Integer >  ar = new ArrayList < Integer >();
  ArrayList < Integer >  fi = new ArrayList < Integer >();
  Map<Integer,Integer > map = new HashMap<Integer, Integer>();
  public static void main (String[] args)
  {
    new CF111111  ();
  }
  
  public int GCD(int a, int b) {
    if (b==0) return a;
    return GCD(b,a%b);
  }
  
  public int LIS(int arr[])
  {
    int n = arr.length;
    int sun[] = new int [n];
    int cur = 0;
    for(int x = 0;x<n;x++)
    {
      int temp = Arrays.binarySearch(sun,0,cur,arr[x]);
      if(temp < 0)
        temp = -temp -1;
      sun[temp] = arr[x];
      if(temp == cur)
        cur++;
    }
    return cur;
    
  }
  
  
  public void no()
  {
    System.out.println(""NO"");
    System.exit(0);
  }
  
  public CF111111  ()
  {
    try
    {
      
      in = new BufferedReader (new InputStreamReader (System.in));
      int a = nextInt();
      nums = new int [a];
      int max = -1;
      int index = -1;
     for(int x = 0;x<a;x++)
     {
       nums[x] = nextInt();
       if(nums[x] > max)
       {
         max = nums[x];
         index = x;
       }
     }
      int lindex = index-1;
      int rindex = index+1;
      int done = 1;
      int top = max;
      for(;;)
      {
        done++;
      //  System.out.println(done + "" "" + lindex + "" "" + rindex);
        if(lindex < 0)
        {
           if(nums[rindex] > top)
           {
             no();
           }
           else
             top = nums[rindex];
           rindex++;
        }
        else if(rindex >= a)
        {
          if(nums[lindex] > top)
            no();
          else
            top = nums[lindex];
          lindex--;
        }
        else
        {
          if(nums[lindex] > top || nums[rindex] > top)
            no();
          else
          {
            if(nums[lindex] > nums[rindex])
            {
              top = nums[lindex];
              lindex--;
            }
            else
            {
              top = nums[rindex];
              rindex++;
            }
          }
        }
        if(done == a)
        {
          System.out.println(""YES"");
          System.exit(0);
        }
      }
    }
    catch(IOException e)
    {

    }
  }
  
  
  
  
  
  
  
  String next () throws IOException
  {
    while (as == null || !as.hasMoreTokens ())
    {
      as = new StringTokenizer (in.readLine ().trim ());
    }
    
    
    return as.nextToken ();
  }
  
  
  
  long nextLong () throws IOException
  {
    return Long.parseLong (next ());
  }
  
  
  int nextInt () throws IOException
  {
    return Integer.parseInt (next ());
  }
  
  
  double nextDouble () throws IOException
  {
    return Double.parseDouble (next ());
  }
  
  
  String nextLine () throws IOException
  {
    return in.readLine ().trim ();
  }
}",3,CorCod,295,295
"import java.util.*;
import java.io.*;
public class Piles {
	static int summation(int arr[]) {
		int k, sum=0;
		for(k=0;k<arr.length;k++) {
			sum = sum + arr[k];
		}
		return sum;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		if(n>=1 && n<=50) {
			int x[] = new int[n];
			int y[] = new int[n];
			
			for(int i=0;i<n;i++) {
				x[i] = sc.nextInt();
			}
			for(int j=0;j<n;j++) {
				y[j] = sc.nextInt();
			}
			int xsum = summation(x);
			int ysum = summation(y);
			if(xsum>=ysum) {
				System.out.println(""Yes"");
			}
			else {
				System.out.println(""No"");
			}
		}
		

	}

}
",3,CorCod,296,296
"import java.util.*;
public class Kello
{
    public static void  main(String args[])
    {
        Scanner sc =new Scanner(System.in);
        int n,q,m,max,inp,k,i;
        long in_q;
        n=sc.nextInt();
        q=sc.nextInt();
        int a[]=new int[n-1];
        int b[]=new int[n-1];
        int c[]=new int[n-1];
        max=sc.nextInt();
        for(i=0;i<n-1;i++)
        {
            inp=sc.nextInt();
            a[i]=max;
            b[i]=inp;
            if(inp>max)
            {
                c[i]=max;
             max=inp;
        }
        else
        c[i]=inp;
    }
   // display(a,b);
        for(i=0;i<q;i++)
        {
            in_q=sc.nextLong();
            if(in_q<n)
            System.out.println(a[(int)in_q-1]+"" ""+b[(int)in_q-1]);
          else   {
          k=(int)(in_q %(n-1))-1;
          if(k==-1)
          k=n-2;
          System.out.println(max+"" ""+c[k]);
            }
        }
    }
    public static void display(int a[],int b[])
    {
        int i;
        for(i=0;i<a.length;i++)
        System.out.println(a[i]+"" ""+b[i]);
}
}

              ",3,CorCod,302,302
"import java.util.*;
import java.io.*;
public class programA {
   	public static void main(String[] args)throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int d = Integer.parseInt(st.nextToken());
		int arr[] = new int[n];
		st = new StringTokenizer(br.readLine());
		for(int i=0;i<n;i++){
			arr[i] = Integer.parseInt(st.nextToken());
		}
		int s= 2;
		for(int i=0;i<n-1;i++){
			long dis = (long)2*d;
			long dis2 = Math.abs(arr[i]-arr[i+1]);
			if(dis2 == dis)s++;
			else if (dis2 > dis)s+=2;
		}
		System.out.println(s);
   		}
}",3,CorCod,303,303
"import java.util.Scanner;

public class Piles {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int[] a = new int[2]; int x = scan.nextInt();
		for(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();
		System.out.println(a[1] <= a[0] ? ""Yes"" : ""No"");

	}

}
",3,CorCod,307,307
"
// O(n) solution for finding smallest subarray with sum 
// greater than x 

class
SmallestSubArraySum 
{ 

// Returns length of smallest subarray with sum greater than x. 

// If there is no subarray with given sum, then returns n+1 

static
int
smallestSubWithSum(
int
arr[], 
int
n, 
int
x) 

{ 

// Initialize current sum and minimum length 

int
curr_sum = 
0
, min_len = n + 
1
; 


// Initialize starting and ending indexes 

int
start = 
0
, end = 
0
; 

while
(end < n) 

{ 

// Keep adding array elements while current sum 

// is smaller than x 

while
(curr_sum <= x && end < n) 

curr_sum += arr[end++]; 


// If current sum becomes greater than x. 

while
(curr_sum > x && start < n) 

{ 

// Update minimum length if needed 

if
(end - start < min_len) 

min_len = end - start; 


// remove starting elements 

curr_sum -= arr[start++]; 

} 

} 

return
min_len; 

} 

// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

int
arr1[] = {
1
, 
4
, 
45
, 
6
, 
10
, 
19
}; 

int
x = 
51
; 

int
n1 = arr1.length; 

int
res1 = smallestSubWithSum(arr1, n1, x); 

if
(res1 == n1+
1
) 

System.out.println(
""Not Possible""
); 

else

System.out.println(res1); 


int
arr2[] = {
1
, 
10
, 
5
, 
2
, 
7
}; 

int
n2 = arr2.length; 

x = 
9
; 

int
res2 = smallestSubWithSum(arr2, n2, x); 

if
(res2 == n2+
1
) 

System.out.println(
""Not Possible""
); 

else

System.out.println(res2); 


int
arr3[] = {
1
, 
11
, 
100
, 
1
, 
0
, 
200
, 
3
, 
2
, 
1
, 
250
}; 

int
n3 = arr3.length; 

x = 
280
; 

int
res3 = smallestSubWithSum(arr3, n3, x); 

if
(res3 == n3+
1
) 

System.out.println(
""Not Possible""
); 

else

System.out.println(res3); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",3,CorCod,308,308
"
// Java implementation of alternate vowel and 
// consonant string 
import
java.util.*; 

class
GFG 
{ 

// 'ch' is vowel or not 
static
boolean
isVowel(
char
ch) 
{ 

if
(ch == 
'a'
|| ch == 
'e'
|| ch == 
'i'
|| 

ch == 
'o'
|| ch ==
'u'
) 

return
true
; 

return
false
; 
} 

// create alternate vowel and consonant string 
// str1[0...l1-1] and str2[start...l2-1] 
static
String createAltStr(String str1, String str2, 

int
start, 
int
l) 
{ 

String finalStr = 
""""
; 


// first adding character of vowel/consonant 

// then adding character of consonant/vowel 

for
(
int
i = 
0
, j = start; j < l; i++, j++) 

finalStr = (finalStr + str1.charAt(i)) + 

str2.charAt(j); 

return
finalStr; 
} 

// function to find the required 
// alternate vowel and consonant string 
static
String findAltStr(String str) 
{ 

int
nv = 
0
, nc = 
0
; 

String vstr = 
""""
, cstr = 
""""
; 

int
l = str.length(); 

for
(
int
i = 
0
; i < l; i++) 

{ 

char
ch = str.charAt(i); 


// count vowels and updaye vowel string 

if
(isVowel(ch)) 

{ 

nv++; 

vstr = vstr + ch; 

} 


// count consonants and update consonant 

// string 

else

{ 

nc++; 

cstr = cstr + ch; 

} 

} 


// no such string can be formed 

if
(Math.abs(nv - nc) >= 
2
) 

return
""no such string""
; 


// remove first character of vowel string 

// then create alternate string with 

// cstr[0...nc-1] and vstr[1...nv-1] 

if
(nv > nc) 

return
(vstr.charAt(
0
) + createAltStr(cstr, vstr, 
1
, nv)); 


// remove first character of consonant string 

// then create alternate string with 

// vstr[0...nv-1] and cstr[1...nc-1] 

if
(nc > nv) 

return
(cstr.charAt(
0
) + createAltStr(vstr, cstr, 
1
, nc)); 


// if both vowel and consonant 

// strings are of equal length 

// start creating string with consonant 

if
(cstr.charAt(
0
) < vstr.charAt(
0
)) 

return
createAltStr(cstr, vstr, 
0
, nv); 


// start creating string with vowel 

return
createAltStr(vstr, cstr, 
0
, nc); 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

String str = 
""geeks""
; 

System.out.println(findAltStr(str)); 
} 
} 

// This code is contributed by 
// Shashank_Sharma ",3,CorCod,323,323
"
// Java program to check fixed point 
// in an array using linear search 

class
Main 
{ 

static
int
linearSearch(
int
arr[], 
int
n) 

{ 

int
i; 

for
(i = 
0
; i < n; i++) 

{ 

if
(arr[i] == i) 

return
i; 

} 


/* If no fixed point present 

then return -1 */

return
-
1
; 

} 

//main function 

public
static
void
main(String args[]) 

{ 

int
arr[] = {-
10
, -
1
, 
0
, 
3
, 
10
, 
11
, 
30
, 
50
, 
100
}; 

int
n = arr.length; 

System.out.println(
""Fixed Point is ""

+ linearSearch(arr, n)); 

} 
} ",3,CorCod,334,334
"
import java.util.*;
import java.io.*;
import java.math.*;
public class loser
{
    static class InputReader {
        public BufferedReader br;
        public StringTokenizer token;
        public InputReader(InputStream stream)
        {
            br=new BufferedReader(new InputStreamReader(stream),32768);
            token=null;
        }

        public String next()
        {
            while(token==null || !token.hasMoreTokens())
            {
                try
                {
                    token=new StringTokenizer(br.readLine());
                }
                catch(IOException e)
                {
                    throw new RuntimeException(e);
                }
            }
            return token.nextToken();
        }

        public int nextInt()
        {
            return Integer.parseInt(next());
        }

        public long nextLong()
        {
            return Long.parseLong(next());
        }
    }
    static class card{
        long a;
        int i;
        public card(long a,int i)
        {
            this.a=a;
            this.i=i;
        }
    }
    static class sort implements Comparator<pair>
    {
        public int compare(pair o1,pair o2)
        {
            if(o1.a!=o2.a)
                return (int)(o1.a-o2.a);
            else
                return (int)(o1.b-o2.b);
        }
    }
    static void shuffle(long a[])
    {
        List<Long> l=new ArrayList<>();
        for(int i=0;i<a.length;i++)
            l.add(a[i]);
        Collections.shuffle(l);
        for(int i=0;i<a.length;i++)
            a[i]=l.get(i);
    }

    /*static long gcd(long a,long b)
    {
    if(b==0)
    return a;
    else
    return gcd(b,a%b);
    }*/
    /*static boolean valid(int i,int j)
    {
    if(i<4 && i>=0 && j<4 && j>=0)
    return true;
    else
    return false;
    }*/
    static class pair{
        int a,b;
        public pair(int a,int b)
        {
            this.a=a;
            this.b=b;
        }
    }
    public  static void main(String[] args) 
    {
        InputReader sc=new InputReader(System.in);
        char c[]=sc.next().toCharArray();
        int l=c.length;
        int a[]=new int[3];
        for(int i=0;i<l;i++)
        {
            a[c[i]-'a']++;
           if(i>0 && c[i]<c[i-1])
           {
               System.out.println(""NO"");
               System.exit(0);
           }
        }
        if(a[0]>0 && a[1]>0 && (a[2]==a[1] || a[2]==a[0]))
        System.out.println(""YES"");
        else
        System.out.println(""NO"");
    }
}",3,CorCod,336,336
"import java.util.Scanner;

public class NickAndArray {
	public static void main(String args[])
	{
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		 int array[]=new int[n];
		 int max=Integer.MAX_VALUE;
		 int index=0;
		 for(int i=0;i<n;i++)
		 {
			 int k=sc.nextInt();
			 array[i]=k;
			 if(array[i]>=0)
			 {
				 array[i]=-array[i]-1;
			 }
			 if(array[i]<max)
			 {
				 max=array[i];
				 index=i;
				 
			 }
		 }
		 if(n%2!=0)
		 {
			 array[index]=-array[index]-1;
		 }
		 for(int i=0;i<n;i++)
		 {
			 System.out.print(array[i]+"" "" );
		 }
	}

}
",3,CorCod,347,347
"
class
MaximumSum 
{ 

/*Function to return max sum such that no two elements 

are adjacent */

int
FindMaxSum(
int
arr[], 
int
n) 

{ 

int
incl = arr[
0
]; 

int
excl = 
0
; 

int
excl_new; 

int
i; 


for
(i = 
1
; i < n; i++) 

{ 

/* current max excluding i */

excl_new = (incl > excl) ? incl : excl; 


/* current max including i */

incl = excl + arr[i]; 

excl = excl_new; 

} 


/* return max of incl and excl */

return
((incl > excl) ? incl : excl); 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

MaximumSum sum = 
new
MaximumSum(); 

int
arr[] = 
new
int
[]{
5
, 
5
, 
10
, 
100
, 
10
, 
5
}; 

System.out.println(sum.FindMaxSum(arr, arr.length)); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",3,CorCod,351,351
"

import java.util.*;
import java.lang.*;
public class CodeForce {
    
    
        public static void main(String[] args) {
            Scanner sc=new Scanner(System.in);
            String s=sc.next();
            String t=sc.next();
            int count=s.length()+t.length();
            for(int i=0;i<Math.min(s.length(), t.length());i++){
                if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;
                else break;
            }
            System.out.println(count);
            
            
            
            
           
            
                
        }    
    }


",3,CorCod,358,358
"
// Java program to find largest pair sum in a given array 

class
Test 
{ 

static
int
arr[] = 
new
int
[]{
12
, 
34
, 
10
, 
6
, 
40
}; 


/* Method to return largest pair sum. Assumes that 

there are at-least two elements in arr[] */

static
int
findLargestSumPair() 

{ 

// Initialize first and second largest element 

int
first, second; 

if
(arr[
0
] > arr[
1
]) 

{ 

first = arr[
0
]; 

second = arr[
1
]; 

} 

else

{ 

first = arr[
1
]; 

second = arr[
0
]; 

} 


// Traverse remaining array and find first and second largest 

// elements in overall array 

for
(
int
i = 
2
; i<arr.length; i ++) 

{ 

/* If current element is greater than first then update both 

first and second */

if
(arr[i] > first) 

{ 

second = first; 

first = arr[i]; 

} 


/* If arr[i] is in between first and second then update second */

else
if
(arr[i] > second && arr[i] != first) 

second = arr[i]; 

} 

return
(first + second); 

} 

// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 


System.out.println(
""Max Pair Sum is ""
+ findLargestSumPair()); 


} 
} ",3,CorCod,359,359
"//package com.krakn.CF.D1159;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n, k;
        n = sc.nextInt();
        k = sc.nextInt();

        int a = (n - k) / 2;

        StringBuilder s = new StringBuilder();

        int i;
        while (s.length() < n) {
            i = 0;
            while (i < a && s.length() < n) {
                s.append(""0"");
                i++;
            }
            if (s.length() < n) s.append(""1"");
        }

        System.out.println(s);
    }
}
",3,CorCod,364,364
"
// Java program to convert BST to binary tree such that sum of 
// all greater keys is added to every key 

class
Node { 


int
data; 

Node left, right; 


Node(
int
d) { 

data = d; 

left = right = 
null
; 

} 
} 

class
Sum { 


int
sum = 
0
; 
} 

class
BinaryTree { 


static
Node root; 

Sum summ = 
new
Sum(); 


// A recursive function that traverses the given BST in reverse inorder and 

// for every key, adds all greater keys to it 

void
addGreaterUtil(Node node, Sum sum_ptr) { 


// Base Case 

if
(node == 
null
) { 

return
; 

} 


// Recur for right subtree first so that sum of all greater 

// nodes is stored at sum_ptr 

addGreaterUtil(node.right, sum_ptr); 


// Update the value at sum_ptr 

sum_ptr.sum = sum_ptr.sum + node.data; 


// Update key of this node 

node.data = sum_ptr.sum; 


// Recur for left subtree so that the updated sum is added 

// to smaller nodes 

addGreaterUtil(node.left, sum_ptr); 

} 


// A wrapper over addGreaterUtil(). It initializes sum and calls 

// addGreaterUtil() to recursivel upodate and use value of sum 

Node addGreater(Node node) { 

addGreaterUtil(node, summ); 

return
node; 

} 


// A utility function to print inorder traversal of Binary Tree 

void
printInorder(Node node) { 

if
(node == 
null
) { 

return
; 

} 

printInorder(node.left); 

System.out.print(node.data + 
"" ""
); 

printInorder(node.right); 

} 


// Driver program to test the above functions 

public
static
void
main(String[] args) { 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
5
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
13
); 


System.out.println(
""Inorder traversal of given tree ""
); 

tree.printInorder(root); 

Node node = tree.addGreater(root); 

System.out.println(
""""
); 

System.out.println(
""Inorder traversal of modified tree ""
); 

tree.printInorder(node); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",3,CorCod,379,379
"/**
 * Created by Baelish on 8/28/2018.
 */

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class F_DSU {
    public static void main(String[] args)throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        n = in.nextInt();
        
        int brr[] = new int[2*n];
        for (int i = 0; i < 2*n; i+= 2) {
            brr[i] = in.nextInt();
            brr[i+1] = in.nextInt();
        }

        arr = shrink(brr);
        int imap[] = new int[2*n];
        for (int i = 0; i < 2*n; i++) {
            imap[arr[i]] = brr[i];
        }

        int idx = binarySearch(arr.length);
        if(idx >= arr.length) pw.println(-1);
        else pw.println(imap[idx]);

        pw.close();
    }
    static int n, arr[];

    static int binarySearch(int H) {
        int lo = 0, hi = H, mid;
        while (lo < hi) {
            mid = (lo + hi) / 2;
            if (check(mid)) hi = mid;
            else lo = mid + 1;
        }
        if(lo > 0 && check(lo-1)) return lo-1;
        return lo;
    }

    static boolean check(int m){
        DSU dsu = new DSU(2*n);
        for (int i = 0; i < n; i++) {
            int u = arr[2*i], v = arr[2*i+1];
            if(u > m) return false;
            if(v > m){
                if(++dsu.cycle[dsu.find(u)] >= 2) return false;
            }
            else{
                if(!dsu.union(u, v)){
                    if(++dsu.cycle[dsu.find(u)] >= 2) return false;
                }
                else{
                    if(dsu.cycle[dsu.find(u)] >= 2) return false;
                }
            }
        }
        return true;
    }

    static class DSU{
        int parent[], cycle[], n;
        DSU(int N){
            n = N;
            parent = new int[N];
            cycle = new int[N];
            for(int i = 0; i < N; i++){
                parent[i] = i;
            }
        }

        DSU(int [] p){
            parent = p; n = p.length;
        }

        int find(int i) {
            int p = parent[i];
            if (i == p) return i;
            return parent[i] = find(p);
        }

        boolean equiv(int u, int v){
            return find(u) == find(v);
        }

        boolean union(int u, int v){
            u = find(u); v = find(v);
            if(u != v) {
                parent[u] = parent[v];
                cycle[v] += cycle[u];
            }
            return u != v;
        }

        int count(){
            int cnt = 0;
            for(int i = 0; i < n; i++){
                if(i == find(i)) cnt++;
            }
            return cnt;
        }
    }

    public static int[] shrink(int[] a) {
        int n = a.length;
        long[] b = new long[n];
        for(int i = 0;i < n;i++)b[i] = (long)a[i]<<32|i;
        Arrays.sort(b);
        int[] ret = new int[n];
        int p = 0;
        for(int i = 0;i < n;i++) {
            if(i>0 && (b[i]^b[i-1])>>32!=0)p++;
            ret[(int)b[i]] = p;
        }
        return ret;
    }

    static void debug(Object...obj) {
        System.err.println(Arrays.deepToString(obj));
    }

    static class FastReader {
        InputStream is;
        private byte[] inbuf = new byte[1024];
        private int lenbuf = 0, ptrbuf = 0;
        static final int ints[] = new int[128];

        public FastReader(InputStream is){
            for(int i='0';i<='9';i++) ints[i]=i-'0';
            this.is = is;
        }

        public int readByte(){
            if(lenbuf == -1)throw new InputMismatchException();
            if(ptrbuf >= lenbuf){
                ptrbuf = 0;
                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
                if(lenbuf <= 0)return -1;
            }
            return inbuf[ptrbuf++];
        }

        public boolean isSpaceChar(int c) {
            return !(c >= 33 && c <= 126);
        }
        public int skip() {
            int b;
            while((b = readByte()) != -1 && isSpaceChar(b));
            return b;
        }

        public String next(){
            int b = skip();
            StringBuilder sb = new StringBuilder();
            while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public int nextInt(){
            int num = 0, b;
            boolean minus = false;
            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
            if(b == '-'){
                minus = true;
                b = readByte();
            }

            while(true){
                if(b >= '0' && b <= '9'){
                    num = (num<<3) + (num<<1) + ints[b];
                }else{
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }

        public long nextLong() {
            long num = 0;
            int b;
            boolean minus = false;
            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
            if(b == '-'){
                minus = true;
                b = readByte();
            }

            while(true){
                if(b >= '0' && b <= '9'){
                    num = (num<<3) + (num<<1) + ints[b];
                }else{
                    return minus ? -num : num;
                }
                b = readByte();
            }
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
       /* public char nextChar() {
            return (char)skip();
        }*/

        public char[] next(int n){
            char[] buf = new char[n];
            int b = skip(), p = 0;
            while(p < n && !(isSpaceChar(b))){
                buf[p++] = (char)b;
                b = readByte();
            }
            return n == p ? buf : Arrays.copyOf(buf, p);
        }

        /*private char buff[] = new char[1005];
        public char[] nextCharArray(){
            int b = skip(), p = 0;
            while(!(isSpaceChar(b))){
                buff[p++] = (char)b;
                b = readByte();
            }
            return Arrays.copyOf(buff, p);
        }*/
    }
}",5,CorCod,395,395
"import java.util.*;
import java.io.*;

public class CodeForces
{
	public static void main(String[] args)throws IOException
	{
		Scanner sc=new Scanner(System.in);
		//Scanner sc=new Scanner(new File(""ip.txt""));
		
		int t,i,j,n,k,x,y,z,min1,min2,min3,arr1[],arr2[],arr3[];
		String s;
		char[] s1,s2,s3;

		t=sc.nextInt();
		
		while(t-->0)
		{
			n=sc.nextInt();
			k=sc.nextInt();
			s=sc.next();
			s1=new char[n];
			s2=new char[n];
			s3=new char[n];
			
			for(i=0;i<n;i++)
			{
				if(i%3==0)
				{
					s1[i]='R';
					s2[i]='G';
					s3[i]='B';
				}
				if(i%3==1)
				{
					s1[i]='G';
					s2[i]='B';
					s3[i]='R';
				}
				if(i%3==2)
				{
					s1[i]='B';
					s2[i]='R';
					s3[i]='G';
				}
			}
			arr1=new int[n];
			arr2=new int[n];
			arr3=new int[n];

			for(i=0;i<n;i++)
			{
				if(s.charAt(i)!=s1[i])
					arr1[i]=1;
				if(s.charAt(i)!=s2[i])
					arr2[i]=1;
				if(s.charAt(i)!=s3[i])
					arr3[i]=1;
			}
			for(i=1;i<n;i++)
			{
				arr1[i]=arr1[i]+arr1[i-1];
				arr2[i]=arr2[i]+arr2[i-1];
				arr3[i]=arr3[i]+arr3[i-1];
			}
			
			min1=arr1[k-1];
			min2=arr2[k-1];
			min3=arr3[k-1];

			for(i=k;i<n;i++)
			{
				if(min1>(arr1[i]-arr1[i-k]))
					min1=(arr1[i]-arr1[i-k]);
				if(min2>(arr2[i]-arr2[i-k]))
					min2=(arr2[i]-arr2[i-k]);
				if(min3>(arr3[i]-arr3[i-k]))
					min3=(arr3[i]-arr3[i-k]);
			}
			System.out.println(Math.min(min1,Math.min(min2,min3)));
		}
	}
}",5,CorCod,398,398
"
// Java program to print all words that have 
// the same unique character set 
import
java.util.ArrayList; 
import
java.util.Arrays; 
import
java.util.HashMap; 
import
java.util.Map.Entry; 
public
class
GFG { 


static
final
int
MAX_CHAR = 
26
; 


// Generates a key from given string. The key 

// contains all unique characters of given string 

// in sorted order consisting of only distinct elements. 

static
String getKey(String str) 

{ 

boolean
[] visited = 
new
boolean
[MAX_CHAR]; 

Arrays.fill(visited, 
false
); 


// store all unique characters of current 

// word in key 

for
(
int
j = 
0
; j < str.length(); j++) 

visited[str.charAt(j) - 
'a'
] = 
true
; 

String key = 
""""
; 

for
(
int
j=
0
; j < MAX_CHAR; j++) 

if
(visited[j]) 

key = key + (
char
)(
'a'
+j); 

return
key; 

} 


// Print all words together with same character sets. 

static
void
wordsWithSameCharSet(String words[], 
int
n) 

{ 

// Stores indexes of all words that have same 

// set of unique characters. 

//unordered_map <string, vector <int> > Hash; 

HashMap<String, ArrayList<Integer>> Hash = 
new
HashMap<>(); 


// Traverse all words 

for
(
int
i=
0
; i<n; i++) 

{ 

String key = getKey(words[i]); 


// if the key is already in the map 

// then get its corresponding value 

// and update the list and put it in the map 

if
(Hash.containsKey(key)) 

{ 

ArrayList<Integer> get_al = Hash.get(key); 

get_al.add(i); 

Hash.put(key, get_al); 

} 


// if key is not present in the map 

// then create a new list and add 

// both key and the list 

else

{ 

ArrayList<Integer> new_al = 
new
ArrayList<>(); 

new_al.add(i); 

Hash.put(key, new_al); 

} 

} 


// print all words that have the same unique character set 

for
(Entry<String, ArrayList<Integer>> it : Hash.entrySet()) 

{ 

ArrayList<Integer> get =it.getValue(); 

for
(Integer v:get) 

System.out.print( words[v] + 
"", ""
); 

System.out.println(); 

} 

} 


// Driver program to test above function 

public
static
void
main(String args[]) 

{ 

String words[] = { 
""may""
, 
""student""
, 
""students""
, 
""dog""
, 

""studentssess""
, 
""god""
, 
""cat""
, 
""act""
, 
""tab""
, 

""bat""
, 
""flow""
, 
""wolf""
, 
""lambs""
, 
""amy""
, 
""yam""
, 

""balms""
, 
""looped""
, 
""poodle""
}; 

int
n = words.length; 

wordsWithSameCharSet(words, n); 

} 
} 
// This code is contributed by Sumit Ghosh ",5,CorCod,400,400
"import java.util.Arrays;
import java.util.Scanner;


public class Solution {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		Solution ss = new Solution();
		ss.test(sc);
	}
	
	void test(Scanner sc){
		int LEN = sc.nextInt();
		int[] a = new int[LEN];
		int[] b = new int[LEN];
		for (int i = 0; i < b.length; i++) {
			a[i] = sc.nextInt();
		}
		for (int i = 0; i < b.length; i++) {
			b[i] = sc.nextInt();
		}
		Arrays.sort(a);
		Arrays.sort(b);
		
		int ia=0, ib=0;
		while(ia<LEN && a[ia]==0) ia++;
		while(ib<LEN && b[ib]==0) ib++;
		if(ib==LEN){
			System.out.println(""Yes"");
			return;
		}
		if(ia==LEN){
			System.out.println(""No"");
			return;
		}		
		boolean out = true;
		while(ia<LEN && ib<LEN){
			if(a[ia]==b[ib]){
				ia++;
				ib++;
			}else{
				if(a[ia]>b[ib]){
					while(ib<LEN && b[ib]!=a[ia]){
						ib++;
					}
					if(ib==LEN){
						out=false;
						break;
					}
				}
			}
		}
		
		if(out){
			System.out.println(""Yes"");
		}else{
			System.out.println(""No"");
		}
	}

}
",5,CorCod,425,425
"
// Space efficient Java program to count all 
// substrings with same first and last characters. 
public
class
GFG { 


static
int
countSubstringWithEqualEnds(String s) 

{ 

int
result = 
0
; 

int
n = s.length(); 


// Iterating through all substrings in 

// way so that we can find first and last 

// character easily 

for
(
int
i = 
0
; i < n; i++) 

for
(
int
j = i; j < n; j++) 

if
(s.charAt(i) == s.charAt(j)) 

result++; 


return
result; 

} 


// Driver function 

public
static
void
main(String args[]) 

{ 

String s = 
""abcab""
; 

System.out.println(countSubstringWithEqualEnds(s)); 

} 
} 
// This code is contributed by Sumit Ghosh ",5,CorCod,434,434
"
// Java Code to find the last man Standing 
public
class
GFG { 


// Node class to store data 

static
class
Node 

{ 

public
int
data ; 

public
Node next; 

public
Node( 
int
data ) 

{ 

this
.data = data; 

} 

} 


/* Function to find the only person left 

after one in every m-th node is killed 

in a circle of n nodes */

static
void
getJosephusPosition(
int
m, 
int
n) 

{ 

// Create a circular linked list of 

// size N. 

Node head = 
new
Node(
1
); 

Node prev = head; 

for
(
int
i = 
2
; i <= n; i++) 

{ 

prev.next = 
new
Node(i); 

prev = prev.next; 

} 


// Connect last node to first 

prev.next = head; 


/* while only one node is left in the 

linked list*/

Node ptr1 = head, ptr2 = head; 


while
(ptr1.next != ptr1) 

{ 


// Find m-th node 

int
count = 
1
; 

while
(count != m) 

{ 

ptr2 = ptr1; 

ptr1 = ptr1.next; 

count++; 

} 


/* Remove the m-th node */

ptr2.next = ptr1.next; 

ptr1 = ptr2.next; 

} 

System.out.println (
""Last person left standing ""
+ 

""(Josephus Position) is ""
+ ptr1.data); 

} 


/* Driver program to test above functions */

public
static
void
main(String args[]) 

{ 

int
n = 
14
, m = 
2
; 

getJosephusPosition(m, n); 

} 
} ",5,CorCod,436,436
"import java.io.*;
import java.util.Scanner;
import java.util.StringTokenizer;

public class Lyft {
    private static FastScanner scan = new FastScanner(System.in);
    private static PrintWriter pr = new PrintWriter(System.out);
    private static int n, m, taxistNumber, noTaxistNumber = 0;
    static people peoples[], taxist[], noTaxist[];
    public static void main(String[] args) throws IOException {
        n = scan.nextInt();
        m = scan.nextInt();
        peoples = new people[n + m];
        noTaxist = new people[n];
        taxist = new people[m];
        for(int i = 0; i < peoples.length; i++){
            peoples[i] = new people(scan.nextInt());
        }
        for (people i : peoples){
            if(scan.nextInt() == 1){
                i.taxi = true;
                i.passangers = 0;
                taxist[taxistNumber] = i;
                taxistNumber++;
            }else{
                noTaxist[noTaxistNumber] = i;
                noTaxistNumber++;
            }
        }
        for (people i : noTaxist){
                for (people ii: taxist){
                    if(ii.taxi){
                       if(i.nearestTaxist == null){
                           i.nearestTaxist = ii;
                           ii.passangers++;
                       }else if(i.coord - i.nearestTaxist.coord > ii.coord - i.coord){
                           i.nearestTaxist.passangers--;
                           i.nearestTaxist = ii;
                           i.nearestTaxist.passangers++;
                       }
                    }
                }
        }
        for (people i : taxist){
                pr.print(i.passangers + "" "");
        }
        pr.close();
    }
}
class FastScanner
{
    private static final int bufferSize = 64 * 1024;
    private final BufferedReader reader;
    private StringTokenizer tokenizer;

    FastScanner(InputStream inputStream)
    {
        this.reader = new BufferedReader(new InputStreamReader(inputStream), bufferSize);
    }

    String nextToken() throws IOException
    {
        while (tokenizer == null || !tokenizer.hasMoreTokens())
        {
            String line = reader.readLine();
            if (line == null)
            {
                tokenizer = null;
                return null;
            }
            tokenizer = new StringTokenizer(line);
        }
        return tokenizer.nextToken();
    }

    int[] readIntArray(int n) throws IOException
    {
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
        {
            a[i] = nextInt();
        }
        return a;
    }

    long[] readLongArray(int n) throws IOException
    {
        long[] a = new long[n];
        for (int i = 0; i < n; i++)
        {
            a[i] = nextLong();
        }
        return a;
    }

    int nextInt() throws NumberFormatException, IOException
    {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws NumberFormatException, IOException
    {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws NumberFormatException, IOException
    {
        return Double.parseDouble(nextToken());
    }

    String nextLine() throws IOException
    {
        tokenizer = null;
        return reader.readLine();
    }
}
class people{
    int coord = 0;
    boolean taxi = false;
    people nearestTaxist = null;
    int passangers = -1;
    people(int coord){
        this.coord = coord;
    }
}
",5,CorCod,438,438
"
// Java implementation to find the character in 
// first string that is present at minimum index 
// in second string 

public
class
GFG 
{ 

// method to find the minimum index character 

static
void
printMinIndexChar(String str, String patt) 

{ 

// to store the index of character having 

// minimum index 

int
minIndex = Integer.MAX_VALUE; 


// lengths of the two strings 

int
m = str.length(); 

int
n = patt.length(); 


// traverse 'patt' 

for
(
int
i = 
0
; i < n; i++) { 


// for each character of 'patt' traverse 'str' 

for
(
int
j = 
0
; j < m; j++) { 


// if patt.charAt(i)is found in 'str', check if 

// it has the minimum index or not. If yes, 

// then update 'minIndex' and break 

if
(patt.charAt(i)== str.charAt(j) && j < minIndex) { 

minIndex = j; 

break
; 

} 

} 

} 


// print the minimum index character 

if
(minIndex != Integer.MAX_VALUE) 

System.out.println(
""Minimum Index Character = ""
+ 

str.charAt(minIndex)); 


// if no character of 'patt' is present in 'str' 

else

System.out.println(
""No character present""
); 

} 


// Driver Method 

public
static
void
main(String[] args) 

{ 

String str = 
""geeksforgeeks""
; 

String patt = 
""set""
; 

printMinIndexChar(str, patt); 

} 
} ",5,CorCod,439,439
"import java.util.*;
import java.lang.*;
import java.io.*;
public class TestClass {
    // function for finding size of set
    public static int set_size(int[] a, int N){
        HashSet <Integer> newset = new HashSet <Integer>();
        int i=0;
        while(i<N){
            newset.add(a[i++]);
        }
        int v = newset.size();
        return v;
    }
    public static void main(String args[] ) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
       StringTokenizer tk = new StringTokenizer(br.readLine());
            int N = Integer.parseInt(tk.nextToken());
            int x = Integer.parseInt(tk.nextToken());
            
            int[] a = new int[N];
            int[] b = new int[N];
            StringTokenizer tb = new StringTokenizer(br.readLine());
            for(int i=0; i<N; i++){
                a[i] = Integer.parseInt(tb.nextToken());
            }
            if(set_size(a, N) < N){
                System.out.print(""0"");
                System.exit(0);
            }
            int num=0;
        while(num++<4){
            for(int i=0; i<N; i++){
                if((a[i]&x) == a[i])
                    continue;
                else{
                    for(int j=0; j<N; j++){
                        if(i==j){
                            b[i] = (a[i]&x);
                        }
                        else{
                            b[j] = a[j];
                        }
                    }
                    int s = set_size(b, N);
                    if(s<N){
                        System.out.print(num);
                        System.exit(0);
                    }
                }
            }
            for(int i=0; i<N; i++)
                a[i] = b[i];
        }
        System.out.print(""-1"");
        System.exit(0);
    }
}",5,CorCod,444,444
"import java.util.Scanner;
public class Codeforces {
    public static Scanner input = new Scanner(System.in);
    public static void main(String[] args){
        int n,k;
        n=input.nextInt();
        k=input.nextInt();
        String s=input.next();
        int[] wtArray=new int[n];
        for(int i=0;i<s.length();i++)
            wtArray[i]=s.charAt(i)-96;
        for(int i=1;i<n;i++)
            for(int j=0;j<n-i;j++)
                if(wtArray[j]>wtArray[j+1]){
                    int temp=wtArray[j+1];
                    wtArray[j+1]=wtArray[j];
                    wtArray[j]=temp;
                }

        int sum=wtArray[0];
        k--;
        int temp=sum;
        for(int i=1;k!=0 &&i <n;i++){
            if((wtArray[i]-temp)>1){
                sum+=wtArray[i];
                k--;
                temp=wtArray[i];
            }
        }
        if(k!=0)
            sum=-1;
        System.out.println(sum);
    }

}",5,CorCod,459,459
"
import java.util.*;

public class Main {

    public static void main(String[] args) {
       Scanner s = new Scanner(System.in);
       int n = s.nextInt();
       int m = s.nextInt();
       m = 0;
       long sum = 0;
       int[] expon = new int[n];
        for (int i = 0; i < n; i++) {
            expon[i] = s.nextInt();
            m = Math.max(expon[i], m);
            sum += expon[i];
        }
        HashSet<Integer> levels = new HashSet<>();


        int amount = 0;
        for (int i = 0; i < n; i++) {
            int currentHigh = expon[i];
            for (int j = currentHigh; j >= 1; j--) {
                if(!levels.contains(j)) {
                    levels.add(j);
                    amount++;
                    break;
                }
                if(j == 1){
                    amount++;
                }
            }
        }
        System.out.println((sum - amount) - (m - levels.size()));
    }
}",5,CorCod,471,471
"
import
java.util.Arrays; 

// Java program to find the largest 
// subset which where each pair 
// is divisible. 
class
GFG { 


// function to find the longest Subsequence 

static
int
largestSubset(
int
[] a, 
int
n) 

{ 

// Sort array in increasing order 

Arrays.sort(a); 


// dp[i] is going to store size of largest 

// divisible subset beginning with a[i]. 

int
[] dp = 
new
int
[n]; 


// Since last element is largest, d[n-1] is 1 

dp[n - 
1
] = 
1
; 


// Fill values for smaller elements. 

for
(
int
i = n - 
2
; i >= 
0
; i--) { 


// Find all multiples of a[i] and consider 

// the multiple that has largest subset 

// beginning with it. 

int
mxm = 
0
; 

for
(
int
j = i + 
1
; j < n; j++) { 

if
(a[j] % a[i] == 
0
) { 

mxm = Math.max(mxm, dp[j]); 

} 

} 


dp[i] = 
1
+ mxm; 

} 


// Return maximum value from dp[] 

return
Arrays.stream(dp).max().getAsInt(); 

} 


// driver code to check the above function 

public
static
void
main(String[] args) 

{ 

int
[] a = { 
1
, 
3
, 
6
, 
13
, 
17
, 
18
}; 

int
n = a.length; 

System.out.println(largestSubset(a, n)); 

} 
} 

/* This JAVA code is contributed by Rajput-Ji*/",5,CorCod,500,500
"
// Java program to Rearrange positive 
// and negative numbers in a array 
import
java.io.*; 

class
GFG { 

/* Function to print an array */

static
void
printArray(
int
A[], 
int
size) 

{ 

for
(
int
i = 
0
; i < size; i++) 

System.out.print(A[i] + 
"" ""
); 

System.out.println(); 

} 


// Merges two subarrays of arr[]. 

// First subarray is arr[l..m] 

// Second subarray is arr[m+1..r] 

static
void
merge(
int
arr[], 
int
l, 
int
m, 
int
r) 

{ 

int
i, j, k; 

int
n1 = m - l + 
1
; 

int
n2 = r - m; 


/* create temp arrays */

int
L[] = 
new
int
[n1]; 

int
R[] = 
new
int
[n2]; 


/* Copy data to temp arrays L[] and R[] */

for
(i = 
0
; i < n1; i++) 

L[i] = arr[l + i]; 

for
(j = 
0
; j < n2; j++) 

R[j] = arr[m + 
1
+ j]; 


/* Merge the temp arrays back into arr[l..r]*/

// Initial index of first subarray 

i = 
0
; 


// Initial index of second subarray 

j = 
0
; 


// Initial index of merged subarray 

k = l; 


// Note the order of appearance of elements should 

// be maintained - we copy elements of left subarray 

// first followed by that of right subarray 


// copy negative elements of left subarray 

while
(i < n1 && L[i] < 
0
) 

arr[k++] = L[i++]; 


// copy negative elements of right subarray 

while
(j < n2 && R[j] < 
0
) 

arr[k++] = R[j++]; 


// copy positive elements of left subarray 

while
(i < n1) 

arr[k++] = L[i++]; 


// copy positive elements of right subarray 

while
(j < n2) 

arr[k++] = R[j++]; 

} 


// Function to Rearrange positive and negative 

// numbers in a array 

static
void
RearrangePosNeg(
int
arr[], 
int
l, 
int
r) 

{ 

if
(l < r) { 

// Same as (l + r)/2, but avoids overflow for 

// large l and h 

int
m = l + (r - l) / 
2
; 


// Sort first and second halves 

RearrangePosNeg(arr, l, m); 

RearrangePosNeg(arr, m + 
1
, r); 


merge(arr, l, m, r); 

} 

} 


// Driver program 

public
static
void
main(String[] args) 

{ 

int
arr[] = { -
12
, 
11
, -
13
, -
5
, 
6
, -
7
, 
5
, -
3
, -
6
}; 

int
arr_size = arr.length; 

RearrangePosNeg(arr, 
0
, arr_size - 
1
); 

printArray(arr, arr_size); 

} 
} 

// This code is contributed by vt_m. ",5,CorCod,504,504
"
// Java program to check if there is a subset 
// with sum divisible by m. 
import
java.util.Arrays; 

class
GFG { 


// Returns true if there is a subset 

// of arr[] with sum divisible by m 

static
boolean
modularSum(
int
arr[], 

int
n, 
int
m) 

{ 

if
(n > m) 

return
true
; 


// This array will keep track of all 

// the possible sum (after modulo m) 

// which can be made using subsets of arr[] 

// initialising boolean array with all false 

boolean
DP[]=
new
boolean
[m]; 


Arrays.fill(DP, 
false
); 


// we'll loop through all the elements 

// of arr[] 

for
(
int
i = 
0
; i < n; i++) 

{ 


// anytime we encounter a sum divisible 

// by m, we are done 

if
(DP[
0
]) 

return
true
; 


// To store all the new encountered sum 

// (after modulo). It is used to make 

// sure that arr[i] is added only to 

// those entries for which DP[j] 

// was true before current iteration. 

boolean
temp[] = 
new
boolean
[m]; 

Arrays.fill(temp, 
false
); 


// For each element of arr[], we loop 

// through all elements of DP table 

// from 1 to m and we add current 

// element i. e., arr[i] to all those 

// elements which are true in DP table 

for
(
int
j = 
0
; j < m; j++) 

{ 


// if an element is true in 

// DP table 

if
(DP[j] == 
true
) 

{ 

if
(DP[(j + arr[i]) % m] == 
false
) 


// We update it in temp and update 

// to DP once loop of j is over 

temp[(j + arr[i]) % m] = 
true
; 

} 

} 


// Updating all the elements of temp 

// to DP table since iteration over 

// j is over 

for
(
int
j = 
0
; j < m; j++) 

if
(temp[j]) 

DP[j] = 
true
; 



// Also since arr[i] is a single 

// element subset, arr[i]%m is one 

// of the possible sum 

DP[arr[i] % m] = 
true
; 

} 


return
DP[
0
]; 

} 


//driver code 

public
static
void
main(String arg[]) 

{ 

int
arr[] = {
1
, 
7
}; 

int
n = arr.length; 

int
m = 
5
; 


if
(modularSum(arr, n, m)) 

System.out.print(
""YES\n""
); 

else

System.out.print(
""NO\n""
); 

} 
} 

//This code is contributed by Anant Agarwal. ",5,CorCod,505,505
"
// Java program to count all substrings with same 
// first and last characters. 
public
class
GFG { 


// Returns true if first and last characters 

// of s are same. 

static
boolean
checkEquality(String s) 

{ 

return
(s.charAt(
0
) == s.charAt(s.length() - 
1
)); 

} 


static
int
countSubstringWithEqualEnds(String s) 

{ 

int
result = 
0
; 

int
n = s.length(); 


// Starting point of substring 

for
(
int
i = 
0
; i < n; i++) 


// Length of substring 

for
(
int
len = 
1
; len <= n-i; len++) 


// Check if current substring has same 

// starting and ending characters. 

if
(checkEquality(s.substring(i, i + len))) 

result++; 


return
result; 

} 


// Driver function 

public
static
void
main(String args[]) 

{ 

String s = 
""abcab""
; 

System.out.println(countSubstringWithEqualEnds(s)); 

} 
} 
// This code is contributed by Sumit Ghosh ",5,CorCod,509,509
"
// JAVA Code for Maximum size square 
// sub-matrix with all 1s 
public
class
GFG 
{ 

// method for Maximum size square sub-matrix with all 1s 

static
void
printMaxSubSquare(
int
M[][]) 

{ 

int
i,j; 

int
R = M.length; 
//no of rows in M[][] 

int
C = M[
0
].length; 
//no of columns in M[][] 

int
S[][] = 
new
int
[R][C]; 


int
max_of_s, max_i, max_j; 


/* Set first column of S[][]*/

for
(i = 
0
; i < R; i++) 

S[i][
0
] = M[i][
0
]; 


/* Set first row of S[][]*/

for
(j = 
0
; j < C; j++) 

S[
0
][j] = M[
0
][j]; 


/* Construct other entries of S[][]*/

for
(i = 
1
; i < R; i++) 

{ 

for
(j = 
1
; j < C; j++) 

{ 

if
(M[i][j] == 
1
) 

S[i][j] = Math.min(S[i][j-
1
], 

Math.min(S[i-
1
][j], S[i-
1
][j-
1
])) + 
1
; 

else

S[i][j] = 
0
; 

} 

} 


/* Find the maximum entry, and indexes of maximum entry 

in S[][] */

max_of_s = S[
0
][
0
]; max_i = 
0
; max_j = 
0
; 

for
(i = 
0
; i < R; i++) 

{ 

for
(j = 
0
; j < C; j++) 

{ 

if
(max_of_s < S[i][j]) 

{ 

max_of_s = S[i][j]; 

max_i = i; 

max_j = j; 

} 

} 

} 


System.out.println(
""Maximum size sub-matrix is: ""
); 

for
(i = max_i; i > max_i - max_of_s; i--) 

{ 

for
(j = max_j; j > max_j - max_of_s; j--) 

{ 

System.out.print(M[i][j] + 
"" ""
); 

} 

System.out.println(); 

} 

} 


// Driver program 

public
static
void
main(String[] args) 

{ 

int
M[][] = {{
0
, 
1
, 
1
, 
0
, 
1
}, 

{
1
, 
1
, 
0
, 
1
, 
0
}, 

{
0
, 
1
, 
1
, 
1
, 
0
}, 

{
1
, 
1
, 
1
, 
1
, 
0
}, 

{
1
, 
1
, 
1
, 
1
, 
1
}, 

{
0
, 
0
, 
0
, 
0
, 
0
}}; 


printMaxSubSquare(M); 

} 

} ",5,CorCod,514,514
"
// Java program to to maximize array 
// sum after k operations. 

class
GFG 
{ 

// This function does k operations 

// on array in a way that maximize 

// the array sum. index --> stores 

// the index of current minimum 

// element for j'th operation 

static
int
maximumSum(
int
arr[], 
int
n, 
int
k) 

{ 

// Modify array K number of times 

for
(
int
i = 
1
; i <= k; i++) 

{ 

int
min = +
2147483647
; 

int
index = -
1
; 


// Find minimum element in array for 

// current operation and modify it 

// i.e; arr[j] --> -arr[j] 

for
(
int
j=
0
; j<n; j++) 

{ 

if
(arr[j] < min) 

{ 

min = arr[j]; 

index = j; 

} 

} 


// this the condition if we find 0 as 

// minimum element, so it will useless to 

// replace 0 by -(0) for remaining operations 

if
(min == 
0
) 

break
; 


// Modify element of array 

arr[index] = -arr[index]; 

} 


// Calculate sum of array 

int
sum = 
0
; 

for
(
int
i = 
0
; i < n; i++) 

sum += arr[i]; 

return
sum; 

} 



// Driver program 

public
static
void
main(String arg[]) 

{ 

int
arr[] = {-
2
, 
0
, 
5
, -
1
, 
2
}; 

int
k = 
4
; 

int
n = arr.length; 

System.out.print(maximumSum(arr, n, k)); 

} 
} 

// This code is contributed by Anant Agarwal. ",5,CorCod,517,517
"import java.util.*;
 
import javax.lang.model.util.ElementScanner6;
 
import java.io.*;
 
public class Main {
 
    public static void main(String[] args) {
 
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader inp = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        Solver solver = new Solver();
        solver.solve(inp, out);
        out.close();
 
    }
 
 
 
 
 
    static class Solver {

        class pair implements Comparable<pair>{

            int i;
            long dist;
            public pair(int i,long dist)
            {
                this.i=i;
                this.dist=dist;
            }

            public int compareTo(pair p)
            {
                return Long.compare(this.dist,p.dist);
            }

        }
 
        class Node implements Comparable < Node > {
            int i;
            int cnt;
 
            Node(int i, int cnt) {
                this.i = i;
                this.cnt = cnt;
            }
 
            public int compareTo(Node n) {
                if (this.cnt == n.cnt) {
                    return Integer.compare(this.i, n.i);
                }
                return Integer.compare(this.cnt, n.cnt);
            }
        }
 
        public boolean done(int[] sp, int[] par) {
            int root;
 
            root = findSet(sp[0], par);
 
            for (int i = 1; i < sp.length; i++) {
                if (root != findSet(sp[i], par))
                    return false;
            }
            return true;
        }
        public int findSet(int i, int[] par) {
            int x = i;
            boolean flag = false;
            while (par[i] >= 0) {
                flag = true;
                i = par[i];
            }
            if (flag)
                par[x] = i;
            return i;
        }
 
        public void unionSet(int i, int j, int[] par) {
            int x = findSet(i, par);
            int y = findSet(j, par);
            if (x < y) {
                par[y] = x;
            } else {
                par[x] = y;
            }
        }
 
        public long pow(long a, long b, long MOD) {
            if (b == 0) {
                return 1;
            }
            if (b == 1) {
                return a;
            }
            long val = pow(a, b / 2, MOD);
            if (b % 2 == 0) {
                return val * val % MOD;
            } else {
                return val * (val * a % MOD) % MOD;
 
            }
 
        }

        public boolean isPrime(int n)
        {
            for(int i=2;i<n;i++)
            {
                if(n%i==0)
                {
                    return false;
                }
            }
            return true;
        }
 
 
        public void minPrimeFactor(int n, int[] s) {
            boolean prime[] = new boolean[n + 1];
            Arrays.fill(prime, true);
            s[1] = 1;
            s[2] = 2;
            for (int i = 4; i <= n; i += 2) {
                prime[i] = false;
                s[i] = 2;
            }
 
            for (int i = 3; i <= n; i += 2) {
                if (prime[i]) {
                    s[i] = i;
                    for (int j = 2 * i; j <= n; j += i) {
                        prime[j] = false;
                        s[j] = i;
                    }
                }
            }
 
        }
 
 
        public void findAllPrime(int n, ArrayList < Node > al, int s[]) {
            int curr = s[n];
            int cnt = 1;
            while (n > 1) {
                n /= s[n];
                if (curr == s[n]) {
                    cnt++;
                    continue;
 
                }
                Node n1 = new Node(curr, cnt);
                al.add(n1);
 
                curr = s[n];
                cnt = 1;
            }
        }
 
 
 
        public int binarySearch(int n, int k) {
            int left = 1;
            int right = 100000000 + 5;
            int ans = 0;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (n / mid >= k) {
                    left = mid + 1;
                    ans = mid;
                } else {
                    right = mid - 1;
                }
            }
 
            return ans;
        }
        public boolean checkPallindrom(String s) {
            char ch[] = s.toCharArray();
 
            for (int i = 0; i < s.length() / 2; i++) {
                if (ch[i] != ch[s.length() - 1 - i])
                    return false;
            }
            return true;
        }
 
 
 
 
        public void remove(ArrayList < Integer > [] al, int x) {
            for (int i = 0; i < al.length; i++) {
                for (int j = 0; j < al[i].size(); j++) {
 
                    if (al[i].get(j) == x)
                        al[i].remove(j);
 
                }
            }
        }
 
        public long gcd(long a, long b) {
            if (a == 0)
                return b;
            return gcd(b % a, a);
        }
 
 
        public void printDivisors(long n, ArrayList < Long > al) {
            // Note that this loop runs till square root 
            for (long i = 1; i <= Math.sqrt(n); i++) {
                if (n % i == 0) {
                    // If divisors are equal, print only one 
                    if (n / i == i) {
                        al.add(i);
                    } else // Otherwise print both 
                    {
                        al.add(i);
                        al.add(n / i);
                    }
 
                }
            }
        }
 
        public static long constructSegment(long seg[], long arr[], int low, int high, int pos) {
            if (low == high) {
                seg[pos] = arr[low];
                return seg[pos];
            }
            int mid = (low + high) / 2;
            long t1 = constructSegment(seg, arr, low, mid, (2 * pos) + 1);
            long t2 = constructSegment(seg, arr, mid + 1, high, (2 * pos) + 2);
            seg[pos] = t1 + t2;
            return seg[pos];
 
        }
        public static long querySegment(long seg[], int low, int high, int qlow, int qhigh, int pos) {
 
            if (qlow <= low && qhigh >= high) {
                return seg[pos];
            } else if (qlow > high || qhigh < low) {
                return 0;
            } else {
                long ans = 0;
                int mid = (low + high) / 2;
                ans += querySegment(seg, low, mid, qlow, qhigh, (2 * pos) + 1);
                ans += querySegment(seg, mid + 1, high, qlow, qhigh, (2 * pos) + 2);
                return ans;
            }
 
        }
        public static int lcs(char[] X, char[] Y, int m, int n) {
            if (m == 0 || n == 0)
                return 0;
            if (X[m - 1] == Y[n - 1])
                return 1 + lcs(X, Y, m - 1, n - 1);
            else
                return Integer.max(lcs(X, Y, m, n - 1), lcs(X, Y, m - 1, n));
        }
 
        public static long recursion(long start, long end, long cnt[], int a, int b) {
 
            long min = 0;
            long count = 0;
            int ans1 = -1;
            int ans2 = -1;
            int l = 0;
            int r = cnt.length - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (cnt[mid] >= start) {
                    ans1 = mid;
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
 
            l = 0;
            r = cnt.length - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (cnt[mid] <= end) {
                    ans2 = mid;
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
 
            if (ans1 == -1 || ans2 == -1 || ans2 < ans1) {
                // System.out.println(""min1 ""+min);
                min = a;
                return a;
 
            } else {
                min = b * (end - start + 1) * (ans2 - ans1 + 1);
            }
            if (start == end) {
                // System.out.println(""min ""+min);
                return min;
            }
            long mid = (end + start) / 2;
            min = Long.min(min, recursion(start, mid, cnt, a, b) + recursion(mid + 1, end, cnt, a, b));
            // System.out.println(""min ""+min);
            return min;
        }
 
 
 
 
 
        public int dfs_util(ArrayList < Integer > [] al, boolean vis[], int x, int[] s, int lvl[]) {
 
            vis[x] = true;
            int cnt = 1;
            for (int i = 0; i < al[x].size(); i++) {
 
                if (!vis[al[x].get(i)]) {
                    lvl[al[x].get(i)] = lvl[x] + 1;
                    cnt += dfs_util(al, vis, al[x].get(i), s, lvl);
 
 
                }
 
 
            }
            s[x] = cnt;
            return s[x];
        }
 
        public void dfs(ArrayList[] al, int[] s, int[] lvl) {
 
            boolean vis[] = new boolean[al.length];
            for (int i = 0; i < al.length; i++) {
                if (!vis[i]) {
                    lvl[i] = 1;
                    dfs_util(al, vis, i, s, lvl);
                }
            }
        }
 
        public int[] computeLps(String s)
        {
            int ans[] =new int[s.length()];
            char ch[] = s.toCharArray();
            int n = s.length();
            int i=1;
            int len=0;
            ans[0]=0;
            while(i<n)
            {
                if(ch[i]==ch[len])
                {
                    len++;
                    ans[i]=len;
                    i++;
                }
                else
                {
                    if(len!=0)
                    {
                        len=ans[len-1];
                    }
                    else
                    {
                        ans[i]=len;
                        i++;
                    }
                }
            }

            return ans;

        }
 
 
        private void solve(InputReader inp, PrintWriter out1) {
            int n = inp.nextInt();
            int m = inp.nextInt();
            long k = inp.nextLong();
            long arr[] = new long[n];

            for(int i=0;i<n;i++)
            {
                arr[i] = inp.nextLong();

            }
            long ans=0;
            for(int i=0;i<m;i++)
            {
                long sum=0;
                for(int j=i;j<n;j++)
                {
                    

                    if(j%m==i)
                    {
                        if(sum<0)
                        {
                           sum=0;
                        }
                        sum-=k;
                    }
                    
                    sum+=arr[j];
                    
                    ans=Math.max(ans,sum);
                }

            

            }

            System.out.println(ans);
           

           
            
        }
 
 
}
 
 
    static class InputReader {
        BufferedReader reader;
        StringTokenizer tokenizer;
 
        InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
 
        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
 
        public int nextInt() {
            return Integer.parseInt(next());
        }
 
        public long nextLong() {
            return Long.parseLong(next());
        }
    }
}
class ele implements Comparable < ele > {
    int value;
    int i;
    boolean flag;
    public ele(int value, int i) {
        this.value = value;
        this.i = i;
        this.flag = false;
    }
    public int compareTo(ele e) {
        return Integer.compare(this.value, e.value);
    }
}",5,CorCod,530,530
"
// Java program to find minimum removals 
// to make max-min <= K 
import
java.util.Arrays; 

class
GFG 
{ 

static
int
MAX=
100
; 

static
int
dp[][]=
new
int
[MAX][MAX]; 


// function to check all possible combinations 

// of removal and return the minimum one 

static
int
countRemovals(
int
a[], 
int
i, 
int
j, 
int
k) 

{ 

// base case when all elements are removed 

if
(i >= j) 

return
0
; 


// if condition is satisfied, no more 

// removals are required 

else
if
((a[j] - a[i]) <= k) 

return
0
; 


// if the state has already been visited 

else
if
(dp[i][j] != -
1
) 

return
dp[i][j]; 


// when Amax-Amin>d 

else
if
((a[j] - a[i]) > k) { 


// minimum is taken of the removal 

// of minimum element or removal 

// of the maximum element 

dp[i][j] = 
1
+ Math.min(countRemovals(a, i + 
1
, j, k), 

countRemovals(a, i, j - 
1
, k)); 

} 

return
dp[i][j]; 

} 


// To sort the array and return the answer 

static
int
removals(
int
a[], 
int
n, 
int
k) 

{ 

// sort the array 

Arrays.sort(a); 


// fill all stated with -1 

// when only one element 

for
(
int
[] rows:dp) 

Arrays.fill(rows,-
1
); 

if
(n == 
1
) 

return
0
; 

else

return
countRemovals(a, 
0
, n - 
1
, k); 

} 


// Driver code 

public
static
void
main (String[] args) 

{ 

int
a[] = { 
1
, 
3
, 
4
, 
9
, 
10
, 
11
, 
12
, 
17
, 
20
}; 

int
n = a.length; 

int
k = 
4
; 

System.out.print(removals(a, n, k)); 

} 
} 

// This code is contributed by Anant Agarwal. ",5,CorCod,542,542
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;
import java.util.function.Function;

public class P1196D2 {

    static boolean multipleIndependent = true;

    void run() {
        int n = in.nextInt();
        int k = in.nextInt();
        char[] s = in.next().toCharArray();
        int[] dp = new int[3];
        char[] c = {'R', 'G', 'B'};
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < k; i++) {
            dp[0] += s[i] == c[(i + 0) % 3] ? 0 : 1;
            dp[1] += s[i] == c[(i + 1) % 3] ? 0 : 1;
            dp[2] += s[i] == c[(i + 2) % 3] ? 0 : 1;
        }
        min = Math.min(Math.min(Math.min(dp[0], dp[1]), dp[2]), min);
//        System.out.println(Arrays.toString(dp));
        for (int i = k; i < n; i++) {
            dp[0] += (s[i] == c[(i + 0) % 3] ? 0 : 1) - (s[i - k] == c[(i - k + 0) % 3] ? 0 : 1);
            dp[1] += (s[i] == c[(i + 1) % 3] ? 0 : 1) - (s[i - k] == c[(i - k + 1) % 3] ? 0 : 1);
            dp[2] += (s[i] == c[(i + 2) % 3] ? 0 : 1) - (s[i - k] == c[(i - k + 2) % 3] ? 0 : 1);
            min = Math.min(Math.min(Math.min(dp[0], dp[1]), dp[2]), min);
//            System.out.println(Arrays.toString(dp));
        }
        System.out.println(min);
    }


    /* -----: Template :----- */
    static InputReader in = new InputReader(System.in);

    public static void main(String[] args) {
        P1196D2 p = new P1196D2();
        int q = multipleIndependent ? in.nextInt() : 1;
        while (q-- > 0) {
            p.run();
        }
    }

    int numLength(long n) {
        int l = 0;
        while (n > 0) {
            n /= 10;
            l++;
        }
        return l;
    }

    <R> long binarySearch(long lowerBound, long upperBound,
            R value, Function<Long, R> generatorFunction, Comparator<R> comparator) {
        if (lowerBound <= upperBound) {
            long mid = (lowerBound + upperBound) / 2;
            int compare = comparator.compare(generatorFunction.apply(mid), value);
            if (compare == 0) {
                return mid;
            } else if (compare < 0) {
                return binarySearch(mid + 1, upperBound, value, generatorFunction, comparator);
            } else {
                return binarySearch(lowerBound, mid - 1, value, generatorFunction, comparator);
            }
        } else {
            return -1;
        }
    }

    <T> Integer[] sortSimultaneously(T[] key, Comparator<T> comparator,
            Object[]... moreArrays) {
        int n = key.length;
        for (Object[] array : moreArrays) {
            if (array.length != n) {
                throw new RuntimeException(""Arrays must have equals lengths"");
            }
        }
        Integer[] indices = new Integer[n];
        for (int i = 0; i < n; i++) {
            indices[i] = i;
        }
        Comparator<Integer> delegatingComparator = (a, b) -> {
            return comparator.compare(key[a], key[b]);
        };
        Arrays.sort(indices, delegatingComparator);
        reorder(indices, key);
        for (Object[] array : moreArrays) {
            reorder(indices, array);
        }
        return indices;
    }

    void reorder(Integer[] indices, Object[] arr) {
        if (indices.length != arr.length) {
            throw new RuntimeException(""Arrays must have equals lengths"");
        }
        int n = arr.length;
        Object[] copy = new Object[n];
        for (int i = 0; i < n; i++) {
            copy[i] = arr[indices[i]];
        }
        System.arraycopy(copy, 0, arr, 0, n);
    }

    int prodMod(int a, int b, int mod) {
        return (int) (((long) a) * b % mod);
    }

    long prodMod(long a, long b, long mod) {
        long res = 0;
        a %= mod;
        b %= mod;
        while (b > 0) {
            if ((b & 1) > 0) {
                res = (res + a) % mod;
            }
            a = (a << 1) % mod;
            b >>= 1;
        }
        return res;
    }

    long sumMod(int[] b, long mod) {
        long res = 0;
        for (int i = 0; i < b.length; i++) {
            res = (res + b[i] % mod) % mod;
        }
        return res;
    }

    long sumMod(long[] a, long mod) {
        long res = 0;
        for (int i = 0; i < a.length; i++) {
            res = (res + a[i] % mod) % mod;
        }
        return res;
    }

    long sumProdMod(int[] a, long b, long mod) {
        long res = sumMod(a, mod);
        return prodMod(res, b, mod);
    }

    long sumProdMod(long[] a, long b, long mod) {
        long res = sumMod(a, mod);
        return prodMod(res, b, mod);
    }

    long sumProdMod(int[] a, int[] b, long mod) {
        if (a.length != b.length) {
            throw new RuntimeException(""Arrays must have equals lengths"");
        }
        long res = 0;
        for (int i = 0; i < a.length; i++) {
            res = (res + prodMod(a[i], b[i], mod)) % mod;
        }
        return res;
    }

    long sumProdMod(long[] a, long[] b, long mod) {
        if (a.length != b.length) {
            throw new RuntimeException(""Arrays must have equals lengths"");
        }
        long res = 0;
        for (int i = 0; i < a.length; i++) {
            res = (res + prodMod(a[i], b[i], mod)) % mod;
        }
        return res;
    }

    int[] toPrimitive(Integer[] arr) {
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    int[][] toPrimitive(Integer[][] arr) {
        int[][] res = new int[arr.length][];
        for (int i = 0; i < arr.length; i++) {
            res[i] = toPrimitive(arr[i]);
        }
        return res;
    }

    long[] toPrimitive(Long[] arr) {
        long[] res = new long[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    long[][] toPrimitive(Long[][] arr) {
        long[][] res = new long[arr.length][];
        for (int i = 0; i < arr.length; i++) {
            res[i] = toPrimitive(arr[i]);
        }
        return res;
    }

    Integer[] toWrapper(int[] arr) {
        Integer[] res = new Integer[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    Integer[][] toWrapper(int[][] arr) {
        Integer[][] res = new Integer[arr.length][];
        for (int i = 0; i < arr.length; i++) {
            res[i] = toWrapper(arr[i]);
        }
        return res;
    }

    Long[] toWrapper(long[] arr) {
        Long[] res = new Long[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    Long[][] toWrapper(long[][] arr) {
        Long[][] res = new Long[arr.length][];
        for (int i = 0; i < arr.length; i++) {
            res[i] = toWrapper(arr[i]);
        }
        return res;
    }

    static class InputReader {

        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int[] nextIntArray(int n) {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = nextInt();
            }
            return arr;
        }

        public <T> T[] nextIntArray(int n, Function<Integer, T> function, Class<T> c) {
            T[] arr = (T[]) Array.newInstance(c, n);
            for (int i = 0; i < n; i++) {
                arr[i] = function.apply(nextInt());
            }
            return arr;
        }

        public long[] nextLongArray(int n) {
            long[] arr = new long[n];
            for (int i = 0; i < n; i++) {
                arr[i] = nextLong();
            }
            return arr;
        }

        public <T> T[] nextLongArray(int n, Function<Long, T> function, Class<T> c) {
            T[] arr = (T[]) Array.newInstance(c, n);
            for (int i = 0; i < n; i++) {
                arr[i] = function.apply(nextLong());
            }
            return arr;
        }

        public int[][] nextIntMap(int n, int m) {
            int[][] map = new int[n][m];
            for (int i = 0; i < n; i++) {
                map[i] = nextIntArray(m);
            }
            return map;
        }

        public long[][] nextLongMap(int n, int m) {
            long[][] map = new long[n][m];
            for (int i = 0; i < n; i++) {
                map[i] = nextLongArray(m);
            }
            return map;
        }

        public char[][] nextCharMap(int n) {
            char[][] map = new char[n][];
            for (int i = 0; i < n; i++) {
                map[i] = next().toCharArray();
            }
            return map;
        }

        public void readColumns(Object[]... columns) {
            int n = columns[0].length;
            for (Object[] column : columns) {
                if (column.length != n) {
                    throw new RuntimeException(""Arrays must have equals lengths"");
                }
            }
            for (int i = 0; i < n; i++) {
                for (Object[] column : columns) {
                    column[i] = read(column[i].getClass());
                }
            }
        }

        public <T> T read(Class<T> c) {
            throw new UnsupportedOperationException(""To be implemented"");
        }

    }

}
",5,CorCod,543,543
"
// Java program for recursive level order traversal in spiral form 

/* A binary tree node has data, pointer to left child 

and a pointer to right child */
class
Node { 

int
data; 

Node left, right; 


public
Node(
int
d) 

{ 

data = d; 

left = right = 
null
; 

} 
} 

class
BinaryTree { 

Node root; 


// Function to print the spiral traversal of tree 

void
printSpiral(Node node) 

{ 

int
h = height(node); 

int
i; 


/* ltr -> left to right. If this variable is set then the 

given label is traversed from left to right */

boolean
ltr = 
false
; 

for
(i = 
1
; i <= h; i++) { 

printGivenLevel(node, i, ltr); 


/*Revert ltr to traverse next level in opposite order*/

ltr = !ltr; 

} 

} 


/* Compute the ""height"" of a tree -- the number of 

nodes along the longest path from the root node 

down to the farthest leaf node.*/

int
height(Node node) 

{ 

if
(node == 
null
) 

return
0
; 

else
{ 


/* compute the height of each subtree */

int
lheight = height(node.left); 

int
rheight = height(node.right); 


/* use the larger one */

if
(lheight > rheight) 

return
(lheight + 
1
); 

else

return
(rheight + 
1
); 

} 

} 


/* Print nodes at a given level */

void
printGivenLevel(Node node, 
int
level, 
boolean
ltr) 

{ 

if
(node == 
null
) 

return
; 

if
(level == 
1
) 

System.out.print(node.data + 
"" ""
); 

else
if
(level > 
1
) { 

if
(ltr != 
false
) { 

printGivenLevel(node.left, level - 
1
, ltr); 

printGivenLevel(node.right, level - 
1
, ltr); 

} 

else
{ 

printGivenLevel(node.right, level - 
1
, ltr); 

printGivenLevel(node.left, level - 
1
, ltr); 

} 

} 

} 

/* Driver program to test the above functions */

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
1
); 

tree.root.left = 
new
Node(
2
); 

tree.root.right = 
new
Node(
3
); 

tree.root.left.left = 
new
Node(
7
); 

tree.root.left.right = 
new
Node(
6
); 

tree.root.right.left = 
new
Node(
5
); 

tree.root.right.right = 
new
Node(
4
); 

System.out.println(
""Spiral order traversal of Binary Tree is ""
); 

tree.printSpiral(tree.root); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",5,CorCod,550,550
"
// Java program to remove duplicates from unsorted 
// linked list 

class
LinkedList { 


static
Node head; 


static
class
Node { 


int
data; 

Node next; 


Node(
int
d) { 

data = d; 

next = 
null
; 

} 

} 


/* Function to remove duplicates from an 

unsorted linked list */

void
remove_duplicates() { 

Node ptr1 = 
null
, ptr2 = 
null
, dup = 
null
; 

ptr1 = head; 


/* Pick elements one by one */

while
(ptr1 != 
null
&& ptr1.next != 
null
) { 

ptr2 = ptr1; 


/* Compare the picked element with rest 

of the elements */

while
(ptr2.next != 
null
) { 


/* If duplicate then delete it */

if
(ptr1.data == ptr2.next.data) { 


/* sequence of steps is important here */

dup = ptr2.next; 

ptr2.next = ptr2.next.next; 

System.gc(); 

} 
else
/* This is tricky */
{ 

ptr2 = ptr2.next; 

} 

} 

ptr1 = ptr1.next; 

} 

} 


void
printList(Node node) { 

while
(node != 
null
) { 

System.out.print(node.data + 
"" ""
); 

node = node.next; 

} 

} 


public
static
void
main(String[] args) { 

LinkedList list = 
new
LinkedList(); 

list.head = 
new
Node(
10
); 

list.head.next = 
new
Node(
12
); 

list.head.next.next = 
new
Node(
11
); 

list.head.next.next.next = 
new
Node(
11
); 

list.head.next.next.next.next = 
new
Node(
12
); 

list.head.next.next.next.next.next = 
new
Node(
11
); 

list.head.next.next.next.next.next.next = 
new
Node(
10
); 


System.out.println(
""Linked List before removing duplicates : \n ""
); 

list.printList(head); 


list.remove_duplicates(); 

System.out.println(
""""
); 

System.out.println(
""Linked List after removing duplicates : \n ""
); 

list.printList(head); 

} 
} 
// This code has been contributed by Mayank Jaiswal ",5,CorCod,557,557
"
// Java program to Count elements which 
// divides all numbers in range L-R 
import
java.io.*; 

class
GFG 
{ 

// function to count element 
// Time complexity O(n^2) worst case 
static
int
answerQuery(
int
a[], 
int
n, 

int
l, 
int
r) 
{ 

// answer for query 

int
count = 
0
; 


// 0 based index 

l = l - 
1
; 


// iterate for all elements 

for
(
int
i = l; i < r; i++) 

{ 

int
element = a[i]; 

int
divisors = 
0
; 


// check if the element divides 

// all numbers in range 

for
(
int
j = l; j < r; j++) 

{ 

// no of elements 

if
(a[j] % a[i] == 
0
) 

divisors++; 

else

break
; 

} 


// if all elements are divisible by a[i] 

if
(divisors == (r - l)) 

count++; 

} 


// answer for every query 

return
count; 
} 

// Driver Code 
public
static
void
main (String[] args) 
{ 

int
a[] = { 
1
, 
2
, 
3
, 
5
}; 

int
n = a.length; 


int
l = 
1
, r = 
4
; 

System.out.println( answerQuery(a, n, l, r)); 


l = 
2
; r = 
4
; 

System.out.println( answerQuery(a, n, l, r)); 
} 
} 

// This code is contributed by anuj_67.. ",5,CorCod,574,574
"import java.util.*;
import java.math.*;
public class Main{
    public static void main(String [] args)
    {
        Scanner scan=new Scanner(System.in);
        int n=scan.nextInt();
        int m=scan.nextInt();
        int a[]=new int[m+1];
        int i,j;
        int c=0;
        for(i=0;i<n;i++)
        {
            int l=scan.nextInt();
            int r=scan.nextInt();
            for(j=l;j<=r;j++)
            {
                if(a[j]!=1)
                {
                    a[j]=1;
                    c++;
                }
            }
        }
        System.out.println(m-c);
        for(i=1;i<=m;i++)
        {
            if(a[i]==0)
            {
                System.out.print(i+"" "");
            }
        }
    }
}",5,CorCod,575,575
"import java.util.*;
import java.io.*;
import java.math.*;
 
public class Main {
    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        //Scanner sc = new Scanner();
        Reader in = new Reader();
        Main solver = new Main();
        solver.solve(out, in);
        out.flush();
        out.close();
 
    }
 
    static int INF = (int)1e5*4*4+5;
    static int maxn = (int)1e5*2+1;
    static int mod=(int)1e9+7 ;
    static int n,m,k,t,q,x,a,b,y;
    
    static ArrayList<Integer> adj[];
    static int[] dist,parent,back;
    static boolean[] vis,vist;
    static int root=0,ans=1;
    
    
    void solve(PrintWriter out, Reader in) throws IOException{
        n = in.nextInt();


        if(n==1) {out.println(1);return;}
        adj = new ArrayList[n+1];
        for(int i=1;i<=n;i++) 
            adj[i] = new ArrayList<Integer>();
        
        int u,v;
        for(int i=0;i<n-1;i++){
            u = in.nextInt();
            v = in.nextInt();
             
            adj[u].add(v);
            adj[v].add(u);
        }
        
        vist = new boolean[n+1];
        vis = new boolean[n+1];
        vist[1] =true;
        makeroot(1);
        
        parent = new int[n+1];
        dist = new int[n+1];
        back = new int[n+1];
        
        dfs(root,0);
        calcdist(root);
        
        vist = new boolean[n+1];
        vis = new boolean[n+1];
        vist[root] =true;
        
        

        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        for(int i=1;i<=n;i++){
            if(i!=root) pq.add(new Node(i,dist[i]));
        }
        
        Node elm;
        int rt = root;
        out.print(1);
        
        makeroot(root);
        removeNodes(root,rt);
        ans+=dist[rt];
        out.print("" ""+ans);
        int itr=2;
        for(int i=2;i<=n;i++){
            
            elm = pq.remove();
            if(vis[elm.idx]) continue;
            removeNodes(back[elm.idx],elm.idx);
            ans += elm.dist+1;
            out.print("" ""+ans);
            itr++;
        }
        for(int i=itr;i<n;i++)
            out.print("" ""+ans);
        out.println();
    }
    
    //<>
    
    static class Node implements Comparable<Node>{
        int dist,idx;
        
        Node(int idx,int dist){
            this.idx = idx;
            this.dist = dist;
        }
        
        public int compareTo(Node o) {
            return o.dist-this.dist;
        }
    }
    
    static void removeNodes(int s,int e){
        vis[s]=true;
        while(s!=e){
            vis[s] = true;
            s = parent[s];
        }
        vis[s]=true;
        return;
    }
    
    static int calcdist(int s){
        int res=0;
        int tmp=0;
        for(int e:adj[s]){
            if(e!=parent[s]){
                tmp= calcdist(e);
                if(1+tmp>res){
                    res = 1+tmp;
                    back[s] = back[e];
                }
            }
        }
        
        if(res==0) back[s]=s;
        return dist[s] = res;
    }
    
    static void dfs(int s,int p){
        for(int e:adj[s]){
            if(e!=p){
                parent[e]=s;
                dfs(e,s);
            }
        }
        return;
    }
    
    static void makeroot(int s){
        Queue<Integer> q = new LinkedList<>();
        q.add(s);
        
        int elm=0;
        while(q.size()!=0){
            elm = q.remove();
            for(int e:adj[elm]){
                if(!vist[e]){
                    vist[e]=true;
                    q.add(e);
                    root = e;
                }
            }
        }
        return;
    }
    
    
    static class Reader {

    private InputStream mIs;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public Reader() {
        this(System.in);
    }

    public Reader(InputStream is) {
        mIs = is;
    }

    public int read() {
        if (numChars == -1) {
            throw new InputMismatchException();

    }
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = mIs.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0) {
                return -1;
            }
        }
        return buf[curChar++];
    }

    public String nextLine() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isEndOfLine(c));
        return res.toString();
    }

    public String next() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    double nextDouble()
    {
        return Double.parseDouble(next());
    }

    public long nextLong() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public int nextInt() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public boolean isEndOfLine(int c) {
        return c == '\n' || c == '\r' || c == -1;
    }

    }
}",4,CorCod,588,588
"import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int m = sc.nextInt();

        long totalBlocks = 0;
        long a[] = new long[n];
        for(int i = 0; i < n; ++i) {
            a[i] = sc.nextLong();
            totalBlocks += a[i];
        }

        Arrays.sort(a);

        long selected = 0;
        for(int i = 0; i < n; ++i) {
            if(a[i] > selected)
                selected++;
        }

        long leftCols = a[n - 1] - selected;
        long remBlocks = totalBlocks - leftCols - n;

        System.out.print(remBlocks);
    }
}",4,CorCod,600,600
"import java.io.*;
import java.util.*;
import java.util.function.Function;

public class Main {

    static int N;
    static int[] U, V;
    static int[] A;

    public static void main(String[] args) {
        FastScanner sc = new FastScanner(System.in);
        N = sc.nextInt();
        U = new int[N-1];
        V = new int[N-1];
        for (int i = 0; i < N - 1; i++) {
            U[i] = sc.nextInt()-1;
            V[i] = sc.nextInt()-1;
        }
        A = sc.nextIntArray(N, -1);

        System.out.println(solve() ? ""Yes"" : ""No"");
    }

    static boolean solve() {
        if( A[0] != 0 ) return false;

        int[][] G = adjB(N, U, V);

        Map<Integer, Integer> parents = new HashMap<>();
        for (Node node : orderFromRoot(N, G, 0)) {
            parents.put(node.a, node.parent);
        }
        ArrayDeque<Integer> q = new ArrayDeque<>();
        for (int next : G[0]) {
            q.add(0);
        }

        int idx = 1;
        while(!q.isEmpty()) {
            int p = q.poll();
            int a = A[idx++];
            if( parents.get(a) != p ) {
                return false;
            }

            for (int next : G[a]) {
                if( next == p ) continue;

                q.add(a);
            }
        }
        return true;
    }

    static int[][] adjB(int n, int[] from, int[] to) {
        int[][] adj = new int[n][];
        int[] cnt = new int[n];
        for (int f : from) {
            cnt[f]++;
        }
        for (int t : to) {
            cnt[t]++;
        }
        for (int i = 0; i < n; i++) {
            adj[i] = new int[cnt[i]];
        }
        for (int i = 0; i < from.length; i++) {
            adj[from[i]][--cnt[from[i]]] = to[i];
            adj[to[i]][--cnt[to[i]]] = from[i];
        }
        return adj;
    }

    static Node[] orderFromRoot(int N, int[][] G, int root) {
        ArrayDeque<Node> q = new ArrayDeque<>();
        Node[] ret = new Node[N];
        int idx = 0;
        q.add(new Node(-1, root));
        while(!q.isEmpty()) {
            Node n = q.poll();
            ret[idx++] = n;
            for (int next : G[n.a]) {
                if( next == n.parent ) continue;

                q.add(new Node(n.a, next));
            }
        }
        return ret;
    }

    static class Node {
        int parent, a;

        public Node(int parent, int a) {
            this.parent = parent;
            this.a = a;
        }
    }

    @SuppressWarnings(""unused"")
    static class FastScanner {
        private BufferedReader reader;
        private StringTokenizer tokenizer;

        FastScanner(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
            tokenizer = null;
        }

        String next() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        String nextLine() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    return reader.readLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken(""\n"");
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        int[] nextIntArray(int n, int delta) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt() + delta;
            return a;
        }

        long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }
    }

    static <A> void writeLines(A[] as, Function<A, String> f) {
        PrintWriter pw = new PrintWriter(System.out);
        for (A a : as) {
            pw.println(f.apply(a));
        }
        pw.flush();
    }

    static void writeLines(int[] as) {
        PrintWriter pw = new PrintWriter(System.out);
        for (int a : as) pw.println(a);
        pw.flush();
    }

    static void writeLines(long[] as) {
        PrintWriter pw = new PrintWriter(System.out);
        for (long a : as) pw.println(a);
        pw.flush();
    }

    static int max(int... as) {
        int max = Integer.MIN_VALUE;
        for (int a : as) max = Math.max(a, max);
        return max;
    }

    static int min(int... as) {
        int min = Integer.MAX_VALUE;
        for (int a : as) min = Math.min(a, min);
        return min;
    }

    static void debug(Object... args) {
        StringJoiner j = new StringJoiner("" "");
        for (Object arg : args) {
            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));
            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));
            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));
            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));
            else j.add(arg.toString());
        }
        System.err.println(j.toString());
    }
}
",4,CorCod,601,601
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author math2do
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int height = in.nextInt();
            int width = in.nextInt();
            int n1 = in.nextInt();
            int n2 = in.nextInt();
            int v = in.nextInt();
            int[] p1 = new int[n1];
            for (int i = 0; i < n1; ++i) p1[i] = in.nextInt();
            int[] p2 = new int[n2];
            for (int i = 0; i < n2; ++i) p2[i] = in.nextInt();
            int nq = in.nextInt();
            for (int iq = 0; iq < nq; ++iq) {
                int r1 = in.nextInt();
                int c1 = in.nextInt();
                int r2 = in.nextInt();
                int c2 = in.nextInt();
                if (r1 == r2) {
                    out.println(Math.abs(c1 - c2));
                } else {
                    long res = Long.MAX_VALUE;
                    int pos = Arrays.binarySearch(p1, c1);
                    if (pos < 0) pos = -(pos + 1);
                    if (pos >= 0 && pos < p1.length) {
                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));
                    }
                    --pos;
                    if (pos >= 0 && pos < p1.length) {
                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));
                    }
                    pos = Arrays.binarySearch(p2, c1);
                    if (pos < 0) pos = -(pos + 1);
                    if (pos >= 0 && pos < p2.length) {
                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);
                    }
                    --pos;
                    if (pos >= 0 && pos < p2.length) {
                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);
                    }
                    out.println(res);
                }
            }
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",4,CorCod,622,622
"import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class Solution {
	public static void main(String[] args) {
		Solution solution = new Solution();
		System.out.println(solution.solve());
	}

	private int solve() {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int m = in.nextInt();

		int[] a = new int[m];
		for (int i = 0; i < m; ++i) a[i] = in.nextInt();

		if (n > m) return 0;

		Map<Integer, Integer> map = new HashMap<>();
		for (int k: a) map.put(k, map.getOrDefault(k, 0) + 1);

		List<Integer> keySet = new ArrayList<>(map.keySet());
		int end = m / n;

		keySet.sort((u, v) -> -Integer.compare(u, v));
		do {
			int count = 0;
			for (int k: keySet) {
				count += map.get(k) / end;
				if (count >= n) return end;
			}
		} while (--end > 0);

		return 0;
	}
}
",4,CorCod,638,638
"
// Java program for Prim's MST for 
// adjacency list representation of graph 
import
java.util.LinkedList; 
import
java.util.TreeSet; 
import
java.util.Comparator; 

public
class
prims { 

class
node1 { 


// Stores destination vertex in adjacency list 

int
dest; 


// Stores weight of a vertex in the adjacency list 

int
weight; 


// Constructor 

node1(
int
a, 
int
b) 

{ 

dest = a; 

weight = b; 

} 

} 

static
class
Graph { 


// Number of vertices in the graph 

int
V; 


// List of adjacent nodes of a given vertex 

LinkedList<node1>[] adj; 


// Constructor 

Graph(
int
e) 

{ 

V = e; 

adj = 
new
LinkedList[V]; 

for
(
int
o = 
0
; o < V; o++) 

adj[o] = 
new
LinkedList<>(); 

} 

} 


// class to represent a node in PriorityQueue 

// Stores a vertex and its corresponding 

// key value 

class
node { 

int
vertex; 

int
key; 

} 


// Comparator class created for PriorityQueue 

// returns 1 if node0.key > node1.key 

// returns 0 if node0.key < node1.key and 

// returns -1 otherwise 

class
comparator 
implements
Comparator<node> { 


@Override

public
int
compare(node node0, node node1) 

{ 

return
node0.key - node1.key; 

} 

} 


// method to add an edge 

// between two vertices 

void
addEdge(Graph graph, 
int
src, 
int
dest, 
int
weight) 

{ 


node1 node0 = 
new
node1(dest, weight); 

node1 node = 
new
node1(src, weight); 

graph.adj[src].addLast(node0); 

graph.adj[dest].addLast(node); 

} 


// method used to find the mst 

void
prims_mst(Graph graph) 

{ 


// Whether a vertex is in PriorityQueue or not 

Boolean[] mstset = 
new
Boolean[graph.V]; 

node[] e = 
new
node[graph.V]; 


// Stores the parents of a vertex 

int
[] parent = 
new
int
[graph.V]; 


for
(
int
o = 
0
; o < graph.V; o++) 

e[o] = 
new
node(); 


for
(
int
o = 
0
; o < graph.V; o++) { 


// Initialize to false 

mstset[o] = 
false
; 


// Initialize key values to infinity 

e[o].key = Integer.MAX_VALUE; 

e[o].vertex = o; 

parent[o] = -
1
; 

} 


// Include the source vertex in mstset 

mstset[
0
] = 
true
; 


// Set key value to 0 

// so that it is extracted first 

// out of PriorityQueue 

e[
0
].key = 
0
; 


// Use TreeSet instead of PriorityQueue as the remove function of the PQ is O(n) in java. 

TreeSet<node> queue = 
new
TreeSet<node>(
new
comparator()); 


for
(
int
o = 
0
; o < graph.V; o++) 

queue.add(e[o]); 


// Loops until the queue is not empty 

while
(!queue.isEmpty()) { 


// Extracts a node with min key value 

node node0 = queue.pollFirst(); 


// Include that node into mstset 

mstset[node0.vertex] = 
true
; 


// For all adjacent vertex of the extracted vertex V 

for
(node1 iterator : graph.adj[node0.vertex]) { 


// If V is in queue 

if
(mstset[iterator.dest] == 
false
) { 

// If the key value of the adjacent vertex is 

// more than the extracted key 

// update the key value of adjacent vertex 

// to update first remove and add the updated vertex 

if
(e[iterator.dest].key > iterator.weight) { 

queue.remove(e[iterator.dest]); 

e[iterator.dest].key = iterator.weight; 

queue.add(e[iterator.dest]); 

parent[iterator.dest] = node0.vertex; 

} 

} 

} 

} 


// Prints the vertex pair of mst 

for
(
int
o = 
1
; o < graph.V; o++) 

System.out.println(parent[o] + 
"" ""

+ 
""-""

+ 
"" ""
+ o); 

} 


public
static
void
main(String[] args) 

{ 

int
V = 
9
; 


Graph graph = 
new
Graph(V); 


prims e = 
new
prims(); 


e.addEdge(graph, 
0
, 
1
, 
4
); 

e.addEdge(graph, 
0
, 
7
, 
8
); 

e.addEdge(graph, 
1
, 
2
, 
8
); 

e.addEdge(graph, 
1
, 
7
, 
11
); 

e.addEdge(graph, 
2
, 
3
, 
7
); 

e.addEdge(graph, 
2
, 
8
, 
2
); 

e.addEdge(graph, 
2
, 
5
, 
4
); 

e.addEdge(graph, 
3
, 
4
, 
9
); 

e.addEdge(graph, 
3
, 
5
, 
14
); 

e.addEdge(graph, 
4
, 
5
, 
10
); 

e.addEdge(graph, 
5
, 
6
, 
2
); 

e.addEdge(graph, 
6
, 
7
, 
1
); 

e.addEdge(graph, 
6
, 
8
, 
6
); 

e.addEdge(graph, 
7
, 
8
, 
7
); 


// Method invoked 

e.prims_mst(graph); 

} 
} 
// This code is contributed by Vikash Kumar Dubey ",4,CorCod,658,658
"import java.util.*;
import java.io.*;
public class A
{
      public static void main(String ar[]) throws Exception
      {
            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
            String s1[]=br.readLine().split("" "");
            int n=Integer.parseInt(s1[0]);
            int m=Integer.parseInt(s1[1]);
            int a[]=new int[n];
            String s2[]=br.readLine().split("" "");
            long S=0;
            for(int i=0;i<n;i++)
            { a[i]=Integer.parseInt(s2[i]);  S+=(long)a[i]; }
            
            Arrays.sort(a);
            m=a[n-1];
            int last=1;
            int t=1;
            for(int i=1;i<n-1;i++)
            {
                  if(a[i]==last)
                   t++;
                  else
                  {
                        t++;
                        last=last+1;
                  }
            }
            if(last<m)
            { t+=m-last; }
            else
             t++;
            System.out.println(S-t);
      }
}",4,CorCod,669,669
"import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class A {
    static MyScanner sc;
    static PrintWriter pw;

    public static void main(String[] args) throws Throwable {
        sc = new MyScanner();
        pw = new PrintWriter(System.out);

        n = sc.nextInt();
        T = sc.nextLong();
        p = new int[n];
        l = new int[n];
        x = new int[n];
        t = new int[n];
        adj = new ArrayList[n];

        for (int i = 0; i < n; i++)
            x[i] = sc.nextInt();
        for (int i = 0; i < n; i++)
            t[i] = sc.nextInt();
        adj[0] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            adj[i] = new ArrayList<>();
            p[i] = sc.nextInt() - 1;
            l[i] = sc.nextInt();
            adj[p[i]].add(i);
        }

        ftCnt = new long[N];
        ftSum = new long[N];
        ans = new long[n];

        dfs(0);
        pw.println(ans[0]);

        pw.flush();
        pw.close();
    }

    static int n;
    static long T;
    static int[] p, l, x, t;
    static ArrayList<Integer>[] adj;

    static long[] ans;

    static void dfs(int u) {
        update(t[u], x[u], 1L * x[u] * t[u]);
        ans[u] = getMaxCnt();
        long[] vals = {-1, -1, -1};
        for (int v : adj[u]) {
            T -= 2 * l[v];
            dfs(v);
            vals[0] = ans[v];
            Arrays.sort(vals);
            T += 2 * l[v];
        }
        if (u != 0) {
            if (vals[1] != -1)
                ans[u] = Math.max(ans[u], vals[1]);
        } else {
            if (vals[2] != -1)
                ans[u] = Math.max(ans[u], vals[2]);
        }
        update(t[u], -x[u], -1L * x[u] * t[u]);
    }

    static int N = (int) 1e6 + 2;
    static long[] ftCnt, ftSum;

    static void update(int idx, long cnt, long val) {
        while (idx < N) {
            ftCnt[idx] += cnt;
            ftSum[idx] += val;
            idx += (idx & -idx);
        }
    }

    static long getSum(int idx) {
        long ret = 0;
        while (idx > 0) {
            ret += ftSum[idx];
            idx -= (idx & -idx);
        }
        return ret;
    }

    static long getCnt(int idx) {
        long ret = 0;
        while (idx > 0) {
            ret += ftCnt[idx];
            idx -= (idx & -idx);
        }
        return ret;
    }

    static long getMaxCnt() {
        int start = 1, end = N - 1, ans = N - 1;
        while (start <= end) {
            int mid = (start + end) / 2;
            if (getSum(mid) >= T) {
                ans = mid;
                end = mid - 1;
            } else
                start = mid + 1;
        }
        long remT = T - (ans > 1 ? getSum(ans - 1) : 0);
        long cnt = (ans > 1 ? getCnt(ans - 1) : 0);
        long cntOfVal = getCnt(ans) - cnt;
        cnt += Math.min(cntOfVal, remT / ans);
        return cnt;
    }


    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}",4,CorCod,687,687
"import java.util.Scanner;
public class JavaApplication7 {

    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n= sc.nextInt();
        int m=sc.nextInt();
        long sum=0;
        long []d=new long[n];
        long[]ds=new long[n];
        for(int i =0;i<n;i++){
            d[i]=sc.nextLong();
            sum+=d[i];
            ds[i]=sum;
        }
        long[]le=new long[m];
        for(int i =0;i<m;i++){
            le[i]=sc.nextLong();
        }
        int l=0;
        int h=n;
        int k=(h-l)/2;
        k+=l;
        for(int i=0;i<m;i++){
        l=0;
        h=n;
        k=(h-l)/2;
        k+=l;
            for(;l<=h;){
                k=(h-l)/2;
                k+=l;
                if(ds[k]<le[i]){
                    l=k+1;
                }
                else if(ds[k]==le[i]){break;}
                else{
                    h=k-1;
                }
            }
            //System.out.println(k);
            if(ds[k]<le[i]){
                    k++;
                }
          if(k==0){
              System.out.println((int)(k+1)+"" ""+le[i]);
           }
            else{
                System.out.println((int)(k+1)+"" ""+(long)(le[i]-ds[k-1]));
           }
        }
        
    }
    
}
",4,CorCod,689,689
"import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;
import java.io.InputStream ;
import java.util.InputMismatchException;
import java.util.ArrayList;


public class Main {
    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        //Scanner sc = new Scanner();
        Reader in = new Reader();
        Main solver = new Main();
        solver.solve(out, in);
        out.flush();
        out.close();

    }
    
    
    void solve(PrintWriter out, Reader in) throws IOException{   
        int n = in.nextInt();
        int m = in.nextInt();
        
        
        
        int[] vert = new int[n+1];
        for(int i=0 ;i<n ;i++) vert[i] = in.nextInt();
        vert[n] = (int)1e9;
        
        int cnt=0,x,y;
        ArrayList<Integer> arr = new ArrayList<>();
        for(int i=0 ;i<m ;i++) {
            x = in.nextInt();
            y = in.nextInt();
            in.nextInt();
            
            if(x==1) arr.add(y);
        }
        
        horz = new int[arr.size()];
        for(int i=0 ;i<arr.size();i++) horz[i] = arr.get(i);
        
        Arrays.sort(horz);
        Arrays.sort(vert);
        
        int ans = 2*(int)1e5+10;
        for(int i=0 ;i<=n ;i++){
            int lesshorz = bs(vert[i],horz.length);
            ans = Math.min(ans,i+horz.length-lesshorz-1);
        }
        out.println(ans);
    }
    
    static int[] horz;
    
    static int bs(int num,int m){
        int mid,lo=0,hi=m-1,r=-1;
        
        while(lo<=hi){
            mid = (lo+hi)/2;
            if(horz[mid]<num){
                lo = mid+1;
                r = mid;
            }else{
                hi =mid-1;
            }
        }
        return r;
    }
    
    static class Reader {
 
        private InputStream mIs;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
     
        public Reader() {
            this(System.in);
        }
     
        public Reader(InputStream is) {
            mIs = is;
        }
     
        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
        
        }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = mIs.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }
     
        public String nextLine() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isEndOfLine(c));
            return res.toString();
        }
     
        public String next() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }
     
        public long nextLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
     
        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
     
        public boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
     
        public boolean isEndOfLine(int c) {
            return c == '\n' || c == '\r' || c == -1;
        }
 
    }
}
",4,CorCod,693,693
"import java.io.*;
import java.util.*;

import static java.lang.System.out;

public class Main {

    private FastScanner scanner = new FastScanner();

    public static void main(String[] args) {
        new Main().solve();
    }

    private List<Integer>[] gr = new ArrayList[1000_000+5];
    private int dp[][] = new int[21][1000_000+5];
    private boolean used[] = new boolean[1000_000+5];

    void init(int v, int p) {
        Stack<Integer> st = new Stack<>();
        st.push(v);
        st.push(p);
        while (!st.isEmpty()) {
            p = st.pop();
            v = st.pop();
            used[v] = true;

            dp[0][v] =  p;
            for (int i = 1; i <= 20; i++) {
                if (dp[i - 1][v] != -1) {
                    dp[i][v] = dp[i - 1][dp[i - 1][v]];
                }
            }

            for (int next : gr[v]) {
                if (!used[next]) {
                    st.push(next);
                    st.push(v);
                }
            }

        }
    }


    private void solve() {
        int n = scanner.nextInt(), k = scanner.nextInt();
        boolean[] ans = new boolean[1000_000 + 5];

        for (int i = 0; i < n; i++) {
            gr[i] = new ArrayList<>();
        }

        for (int i = 0; i < n - 1; i ++) {
            int u = scanner.nextInt() - 1, v = scanner.nextInt() - 1;
            gr[u].add(v);
            gr[v].add(u);
        }

        k = n - k - 1;
        ans[n - 1] = true;

        init(n - 1 , n - 1);

        int t, d, next;
        for (int i = n - 2; i >= 0; i--) {
            t = i;
            d = 1;
            if (ans[i]) {
                continue;
            }
            for (int j = 20; j >= 0; j--){
                next = dp[j][t];
                if (next != -1 && !ans[next]) {
                    t = next;
                    d +=  1 << j;
                }
            }

            if (d <= k) {
                k -=d;
                t = i;

                while (!ans[t]) {
                    ans[t] = true;
                    t = dp[0][t];
                }
            }
            if (k == 0) {
                break;
            }
        }
        StringBuilder sb = new StringBuilder("""");
        for (int i = 0; i < n; i++) {
            if (!ans[i]) {
                sb.append(i + 1).append("" "");
            }
        }
        System.out.println(sb.toString());
    }

    class FastScanner {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public FastScanner() {
            reader = new BufferedReader(new InputStreamReader(System.in), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}",4,CorCod,701,701
"import java.util.*;
import java.io.*;

public class Sol {
	public static void main(String[] args) {
		MyScanner sc = new MyScanner();
		out = new PrintWriter(new BufferedOutputStream(System.out));
		int n = sc.nextInt();
		int k = sc.nextInt();
		int l = sc.nextInt();
		Integer[] a = new Integer[n*k];
		for(int i = 0; i < n*k; i++){
			a[i] = sc.nextInt();
		}
		Arrays.sort(a);
		if (a[n - 1] - a[0] > l) {
			out.println(0);
		} else {
			int maxPos = n*k - 1;
			for (int i = 0; i < n*k; i++) {
				if (a[i] - a[0] > l) {
					maxPos = i-1;
					break;
				}
			}
			long o = a[0];
			int s = 0;
			int t = 1;
			for (int i = 1; i <= maxPos; i++) {
				//System.out.print(a[i]);
				if (s < k - 1 && maxPos-i+1 > n-t) {
					//System.out.println("" @"");
					s++;
				} else {
					//System.out.println("" #"");
					s = 0;
					t++;
					o += a[i];
				}
			}
			out.println(o);
		}
		out.close();
	}

	// -----------PrintWriter for faster output-------------
	public static PrintWriter out;

	// -----------MyScanner class for faster input----------
	public static class MyScanner {
		BufferedReader br;
		StringTokenizer st;

		public MyScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}

	}
	// --------------------------------------------------------
}",4,CorCod,705,705
"

import java.util.Scanner;

public class Fly {

    static double ERROR = 0.0000001;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n =  scanner.nextInt();
        int m = scanner.nextInt();
        int [] a = new int[n + 1];
        int [] b = new int[n + 1];
        for(int i =0; i< n; i++ ) {
            a[i] = scanner.nextInt();
        }

        for(int i =0; i< n; i++ ) {
            b[i] = scanner.nextInt();
        }
        b[n] = b[0];

        double max =  1000000000;
        double min = 0;
        boolean found = false;
        while (max >= min) {
            double mid = max + min;
             mid /= 2;
             boolean v = isValid(a, b, m, n, mid);
             // System.out.println(""For fuel:"" + mid + "" isValid: "" + v + "", max:"" + max + "", min:"" + min);
             if (v) {
                 max = mid;
             }
             else {
                 min = mid;
             }
             if (max - min <= ERROR && v) {
                 //System.out.println(""max: "" + max + "" , min:"" + min);
                 found = true;
                 break;
             }
             if (max ==  min) {
                 break;
             }
        }
        //System.out.println(found);
        if (found) {
            System.out.println(max);
        }
        else System.out.println(-1);
    }


    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {
        double total =  m + fuel;
        for (int i=0; i<n;i++) {
            double lost = total;
            lost/= a[i];
            total -= lost;

            lost = total;
            lost/=b[i+1];
            total -= lost;
            if ((total-m) < 0) {
                return false;
            }
        }
        if ((total-m) < 0) return false;
        return  true;
    }
}
",4,CorCod,706,706
"import java.io.*;
import java.util.*;
import java.util.Arrays;

public class Main
{
    
     static void merge(int arr[], int l, int m, int r) 
    { 
        // Find sizes of two subarrays to be merged 
        int n1 = m - l + 1; 
        int n2 = r - m; 
  
        /* Create temp arrays */
        int L[] = new int [n1]; 
        int R[] = new int [n2]; 
  
        /*Copy data to temp arrays*/
        for (int i=0; i<n1; ++i) 
            L[i] = arr[l + i]; 
        for (int j=0; j<n2; ++j) 
            R[j] = arr[m + 1+ j]; 
  
  
        /* Merge the temp arrays */
  
        // Initial indexes of first and second subarrays 
        int i = 0, j = 0; 
  
        // Initial index of merged subarry array 
        int k = l; 
        while (i < n1 && j < n2) 
        { 
            if (L[i] <= R[j]) 
            { 
                arr[k] = L[i]; 
                i++; 
            } 
            else
            { 
                arr[k] = R[j]; 
                j++; 
            } 
            k++; 
        } 
  
        /* Copy remaining elements of L[] if any */
        while (i < n1) 
        { 
            arr[k] = L[i]; 
            i++; 
            k++; 
        } 
  
        /* Copy remaining elements of R[] if any */
        while (j < n2) 
        { 
            arr[k] = R[j]; 
            j++; 
            k++; 
        } 
    } 
  
    // Main function that sorts arr[l..r] using 
    // merge() 
    static void sort(int arr[], int l, int r) 
    { 
        if (l < r) 
        { 
            // Find the middle point 
            int m = (l+r)/2; 
  
            // Sort first and second halves 
            sort(arr, l, m); 
            sort(arr , m+1, r); 
  
            // Merge the sorted halves 
            merge(arr, l, m, r); 
        } 
    } 
  
    public static void main(String args[]) throws Exception
    {
        Scanner sc=new Scanner(System.in);
        int q=sc.nextInt();
        while(q>0)
        {
            
            int n=sc.nextInt();
            int a[]=new int[n];
            int i=0;
            for(i=0;i<n;i++)
                a[i]=sc.nextInt();
           sort(a,0,n-1);
           int p=a[n-2]-1;
            if(n-2>=p)
                System.out.println(p);
            else if (n-2==0)
            System.out.println(0);
            else 
                System.out.println(n-2);
            q--;
        }
        
    }
        
    }",4,CorCod,729,729
"import java.io.*;
import java.util.*;
import java.math.*;

public class Main
{
	//static long k = 0;
	public static void main(String[] args) throws IOException
	{
		BufferedReader st = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer s = new StringTokenizer(st.readLine());
		long n = Long.parseLong(s.nextToken());
		long k = Long.parseLong(s.nextToken());
		long ans = k/n;
		if(k%n != 0) ans++;
		System.out.println(ans+"""");
	}
}",1,CorCod,768,768
"import java.util.Scanner;
public class Main{
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);

		int a = in.nextInt();

		if(a>=1 && a<=100){
			if(a>2){
				if(a%2==0){
					System.out.println(""YES"");
				}else{
					System.out.println(""NO"");
				}
			}else{
				System.out.println(""NO"");
			}
		}
		
		

	}
}",1,CorCod,792,792
"import java.util.*;
import java.math.*;
import java.io.*;

public class CF1068A {
	public CF1068A() {
		FS scan = new FS();
		long n = scan.nextLong(), m = scan.nextLong(), k = scan.nextLong(), l = scan.nextLong();
		long ceil = (k + l + m - 1) / m;
		if(k + l <= n && ceil * m <= n) System.out.println(ceil);
		else System.out.println(-1);
	}
	class FS {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer("""");
		public String next() {
			while(!st.hasMoreTokens()) {
				try { st = new StringTokenizer(br.readLine()); }
				catch(Exception e) { e.printStackTrace(); }
			}
			return st.nextToken();
		}
		public int nextInt() { return Integer.parseInt(next()); }
		public long nextLong() { return Long.parseLong(next()); }
	}
	public static void main(String[] args) { new CF1068A(); }
}
",1,CorCod,804,804
"
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class cf2 {
	static final double EPS = 1e-9;

  public static void main(String[] args) throws IOException {
	 Scanner sc = new Scanner(System.in);
	
	 //rec
	 int xr1=sc.nextInt(), yr1=sc.nextInt(), xr2=sc.nextInt(),yr2=sc.nextInt();
	 int xr3=sc.nextInt(), yr3=sc.nextInt(), xr4=sc.nextInt(),yr4=sc.nextInt();
	
	 Point pr1 = new Point(xr1, yr1);
	 Point pr2 = new Point(xr2, yr2);
	 Point pr3 = new Point(xr3, yr3);
	 Point pr4 = new Point(xr4, yr4);
	 
	 LineSegment lr1 = new LineSegment(pr1, pr2);
	 LineSegment lr2 = new LineSegment(pr2, pr3);
	 LineSegment lr3 = new LineSegment(pr3, pr4);
	 LineSegment lr4 = new LineSegment(pr4, pr1);
	 
	 //diamond
	 int xd1=sc.nextInt(), yd1=sc.nextInt(), xd2=sc.nextInt(),yd2=sc.nextInt();
	 int xd3=sc.nextInt(), yd3=sc.nextInt(), xd4=sc.nextInt(),yd4=sc.nextInt();
	 
	 Point p1 = new Point(xd1, yd1);
	 Point p2 = new Point(xd2, yd2);
	 Point p3 = new Point(xd3, yd3);
	 Point p4 = new Point(xd4, yd4);
	 
	 Point [] pt = new Point [5];
	 pt[0]=p1;  pt[1]=p2;  pt[2]=p3;  pt[3]=p4;  pt[4]=p1;
	 Polygon pg = new Polygon(pt);
	 
	 if(pg.inside(pr1)||pg.inside(pr2)||pg.inside(pr3)||pg.inside(pr4)) {
		 System.out.println(""YES"");
		 return;
	 }
	
	 
	 LineSegment ld1 = new LineSegment(p1, p2);
	 LineSegment ld2 = new LineSegment(p2, p3);
	 LineSegment ld3 = new LineSegment(p3, p4);
	 LineSegment ld4 = new LineSegment(p4, p1);
	 
	 Rectangle rec = new Rectangle(new Point(Math.min(Math.min(xr3,xr4),Math.min(xr1,xr2)), Math.min(Math.min(yr3,yr4),Math.min(yr1,yr2))), 
			 new Point(Math.max(Math.max(xr3,xr4),Math.max(xr1,xr2)), Math.max(Math.max(yr3,yr4),Math.max(yr1,yr2))) );
	 
	 if(rec.contains(p1)||rec.contains(p2)||rec.contains(p3)||rec.contains(p4)) {
		 System.out.println(""YES"");
	     return;
	 }
	 
	 if(ld1.intersect(lr1)||ld1.intersect(lr3)||ld1.intersect(lr3)||ld1.intersect(lr4)) {
		 System.out.println(""YES"");
	     return;
	 }
	 
	 if(ld2.intersect(lr1)||ld2.intersect(lr3)||ld2.intersect(lr3)||ld2.intersect(lr4)) {
		 System.out.println(""YES"");
	     return;
	 }
	 
	 if(ld3.intersect(lr1)||ld3.intersect(lr3)||ld3.intersect(lr3)||ld3.intersect(lr4)) {
		 System.out.println(""YES"");
	     return;
	 }
	 
	 if(ld4.intersect(lr1)||ld4.intersect(lr3)||ld4.intersect(lr3)||ld4.intersect(lr4)) {
		 System.out.println(""YES"");
	     return;
	 }
	 
	 System.out.println(""NO"");
	 
	 
	 
	 
}
  
  public static class Polygon { 
		// Cases to handle: collinear points, polygons with n < 3

		static final double EPS = 1e-9;
		
		Point[] g; 			//first point = last point, counter-clockwise representation
		
		Polygon(Point[] o) { g = o; }

		double perimeter()
		{
			double sum = 0.0;
			for(int i = 0; i < g.length - 1; ++i)
				sum += g[i].dist(g[i+1]);
			return sum;
		}
		
		double area() 		//clockwise/anti-clockwise check, for convex/concave polygons
		{
			double area = 0.0;
			for(int i = 0; i < g.length - 1; ++i)
				area += g[i].x * g[i+1].y - g[i].y * g[i+1].x;
			return Math.abs(area) / 2.0;			//negative value in case of clockwise
		}

	
		
		boolean inside(Point p)	//for convex/concave polygons - winding number algorithm 
		{
			double sum = 0.0;
			for(int i = 0; i < g.length - 1; ++i)
			{
				double angle = Point.angle(g[i], p, g[i+1]);
				if((Math.abs(angle) < EPS || Math.abs(angle - Math.PI) < EPS) && p.between(g[i], g[i+1]))
					return true;
				if(Point.ccw(p, g[i], g[i+1]))
					sum += angle;
				else
					sum -= angle;
			}

			return Math.abs(2 * Math.PI - Math.abs(sum)) < EPS;		//abs makes it work for clockwise
		}
		/*
		 * Another way if the polygon is convex
		 * 1. Triangulate the poylgon through p
		 * 2. Check if sum areas == poygon area
		 * 3. Handle empty polygon
		 */
		
		

	
		Point centroid()		//center of mass
		{
			double cx = 0.0, cy = 0.0;
			for(int i = 0; i < g.length - 1; i++)
			{
				double x1 = g[i].x, y1 = g[i].y;
				double x2 = g[i+1].x, y2 = g[i+1].y;

				double f = x1 * y2 - x2 * y1;
				cx += (x1 + x2) * f;
				cy += (y1 + y2) * f;
			}
			double area = area();		//remove abs
			cx /= 6.0 * area;
			cy /= 6.0 * area;
			return new Point(cx, cy);
		}
	}
  
   static class LineSegment {

		Point p, q;
		
		LineSegment(Point a, Point b) { p = a; q = b; }
		

		boolean intersect(LineSegment ls)
		{
			Line l1 = new Line(p, q), l2 = new Line(ls.p, ls.q);
			if(l1.parallel(l2))
			{
				if(l1.same(l2))
					return p.between(ls.p, ls.q) || q.between(ls.p, ls.q) || ls.p.between(p, q) || ls.q.between(p, q);
				return false;
			}
			Point c = l1.intersect(l2);
			return c.between(p, q) && c.between(ls.p, ls.q);
		}

	}
  
   static class Rectangle {

		static final double EPS = 1e-9;
		
		Point ll, ur;

		Rectangle(Point a, Point b) { ll = a; ur = b; }

		double area() { return (ur.x - ll.x) * (ur.y - ll.y); }

		boolean contains(Point p)
		{
			return p.x <= ur.x + EPS && p.x + EPS >= ll.x && p.y <= ur.y + EPS && p.y + EPS >= ll.y;
		}

		Rectangle intersect(Rectangle r)
		{
			Point ll = new Point(Math.max(this.ll.x, r.ll.x), Math.max(this.ll.y, r.ll.y));
			Point ur = new Point(Math.min(this.ur.x, r.ur.x), Math.min(this.ur.y, r.ur.y));
			if(Math.abs(ur.x - ll.x) > EPS && Math.abs(ur.y - ll.y) > EPS && this.contains(ll) && this.contains(ur) && r.contains(ll) && r.contains(ur))
				return new Rectangle(ll, ur);
			return null;
		}

	}
   static class Line {

		static final double INF = 1e9, EPS = 1e-9;
		
		double a, b, c;
		
		Line(Point p, Point q)
		{
			if(Math.abs(p.x - q.x) < EPS) {	a = 1; b = 0; c = -p.x;	}
			else
			{
				a = (p.y - q.y) / (q.x - p.x);
				b = 1.0;
				c = -(a * p.x + p.y);
			}
						
		}
		
		Line(Point p, double m) { a = -m; b = 1; c =  -(a * p.x + p.y); } 
		
		boolean parallel(Line l) { return Math.abs(a - l.a) < EPS && Math.abs(b - l.b) < EPS; }
		
		boolean same(Line l) { return parallel(l) && Math.abs(c - l.c) < EPS; }
		
		Point intersect(Line l)
		{
			if(parallel(l))
				return null;
			double x = (b * l.c - c * l.b) / (a * l.b - b * l.a);
			double y;
			if(Math.abs(b) < EPS)
				 y = -l.a * x - l.c;
			else
				y = -a * x - c;
			
			return new Point(x, y);
		}
		
		Point closestPoint(Point p)
		{
			if(Math.abs(b) < EPS) return new Point(-c, p.y);
			if(Math.abs(a) < EPS) return new Point(p.x, -c);
			return intersect(new Line(p, 1 / a));
		}
				
	}

   public static class Vector {

		double x, y; 

		Vector(double a, double b) { x = a; y = b; }

		Vector(Point a, Point b) { this(b.x - a.x, b.y - a.y); }

		Vector scale(double s) { return new Vector(x * s, y * s); }              //s is a non-negative value

		double dot(Vector v) { return (x * v.x + y * v.y); }

		double cross(Vector v) { return x * v.y - y * v.x; }

		double norm2() { return x * x + y * y; }

		Vector reverse() { return new Vector(-x, -y); }

		Vector normalize() 
		{ 
			double d = Math.sqrt(norm2());
			return scale(1 / d);
		}		
	}
   
   static class Point implements Comparable<Point>{

		static final double EPS = 1e-9;

		double x, y;                  

		Point(double a, double b) { x = a; y = b; }  
		
		public int compareTo(Point p)
		{
			if(Math.abs(x - p.x) > EPS) return x > p.x ? 1 : -1;
			if(Math.abs(y - p.y) > EPS) return y > p.y ? 1 : -1;
			return 0;
		}
		static double angle(Point a, Point o, Point b)  // angle AOB
		{
			Vector oa = new Vector(o, a), ob = new Vector(o, b);
			return Math.acos(oa.dot(ob) / Math.sqrt(oa.norm2() * ob.norm2()));
		}
		static boolean ccw(Point p, Point q, Point r)
		{
			return new Vector(p, q).cross(new Vector(p, r)) > 0;
		}
		
		public double dist(Point p) { return Math.sqrt(sq(x - p.x) + sq(y - p.y)); }
		
		static double sq(double x) { return x * x; }
		
		Point rotate(double angle)
		{
			double c = Math.cos(angle), s = Math.sin(angle);
			return new Point(x * c - y * s, x * s + y * c);
		}
		// for integer points and rotation by 90 (counterclockwise) : swap x and y, negate x
		
	
		
		boolean between(Point p, Point q)
		{
			return x < Math.max(p.x, q.x) + EPS && x + EPS > Math.min(p.x, q.x)
					&& y < Math.max(p.y, q.y) + EPS && y + EPS > Math.min(p.y, q.y);
		}
		
		//returns true if it is on the line defined by a and b
	
		//returns true if it is on the ray whose start point is a and passes through b
		// Another way: find closest point and calculate the distance between it and p
	}
  
	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public Scanner(String file) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(file));
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public long nextlong() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder(""0"");
			long res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder(""0"");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

	}
}
",1,CorCod,813,813
"import java.util.*;import java.lang.*;import java.io.*;
public class Codechef
{   static PrintWriter out=new PrintWriter(System.out);
	static FastScanner in = new FastScanner(System.in);
     static class FastScanner {BufferedReader br;StringTokenizer stok;FastScanner(InputStream is) {br = new BufferedReader(new InputStreamReader(is));}
        String next() throws IOException {while (stok == null || !stok.hasMoreTokens()) {String s = br.readLine();if (s == null) {return null;}
                stok = new StringTokenizer(s);}return stok.nextToken();}
        int ni() throws IOException {    return Integer.parseInt(next());}
        long nl() throws IOException {return Long.parseLong(next());}
        double nd() throws IOException {return Double.parseDouble(next());}
        char nc() throws IOException {return (char) (br.read());}
        String ns() throws IOException {return br.readLine();}
        int[] nia(int n) throws IOException{int a[] = new int[n];for (int i = 0; i < n; i++)a[i] = ni();return a;}
        long[] nla(int n) throws IOException {
            long a[] = new long[n];for (int i = 0; i < n; i++)a[i] = nl();return a;}
        double[] nda(int n)throws IOException {double a[] = new double[n];for (int i = 0; i < n; i++)        a[i] = nd();    return a;}
        int [][] imat(int n,int m) throws IOException
        {   int mat[][]=new int[n][m];for(int i=0;i<n;i++){   for(int j=0;j<m;j++)mat[i][j]=ni();}return mat;}
    }
        
    ///MAIN METHOD
    
    
    
    
	static long mod=Long.MAX_VALUE;
	public static void main (String[] args) throws java.lang.Exception
	{   int i,j;
	    HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();
		/*  if(hm.containsKey(z))
		        hm.put(z,hm.get(z)+1);
		    else
		        hm.put(z,1);
		 */       
        ArrayList<Integer> arr=new ArrayList<Integer>();
        HashSet<Integer> set=new HashSet<Integer>();
        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();
        /*  int n = in.ni();
            int m = in.ni();
            String s=in.ns();
            int a[]=in.nia(n);
            int b[][]=in.im(n,m);
            pia(a);
		    pimat(b);
            sort(a,0,a.length-1);
        */
        long n=in.nl();
        long v=in.nl();
        long temp=n-1;
        long ans=0;
          
        ans+=Math.min(v,temp);
        temp-=v;
	    
	    if(temp>0)
            ans+=((temp+1)*(temp+2))/(long)2-1;
        
        
        out.println(ans);
        out.close();
	}
	
	
	
	
	
	static long gcd(long a,long b)
	{   if(b==0)
	        return a;
	    return gcd(b,a%b);    
	}
	static long exponent(long a,long n)
	{   long ans=1;
	    while(n!=0)
	    {   if(n%2==1)
	            ans=(ans*a)%mod;
	       a=(a*a)%mod;
	       n=n>>1;
	    }
	    return ans;
	}
	static int binarySearch(int a[], int item, int low, int high) 
    {   if (high <= low) 
            return (item > a[low])?  (low + 1): low; 
        int mid = (low + high)/2; 
        if(item == a[mid]) 
            return mid+1; 
        if(item > a[mid]) 
            return binarySearch(a, item, mid+1, high); 
        return binarySearch(a, item, low, mid-1); 
    } 
   static void merge(int arr[], int l, int m, int r) 
    {   int n1 = m - l + 1; int n2 = r - m; int L[] = new int [n1]; int R[] = new int [n2]; 
        
        for (int i=0; i<n1; ++i) L[i] = arr[l + i]; for (int j=0; j<n2; ++j) R[j] = arr[m + 1+ j]; int i = 0, j = 0; int k = l; 
        while (i < n1 && j < n2) {   if (L[i] <= R[j]) {   arr[k] = L[i]; i++; } else{   arr[k] = R[j]; j++; } k++; } while (i < n1){   arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j];   j++;     k++; } 
    } 
    static void Sort(int arr[], int l, int r) 
    {    if (l < r) {   int m = (l+r)/2; Sort(arr, l, m); Sort(arr , m+1, r); merge(arr, l, m, r); } } 
    
    static void sort(int a[])
    {Sort(a,0,a.length-1);}

}",1,CorCod,814,814
"import java.util.*;

public class A912 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		Scanner scan = new Scanner(System.in);
		
		int A = scan.nextInt();
		int B = scan.nextInt();
		long x = scan.nextInt();
		long y = scan.nextInt();
		long z = scan.nextInt();
		
		long requiredA = x * 2 + y;
		long requiredB = y + z * 3;
		
		long neededA = Math.max(0, requiredA - A);
		long neededB = Math.max(0, requiredB - B);
		System.out.print(neededA + neededB);
	}

}
",1,CorCod,818,818
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

public class CodeForces
{
	public static void main(String[] args)
	{
		Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

		System.out.println(input.nextInt() / 2 + 1);
	}
}",1,CorCod,848,848
"import java.io.BufferedReader;
import java.io.InputStreamReader;
public class TestClass1 {


    public static void main(String[] args) throws  Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s[] = br.readLine().split("" "");

        long A,B,y,g,b;
        A= Long.parseLong(s[0]);
        B= Long.parseLong(s[1]);
        s=br.readLine().split("" "");

        y = Long.parseLong(s[0]);
        g = Long.parseLong(s[1]);
        b = Long.parseLong(s[2]);

long ans=0;
        if(A-2*y-g < 0){
            ans+=Math.abs(A-2*y-g);
        }
        
        if(B-g-3*b < 0){
            ans+=Math.abs(B-g-3*b);
        }
        System.out.println(ans);



    }
}
",1,CorCod,859,859
"
import java.io.*;
import java.util.*;

public class IntegerSequenceDividing {
	static PrintWriter pw = new PrintWriter(System.out);
	public static void main(String[] args) throws IOException{
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		if(n%2==0)
		{
			n=n/2;
			if(n%2==0)
				System.out.println(0);
			else
				System.out.println(1);
		}else
		{
			n++;
			n=n/2;
			if(n%2==0)
				System.out.println(0);
			else
				System.out.println(1);
		}
	}
	static class Scanner {
		StringTokenizer st;
		BufferedReader br;
 
		public Scanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}
 
		public Scanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}
 
		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}
 
		public String nextLine() throws IOException {
			return br.readLine();
		}
 
		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}
 
		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}
 
		public char nextChar() throws IOException {
			return next().charAt(0);
		}
 
		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}
 
		public boolean ready() throws IOException {
			return br.ready();
		}
 
		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
}
",1,CorCod,866,866
"
import java.util.*;
import java.io.*;
import java.math.*;
public class loser
{
    static class InputReader {
        public BufferedReader br;
        public StringTokenizer token;
        public InputReader(InputStream stream)
        {
            br=new BufferedReader(new InputStreamReader(stream),32768);
            token=null;
        }

        public String next()
        {
            while(token==null || !token.hasMoreTokens())
            {
                try
                {
                    token=new StringTokenizer(br.readLine());
                }
                catch(IOException e)
                {
                    throw new RuntimeException(e);
                }
            }
            return token.nextToken();
        }

        public int nextInt()
        {
            return Integer.parseInt(next());
        }

        public long nextLong()
        {
            return Long.parseLong(next());
        }
    }
    static class card{
        long a;
        int i;
        public card(long a,int i)
        {
            this.a=a;
            this.i=i;
        }
    }
    static class sort implements Comparator<pair>
    {
        public int compare(pair o1,pair o2)
        {
            if(o1.a!=o2.a)
                return (int)(o1.a-o2.a);
            else
                return (int)(o1.b-o2.b);
        }
    }
    static void shuffle(long a[])
    {
        List<Long> l=new ArrayList<>();
        for(int i=0;i<a.length;i++)
            l.add(a[i]);
        Collections.shuffle(l);
        for(int i=0;i<a.length;i++)
            a[i]=l.get(i);
    }

    /*static long gcd(long a,long b)
    {
    if(b==0)
    return a;
    else
    return gcd(b,a%b);
    }*/
    /*static boolean valid(int i,int j)
    {
    if(i<4 && i>=0 && j<4 && j>=0)
    return true;
    else
    return false;
    }*/
    static class pair{
        int a,b;
        public pair(int a,int b)
        {
            this.a=a;
            this.b=b;
        }
    }
    public  static void main(String[] args) 
    {
        InputReader sc=new InputReader(System.in);
        int k=sc.nextInt();
        int n=sc.nextInt();
        int s=sc.nextInt();
        int p=sc.nextInt();
        long d=(long)Math.ceil((double)n/s);
        if(d==0)
        d=1;
        d=k*d;
        long ans=(long)Math.ceil((double)d/p);
        System.out.println(ans);
    }
}",1,CorCod,872,872
"
// Java program to demonstrate working of 
// an algorithm that finds an element in an 
// array of infinite size 

class
Test 
{ 

// Simple binary search algorithm 

static
int
binarySearch(
int
arr[], 
int
l, 
int
r, 
int
x) 

{ 

if
(r>=l) 

{ 

int
mid = l + (r - l)/
2
; 

if
(arr[mid] == x) 

return
mid; 

if
(arr[mid] > x) 

return
binarySearch(arr, l, mid-
1
, x); 

return
binarySearch(arr, mid+
1
, r, x); 

} 

return
-
1
; 

} 


// Method takes an infinite size array and a key to be 

// searched and returns its position if found else -1. 

// We don't know size of arr[] and we can assume size to be 

// infinite in this function. 

// NOTE THAT THIS FUNCTION ASSUMES arr[] TO BE OF INFINITE SIZE 

// THEREFORE, THERE IS NO INDEX OUT OF BOUND CHECKING 

static
int
findPos(
int
arr[],
int
key) 

{ 

int
l = 
0
, h = 
1
; 

int
val = arr[
0
]; 


// Find h to do binary search 

while
(val < key) 

{ 

l = h; 
// store previous high 

//check that 2*h doesn't exceeds array 

//length to prevent ArrayOutOfBoundException 

if
(
2
*h < arr.length-
1
) 

h = 
2
*h; 

else

h = arr.length-
1
; 


val = arr[h]; 
// update new val 

} 


// at this point we have updated low 

// and high indices, thus use binary 

// search between them 

return
binarySearch(arr, l, h, key); 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

int
arr[] = 
new
int
[]{
3
, 
5
, 
7
, 
9
, 
10
, 
90
, 

100
, 
130
, 
140
, 
160
, 
170
}; 

int
ans = findPos(arr,
10
); 


if
(ans==-
1
) 

System.out.println(
""Element not found""
); 

else

System.out.println(
""Element found at index ""
+ ans); 

} 
} ",2,CorCod,899,899
"import java.util.*;
import java.lang.*;
public class Main {
    static long m = 1000000007;
    static long powmod(long x, long y, long p)
    {
        // Initialize result
        long res = 1;

        // Update x if it is more
        // than or equal to p
        x = x % p;

        while (y > 0)
        {
            // If y is odd, multiply x
            // with result
            if((y & 1)==1)
                res = (res * x) % p;

            // y must be even now
            // y = y / 2
            y = y >> 1;
            x = (x * x) % p;
        }
        return res;
    }

    static long mulmod(long a, long b, long mod){
        long res=0;
        a = a % mod;
        while (b > 0)
        {
            // If b is odd, add 'a' to result
            if (b % 2 == 1)
                res = (res + a) % mod;

            // Multiply 'a' with 2
            a = (a * 2) % mod;

            // Divide b by 2
            b /= 2;
        }

        // Return result
        return res % mod;
    }

    public static void main(String args[] ) throws Exception {
        Scanner sc = new Scanner(System.in);
        long x = sc.nextLong();
        long k = sc.nextLong();
        if(x>0) {
            long d= powmod(2,k,m);
            long ans= mulmod(d,2,m)%m;
            ans= mulmod(ans,x,m)%m;
            ans++;
            ans%=m;
            ans= (ans-d+m)%m;
            System.out.println(ans);
        }
        else
            System.out.println(0);
    }
}",2,CorCod,903,903
"
// Java program to reverse the number 
// using a stack 
import
java.util.Stack; 

public
class
GFG 
{ 

// Stack to maintain order of digits 

static
Stack<Integer> st= 
new
Stack<>(); 


// Function to push digits into stack 

static
void
push_digits(
int
number) 

{ 

while
(number != 
0
) 

{ 

st.push(number % 
10
); 

number = number / 
10
; 

} 

} 


// Function to reverse the number 

static
int
reverse_number(
int
number) 

{ 

// Function call to push number's 

// digits to stack 

push_digits(number); 

int
reverse = 
0
; 

int
i = 
1
; 


// Popping the digits and forming 

// the reversed number 

while
(!st.isEmpty()) 

{ 

reverse = reverse + (st.peek() * i); 

st.pop(); 

i = i * 
10
; 

} 


// Return the reversed number formed 

return
reverse; 

} 


// Driver program to test above function 

public
static
void
main(String[] args) 

{ 

int
number = 
39997
; 

System.out.println(reverse_number(number)); 

} 
} 
// This code is contributed by Sumit Ghosh ",2,CorCod,906,906
"package com.rampatra.searching;

/**
 * Created by IntelliJ IDEA.
 *
 * @author rampatra
 * @version 9/1/15
 */
public class BinarySearch {

    /**
     * Searches an element {@param n} in a sorted array {@param a}
     * and returns its index in O(log n) time. The Index may not
     * correspond to the first occurrence of the element.
     *
     * @param a sorted array to be searched
     * @param n number to be searched in the array
     * @return index of {@param n} or {@code -1} if not present
     */
    private static int binarySearch(int[] a, int n) {
        return binarySearch(a, n, 0, a.length - 1);
    }

    public static int binarySearch(int[] a, int n, int low, int high) {

        if (low <= high) {
            int mid = (low + high) / 2; // to prevent overflow you can instead do: mid = low + (high - low) / 2

            if (n == a[mid]) {
                return mid;
            } else if (n < a[mid]) {
                return binarySearch(a, n, 0, mid - 1);
            } else {
                return binarySearch(a, n, mid + 1, high);
            }
        } else {
            return -1;
        }
    }

    /**
     * Non-recursive version of binary search.
     *
     * @param a sorted array to be searched
     * @param n number to be searched in the array
     * @return index of {@param n} or {@code -1} if not present
     */
    private static int binarySearchNonRecursive(int[] a, int n) {
        int low = 0, high = a.length, mid;
        while (low <= high) {
            mid = (low + high) / 2; // to prevent overflow you can instead do: mid = low + (high - low) / 2
            if (n == a[mid]) {
                return mid;
            } else if (n < a[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }

    /**
     * Driver for testing.
     *
     * @param a
     */
    public static void main(String[] args) {
        System.out.println(binarySearch(new int[]{0, 2}, 2));
        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 2));
        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 3));
        System.out.println(binarySearch(new int[]{0, 2}, 0));
        System.out.println(binarySearch(new int[]{0, 1, 2, 2, 2, 3, 3}, 2)); // doesn't return index of first occurrence
        System.out.println(""---------"");
        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 2));
        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 2));
        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 3));
        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 0));
        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));
    }
}",2,CorCod,910,910
"import java.util.*;
import java.io.*;
public class code{
    public static void main(String[] args) throws IOException{
        Scanner sc = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int ok,ok2;
        int va,vb;
        va = 0;
        vb = 0;
        out.println(""? ""+va+"" ""+vb);
        out.flush();
        ok = sc.nextInt();
        for(int i=29;i>=0;i--){
            if(ok==0){
                va += (1<<i);
                out.println(""? ""+va+"" ""+vb);
                out.flush();
                ok2 = sc.nextInt();
                if(ok2==1){
                    va -= (1<<i);
                }else{
                    vb += (1<<i);
                }
            }else{
                va += (1<<i);
                vb += (1<<i);
                out.println(""? ""+va+"" ""+vb);
                out.flush();
                ok2 = sc.nextInt();
                if(ok==ok2){
                    vb -= (1<<i);
                    out.println(""? ""+va+"" ""+vb);
                    out.flush();
                    ok2 = sc.nextInt();
                    if(ok2==1){
                        va -= (1<<i);
                    }else{
                        vb += (1<<i);
                    }
                }else{
                    if(ok==1){
                        vb -= (1<<i);
                        out.println(""? ""+va+"" ""+vb);
                        out.flush();
                        ok = sc.nextInt();
                    }
                    else {
                        va -= (1<<i);
                        out.println(""? ""+va+"" ""+vb);
                        out.flush();
                        ok = sc.nextInt();
                    }
                }
            }
        }
        out.println(""! ""+va+"" ""+vb);
        out.flush();
    }
}",2,CorCod,916,916
"package com.interview.binarysearch;

/**
 * Regular binary search
 */
public class BinarySearch {

    public int search(final int input[], int search) {
        int low = 0;
        int high = input.length - 1;
        int mid;
        while (low <= high) {
            mid = low + ((high - low) / 2);
            if (input[mid] == search) {
                return mid;
            } else if (input[mid] < search) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1;
    }

    public static void main(String args[]) {
        BinarySearch bSearch = new BinarySearch();
        final int arr1[] = {1, 2, 4, 5, 7, 8};
        System.out.println(bSearch.search(arr1, -1));
        System.out.println(bSearch.search(arr1, 1));
        System.out.println(bSearch.search(arr1, 8));
        System.out.println(bSearch.search(arr1, 2));
    }
}",2,CorCod,927,927
